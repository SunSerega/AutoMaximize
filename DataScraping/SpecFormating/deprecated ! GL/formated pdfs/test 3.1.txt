R
The OpenGL Graphics System:
A Specification
(Version 3.1 - May 28, 2009)
Mark Segal
Kurt Akeley
Editor (version 1.1): Chris Frazier
Editor (versions 1.2-3.1): Jon Leech
Editor (version 2.0): Pat BrownCopyrightc 2006-2009 The Khronos Group Inc. All Rights Reserved.
This speci?cation is protected by copyright laws and contains material proprietary
to the Khronos Group, Inc. It or any components may not be reproduced, repub-
lished, distributed, transmitted, displayed, broadcast or otherwise exploited in any
manner without the express prior written permission of Khronos Group. You may
use this speci?cation for implementing the functionality therein, without altering or
removing any trademark, copyright or other notice from the speci?cation, but the
receipt or possession of this speci?cation does not convey any rights to reproduce,
disclose, or distribute its contents, or to manufacture, use, or sell anything that it
may describe, in whole or in part.
Khronos Group grants express permission to any current Promoter, Contributor
or Adopter member of Khronos to copy and redistribute UNMODIFIED versions
of this speci?cation in any fashion, provided that NO CHARGE is made for the
speci?cation and the latest available update of the speci?cation for any version
of the API is used whenever possible. Such distributed speci?cation may be re-
formatted AS LONG AS the contents of the speci?cation are not changed in any
way. The speci?cation may be incorporated into a product that is sold as long as
such product includes signi?cant independent work developed by the seller. A link
to the current version of this speci?cation on the Khronos Group web-site should
be included whenever possible with speci?cation distributions.
Khronos Group makes no, and expressly disclaims any, representations or war-
ranties, express or implied, regarding this speci?cation, including, without limita-
tion, any implied warranties of merchantability or ?tness for a particular purpose
or non-infringement of any intellectual property. Khronos Group makes no, and
expressly disclaims any, warranties, express or implied, regarding the correctness,
accuracy, completeness, timeliness, and reliability of the speci?cation. Under no
circumstances will the Khronos Group, or any of its Promoters, Contributors or
Members or their respective partners, of?cers, directors, employees, agents or rep-
resentatives be liable for any damages, whether direct, indirect, special or conse-
quential damages for lost revenues, lost pro?ts, or otherwise, arising from or in
connection with these materials.
Khronos is a trademark of The Khronos Group Inc. OpenGL is a registered trade-
mark, and OpenGL ES is a trademark, of Silicon Graphics, Inc.Contents
1 Introduction 1
1.1 What is the OpenGL Graphics System? . . . . . . . . . . . . . . 1
1.2 Programmer’s View of OpenGL . . . . . . . . . . . . . . . . . . 1
1.3 Implementor’s View of OpenGL . . . . . . . . . . . . . . . . . . 2
1.4 Our View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.5 The Deprecation Model . . . . . . . . . . . . . . . . . . . . . . . 3
1.6 Companion Documents . . . . . . . . . . . . . . . . . . . . . . . 3
1.6.1 OpenGL Shading Language . . . . . . . . . . . . . . . . 3
1.6.2 Window System Bindings . . . . . . . . . . . . . . . . . 3
2 OpenGL Operation 5
2.1 OpenGL Fundamentals . . . . . . . . . . . . . . . . . . . . . . . 5
2.1.1 Floating-Point Computation . . . . . . . . . . . . . . . . 7
2.1.2 16-Bit Floating-Point Numbers . . . . . . . . . . . . . . 8
2.1.3 Unsigned 11-Bit Floating-Point Numbers . . . . . . . . . 8
2.1.4 Unsigned 10-Bit Floating-Point Numbers . . . . . . . . . 9
2.1.5 Fixed-Point Data Conversions . . . . . . . . . . . . . . . 10
2.2 GL State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.2.1 Shared Object State . . . . . . . . . . . . . . . . . . . . . 13
2.3 GL Command Syntax . . . . . . . . . . . . . . . . . . . . . . . . 13
2.4 Basic GL Operation . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.5 GL Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
2.6 Primitives and Vertices . . . . . . . . . . . . . . . . . . . . . . . 19
2.6.1 Primitive Types . . . . . . . . . . . . . . . . . . . . . . . 21
2.7 Vertex Specification . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.8 Vertex Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
2.8.1 Transferring Array Elements . . . . . . . . . . . . . . . . 26
2.8.2 Drawing Commands . . . . . . . . . . . . . . . . . . . . 27
2.9 Buffer Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
iCONTENTS ii
2.9.1 Mapping and Unmapping Buffer Data . . . . . . . . . . . 34
2.9.2 Effects of Accessing Outside Buffer Bounds . . . . . . . 38
2.9.3 Copying Between Buffers . . . . . . . . . . . . . . . . . 38
2.9.4 Vertex Arrays in Buffer Objects . . . . . . . . . . . . . . 39
2.9.5 Array Indices in Buffer Objects . . . . . . . . . . . . . . 40
2.9.6 Buffer Object State . . . . . . . . . . . . . . . . . . . . . 40
2.10 Vertex Array Objects . . . . . . . . . . . . . . . . . . . . . . . . 40
2.11 Vertex Shaders . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
2.11.1 Shader Objects . . . . . . . . . . . . . . . . . . . . . . . 42
2.11.2 Program Objects . . . . . . . . . . . . . . . . . . . . . . 44
2.11.3 Vertex Attributes . . . . . . . . . . . . . . . . . . . . . . 46
2.11.4 Uniform Variables . . . . . . . . . . . . . . . . . . . . . 49
2.11.5 Samplers . . . . . . . . . . . . . . . . . . . . . . . . . . 64
2.11.6 Varying Variables . . . . . . . . . . . . . . . . . . . . . . 65
2.11.7 Shader Execution . . . . . . . . . . . . . . . . . . . . . . 67
2.11.8 Required State . . . . . . . . . . . . . . . . . . . . . . . 72
2.12 Coordinate Transformations . . . . . . . . . . . . . . . . . . . . 73
2.12.1 Controlling the Viewport . . . . . . . . . . . . . . . . . . 74
2.13 Asynchronous Queries . . . . . . . . . . . . . . . . . . . . . . . 75
2.14 Conditional Rendering . . . . . . . . . . . . . . . . . . . . . . . 77
2.15 Transform Feedback . . . . . . . . . . . . . . . . . . . . . . . . 78
2.16 Primitive Queries . . . . . . . . . . . . . . . . . . . . . . . . . . 81
2.17 Primitive Clipping . . . . . . . . . . . . . . . . . . . . . . . . . . 81
2.17.1 Clipping Shader Varying Outputs . . . . . . . . . . . . . 83
3 Rasterization 84
3.1 Discarding Primitives Before Rasterization . . . . . . . . . . . . 85
3.2 Invariance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
3.3 Antialiasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
3.3.1 Multisampling . . . . . . . . . . . . . . . . . . . . . . . 87
3.4 Points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88
3.4.1 Basic Point Rasterization . . . . . . . . . . . . . . . . . . 89
3.4.2 Point Rasterization State . . . . . . . . . . . . . . . . . . 90
3.4.3 Point Multisample Rasterization . . . . . . . . . . . . . . 90
3.5 Line Segments . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
3.5.1 Basic Line Segment Rasterization . . . . . . . . . . . . . 91
3.5.2 Other Line Segment Features . . . . . . . . . . . . . . . . 93
3.5.3 Line Rasterization State . . . . . . . . . . . . . . . . . . 94
3.5.4 Line Multisample Rasterization . . . . . . . . . . . . . . 95
3.6 Polygons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
OpenGL 3.1 - May 28, 2009CONTENTS iii
3.6.1 Basic Polygon Rasterization . . . . . . . . . . . . . . . . 95
3.6.2 Antialiasing . . . . . . . . . . . . . . . . . . . . . . . . . 98
3.6.3 Options Controlling Polygon Rasterization . . . . . . . . 98
3.6.4 Depth Offset . . . . . . . . . . . . . . . . . . . . . . . . 99
3.6.5 Polygon Multisample Rasterization . . . . . . . . . . . . 100
3.6.6 Polygon Rasterization State . . . . . . . . . . . . . . . . 100
3.7 Pixel Rectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
3.7.1 Pixel Storage Modes and Pixel Buffer Objects . . . . . . . 101
3.7.2 Transfer of Pixel Rectangles . . . . . . . . . . . . . . . . 102
3.8 Texturing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
3.8.1 Texture Image Specification . . . . . . . . . . . . . . . . 115
3.8.2 Alternate Texture Image Specification Commands . . . . 127
3.8.3 Compressed Texture Images . . . . . . . . . . . . . . . . 134
3.8.4 Buffer Textures . . . . . . . . . . . . . . . . . . . . . . . 138
3.8.5 Texture Parameters . . . . . . . . . . . . . . . . . . . . . 141
3.8.6 Depth Component Textures . . . . . . . . . . . . . . . . 141
3.8.7 Cube Map Texture Selection . . . . . . . . . . . . . . . . 143
3.8.8 Texture Minification . . . . . . . . . . . . . . . . . . . . 144
3.8.9 Texture Magnification . . . . . . . . . . . . . . . . . . . 152
3.8.10 Combined Depth/Stencil Textures . . . . . . . . . . . . . 153
3.8.11 Texture Completeness . . . . . . . . . . . . . . . . . . . 153
3.8.12 Texture State and Proxy State . . . . . . . . . . . . . . . 154
3.8.13 Texture Objects . . . . . . . . . . . . . . . . . . . . . . . 156
3.8.14 Texture Comparison Modes . . . . . . . . . . . . . . . . 157
3.8.15 sRGB Texture Color Conversion . . . . . . . . . . . . . . 159
3.8.16 Shared Exponent Texture Color Conversion . . . . . . . . 159
3.9 Fragment Shaders . . . . . . . . . . . . . . . . . . . . . . . . . . 160
3.9.1 Shader Variables . . . . . . . . . . . . . . . . . . . . . . 160
3.9.2 Shader Execution . . . . . . . . . . . . . . . . . . . . . . 161
3.10 Antialiasing Application . . . . . . . . . . . . . . . . . . . . . . 165
3.11 Multisample Point Fade . . . . . . . . . . . . . . . . . . . . . . . 165
4 Per-Fragment Operations and the Framebuffer 166
4.1 Per-Fragment Operations . . . . . . . . . . . . . . . . . . . . . . 167
4.1.1 Pixel Ownership Test . . . . . . . . . . . . . . . . . . . . 168
4.1.2 Scissor Test . . . . . . . . . . . . . . . . . . . . . . . . . 168
4.1.3 Multisample Fragment Operations . . . . . . . . . . . . . 169
4.1.4 Stencil Test . . . . . . . . . . . . . . . . . . . . . . . . . 170
4.1.5 Depth Buffer Test . . . . . . . . . . . . . . . . . . . . . . 172
4.1.6 Occlusion Queries . . . . . . . . . . . . . . . . . . . . . 173
OpenGL 3.1 - May 28, 2009CONTENTS iv
4.1.7 Blending . . . . . . . . . . . . . . . . . . . . . . . . . . 173
4.1.8 sRGB Conversion . . . . . . . . . . . . . . . . . . . . . 178
4.1.9 Dithering . . . . . . . . . . . . . . . . . . . . . . . . . . 178
4.1.10 Logical Operation . . . . . . . . . . . . . . . . . . . . . 179
4.1.11 Additional Multisample Fragment Operations . . . . . . . 180
4.2 Whole Framebuffer Operations . . . . . . . . . . . . . . . . . . . 181
4.2.1 Selecting a Buffer for Writing . . . . . . . . . . . . . . . 181
4.2.2 Fine Control of Buffer Updates . . . . . . . . . . . . . . 185
4.2.3 Clearing the Buffers . . . . . . . . . . . . . . . . . . . . 187
4.3 Reading and Copying Pixels . . . . . . . . . . . . . . . . . . . . 189
4.3.1 Reading Pixels . . . . . . . . . . . . . . . . . . . . . . . 189
4.3.2 Copying Pixels . . . . . . . . . . . . . . . . . . . . . . . 196
4.3.3 Pixel Draw/Read State . . . . . . . . . . . . . . . . . . . 198
4.4 Framebuffer Objects . . . . . . . . . . . . . . . . . . . . . . . . 199
4.4.1 Binding and Managing Framebuffer Objects . . . . . . . . 199
4.4.2 Attaching Images to Framebuffer Objects . . . . . . . . . 202
4.4.3 Feedback Loops Between Textures and the Framebuffer . 209
4.4.4 Framebuffer Completeness . . . . . . . . . . . . . . . . . 211
4.4.5 Effects of Framebuffer State on Framebuffer Dependent
Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
4.4.6 Mapping between Pixel and Element in Attached Image . 216
5 Special Functions 218
5.1 Flush and Finish . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
5.2 Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
6 State and State Requests 220
6.1 Querying GL State . . . . . . . . . . . . . . . . . . . . . . . . . 220
6.1.1 Simple Queries . . . . . . . . . . . . . . . . . . . . . . . 220
6.1.2 Data Conversions . . . . . . . . . . . . . . . . . . . . . . 221
6.1.3 Enumerated Queries . . . . . . . . . . . . . . . . . . . . 222
6.1.4 Texture Queries . . . . . . . . . . . . . . . . . . . . . . . 224
6.1.5 String Queries . . . . . . . . . . . . . . . . . . . . . . . 226
6.1.6 Asynchronous Queries . . . . . . . . . . . . . . . . . . . 227
6.1.7 Buffer Object Queries . . . . . . . . . . . . . . . . . . . 229
6.1.8 Vertex Array Object Queries . . . . . . . . . . . . . . . . 231
6.1.9 Shader and Program Queries . . . . . . . . . . . . . . . . 231
6.1.10 Framebuffer Object Queries . . . . . . . . . . . . . . . . 235
6.1.11 Renderbuffer Object Queries . . . . . . . . . . . . . . . . 238
6.2 State Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
OpenGL 3.1 - May 28, 2009CONTENTS v
A Invariance 280
A.1 Repeatability . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
A.2 Multi-pass Algorithms . . . . . . . . . . . . . . . . . . . . . . . 281
A.3 Invariance Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
A.4 What All This Means . . . . . . . . . . . . . . . . . . . . . . . . 282
B Corollaries 284
C Compressed Texture Image Formats 286
C.1 RGTC Compressed Texture Image Formats . . . . . . . . . . . . 286
C.1.1 FormatCOMPRESSED_RED_RGTC1 . . . . . . . . . . . . 287
C.1.2 FormatCOMPRESSED_SIGNED_RED_RGTC1 . . . . . . . 288
C.1.3 FormatCOMPRESSED_RG_RGTC2 . . . . . . . . . . . . . 288
C.1.4 FormatCOMPRESSED_SIGNED_RG_RGTC2 . . . . . . . . 289
D Shared Objects and Multiple Contexts 290
D.1 Object Deletion Behavior . . . . . . . . . . . . . . . . . . . . . . 290
D.2 Propagating State Changes . . . . . . . . . . . . . . . . . . . . . 291
D.2.1 De?nitions . . . . . . . . . . . . . . . . . . . . . . . . . 292
D.2.2 Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
E The Deprecation Model 294
E.1 Pro?les and Deprecated Features of OpenGL 3.0 . . . . . . . . . 294
F Version 3.0 and Before 300
F.1 New Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . 300
F.2 Deprecation Model . . . . . . . . . . . . . . . . . . . . . . . . . 301
F.3 Changed Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
F.4 Change Log . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302
F.5 Credits and Acknowledgements . . . . . . . . . . . . . . . . . . 304
G Version 3.1 307
G.1 New Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307
G.2 Deprecation Model . . . . . . . . . . . . . . . . . . . . . . . . . 308
G.3 Change Log . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
G.4 Credits and Acknowledgements . . . . . . . . . . . . . . . . . . 309
H Extension Registry, Header Files, and ARB Extensions 312
H.1 Extension Registry . . . . . . . . . . . . . . . . . . . . . . . . . 312
H.2 Header Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
H.3 ARB Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
OpenGL 3.1 - May 28, 2009CONTENTS vi
H.3.1 Naming Conventions . . . . . . . . . . . . . . . . . . . . 314
H.3.2 Promoting Extensions to Core Features . . . . . . . . . . 314
H.3.3 Multitexture . . . . . . . . . . . . . . . . . . . . . . . . . 314
H.3.4 Transpose Matrix . . . . . . . . . . . . . . . . . . . . . . 315
H.3.5 Multisample . . . . . . . . . . . . . . . . . . . . . . . . 315
H.3.6 Texture Add Environment Mode . . . . . . . . . . . . . . 315
H.3.7 Cube Map Textures . . . . . . . . . . . . . . . . . . . . . 315
H.3.8 Compressed Textures . . . . . . . . . . . . . . . . . . . . 315
H.3.9 Texture Border Clamp . . . . . . . . . . . . . . . . . . . 315
H.3.10 Point Parameters . . . . . . . . . . . . . . . . . . . . . . 315
H.3.11 Vertex Blend . . . . . . . . . . . . . . . . . . . . . . . . 315
H.3.12 Matrix Palette . . . . . . . . . . . . . . . . . . . . . . . . 316
H.3.13 Texture Combine Environment Mode . . . . . . . . . . . 316
H.3.14 Texture Crossbar Environment Mode . . . . . . . . . . . 316
H.3.15 Texture Dot3 Environment Mode . . . . . . . . . . . . . 316
H.3.16 Texture Mirrored Repeat . . . . . . . . . . . . . . . . . . 316
H.3.17 Depth Texture . . . . . . . . . . . . . . . . . . . . . . . . 316
H.3.18 Shadow . . . . . . . . . . . . . . . . . . . . . . . . . . . 316
H.3.19 Shadow Ambient . . . . . . . . . . . . . . . . . . . . . . 317
H.3.20 Window Raster Position . . . . . . . . . . . . . . . . . . 317
H.3.21 Low-Level Vertex Programming . . . . . . . . . . . . . . 317
H.3.22 Low-Level Fragment Programming . . . . . . . . . . . . 317
H.3.23 Buffer Objects . . . . . . . . . . . . . . . . . . . . . . . 317
H.3.24 Occlusion Queries . . . . . . . . . . . . . . . . . . . . . 317
H.3.25 Shader Objects . . . . . . . . . . . . . . . . . . . . . . . 318
H.3.26 High-Level Vertex Programming . . . . . . . . . . . . . . 318
H.3.27 High-Level Fragment Programming . . . . . . . . . . . . 318
H.3.28 OpenGL Shading Language . . . . . . . . . . . . . . . . 318
H.3.29 Non-Power-Of-Two Textures . . . . . . . . . . . . . . . . 318
H.3.30 Point Sprites . . . . . . . . . . . . . . . . . . . . . . . . 318
H.3.31 Fragment Program Shadow . . . . . . . . . . . . . . . . . 318
H.3.32 Multiple Render Targets . . . . . . . . . . . . . . . . . . 319
H.3.33 Rectangular Textures . . . . . . . . . . . . . . . . . . . . 319
H.3.34 Floating-Point Color Buffers . . . . . . . . . . . . . . . . 319
H.3.35 Half-Precision Floating Point . . . . . . . . . . . . . . . 319
H.3.36 Floating-Point Textures . . . . . . . . . . . . . . . . . . . 320
H.3.37 Pixel Buffer Objects . . . . . . . . . . . . . . . . . . . . 320
H.3.38 Floating-Point Depth Buffers . . . . . . . . . . . . . . . . 320
H.3.39 Instanced Rendering . . . . . . . . . . . . . . . . . . . . 320
H.3.40 Framebuffer Objects . . . . . . . . . . . . . . . . . . . . 320
OpenGL 3.1 - May 28, 2009CONTENTS vii
H.3.41 sRGB Framebuffers . . . . . . . . . . . . . . . . . . . . 321
H.3.42 Geometry Shaders . . . . . . . . . . . . . . . . . . . . . 321
H.3.43 Half-Precision Vertex Data . . . . . . . . . . . . . . . . . 321
H.3.44 Instanced Rendering . . . . . . . . . . . . . . . . . . . . 321
H.3.45 Flexible Buffer Mapping . . . . . . . . . . . . . . . . . . 321
H.3.46 Texture Buffer Objects . . . . . . . . . . . . . . . . . . . 322
H.3.47 RGTC Texture Compression Formats . . . . . . . . . . . 322
H.3.48 One- and Two-Component Texture Formats . . . . . . . . 322
H.3.49 Vertex Array Objects . . . . . . . . . . . . . . . . . . . . 322
H.3.50 Versioned Context Creation . . . . . . . . . . . . . . . . 322
H.3.51 Uniform Buffer Objects . . . . . . . . . . . . . . . . . . 322
H.3.52 Restoration of features removed from OpenGL 3.0 . . . . 323
H.3.53 Fast Buffer-to-Buffer Copies . . . . . . . . . . . . . . . . 323
H.3.54 Shader Texture Level of Detail Control . . . . . . . . . . 323
OpenGL 3.1 - May 28, 2009List of Figures
2.1 Block diagram of the GL. . . . . . . . . . . . . . . . . . . . . . . 15
2.2 Vertex processing and primitive assembly. . . . . . . . . . . . . . 19
2.3 Triangle strips, fans, and independent triangles. . . . . . . . . . . 22
3.1 Rasterization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
3.2 Visualization of Bresenham’s algorithm. . . . . . . . . . . . . . . 92
3.3 The region used in rasterizing an antialiased line segment. . . . . 94
3.4 Transfer of pixel rectangles. . . . . . . . . . . . . . . . . . . . . 102
3.5 Selecting a subimage from an image . . . . . . . . . . . . . . . . 107
3.6 A texture image and the coordinates used to access it. . . . . . . . 127
4.1 Per-fragment operations. . . . . . . . . . . . . . . . . . . . . . . 168
4.2 Operation of ReadPixels. . . . . . . . . . . . . . . . . . . . . . . 189
viiiList of Tables
2.1 GL command suf?xes . . . . . . . . . . . . . . . . . . . . . . . . 14
2.2 GL data types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
2.3 Summary of GL errors . . . . . . . . . . . . . . . . . . . . . . . 19
2.4 Vertex array sizes (values per vertex) and data types . . . . . . . . 25
2.5 Buffer object binding targets. . . . . . . . . . . . . . . . . . . . . 31
2.6 Buffer object parameters and their values. . . . . . . . . . . . . . 31
2.7 Buffer object initial state. . . . . . . . . . . . . . . . . . . . . . . 33
2.8 Buffer object state set by MapBufferRange. . . . . . . . . . . . 36
2.9 OpenGL Shading Language type tokens . . . . . . . . . . . . . . 56
2.10 Transform feedback modes . . . . . . . . . . . . . . . . . . . . . 78
3.1 PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . . 102
3.2 Pixel data types. . . . . . . . . . . . . . . . . . . . . . . . . . . . 105
3.3 Pixel data formats. . . . . . . . . . . . . . . . . . . . . . . . . . 106
3.4 Swap Bytes bit ordering. . . . . . . . . . . . . . . . . . . . . . . 106
3.5 Packed pixel formats. . . . . . . . . . . . . . . . . . . . . . . . . 108
3.6 UNSIGNED_BYTE formats. Bit numbers are indicated for each
component. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
3.7 UNSIGNED_SHORT formats . . . . . . . . . . . . . . . . . . . . . 110
3.8 UNSIGNED_INT formats . . . . . . . . . . . . . . . . . . . . . . 111
3.9 FLOAT_UNSIGNED_INT formats . . . . . . . . . . . . . . . . . . 112
3.10 Packed pixel ?eld assignments. . . . . . . . . . . . . . . . . . . . 113
3.11 Conversion from RGBA, depth, and stencil pixel components to
internal texture components. . . . . . . . . . . . . . . . . . . . . 117
3.12 Sized internal color formats. . . . . . . . . . . . . . . . . . . . . 122
3.13 Sized internal depth and stencil formats. . . . . . . . . . . . . . . 123
3.14 Generic and speci?c compressed internal formats. . . . . . . . . . 124
3.15 Internal formats for buffer textures . . . . . . . . . . . . . . . . . 140
3.16 Texture parameters and their values. . . . . . . . . . . . . . . . . 142
ixLISTOFTABLES x
3.17 Selection of cube map images. . . . . . . . . . . . . . . . . . . . 143
3.18 Texel location wrap mode application. . . . . . . . . . . . . . . . 147
3.19 Depth texture comparison functions. . . . . . . . . . . . . . . . . 158
3.20 Correspondence of ?ltered texture components to texture source
components. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
4.1 RGB and Alpha blend equations. . . . . . . . . . . . . . . . . . . 176
4.2 Blending functions. . . . . . . . . . . . . . . . . . . . . . . . . . 177
4.3 Arguments to LogicOp and their corresponding operations. . . . . 180
4.4 Buffer selection for the default framebuffer . . . . . . . . . . . . 183
4.5 Buffer selection for a framebuffer object . . . . . . . . . . . . . . 183
4.6 DrawBuffers buffer selection for the default framebuffer . . . . . 183
4.7 PixelStore parameters. . . . . . . . . . . . . . . . . . . . . . . . 191
4.8 ReadPixels index masks. . . . . . . . . . . . . . . . . . . . . . . 194
4.9 ReadPixels GL data types and reversed component conversion for-
mulas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
4.10 Correspondence of renderbuffer sized to base internal formats. . . 204
4.11 Framebuffer attachment points. . . . . . . . . . . . . . . . . . . . 206
5.1 Hint targets and descriptions . . . . . . . . . . . . . . . . . . . . 219
6.1 Texture, table, and ?lter return values. . . . . . . . . . . . . . . . 226
6.2 State Variable Types . . . . . . . . . . . . . . . . . . . . . . . . . 239
6.3 Vertex Array Object State (cont.) . . . . . . . . . . . . . . . . . . 240
6.4 Vertex Array Object State (cont.) . . . . . . . . . . . . . . . . . . 241
6.5 Vertex Array Data (not in Vertex Array objects) . . . . . . . . . . 242
6.6 Buffer Object State . . . . . . . . . . . . . . . . . . . . . . . . . 243
6.7 Transformation state . . . . . . . . . . . . . . . . . . . . . . . . 244
6.8 Coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
6.9 Rasterization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246
6.10 Rasterization (cont.) . . . . . . . . . . . . . . . . . . . . . . . . . 247
6.11 Multisampling . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
6.12 Textures (state per texture unit and binding point) . . . . . . . . . 249
6.13 Textures (state per texture object) . . . . . . . . . . . . . . . . . . 250
6.14 Textures (state per texture image) . . . . . . . . . . . . . . . . . . 251
6.15 Texture Environment and Generation . . . . . . . . . . . . . . . . 252
6.16 Pixel Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
6.17 Pixel Operations (cont.) . . . . . . . . . . . . . . . . . . . . . . . 254
6.18 Framebuffer Control . . . . . . . . . . . . . . . . . . . . . . . . 255
6.19 Framebuffer (state per target binding point) . . . . . . . . . . . . 256
OpenGL 3.1 - May 28, 2009LISTOFTABLES xi
6.20 Framebuffer (state per framebuffer object) . . . . . . . . . . . . . 257
6.21 Framebuffer (state per attachment point) . . . . . . . . . . . . . . 258
6.22 Renderbuffer (state per target and binding point) . . . . . . . . . . 259
6.23 Renderbuffer (state per renderbuffer object) . . . . . . . . . . . . 260
6.24 Pixels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261
6.25 Shader Object State . . . . . . . . . . . . . . . . . . . . . . . . . 262
6.26 Program Object State . . . . . . . . . . . . . . . . . . . . . . . . 263
6.27 Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 264
6.28 Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 265
6.29 Program Object State (cont.) . . . . . . . . . . . . . . . . . . . . 266
6.30 Vertex Shader State . . . . . . . . . . . . . . . . . . . . . . . . . 267
6.31 Query Object State . . . . . . . . . . . . . . . . . . . . . . . . . 268
6.32 Transform Feedback State . . . . . . . . . . . . . . . . . . . . . 269
6.33 Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
6.34 Implementation Dependent Values . . . . . . . . . . . . . . . . . 271
6.35 Implementation Dependent Values (cont.) . . . . . . . . . . . . . 272
6.36 Implementation Dependent Values (cont.) . . . . . . . . . . . . . 273
6.37 Implementation Dependent Values (cont.) . . . . . . . . . . . . . 274
6.38 Implementation Dependent Values (cont.) . . . . . . . . . . . . . 275
6.39 Implementation Dependent Values (cont.) . . . . . . . . . . . . . 276
6.40 Implementation Dependent Values (cont.)
(1) The minimum value for each stage is MAX_stage_-
UNIFORM_BLOCKS  MAX_stage_UNIFORM_BLOCK_SIZE +
MAX_stage_UNIFORM_COMPONENTS . . . . . . . . . . . . . . . 277
6.41 Framebuffer Dependent Values . . . . . . . . . . . . . . . . . . . 278
6.42 Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
F.1 New token names . . . . . . . . . . . . . . . . . . . . . . . . . . 302
OpenGL 3.1 - May 28, 2009Chapter 1
Introduction
This document describes the OpenGL graphics system: what it is, how it acts, and
what is required to implement it. We assume that the reader has at least a rudi-
mentary understanding of computer graphics. This means familiarity with the es-
sentials of computer graphics algorithms as well as familiarity with basic graphics
hardware and associated terms.
1.1 What is the OpenGL Graphics System?
OpenGL (for “Open Graphics Library”) is a software interface to graphics hard-
ware. The interface consists of a set of several hundred procedures and functions
that allow a programmer to specify the objects and operations involved in produc-
ing high-quality graphical images, speci?cally color images of three-dimensional
objects.
Most of OpenGL requires that the graphics hardware contain a framebuffer.
Many OpenGL calls pertain to drawing objects such as points, lines, and polygons,
but the way that some of this drawing occurs (such as when antialiasing is enabled)
relies on the existence of a framebuffer. Further, some of OpenGL is speci?cally
concerned with framebuffer manipulation.
1.2 Programmer’s View of OpenGL
To the programmer, OpenGL is a set of commands that allow the speci?cation of
geometric objects in two or three dimensions, together with commands that control
how these objects are rendered into the framebuffer.
A typical program that uses OpenGL begins with calls to open a window into
the framebuffer into which the program will draw. Then, calls are made to allocate
11.3. IMPLEMENTOR’SVIEWOFOPENGL 2
a GL context and associate it with the window. Once a GL context is allocated,
the programmer is free to issue OpenGL commands. Some calls are used to draw
simple geometric objects (i.e. points, line segments, and polygons), while others
affect the rendering of these primitives including how they are lit or colored and
how they are mapped from the user’s two- or three-dimensional model space to
the two-dimensional screen. There are also calls to effect direct control of the
framebuffer, such as reading and writing pixels.
1.3 Implementor’s View of OpenGL
To the implementor, OpenGL is a set of commands that affect the operation of
graphics hardware. If the hardware consists only of an addressable framebuffer,
then OpenGL must be implemented almost entirely on the host CPU. More typi-
cally, the graphics hardware may comprise varying degrees of graphics accelera-
tion, from a raster subsystem capable of rendering two-dimensional lines and poly-
gons to sophisticated ?oating-point processors capable of transforming and com-
puting on geometric data. The OpenGL implementor’s task is to provide the CPU
software interface while dividing the work for each OpenGL command between
the CPU and the graphics hardware. This division must be tailored to the available
graphics hardware to obtain optimum performance in carrying out OpenGL calls.
OpenGL maintains a considerable amount of state information. This state con-
trols how objects are drawn into the framebuffer. Some of this state is directly
available to the user: he or she can make calls to obtain its value. Some of it, how-
ever, is visible only by the effect it has on what is drawn. One of the main goals of
this speci?cation is to make OpenGL state information explicit, to elucidate how it
changes, and to indicate what its effects are.
1.4 Our View
We view OpenGL as a pipeline having some programmable stages and some state-
driven stages that control a set of speci?c drawing operations. This model should
engender a speci?cation that satis?es the needs of both programmers and imple-
mentors. It does not, however, necessarily provide a model for implementation. An
implementation must produce results conforming to those produced by the speci-
?ed methods, but there may be ways to carry out a particular computation that are
more ef?cient than the one speci?ed.
OpenGL 3.1 - May 28, 20091.5. THEDEPRECATIONMODEL 3
1.5 The Deprecation Model
GL features marked as deprecated in one version of the speci?cation are expected
to be removed in a future version, allowing applications time to transition away
from use of deprecated features. The deprecation model is described in more detail,
together with a summary of the commands and state deprecated from this version
of the API, in appendix E.
1.6 Companion Documents
1.6.1 OpenGL Shading Language
This speci?cation should be read together with a companion document titled The
OpenGL Shading Language. The latter document (referred to as the OpenGL Shad-
ing Language Specification hereafter) de?nes the syntax and semantics of the pro-
gramming language used to write vertex and fragment shaders (see sections 2.11
and 3.9). These sections may include references to concepts and terms (such as
shading language variable types) de?ned in the companion document.
OpenGL 3.1 implementations are guaranteed to support at least version 1.30 of
the shading language. The actual version supported may be queried as described
in section 6.1.4.
1.6.2 Window System Bindings
OpenGL requires a companion API to create and manage graphics contexts, win-
dows to render into, and other resources beyond the scope of this Specification.
There are several such APIs supporting different operating and window systems.
OpenGL Graphics with the X Window System, also called the “GLX Speci?ca-
tion”, describes the GLX API for use of OpenGL in the X Window System. It is
primarily directed at Linux and Unix systems, but GLX implementations also exist
for Microsoft Windows, MacOS X, and some other platforms where X is avail-
able. The GLX Specification is available in the OpenGL Extension Registry (see
appendix H).
The WGL API supports use of OpenGL with Microsoft Windows. WGL is
documented in Microsoft’s MSDN system, although no full speci?cation exists.
Several APIs exist supporting use of OpenGL with Quartz, the MacOS X win-
dow system, including CGL, AGL, and NSOpenGLView. These APIs are docu-
mented on Apple’s developer website.
The Khronos Native Platform Graphics Interface or “EGL Specification” de-
scribes the EGL API for use of OpenGL ES on mobile and embedded devices.
OpenGL 3.1 - May 28, 20091.6. COMPANIONDOCUMENTS 4
EGL implementations may be available supporting OpenGL as well. The EGL
Specification is available in the Khronos Extension Registry at URL
http://www.khronos.org/registry/egl
OpenGL 3.1 - May 28, 2009Chapter 2
OpenGL Operation
2.1 OpenGL Fundamentals
OpenGL (henceforth, the “GL”) is concerned only with rendering into a frame-
buffer (and reading values stored in that framebuffer). There is no support for
other peripherals sometimes associated with graphics hardware, such as mice and
keyboards. Programmers must rely on other mechanisms to obtain user input.
The GL draws primitives subject to a number of selectable modes and shader
programs. Each primitive is a point, line segment, or polygon. Each mode may
be changed independently; the setting of one does not affect the settings of oth-
ers (although many modes may interact to determine what eventually ends up in
the framebuffer). Modes are set, primitives speci?ed, and other GL operations
described by sending commands in the form of function or procedure calls.
Primitives are de?ned by a group of one or more vertices. A vertex de?nes
a point, an endpoint of an edge, or a corner of a polygon where two edges meet.
Data such as positional coordinates, colors, normals, texture coordinates, etc. are
associated with a vertex and each vertex is processed independently, in order, and
in the same way. The only exception to this rule is if the group of vertices must
be clipped so that the indicated primitive ?ts within a speci?ed region; in this
case vertex data may be modi?ed and new vertices created. The type of clipping
depends on which primitive the group of vertices represents.
Commands are always processed in the order in which they are received, al-
though there may be an indeterminate delay before the effects of a command are
realized. This means, for example, that one primitive must be drawn completely
before any subsequent one can affect the framebuffer. It also means that queries
and pixel read operations return state consistent with complete execution of all
previously invoked GL commands, except where explicitly speci?ed otherwise. In
52.1. OPENGLFUNDAMENTALS 6
general, the effects of a GL command on either GL modes or the framebuffer must
be complete before any subsequent command can have any such effects.
In the GL, data binding occurs on call. This means that data passed to a com-
mand are interpreted when that command is received. Even if the command re-
quires a pointer to data, those data are interpreted when the call is made, and any
subsequent changes to the data have no effect on the GL (unless the same pointer
is used in a subsequent command).
The GL provides direct control over the fundamental operations of 3D and 2D
graphics. This includes speci?cation of parameters of application-de?ned shader
programs performing transformation, lighting, texturing, and shading operations,
as well as built-in functionality such as antialiasing and texture ?ltering. It does
not provide a means for describing or modeling complex geometric objects. An-
other way to describe this situation is to say that the GL provides mechanisms to
describe how complex geometric objects are to be rendered rather than mechanisms
to describe the complex objects themselves.
The model for interpretation of GL commands is client-server. That is, a pro-
gram (the client) issues commands, and these commands are interpreted and pro-
cessed by the GL (the server). The server may or may not operate on the same
computer as the client. In this sense, the GL is “network-transparent.” A server
may maintain a number of GL contexts, each of which is an encapsulation of cur-
rent GL state. A client may choose to connect to any one of these contexts. Issuing
GL commands when the program is not connected to a context results in unde?ned
behavior.
The GL interacts with two classes of framebuffers: window system-provided
and application-created. There is at most one window system-provided framebuffer
at any time, referred to as the default framebuffer. Application-created frame-
buffers, referred to as framebuffer objects, may be created as desired. These two
types of framebuffer are distinguished primarily by the interface for con?guring
and managing their state.
The effects of GL commands on the default framebuffer are ultimately con-
trolled by the window system, which allocates framebuffer resources, determines
which portions of the default framebuffer the GL may access at any given time, and
communicates to the GL how those portions are structured. Therefore, there are
no GL commands to initialize a GL context or con?gure the default framebuffer.
Similarly, display of framebuffer contents on a physical display device (including
the transformation of individual framebuffer values by such techniques as gamma
correction) is not addressed by the GL.
Allocation and con?guration of the default framebuffer occurs outside of the
GL in conjunction with the window system, using companion APIs described in
section 1.6.2.
OpenGL 3.1 - May 28, 20092.1. OPENGLFUNDAMENTALS 7
Allocation and initialization of GL contexts is also done using these companion
APIs. GL contexts can typically be associated with different default framebuffers,
and some context state is determined at the time this association is performed.
It is possible to use a GL context without a default framebuffer, in which case
a framebuffer object must be used to perform all rendering. This is useful for
applications needing to perform offscreen rendering.
The GL is designed to be run on a range of graphics platforms with varying
graphics capabilities and performance. To accommodate this variety, we specify
ideal behavior instead of actual behavior for certain GL operations. In cases where
deviation from the ideal is allowed, we also specify the rules that an implemen-
tation must obey if it is to approximate the ideal behavior usefully. This allowed
variation in GL behavior implies that two distinct GL implementations may not
agree pixel for pixel when presented with the same input even when run on identi-
cal framebuffer con?gurations.
Finally, command names, constants, and types are pre?xed in the GL (by gl,
GL_, andGL, respectively inC) to reduce name clashes with other packages. The
pre?xes are omitted in this document for clarity.
2.1.1 Floating-Point Computation
The GL must perform a number of ?oating-point operations during the course of
its operation. In some cases, the representation and/or precision of such opera-
tions is de?ned or limited; by the OpenGL Shading Language Specification for
operations in shaders, and in some cases implicitly limited by the speci?ed format
of vertex, texture, or renderbuffer data consumed by the GL. Otherwise, the rep-
resentation of such ?oating-point numbers, and the details of how operations on
them are performed, is not speci?ed. We require simply that numbers’ ?oating-
point parts contain enough bits and that their exponent ?elds are large enough so
that individual results of ?oating-point operations are accurate to about 1 part in
5
10 . The maximum representable magnitude of a ?oating-point number used to
32
represent positional, normal, or texture coordinates must be at least 2 ; the max-
10
imum representable magnitude for colors must be at least 2 . The maximum
32
representable magnitude for all other ?oating-point values must be at least 2 .
x 0 = 0x = 0 for any non-in?nite and non-NaN x. 1x = x 1 = x.
0
x + 0 = 0 +x =x. 0 = 1. (Occasionally further requirements will be speci?ed.)
Most single-precision ?oating-point formats meet these requirements.
The special values Inf and Inf encode values with magnitudes too large to
be represented; the special value NaN encodes “Not A Number” values resulting
1
from unde?ned arithmetic operations such as . Implementations are permitted,
0
but not required, to support Inf s and NaN s in their ?oating-point computations.
OpenGL 3.1 - May 28, 20092.1. OPENGLFUNDAMENTALS 8
Any representable ?oating-point value is legal as input to a GL command that
requires ?oating-point data. The result of providing a value that is not a ?oating-
point number to such a command is unspeci?ed, but must not lead to GL interrup-
tion or termination. In IEEE arithmetic, for example, providing a negative zero or a
denormalized number to a GL command yields predictable results, while providing
a NaN or an in?nity yields unspeci?ed results.
Some calculations require division. In such cases (including implied divisions
required by vector normalizations), a division by zero produces an unspeci?ed re-
sult but must not lead to GL interruption or termination.
2.1.2 16-Bit Floating-Point Numbers
A 16-bit ?oating-point number has a 1-bit sign (S), a 5-bit exponent (E), and a
10-bit mantissa (M). The valueV of a 16-bit ?oating-point number is determined
by the following:
8
S
>( 1)  0:0; E = 0;M = 0
>
>
>
S  14 M
>
>( 1)  2  ; E = 0;M6= 0
10
< 2
  
M
S E 15
V =
( 1)  2  1 + ; 0<E < 31
10
2
>
>
S
>
>( 1)  Inf; E = 31;M = 0
>
>
:
NaN; E = 31;M =6 0
If the ?oating-point number is interpreted as an unsigned 16-bit integerN, then
 
N mod 65536
S =
32768
 
N mod 32768
E =
1024
M =N mod 1024:
Any representable 16-bit ?oating-point value is legal as input to a GL command
that accepts 16-bit ?oating-point data. The result of providing a value that is not a
?oating-point number (such as Inf or NaN ) to such a command is unspeci?ed, but
must not lead to GL interruption or termination. Providing a denormalized number
or negative zero to GL must yield predictable results.
2.1.3 Unsigned 11-Bit Floating-Point Numbers
An unsigned 11-bit ?oating-point number has no sign bit, a 5-bit exponent (E), and
a 6-bit mantissa (M). The valueV of an unsigned 11-bit ?oating-point number is
OpenGL 3.1 - May 28, 20092.1. OPENGLFUNDAMENTALS 9
determined by the following:
8
>0:0; E = 0;M = 0
>
>
>
 14 M
>
>2  ; E = 0;M6= 0
< 64
  
M
E 15
V =
2  1 + ; 0<E < 31
64
>
>
>
>Inf; E = 31;M = 0
>
>
:
NaN; E = 31;M6= 0
If the ?oating-point number is interpreted as an unsigned 11-bit integerN, then
 
N
E =
64
M =N mod 64:
When a ?oating-point value is converted to an unsigned 11-bit ?oating-point
representation, ?nite values are rounded to the closest representable ?nite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, ?nite posi-
tive values greater than 65024 (the maximum ?nite representable unsigned 11-bit
?oating-point value) are converted to 65024. Additionally: negative in?nity is con-
verted to zero; positive in?nity is converted to positive in?nity; and both positive
and negative NaN are converted to positive NaN .
Any representable unsigned 11-bit ?oating-point value is legal as input to a
GL command that accepts 11-bit ?oating-point data. The result of providing a
value that is not a ?oating-point number (such as Inf or NaN ) to such a command
is unspeci?ed, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.
2.1.4 Unsigned 10-Bit Floating-Point Numbers
An unsigned 10-bit ?oating-point number has no sign bit, a 5-bit exponent (E), and
a 5-bit mantissa (M). The valueV of an unsigned 10-bit ?oating-point number is
determined by the following:
8
>0:0; E = 0;M = 0
>
>
>
M
>  14
>2  ; E = 0;M6= 0
< 32
  
M
E 15
V =
2  1 + ; 0<E < 31
32
>
>
>
>Inf; E = 31;M = 0
>
>
:
NaN; E = 31;M =6 0
OpenGL 3.1 - May 28, 20092.1. OPENGLFUNDAMENTALS 10
If the ?oating-point number is interpreted as an unsigned 10-bit integerN, then
 
N
E =
32
M =N mod 32:
When a ?oating-point value is converted to an unsigned 10-bit ?oating-point
representation, ?nite values are rounded to the closest representable ?nite value.
While less accurate, implementations are allowed to always round in the direction
of zero. This means negative values are converted to zero. Likewise, ?nite posi-
tive values greater than 64512 (the maximum ?nite representable unsigned 10-bit
?oating-point value) are converted to 64512. Additionally: negative in?nity is con-
verted to zero; positive in?nity is converted to positive in?nity; and both positive
and negative NaN are converted to positive NaN .
Any representable unsigned 10-bit ?oating-point value is legal as input to a
GL command that accepts 10-bit ?oating-point data. The result of providing a
value that is not a ?oating-point number (such as Inf or NaN ) to such a command
is unspeci?ed, but must not lead to GL interruption or termination. Providing a
denormalized number to GL must yield predictable results.
2.1.5 Fixed-Point Data Conversions
When generic vertex attributes and pixel color or depth components are repre-
sented as integers, they are often (but not always) considered to be normalized.
Normalized integer values are treated specially when being converted to and from
?oating-point values, and are usually referred to as normalized ?xed-point. Such
values are always either signed or unsigned.
In the remainder of this section,b denotes the bit width of the ?xed-point in-
teger representation. When the integer is one of the types de?ned in table 2.2, b
is the minimum required bit width of that type. When the integer is a texture or
renderbuffer color or depth component (see section 3.8.1),b is the number of bits
allocated to that component in the internal format of the texture or renderbuffer.
When the integer is a framebuffer color or depth component (see section 4,b is the
number of bits allocated to that component in the framebuffer. For framebuffer and
renderbuffer A components,b must be at least 2 if the buffer does not contain an A
component, or if there is only 1 bit of A in the buffer.
The signed and unsigned ?xed-point representations are assumed to be b-bit
binary twos-complement integers and binary unsigned integers, respectively The
signed ?xed-point representation may be treated in one of two ways, as discussed
below.
OpenGL 3.1 - May 28, 20092.1. OPENGLFUNDAMENTALS 11
All the conversions described below are performed as de?ned, even if the im-
plemented range of an integer data type is greater than the minimum required range.
Conversion from Normalized Fixed-Point to Floating-Point
Unsigned normalized ?xed-point integers represent numbers in the range [0; 1].
The conversion from an unsigned normalized ?xed-point valuec to the correspond-
ing ?oating-point valuef is de?ned as
c
f = : (2.1)
b
2   1
Signed normalized ?xed-point integers represent numbers in the range [ 1; 1].
The conversion from a signed normalized ?xed-point valuec to the corresponding
?oating-point valuef may be performed in two ways:
2c + 1
f = (2.2)
b
2   1
b 1
In this case the full range of the representation is used, so that 2 corre-
b 1
sponds to -1.0 and 2   1 corresponds to 1.0. For example, ifb = 8, then the
integer value -128 corresponds to -1.0 and the value 127 corresponds to 1.0. Note
that it is not possible to exactly express 0 in this representation. In general, this rep-
resentation is used for signed normalized ?xed-point parameters in GL commands,
such as vertex attribute values.
Alternatively, conversion may be performed using
 
c
f =max ; 1:0 : (2.3)
b 1
2   1
b 1 b 1
In this case only the range [ 2 + 1; 2   1] is used to represent signed
?xed-point values in the range [ 1; 1]. For example, if b = 8, then the integer
value -127 corresponds to -1.0 and the value 127 corresponds to 1.0. Note that
while zero can be exactly expressed in this representation, one value (-128 in the
example) is outside the representable range, and must be clamped before use. In
general, this representation is used for signed normalized ?xed-point texture or
framebuffer values.
Everywhere that signed normalized ?xed-point values are converted, the equa-
tion used is speci?ed.
OpenGL 3.1 - May 28, 20092.2. GLSTATE 12
Conversion from Floating-Point to Normalized Fixed-Point
The conversion from a ?oating-point valuef to the corresponding unsigned nor-
malized ?xed-point valuec is de?ned by ?rst clampingf to the range [0; 1], then
computing
0 b
f =f (2   1): (2.4)
0
f is then cast to an unsigned binary integer value with exactlyb bits.
The conversion from a ?oating-point valuef to the corresponding signed nor-
malized ?xed-point value c may be performed in two ways, both beginning by
clampingf to the range [ 1; 1]:
0 b
f =f (2   1)  1
(2.5)
2
In general, this conversion is used when querying ?oating-point state (see sec-
tion 6) and returning integers.
Alternatively, conversion may be performed using
0 b 1
f =f (2   1): (2.6)
In general, this conversion is used when specifying signed normalized ?xed-
point texture or framebuffer values.
0
After conversion,f is then cast to a signed two’s-complement binary integer
value with exactlyb bits.
Everywhere that ?oating-point values are converted to signed normalized ?xed-
point, the equation used is speci?ed.
2.2 GL State
The GL maintains considerable state. This document enumerates each state vari-
able and describes how each variable can be changed. For purposes of discussion,
state variables are categorized somewhat arbitrarily by their function. Although we
describe the operations that the GL performs on the framebuffer, the framebuffer
is not a part of GL state.
We distinguish two types of state. The ?rst type of state, called GL server
state, resides in the GL server. The majority of GL state falls into this category.
The second type of state, called GL client state, resides in the GL client. Unless
otherwise speci?ed, all state referred to in this document is GL server state; GL
client state is speci?cally identi?ed. Each instance of a GL context implies one
OpenGL 3.1 - May 28, 20092.3. GLCOMMANDSYNTAX 13
complete set of GL server state; each connection from a client to a server implies
a set of both GL client state and GL server state.
While an implementation of the GL may be hardware dependent, this discus-
sion is independent of the speci?c hardware on which a GL is implemented. We are
therefore concerned with the state of graphics hardware only when it corresponds
precisely to GL state.
2.2.1 Shared Object State
It is possible for groups of contexts to share certain state. Enabling such sharing
between contexts is done through window system binding APIs such as those de-
scribed in section 1.6.2. These APIs are responsible for creation and management
of contexts, and not discussed further here. More detailed discussion of the behav-
ior of shared objects is included in appendix D. Except as de?ned in this appendix,
all state in a context is speci?c to that context only.
2.3 GL Command Syntax
GL commands are functions or procedures. Various groups of commands perform
the same operation but differ in how arguments are supplied to them. To conve-
niently accommodate this variation, we adopt a notation for describing commands
and their arguments.
GL commands are formed from a name followed, depending on the particular
command, by up to 4 characters. The ?rst character indicates the number of values
of the indicated type that must be presented to the command. The second character
or character pair indicates the speci?c type of the arguments: 8-bit integer, 16-bit
integer, 32-bit integer, single-precision ?oating-point, or double-precision ?oating-
point. The ?nal character, if present, is v, indicating that the command takes a
pointer to an array (a vector) of values rather than a series of individual arguments.
Two speci?c examples are:
void Uniform4f(int location,float v0,float v1,
float v2,float v3 );
and
void GetFloatv(enum value,float *data );
OpenGL 3.1 - May 28, 20092.3. GLCOMMANDSYNTAX 14
Letter CorrespondingGL Type
b byte
s short
i int
f float
d double
ub ubyte
us ushort
ui uint
Table 2.1: Correspondence of command suf?x letters to GL argument types. Refer
to table 2.2 for de?nitions of the GL types.
These examples show the ANSIC declarations for these commands. In general,
1
a command declaration has the form
rtype Namef1234gf b s i f d ub us uigfvg
( [args ,] T arg1 ,::: , T argN [, args] );
rtype is the return type of the function. The braces (fg) enclose a series of char-
acters (or character pairs) of which one is selected.  indicates no character. The
arguments enclosed in brackets ([args ,] and [, args]) may or may not be present.
TheN arguments arg1 through argN have type T, which corresponds to one of the
type letters or letter pairs as indicated in table 2.1 (if there are no letters, then the
arguments’ type is given explicitly). If the ?nal character is not v, thenN is given
by the digit 1, 2, 3, or 4 (if there is no digit, then the number of arguments is ?xed).
If the ?nal character is v, then only arg1 is present and it is an array ofN values
of the indicated type. Finally, we indicate anunsigned type by the shorthand of
prepending au to the beginning of the type name (so that, for instance,unsigned
byte is abbreviatedubyte).
For example,
void Uniformf1234gfifg(int location,T value );
indicates the eight declarations
void Uniform1i(int location,int value );
1
The declarations shown in this document apply to ANSI C. Languages such as C++ and Ada
that allow passing of argument type information admit simpler declarations and fewer entry points.
OpenGL 3.1 - May 28, 20092.4. BASICGLOPERATION 15
void Uniform1f(int location,float value );
void Uniform2i(int location,int v0,int v1 );
void Uniform2f(int location,float v0,float v1 );
void Uniform3i(int location,int v0,int v1,int v2 );
void Uniform3f(int location,float v1,float v2,
float v2 );
void Uniform4i(int location,int v0,int v1,int v2,
int v3 );
void Uniform4f(int location,float v0,float v1,
float v2,float v3 );
Arguments whose type is ?xed (i.e. not indicated by a suf?x on the command)
are of one of the GL data types summarized in table 2.2, or pointers to one of these
types.
2.4 Basic GL Operation
Figure 2.1 shows a schematic diagram of the GL. Commands enter the GL on the
left. Some commands specify geometric objects to be drawn while others control
how the objects are handled by the various stages. Commands are effectively sent
through a processing pipeline.
The ?rst stage operates on geometric primitives described by vertices: points,
line segments, and polygons. In this stage vertices may be transformed and lit,
and primitives are clipped to a viewing volume in preparation for the next stage,
rasterization. The rasterizer produces a series of framebuffer addresses and values
using a two-dimensional description of a point, line segment, or polygon. Each
fragment so produced is fed to the next stage that performs operations on individ-
ual fragments before they ?nally alter the framebuffer. These operations include
conditional updates into the framebuffer based on incoming and previously stored
depth values (to effect depth buffering), blending of incoming fragment colors with
stored colors, as well as masking and other logical operations on fragment values.
Finally, values may also be read back from the framebuffer or copied from one
portion of the framebuffer to another. These transfers may include some type of
decoding or encoding.
This ordering is meant only as a tool for describing the GL, not as a strict rule
of how the GL is implemented, and we present it only as a means to organize the
various operations of the GL. Objects such as curved surfaces, for instance, may
be transformed before they are converted to polygons.
OpenGL 3.1 - May 28, 20092.4. BASICGLOPERATION 16
GL Type Minimum Description
Bit Width
boolean 1 Boolean
byte 8 Signed 2’s complement binary integer
ubyte 8 Unsigned binary integer
char 8 Characters making up strings
short 16 Signed 2’s complement binary integer
ushort 16 Unsigned binary integer
int 32 Signed 2’s complement binary integer
uint 32 Unsigned binary integer
sizei 32 Non-negative binary integer size
enum 32 Enumerated binary integer value
intptr ptrbits Signed 2’s complement binary integer
sizeiptr ptrbits Non-negative binary integer size
bitfield 32 Bit ?eld
half 16 Half-precision ?oating-point value
encoded in an unsigned scalar
float 32 Floating-point value
clampf 32 Floating-point value clamped to [0; 1]
double 64 Floating-point value
clampd 64 Floating-point value clamped to [0; 1]
Table 2.2: GL data types. GL types are not C types. Thus, for example, GL
type int is referred to as GLint outside this document, and is not necessarily
equivalent to the C type int. An implementation may use more bits than the
number indicated in the table to represent a GL type. Correct interpretation of
integer values outside the minimum range is not required, however.
ptrbits is the number of bits required to represent a pointer type; in other words,
typesintptr andsizeiptr must be suf?ciently large as to store any address.
OpenGL 3.1 - May 28, 20092.4. BASICGLOPERATION 17
Transform
Feedback
Vertex Vertex
Primitive Fragment
Data
Shading and
Assembly Shading and
Per-Vertex Framebuffer
and Per-Fragment
Operations
Rasterization Operations
Pixel
Data
Texture
Memory
Pixel
Pack/Unpack
Figure 2.1. Block diagram of the GL.
OpenGL 3.1 - May 28, 20092.5. GLERRORS 18
2.5 GL Errors
The GL detects only a subset of those conditions that could be considered errors.
This is because in many cases error checking would adversely impact the perfor-
mance of an error-free program.
The command
enum GetError(void );
is used to obtain error information. Each detectable error is assigned a numeric
code. When an error is detected, a ?ag is set and the code is recorded. Further
errors, if they occur, do not affect this recorded code. When GetError is called,
the code is returned and the ?ag is cleared, so that a further error will again record
its code. If a call to GetError returnsNO_ERROR, then there has been no detectable
error since the last call to GetError (or since the GL was initialized).
To allow for distributed implementations, there may be several ?ag-code pairs.
In this case, after a call to GetError returns a value other than NO_ERROR each
subsequent call returns the non-zero code of a distinct ?ag-code pair (in unspeci?ed
order), until all non-NO_ERROR codes have been returned. When there are no more
non-NO_ERROR error codes, all ?ags are reset. This scheme requires some positive
number of pairs of a ?ag bit and an integer. The initial state of all ?ags is cleared
and the initial value of all codes isNO_ERROR.
Table 2.3 summarizes GL errors. Currently, when an error ?ag is set, results of
GL operation are unde?ned only ifOUT_OF_MEMORY has occurred. In other cases,
the command generating the error is ignored so that it has no effect on GL state or
framebuffer contents. If the generating command returns a value, it returns zero. If
the generating command modi?es values through a pointer argument, no change is
made to these values. These error semantics apply only to GL errors, not to system
errors such as memory access errors. This behavior is the current behavior; the
action of the GL in the presence of errors is subject to change.
Several error generation conditions are implicit in the description of every GL
command:
 If a command that requires an enumerated value is passed a symbolic con-
stant that is not one of those speci?ed as allowable for that command, the
error INVALID_ENUM is generated. This is the case even if the argument is
a pointer to a symbolic constant, if the value pointed to is not allowable for
the given command.
 If a negative number is provided where an argument of type sizei or
sizeiptr is speci?ed, the errorINVALID_VALUE is generated.
OpenGL 3.1 - May 28, 20092.6. PRIMITIVESANDVERTICES 19
Error Description Offending com-
mand ignored?
INVALID_ENUM enum argument out of range Yes
INVALID_VALUE Numeric argument out of range Yes
INVALID_OPERATION Operation illegal in current state Yes
INVALID_FRAMEBUFFER_OPERATION Framebuffer object is not com- Yes
plete
OUT_OF_MEMORY Not enough memory left to exe- Unknown
cute command
Table 2.3: Summary of GL errors
 If memory is exhausted as a side effect of the execution of a command, the
errorOUT_OF_MEMORY may be generated.
Otherwise, errors are generated only for conditions that are explicitly described in
this speci?cation.
2.6 Primitives and Vertices
In the GL, most geometric objects are drawn by specifying a series of generic
attribute sets using DrawArrays or one of the other drawing commands de?ned in
section 2.8.2. There are seven geometric objects that are drawn this way: points,
line segment strips, line segment loops, separated line segments, triangle strips,
triangle fans, and separated triangles,
Each vertex is speci?ed with one or more generic vertex attributes. Each at-
tribute is speci?ed with one, two, three, or four scalar values. Generic vertex
attributes can be accessed from within vertex shaders (section 2.11) and used to
compute values for consumption by later processing stages.
The methods by which generic attributes are sent to the GL, as well as how
attributes are used by vertex shaders to generate vertices mapped to the two-
dimensional screen, are discussed later.
Before vertex shader execution, the state required by a vertex is its generic
vertex attributes. Vertex shader execution processes vertices producing a homo-
geneous vertex position and any varying outputs explicitly written by the vertex
shader.
Figure 2.2 shows the sequence of operations that builds a primitive (point, line
segment, or polygon) from a sequence of vertices. After a primitive is formed, it
OpenGL 3.1 - May 28, 20092.6. PRIMITIVESANDVERTICES 20
Coordinates
Point,
Point culling,
Vertex Line Segment, or
Shaded
Line Segment
Shader Triangle Rasterization
Vertices
or Triangle
Execution (Primitive)
clipping
Assembly
Varying
Outputs
Generic Primitive type
Vertex (from DrawArrays or
Attributes DrawElements mode)
Figure 2.2. Vertex processing and primitive assembly.
OpenGL 3.1 - May 28, 20092.6. PRIMITIVESANDVERTICES 21
is clipped to a viewing volume. This may alter the primitive by altering vertex
coordinates and varying vertex shader outputs. In the case of line and polygon
primitives, clipping may insert new vertices into the primitive. The vertices de?n-
ing a primitive to be rasterized have varying outputs associated with them.
2.6.1 Primitive Types
A sequence of vertices is passed to the GL using DrawArrays or one of the other
drawing commands de?ned in section 2.8.2. There is no limit to the number of
vertices that may be speci?ed, other than the size of the vertex arrays. The mode
parameter of these commands determines the type of primitives to be drawn using
the vertices. The types, and the corresponding mode parameters, are:
Points. A series of individual points may be speci?ed with mode POINTS.
Each vertex de?nes a separate point.
Line Strips. A series of one or more connected line segments may be speci?ed
with modeLINE_STRIP. In this case, the ?rst vertex speci?es the ?rst segment’s
start point while the second vertex speci?es the ?rst segment’s endpoint and the
second segment’s start point. In general, the ith vertex (for i > 1) speci?es the
beginning of theith segment and the end of thei  1st. The last vertex speci?es
the end of the last segment. If only one vertex is speci?ed, then no primitive is
generated.
The required state consists of the processed vertex produced from the last ver-
tex that was sent (so that a line segment can be generated from it to the current
vertex), and a boolean ?ag indicating if the current vertex is the ?rst vertex.
Line Loops. Line loops may be speci?ed with mode LINE_LOOP. Loops are
the same as line strips except that a ?nal segment is added from the ?nal speci?ed
vertex to the ?rst vertex. The required state consists of the processed ?rst vertex,
in addition to the state required for line strips.
Separate Lines. Individual line segments, each speci?ed by a pair of vertices,
may be speci?ed with mode LINES. The ?rst two vertices passed de?ne the ?rst
segment, with subsequent pairs of vertices each de?ning one more segment. If the
number of speci?ed vertices is odd, then the last one is ignored. The state required
is the same as for line strips but it is used differently: a processed vertex holding
the ?rst vertex of the current segment, and a boolean ?ag indicating whether the
current vertex is odd or even (a segment start or end).
Triangle strips. A triangle strip is a series of triangles connected along shared
edges, and may be speci?ed with mode TRIANGLE_STRIP. In this case, the ?rst
three vertices de?ne the ?rst triangle (and their order is signi?cant). Each subse-
quent vertex de?nes a new triangle using that point along with two vertices from
the previous triangle. If fewer than three vertices are speci?ed, no primitive is
OpenGL 3.1 - May 28, 20092.6. PRIMITIVESANDVERTICES 22
4
2 2 2
3 6
4
4
5
5
1
1 3 5 1 3
(a) (b) (c)
Figure 2.3. (a) A triangle strip. (b) A triangle fan. (c) Independent triangles. The
numbers give the sequencing of the vertices in order within the vertex arrays. Note
that in (a) and (b) triangle edge ordering is determined by the ?rst triangle, while in
(c) the order of each triangle’s edges is independent of the other triangles.
produced. See ?gure 2.3.
The required state consists of a ?ag indicating if the ?rst triangle has been
completed, two stored processed vertices, (called vertex A and vertex B), and a
one bit pointer indicating which stored vertex will be replaced with the next vertex.
The pointer is initialized to point to vertex A. Each successive vertex toggles the
pointer. Therefore, the ?rst vertex is stored as vertex A, the second stored as vertex
B, the third stored as vertex A, and so on. Any vertex after the second one sent
forms a triangle from vertex A, vertex B, and the current vertex (in that order).
Triangle fans. A triangle fan is the same as a triangle strip with one exception:
each vertex after the ?rst always replaces vertex B of the two stored vertices. A
triangle fan may be speci?ed with modeTRIANGLE_FAN.
Separate Triangles. Separate triangles are speci?ed with mode TRIANGLES.
In this case, The 3i + 1st, 3i + 2nd, and 3i + 3rd vertices (in that order) determine
a triangle for eachi = 0; 1;:::;n  1, where there are 3n +k vertices drawn.k is
either 0, 1, or 2; ifk is not zero, the ?nalk vertices are ignored. For each triangle,
vertex A is vertex 3i and vertex B is vertex 3i + 1. Otherwise, separate triangles
are the same as a triangle strip.
Depending on the current state of the GL, a polygon primitive generated
from a drawing command with mode TRIANGLE_FAN, TRIANGLE_STRIP, or
TRIANGLES may be rendered in one of several ways, such as outlining its bor-
der or ?lling its interior. The order of vertices in such a primitive is signi?cant in
OpenGL 3.1 - May 28, 20092.7. VERTEXSPECIFICATION 23
polygon rasterization and fragment shading (see sections 3.6.1 and 3.9.2).
2.7 Vertex Specification
Vertex shaders (see section 2.11) access an array of 4-component generic vertex
attributes . The ?rst slot of this array is numbered 0, and the size of the array is
speci?ed by the implementation-dependent constantMAX_VERTEX_ATTRIBS.
Current generic attribute values de?ne generic attributes for a vertex when a
vertex array de?ning that data is not enabled, as described in section 2.8. The cur-
rent values of a generic shader attribute declared as a ?oating-point scalar, vector,
or matrix may be changed at any time by issuing one of the commands
void VertexAttribf1234gfsfdg(uint index,T values );
void VertexAttribf123gfsfdgv(uint index,T values );
void VertexAttrib4fbsifd ub us uigv(uint index,T values );
void VertexAttrib4Nub(uint index,T values );
void VertexAttrib4Nfbsi ub us uigv(uint index,T values );
The VertexAttrib4N* commands specify ?xed-point values that are converted
to a normalized [0; 1] or [ 1; 1] range as described in equations 2.1 and 2.2, re-
spectively, while the other commands specify values that are converted directly to
the internal ?oating-point representation.
The resulting value(s) are loaded into the generic attribute at slot index, whose
components are named x, y, z, and w. The VertexAttrib1* family of commands
sets the x coordinate to the provided single argument while setting y and z to 0 and
w to 1. Similarly, VertexAttrib2* commands set x and y to the speci?ed values,
z to 0 and w to 1; VertexAttrib3* commands set x, y, and z, with w set to 1, and
VertexAttrib4* commands set all four coordinates.
The VertexAttrib* entry points may also be used to load shader attributes de-
clared as a ?oating-point matrix. Each column of a matrix takes up one generic
4-component attribute slot out of theMAX_VERTEX_ATTRIBS available slots. Ma-
trices are loaded into these slots in column major order. Matrix columns are loaded
in increasing slot numbers.
The resulting attribute values are unde?ned if the base type of the shader at-
tribute at slot index is not ?oating-point (e.g. is signed or unsigned integer). To
load current values of a generic shader attribute declared as a signed or unsigned
scalar or vector, use the commands
void VertexAttribIf1234gfi uig(uint index,T values );
void VertexAttribIf1234gfi uigv(uint index,T values );
OpenGL 3.1 - May 28, 20092.8. VERTEXARRAYS 24
void VertexAttribI4fbs ubusgv(uint index,T values );
These commands specify values that are extended to full signed or unsigned
integers, then loaded into the generic attribute at slot index in the same fashion as
described above.
The resulting attribute values are unde?ned if the base type of the shader at-
tribute at slot index is ?oating-point; if the base type is integer and unsigned in-
teger values are supplied (the VertexAttribI*ui, VertexAttribI*us, and Vertex-
AttribI*ub commands); or if the base type is unsigned integer and signed integer
values are supplied (the VertexAttribI*i, VertexAttribI*s, and VertexAttribI*b
commands)
The error INVALID_VALUE is generated by VertexAttrib* if index is greater
than or equal toMAX_VERTEX_ATTRIBS.
The state required to support vertex speci?cation consists of the value of
MAX_VERTEX_ATTRIBS four-component vectors to store generic vertex attributes.
The initial values for all generic vertex attributes are (0:0; 0:0; 0:0; 1:0).
2.8 Vertex Arrays
Vertex data is placed into arrays that are stored in the server’s address space (de-
scribed in section 2.9). Blocks of data in these arrays may then be used to specify
multiple geometric primitives through the execution of a single GL command. The
client may specify up to the value of MAX_VERTEX_ATTRIBS arrays to store one
or more generic vertex attributes. The commands
void VertexAttribPointer(uint index,int size,enum type,
boolean normalized,sizei stride,const
void *pointer );
void VertexAttribIPointer(uint index,int size,enum type,
sizei stride,const void *pointer );
describe the locations and organizations of these arrays. For each command, type
speci?es the data type of the values stored in the array. size indicates the number
of values per vertex (1, 2, 3, or 4) that are stored in the array. Table 2.4 indicates
the allowable values for size and type (when present). For type the values BYTE,
SHORT, INT, FLOAT, HALF_FLOAT, and DOUBLE indicate types byte, short,
int, float, half, and double, respectively; and the values UNSIGNED_-
BYTE, UNSIGNED_SHORT, and UNSIGNED_INT indicate types ubyte, ushort,
anduint, respectively. The errorINVALID_VALUE is generated if size is speci?ed
with a value other than that indicated in the table.
OpenGL 3.1 - May 28, 20092.8. VERTEXARRAYS 25
Integer
Command Sizes Handling Types
VertexAttribPointer 1,2,3,4 ?ag byte, ubyte, short,
ushort, int, uint, float,
half,double
VertexAttribIPointer 1,2,3,4 integer byte, ubyte, short,
ushort,int,uint
Table 2.4: Vertex array sizes (values per vertex) and data types. The “Integer Han-
dling” column indicates how ?xed-point data types are handled: “integer” means
that they remain as integer values, and “?ag” means that they are either converted
to ?oating-point directly, or converted by normalizing to [0; 1] (for unsigned types)
or [ 1; 1] (for signed types), depending on the setting of the normalized ?ag in
VertexAttribPointer.
The index parameter in the VertexAttribPointer and VertexAttribIPointer
commands identi?es the generic vertex attribute array being described. The er-
ror INVALID_VALUE is generated if index is greater than or equal to the value of
MAX_VERTEX_ATTRIBS. Generic attribute arrays with integer type arguments can
be handled in one of three ways: converted to ?oat by normalizing to [0; 1] or
[ 1; 1] as described in equations 2.1 and 2.2, respectively; converted directly to
?oat, or left as integers. Data for an array speci?ed by VertexAttribPointer will
be converted to ?oating-point by normalizing if normalized isTRUE, and converted
directly to ?oating-point otherwise. Data for an array speci?ed by VertexAttribI-
Pointer will always be left as integer values; such data are referred to as pure
integers.
The one, two, three, or four values in an array that correspond to a single vertex
comprise an array element. The values within each array element are stored se-
quentially in memory. If stride is speci?ed as zero, then array elements are stored
sequentially as well. The errorINVALID_VALUE is generated if stride is negative.
Otherwise pointers to the ith and (i + 1)st elements of an array differ by stride
basic machine units (typically unsigned bytes), the pointer to the (i + 1)st element
being greater. For each command, pointer speci?es the offset within a buffer of the
?rst value of the ?rst element of the array being speci?ed.
An individual generic vertex attribute array is enabled or disabled by calling
one of
void EnableVertexAttribArray(uint index );
void DisableVertexAttribArray(uint index );
OpenGL 3.1 - May 28, 20092.8. VERTEXARRAYS 26
where index identi?es the generic vertex attribute array to enable or disable. The
error INVALID_VALUE is generated if index is greater than or equal to MAX_-
VERTEX_ATTRIBS.
2.8.1 Transferring Array Elements
When an array elementi is transferred to the GL by DrawArrays, DrawElements,
or the other Draw* commands described below, each generic attribute is expanded
to four components. If size is one then thex component of the attribute is speci?ed
by the array; they,z, andw components are implicitly set to 0, 0, and 1, respec-
tively. If size is two then thex andy components of the attribute are speci?ed by
the array; thez andw components are implicitly set to 0 and 1, respectively. If size
is three thenx,y, andz are speci?ed, andw is implicitly set to 1. If size is four
then all components are speci?ed.
Primitive restarting is enabled or disabled by calling one of the commands
void Enable(enum target );
and
void Disable(enum target );
with targetPRIMITIVE_RESTART. The command
void PrimitiveRestartIndex(uint index );
speci?es a vertex array element that is treated specially when primitive restarting is
enabled. This value is called the primitive restart index. When one of the Draw*
commands transfers the ith successive set of generic attribute array elements to
2
the GL, ifi is equal to the primitive restart index, then the GL does not process
those elements as a vertex. Instead, it is as if the drawing command ended with
the immediately preceding transfer, and another drawing command is immediately
started with the same parameters, but only transferring elementsi + 1 through the
end of the originally speci?ed elements.
2
Note that i is used here to index the successively transferred attribute sets, so that the ?rst set
transferred has i = 0, the second set transferred has i = 1, and so on. i is not the same as the index
of a set within the attribute arrays, which will also depend on either the ?rst or indices arguments,
depending on which drawing command is used.
OpenGL 3.1 - May 28, 20092.8. VERTEXARRAYS 27
2.8.2 Drawing Commands
The command
void DrawArrays(enum mode,int ?rst,sizei count );
constructs a sequence of geometric primitives by transferring elements ?rst through
rst+count 1 of each enabled array to the GL. mode speci?es what kind of prim-
itives are constructed, as de?ned in section 2.6.1. If an array corresponding to a
generic attribute required by a vertex shader is not enabled, then the corresponding
element is taken from the current generic attribute state (see section 2.7).
If an array corresponding to a generic attribute required by a vertex is enabled,
the corresponding current generic attribute value is unde?ned after the execution
of DrawArrays.
Specifying first < 0 results in unde?ned behavior. Generating the error
INVALID_VALUE is recommended in this case.
The command
void MultiDrawArrays(enum mode,int *?rst,
sizei *count,sizei primcount );
behaves identically to DrawArrays except that primcount separate ranges of
elements are speci?ed instead. It has the same effect as:
for (i = 0; i < primcount; i++) f
if (count[i] > 0)
DrawArrays(mode, first[i], count[i]);
g
The command
void DrawElements(enum mode,sizei count,enum type,
void *indices );
constructs a sequence of geometric primitives by successively transferring the
count elements whose indices are stored in the currently bound element array
buffer (see section 2.9.5) at the offset de?ned by indices to the GL. The ith el-
ement transferred by DrawElements will be taken from element indices[i] of
each enabled array. type must be one ofUNSIGNED_BYTE,UNSIGNED_SHORT, or
UNSIGNED_INT, indicating that the index values are of GL typeubyte,ushort,
oruint respectively. mode speci?es what kind of primitives are constructed, as
de?ned in section 2.6.1. If an array corresponding to a generic attribute required
OpenGL 3.1 - May 28, 20092.8. VERTEXARRAYS 28
by a vertex shader is not enabled, then the corresponding element is taken from the
current generic attribute state (see section 2.7).
If an array corresponding to a generic attribute required by a vertex is enabled,
the corresponding current generic attribute value is unde?ned after the execution
of DrawElements.
The command
void MultiDrawElements(enum mode,sizei *count,
enum type,void **indices,sizei primcount );
behaves identically to DrawElements except that primcount separate lists of
elements are speci?ed instead. It has the same effect as:
for (i = 0; i < primcount; i++) f
if (count[i]) > 0)
DrawElements(mode, count[i], type, indices[i]);
g
The command
void DrawRangeElements(enum mode,uint start,
uint end,sizei count,enum type,void *indices );
is a restricted form of DrawElements. mode, count, type, and indices match the
corresponding arguments to DrawElements, with the additional constraint that all
index values identi?ed by indices must lie between start and end inclusive.
Implementations denote recommended maximum amounts of vertex and index
data, which may be queried by calling GetIntegerv with the symbolic constants
MAX_ELEMENTS_VERTICES and MAX_ELEMENTS_INDICES. Ifend start + 1
is greater than the value ofMAX_ELEMENTS_VERTICES, or if count is greater than
the value ofMAX_ELEMENTS_INDICES, then the call may operate at reduced per-
formance. There is no requirement that all vertices in the range [start;end] be
referenced. However, the implementation may partially process unused vertices,
reducing performance from what could be achieved with an optimal index set.
The errorINVALID_VALUE is generated ifend<start. Invalid mode, count,
or type parameters generate the same errors as would the corresponding call to
DrawElements. It is an error for indices to lie outside the range [start;end], but
implementations may not check for this. Such indices will cause implementation-
dependent behavior.
The internal counter instanceID is a 32-bit integer value which may be read by
a vertex shader as gl_InstanceID, as described in section 2.11.7. The value of
this counter is always zero, except as noted below.
OpenGL 3.1 - May 28, 20092.8. VERTEXARRAYS 29
The command
void DrawArraysInstanced(enum mode,int ?rst,
sizei count,sizei primcount );
behaves identically to DrawArrays except that primcount instances of the range
of elements are executed and the value of instanceID advances for each iteration.
It has the same effect as:
if (mode orcount is invalid)
generate appropriate error
else f
for (int i = 0; i < primcount; i++) f
instanceID = i;
DrawArrays(mode, first, count);
g
instanceID = 0;
g
The command
void DrawElementsInstanced(enum mode,sizei count,
enum type,const void *indices,sizei primcount );
behaves identically to DrawElements except that primcount instances of the set of
elements are executed, and the value of instanceID advances for each iteration. It
has the same effect as:
if (mode,count, ortype is invalid)
generate appropriate error
else f
for (int i = 0; i < primcount; i++) f
instanceID = i;
DrawElements(mode, count, type, indices);
g
instanceID = 0;
g
If the number of supported generic vertex attributes (the value of MAX_-
VERTEX_ATTRIBS) is n, then the client state required to implement vertex ar-
rays consists of n boolean values, n memory pointers, n integer stride values,
OpenGL 3.1 - May 28, 20092.9. BUFFEROBJECTS 30
n symbolic constants representing array types,n integers representing values per
element, n boolean values indicating normalization, n boolean values indicating
whether the attribute values are pure integers, and an unsigned integer representing
the restart index.
In the initial state, the boolean values are each false, the memory pointers are
each NULL, the strides are each zero, the array types are each FLOAT, the integers
representing values per element are each four, the normalized and pure integer ?ags
are each false, and the restart index is zero.
2.9 Buffer Objects
Vertex array data are stored in high-performance server memory. GL buffer ob-
jects provide a mechanism that clients can use to allocate, initialize, and render
from such memory.
The command
void GenBuffers(sizei n,uint *buffers );
returns n previously unused buffer object names in buffers. These names are
marked as used, for the purposes of GenBuffers only, but they acquire buffer state
only when they are ?rst bound with BindBuffer (see below), just as if they were
unused.
Buffer objects are deleted by calling
void DeleteBuffers(sizei n,const uint *buffers );
buffers contains n names of buffer objects to be deleted. After a buffer object is
deleted it has no contents, and its name is again unused. Unused names in buffers
are silently ignored, as is the value zero.
A buffer object is created by binding a name returned by GenBuffers to a
buffer target. The binding is effected by calling
void BindBuffer(enum target,uint buffer );
target must be one of the targets listed in table 2.5. If the buffer object named buffer
has not been previously bound, the GL creates a new state vector, initialized with
a zero-sized memory buffer and comprising the state values listed in table 2.6.
Buffer objects created by binding a name returned by GenBuffers to any of
the valid targets are formally equivalent, but the GL may make different choices
about storage location and layout based on the initial binding.
OpenGL 3.1 - May 28, 20092.9. BUFFEROBJECTS 31
Target name Purpose Described in section(s)
ARRAY_BUFFER Vertex attributes 2.9.4
COPY_READ_BUFFER Buffer copy source 2.9.3
COPY_WRITE_BUFFER Buffer copy destination 2.9.3
ELEMENT_ARRAY_BUFFER Vertex array indices 2.9.5
PIXEL_PACK_BUFFER Pixel read target 4.3.1, 6.1
PIXEL_UNPACK_BUFFER Texture data source 3.7
TEXTURE_BUFFER Texture data buffer 3.8.4
TRANSFORM_FEEDBACK_BUFFER Transform feedback buffer 2.15
UNIFORM_BUFFER Uniform block storage 2.11.4
Table 2.5: Buffer object binding targets.
Name Type Initial Value Legal Values
BUFFER_SIZE integer 0 any non-negative integer
BUFFER_USAGE enum STATIC_DRAW STREAM_DRAW,STREAM_READ,
STREAM_COPY,STATIC_DRAW,
STATIC_READ,STATIC_COPY,
DYNAMIC_DRAW,DYNAMIC_READ,
DYNAMIC_COPY
BUFFER_ACCESS enum READ_WRITE READ_ONLY,WRITE_ONLY,
READ_WRITE
BUFFER_ACCESS_FLAGS integer 0 See section 2.9.1
BUFFER_MAPPED boolean FALSE TRUE,FALSE
BUFFER_MAP_POINTER void* NULL address
BUFFER_MAP_OFFSET integer 0 any non-negative integer
BUFFER_MAP_LENGTH integer 0 any non-negative integer
Table 2.6: Buffer object parameters and their values.
OpenGL 3.1 - May 28, 20092.9. BUFFEROBJECTS 32
BindBuffer may also be used to bind an existing buffer object. If the bind is
successful no change is made to the state of the newly bound buffer object, and any
previous binding to target is broken.
BindBuffer fails and an INVALID_OPERATION error is generated if buffer is
not zero or a name returned from a previous call to GenBuffers, or if such a name
has since been deleted with DeleteBuffers.
While a buffer object is bound, GL operations on the target to which it is bound
affect the bound buffer object, and queries of the target to which a buffer object is
bound return state from the bound object. Operations on the target also affect any
other bindings of that object.
If a buffer object is deleted while it is bound, all bindings to that object in
the current context (i.e. in the thread that called DeleteBuffers) are reset to zero.
Bindings to that buffer in other contexts and other threads are not affected, but
attempting to use a deleted buffer in another thread produces unde?ned results,
including but not limited to possible GL errors and rendering corruption. Using
a deleted buffer in another context or thread may not, however, result in program
termination.
Initially, each buffer object target is bound to zero. There is no buffer object
corresponding to the name zero, so client attempts to modify or query buffer object
state for a target bound to zero generate anINVALID_OPERATION error.
The data store of a buffer object is created and initialized by calling
void BufferData(enum target,sizeiptr size,const
void *data,enum usage );
with target set to one of the targets listed in table 2.5. size set to the size of the data
store in basic machine units, and data pointing to the source data in client memory.
If data is non-null, then the source data is copied to the buffer object’s data store.
If data is null, then the contents of the buffer object’s data store are unde?ned.
usage is speci?ed as one of nine enumerated values, indicating the expected
application usage pattern of the data store. The values are:
STREAM_DRAW The data store contents will be speci?ed once by the application,
and used at most a few times as the source for GL drawing and image speci-
?cation commands.
STREAM_READ The data store contents will be speci?ed once by reading data from
the GL, and queried at most a few times by the application.
STREAM_COPY The data store contents will be speci?ed once by reading data from
the GL, and used at most a few times as the source for GL drawing and image
speci?cation commands.
OpenGL 3.1 - May 28, 20092.9. BUFFEROBJECTS 33
Name Value
BUFFER_SIZE size
BUFFER_USAGE usage
BUFFER_ACCESS READ_WRITE
BUFFER_ACCESS_FLAGS 0
BUFFER_MAPPED FALSE
BUFFER_MAP_POINTER NULL
BUFFER_MAP_OFFSET 0
BUFFER_MAP_LENGTH 0
Table 2.7: Buffer object initial state.
STATIC_DRAW The data store contents will be speci?ed once by the application,
and used many times as the source for GL drawing and image speci?cation
commands.
STATIC_READ The data store contents will be speci?ed once by reading data from
the GL, and queried many times by the application.
STATIC_COPY The data store contents will be speci?ed once by reading data from
the GL, and used many times as the source for GL drawing and image spec-
i?cation commands.
DYNAMIC_DRAW The data store contents will be respeci?ed repeatedly by the ap-
plication, and used many times as the source for GL drawing and image
speci?cation commands.
DYNAMIC_READ The data store contents will be respeci?ed repeatedly by reading
data from the GL, and queried many times by the application.
DYNAMIC_COPY The data store contents will be respeci?ed repeatedly by reading
data from the GL, and used many times as the source for GL drawing and
image speci?cation commands.
usage is provided as a performance hint only. The speci?ed usage value does
not constrain the actual usage pattern of the data store.
BufferData deletes any existing data store, and sets the values of the buffer
object’s state variables as shown in table 2.7.
Clients must align data elements consistent with the requirements of the client
platform, with an additional base-level requirement that an offset within a buffer to
a datum comprisingN basic machine units be a multiple ofN.
OpenGL 3.1 - May 28, 20092.9. BUFFEROBJECTS 34
If the GL is unable to create a data store of the requested size, the errorOUT_-
OF_MEMORY is generated.
To modify some or all of the data contained in a buffer object’s data store, the
client may use the command
void BufferSubData(enum target,intptr offset,
sizeiptr size,const void *data );
with target set to one of the targets listed in table 2.5. offset and size indicate the
range of data in the buffer object that is to be replaced, in terms of basic machine
units. data speci?es a region of client memory size basic machine units in length,
containing the data that replace the speci?ed buffer range. An INVALID_VALUE
error is generated if offset or size is less than zero or if oset + size is greater than
the value of BUFFER_SIZE. An INVALID_OPERATION error is generated if any
part of the speci?ed buffer range is mapped with MapBufferRange or MapBuffer
(see section 2.9.1).
2.9.1 Mapping and Unmapping Buffer Data
All or part of the data store of a buffer object may be mapped into the client’s
address space by calling
void *MapBufferRange(enum target,intptr offset,
sizeiptr length,bitfield access );
with target set to one of the targets listed in table 2.5. offset and length indicate the
range of data in the buffer object that is to be mapped, in terms of basic machine
units. access is a bit?eld containing ?ags which describe the requested mapping.
These ?ags are described below.
If no error occurs, a pointer to the beginning of the mapped range is returned
once all pending operations on that buffer have completed, and may be used to
modify and/or query the corresponding range of the buffer, according to the fol-
lowing ?ag bits set in access:
 MAP_READ_BIT indicates that the returned pointer may be used to read
buffer object data. No GL error is generated if the pointer is used to query
a mapping which excludes this ?ag, but the result is unde?ned and system
errors (possibly including program termination) may occur.
 MAP_WRITE_BIT indicates that the returned pointer may be used to modify
buffer object data. No GL error is generated if the pointer is used to modify
a mapping which excludes this ?ag, but the result is unde?ned and system
errors (possibly including program termination) may occur.
OpenGL 3.1 - May 28, 20092.9. BUFFEROBJECTS 35
Pointer values returned by MapBufferRange may not be passed as parameter
values to GL commands. For example, they may not be used to specify array
pointers, or to specify or query pixel or texture image data; such actions produce
unde?ned results, although implementations may not check for such behavior for
performance reasons.
Mappings to the data stores of buffer objects may have nonstandard perfor-
mance characteristics. For example, such mappings may be marked as uncacheable
regions of memory, and in such cases reading from them may be very slow. To en-
sure optimal performance, the client should use the mapping in a fashion consistent
with the values of BUFFER_USAGE and access. Using a mapping in a fashion in-
consistent with these values is liable to be multiple orders of magnitude slower
than using normal memory.
The following optional ?ag bits in access may be used to modify the mapping:
 MAP_INVALIDATE_RANGE_BIT indicates that the previous contents of the
speci?ed range may be discarded. Data within this range are unde?ned with
the exception of subsequently written data. No GL error is generated if sub-
sequent GL operations access unwritten data, but the result is unde?ned and
system errors (possibly including program termination) may occur. This ?ag
may not be used in combination withMAP_READ_BIT.
 MAP_INVALIDATE_BUFFER_BIT indicates that the previous contents of the
entire buffer may be discarded. Data within the entire buffer are unde?ned
with the exception of subsequently written data. No GL error is generated if
subsequent GL operations access unwritten data, but the result is unde?ned
and system errors (possibly including program termination) may occur. This
?ag may not be used in combination withMAP_READ_BIT.
 MAP_FLUSH_EXPLICIT_BIT indicates that one or more discrete subranges
of the mapping may be modi?ed. When this ?ag is set, modi?cations to
each subrange must be explicitly ?ushed by calling FlushMappedBuffer-
Range. No GL error is set if a subrange of the mapping is modi?ed and
not ?ushed, but data within the corresponding subrange of the buffer are un-
de?ned. This ?ag may only be used in conjunction with MAP_WRITE_BIT.
When this option is selected, ?ushing is strictly limited to regions that are
explicitly indicated with calls to FlushMappedBufferRange prior to un-
map; if this option is not selected UnmapBuffer will automatically ?ush the
entire mapped range when called.
 MAP_UNSYNCHRONIZED_BIT indicates that the GL should not attempt to
synchronize pending operations on the buffer prior to returning from Map-
BufferRange. No GL error is generated if pending operations which source
OpenGL 3.1 - May 28, 20092.9. BUFFEROBJECTS 36
Name Value
1
BUFFER_ACCESS Depends on access
BUFFER_ACCESS_FLAGS access
BUFFER_MAPPED TRUE
BUFFER_MAP_POINTER pointer to the data store
BUFFER_MAP_OFFSET offset
BUFFER_MAP_LENGTH length
Table 2.8: Buffer object state set by MapBufferRange.
1
BUFFER_ACCESS is set toREAD_ONLY,WRITE_ONLY, orREAD_WRITE if access
& (MAP_READ_BITjMAP_WRITE_BIT) is respectively MAP_READ_BIT, MAP_-
WRITE_BIT, orMAP_READ_BITjMAP_WRITE_BIT.
or modify the buffer overlap the mapped region, but the result of such previ-
ous and any subsequent operations is unde?ned.
A successful MapBufferRange sets buffer object state values as shown in ta-
ble 2.8.
Errors
If an error occurs, MapBufferRange returns aNULL pointer.
AnINVALID_VALUE error is generated if offset or length is negative, if oset+
length is greater than the value ofBUFFER_SIZE, or if access has any bits set other
than those de?ned above.
An INVALID_OPERATION error is generated for any of the following condi-
tions:
 The buffer is already in a mapped state.
 NeitherMAP_READ_BIT norMAP_WRITE_BIT is set.
 MAP_READ_BIT is set and any of MAP_INVALIDATE_RANGE_BIT, MAP_-
INVALIDATE_BUFFER_BIT, orMAP_UNSYNCHRONIZED_BIT is set.
 MAP_FLUSH_EXPLICIT_BIT is set andMAP_WRITE_BIT is not set.
An OUT_OF_MEMORY error is generated if MapBufferRange fails because
memory for the mapping could not be obtained.
No error is generated if memory outside the mapped range is modi?ed or
queried, but the result is unde?ned and system errors (possibly including program
termination) may occur.
OpenGL 3.1 - May 28, 20092.9. BUFFEROBJECTS 37
The entire data store of a buffer object can be mapped into the client’s address
space by calling
void *MapBuffer(enum target,enum access );
MapBuffer is equivalent to calling MapBufferRange with the same target, offset
of zero, length equal to the value ofBUFFER_SIZE, and the access value passed to
MapBufferRange equal to
 MAP_READ_BIT, if access isREAD_ONLY
 MAP_WRITE_BIT, if access isWRITE_ONLY
 MAP_READ_BITjMAP_WRITE_BIT, if access isREAD_WRITE.
INVALID_ENUM is generated if access is not one of the values described above.
Other errors are generated as described above for MapBufferRange.
If a buffer is mapped with theMAP_FLUSH_EXPLICIT_BIT ?ag, modi?cations
to the mapped range may be indicated by calling
void FlushMappedBufferRange(enum target,intptr offset,
sizeiptr length );
with target set to one of the targets listed in table 2.5. offset and length indi-
cate a modi?ed subrange of the mapping, in basic machine units. The speci?ed
subrange to ?ush is relative to the start of the currently mapped range of buffer.
FlushMappedBufferRange may be called multiple times to indicate distinct sub-
ranges of the mapping which require ?ushing.
Errors
An INVALID_VALUE error is generated if offset or length is negative, or if
oset + length exceeds the size of the mapping.
AnINVALID_OPERATION error is generated if zero is bound to target.
An INVALID_OPERATION error is generated if the buffer bound to target is
not mapped, or is mapped without theMAP_FLUSH_EXPLICIT_BIT ?ag.
Unmapping Buffers
After the client has speci?ed the contents of a mapped buffer range, and before
the data in that range are dereferenced by any GL commands, the mapping must be
relinquished by calling
boolean UnmapBuffer(enum target );
OpenGL 3.1 - May 28, 20092.9. BUFFEROBJECTS 38
with target set to one of the targets listed in table 2.5. Unmapping a mapped buffer
object invalidates the pointer to its data store and sets the object’s BUFFER_-
MAPPED, BUFFER_MAP_POINTER, BUFFER_ACCESS_FLAGS, BUFFER_MAP_-
OFFSET, and BUFFER_MAP_LENGTH state variables to the initial values shown in
table 2.7.
UnmapBuffer returns TRUE unless data values in the buffer’s data store have
become corrupted during the period that the buffer was mapped. Such corruption
can be the result of a screen resolution change or other window system-dependent
event that causes system heaps such as those for high-performance graphics mem-
ory to be discarded. GL implementations must guarantee that such corruption can
occur only during the periods that a buffer’s data store is mapped. If such corrup-
tion has occurred, UnmapBuffer returns FALSE, and the contents of the buffer’s
data store become unde?ned.
If the buffer data store is already in the unmapped state, UnmapBuffer returns
FALSE, and an INVALID_OPERATION error is generated. However, unmapping
that occurs as a side effect of buffer deletion or reinitialization is not an error.
Effects of Mapping Buffers on Other GL Commands
Any GL command that attempts to read data from a buffer object will fail and
generate an INVALID_OPERATION error if the object is mapped at the time the
command is issued.
2.9.2 Effects of Accessing Outside Buffer Bounds
Most, but not all GL commands operating on buffer objects will detect attempts to
read from or write to a location in a bound buffer object at an offset less than zero,
or greater than or equal to the buffer’s size. When such an attempt is detected, a
GL error will be generated. Any command which does not detect these attempts,
and performs such an invalid read or write, has unde?ned results, and may result
in GL interruption or termination.
2.9.3 Copying Between Buffers
All or part of the data store of a buffer object may be copied to the data store of
another buffer object by calling
void *CopyBufferSubData(enum readtarget,
enum writetarget,intptr readoffset,intptr writeoffset,
sizeiptr size );
OpenGL 3.1 - May 28, 20092.9. BUFFEROBJECTS 39
with readtarget and writetarget each set to one of the targets listed in table 2.5.
While any of these targets may be used, the COPY_READ_BUFFER and COPY_-
WRITE_BUFFER targets are provided speci?cally for copies, so that they can be
done without affecting other buffer binding targets that may be in use. writeoffset
and size specify the range of data in the buffer object bound to writetarget that is
to be replaced, in terms of basic machine units. readoffset and size specify the
range of data in the buffer object bound to readtarget that is to be copied to the
corresponding region of writetarget.
AnINVALID_VALUE error is generated if any of readoffset, writeoffset, or size
are negative, if readoset + size exceeds the size of the buffer object bound to
readtarget, or if writeoset + size exceeds the size of the buffer object bound to
writetarget.
An INVALID_VALUE error is generated if the same buffer object is bound to
both readtarget and writetarget, and the ranges [readoset; readoset+size) and
[writeoset; writeoset+size) overlap.
An INVALID_OPERATION error is generated if zero is bound to readtarget or
writetarget.
An INVALID_OPERATION error is generated if the buffer objects bound to
either readtarget or writetarget are mapped.
2.9.4 Vertex Arrays in Buffer Objects
Blocks of vertex array data are stored in buffer objects with the same format and
layout options described in section 2.8. A buffer object binding point is added to
the client state associated with each vertex array type. The commands that specify
the locations and organizations of vertex arrays copy the buffer object name that is
bound toARRAY_BUFFER to the binding point corresponding to the vertex array of
the type being speci?ed. For example, the VertexAttribPointer command copies
the value of ARRAY_BUFFER_BINDING (the queriable name of the buffer binding
corresponding to the targetARRAY_BUFFER) to the client state variableVERTEX_-
ATTRIB_ARRAY_BUFFER_BINDING for the speci?ed index.
Rendering commands DrawArrays, and the other drawing commands de?ned
in section 2.8.2 operate as previously de?ned, where data for enabled generic
attribute arrays are sourced from buffer objects. When an array is sourced from a
buffer object, the pointer value of that array is used to compute an offset, in basic
machine units, into the data store of the buffer object. This offset is computed by
subtracting a null pointer from the pointer value, where both pointers are treated as
pointers to basic machine units.
If any enabled array’s buffer binding is zero when DrawArrays or one of the
other drawing commands de?ned in section 2.8.2 is called, the result is unde?ned.
OpenGL 3.1 - May 28, 20092.10. VERTEXARRAYOBJECTS 40
2.9.5 Array Indices in Buffer Objects
Blocks of array indices are stored in buffer objects in the formats described by the
type parameter of DrawElements (see section 2.8.2).
A buffer object is bound toELEMENT_ARRAY_BUFFER by calling BindBuffer
with target set to ELEMENT_ARRAY_BUFFER, and buffer set to the name of the
buffer object. If no corresponding buffer object exists, one is initialized as de?ned
in section 2.9.
DrawElements, DrawRangeElements, and DrawElementsInstanced source
their indices from the buffer object whose name is bound toELEMENT_ARRAY_-
BUFFER, using their indices parameters as offsets into the buffer object in the
same fashion as described in section 2.9.4. MultiDrawElements also sources its
indices from that buffer object, using its indices parameter as a pointer to an array
of pointers that represent offsets into the buffer object. If zero is bound to
ELEMENT_ARRAY_BUFFER, the result of these drawing commands is unde?ned.
In some cases performance will be optimized by storing indices and array data
in separate buffer objects, and by creating those buffer objects with the correspond-
ing binding points.
2.9.6 Buffer Object State
The state required to support buffer objects consists of binding names for the array
buffer, element buffer, pixel unpack buffer, and pixel pack buffer. Additionally,
each vertex array has an associated binding so there is a buffer object binding for
each of the vertex attribute arrays. The initial values for all buffer object bindings
is zero.
The state of each buffer object consists of a buffer size in basic machine units, a
usage parameter, an access parameter, a mapped boolean, two integers for the offset
and size of the mapped region, a pointer to the mapped buffer (NULL if unmapped),
and the sized array of basic machine units for the buffer data.
2.10 Vertex Array Objects
The buffer objects that are to be used by the vertex stage of the GL are collected
together to form a vertex array object. All state related to the de?nition of data
used by the vertex processor is encapsulated in a vertex array object.
The command
void GenVertexArrays(sizei n,uint *arrays );
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 41
returns n previous unused vertex array object names in arrays. These names are
marked as used, for the purposes of GenVertexArrays only, but they acquire array
state only when they are ?rst bound, just as if they were unused.
Vertex array objects are deleted by calling
void DeleteVertexArrays(sizei n,const uint *arrays );
arrays contains n names of vertex array objects to be deleted. Once a vertex array
object is deleted it has no contents and its name is again unused. If a vertex array
object that is currently bound is deleted, the binding for that object reverts to zero
and the default vertex array becomes current. Unused names in arrays are silently
ignored, as is the value zero.
A vertex array object is created by binding a name returned by GenVertexAr-
rays with the command
void BindVertexArray(uint array );
array is the vertex array object name. The resulting vertex array object is a new
state vector, comprising all the state values listed in tables 6.3 and 6.4.
BindVertexArray may also be used to bind an existing vertex array object.
If the bind is successful no change is made to the state of the bound vertex array
object, and any previous binding is broken.
The currently bound vertex array object is used for all commands which modify
vertex array state, such as VertexAttribPointer and EnableVertexAttribArray;
all commands which draw from vertex arrays, such as DrawArrays and DrawEle-
ments; and all queries of vertex array state (see chapter 6).
BindVertexArray fails and anINVALID_OPERATION error is generated if ar-
ray is not zero or a name returned from a previous call to GenVertexArrays, or if
such a name has since been deleted with DeleteVertexArrays.
AnINVALID_OPERATION error is generated if any of the *Pointer commands
specifying the location and organization of vertex array data are called while zero
is bound to theARRAY_BUFFER buffer object binding point, and the pointer argu-
3
ment is notNULL .
2.11 Vertex Shaders
Vertex shaders describe the operations that occur on vertex values and their asso-
ciated data.
3
This error makes it impossible to create a vertex array object containing client array pointers,
while still allowing buffer objects to be unbound.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 42
A vertex shader is an array of strings containing source code for the operations
that are meant to occur on each vertex that is processed. The language used for
vertex shaders is described in the OpenGL Shading Language Specification.
To use a vertex shader, shader source code is ?rst loaded into a shader ob-
ject and then compiled. One or more vertex shader objects are then attached to
a program object. A program object is then linked, which generates executable
code from all the compiled shader objects attached to the program. When a linked
program object is used as the current program object, the executable code for the
vertex shaders it contains is used to process vertices.
In addition to vertex shaders, fragment shaders can be created, compiled, and
linked into program objects. Fragment shaders affect the processing of fragments
during rasterization, and are described in section 3.9. A single program object can
contain both vertex and fragment shaders.
When the program object currently in use includes a vertex shader, its vertex
shader is considered active and is used to process vertices. If the program object
has no vertex shader, or no program object is currently in use, the results of vertex
shader execution are unde?ned.
A vertex shader can reference a number of variables as it executes. Vertex
attributes are the per-vertex values speci?ed in section 2.7. Uniforms are per-
program variables that are constant during program execution. Samplers are a
special form of uniform used for texturing (section 3.8). Varying variables hold
the results of vertex shader execution that are used later in the pipeline. Each of
these variable types is described in more detail below.
2.11.1 Shader Objects
The source code that makes up a program that gets executed by one of the pro-
grammable stages is encapsulated in one or more shader objects.
The name space for shader objects is the unsigned integers, with zero reserved
for the GL. This name space is shared with program objects. The following sections
de?ne commands that operate on shader and program objects by name. Commands
that accept shader or program object names will generate the error INVALID_-
VALUE if the provided name is not the name of either a shader or program object
andINVALID_OPERATION if the provided name identi?es an object that is not the
expected type.
To create a shader object, use the command
uint CreateShader(enum type );
The shader object is empty when it is created. The type argument speci?es the type
of shader object to be created. For vertex shaders, type must beVERTEX_SHADER.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 43
A non-zero name that can be used to reference the shader object is returned. If an
error occurs, zero will be returned.
The command
void ShaderSource(uint shader,sizei count,const
char **string,const int *length );
loads source code into the shader object named shader. string is an array of count
pointers to optionally null-terminated character strings that make up the source
code. The length argument is an array with the number ofchars in each string (the
string length). If an element in length is negative, its accompanying string is null-
terminated. If length isNULL, all strings in the string argument are considered null-
terminated. The ShaderSource command sets the source code for the shader to
the text strings in the string array. If shader previously had source code loaded into
it, the existing source code is completely replaced. Any length passed in excludes
the null terminator in its count.
The strings that are loaded into a shader object are expected to form the source
code for a valid shader as de?ned in the OpenGL Shading Language Specification.
Once the source code for a shader has been loaded, a shader object can be
compiled with the command
void CompileShader(uint shader );
Each shader object has a boolean status, COMPILE_STATUS, that is modi?ed as
a result of compilation. This status can be queried with GetShaderiv (see sec-
tion 6.1.9). This status will be set to TRUE if shader was compiled without errors
and is ready for use, and FALSE otherwise. Compilation can fail for a variety of
reasons as listed in the OpenGL Shading Language Specification. If Compile-
Shader failed, any information about a previous compile is lost. Thus a failed
compile does not restore the old state of shader.
Changing the source code of a shader object with ShaderSource does not
change its compile status or the compiled shader code.
Each shader object has an information log, which is a text string that is over-
written as a result of compilation. This information log can be queried with Get-
ShaderInfoLog to obtain more information about the compilation attempt (see
section 6.1.9).
Shader objects can be deleted with the command
void DeleteShader(uint shader );
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 44
If shader is not attached to any program object, it is deleted immediately. Oth-
erwise, shader is ?agged for deletion and will be deleted when it is no longer
attached to any program object. If an object is ?agged for deletion, its boolean
status bit DELETE_STATUS is set to true. The value of DELETE_STATUS can be
queried with GetShaderiv (see section 6.1.9). DeleteShader will silently ignore
the value zero.
2.11.2 Program Objects
The shader objects that are to be used by the programmable stages of the GL are
collected together to form a program object. The programs that are executed by
these programmable stages are called executables. All information necessary for
de?ning an executable is encapsulated in a program object. A program object is
created with the command
uint CreateProgram(void );
Program objects are empty when they are created. A non-zero name that can be
used to reference the program object is returned. If an error occurs, 0 will be
returned.
To attach a shader object to a program object, use the command
void AttachShader(uint program,uint shader );
The errorINVALID_OPERATION is generated if shader is already attached to pro-
gram.
Shader objects may be attached to program objects before source code has
been loaded into the shader object, or before the shader object has been compiled.
Multiple shader objects of the same type may be attached to a single program
object, and a single shader object may be attached to more than one program object.
To detach a shader object from a program object, use the command
void DetachShader(uint program,uint shader );
The errorINVALID_OPERATION is generated if shader is not attached to program.
If shader has been ?agged for deletion and is not attached to any other program
object, it is deleted.
In order to use the shader objects contained in a program object, the program
object must be linked. The command
void LinkProgram(uint program );
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 45
will link the program object named program. Each program object has a boolean
status, LINK_STATUS, that is modi?ed as a result of linking. This status can be
queried with GetProgramiv (see section 6.1.9). This status will be set to TRUE if
a valid executable is created, and FALSE otherwise. Linking can fail for a variety
of reasons as speci?ed in the OpenGL Shading Language Specification. Linking
will also fail if one or more of the shader objects, attached to program are not
compiled successfully, or if more active uniform or active sampler variables are
used in program than allowed (see section 2.11.5). If LinkProgram failed, any
information about a previous link of that program object is lost. Thus, a failed link
does not restore the old state of program.
Each program object has an information log that is overwritten as a result of a
link operation. This information log can be queried with GetProgramInfoLog to
obtain more information about the link operation or the validation information (see
section 6.1.9).
If a valid executable is created, it can be made part of the current rendering
state with the command
void UseProgram(uint program );
This command will install the executable code as part of current rendering state if
the program object program contains valid executable code, i.e. has been linked
successfully. If UseProgram is called with program set to 0, then the current
rendering state refers to an invalid program object, and the results of vertex and
fragment shader execution are unde?ned. However, this is not an error. If program
has not been successfully linked, the errorINVALID_OPERATION is generated and
the current rendering state is not modi?ed.
While a program object is in use, applications are free to modify attached
shader objects, compile attached shader objects, attach additional shader objects,
and detach shader objects. These operations do not affect the link status or exe-
cutable code of the program object.
If the program object that is in use is re-linked successfully, the LinkProgram
command will install the generated executable code as part of the current rendering
state if the speci?ed program object was already in use as a result of a previous call
to UseProgram.
If that program object that is in use is re-linked unsuccessfully, the link status
will be set to FALSE, but existing executable and associated state will remain part
of the current rendering state until a subsequent call to UseProgram removes it
from use. After such a program is removed from use, it can not be made part of the
current rendering state until it is successfully re-linked.
Program objects can be deleted with the command
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 46
void DeleteProgram(uint program );
If program is not the current program for any GL context, it is deleted immediately.
Otherwise, program is ?agged for deletion and will be deleted when it is no longer
the current program for any context. When a program object is deleted, all shader
objects attached to it are detached. DeleteProgram will silently ignore the value
zero.
2.11.3 Vertex Attributes
Vertex shaders can de?ne named attribute variables, which are bound to the generic
vertex attributes that are set by VertexAttrib*. This binding can be speci?ed by
the application before the program is linked, or automatically assigned by the GL
when the program is linked.
When an attribute variable declared as afloat,vec2,vec3 orvec4 is bound
to a generic attribute indexi, its value(s) are taken from thex, (x;y), (x;y;z), or
(x;y;z;w) components, respectively, of the generic attributei. When an attribute
variable is declared as a mat2, mat3x2 or mat4x2, its matrix columns are taken
from the (x;y) components of generic attributesi andi+1 (mat2), from attributes
i throughi + 2 (mat3x2), or from attributesi throughi + 3 (mat4x2). When an
attribute variable is declared as a mat2x3, mat3 or mat4x3, its matrix columns
are taken from the (x;y;z) components of generic attributesi andi + 1 (mat2x3),
from attributesi throughi +2 (mat3), or from attributesi throughi +3 (mat4x3).
When an attribute variable is declared as a mat2x4, mat3x4 or mat4, its matrix
columns are taken from the (x;y;z;w) components of generic attributesi andi+1
(mat2x4), from attributesi throughi + 2 (mat3x4), or from attributesi through
i + 3 (mat4).
A generic attribute variable is considered active if it is determined by the com-
piler and linker that the attribute may be accessed when the shader is executed. At-
tribute variables that are declared in a vertex shader but never used will not count
against the limit. In cases where the compiler and linker cannot make a conclusive
determination, an attribute will be considered active. A program object will fail to
link if the number of active vertex attributes exceedsMAX_VERTEX_ATTRIBS.
To determine the set of active vertex attributes used by a program, and to de-
termine their types, use the command:
void GetActiveAttrib(uint program,uint index,
sizei bufSize,sizei *length,int *size,enum *type,
char *name );
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 47
This command provides information about the attribute selected by index. An in-
dex of 0 selects the ?rst active attribute, and an index ofACTIVE_ATTRIBUTES 1
selects the last active attribute. The value ofACTIVE_ATTRIBUTES can be queried
with GetProgramiv (see section 6.1.9). If index is greater than or equal to
ACTIVE_ATTRIBUTES, the error INVALID_VALUE is generated. Note that index
simply identi?es a member in a list of active attributes, and has no relation to the
generic attribute that the corresponding variable is bound to.
The parameter program is the name of a program object for which the com-
mand LinkProgram has been issued in the past. It is not necessary for program to
have been linked successfully. The link could have failed because the number of
active attributes exceeded the limit.
The name of the selected attribute is returned as a null-terminated string in
name. The actual number of characters written into name, excluding the null termi-
nator, is returned in length. If length isNULL, no length is returned. The maximum
number of characters that may be written into name, including the null termina-
tor, is speci?ed by bufSize. The returned attribute name must be the name of a
generic attribute. The length of the longest attribute name in program is given by
ACTIVE_ATTRIBUTE_MAX_LENGTH, which can be queried with GetProgramiv
(see section 6.1.9).
For the selected attribute, the type of the attribute is returned into type.
The size of the attribute is returned into size. The value in size is in units of
the type returned in type. The type returned can be any of FLOAT, FLOAT_-
VEC2, FLOAT_VEC3, FLOAT_VEC4, FLOAT_MAT2, FLOAT_MAT3, FLOAT_MAT4,
FLOAT_MAT2x3, FLOAT_MAT2x4, FLOAT_MAT3x2, FLOAT_MAT3x4, FLOAT_-
MAT4x2,FLOAT_MAT4x3,INT,INT_VEC2,INT_VEC3,INT_VEC4,UNSIGNED_-
INT,UNSIGNED_INT_VEC2,UNSIGNED_INT_VEC3, orUNSIGNED_INT_VEC4.
If an error occurred, the return parameters length, size, type and name will be
unmodi?ed.
This command will return as much information about active attributes as pos-
sible. If no information is available, length will be set to zero and name will be an
empty string. This situation could arise if GetActiveAttrib is issued after a failed
link.
After a program object has been linked successfully, the bindings of attribute
variable names to indices can be queried. The command
int GetAttribLocation(uint program,const char *name );
returns the generic attribute index that the attribute variable named name was bound
to when the program object named program was last linked. name must be a null-
terminated string. If name is active and is an attribute matrix, GetAttribLocation
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 48
returns the index of the ?rst column of that matrix. If program has not been suc-
cessfully linked, the error INVALID_OPERATION is generated. If name is not an
active attribute, or if an error occurs, -1 will be returned.
The binding of an attribute variable to a generic attribute index can also be
speci?ed explicitly. The command
void BindAttribLocation(uint program,uint index,const
char *name );
speci?es that the attribute variable named name in program program should be
bound to generic vertex attribute index when the program is next linked. If name
was bound previously, its assigned binding is replaced with index. name must be a
null-terminated string. The errorINVALID_VALUE is generated if index is equal or
greater thanMAX_VERTEX_ATTRIBS. BindAttribLocation has no effect until the
program is linked. In particular, it doesn’t modify the bindings of active attribute
variables in a program that has already been linked.
When a program is linked, any active attributes without a binding speci?ed
through BindAttribLocation will automatically be bound to vertex attributes by
the GL. Such bindings can be queried using the command GetAttribLocation.
LinkProgram will fail if the assigned binding of an active attribute variable would
cause the GL to reference a non-existent generic attribute (one greater than or
equal to MAX_VERTEX_ATTRIBS). LinkProgram will fail if the attribute bind-
ings assigned by BindAttribLocation do not leave not enough space to assign a
location for an active matrix attribute, which requires multiple contiguous generic
attributes.
BindAttribLocation may be issued before any vertex shader objects are at-
tached to a program object. Hence it is allowed to bind any name to an index,
including a name that is never used as an attribute in any vertex shader object. As-
signed bindings for attribute variables that do not exist or are not active are ignored.
The values of generic attributes sent to generic attribute index i are part of
current state. If a new program object has been made active, then these values
will be tracked by the GL in such a way that the same values will be observed by
attributes in the new program object that are also bound to indexi.
It is possible for an application to bind more than one attribute name to the
same location. This is referred to as aliasing. This will only work if only one of
the aliased attributes is active in the executable program, or if no path through the
shader consumes more than one attribute of a set of attributes aliased to the same
location. A link error can occur if the linker determines that every path through the
shader consumes multiple aliased attributes, but implementations are not required
to generate an error in this case. The compiler and linker are allowed to assume that
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 49
no aliasing is done, and may employ optimizations that work only in the absence
of aliasing.
2.11.4 Uniform Variables
Shaders can declare named uniform variables, as described in the OpenGL Shading
Language Specification. Values for these uniforms are constant over a primitive,
and typically they are constant across many primitives. Uniforms are program
object-speci?c state. They retain their values once loaded, and their values are
restored whenever a program object is used, as long as the program object has not
been re-linked. A uniform is considered active if it is determined by the compiler
and linker that the uniform will actually be accessed when the executable code
is executed. In cases where the compiler and linker cannot make a conclusive
determination, the uniform will be considered active.
Sets of uniforms can be grouped into uniform blocks. The values of each uni-
form in such a set are extracted from the data store of a buffer object corresponding
to the uniform block. OpenGL Shading Language syntax serves to delimit named
blocks of uniforms that can be backed by a buffer object. These are referred to
as named uniform blocks, and are assigned a uniform block index. Uniforms that
are declared outside of a named uniform block are said to be part of the default
uniform block. Default uniform blocks have no name or uniform block index. Like
uniforms, uniform blocks can be active or inactive. Active uniform blocks are those
that contain active uniforms after a program has been compiled and linked.
The amount of storage available for uniform variables in the default uniform
block accessed by a vertex shader is speci?ed by the value of the implementation-
dependent constant MAX_VERTEX_UNIFORM_COMPONENTS. The total amount of
combined storage available for uniform variables in all uniform blocks accessed
by a vertex shader (including the default uniform block) is speci?ed by the value
of the implementation-dependent constantMAX_COMBINED_VERTEX_UNIFORM_-
COMPONENTS. These values represent the numbers of individual ?oating-point,
integer, or boolean values that can be held in uniform variable storage for a vertex
shader. A link error is generated if an attempt is made to utilize more than the space
available for vertex shader uniform variables.
When a program is successfully linked, all active uniforms belonging to the
program object’s default uniform block are initialized as de?ned by the version of
the OpenGL Shading Language used to compile the program. A successful link
will also generate a location for each active uniform in the default uniform block.
The values of active uniforms in the default uniform block can be changed using
this location and the appropriate Uniform* command (see below). These locations
are invalidated and new ones assigned after each successful re-link.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 50
Similarly, when a program is successfully linked, all active uniforms belong-
ing to the program’s named uniform blocks are assigned offsets (and strides for
array and matrix type uniforms) within the uniform block according to layout rules
described below. Uniform buffer objects provide the storage for named uniform
blocks, so the values of active uniforms in named uniform blocks may be changed
by modifying the contents of the buffer object using commands such as Buffer-
Data, BufferSubData, MapBuffer, and UnmapBuffer. Uniforms in a named
uniform block are not assigned a location and may be be modi?ed using the Uni-
form* commands. The offsets and strides of all active uniforms belonging to
named uniform blocks of a program object are invalidated and new ones assigned
after each successful re-link.
To ?nd the location within a program object of an active uniform variable as-
sociated with the default uniform block, use the command
int GetUniformLocation(uint program,const
char *name );
This command will return the location of uniform variable name if it is associ-
ated with the default uniform block. name must be a null-terminated string, without
white space. The value -1 will be returned if if name does not correspond to an
active uniform variable name in program, or if name is associated with a named
uniform block.
If program has not been successfully linked, the error INVALID_OPERATION
is generated. After a program is linked, the location of a uniform variable will not
change, unless the program is re-linked.
A valid name cannot be a structure, an array of structures, or any portion of
a single vector or a matrix. In order to identify a valid name, the "." (dot) and
"[]" operators can be used in name to specify a member of a structure or element
of an array.
The ?rst element of a uniform array is identi?ed using the name of the uniform
array appended with"[0]". Except if the last part of the string name indicates a
uniform array, then the location of the ?rst element of that array can be retrieved
by either using the name of the uniform array, or the name of the uniform array
appended with"[0]".
Named uniform blocks, like uniforms, are identi?ed by name strings. Uniform
block indices corresponding to uniform block names can be queried by calling
uint GetUniformBlockIndex(uint program,const
char *uniformBlockName );
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 51
program is the name of a program object for which the command LinkProgram
has been issued in the past. It is not necessary for program to have been linked
successfully. The link could have failed because the number of active uniforms
exceeded the limit.
uniformBlockName must contain a null-terminated string specifying the name
of a uniform block.
GetUniformBlockIndex returns the uniform block index for the uniform block
named uniformBlockName of program. If uniformBlockName does not identify an
active uniform block of program, or an error occurred, then INVALID_INDEX is
returned. The indices of the active uniform blocks of a program are assigned in
consecutive order, beginning with zero.
An active uniform block’s name string can be queried from its uniform block
index by calling
void GetActiveUniformBlockName(uint program,
uint uniformBlockIndex,sizei bufSize,sizei *length,
char *uniformBlockName );
program is the name of a program object for which the command LinkProgram
has been issued in the past. It is not necessary for program to have been linked
successfully. The link could have failed because the number of active uniforms
exceeded the limit.
uniformBlockIndex must be an active uniform block index of program, in the
range zero to the value ofACTIVE_UNIFORM_BLOCKS - 1. The value ofACTIVE_-
UNIFORM_BLOCKS can be queried with GetProgramiv (see section 6.1.9). If
uniformBlockIndex is greater than or equal to the value of ACTIVE_UNIFORM_-
BLOCKS, the errorINVALID_VALUE is generated.
The string name of the uniform block identi?ed by uniformBlockIndex is re-
turned into uniformBlockName. The name is null-terminated. The actual number
of characters written into uniformBlockName, excluding the null terminator, is re-
turned in length. If length isNULL, no length is returned.
bufSize contains the maximum number of characters (including the null termi-
nator) that will be written back to uniformBlockName.
If an error occurs, nothing will be written to uniformBlockName or length.
Information about an active uniform block can be queried by calling
void GetActiveUniformBlockiv(uint program,
uint uniformBlockIndex,enum pname,int *params );
program is the name of a program object for which the command LinkProgram
has been issued in the past. It is not necessary for program to have been linked
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 52
successfully. The link could have failed because the number of active uniforms
exceeded the limit.
uniformBlockIndex is an active uniform block index of program. If uniform-
BlockIndex is greater than or equal to the value ofACTIVE_UNIFORM_BLOCKS, or
is not the index of an active uniform block in program, the errorINVALID_VALUE
is generated.
If no error occurs, the uniform block parameter(s) speci?ed by pname are re-
turned in params. Otherwise, nothing will be written to params.
If pname is UNIFORM_BLOCK_BINDING, then the index of the uniform buffer
binding point last selected by the uniform block speci?ed by uniformBlockIndex
for program is returned. If no uniform block has been previously speci?ed, zero is
returned.
If pname is UNIFORM_BLOCK_DATA_SIZE, then the implementation-
dependent minimum total buffer object size, in basic machine units, required to
hold all active uniforms in the uniform block identi?ed by uniformBlockIndex is
returned. It is neither guaranteed nor expected that a given implementation will
arrange uniform values as tightly packed in a buffer object. The exception to this is
thestd140 uniform block layout, which guarantees speci?c packing behavior and
does not require the application to query for offsets and strides. In this case the
minimum size may still be queried, even though it is determined in advance based
only on the uniform block declaration (see “Standard Uniform Block Layout” in
section 2.11.4).
The total amount of buffer object storage available for any given uniform block
is subject to an implementation-dependent limit. The maximum amount of avail-
able space, in basic machine units, can be queried by calling GetIntegerv with
the constantMAX_UNIFORM_BLOCK_SIZE. If the amount of storage required for a
uniform block exceeds this limit, a program may fail to link.
If pname is UNIFORM_BLOCK_NAME_LENGTH, then the total length (includ-
ing the null terminator) of the name of the uniform block identi?ed by uniform-
BlockIndex is returned.
If pname isUNIFORM_BLOCK_ACTIVE_UNIFORMS, then the number of active
uniforms in the uniform block identi?ed by uniformBlockIndex is returned.
If pname isUNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES, then a list of the
active uniform indices for the uniform block identi?ed by uniformBlockIndex is
returned. The number of elements that will be written to params is the value of
UNIFORM_BLOCK_ACTIVE_UNIFORMS for uniformBlockIndex.
If pname is UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER or
UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER, then a boolean value
indicating whether the uniform block identi?ed by uniformBlockIndex is refer-
enced by the vertex or fragment programming stages of program, respectively, is
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 53
returned.
Each active uniform, whether in a named uniform block or in the default block,
is assigned an index when a program is linked. Indices are assigned in consecutive
order, beginning with zero. The indices assigned to a set of uniforms in a program
may be queried by calling
void GetUniformIndices(uint program,
sizei uniformCount,const char **uniformNames,
uint *uniformIndices );
program is the name of a program object for which the command LinkProgram
has been issued in the past. It is not necessary for program to have been linked
successfully. The link could have failed because the number of active uniforms
exceeded the limit.
uniformCount indicates both the number of elements in the array of names
uniformNames and the number of indices that may be written to uniformIndices.
uniformNames contains a list of uniformCount name strings identifying the uni-
form names to be queried for indices. For each name string in uniformNames, the
index assigned to the active uniform of that name will be written to the correspond-
ing element of uniformIndices. If a string in uniformNames is not the name of an
active uniform, the value INVALID_INDEX will be written to the corresponding
element of uniformIndices.
If an error occurs, nothing is written to uniformIndices.
The name of an active uniform may be queried from the corresponding uniform
index by calling
void GetActiveUniformName(uint program,
uint uniformIndex,sizei bufSize,sizei *length,
char *uniformName );
program is the name of a program object for which the command LinkProgram
has been issued in the past. It is not necessary for program to have been linked
successfully. The link could have failed because the number of active uniforms
exceeded the limit.
uniformIndex must be an active uniform index of the program program, in
the range zero to the value of ACTIVE_UNIFORMS - 1. The value of ACTIVE_-
UNIFORMS can be queried with GetProgramiv. If uniformIndex is greater than or
equal to the value ofACTIVE_UNIFORMS, the errorINVALID_VALUE is generated.
The name of the uniform identi?ed by uniformIndex is returned as a null-
terminated string in uniformName. The actual number of characters written into
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 54
uniformName, excluding the null terminator, is returned in length. If length is
NULL, no length is returned. The maximum number of characters that may be writ-
ten into uniformName, including the null terminator, is speci?ed by bufSize. The
returned uniform name can be the name of built-in uniform state as well. The com-
plete list of built-in uniform state is described in section 7.5 of the OpenGL Shad-
ing Language speci?cation. The length of the longest uniform name in program
is given by the value of ACTIVE_UNIFORM_MAX_LENGTH, which can be queried
with GetProgramiv.
If GetActiveUniformName is not successful, nothing is written to length or
uniformName.
Each uniform variable, declared in a shader, is broken down into one or more
strings using the "." (dot) and "[]" operators, if necessary, to the point that it
is legal to pass each string back into GetUniformLocation, for default uniform
block uniform names, or GetUniformIndices, for named uniform block uniform
names.
Information about active uniforms can be obtained by calling either
void GetActiveUniform(uint program,uint index,
sizei bufSize,sizei *length,int *size,enum *type,
char *name );
or
void GetActiveUniformsiv(uint program,
sizei uniformCount,const uint *uniformIndices,
enum pname,int *params );
program is the name of a program object for which the command LinkProgram
has been issued in the past. It is not necessary for program to have been linked
successfully. The link could have failed because the number of active uniforms
exceeded the limit.
These commands provide information about the uniform or uniforms selected
by index or uniformIndices, respectively. In GetActiveUniform, an index of 0
selects the ?rst active uniform, and an index of the value of ACTIVE_UNIFORMS
- 1 selects the last active uniform. In GetActiveUniformsiv, uniformIndices is an
array of such active uniform indices. If any index is greater than or equal to the
value ofACTIVE_UNIFORMS, the errorINVALID_VALUE is generated.
For the selected uniform, GetActiveUniform returns the uniform name as a
null-terminated string in name. The actual number of characters written into name,
excluding the null terminator, is returned in length. If length is NULL, no length
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 55
is returned. The maximum number of characters that may be written into name,
including the null terminator, is speci?ed by bufSize. The returned uniform name
can be the name of built-in uniform state as well. The complete list of built-in
uniform state is described in section 7.5 of the OpenGL Shading Language speci?-
cation. The length of the longest uniform name in program is given byACTIVE_-
UNIFORM_MAX_LENGTH.
Each uniform variable, declared in a shader, is broken down into one or more
strings using the"." (dot) and"[]" operators, if necessary, to the point that it is
legal to pass each string back into GetUniformLocation, for default uniform block
uniform names, or GetUniformIndices, for named uniform block uniform names.
For the selected uniform, GetActiveUniform returns the type of the uniform
into type and the size of the uniform is into size. The value in size is in units of the
uniform type, which can be any of the type name tokens in table 2.9, corresponding
to OpenGL Shading Language type keywords also shown in that table.
If one or more elements of an array are active, GetActiveUniform will return
the name of the array in name, subject to the restrictions listed above. The type of
the array is returned in type. The size parameter contains the highest array element
index used, plus one. The compiler or linker determines the highest index used.
There will be only one active uniform reported by the GL per uniform array.
GetActiveUniform will return as much information about active uniforms as
possible. If no information is available, length will be set to zero and name will be
an empty string. This situation could arise if GetActiveUniform is issued after a
failed link.
If an error occurs, nothing is written to length, size, type, or name.
For GetActiveUniformsiv, uniformCount indicates both the number of ele-
ments in the array of indices uniformIndices and the number of parameters written
to params upon successful return. pname identi?es a property of each uniform in
uniformIndices that should be written into the corresponding element of params.
If an error occurs, nothing will be written to params.
If pname isUNIFORM_TYPE, then an array identifying the types of the uniforms
speci?ed by the corresponding array of uniformIndices is returned. The returned
types can be any of the values in table 2.9.
If pname isUNIFORM_SIZE, then an array identifying the size of the uniforms
speci?ed by the corresponding array of uniformIndices is returned. The sizes re-
turned are in units of the type returned by a query of UNIFORM_TYPE. For active
uniforms that are arrays, the size is the number of active elements in the array; for
all other uniforms, the size is one.
If pname is UNIFORM_NAME_LENGTH, then an array identifying the length,
including the terminating null character, of the uniform name strings speci?ed by
the corresponding array of uniformIndices is returned.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 56
Type Name Token Keyword Type Name Token Keyword
FLOAT float SAMPLER_1D sampler1D
FLOAT_VEC2 vec2 SAMPLER_2D sampler2D
FLOAT_VEC3 vec3 SAMPLER_3D sampler3D
FLOAT_VEC4 vec4 SAMPLER_CUBE samplerCube
INT int SAMPLER_1D_SHADOW sampler1DShadow
INT_VEC2 ivec2 SAMPLER_2D_SHADOW sampler2DShadow
INT_VEC3 ivec3 SAMPLER_1D_ARRAY sampler1DArray
INT_VEC4 ivec4 SAMPLER_2D_ARRAY sampler2DArray
UNSIGNED_INT unsigned int SAMPLER_1D_ARRAY_SHADOW sampler1DArrayShadow
UNSIGNED_INT_VEC2 uvec2 SAMPLER_2D_ARRAY_SHADOW sampler2DArrayShadow
UNSIGNED_INT_VEC3 uvec3 SAMPLER_CUBE_SHADOW samplerCubeShadow
UNSIGNED_INT_VEC4 uvec4 SAMPLER_2D_RECT sampler2DRect
BOOL bool SAMPLER_2D_RECT_SHADOW sampler2DRectShadow
BOOL_VEC2 bvec2 INT_SAMPLER_1D isampler1D
BOOL_VEC3 bvec3 INT_SAMPLER_2D isampler2D
BOOL_VEC4 bvec4 INT_SAMPLER_3D isampler3D
FLOAT_MAT2 mat2 INT_SAMPLER_CUBE isamplerCube
FLOAT_MAT3 mat3 INT_SAMPLER_1D_ARRAY isampler1DArray
FLOAT_MAT4 mat4 INT_SAMPLER_2D_ARRAY isampler2DArray
FLOAT_MAT2x3 mat2x3 UNSIGNED_INT_SAMPLER_1D usampler1D
FLOAT_MAT2x4 mat2x4 UNSIGNED_INT_SAMPLER_2D usampler2D
FLOAT_MAT3x2 mat3x2 UNSIGNED_INT_SAMPLER_3D usampler3D
FLOAT_MAT3x4 mat3x4 UNSIGNED_INT_SAMPLER_CUBE usamplerCube
FLOAT_MAT4x2 mat4x2 UNSIGNED_INT_SAMPLER_1D_ARRAY usampler1DArray
FLOAT_MAT4x3 mat4x3 UNSIGNED_INT_SAMPLER_2D_ARRAY usampler2DArray
Table 2.9: OpenGL Shading Language type tokens returned by GetActiveUni-
form and GetActiveUniformsiv, and corresponding shading language keywords
declaring each such type.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 57
If pname is UNIFORM_BLOCK_INDEX, then an array identifying the uniform
block index of each of the uniforms speci?ed by the corresponding array of unifor-
mIndices is returned. The index of a uniform associated with the default uniform
block is -1.
If pname is UNIFORM_OFFSET, then an array of uniform buffer offsets is re-
turned. For uniforms in a named uniform block, the returned value will be its offset,
in basic machine units, relative to the beginning of the uniform block in the buffer
object data store. For uniforms in the default uniform block, -1 will be returned.
If pname is UNIFORM_ARRAY_STRIDE, then an array identifying the stride
between elements, in basic machine units, of each of the uniforms speci?ed by
the corresponding array of uniformIndices is returned. The stride of a uniform
associated with the default uniform block is -1. Note that this information only
makes sense for uniforms that are arrays. For uniforms that are not arrays, but are
declared in a named uniform block, an array stride of zero is returned.
If pname is UNIFORM_MATRIX_STRIDE, then an array identifying the stride
between columns of a column-major matrix or rows of a row-major matrix, in ba-
sic machine units, of each of the uniforms speci?ed by the corresponding array of
uniformIndices is returned. The matrix stride of a uniform associated with the de-
fault uniform block is -1. Note that this information only makes sense for uniforms
that are matrices. For uniforms that are not matrices, but are declared in a named
uniform block, a matrix stride of zero is returned.
If pname isUNIFORM_IS_ROW_MAJOR, then an array identifying whether each
of the uniforms speci?ed by the corresponding array of uniformIndices is a row-
major matrix or not is returned. A value of one indicates a row-major matrix, and
a value of zero indicates a column-major matrix, a matrix in the default uniform
block, or a non-matrix.
Loading Uniform Variables In The Default Uniform Block
To load values into the uniform variables of the default uniform block of the
program object that is currently in use, use the commands
void Uniformf1234gfifg(int location,T value );
void Uniformf1234gfifgv(int location,sizei count,
T value );
void Uniformf1,2,3,4gui(int location,T value );
void Uniformf1,2,3,4guiv(int location,sizei count,
T value );
void UniformMatrixf234gfv(int location,sizei count,
boolean transpose,const float *value );
void UniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3gfv(
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 58
int location,sizei count,boolean transpose,const
float *value );
The given values are loaded into the default uniform block uniform variable loca-
tion identi?ed by location.
The Uniform*ffvg commands will load count sets of one to four ?oating-point
values into a uniform location de?ned as a ?oat, a ?oating-point vector, an array of
?oats, or an array of ?oating-point vectors.
The Uniform*ifvg commands will load count sets of one to four integer val-
ues into a uniform location de?ned as a sampler, an integer, an integer vector, an
array of samplers, an array of integers, or an array of integer vectors. Only the
Uniform1ifvg commands can be used to load sampler values (see below).
The Uniform*uifvg commands will load count sets of one to four unsigned
integer values into a uniform location de?ned as a unsigned integer, an unsigned
integer vector, an array of unsigned integers or an array of unsigned integer vectors.
The UniformMatrixf234gfv commands will load count 2 2, 3 3, or 4 4
matrices (corresponding to 2, 3, or 4 in the command name) of ?oating-point values
into a uniform location de?ned as a matrix or an array of matrices. If transpose
is FALSE, the matrix is speci?ed in column major order, otherwise in row major
order.
The UniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3gfv commands will load count
23, 32, 24, 42, 34, or 43 matrices (corresponding to the numbers in the
command name) of ?oating-point values into a uniform location de?ned as a matrix
or an array of matrices. The ?rst number in the command name is the number of
columns; the second is the number of rows. For example, UniformMatrix2x4fv
is used to load a matrix consisting of two columns and four rows. If transpose
is FALSE, the matrix is speci?ed in column major order, otherwise in row major
order.
When loading values for a uniform declared as a boolean, a boolean vector,
an array of booleans, or an array of boolean vectors, the Uniform*ifvg, Uni-
form*uifvg, and Uniform*ffvg set of commands can be used to load boolean
values. Type conversion is done by the GL. The uniform is set to FALSE if the
input value is 0 or 0.0f, and set toTRUE otherwise. The Uniform* command used
must match the size of the uniform, as declared in the shader. For example, to
load a uniform declared as abvec2, any of the Uniform2fif uig* commands may
be used. An INVALID_OPERATION error will be generated if an attempt is made
to use a non-matching Uniform* command. In this example using Uniform1iv
would generate an error.
For all other uniform types the Uniform* command used must match the size
and type of the uniform, as declared in the shader. No type conversions are
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 59
done. For example, to load a uniform declared as a vec4, Uniform4ffvg must
be used. To load a 3x3 matrix, UniformMatrix3fv must be used. AnINVALID_-
OPERATION error will be generated if an attempt is made to use a non-matching
Uniform* command. In this example, using Uniform4ifvg would generate an
error.
When loadingN elements starting at an arbitrary positionk in a uniform de-
clared as an array, elements k through k +N  1 in the array will be replaced
with the new values. Values for any array element that exceeds the highest array
element index used, as reported by GetActiveUniform, will be ignored by the GL.
If the value of location is -1, the Uniform* commands will silently ignore the
data passed in, and the current uniform values will not be changed.
If any of the following conditions occur, an INVALID_OPERATION error is
generated by the Uniform* commands, and no uniform values are changed:
 if the size indicated in the name of the Uniform* command used does not
match the size of the uniform declared in the shader,
 if the uniform declared in the shader is not of type boolean and the type
indicated in the name of the Uniform* command used does not match the
type of the uniform,
 if count is greater than one, and the uniform declared in the shader is not an
array variable,
 if no variable with a location of location exists in the program object cur-
rently in use and location is not -1, or
 if there is no program object currently in use.
Uniform Blocks
The values of uniforms arranged in named uniform blocks are extracted from buffer
object storage. The mechanisms for placing individual uniforms in a buffer object
and connecting a uniform block to an individual buffer object are described below.
There is a set of implementation-dependent maximums for the number of ac-
tive uniform blocks used by each shader (vertex and fragment). If the number of
uniform blocks used by any shader in the program exceeds its corresponding limit,
the program will fail to link. The limits for vertex and fragment shaders can be
obtained by calling GetIntegerv with pname values ofMAX_VERTEX_UNIFORM_-
BLOCKS andMAX_FRAGMENT_UNIFORM_BLOCKS, respectively.
Additionally, there is an implementation-dependent limit on the sum of the
number of active uniform blocks used by each shader of a program. If a uniform
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 60
block is used by multiple shaders, each such use counts separately against this
combined limit. The combined uniform block use limit can be obtained by calling
GetIntegerv with a pname ofMAX_COMBINED_UNIFORM_BLOCKS.
When a named uniform block is declared by multiple shaders in a program, it
must be declared identically in each shader. The uniforms within the block must
be declared with the same names and types, and in the same order. If a program
contains multiple shaders with different declarations for the same named uniform
block differs between shader, the program will fail to link.
Uniform Buffer Object Storage
When stored in buffer objects associated with uniform blocks, uniforms are repre-
sented in memory as follows:
 Members of typebool are extracted from a buffer object by reading a single
uint-typed value at the speci?ed offset. All non-zero values correspond to
true, and zero corresponds to false.
 Members of typeint are extracted from a buffer object by reading a single
int-typed value at the speci?ed offset.
 Members of typeuint are extracted from a buffer object by reading a single
uint-typed value at the speci?ed offset.
 Members of type float are extracted from a buffer object by reading a
single ?oat-typed value at the speci?ed offset.
 Vectors with N elements with basic data types of bool, int, uint, or
float are extracted as N values in consecutive memory locations begin-
ning at the speci?ed offset, with components stored in order with the ?rst
(X) component at the lowest offset. The GL data type used for component
extraction is derived according to the rules for scalar members above.
 Column-major matrices with C columns and R rows (using the type
matCxR, or simply matC ifC = R) are treated as an array ofC ?oating-
point column vectors, each consisting ofR components. The column vec-
tors will be stored in order, with column zero at the lowest offset. The dif-
ference in offsets between consecutive columns of the matrix will be re-
ferred to as the column stride, and is constant across the matrix. The column
stride, UNIFORM_MATRIX_STRIDE, is an implementation-dependent value
and may be queried after a program is linked.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 61
 Row-major matrices withC columns andR rows (using the type matCxR,
or simply matC if C==R) are treated as an array of R ?oating-point row
vectors, each consisting ofC components. The row vectors will be stored in
order, with row zero at the lowest offset. The difference in offsets between
consecutive rows of the matrix will be referred to as the row stride, and is
constant across the matrix. The row stride, UNIFORM_MATRIX_STRIDE, is
an implementation-dependent value and may be queried after a program is
linked.
 Arrays of scalars, vectors, and matrices are stored in memory by element
order, with array member zero at the lowest offset. The difference in offsets
between each pair of elements in the array in basic machine units is referred
to as the array stride, and is constant across the entire array. The array stride,
UNIFORM_ARRAY_STRIDE, is an implementation-dependent value and may
be queried after a program is linked.
Standard Uniform Block Layout
By default, uniforms contained within a uniform block are extracted from buffer
storage in an implementation-dependent manner. Applications may query the off-
sets assigned to uniforms inside uniform blocks with query functions provided by
the GL.
The layout quali?er provides shaders with control of the layout of uniforms
within a uniform block. When the std140 layout is speci?ed, the offset of each
uniform in a uniform block can be derived from the de?nition of the uniform block
by applying the set of rules described below.
If a uniform block is declared in multiple shaders linked together into a single
program, the link will fail unless the uniform block declaration, including layout
quali?er, are identical in all such shaders.
When using the std140 storage layout, structures will be laid out in buffer
storage with its members stored in monotonically increasing order based on their
location in the declaration. A structure and each structure member have a base
offset and a base alignment, from which an aligned offset is computed by rounding
the base offset up to a multiple of the base alignment. The base offset of the ?rst
member of a structure is taken from the aligned offset of the structure itself. The
base offset of all other structure members is derived by taking the offset of the
last basic machine unit consumed by the previous member and adding one. Each
structure member is stored in memory at its aligned offset. The members of a top-
level uniform block are laid out in buffer storage by treating the uniform block as
a structure with a base offset of zero.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 62
1. If the member is a scalar consumingN basic machine units, the base align-
ment isN.
2. If the member is a two- or four-component vector with components consum-
ingN basic machine units, the base alignment is 2N or 4N, respectively.
3. If the member is a three-component vector with components consumingN
basic machine units, the base alignment is 4N.
4. If the member is an array of scalars or vectors, the base alignment and array
stride are set to match the base alignment of a single array element, according
to rules (1), (2), and (3), and rounded up to the base alignment of a vec4. The
array may have padding at the end; the base offset of the member following
the array is rounded up to the next multiple of the base alignment.
5. If the member is a column-major matrix with C columns and R rows, the
matrix is stored identically to an array ofC column vectors withR compo-
nents each, according to rule (4).
6. If the member is an array ofS column-major matrices withC columns and
R rows, the matrix is stored identically to a row ofSC column vectors
withR components each, according to rule (4).
7. If the member is a row-major matrix withC columns andR rows, the matrix
is stored identically to an array ofR row vectors withC components each,
according to rule (4).
8. If the member is an array ofS row-major matrices withC columns andR
rows, the matrix is stored identically to a row ofSR row vectors withC
components each, according to rule (4).
9. If the member is a structure, the base alignment of the structure isN, where
N is the largest base alignment value of any of its members, and rounded
up to the base alignment of a vec4. The individual members of this sub-
structure are then assigned offsets by applying this set of rules recursively,
where the base offset of the ?rst member of the sub-structure is equal to the
aligned offset of the structure. The structure may have padding at the end;
the base offset of the member following the sub-structure is rounded up to
the next multiple of the base alignment of the structure.
10. If the member is an array ofS structures, theS elements of the array are laid
out in order, according to rule (9).
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 63
Uniform Buffer Object Bindings
The value an active uniform inside a named uniform block is extracted from the
data store of a buffer object bound to one of an array of uniform buffer binding
points. The number of binding points can be queried using GetIntegerv with the
constantMAX_UNIFORM_BUFFER_BINDINGS.
Buffer objects are bound to uniform block binding points by calling one of the
commands
void BindBufferRange(enum target,uint index,
uint buffer,intptr offset,sizeiptr size );
void BindBufferBase(enum target,uint index,uint buffer );
with target set to UNIFORM_BUFFER. There is an array of buffer object binding
points with which uniform blocks can be associated via UniformBlockBinding,
plus a single general binding point that can be used by other buffer object manip-
ulation functions (e.g. BindBuffer, MapBuffer). Both commands bind the buffer
object named by buffer to the general binding point, and additionally bind the buffer
object to the binding point in the array given by index. The errorINVALID_VALUE
is generated if index is greater than or equal to the value of MAX_UNIFORM_-
BUFFER_BINDINGS.
For BindBufferRange, offset speci?es a starting offset into the buffer object
buffer, and size speci?es the amount of data that can be read from the buffer ob-
ject while used as the storage for a uniform block. Both offset and size are in
basic machine units. The error INVALID_VALUE is generated if the value of size
is less than or equal to zero, if oset + size is greater than the value ofBUFFER_-
SIZE, or if offset is not a multiple of the implementation-dependent required align-
ment (UNIFORM_BUFFER_OFFSET_ALIGNMENT). BindBufferBase is equivalent
to calling BindBufferRange with offset zero and size equal to the size of buffer.
Each of a program’s active uniform blocks has a corresponding uniform buffer
object binding point. This binding point can be assigned by calling:
void UniformBlockBinding(uint program,
uint uniformBlockIndex,uint uniformBlockBinding );
program is a name of a program object for which the command LinkProgram has
been issued in the past.
uniformBlockIndex must be an active uniform block index of the program pro-
gram. Otherwise,INVALID_VALUE is generated.
uniformBlockBinding must be less than MAX_UNIFORM_BUFFER_BINDINGS.
Otherwise,INVALID_VALUE is generated.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 64
If successful, UniformBlockBinding speci?es that program will use the data
store of the buffer object bound to the binding point uniformBlockBinding to extract
the values of the uniforms in the uniform block identi?ed by uniformBlockIndex.
When executing shaders that access uniform blocks, the binding point corre-
sponding to each active uniform block must be populated with a buffer object with
a size no smaller than the minimum required size of the uniform block (the value
ofUNIFORM_BLOCK_DATA_SIZE). For binding points populated by BindBuffer-
Range, the size in question is the value of the size parameter. If any active uniform
block is not backed by a suf?ciently large buffer object, the results of shader ex-
ecution are unde?ned, and may result in GL interruption or termination. Shaders
may be executed to process the primitives and vertices speci?ed by vertex array
commands (see section 2.8).
When a program object is linked or re-linked, the uniform buffer object binding
point assigned to each of its active uniform blocks is reset to zero.
2.11.5 Samplers
Samplers are special uniforms used in the OpenGL Shading Language to identify
the texture object used for each texture lookup. The value of a sampler indicates
the texture image unit being accessed. Setting a sampler’s value toi selects texture
image unit number i. The values of i range from zero to the implementation-
dependent maximum supported number of texture image units.
The type of the sampler identi?es the target on the texture image unit. The
texture object bound to that texture image unit’s target is then used for the texture
lookup. For example, a variable of type sampler2D selects target TEXTURE_2D
on its texture image unit. Binding of texture objects to targets is done as usual with
BindTexture. Selecting the texture image unit to bind to is done as usual with
ActiveTexture.
The location of a sampler needs to be queried with GetUniformLocation, just
like any uniform variable. Sampler values need to be set by calling Uniform1ifvg.
Loading samplers with any of the other Uniform* entry points is not allowed and
will result in anINVALID_OPERATION error.
It is not allowed to have variables of different sampler types pointing to the
same texture image unit within a program object. This situation can only be de-
tected at the next rendering command issued, and anINVALID_OPERATION error
will then be generated.
Active samplers are samplers actually being used in a program object. The
LinkProgram command determines if a sampler is active or not. The LinkPro-
gram command will attempt to determine if the active samplers in the shader(s)
contained in the program object exceed the maximum allowable limits. If it deter-
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 65
mines that the count of active samplers exceeds the allowable limits, then the link
fails (these limits can be different for different types of shaders). Each active sam-
pler variable counts against the limit, even if multiple samplers refer to the same
texture image unit.
2.11.6 Varying Variables
A vertex shader may de?ne one or more varying variables (see the OpenGL Shad-
ing Language speci?cation). These values are expected to be interpolated across
the primitive being rendered. The OpenGL Shading Language speci?cation de?nes
a set of built-in varying variables for vertex shaders that correspond to the values
required for the ?xed-function processing that occurs after vertex processing.
The number of interpolators available for processing varying variables is
given by the value of the implementation-dependent constant MAX_VARYING_-
COMPONENTS. This value represents the number of individual scalar numeric val-
ues that can be interpolated; varying variables declared as vectors, matrices, and
arrays will all consume multiple interpolators. When a program is linked, all com-
ponents of any varying variable written by a vertex shader, read by a fragment
shader, or used for transform feedback will count against this limit. The trans-
formed vertex position (gl_Position) is not a varying variable and does not
count against this limit. A program whose shaders access more than the value
of MAX_VARYING_COMPONENTS components worth of varying variables may fail
to link, unless device-dependent optimizations are able to make the program ?t
within available hardware resources.
Each program object can specify a set of one or more varying variables to be
recorded in transform feedback mode with the command
void TransformFeedbackVaryings(uint program,
sizei count,const char **varyings,enum bufferMode );
program speci?es the program object. count speci?es the number of vary-
ing variables used for transform feedback. varyings is an array of count zero-
terminated strings specifying the names of the varying variables to use for trans-
form feedback. Varying variables are written out in the order they appear in the
array varyings. bufferMode is either INTERLEAVED_ATTRIBS or SEPARATE_-
ATTRIBS, and identi?es the mode used to capture the varying variables when
transform feedback is active. The error INVALID_VALUE is generated if program
is not the name of a program object, or if bufferMode is SEPARATE_ATTRIBS
and count is greater than the value of the implementation-dependent limit MAX_-
TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 66
The state set by TransformFeedbackVaryings has no effect on the execu-
tion of the program until program is subsequently linked. When LinkProgram is
called, the program is linked so that the values of the speci?ed varying variables
for the vertices of each primitive generated by the GL are written to a single buffer
object (if the buffer mode is INTERLEAVED_ATTRIBS) or multiple buffer objects
(if the buffer mode isSEPARATE_ATTRIBS). A program will fail to link if:
 the count speci?ed by TransformFeedbackVaryings is non-zero, but the
program object has no vertex shader;
 any variable name speci?ed in the varyings array is not declared as an output
in the vertex shader.
 any two entries in the varyings array specify the same varying variable;
 the total number of components to capture in any varying variable in varyings
is greater than the constant MAX_TRANSFORM_FEEDBACK_SEPARATE_-
COMPONENTS and the buffer mode isSEPARATE_ATTRIBS; or
 the total number of components to capture is greater than the constant
MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS and the buffer
mode isINTERLEAVED_ATTRIBS.
To determine the set of varying variables in a linked program object that will
be captured in transform feedback mode, the command:
void GetTransformFeedbackVarying(uint program,
uint index,sizei bufSize,sizei *length,sizei *size,
enum *type,char *name );
provides information about the varying variable selected by index. An index of 0
selects the ?rst varying variable speci?ed in the varyings array of TransformFeed-
backVaryings, and an index ofTRANSFORM_FEEDBACK_VARYINGS-1 selects the
last such varying variable. The value of TRANSFORM_FEEDBACK_VARYINGS can
be queried with GetProgramiv (see section 6.1.9). If index is greater than or equal
to TRANSFORM_FEEDBACK_VARYINGS, the error INVALID_VALUE is generated.
The parameter program is the name of a program object for which the command
LinkProgram has been issued in the past. If program has not been linked, the er-
rorINVALID_OPERATION is generated. If a new set of varying variables is speci-
?ed by TransformFeedbackVaryings after a program object has been linked, the
information returned by GetTransformFeedbackVarying will not re?ect those
variables until the program is re-linked.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 67
The name of the selected varying is returned as a null-terminated string in
name. The actual number of characters written into name, excluding the null termi-
nator, is returned in length. If length isNULL, no length is returned. The maximum
number of characters that may be written into name, including the null terminator,
is speci?ed by bufSize. The length of the longest varying name in program is
given byTRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, which can be queried
with GetProgramiv (see section 6.1.9).
For the selected varying variable, its type is returned into type. The size of
the varying is returned into size. The value in size is in units of the type returned
in type. The type returned can be any of the scalar, vector, or matrix attribute
types returned by GetActiveAttrib. If an error occurred, the return parameters
length, size, type and name will be unmodi?ed. This command will return as much
information about the varying variables as possible. If no information is available,
length will be set to zero and name will be an empty string. This situation could
arise if GetTransformFeedbackVarying is called after a failed link.
2.11.7 Shader Execution
If a successfully linked program object that contains a vertex shader is made current
by calling UseProgram, the executable version of the vertex shader is used to
process incoming vertex values . In particular,
The following operations are applied to vertex values that are the result of
executing the vertex shader:
 Perspective division on clip coordinates (section 2.12).
 Viewport mapping, including depth range scaling (section 2.12.1).
 Clipping, including client-de?ned half-spaces (section 2.17).
 Front face determination (section 3.6.1).
 generic attribute clipping (section 2.17.1).
There are several special considerations for vertex shader execution described
in the following sections.
Shader Only Texturing
This section describes texture functionality that is accessible through vertex or
fragment shaders. Also refer to section 3.8 and to the OpenGL Shading Language
Specification, section 8.7.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 68
Texel Fetches
The OpenGL Shading Language texel fetch functions provide the ability to
extract a single texel from a speci?ed texture image. The integer coordinates passed
to the texel fetch functions are used directly as the texel coordinates (i;j;k) into the
texture image. This in turn means the texture image is point-sampled (no ?ltering
is performed).
The level of detail accessed is computed by adding the speci?ed level-of-detail
parameter lod to the base level of the texture,level .
base
The texel fetch functions can not perform depth comparisons or access cube
maps. Unlike ?ltered texel accesses, texel fetches do not support LOD clamping or
any texture wrap mode, and require a mipmapped mini?cation ?lter to access any
level of detail other than the base level.
The results of the texel fetch are unde?ned if any of the following conditions
hold:
 the computed LOD is less than the texture’s base level (level ) or greater
base
than the maximum level (level )
max
 the computed LOD is not the texture’s base level and the texture’s mini?ca-
tion ?lter isNEAREST orLINEAR
 the layer speci?ed for array textures is negative or greater than the number
of layers in the array texture,
 the texel coordinates (i;j;k) refer to a border texel outside the de?ned ex-
tents of the speci?ed LOD, where any of
i< b iw  b
s s s
j < b jh  b
s s s
k< b kd  b
s s s
and the size parametersw ,h ,d , andb refer to the width, height, depth,
s s s s
and border size of the image, as in equations 3.16
 the texture being accessed is not complete (or cube complete for cubemaps).
Texture Size Query
The OpenGL Shading Language texture size functions provide the ability to
query the size of a texture image. The LOD value lod passed in as an argument
to the texture size functions is added to the level of the texture to determine
base
a texture image level. The dimensions of that image level, excluding a possible
border, are then returned. If the computed texture image level is outside the range
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 69
[level ;level ], the results are unde?ned. When querying the size of an array
base max
texture, both the dimensions and the layer index are returned.
Texture Access
Vertex shaders have the ability to do a lookup into a texture map. The maxi-
mum number of texture image units available to a vertex shader is the value of
the implementation-dependent constant MAX_VERTEX_TEXTURE_IMAGE_UNITS.
The maximum number of texture image units available to a fragment shader is
the value of MAX_TEXTURE_IMAGE_UNITS. Both the vertex shader and fragment
shader combined cannot use more than the value ofMAX_COMBINED_TEXTURE_-
IMAGE_UNITS texture image units. If both the vertex shader and the fragment
processing stage access the same texture image unit, then that counts as using two
texture image units against theMAX_COMBINED_TEXTURE_IMAGE_UNITS limit.
When a texture lookup is performed in a vertex shader, the ?ltered texture value
 is computed in the manner described in sections 3.8.8 and 3.8.9, and converted
to a texture source color C according to table 3.20 (section 3.9.2). A four-
s
component vector (R ;G ;B ;A ) is returned to the vertex shader. Texture lookup
s s s s
functions (see section 8.7 of the OpenGL Shading Language Specification) may
return ?oating-point, signed, or unsigned integer values depending on the function
and the internal format of the texture.
In a vertex shader, it is not possible to perform automatic level-of-detail calcu-
lations using partial derivatives of the texture coordinates with respect to window
coordinates as described in section 3.8.8. Hence, there is no automatic selection of
an image array level. Minification or magni?cation of a texture map is controlled
by a level-of-detail value optionally passed as an argument in the texture lookup
functions. If the texture lookup function supplies an explicit level-of-detail valuel,
then the pre-bias level-of-detail value (x;y) =l (replacing equation 3.17). If
base
the texture lookup function does not supply an explicit level-of-detail value, then
 (x;y) = 0. The scale factor(x;y) and its approximation functionf(x;y)
base
(see equation 3.21) are ignored.
Texture lookups involving textures with depth component data can either re-
turn the depth data directly or return the results of a comparison with a refer-
ence depth value speci?ed in the coordinates passed to the texture lookup func-
tion, as described in section 3.8.14. The comparison operation is requested in
the shader by using any of the shadow sampler types (sampler1DShadow,
sampler2DShadow, or sampler2DRectShadow), and in the texture using the
TEXTURE_COMPARE_MODE parameter. These requests must be consistent; the re-
sults of a texture lookup are unde?ned if:
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 70
 The sampler used in a texture lookup function is not one of the shadow
sampler types, the texture object’s internal format is DEPTH_COMPONENT
orDEPTH_STENCIL, and theTEXTURE_COMPARE_MODE is notNONE.
 The sampler used in a texture lookup function is one of the shadow sam-
pler types, the texture object’s internal format is DEPTH_COMPONENT or
DEPTH_STENCIL, and theTEXTURE_COMPARE_MODE isNONE.
 The sampler used in a texture lookup function is one of the shadow sampler
types, and the texture object’s internal format is not DEPTH_COMPONENT or
DEPTH_STENCIL.
The stencil index texture internal component is ignored if the base internal
format isDEPTH_STENCIL.
If a vertex shader uses a sampler where the associated texture object is not com-
plete, as de?ned in section 3.8.11, the texture image unit will return (R;G;B;A)
= (0; 0; 0; 1).
Shader Inputs
Besides having access to vertex attributes and uniform variables, vertex shaders
can access the read-only built-in variablesgl_VertexID andgl_InstanceID
gl_VertexID holds the integer indexi implicitly passed by DrawArrays or
one of the other drawing commands de?ned in section 2.8.2.
gl_InstanceID holds the integer index of the current primitive in an in-
stanced draw call (see section 2.8.2).
Section 7.1 of the OpenGL Shading Language Specification also describes
these variables.
Shader Outputs
A vertex shader can write to user-de?ned varying variables. These values are
expected to be interpolated across the primitive it outputs, unless they are speci?ed
to be ?at shaded. Refer to the OpenGL Shading Language speci?cation sections
4.3.6, 7.1 and 7.6 for more detail.
The built-in special variable gl_Position is intended to hold the homoge-
neous vertex position. Writinggl_Position is optional.
The built-in special variable gl_ClipDistance holds the clip distance(s)
used in the clipping stage, as described in section 2.17. If clipping is enabled,
gl_ClipDistance should be written.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 71
Validation
It is not always possible to determine at link time if a program object actually will
execute. Therefore validation is done when the ?rst rendering command is issued,
to determine if the currently active program object can be executed. If it cannot be
executed then no fragments will be rendered, and the errorINVALID_OPERATION
will be generated.
This error is generated by any command that transfers vertices to the GL if:
 any two active samplers in the current program object are of different types,
but refer to the same texture image unit,
 the number of active samplers in the program exceeds the maximum number
of texture image units allowed.
Unde?ned behavior results if the program object in use has no fragment shader
unless transform feedback is enabled, in which case only a vertex shader is re-
quired.
The INVALID_OPERATION error reported by these rendering commands may
not provide enough information to ?nd out why the currently active program object
would not execute. No information at all is available about a program object that
would still execute, but is inef?cient or suboptimal given the current GL state. As
a development aid, use the command
void ValidateProgram(uint program );
to validate the program object program against the current GL state. Each program
object has a boolean status, VALIDATE_STATUS, that is modi?ed as a result of
validation. This status can be queried with GetProgramiv (see section 6.1.9). If
validation succeeded this status will be set to TRUE, otherwise it will be set to
FALSE. If validation succeeded the program object is guaranteed to execute, given
the current GL state. If validation failed, the program object is guaranteed to not
execute, given the current GL state.
ValidateProgram will check for all the conditions that could lead to an
INVALID_OPERATION error when rendering commands are issued, and may check
for other conditions as well. For example, it could give a hint on how to optimize
some piece of shader code. The information log of program is overwritten with
information on the results of the validation, which could be an empty string. The
results written to the information log are typically only useful during application
development; an application should not expect different GL implementations to
produce identical information.
OpenGL 3.1 - May 28, 20092.11. VERTEXSHADERS 72
A shader should not fail to compile, and a program object should not fail to
link due to lack of instruction space or lack of temporary variables. Implementa-
tions should ensure that all valid shaders and program objects may be successfully
compiled, linked and executed.
Unde?ned Behavior
When using array or matrix variables in a shader, it is possible to access a vari-
able with an index computed at run time that is outside the declared extent of the
variable. Such out-of-bounds reads will return unde?ned values; out-of-bounds
writes will have unde?ned results and could corrupt other variables used by shader
or the GL. The level of protection provided against such errors in the shader is
implementation-dependent.
2.11.8 Required State
The GL maintains state to indicate which shader and program object names are in
use. Initially, no shader or program objects exist, and no names are in use.
The state required per shader object consists of:
 An unsigned integer specifying the shader object name.
 An integer holding the value ofSHADER_TYPE.
 A boolean holding the delete status, initiallyFALSE.
 A boolean holding the status of the last compile, initiallyFALSE.
 An array of typechar containing the information log, initially empty.
 An integer holding the length of the information log.
 An array of type char containing the concatenated shader string, initially
empty.
 An integer holding the length of the concatenated shader string.
The state required per program object consists of:
 An unsigned integer indicating the program object name.
 A boolean holding the delete status, initiallyFALSE.
 A boolean holding the status of the last link attempt, initiallyFALSE.
OpenGL 3.1 - May 28, 20092.12. COORDINATETRANSFORMATIONS 73
 A boolean holding the status of the last validation attempt, initallyFALSE.
 An integer holding the number of attached shader objects.
 A list of unsigned integers to keep track of the names of the shader objects
attached.
 An array of typechar containing the information log, initially empty.
 An integer holding the length of the information log.
 An integer holding the number of active uniforms.
 For each active uniform, three integers, holding its location, size, and type,
and an array of typechar holding its name.
 An array holding the values of each active uniform.
 An integer holding the number of active attributes.
 For each active attribute, three integers holding its location, size, and type,
and an array of typechar holding its name.
Additional state required to support vertex shaders consists of:
 A bit indicating whether or not vertex program two-sided color mode is en-
abled, initially disabled.
 A bit indicating whether or not vertex program point size mode (sec-
tion 3.4.1) is enabled, initially disabled.
Additionally, one unsigned integer is required to hold the name of the current pro-
gram object, if any.
2.12 Coordinate Transformations
Clip coordinates for a vertex result from vertex shader execution, which yields a
vertex coordinategl_Position. Perspective division on clip coordinates yields
normalized device coordinates, followed by a viewport transformation to convert
these coordinates into window coordinates.
0 1
x
c
B C
y
c
B C
If a vertex in clip coordinates is given by
@ A
z
c
w
c
OpenGL 3.1 - May 28, 20092.12. COORDINATETRANSFORMATIONS 74
then the vertex’s normalized device coordinates are
0 1 0 1
x
c
x
d
w
c
y
c
@ A @ A
y = :
d
w
c
z
c
z
d
w
c
2.12.1 Controlling the Viewport
The viewport transformation is determined by the viewport’s width and height in
pixels,p andp , respectively, and its center (o ;o ) (also in pixels). The vertex’s
x y x y
0 1
x
w
@ A
window coordinates, y ; are given by
w
z
w
0 1 0 1
p
x
x +o
x
w d x
2
p
y
@ A @ A
y = y +o :
d y
w
2
f n n+f
z z +
w
d
2 2
The factor and offset applied toz encoded byn andf are set using
d
void DepthRange(clampd n,clampd f );
z is represented as either ?xed- or ?oating-point depending on whether the frame-
w
buffer’s depth buffer uses a ?xed- or ?oating-point representation. If the depth
m
buffer uses ?xed-point, we assume that it represents each valuek=(2   1), where
m
k2f0; 1;:::; 2   1g, ask (e.g. 1.0 is represented in binary as a string of all
ones). The parameters n and f are clamped to the range [0; 1], as are all arguments
of typeclampd orclampf.
Viewport transformation parameters are speci?ed using
void Viewport(int x,int y,sizei w,sizei h );
where x and y give the x and y window coordinates of the viewport’s lower left
corner and w and h give the viewport’s width and height, respectively. The viewport
parameters shown in the above equations are found from these values as
w
o =x +
x
2
h
o =y +
y
2
p =w
x
p =h:
y
Viewport width and height are clamped to implementation-dependent maxi-
mums when speci?ed. The maximum width and height may be found by issuing
OpenGL 3.1 - May 28, 20092.13. ASYNCHRONOUSQUERIES 75
an appropriate Get command (see chapter 6). The maximum viewport dimensions
must be greater than or equal to the larger of the visible dimensions of the display
being rendered to (if a display exists), and the largest renderbuffer image which
can be successfully created and attached to a framebuffer object (see chapter 4).
INVALID_VALUE is generated if either w or h is negative.
The state required to implement the viewport transformation is four integers
and two clamped ?oating-point values. In the initial state, w and h are set to the
width and height, respectively, of the window into which the GL is to do its ren-
dering. If the default framebuffer is bound but no default framebuffer is associated
with the GL context (see chapter 4), then w and h are initially set to zero. o ,o ,
x y
w h
n, andf are set to , , 0:0, and 1:0, respectively.
2 2
2.13 Asynchronous Queries
Asynchronous queries provide a mechanism to return information about the pro-
cessing of a sequence of GL commands. There are two query types supported by
the GL. Transform feedback queries (see section 2.15) return information on the
number of vertices and primitives processed by the GL and written to one or more
buffer objects. Occlusion queries (see section 4.1.6) count the number of fragments
or samples that pass the depth test.
The results of asynchronous queries are not returned by the GL immediately
after the completion of the last command in the set; subsequent commands can
be processed while the query results are not complete. When available, the query
results are stored in an associated query object. The commands described in sec-
tion 6.1.6 provide mechanisms to determine when query results are available and
return the actual results of the query. The name space for query objects is the
unsigned integers, with zero reserved by the GL.
Each type of query supported by the GL has an active query object name. If
the active query object name for a query type is non-zero, the GL is currently
tracking the information corresponding to that query type and the query results
will be written into the corresponding query object. If the active query object for a
query type name is zero, no such information is being tracked.
A query object is created and made active by calling
void BeginQuery(enum target,uint id );
target indicates the type of query to be performed; valid values of target are de?ned
in subsequent sections. If id is an unused query object name, the name is marked
as used and associated with a new query object of the type speci?ed by target.
Otherwise id must be the name of an existing query object of that type.
OpenGL 3.1 - May 28, 20092.13. ASYNCHRONOUSQUERIES 76
BeginQuery fails and anINVALID_OPERATION error is generated if id is not
a name returned from a previous call to GenQueries, or if such a name has since
been deleted with DeleteQueries.
BeginQuery sets the active query object name for the query type given by
target to id. If BeginQuery is called with an id of zero, if the active query object
name for target is non-zero, if id is the name of an existing query object whose
type does not match target, if id is the active query object name for any query type,
or if id is the active query object for condtional rendering (see section 2.14), the
errorINVALID_OPERATION is generated.
The command
void EndQuery(enum target );
marks the end of the sequence of commands to be tracked for the query type given
by target. The active query object for target is updated to indicate that query results
are not available, and the active query object name for target is reset to zero. When
the commands issued prior to EndQuery have completed and a ?nal query result
is available, the query object active when EndQuery is called is updated by the
GL. The query object is updated to indicate that the query results are available and
to contain the query result. If the active query object name for target is zero when
EndQuery is called, the errorINVALID_OPERATION is generated.
The command
void GenQueries(sizei n,uint *ids );
returns n previously unused query object names in ids. These names are marked
as used, but no object is associated with them until the ?rst time they are used by
BeginQuery.
Query objects are deleted by calling
void DeleteQueries(sizei n,const uint *ids );
ids contains n names of query objects to be deleted. After a query object is deleted,
its name is again unused. Unused names in ids are silently ignored.
Query objects contain two pieces of state: a single bit indicating whether a
query result is available, and an integer containing the query result value. The
number of bits used to represent the query result is implementation-dependent. In
the initial state of a query object, the result is available and its value is zero.
The necessary state for each query type is an unsigned integer holding the
active query object name (zero if no query object is active), and any state necessary
to keep the current results of an asynchronous query in progress.
OpenGL 3.1 - May 28, 20092.14. CONDITIONALRENDERING 77
2.14 Conditional Rendering
Conditional rendering can be used to discard rendering commands based on the
result of an occlusion query. Conditional rendering is started and stopped using the
commands
void BeginConditionalRender(uint id,enum mode );
void EndConditionalRender(void );
id speci?es the name of an occlusion query object whose results are used to deter-
mine if the rendering commands are discarded. If the result (SAMPLES_PASSED)
of the query is zero, all rendering commands between BeginConditionalRender
and the corresponding EndConditionalRender are discarded. In this case, all
vertex array commands (see section 2.8), as well as Clear and ClearBuffer* (see
section 4.2.3), have no effect. The effect of commands setting current vertex state,
such as VertexAttrib, are unde?ned. If the result of the occlusion query is non-
zero, such commands are not discarded.
mode speci?es how BeginConditionalRender interprets the results of the oc-
clusion query given by id. If mode isQUERY_WAIT, the GL waits for the results of
the query to be available and then uses the results to determine if subsquent render-
ing commands are discarded. If mode isQUERY_NO_WAIT, the GL may choose to
unconditionally execute the subsequent rendering commands without waiting for
the query to complete.
If mode is QUERY_BY_REGION_WAIT, the GL will also wait for occlusion
query results and discard rendering commands if the result of the occlusion query is
zero. If the query result is non-zero, subsequent rendering commands are executed,
but the GL may discard the results of the commands for any region of the frame-
buffer that did not contribute to the sample count in the speci?ed occlusion query.
Any such discarding is done in an implementation-dependent manner, but the ren-
dering command results may not be discarded for any samples that contributed
to the occlusion query sample count. If mode is QUERY_BY_REGION_NO_WAIT,
the GL operates as inQUERY_BY_REGION_WAIT, but may choose to uncondition-
ally execute the subsequent rendering commands without waiting for the query to
complete.
If BeginConditionalRender is called while conditional rendering is in
progress, or if EndConditionalRender is called while conditional rendering is not
in progress, the error INVALID_OPERATION is generated. The error INVALID_-
VALUE is generated if id is not the name of an existing query object. The error
INVALID_OPERATION is generated if id is the name of a query object with a target
other thanSAMPLES_PASSED, or id is the name of a query currently in progress.
OpenGL 3.1 - May 28, 20092.15. TRANSFORMFEEDBACK 78
Transform Feedback Allowed render primitive
primitiveMode modes
POINTS POINTS
LINES LINES,LINE_LOOP,LINE_STRIP
TRIANGLES TRIANGLES,TRIANGLE_STRIP,TRIANGLE_FAN
Table 2.10: Legal combinations of the transform feedback primitive mode, as
passed to BeginTransformFeedback, and the current primitive mode.
2.15 Transform Feedback
In transform feedback mode, attributes of the vertices of transformed primitives
processed by a vertex shader are written out to one or more buffer objects. The
vertices are fed back after vertex color clamping, but before clipping. The trans-
formed vertices may be optionally discarded after being stored into one or more
buffer objects, or they can be passed on down to the clipping stage for further
processing. The set of attributes captured is determined when a program is linked.
Transform feedback is started and ?nished by calling
void BeginTransformFeedback(enum primitiveMode );
and
void EndTransformFeedback(void );
respectively. Transform feedback is said to be active after a call to BeginTrans-
formFeedback and inactive after a call to EndTransformFeedback. primitive-
Mode is one of TRIANGLES, LINES, or POINTS, and speci?es the output type of
primitives that will be recorded into the buffer objects bound for transform feed-
back (see below). primitiveMode restricts the primitive types that may be rendered
while transform feedback is active, as shown in table 2.10.
Transform feedback commands must be paired; the error INVALID_-
OPERATION is generated by BeginTransformFeedback if transform feedback is
active, and by EndTransformFeedback if transform feedback is inactive.
Transform feedback mode captures the values of varying variables written by
the vertex shader.
When transform feedback is active, all geometric primitives generated must
be compatible with the value of primitiveMode passed to BeginTransformFeed-
back. The error INVALID_OPERATION is generated by DrawArrays and the
OpenGL 3.1 - May 28, 20092.15. TRANSFORMFEEDBACK 79
other drawing commands de?ned in section 2.8.2 if mode is not one of the allowed
modes in table 2.10.
Buffer objects are made to be targets of transform feedback by calling one of
the commands
void BindBufferRange(enum target,uint index,
uint buffer,intptr offset,sizeiptr size );
void BindBufferBase(enum target,uint index,uint buffer );
with target set to TRANSFORM_FEEDBACK_BUFFER. There is an array of buffer
object binding points that are used while transform feedback is active, plus a sin-
gle general binding point that can be used by other buffer object manipulation
functions (e.g., BindBuffer, MapBuffer). Both commands bind the buffer object
named by buffer to the general binding point, and additionally bind the buffer ob-
ject to the binding point in the array given by index. The error INVALID_VALUE
is generated if index is greater than or equal to the value of MAX_TRANSFORM_-
FEEDBACK_SEPARATE_ATTRIBS.
For BindBufferRange, offset speci?es a starting offset into the buffer object
buffer, and size speci?es the amount of data that can be written to the buffer object
while transform feedback mode is active. Both offset and size are in basic machine
units. The error INVALID_VALUE is generated if the value of size is less than
or equal to zero, if oset + size is greater than the value of BUFFER_SIZE, or if
either offset or size are not a multiple of 4. BindBufferBase is equivalent to calling
BindBufferRange with offset zero and size equal to the size of buffer, rounded
down to the nearest multiple of 4.
When an individual point, line, or triangle primitive reaches the transform feed-
back stage while transform feedback is active, the values of the speci?ed varying
variables of the vertex are appended to the buffer objects bound to the transform
feedback binding points. The attributes of the ?rst vertex received after Begin-
TransformFeedback are written at the starting offsets of the bound buffer objects
set by BindBufferRange, and subsequent vertex attributes are appended to the
buffer object. When capturing line and triangle primitives, all attributes of the ?rst
vertex are written ?rst, followed by attributes of the subsequent vertices. When
writing varying variables that are arrays, individual array elements are written in
order. For multi-component varying variables or varying array elements, the indi-
vidual components are written in order. The value for any attribute speci?ed to be
streamed to a buffer object but not actually written by a vertex shader is unde?ned.
Individual lines or triangles of a strip or fan primitive will be extracted and
recorded separately. Incomplete primitives are not recorded.
Transform feedback can operate in either INTERLEAVED_ATTRIBS or
SEPARATE_ATTRIBS mode. InINTERLEAVED_ATTRIBS mode, the values of one
OpenGL 3.1 - May 28, 20092.15. TRANSFORMFEEDBACK 80
or more varyings are written, interleaved, into the buffer object bound to the ?rst
transform feedback binding point (index = 0). If more than one varying variable is
written, they will be recorded in the order speci?ed by TransformFeedbackVary-
ings (see section 2.11.6). InSEPARATE_ATTRIBS mode, the ?rst varying variable
speci?ed by TransformFeedbackVaryings is written to the ?rst transform feed-
back binding point; subsequent varying variables are written to the subsequent
transform feedback binding points. The total number of variables that may be cap-
tured in separate mode is given by MAX_TRANSFORM_FEEDBACK_SEPARATE_-
ATTRIBS.
If recording the vertices of a primitive to the buffer objects being used for trans-
form feedback purposes would result in either exceeding the limits of any buffer
object’s size, or in exceeding the end position oset + size  1, as set by Bind-
BufferRange, then no vertices of that primitive are recorded in any buffer object,
and the counter corresponding to the asynchronous query target TRANSFORM_-
FEEDBACK_PRIMITIVES_WRITTEN (see section 2.16) is not incremented.
In either separate or interleaved modes, all transform feedback binding points
that will be written to must have buffer objects bound when BeginTransformFeed-
back is called. The error INVALID_OPERATION is generated by BeginTrans-
formFeedback if any binding point used in transform feedback mode does not
have a buffer object bound. In interleaved mode, only the ?rst buffer object bind-
ing point is ever written to. The error INVALID_OPERATION is also generated
by BeginTransformFeedback if no binding points would be used, either because
no program object is active or because the active program object has speci?ed no
varying variables to record.
While transform feedback is active, the set of attached buffer objects and the set
of varying variables captured may not be changed. If transform feedback is active,
the error INVALID_OPERATION is generated by UseProgram, by LinkProgram
if program is the currently active program object, and by BindBufferRange or
BindBufferBase if target isTRANSFORM_FEEDBACK_BUFFER.
Buffers should not be bound or in use for both transform feedback and other
purposes in the GL. Speci?cally, if a buffer object is simultaneously bound to a
transform feedback buffer binding point and elsewhere in the GL, any writes to
or reads from the buffer generate unde?ned values. Examples of such bindings
include ReadPixels to a pixel buffer object binding point and client access to a
buffer mapped with MapBuffer.
However, if a buffer object is written and read sequentially by transform feed-
back and other mechanisms, it is the responsibility of the GL to ensure that data
are accessed consistently, even if the implementation performs the operations in a
pipelined manner. For example, MapBuffer may need to block pending the com-
pletion of a previous transform feedback operation.
OpenGL 3.1 - May 28, 20092.16. PRIMITIVEQUERIES 81
2.16 Primitive Queries
Primitive queries use query objects to track the number of primitives generated by
the GL and to track the number of primitives written to transform feedback buffers.
When BeginQuery is called with a target of PRIMITIVES_GENERATED, the
primitives-generated count maintained by the GL is set to zero. When the generated
primitive query is active, the primitives-generated count is incremented every time
a primitive reaches the “Discarding Primitives Before Rasterization” stage (see
section 3.1) immediately before rasterization.
When BeginQuery is called with a target of TRANSFORM_FEEDBACK_-
PRIMITIVES_WRITTEN, the transform-feedback-primitives-written count main-
tained by the GL is set to zero. When the transform feedback primitive written
query is active, the transform-feedback-primitives-written count is incremented ev-
ery time a primitive is recorded into a buffer object. If transform feedback is not
active, this counter is not incremented. If the primitive does not ?t in the buffer
object, the counter is not incremented.
These two queries can be used together to determine if all primitives have been
written to the bound feedback buffers; if both queries are run simultaneously and
the query results are equal, all primitives have been written to the buffer(s). If the
number of primitives written is less than the number of primitives generated, the
buffer is full.
2.17 Primitive Clipping
Primitives are clipped to the clip volume. In clip coordinates, the view volume
is de?ned by
 w x w
c c c
 w y w
c c c
 w z w :
c c c
This view volume may be further restricted by as many asn client-de?ned half-
spaces. (n is an implementation-dependent maximum that must be at least 6.) The
clip volume is the intersection of all such half-spaces with the view volume (if no
client-de?ned half-spaces are enabled, the clip volume is the view volume).
A vertex shader may write a single clip distance for each supported half-space
to elements of thegl_ClipDistance[] array. Half-spacen is then given by the
set of points satisfying the inequality
c (P ) 0;
n
OpenGL 3.1 - May 28, 20092.17. PRIMITIVECLIPPING 82
wherec (P ) is the value of clip distancen at pointP . For point primitives,
n
c (P ) is simply the clip distance for the vertex in question. For line and triangle
n
primitives, per-vertex clip distances are interpolated using a weighted mean, with
weights derived according to the algorithms described in sections 3.5 and 3.6.
Client-de?ned half-spaces are enabled with the generic Enable command and
disabled with the Disable command. The value of the argument to either com-
mand isCLIP_DISTANCEi wherei is an integer between 0 andn  1; specifying a
value ofi enables or disables the plane equation with indexi. The constants obey
CLIP_DISTANCEi = CLIP_DISTANCE0 +i.
If the primitive under consideration is a point, then clipping passes it un-
changed if it lies within the clip volume; otherwise, it is discarded.
If the primitive is a line segment, then clipping does nothing to it if it lies
entirely within the clip volume, and discards it if it lies entirely outside the volume.
If part of the line segment lies in the volume and part lies outside, then the
line segment is clipped and new vertex coordinates are computed for one or both
vertices. A clipped line segment endpoint lies on both the original line segment
and the boundary of the clip volume.
This clipping produces a value, 0 t 1, for each clipped vertex. If the
coordinates of a clipped vertex areP and the original vertices’ coordinates areP
1
andP , thent is given by
2
P =tP + (1 t)P :
1 2
The value oft is used to clip vertex shader varying variables as described in sec-
tion 2.17.1.
If the primitive is a polygon, then it is passed if every one of its edges lies
entirely inside the clip volume and either clipped or discarded otherwise. Polygon
clipping may cause polygon edges to be clipped, but because polygon connectivity
must be maintained, these clipped edges are connected by new edges that lie along
the clip volume’s boundary. Thus, clipping may require the introduction of new
vertices into a polygon.
If it happens that a polygon intersects an edge of the clip volume’s boundary,
then the clipped polygon must include a point on this boundary edge.
Primitives rendered with user-de?ned half-spaces must satisfy a complemen-
tarity criterion. Suppose a series of primitives is drawn where each vertexi has a
single speci?ed clip distanced (or a number of similarly speci?ed clip distances,
i
if multiple half-spaces are enabled). Next, suppose that the same series of primi-
tives are drawn again with each such clip distance replaced by d (and the GL
i
is otherwise in the same state). In this case, primitives must not be missing any
pixels, nor may any pixels be drawn twice in regions where those primitives are
cut by the clip planes.
OpenGL 3.1 - May 28, 20092.17. PRIMITIVECLIPPING 83
The state required for clipping is at least 8 bits indicating which of the client-
de?ned half-spaces are enabled. In the initial state, all half-spaces are disabled.
2.17.1 Clipping Shader Varying Outputs
Next, vertex shader varying variables are clipped. The varying values associ-
ated with a vertex that lies within the clip volume are unaffected by clipping. If a
primitive is clipped, however, the varying values assigned to vertices produced by
clipping are clipped.
Let the varying values assigned to the two verticesP andP of an unclipped
1 2
edge bec andc . The value oft (section 2.17) for a clipped pointP is used to
1 2
4
obtain the varying value associated withP as
c =tc + (1 t)c :
1 2
(Multiplying a varying value by a scalar means multiplying each of x, y, z, and w
by the scalar.)
Polygon clipping may create a clipped vertex along an edge of the clip volume’s
boundary. This situation is handled by noting that polygon clipping proceeds by
clipping against one half-space at a time. Varying value clipping is done in the
same way, so that clipped points always occur at the intersection of polygon edges
(possibly already clipped) with the clip volume’s boundary.
For vertex shader varying variables speci?ed to be interpolated without per-
spective correction (using the noperspective quali?er), the value of t used to
obtain the varying value associated withP will be adjusted to produce results that
vary linearly in screen space.
Varying outputs of integer or unsigned integer type must always be declared
with theflat quali?er. Since such varyings are constant over the primitive being
rasterized (see sections 3.5.1 and 3.6.1), no interpolation is performed.
4
Since this computation is performed in clip space before division byw , clipped varying values
c
are perspective-correct.
OpenGL 3.1 - May 28, 2009Chapter 3
Rasterization
Rasterization is the process by which a primitive is converted to a two-dimensional
image. Each point of this image contains such information as color and depth.
Thus, rasterizing a primitive consists of two parts. The ?rst is to determine which
squares of an integer grid in window coordinates are occupied by the primitive.
The second is assigning a depth value and one or more color values to each such
square. The results of this process are passed on to the next stage of the GL (per-
fragment operations), which uses the information to update the appropriate loca-
tions in the framebuffer. Figure 3.1 diagrams the rasterization process. The color
values assigned to a fragment are initially determined by the rasterization opera-
tions (sections 3.4 through 3.7) and modi?ed by a fragment shader as de?ned in
section 3.9. The ?nal depth value is initially determined by the rasterization op-
erations and may be modi?ed or replaced by a fragment shader. The results from
rasterizing a point, line, or polygon can be routed through a fragment shader.
A grid square along with its parameters of assigned colors,z (depth), fog coor-
dinate, and texture coordinates is called a fragment; the parameters are collectively
dubbed the fragment’s associated data. A fragment is located by its lower left cor-
ner, which lies on integer grid coordinates. Rasterization operations also refer to a
fragment’s center, which is offset by (1=2; 1=2) from its lower left corner (and so
lies on half-integer coordinates).
Grid squares need not actually be square in the GL. Rasterization rules are not
affected by the actual aspect ratio of the grid squares. Display of non-square grids,
however, will cause rasterized points and line segments to appear fatter in one
direction than the other. We assume that fragments are square, since it simpli?es
antialiasing and texturing.
Several factors affect rasterization. Primitives may be discarded before ras-
terization. Points may be given differing diameters and line segments differing
843.1. DISCARDINGPRIMITIVESBEFORERASTERIZATION 85
Point
Rasterization
From
Line Fragment
Primitive
Rasterization Program
Assembly
Fragments
Triangle
Rasterization
Figure 3.1. Rasterization.
widths. A point, line segment, or polygon may be antialiased.
3.1 Discarding Primitives Before Rasterization
Primitives can be optionally discarded before rasterization by calling Enable and
Disable withRASTERIZER_DISCARD. When enabled, primitives are discarded im-
mediately before the rasterization stage, but after the optional transform feedback
stage (see section 2.15). When disabled, primitives are passed through to the ras-
terization stage to be processed normally. When enabled,RASTERIZER_DISCARD
also causes the Clear and ClearBuffer* commands to be ignored.
3.2 Invariance
0
Consider a primitivep obtained by translating a primitivep through an offset (x;y)
0
in window coordinates, wherex andy are integers. As long as neitherp norp is
0 0
clipped, it must be the case that each fragmentf produced fromp is identical to
0
a corresponding fragmentf fromp except that the center off is offset by (x;y)
from the center off.
OpenGL 3.1 - May 28, 20093.3. ANTIALIASING 86
3.3 Antialiasing
The R, G, and B values of the rasterized fragment are left unaffected, but the A
value is multiplied by a ?oating-point value in the range [0; 1] that describes a
fragment’s screen pixel coverage. The per-fragment stage of the GL can be set up
to use the A value to blend the incoming fragment with the corresponding pixel
already present in the framebuffer.
The details of how antialiased fragment coverage values are computed are dif-
?cult to specify in general. The reason is that high-quality antialiasing may take
into account perceptual issues as well as characteristics of the monitor on which
the contents of the framebuffer are displayed. Such details cannot be addressed
within the scope of this document. Further, the coverage value computed for a
fragment of some primitive may depend on the primitive’s relationship to a num-
ber of grid squares neighboring the one corresponding to the fragment, and not just
on the fragment’s grid square. Another consideration is that accurate calculation
of coverage values may be computationally expensive; consequently we allow a
given GL implementation to approximate true coverage values by using a fast but
not entirely accurate coverage computation.
In light of these considerations, we chose to specify the behavior of exact an-
tialiasing in the prototypical case that each displayed pixel is a perfect square of
uniform intensity. The square is called a fragment square and has lower left corner
(x;y) and upper right corner (x+1;y+1). We recognize that this simple box ?lter
may not produce the most favorable antialiasing results, but it provides a simple,
well-de?ned model.
A GL implementation may use other methods to perform antialiasing, subject
to the following conditions:
1. Iff andf are two fragments, and the portion off covered by some prim-
1 2 1
itive is a subset of the corresponding portion off covered by the primitive,
2
then the coverage computed forf must be less than or equal to that com-
1
puted forf .
2
2. The coverage computation for a fragment f must be local: it may depend
only onf’s relationship to the boundary of the primitive being rasterized. It
may not depend onf’sx andy coordinates.
Another property that is desirable, but not required, is:
3. The sum of the coverage values for all fragments produced by rasterizing a
particular primitive must be constant, independent of any rigid motions in
window coordinates, as long as none of those fragments lies along window
edges.
OpenGL 3.1 - May 28, 20093.3. ANTIALIASING 87
In some implementations, varying degrees of antialiasing quality may be obtained
by providing GL hints (section 5.2), allowing a user to make an image quality
versus speed tradeoff.
3.3.1 Multisampling
Multisampling is a mechanism to antialias all GL primitives: points, lines, and
polygons. The technique is to sample all primitives multiple times at each pixel.
The color sample values are resolved to a single, displayable color each time a
pixel is updated, so the antialiasing appears to be automatic at the application level.
Because each sample includes color, depth, and stencil information, the color (in-
cluding texture operation), depth, and stencil functions perform equivalently to the
single-sample mode.
An additional buffer, called the multisample buffer, is added to the framebuffer.
Pixel sample values, including color, depth, and stencil values, are stored in this
buffer. Samples contain separate color values for each fragment color. When
the framebuffer includes a multisample buffer, it does not include depth or sten-
cil buffers, even if the multisample buffer does not store depth or stencil values.
Color buffers do coexist with the multisample buffer, however.
Multisample antialiasing is most valuable for rendering polygons, because it
requires no sorting for hidden surface elimination, and it correctly handles adja-
cent polygons, object silhouettes, and even intersecting polygons. If only lines
are being rendered, the “smooth” antialiasing mechanism provided by the base GL
may result in a higher quality image. This mechanism is designed to allow multi-
sample and smooth antialiasing techniques to be alternated during the rendering of
a single scene.
If the value of SAMPLE_BUFFERS is one, the rasterization of all primitives
is changed, and is referred to as multisample rasterization. Otherwise, primitive
rasterization is referred to as single-sample rasterization. The value ofSAMPLE_-
BUFFERS is queried by calling GetIntegerv with pname set toSAMPLE_BUFFERS.
During multisample rendering the contents of a pixel fragment are changed
in two ways. First, each fragment includes a coverage value with SAMPLES bits.
The value ofSAMPLES is an implementation-dependent constant, and is queried by
calling GetIntegerv with pname set toSAMPLES.
Second, each fragment includesSAMPLES depth values, color values, and sets
of texture coordinates, instead of the single depth value, color value, and set of
texture coordinates that is maintained in single-sample rendering mode. An imple-
mentation may choose to assign the same color value and the same set of texture
coordinates to more than one sample. The location for evaluating the color value
and the set of texture coordinates can be anywhere within the pixel including the
OpenGL 3.1 - May 28, 20093.4. POINTS 88
fragment center or any of the sample locations. The color value and the set of tex-
ture coordinates need not be evaluated at the same location. Each pixel fragment
thus consists of integer x and y grid coordinates,SAMPLES color and depth values,
SAMPLES sets of texture coordinates, and a coverage value with a maximum of
SAMPLES bits.
Multisample rasterization is enabled or disabled by calling Enable or Disable
with the symbolic constantMULTISAMPLE.
If MULTISAMPLE is disabled, multisample rasterization of all primitives is
equivalent to single-sample (fragment-center) rasterization, except that the frag-
ment coverage value is set to full coverage. The color and depth values and the
sets of texture coordinates may all be set to the values that would have been as-
signed by single-sample rasterization, or they may be assigned as described below
for multisample rasterization.
IfMULTISAMPLE is enabled, multisample rasterization of all primitives differs
substantially from single-sample rasterization. It is understood that each pixel in
the framebuffer has SAMPLES locations associated with it. These locations are
exact positions, rather than regions or areas, and each is referred to as a sample
point. The sample points associated with a pixel may be located inside or outside
of the unit square that is considered to bound the pixel. Furthermore, the relative
locations of sample points may be identical for each pixel in the framebuffer, or
they may differ.
If the sample locations differ per pixel, they should be aligned to window, not
screen, boundaries. Otherwise rendering results will be window-position speci?c.
The invariance requirement described in section 3.2 is relaxed for all multisample
rasterization, because the sample locations may be a function of pixel location.
It is not possible to query the actual sample locations of a pixel.
3.4 Points
If vertex program point size mode is enabled, then the derived point size is taken
from the (potentially clipped) shader built-in gl_PointSize and clamped to the
implementation-dependent point size range. If the value written togl_PointSize
is less than or equal to zero, results are unde?ned. If vertex program point size
mode is disabled, then the derived point size is speci?ed with the command
void PointSize(float size );
size speci?es the requested size of a point. The default value is 1.0. A value less
than or equal to zero results in the error INVALID_VALUE. Vertex program point
OpenGL 3.1 - May 28, 20093.4. POINTS 89
size mode is enabled and disabled by calling Enable or Disable with the symbolic
valueVERTEX_PROGRAM_POINT_SIZE.
If multisampling is enabled, an implementation may optionally fade the point
alpha (see section 3.11) instead of allowing the point width to go below a given
threshold. In this case, the width of the rasterized point is

derived size derived sizethreshold
width = (3.1)
threshold otherwise
and the fade factor is computed as follows:
(
1 derived sizethreshold
  
fade = (3.2)
2
derived size
otherwise
threshold
The point fadethreshold is speci?ed with
void PointParameterfifg(enum pname,T param );
void PointParameterfifgv(enum pname,const T params );
If pname isPOINT_FADE_THRESHOLD_SIZE, then param speci?es, or params
points to the point fadethreshold. Values of POINT_FADE_THRESHOLD_SIZE
less than zero result in the errorINVALID_VALUE.
The point sprite texture coordinate origin is set with the PointParame-
ter* commands where pname is POINT_SPRITE_COORD_ORIGIN and param is
LOWER_LEFT orUPPER_LEFT. The default value isUPPER_LEFT.
3.4.1 Basic Point Rasterization
Point rasterization produces a fragment for each framebuffer pixel whose center
lies inside a square centered at the point’s (x ;y ), with side length equal to the
w w
current point size.
All fragments produced in rasterizing a point sprite are assigned the same as-
sociated data, which are those of the vertex corresponding to the point. However,
the fragment shader builtin gl_PointCoord contains point sprite texture coor-
dinates. The s point sprite texture coordinate varies from 0 to 1 across the
point horizontally left-to-right. If POINT_SPRITE_COORD_ORIGIN is LOWER_-
LEFT, the t coordinate varies from 0 to 1 vertically bottom-to-top. Otherwise if
the point sprite texture coordinate origin is UPPER_LEFT, thet coordinate varies
from 0 to 1 vertically top-to-bottom. Ther andq coordinates are replaced with the
constants 0 and 1, respectively.
OpenGL 3.1 - May 28, 20093.4. POINTS 90
The following formula is used to evaluate thes andt point sprite texture coor-
dinates:
  
1
1 x +  x
w
f
2
s = + (3.3)
2 size
8
1
(y +  y )
< f w
1
2
+ ;POINT_SPRITE_COORD_ORIGIN = LOWER_LEFT
2 size
t =
1
y +  y
( f w)
: 1
2
  ;POINT_SPRITE_COORD_ORIGIN = UPPER_LEFT
2 size
(3.4)
wheresize is the point’s size,x andy are the (integral) window coordinates of
f f
the fragment, andx andy are the exact, unrounded window coordinates of the
w w
vertex for the point.
Not all point widths need be supported, but the width 1:0 must be provided.
The range of supported widths and the width of evenly-spaced gradations within
that range are implementation-dependent. The range and gradations may be ob-
tained using the query mechanism described in chapter 6. If, for instance, the
width range is from 0.1 to 2.0 and the gradation width is 0.1, then the widths
0:1; 0:2;:::; 1:9; 2:0 are supported. Additional point widths may also be sup-
ported. There is no requirement that these widths must be equally spaced. If
an unsupported width is requested, the nearest supported width is used instead.
3.4.2 Point Rasterization State
The state required to control point rasterization consists of the ?oating-point point
width, a bit indicating whether or not vertex program point size mode is enabled,
a bit for the point sprite texture coordinate origin, and a ?oating-point value speci-
fying the point fade threshold size.
3.4.3 Point Multisample Rasterization
IfMULTISAMPLE is enabled, and the value ofSAMPLE_BUFFERS is one, then points
are rasterized using the following algorithm Point rasterization produces a frag-
ment for each framebuffer pixel with one or more sample points that intersect a
region centered at the point’s (x ;y ). This region is a square with side equal
w w
to the current point width. Coverage bits that correspond to sample points that
intersect the region are 1, other coverage bits are 0. All data associated with each
sample for the fragment are the data associated with the point being rasterized, .
The set of point sizes supported is equivalent to those for point sprites without
multisample .
OpenGL 3.1 - May 28, 20093.5. LINESEGMENTS 91
3.5 Line Segments
A line segment results from a line strip, a line loop, or a series of separate line
segments. Line segment rasterization is controlled by several variables. Line width,
which may be set by calling
void LineWidth(float width );
with an appropriate positive ?oating-point width, controls the width of rasterized
line segments. The default width is 1:0. Values less than or equal to 0.0 generate
the error INVALID_VALUE. Antialiasing is controlled with Enable and Disable
using the symbolic constantLINE_SMOOTH.
3.5.1 Basic Line Segment Rasterization
Line segment rasterization begins by characterizing the segment as either x-major
or y-major. x-major line segments have slope in the closed interval [ 1; 1]; all
other line segments arey-major (slope is determined by the segment’s endpoints).
We shall specify rasterization only forx-major segments except in cases where the
modi?cations fory-major segments are not self-evident.
Ideally, the GL uses a “diamond-exit” rule to determine those fragments that
are produced by rasterizing a line segment. For each fragmentf with center at win-
dow coordinatesx andy , de?ne a diamond-shaped region that is the intersection
f f
of four half planes:
R =f (x;y)jjx xj +jy yj< 1=2:g
f f f
Essentially, a line segment starting atp and ending atp produces those frag-
a b
mentsf for which the segment intersectsR , except ifp is contained inR . See
f b f
?gure 3.2.
To avoid dif?culties when an endpoint lies on a boundary ofR we (in princi-
f
ple) perturb the supplied endpoints by a tiny amount. Letp andp have window
a b
0
coordinates (x ;y ) and (x ;y ), respectively. Obtain the perturbed endpointsp
a a
b b
a
2 0 2
given by (x ;y )  (; ) andp given by (x ;y )  (; ). Rasterizing the line
a a b b
b
segment starting atp and ending atp produces those fragmentsf for which the
a b
0 0 0
segment starting atp and ending onp intersectsR , except ifp is contained in
f
a
b b
R .  is chosen to be so small that rasterizing the line segment produces the same
f
fragments when is substituted for for any 0<.
When p and p lie on fragment centers, this characterization of fragments
a b
reduces to Bresenham’s algorithm with one modi?cation: lines produced in this
description are “half-open,” meaning that the ?nal fragment (corresponding top )
b
OpenGL 3.1 - May 28, 20093.5. LINESEGMENTS 92
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
Figure 3.2. Visualization of Bresenham’s algorithm. A portion of a line segment is
shown. A diamond shaped region of height 1 is placed around each fragment center;
those regions that the line segment exits cause rasterization to produce correspond-
ing fragments.
is not drawn. This means that when rasterizing a series of connected line segments,
shared endpoints will be produced only once rather than twice (as would occur with
Bresenham’s algorithm).
Because the initial and ?nal conditions of the diamond-exit rule may be dif?cult
to implement, other line segment rasterization algorithms are allowed, subject to
the following rules:
1. The coordinates of a fragment produced by the algorithm may not deviate by
more than one unit in eitherx ory window coordinates from a corresponding
fragment produced by the diamond-exit rule.
2. The total number of fragments produced by the algorithm may differ from
that produced by the diamond-exit rule by no more than one.
3. For anx-major line, no two fragments may be produced that lie in the same
window-coordinate column (for ay-major line, no two fragments may ap-
pear in the same row).
4. If two line segments share a common endpoint, and both segments are either
x-major (both left-to-right or both right-to-left) ory-major (both bottom-to-
top or both top-to-bottom), then rasterizing both segments may not produce
OpenGL 3.1 - May 28, 20093.5. LINESEGMENTS 93
duplicate fragments, nor may any fragments be omitted so as to interrupt
continuity of the connected segments.
Next we must specify how the data associated with each rasterized fragment
are obtained. Let the window coordinates of a produced fragment center be given
byp = (x ;y ) and letp = (x ;y ) andp = (x ;y ). Set
r d d a a a b b b
(p  p ) (p  p )
r a b a
t = : (3.5)
2
kp  pk
b a
(Note thatt = 0 atp andt = 1 atp .) The value of an associated datumf for the
a
b
fragment, whether it be a varying shader output or the clipw coordinate, is found
as
(1 t)f =w +tf =w
a a b b
f = (3.6)
(1 t)=w +t=w
a b
wheref andf are the data associated with the starting and ending endpoints of
a b
the segment, respectively;w andw are the clipw coordinates of the starting and
a
b
ending endpoints of the segments, respectively. However, depth values for lines
must be interpolated by
z = (1 t)z +tz (3.7)
a b
wherez andz are the depth values of the starting and ending endpoints of the
a b
segment, respectively.
The noperspective and flat keywords used to declare varying shader
outputs affect how they are interpolated. When neither keyword is speci?ed, inter-
polation is performed as described in equation 3.6. When thenoperspective
keyword is speci?ed, interpolation is performed in the same fashion as for depth
values, as described in equation 3.7. When the flat keyword is speci?ed, no
interpolation is performed, and varying outputs are taken from the corresponding
generic attribute value of the last (highest numbered) vertex transferred to the GL
corresponding to that primitive.
3.5.2 Other Line Segment Features
We have just described the rasterization of non-antialiased line segments of width
one. We now describe the rasterization of line segments for general values of the
line segment rasterization parameters.
OpenGL 3.1 - May 28, 20093.5. LINESEGMENTS 94
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
Figure 3.3. The region used in rasterizing and ?nding corresponding coverage val-
ues for an antialiased line segment (an x-major line segment is shown).
Antialiasing
Rasterized antialiased line segments produce fragments whose fragment squares
intersect a rectangle centered on the line segment. Two of the edges are parallel to
the speci?ed line segment; each is at a distance of one-half the current width from
that segment: one above the segment and one below it. The other two edges pass
through the line endpoints and are perpendicular to the direction of the speci?ed
line segment. Coverage values are computed for each fragment by computing the
area of the intersection of the rectangle with the fragment square (see ?gure 3.3;
see also section 3.3). Equation 3.6 is used to compute associated data values just as
with non-antialiased lines; equation 3.5 is used to ?nd the value oft for each frag-
ment whose square is intersected by the line segment’s rectangle. Not all widths
need be supported for line segment antialiasing, but width 1:0 antialiased segments
must be provided. As with the point width, a GL implementation may be queried
for the range and number of gradations of available antialiased line widths.
3.5.3 Line Rasterization State
The state required for line rasterization consists of the ?oating-point line width
and a bit indicating whether line antialiasing is on or off. The initial value of the
line width is 1:0. The initial state of line segment antialiasing is disabled.
OpenGL 3.1 - May 28, 20093.6. POLYGONS 95
3.5.4 Line Multisample Rasterization
IfMULTISAMPLE is enabled, and the value ofSAMPLE_BUFFERS is one, then lines
are rasterized using the following algorithm, regardless of whether line antialiasing
(LINE_SMOOTH) is enabled or disabled. Line rasterization produces a fragment for
each framebuffer pixel with one or more sample points that intersect the rectangular
region that is described in the Antialiasing portion of section 3.5.2 (Other Line
Segment Features).
Coverage bits that correspond to sample points that intersect a retained rectan-
gle are 1, other coverage bits are 0. Each color, depth, and set of texture coordinates
is produced by substituting the corresponding sample location into equation 3.5,
then using the result to evaluate equation 3.7. An implementation may choose to
assign the same color value and the same set of texture coordinates to more than
one sample by evaluating equation 3.5 at any location within the pixel including
the fragment center or any one of the sample locations, then substituting into equa-
tion 3.6. The color value and the set of texture coordinates need not be evaluated
at the same location.
Line width range and number of gradations are equivalent to those supported
for antialiased lines.
3.6 Polygons
A polygon results from a triangle arising from a triangle strip, triangle fan, or
series of separate triangles. Like points and line segments, polygon rasterization
is controlled by several variables. Polygon antialiasing is controlled with Enable
and Disable with the symbolic constantPOLYGON_SMOOTH.
3.6.1 Basic Polygon Rasterization
The ?rst step of polygon rasterization is to determine if the polygon is back-facing
or front-facing. This determination is made based on the sign of the (clipped or
unclipped) polygon’s area computed in window coordinates. One way to compute
this area is
n 1
X
1
i i1 i1 i
a = x y  x y (3.8)
w w w w
2
i=0
i i
where x and y are the x and y window coordinates of the ith vertex of
w w
then-vertex polygon (vertices are numbered starting at zero for purposes of this
OpenGL 3.1 - May 28, 20093.6. POLYGONS 96
computation) andi1 is (i+1) modn. The interpretation of the sign of this value
is controlled with
void FrontFace(enum dir );
Setting dir toCCW (corresponding to counter-clockwise orientation of the pro-
jected polygon in window coordinates) usesa as computed above. Setting dir to
CW (corresponding to clockwise orientation) indicates that the sign ofa should be
reversed prior to use. Front face determination requires one bit of state, and is
initially set toCCW.
If the sign ofa (including the possible reversal of this sign as determined by
FrontFace) is positive, the polygon is front-facing; otherwise, it is back-facing.
This determination is used in conjunction with the CullFace enable bit and mode
value to decide whether or not a particular polygon is rasterized. The CullFace
mode is set by calling
void CullFace(enum mode );
mode is a symbolic constant: one of FRONT, BACK or FRONT_AND_BACK. Culling
is enabled or disabled with Enable or Disable using the symbolic constantCULL_-
FACE. Front-facing polygons are rasterized if either culling is disabled or the Cull-
Face mode isBACK while back-facing polygons are rasterized only if either culling
is disabled or the CullFace mode is FRONT. The initial setting of the CullFace
mode isBACK. Initially, culling is disabled.
The rule for determining which fragments are produced by polygon rasteriza-
tion is called point sampling. The two-dimensional projection obtained by taking
the x and y window coordinates of the polygon’s vertices is formed. Fragment
centers that lie inside of this polygon are produced by rasterization. Special treat-
ment is given to a fragment whose center lies on a polygon edge. In such a case
we require that if two polygons lie on either side of a common edge (with identical
endpoints) on which a fragment center lies, then exactly one of the polygons results
in the production of the fragment during rasterization.
As for the data associated with each fragment produced by rasterizing a poly-
gon, we begin by specifying how these values are produced for fragments in a
triangle. De?ne barycentric coordinates for a triangle. Barycentric coordinates are
a set of three numbers, a, b, andc, each in the range [0; 1], witha +b +c = 1.
These coordinates uniquely specify any pointp within the triangle or on the trian-
gle’s boundary as
p =ap +bp +cp ;
a c
b
OpenGL 3.1 - May 28, 20093.6. POLYGONS 97
wherep ,p , andp are the vertices of the triangle.a,b, andc can be found as
a b c
A(pp p ) A(pp p ) A(pp p )
c a c a
b b
a = ; b = ; c = ;
A(p p p ) A(p p p ) A(p p p )
a b c a b c a b c
where A(lmn) denotes the area in window coordinates of the triangle with vertices
l,m, andn.
Denote an associated datum atp ,p , orp asf ,f , orf , respectively. Then
a b c a b c
the valuef of a datum at a fragment produced by rasterizing a triangle is given by
af =w +bf =w +cf =w
a a c c
b b
f = (3.9)
a=w +b=w +c=w
a b c
where w , w and w are the clip w coordinates of p , p , and p , respectively.
a b c a b c
a,b, andc are the barycentric coordinates of the fragment for which the data are
produced. a, b, and c must correspond precisely to the exact coordinates of the
center of the fragment. Another way of saying this is that the data associated with
a fragment must be sampled at the fragment’s center. However, depth values for
polygons must be interpolated by
z =az +bz +cz (3.10)
a b c
wherez ,z , andz are the depth values ofp ,p , andp , respectively.
a b c a b c
The noperspective and flat keywords used to declare varying shader
outputs affect how they are interpolated. When neither keyword is speci?ed, inter-
polation is performed as described in equation 3.9. When thenoperspective
keyword is speci?ed, interpolation is performed in the same fashion as for depth
values, as described in equation 3.10. When the flat keyword is speci?ed, no
interpolation is performed, and varying outputs are taken from the corresponding
generic attribute value of the last (highest numbered) vertex transferred to the GL
corresponding to that primitive.
For a polygon with more than three edges, such as may be produced by clipping
a triangle, we require only that a convex combination of the values of the datum
at the polygon’s vertices can be used to obtain the value assigned to each fragment
produced by the rasterization algorithm. That is, it must be the case that at every
fragment
n
X
f = af
i i
i=1
wheren is the number of vertices in the polygon,f is the value of thef at vertex
i
P
n
i; for eachi 0 a  1 and a = 1. The values of thea may differ from
i i i
i=1
fragment to fragment, but at vertexi,a = 0;j6=i anda = 1.
j i
OpenGL 3.1 - May 28, 20093.6. POLYGONS 98
One algorithm that achieves the required behavior is to triangulate a polygon
(without adding any vertices) and then treat each triangle individually as already
discussed. A scan-line rasterizer that linearly interpolates data along each edge
and then linearly interpolates data across each horizontal span from edge to edge
also satis?es the restrictions (in this case, the numerator and denominator of equa-
tion 3.9 should be iterated independently and a division performed for each frag-
ment).
3.6.2 Antialiasing
Polygon antialiasing rasterizes a polygon by producing a fragment wherever the
interior of the polygon intersects that fragment’s square. A coverage value is com-
puted at each such fragment, and this value is saved to be applied as described
in section 3.10. An associated datum is assigned to a fragment by integrating the
datum’s value over the region of the intersection of the fragment square with the
polygon’s interior and dividing this integrated value by the area of the intersection.
For a fragment square lying entirely within the polygon, the value of a datum at the
fragment’s center may be used instead of integrating the value across the fragment.
3.6.3 Options Controlling Polygon Rasterization
The interpretation of polygons for rasterization is controlled using
void PolygonMode(enum face,enum mode );
face must be FRONT_AND_BACK, indicating that the rasterizing method described
by mode replaces the rasterizing method for both front- and back-facing polygons.
mode is one of the symbolic constants POINT, LINE, or FILL. Calling Polygon-
Mode withPOINT causes the vertices of a polygon to be treated, for rasterization
purposes, as if they had been drawn with mode POINTS. LINE causes edges to
be rasterized as line segments. FILL is the default mode of polygon rasteriza-
tion, corresponding to the description in sections 3.6.1, and 3.6.2. Note that these
modes affect only the ?nal rasterization of polygons: in particular, a polygon’s ver-
tices are lit, and the polygon is clipped and possibly culled before these modes are
applied.
Polygon antialiasing applies only to the FILL state of PolygonMode. For
POINT or LINE, point antialiasing or line segment antialiasing, respectively, ap-
ply.
OpenGL 3.1 - May 28, 20093.6. POLYGONS 99
3.6.4 Depth Offset
The depth values of all fragments generated by the rasterization of a polygon may
be offset by a single value that is computed for that polygon. The function that
determines this value is speci?ed by calling
void PolygonOffset(float factor,float units );
factor scales the maximum depth slope of the polygon, and units scales an
implementation-dependent constant that relates to the usable resolution of the
depth buffer. The resulting values are summed to produce the polygon offset value.
Both factor and units may be either positive or negative.
The maximum depth slopem of a triangle is
s
   
2 2
@z @z
w w
m = + (3.11)
@x @y
w w
where (x ;y ;z ) is a point on the triangle.m may be approximated as
w w w
   
 
   
@z @z
w w
   
m = max ; : (3.12)
   
@x @y
w w
The minimum resolvable differencer is an implementation-dependent param-
eter that depends on the depth buffer representation. It is the smallest difference in
window coordinatez values that is guaranteed to remain distinct throughout poly-
gon rasterization and in the depth buffer. All pairs of fragments generated by the
rasterization of two polygons with otherwise identical vertices, butz values that
w
differ byr, will have distinct depth values.
For ?xed-point depth buffer representations,r is constant throughout the range
of the entire depth buffer. For ?oating-point depth buffers, there is no single min-
imum resolvable difference. In this case, the minimum resolvable difference for a
given polygon is dependent on the maximum exponent,e, in the range ofz values
spanned by the primitive. Ifn is the number of bits in the ?oating-point mantissa,
the minimum resolvable difference,r, for the given primitive is de?ned as
e n
r = 2 :
The offset valueo for a polygon is
o =mfactor +runits: (3.13)
m is computed as described above. If the depth buffer uses a ?xed-point represen-
tation,m is a function of depth values in the range [0; 1], ando is applied to depth
values in the same range.
OpenGL 3.1 - May 28, 20093.6. POLYGONS 100
Boolean state values POLYGON_OFFSET_POINT, POLYGON_OFFSET_LINE,
andPOLYGON_OFFSET_FILL determine whethero is applied during the rasteriza-
tion of polygons inPOINT,LINE, andFILL modes. These boolean state values are
enabled and disabled as argument values to the commands Enable and Disable.
If POLYGON_OFFSET_POINT is enabled, o is added to the depth value of each
fragment produced by the rasterization of a polygon in POINT mode. Likewise,
ifPOLYGON_OFFSET_LINE orPOLYGON_OFFSET_FILL is enabled,o is added to
the depth value of each fragment produced by the rasterization of a polygon in
LINE orFILL modes, respectively.
For ?xed-point depth buffers, fragment depth values are always limited to the
range [0; 1], either by clamping after offset addition is performed (preferred), or by
clamping the vertex values used in the rasterization of the polygon. Fragment depth
values are clamped even when the depth buffer uses a ?oating-point representation.
3.6.5 Polygon Multisample Rasterization
IfMULTISAMPLE is enabled and the value ofSAMPLE_BUFFERS is one, then poly-
gons are rasterized using the following algorithm, regardless of whether polygon
antialiasing (POLYGON_SMOOTH) is enabled or disabled. Polygon rasterization pro-
duces a fragment for each framebuffer pixel with one or more sample points that
satisfy the point sampling criteria described in section 3.6.1. If a polygon is
culled, based on its orientation and the CullFace mode, then no fragments are pro-
duced during rasterization.
Coverage bits that correspond to sample points that satisfy the point sampling
criteria are 1, other coverage bits are 0. Each associated datum is produced as
described in section 3.6.1, but using the corresponding sample location instead of
the fragment center. An implementation may choose to assign the same associated
data values to more than one sample by barycentric evaluation using any location
within the pixel including the fragment center or one of the sample locations.
When using a vertex shader, thenoperspective andflat keywords affect
how varying shader outputs are interpolated, as described in the OpenGL Shading
Language Specification.
The rasterization described above applies only to the FILL state of Polygon-
Mode. For POINT and LINE, the rasterizations described in sections 3.4.3 (Point
Multisample Rasterization) and 3.5.4 (Line Multisample Rasterization) apply.
3.6.6 Polygon Rasterization State
The state required for polygon rasterization consists of the current state of polygon
antialiasing (enabled or disabled), the current values of the PolygonMode setting,
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 101
whether point, line, and ?ll mode polygon offsets are enabled or disabled, and
the factor and bias values of the polygon offset equation. The initial setting of
polygon antialiasing is disabled. The initial state for PolygonMode isFILL . The
initial polygon offset factor and bias values are both 0; initially polygon offset is
disabled for all modes.
3.7 Pixel Rectangles
Rectangles of color, depth, and certain other values may be speci?ed to the GL
using TexImage*D (see section 3.8.1). Some of the parameters and operations
governing the operation of these commands are shared by ReadPixels (used to
obtain pixel values from the framebuffer); the discussion of ReadPixels, how-
ever, is deferred until chapter 4 after the framebuffer has been discussed in detail.
Nevertheless, we note in this section when parameters and state pertaining to these
commands also pertain to ReadPixels.
A number of parameters control the encoding of pixels in buffer object or client
memory (for reading and writing) and how pixels are processed before being placed
in or after being read from the framebuffer (for reading, writing, and copying).
These parameters are set with PixelStore.
3.7.1 Pixel Storage Modes and Pixel Buffer Objects
Pixel storage modes affect the operation of TexImage*D, TexSubImage*D, and
ReadPixels when one of these commands is issued. Pixel storage modes are set
with
void PixelStorefifg(enum pname,T param );
pname is a symbolic constant indicating a parameter to be set, and param is the
value to set it to. Table 3.1 summarizes the pixel storage parameters, their types,
their initial values, and their allowable ranges. Setting a parameter to a value out-
side the given range results in the errorINVALID_VALUE.
The version of PixelStore that takes a ?oating-point value may be used to
set any type of parameter; if the parameter is boolean, then it is set to FALSE if
the passed value is 0:0 and TRUE otherwise, while if the parameter is an integer,
then the passed value is rounded to the nearest integer. The integer version of
the command may also be used to set any type of parameter; if the parameter is
boolean, then it is set toFALSE if the passed value is 0 andTRUE otherwise, while
if the parameter is a ?oating-point value, then the passed value is converted to
?oating-point.
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 102
Parameter Name Type Initial Value Valid Range
UNPACK_SWAP_BYTES boolean FALSE TRUE/FALSE
UNPACK_LSB_FIRST boolean FALSE TRUE/FALSE
UNPACK_ROW_LENGTH integer 0 [0;1)
UNPACK_SKIP_ROWS integer 0 [0;1)
UNPACK_SKIP_PIXELS integer 0 [0;1)
UNPACK_ALIGNMENT integer 4 1,2,4,8
UNPACK_IMAGE_HEIGHT integer 0 [0;1)
UNPACK_SKIP_IMAGES integer 0 [0;1)
Table 3.1: PixelStore parameters pertaining to one or more of TexImage1D, Tex-
Image2D, TexImage3D, TexSubImage1D, TexSubImage2D, and TexSubIm-
age3D.
In addition to storing pixel data in client memory, pixel data may also be
stored in buffer objects (described in section 2.9). The current pixel unpack and
pack buffer objects are designated by thePIXEL_UNPACK_BUFFER andPIXEL_-
PACK_BUFFER targets respectively.
Initially, zero is bound for the PIXEL_UNPACK_BUFFER, indicating that im-
age speci?cation commands such as TexImage*D source their pixels from client
memory pointer parameters. However, if a non-zero buffer object is bound as the
current pixel unpack buffer, then the pointer parameter is treated as an offset into
the designated buffer object.
3.7.2 Transfer of Pixel Rectangles
The process of transferring pixels encoded in buffer object or client memory
is diagrammed in ?gure 3.4. We describe the stages of this process in the order in
which they occur.
Commands accepting or returning pixel rectangles take the following argu-
ments (as well as additional arguments speci?c to their function):
format is a symbolic constant indicating what the values in memory represent.
width and height are the width and height, respectively, of the pixel rectangle
to be transferred.
data refers to the data to be drawn. These data are represented with one of
several GL data types, speci?ed by type. The correspondence between the type
token values and the GL data types they indicate is given in table 3.2.
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 103
byte, short, int, float, or packed
pixel component data stream
Unpack
Pixel Storage
Operations
Convert to Float
Expansion to
RGBA
RGBA pixel data out
Figure 3.4. Transfer of pixel rectangles to the GL. Output is RGBA pixels. Depth
and stencil pixel paths are not shown.
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 104
Not all combinations of format and type are valid. If format is DEPTH_-
STENCIL and type is not UNSIGNED_INT_24_8 or FLOAT_32_UNSIGNED_-
INT_24_8_REV, then the error INVALID_ENUM occurs. If format is one of the
integer component formats as de?ned in table 3.3 and type is FLOAT, the error
INVALID_ENUM occurs. Some additional constraints on the combinations of for-
mat and type values that are accepted are discussed below. Additional restrictions
may be imposed by speci?c commands.
Unpacking
Data are taken from the currently bound pixel unpack buffer or client memory as a
sequence of signed or unsigned bytes (GL data typesbyte andubyte), signed or
unsigned short integers (GL data typesshort andushort), signed or unsigned
integers (GL data types int and uint), or ?oating point values (GL data types
half and float). These elements are grouped into sets of one, two, three, or
four values, depending on the format, to form a group. Table 3.3 summarizes the
format of groups obtained from memory; it also indicates those formats that yield
indices and those that yield ?oating-point or integer components.
If a pixel unpack buffer is bound (as indicated by a non-zero value ofPIXEL_-
UNPACK_BUFFER_BINDING), data is an offset into the pixel unpack buffer and
the pixels are unpacked from the buffer relative to this offset; otherwise, data is a
pointer to client memory and the pixels are unpacked from client memory relative
to the pointer. If a pixel unpack buffer object is bound and unpacking the pixel data
according to the process described below would access memory beyond the size of
the pixel unpack buffer’s memory size, anINVALID_OPERATION error results. If a
pixel unpack buffer object is bound and data is not evenly divisible by the number
of basic machine units needed to store in memory the corresponding GL data type
from table 3.2 for the type parameter, anINVALID_OPERATION error results.
By default the values of each GL data type are interpreted as they would be
speci?ed in the language of the client’s GL binding. If UNPACK_SWAP_BYTES is
enabled, however, then the values are interpreted with the bit orderings modi?ed
as per table 3.4. The modi?ed bit orderings are de?ned only if the GL data type
ubyte has eight bits, and then for each speci?c GL data type only if that type is
represented with 8, 16, or 32 bits.
The groups in memory are treated as being arranged in a rectangle. This rect-
angle consists of a series of rows, with the ?rst element of the ?rst group of the
?rst row pointed to by data. If the value ofUNPACK_ROW_LENGTH is not positive,
then the number of groups in a row is width; otherwise the number of groups is
UNPACK_ROW_LENGTH. Ifp indicates the location in memory of the ?rst element
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 105
type Parameter Corresponding Special
Token Name GL Data Type Interpretation
UNSIGNED_BYTE ubyte No
BYTE byte No
UNSIGNED_SHORT ushort No
SHORT short No
UNSIGNED_INT uint No
INT int No
HALF_FLOAT half No
FLOAT float No
UNSIGNED_BYTE_3_3_2 ubyte Yes
UNSIGNED_BYTE_2_3_3_REV ubyte Yes
UNSIGNED_SHORT_5_6_5 ushort Yes
UNSIGNED_SHORT_5_6_5_REV ushort Yes
UNSIGNED_SHORT_4_4_4_4 ushort Yes
UNSIGNED_SHORT_4_4_4_4_REV ushort Yes
UNSIGNED_SHORT_5_5_5_1 ushort Yes
UNSIGNED_SHORT_1_5_5_5_REV ushort Yes
UNSIGNED_INT_8_8_8_8 uint Yes
UNSIGNED_INT_8_8_8_8_REV uint Yes
UNSIGNED_INT_10_10_10_2 uint Yes
UNSIGNED_INT_2_10_10_10_REV uint Yes
UNSIGNED_INT_24_8 uint Yes
UNSIGNED_INT_10F_11F_11F_REV uint Yes
UNSIGNED_INT_5_9_9_9_REV uint Yes
FLOAT_32_UNSIGNED_INT_24_8_REV n/a Yes
Table 3.2: Pixel data type parameter values and the corresponding GL data types.
Refer to table 2.2 for de?nitions of GL data types. Special interpretations are
described near the end of section 3.5.
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 106
Format Name Element Meaning and Order Target Buffer
STENCIL_INDEX Stencil Index Stencil
DEPTH_COMPONENT Depth Depth
DEPTH_STENCIL Depth and Stencil Index Depth and Stencil
RED R Color
GREEN G Color
BLUE B Color
RG R, G Color
RGB R, G, B Color
RGBA R, G, B, A Color
BGR B, G, R Color
BGRA B, G, R, A Color
RED_INTEGER iR Color
GREEN_INTEGER iG Color
BLUE_INTEGER iB Color
RG_INTEGER iR, iG Color
RGB_INTEGER iR, iG, iB Color
RGBA_INTEGER iR, iG, iB, iA Color
BGR_INTEGER iB, iG, iR Color
BGRA_INTEGER iB, iG, iR, iA Color
Table 3.3: Pixel data formats. The second column gives a description of and the
number and order of elements in a group. Unless speci?ed as an index, formats
yield components. Components are ?oating-point unless pre?xed with the letter
’i’, which indicates they are integer.
Element Size Default Bit Ordering Modi?ed Bit Ordering
8 bit [7::0] [7::0]
16 bit [15::0] [7::0][15::8]
32 bit [31::0] [7::0][15::8][23::16][31::24]
Table 3.4: Bit ordering modi?cation of elements when UNPACK_SWAP_BYTES is
enabled. These reorderings are de?ned only when GL data typeubyte has 8 bits,
and then only for GL data types with 8, 16, or 32 bits. Bit 0 is the least signi?cant.
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 107
ROW_LENGTH
                   
                   
                   
                   
      subimage             
                   
                   
SKIP_PIXELS
                   
SKIP_ROWS
Figure 3.5. Selecting a subimage from an image. The indicated parameter names
are pre?xed byUNPACK_ for TexImage* and byPACK_ for ReadPixels.
of the ?rst row, then the ?rst element of theNth row is indicated by
p +Nk (3.14)
whereN is the row number (counting from zero) and k is de?ned as

nl sa;
k = (3.15)
a=sdsnl=ae s<a
where n is the number of elements in a group, l is the number of groups in
the row, a is the value of UNPACK_ALIGNMENT, ands is the size, in units of GL
ubytes, of an element. If the number of bits per element is not 1, 2, 4, or 8 times
the number of bits in a GLubyte, thenk =nl for all values ofa.
There is a mechanism for selecting a sub-rectangle of groups from a
larger containing rectangle. This mechanism relies on three integer parameters:
UNPACK_ROW_LENGTH, UNPACK_SKIP_ROWS, and UNPACK_SKIP_PIXELS. Be-
fore obtaining the ?rst group from memory, the data pointer is advanced by
(UNPACK_SKIP_PIXELS)n + (UNPACK_SKIP_ROWS)k elements. Then width
groups are obtained from contiguous elements in memory (without advancing the
pointer), after which the pointer is advanced byk elements. height sets of width
groups of values are obtained this way. See ?gure 3.5.
Special Interpretations
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 108
type Parameter GL Data Number of Matching
Token Name Type Components Pixel Formats
UNSIGNED_BYTE_3_3_2 ubyte 3 RGB
UNSIGNED_BYTE_2_3_3_REV ubyte 3 RGB
UNSIGNED_SHORT_5_6_5 ushort 3 RGB
UNSIGNED_SHORT_5_6_5_REV ushort 3 RGB
UNSIGNED_SHORT_4_4_4_4 ushort 4 RGBA,BGRA
UNSIGNED_SHORT_4_4_4_4_REV ushort 4 RGBA,BGRA
UNSIGNED_SHORT_5_5_5_1 ushort 4 RGBA,BGRA
UNSIGNED_SHORT_1_5_5_5_REV ushort 4 RGBA,BGRA
UNSIGNED_INT_8_8_8_8 uint 4 RGBA,BGRA
UNSIGNED_INT_8_8_8_8_REV uint 4 RGBA,BGRA
UNSIGNED_INT_10_10_10_2 uint 4 RGBA,BGRA
UNSIGNED_INT_2_10_10_10_REV uint 4 RGBA,BGRA
UNSIGNED_INT_24_8 uint 2 DEPTH_STENCIL
UNSIGNED_INT_10F_11F_11F_REV uint 3 RGB
UNSIGNED_INT_5_9_9_9_REV uint 4 RGB
FLOAT_32_UNSIGNED_INT_24_8_REV n/a 2 DEPTH_STENCIL
Table 3.5: Packed pixel formats.
A type matching one of the types in table 3.5 is a special case in which all
the components of each group are packed into a single unsigned byte, unsigned
short, or unsigned int, depending on the type. If type isFLOAT_32_UNSIGNED_-
INT_24_8_REV, the components of each group are contained within two 32-bit
words; the ?rst word contains the ?oat component, and the second word contains
a packed 24-bit unused ?eld, followed by an 8-bit component. The number of
components per packed pixel is ?xed by the type, and must match the number of
components per group indicated by the format parameter, as listed in table 3.5.
The error INVALID_OPERATION is generated by any command processing pixel
rectangles if a mismatch occurs.
Bit?eld locations of the ?rst, second, third, and fourth components of each
packed pixel type are illustrated in tables 3.6- 3.9. Each bit?eld is interpreted as
an unsigned integer value. If the base GL type is supported with more than the
minimum precision (e.g. a 9-bit byte) the packed components are right-justi?ed in
the pixel.
Components are normally packed with the ?rst component in the most signif-
icant bits of the bit?eld, and successive component occupying progressively less
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 109
signi?cant locations. Types whose token names end with_REV reverse the compo-
nent packing order from least to most signi?cant locations. In all cases, the most
signi?cant bit of each component is packed in the most signi?cant bit location of
its location in the bit?eld.
UNSIGNED_BYTE_3_3_2:
7 6 5 4 3 2 1 0
1stComponent 2nd 3rd
UNSIGNED_BYTE_2_3_3_REV:
7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
Table 3.6: UNSIGNED_BYTE formats. Bit numbers are indicated for each compo-
nent.
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 110
UNSIGNED_SHORT_5_6_5:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd
UNSIGNED_SHORT_5_6_5_REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
UNSIGNED_SHORT_4_4_4_4:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED_SHORT_4_4_4_4_REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED_SHORT_5_5_5_1:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED_SHORT_1_5_5_5_REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
Table 3.7: UNSIGNED_SHORT formats
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 111
UNSIGNED_INT_8_8_8_8:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED_INT_8_8_8_8_REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED_INT_10_10_10_2:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED_INT_2_10_10_10_REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED_INT_24_8:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd
UNSIGNED_INT_10F_11F_11F_REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
UNSIGNED_INT_5_9_9_9_REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
Table 3.8: UNSIGNED_INT formats
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 112
FLOAT_32_UNSIGNED_INT_24_8_REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
Unused 2nd
Table 3.9: FLOAT_UNSIGNED_INT formats
OpenGL 3.1 - May 28, 20093.7. PIXELRECTANGLES 113
Format First Second Third Fourth
Component Component Component Component
RGB red green blue
RGBA red green blue alpha
BGRA blue green red alpha
DEPTH_STENCIL depth stencil
Table 3.10: Packed pixel ?eld assignments.
The assignment of component to ?elds in the packed pixel is as described in
table 3.10.
Byte swapping, if enabled, is performed before the components are extracted
from each pixel. The above discussions of row length and image extraction are
valid for packed pixels, if “group” is substituted for “component” and the number
of components per group is understood to be one.
A type ofUNSIGNED_INT_10F_11F_11F_REV and format ofRGB is a special
case in which the data are a series of GLuint values. Each uint value speci?es 3
packed components as shown in table 3.8. The 1st, 2nd, and 3rd components are
calledf (11 bits),f (11 bits), andf (10 bits) respectively.
red green blue
f and f are treated as unsigned 11-bit ?oating-point values and con-
red green
verted to ?oating-point red and green components respectively as described in sec-
tion 2.1.3.f is treated as an unsigned 10-bit ?oating-point value and converted
blue
to a ?oating-point blue component as described in section 2.1.4.
A type ofUNSIGNED_INT_5_9_9_9_REV and format ofRGB is a special case
in which the data are a series of GL uint values. Each uint value speci?es 4
packed components as shown in table 3.8. The 1st, 2nd, 3rd, and 4th components
are called p , p , p , and p respectively and are treated as unsigned
red green blue exp
integers. These are then used to compute ?oating-pointRGB components (ignoring
the ”Conversion to ?oating-point” section below in this case) as follows:
p  B N
exp
red =p 2
red
p  B N
exp
green =p 2
green
p  B N
exp
blue =p 2
blue
whereB = 15 (the exponent bias) andN = 9 (the number of mantissa bits).
OpenGL 3.1 - May 28, 20093.8. TEXTURING 114
Conversion to ?oating-point
This step applies only to groups of ?oating-point components. It is not performed
on indices or integer components. For groups containing both components and
indices, such asDEPTH_STENCIL, the indices are not converted.
Each element in a group is converted to a ?oating-point value. For unsigned
integer elements, equation 2.1 is used. For signed integer elements, equation 2.2
is used unless the ?nal destination of the transferred element is a texture or frame-
buffer component in one of the SNORM formats described in table 3.12, in which
case equation 2.3 is used instead.
Final Expansion to RGBA
This step is performed only for non-depth component groups. Each group is con-
verted to a group of 4 elements as follows: if a group does not contain an A ele-
ment, then A is added and set to 1 for integer components or 1.0 for ?oating-point
components. If any of R, G, or B is missing from the group, each missing element
is added and assigned a value of 0 for integer components or 0.0 for ?oating-point
components.
3.8 Texturing
Texturing maps a portion of one or more speci?ed images onto a fragment or
vertex. This mapping is accomplished in shaders by sampling the color of an
image at the location indicated by speci?ed (s;t;r) texture coordinates. Texture
lookups are typically used to modify a fragment’s RGBA color but may be used
for any purpose in a shader.
The internal data type of a texture may be signed or unsigned normalized
?xed-point, signed or unsigned integer, or ?oating-point, depending on the inter-
nal format of the texture. The correspondence between the internal format and the
internal data type is given in tables 3.12-3.13. Fixed-point and ?oating-point tex-
tures return a ?oating-point value and integer textures return signed or unsigned
integer values. The fragment shader is responsible for interpreting the result of a
texture lookup as the correct data type, otherwise the result is unde?ned.
Eight types of texture are supported; each is a collection of images built from
one-, two-, or three-dimensional array of image elements referred to as texels.
One-, two-, and three-dimensional textures consist respectively of one-, two-, or
three-dimensional texel arrays. One- and two-dimensional array textures are arrays
of one- or two-dimensional images, consisting of one or more layers. Cube maps
are special two-dimensional array textures with six layers that represent the faces
OpenGL 3.1 - May 28, 20093.8. TEXTURING 115
of a cube. When accessing a cube map, the texture coordinates are projected onto
one of the six faces of the cube. Rectangular textures are special two-dimensional
textures consisting of only a single image and accessed using unnormalized coor-
dinates. Buffer textures are special one-dimensional textures whose texel arrays
are stored in separate buffer objects.
Implementations must support texturing using multiple images. The following
subsections (up to and including section 3.8.8) specify the GL operation with a
single texture. The process by which multiple texture images may be sampled and
combined by the application-supplied vertex and fragment shaders is described in
sections 2.11 and 3.9.
The coordinates used for texturing in a fragment shader are de?ned by the
OpenGL Shading Language Specification.
The command
void ActiveTexture(enum texture );
speci?es the active texture unit selector, ACTIVE_TEXTURE. Each texture image
unit consists of all the texture state de?ned in section 3.8.
The active texture unit selector selects the texture image unit accessed by com-
mands involving texture image processing. Such commands include TexPa-
rameter, TexImage, BindTexture, and queries of all such state. If the texture
image unit number corresponding to the current value of ACTIVE_TEXTURE is
greater than or equal to the implementation-dependent constantMAX_COMBINED_-
TEXTURE_IMAGE_UNITS, the error INVALID_OPERATION is generated by any
such command.
ActiveTexture generates the errorINVALID_ENUM if an invalid texture is spec-
i?ed. texture is a symbolic constant of the formTEXTUREi, indicating that texture
uniti is to be modi?ed. The constants obeyTEXTUREi = TEXTURE0+i (i is in the
range 0 tok  1, wherek is the value of MAX_COMBINED_TEXTURE_IMAGE_-
UNITS).
The state required for the active texture image unit selector is a single integer.
The initial value isTEXTURE0.
3.8.1 Texture Image Specification
The command
void TexImage3D(enum target,int level,int internalformat,
sizei width,sizei height,sizei depth,int border,
enum format,enum type,void *data );
OpenGL 3.1 - May 28, 20093.8. TEXTURING 116
is used to specify a three-dimensional texture image. target must be one of
TEXTURE_3D for a three-dimensional texture orTEXTURE_2D_ARRAY for an two-
dimensional array texture. Additionally, target may be eitherPROXY_TEXTURE_-
3D for a three-dimensional proxy texture, or PROXY_TEXTURE_2D_ARRAY for a
two-dimensional proxy array texture, as discussed in section 3.8.12. format, type,
and data specify the format of the image data, the type of those data, and a refer-
ence to the image data in the currently bound pixel unpack buffer or client memory,
as described in section 3.7.2. The formatSTENCIL_INDEX is not allowed.
The groups in memory are treated as being arranged in a sequence of adjacent
rectangles. Each rectangle is a two-dimensional image, whose size and organiza-
tion are speci?ed by the width and height parameters to TexImage3D. The val-
ues of UNPACK_ROW_LENGTH and UNPACK_ALIGNMENT control the row-to-row
spacing in these images as described in section 3.7.2. If the value of the integer
parameter UNPACK_IMAGE_HEIGHT is not positive, then the number of rows in
each two-dimensional image is height; otherwise the number of rows isUNPACK_-
IMAGE_HEIGHT. Each two-dimensional image comprises an integral number of
rows, and is exactly adjacent to its neighbor images.
The mechanism for selecting a sub-volume of a three-dimensional image relies
on the integer parameter UNPACK_SKIP_IMAGES. If UNPACK_SKIP_IMAGES is
positive, the pointer is advanced by UNPACK_SKIP_IMAGES times the number of
elements in one two-dimensional image before obtaining the ?rst group from mem-
ory. Then depth two-dimensional images are processed, each having a subimage
extracted as described in section 3.7.2.
The selected groups are transferred to the GL as described in section 3.7.2
and then clamped to the representable range of the internal format. If the inter-
nalformat of the texture is signed or unsigned integer, components are clamped
n 1 n 1 n
to [ 2 ; 2   1] or [0; 2   1], respectively, where n is the number of bits
per component. For color component groups, if the internalformat of the texture
is signed or unsigned normalized ?xed-point, components are clamped to [ 1; 1]
or [0; 1], respectively. For depth component groups, the depth value is clamped
to [0; 1]. Otherwise, values are not modi?ed. Stencil index values are masked by
n
2   1, wheren is the number of stencil bits in the internal format resolution (see
below). If the base internal format isDEPTH_STENCIL and format is notDEPTH_-
STENCIL, then the values of the stencil index texture components are unde?ned.
Components are then selected from the resulting R, G, B, A, depth, or stencil
values to obtain a texture with the base internal format speci?ed by (or derived
from) internalformat. Table 3.11 summarizes the mapping of R, G, B, A, depth,
or stencil values to texture components, as a function of the base internal format
of the texture image. internalformat may be speci?ed as one of the internal format
symbolic constants listed in table 3.11, as one of the sized internal format symbolic
OpenGL 3.1 - May 28, 20093.8. TEXTURING 117
Base Internal Format RGBA, Depth, and Stencil Values Internal Components
DEPTH_COMPONENT Depth D
DEPTH_STENCIL Depth,Stencil D,S
RED R R
RG R,G R,G
RGB R,G,B R,G,B
RGBA R,G,B,A R,G,B,A
Table 3.11: Conversion from RGBA, depth, and stencil pixel components to inter-
nal texture components. Texture componentsR,G,B, andA are converted back
to RGBA colors during ?ltering as shown in table 3.20.
constants listed in tables 3.12- 3.13, as one of the generic compressed internal
format symbolic constants listed in table 3.14, or as one of the speci?c compressed
internal format symbolic constants (if listed in table 3.14). Specifying a value for
internalformat that is not one of the above values generates the error INVALID_-
VALUE.
Textures with a base internal format of DEPTH_COMPONENT or DEPTH_-
STENCIL are supported by texture image speci?cation commands only if
target is TEXTURE_1D, TEXTURE_2D, TEXTURE_1D_ARRAY, TEXTURE_2D_-
ARRAY, TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP, PROXY_TEXTURE_-
1D, PROXY_TEXTURE_2D, PROXY_TEXTURE_1D_ARRAY, PROXY_TEXTURE_-
2D_ARRAY, PROXY_TEXTURE_RECTANGLE, or PROXY_TEXTURE_CUBE_MAP.
Using these formats in conjunction with any other target will result in an
INVALID_OPERATION error.
Textures with a base internal format of DEPTH_COMPONENT or DEPTH_-
STENCIL require either depth component data or depth/stencil component data.
Textures with other base internal formats require RGBA component data. The error
INVALID_OPERATION is generated if one of the base internal format and format is
DEPTH_COMPONENT orDEPTH_STENCIL, and the other is neither of these values.
Textures with integer internal formats (see table 3.12) require integer data.
The error INVALID_OPERATION is generated if the internal format is integer and
format is not one of the integer formats listed in table 3.3; if the internal format is
not integer and format is an integer format; or if format is an integer format and type
is FLOAT, HALF_FLOAT, UNSIGNED_INT_10F_11F_11F_REV, or UNSIGNED_-
INT_5_9_9_9_REV.
In addition to the speci?c compressed internal formats listed in table 3.14, the
GL provides a mechanism to obtain token values for all such formats provided
OpenGL 3.1 - May 28, 20093.8. TEXTURING 118
by extensions. The number of speci?c compressed internal formats supported
by the renderer can be obtained by querying the value of NUM_COMPRESSED_-
TEXTURE_FORMATS. The set of speci?c compressed internal formats supported by
the renderer can be obtained by querying the value of COMPRESSED_TEXTURE_-
FORMATS. The only values returned by this query are those corresponding to for-
mats suitable for general-purpose usage. The renderer will not enumerate formats
with restrictions that need to be speci?cally understood prior to use.
Generic compressed internal formats are never used directly as the internal for-
mats of texture images. If internalformat is one of the six generic compressed
internal formats, its value is replaced by the symbolic constant for a speci?c com-
pressed internal format of the GL’s choosing with the same base internal format.
If no speci?c compressed format is available, internalformat is instead replaced by
the corresponding base internal format. If internalformat is given as or mapped
to a speci?c compressed internal format, but the GL can not support images com-
pressed in the chosen internal format for any reason (e.g., the compression format
might not support 3D textures), internalformat is replaced by the corresponding
base internal format and the texture image will not be compressed by the GL.
The internal component resolution is the number of bits allocated to each value
in a texture image. If internalformat is speci?ed as a base internal format, the GL
stores the resulting texture with internal component resolutions of its own choos-
ing. If a sized internal format is speci?ed, the mapping of the R, G, B, A, depth,
and stencil values to texture components is equivalent to the mapping of the cor-
responding base internal format’s components, as speci?ed in table 3.11; the type
(unsigned int, ?oat, etc.) is assigned the same type speci?ed by internalformat;
and the memory allocation per texture component is assigned by the GL to match
the allocations listed in tables 3.12- 3.13 as closely as possible. (The de?nition of
closely is left up to the implementation. However, a non-zero number of bits must
be allocated for each component whose desired allocation in tables 3.12- 3.13 is
non-zero, and zero bits must be allocated for all other components).
Required Texture Formats
Implementations are required to support at least one allocation of internal com-
ponent resolution for each type (unsigned int, ?oat, etc.) for each base internal
format.
In addition, implementations are required to support the following sized and
compressed internal formats. Requesting one of these sized internal formats for
any texture type will allocate at least the internal component sizes, and exactly the
component types shown for that format in tables 3.12- 3.13:
OpenGL 3.1 - May 28, 20093.8. TEXTURING 119
 Texture and renderbuffer color formats (see section 4.4.2)).
– RGBA32F, RGBA32I, RGBA32UI, RGBA16, RGBA16F, RGBA16I,
RGBA16UI, RGBA8, RGBA8I, RGBA8UI, SRGB8_ALPHA8, and
RGB10_A2.
– R11F_G11F_B10F.
– RG32F, RG32I, RG32UI, RG16, RG16F, RG16I, RG16UI, RG8, RG8I,
andRG8UI.
– R32F,R32I,R32UI,R16F,R16I,R16UI,R16,R8,R8I, andR8UI.
 Texture-only color formats:
– RGBA16_SNORM andRGBA8_SNORM.
– RGB32F,RGB32I, andRGB32UI.
– RGB16_SNORM,RGB16F,RGB16I,RGB16UI, andRGB16.
– RGB8_SNORM,RGB8,RGB8I,RGB8UI, andSRGB8.
– RGB9_E5.
– RG16_SNORM, RG8_SNORM, COMPRESSED_RG_RGTC2 and
COMPRESSED_SIGNED_RG_RGTC2.
– R16_SNORM, R8_SNORM, COMPRESSED_RED_RGTC1 and
COMPRESSED_SIGNED_RED_RGTC1.
 Depth formats: DEPTH_COMPONENT32F, DEPTH_COMPONENT24, and
DEPTH_COMPONENT16.
 Combined depth+stencil formats: DEPTH32F_STENCIL8 and DEPTH24_-
STENCIL8.
Encoding of Special Internal Formats
If internalformat isR11F_G11F_B10F, the red, green, and blue bits are converted
to unsigned 11-bit, unsigned 11-bit, and unsigned 10-bit ?oating-point values as
described in sections 2.1.3 and 2.1.4.
If internalformat is RGB9_E5, the red, green, and blue bits are converted to a
shared exponent format according to the following procedure:
Componentsred,green, andblue are ?rst clamped (in the process, mapping
NaN to zero) as follows:
OpenGL 3.1 - May 28, 20093.8. TEXTURING 120
red =max(0;min(sharedexp ;red))
c max
green =max(0;min(sharedexp ;green))
c max
blue =max(0;min(sharedexp ;blue))
c max
where
N
(2   1)
E  B
max
sharedexp = 2 :
max
N
2
N is the number of mantissa bits per component (9),B is the exponent bias (15),
andE is the maximum allowed biased exponent value (31).
max
The largest clamped component,max , is determined:
c
max =max(red ;green ;blue )
c c c c
A preliminary shared exponentexp is computed:
p
exp =max( B  1;blog (max )c) + 1 +B
p 2 c
A re?ned shared exponentexp is computed:
s
j k
max
c
max = + 0:5
s
exp  B N
p
2
(
N
exp ; 0max < 2
p s
exp =
s
N
exp + 1; max = 2
p s
N
Finally, three integer values in the range 0 to 2   1 are computed:
 
red
c
red = + 0:5
s
exp B N
s
2
j k
green
c
green = + 0:5
s
exp B N
s
2
 
blue
c
blue = + 0:5
s
exp B N
s
2
The resultingred ,green ,blue , andexp are stored in the red, green, blue,
s s s s
and shared bits respectively of the texture image.
An implementation accepting pixel data of typeUNSIGNED_INT_5_9_9_9_-
REV with formatRGB is allowed to store the components “as is”.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 121
Sized Base R G B A Shared
Internal Format Internal Format bits bits bits bits bits
R8 RED 8
R8_SNORM RED s8
R16 RED 16
R16_SNORM RED s16
RG8 RG 8 8
RG8_SNORM RG s8 s8
RG16 RG 16 16
RG16_SNORM RG s16 s16
R3_G3_B2 RGB 3 3 2
RGB4 RGB 4 4 4
RGB5 RGB 5 5 5
RGB8 RGB 8 8 8
RGB8_SNORM RGB s8 s8 s8
RGB10 RGB 10 10 10
RGB12 RGB 12 12 12
RGB16 RGB 16 16 16
RGB16_SNORM RGB s16 s16 s16
RGBA2 RGBA 2 2 2 2
RGBA4 RGBA 4 4 4 4
RGB5_A1 RGBA 5 5 5 1
RGBA8 RGBA 8 8 8 8
RGBA8_SNORM RGBA s8 s8 s8 s8
RGB10_A2 RGBA 10 10 10 2
RGBA12 RGBA 12 12 12 12
RGBA16 RGBA 16 16 16 16
RGBA16_SNORM RGBA s16 s16 s16 s16
SRGB8 RGB 8 8 8
SRGB8_ALPHA8 RGBA 8 8 8 8
R16F RED f16
RG16F RG f16 f16
RGB16F RGB f16 f16 f16
RGBA16F RGBA f16 f16 f16 f16
R32F RED f32
RG32F RG f32 f32
RGB32F RGB f32 f32 f32
Sized internal color formats continued on next page
OpenGL 3.1 - May 28, 20093.8. TEXTURING 122
Sized internal color formats continued from previous page
Sized Base R G B A Shared
Internal Format Internal Format bits bits bits bits bits
RGBA32F RGBA f32 f32 f32 f32
R11F_G11F_B10F RGB f11 f11 f10
RGB9_E5 RGB 9 9 9 5
R8I RED i8
R8UI RED ui8
R16I RED i16
R16UI RED ui16
R32I RED i32
R32UI RED ui32
RG8I RG i8 i8
RG8UI RG ui8 ui8
RG16I RG i16 i16
RG16UI RG ui16 ui16
RG32I RG i32 i32
RG32UI RG ui32 ui32
RGB8I RGB i8 i8 i8
RGB8UI RGB ui8 ui8 ui8
RGB16I RGB i16 i16 i16
RGB16UI RGB ui16 ui16 ui16
RGB32I RGB i32 i32 i32
RGB32UI RGB ui32 ui32 ui32
RGBA8I RGBA i8 i8 i8 i8
RGBA8UI RGBA ui8 ui8 ui8 ui8
RGBA16I RGBA i16 i16 i16 i16
RGBA16UI RGBA ui16 ui16 ui16 ui16
RGBA32I RGBA i32 i32 i32 i32
RGBA32UI RGBA ui32 ui32 ui32 ui32
Table 3.12: Correspondence of sized internal color formats to base
internal formats, internal data type, and desired component reso-
lutions for each sized internal format. The component resolution
pre?x indicates the internal data type: f is ?oating point, i is signed
integer, ui is unsigned integer, s is signed normalized ?xed-point,
and no pre?x is unsigned normalized ?xed-point.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 123
Sized Base D S
Internal Format Internal Format bits bits
DEPTH_COMPONENT16 DEPTH_COMPONENT 16
DEPTH_COMPONENT24 DEPTH_COMPONENT 24
DEPTH_COMPONENT32 DEPTH_COMPONENT 32
DEPTH_COMPONENT32F DEPTH_COMPONENT f32
DEPTH24_STENCIL8 DEPTH_STENCIL 24 8
DEPTH32F_STENCIL8 DEPTH_STENCIL f32 8
Table 3.13: Correspondence of sized internal depth and stencil formats to base
internal formats, internal data type, and desired component resolutions for each
sized internal format. The component resolution pre?x indicates the internal data
type: f is ?oating point, i is signed integer, ui is unsigned integer, and no pre?x is
?xed-point.
If a compressed internal format is speci?ed, the mapping of the R, G, B, and
A values to texture components is equivalent to the mapping of the corresponding
base internal format’s components, as speci?ed in table 3.11. The speci?ed image
is compressed using a (possibly lossy) compression algorithm chosen by the GL.
A GL implementation may vary its allocation of internal component resolution
or compressed internal format based on any TexImage3D, TexImage2D (see be-
low), or TexImage1D (see below) parameter (except target), but the allocation and
chosen compressed image format must not be a function of any other state and can-
not be changed once they are established. In addition, the choice of a compressed
image format may not be affected by the data parameter. Allocations must be in-
variant; the same allocation and compressed image format must be chosen each
time a texture image is speci?ed with the same parameter values. These allocation
rules also apply to proxy textures, which are described in section 3.8.12.
The image itself (referred to by data) is a sequence of groups of values. The
?rst group is the lower left back corner of the texture image. Subsequent groups
?ll out rows of width width from left to right; height rows are stacked from bottom
to top forming a single two-dimensional image slice; and depth slices are stacked
from back to front. When the ?nal R, G, B, and A components have been computed
for a group, they are assigned to components of a texel as described by table 3.11.
Counting from zero, each resultingNth texel is assigned internal integer coordi-
nates (i;j;k), where
i = (N modwidth) w
b
OpenGL 3.1 - May 28, 20093.8. TEXTURING 124
Compressed Internal Format Base Internal Format Type
COMPRESSED_RED RED Generic
COMPRESSED_RG RG Generic
COMPRESSED_RGB RGB Generic
COMPRESSED_RGBA RGBA Generic
COMPRESSED_SRGB RGB Generic
COMPRESSED_SRGB_ALPHA RGBA Generic
COMPRESSED_RED_RGTC1 RED Speci?c
COMPRESSED_SIGNED_RED_RGTC1 RED Speci?c
COMPRESSED_RG_RGTC2 RG Speci?c
COMPRESSED_SIGNED_RG_RGTC2 RG Speci?c
Table 3.14: Generic and speci?c compressed internal formats. The speci?c
RGTC formats are described in appendix C.1.
* *
N
j = (b c modheight) h
b
width
N
k = (b c moddepth) d
b
widthheight
andw ,h , andd are the speci?ed border width, height, and depth.w andh are
b b b b b
the speci?ed border value;d is the speci?ed border value if target isTEXTURE_-
b
3D, or zero if target isTEXTURE_2D_ARRAY. Thus the last two-dimensional image
slice of the three-dimensional image is indexed with the highest value ofk.
If the internal data type of the image array is signed or unsigned normalized
?xed-point, each color component is converted using equation 2.6 or 2.4, respec-
tively. If the internal type is ?oating-point or integer, components are clamped
to the representable range of the corresponding internal component, but are not
converted.
The level argument to TexImage3D is an integer level-of-detail number. Levels
of detail are discussed below, under Mipmapping. The main texture image has a
level of detail number of 0. If a level-of-detail less than zero is speci?ed, the error
INVALID_VALUE is generated.
The border argument to TexImage3D is a border width. The signi?cance of
borders is described below. The border width affects the dimensions of the texture
OpenGL 3.1 - May 28, 20093.8. TEXTURING 125
image: let
w =w + 2w
s t b
h =h + 2h (3.16)
s t
b
d =d + 2d
s t b
wherew ,h , andd are the speci?ed image width, height, and depth, andw ,
s s s t
h , andd are the dimensions of the texture image internal to the border. Ifw ,h ,
t t t t
ord are less than zero, then the errorINVALID_VALUE is generated.
t
The maximum border widthb is 0. If border is less than zero, or greater than
t
b , then the errorINVALID_VALUE is generated.
t
The maximum allowable width, height, or depth of a texel array for a three-
dimensional texture is an implementation-dependent function of the level-of-detail
k lod
and internal format of the resulting image array. It must be at least 2 + 2b
t
for image arrays of level-of-detail 0 throughk, wherek is the log base 2 ofMAX_-
3D_TEXTURE_SIZE, lod is the level-of-detail of the image array, and b is the
t
maximum border width. It may be zero for image arrays of any level-of-detail
greater thank. The error INVALID_VALUE is generated if the speci?ed image is
too large to be stored under any conditions.
If a pixel unpack buffer object is bound and storing texture data would access
memory beyond the end of the pixel unpack buffer, anINVALID_OPERATION error
results.
In a similar fashion, the maximum allowable width of a texel array for a one-
or two-dimensional, or one- or two-dimensional array texture, and the maximum
allowable height of a two-dimensional or two-dimensional array texture, must be
k lod
at least 2 +2b for image arrays of level 0 throughk, wherek is the log base 2
t
ofMAX_TEXTURE_SIZE. The maximum allowable width and height of a cube map
k lod
texture must be the same, and must be at least 2 + 2b for image arrays level
t
0 throughk, wherek is the log base 2 of MAX_CUBE_MAP_TEXTURE_SIZE. The
maximum number of layers for one- and two-dimensional array textures (height or
depth, respectively) must be at leastMAX_ARRAY_TEXTURE_LAYERS for all levels.
The maximum allowable width and height of a rectangular texture image
must each be at least the value of the implementation-dependent constant MAX_-
RECTANGLE_TEXTURE_SIZE.
An implementation may allow an image array of level 0 to be created only if
that single image array can be supported. Additional constraints on the creation of
image arrays of level 1 or greater are described in more detail in section 3.8.11.
The command
OpenGL 3.1 - May 28, 20093.8. TEXTURING 126
void TexImage2D(enum target,int level,
int internalformat,sizei width,sizei height,
int border,enum format,enum type,void *data );
is used to specify a two-dimensional texture image. target must be one of
TEXTURE_2D for a two-dimensional texture, TEXTURE_1D_ARRAY for a one-
dimensional array texture, TEXTURE_RECTANGLE for a rectangle texture, or
one ofTEXTURE_CUBE_MAP_POSITIVE_X,TEXTURE_CUBE_MAP_NEGATIVE_-
X, TEXTURE_CUBE_MAP_POSITIVE_Y, TEXTURE_CUBE_MAP_NEGATIVE_Y,
TEXTURE_CUBE_MAP_POSITIVE_Z, or TEXTURE_CUBE_MAP_NEGATIVE_Z for
a cube map texture. Additionally, target may be either PROXY_TEXTURE_2D
for a two-dimensional proxy texture, PROXY_TEXTURE_1D_ARRAY for a one-
dimensional proxy array texture, PROXY_TEXTURE_RECTANGLE for a rectangle
proxy texture, or PROXY_TEXTURE_CUBE_MAP for a cube map proxy texture
in the special case discussed in section 3.8.12. The other parameters match the
corresponding parameters of TexImage3D.
For the purposes of decoding the texture image, TexImage2D is equivalent to
calling TexImage3D with corresponding arguments and depth of 1, except that
UNPACK_SKIP_IMAGES is ignored.
A two-dimensional or rectangle texture consists of a single two-dimensional
texture image. A cube map texture is a set of six two-dimensional texture im-
ages. The six cube map texture targets form a single cube map texture though
each target names a distinct face of the cube map. The TEXTURE_CUBE_MAP_
*
targets listed above update their appropriate cube map face 2D texture image. Note
that the six cube map two-dimensional image tokens such as TEXTURE_CUBE_-
MAP_POSITIVE_X are used when specifying, updating, or querying one of a cube
map’s six two-dimensional images, but when binding to a cube map texture ob-
ject (that is when the cube map is accessed as a whole as opposed to a particular
two-dimensional image), theTEXTURE_CUBE_MAP target is speci?ed.
When the target parameter to TexImage2D is one of the six cube map two-
dimensional image targets, the error INVALID_VALUE is generated if the width
and height parameters are not equal.
When target isTEXTURE_RECTANGLE, anINVALID_VALUE error is generated
if level is non-zero.
AnINVALID_VALUE error is generated if border is non-zero.
Finally, the command
void TexImage1D(enum target,int level,
int internalformat,sizei width,int border,
enum format,enum type,void *data );
OpenGL 3.1 - May 28, 20093.8. TEXTURING 127
is used to specify a one-dimensional texture image. target must be either
TEXTURE_1D, or PROXY_TEXTURE_1D in the special case discussed in sec-
tion 3.8.12.
For the purposes of decoding the texture image, TexImage1D is equivalent to
calling TexImage2D with corresponding arguments and height of 1.
The image indicated to the GL by the image pointer is decoded and copied into
the GL’s internal memory.
We shall refer to the decoded image as the texel array. A three-dimensional
texel array has width, height, and depthw ,h , andd as de?ned in equation 3.16.
s s s
A two-dimensional or rectangular texel array has depth d = 1, with height h
s s
and widthw as above. A one-dimensional texel array has depthd = 1, height
s s
h = 1, and widthw as above.
s s
An element (i;j;k) of the texel array is called a texel (for a two-dimensional
texture or one-dimensional array texture, k is irrelevant; for a one-dimensional
texture,j andk are both irrelevant). The texture value used in texturing a fragment
is determined by sampling the texture in a shader, but may not correspond to any
actual texel. See ?gure 3.6.
If the data argument of TexImage1D, TexImage2D, or TexImage3D is a null
pointer (a zero-valued pointer in the C implementation), and the pixel unpack
buffer object is zero, a one-, two-, or three-dimensional texel array is created with
the speci?ed target, level, internalformat, border, width, height, and depth, but
with unspeci?ed image contents. In this case no pixel values are accessed in client
memory, and no pixel processing is performed. Errors are generated, however, ex-
actly as though the data pointer were valid. Otherwise if the pixel unpack buffer
object is non-zero, the data argument is treatedly normally to refer to the beginning
of the pixel unpack buffer object’s data.
3.8.2 Alternate Texture Image Specification Commands
Two-dimensional and one-dimensional texture images may also be speci?ed us-
ing image data taken directly from the framebuffer, and rectangular subregions of
existing texture images may be respeci?ed.
The command
void CopyTexImage2D(enum target,int level,
enum internalformat,int x,int y,sizei width,
sizei height,int border );
de?nes a two-dimensional texel array in exactly the manner of TexImage2D, ex-
cept that the image data are taken from the framebuffer rather than from client
OpenGL 3.1 - May 28, 20093.8. TEXTURING 128
5.0
4
1.0
3
?
2
t v j
?
1
0
0.0
?1
?1.0
?1 0 1 2 3 4 5 6 7 8
i
?1.0 u 9.0
0.0 s 1.0
Figure 3.6. A texture image and the coordinates used to access it. This is a two-
dimensional texture with n = 3 and m = 2. A one-dimensional texture would
consist of a single horizontal strip. and, values used in blending adjacent texels
to obtain a texture value, are also shown.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 129
memory. Currently, target must be one of TEXTURE_2D, TEXTURE_1D_ARRAY,
TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP_POSITIVE_X, TEXTURE_CUBE_-
MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_POSITIVE_-
Y, TEXTURE_CUBE_MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z, or
TEXTURE_CUBE_MAP_NEGATIVE_Z. x, y, width, and height correspond precisely
to the corresponding arguments to ReadPixels (refer to section 4.3.1); they specify
the image’s width and height, and the lower left (x;y) coordinates of the frame-
buffer region to be copied. The image is taken from the framebuffer exactly as
if these arguments were passed to ReadPixels with argument type set to COLOR,
DEPTH, or DEPTH_STENCIL, depending on internalformat, stopping after con-
version of depth values. RGBA data is taken from the current color buffer,
while depth component and stencil index data are taken from the depth and sten-
cil buffers, respectively. The error INVALID_OPERATION is generated if depth
component data is required and no depth buffer is present; if stencil index data is
required and no stencil buffer is present; if integer RGBA data is required and the
format of the current color buffer is not integer; or if ?oating- or ?xed-point RGBA
data is required and the format of the current color buffer is integer.
Subsequent processing is identical to that described for TexImage2D, begin-
ning with clamping of the R, G, B, A, or depth values, and masking of the stencil
index values from the resulting pixel groups. Parameters level, internalformat, and
border are speci?ed using the same values, with the same meanings, as the equiv-
alent arguments of TexImage2D. An invalid value speci?ed for internalformat
generates the error INVALID_ENUM. The constraints on width, height, and border
are exactly those for the equivalent arguments of TexImage2D.
When the target parameter to CopyTexImage2D is one of the six cube map
two-dimensional image targets, the errorINVALID_VALUE is generated if the width
and height parameters are not equal.
An INVALID_FRAMEBUFFER_OPERATION error will be generated if the ob-
ject bound toREAD_FRAMEBUFFER_BINDING (see section 4.4) is not framebuffer
complete (as de?ned in section 4.4.4). An INVALID_OPERATION error will be
generated if the object bound to READ_FRAMEBUFFER_BINDING is framebuffer
complete and the value ofSAMPLE_BUFFERS is greater than zero.
The command
void CopyTexImage1D(enum target,int level,
enum internalformat,int x,int y,sizei width,
int border );
de?nes a one-dimensional texel array in exactly the manner of TexImage1D, ex-
cept that the image data are taken from the framebuffer, rather than from client
OpenGL 3.1 - May 28, 20093.8. TEXTURING 130
memory. Currently, target must be TEXTURE_1D. For the purposes of decoding
the texture image, CopyTexImage1D is equivalent to calling CopyTexImage2D
with corresponding arguments and height of 1, except that the height of the image
is always 1, regardless of the value of border. level, internalformat, and border are
speci?ed using the same values, with the same meanings, as the equivalent argu-
ments of TexImage1D. The constraints on width and border are exactly those of
the equivalent arguments of TexImage1D.
Six additional commands,
void TexSubImage3D(enum target,int level,int xoffset,
int yoffset,int zoffset,sizei width,sizei height,
sizei depth,enum format,enum type,void *data );
void TexSubImage2D(enum target,int level,int xoffset,
int yoffset,sizei width,sizei height,enum format,
enum type,void *data );
void TexSubImage1D(enum target,int level,int xoffset,
sizei width,enum format,enum type,void *data );
void CopyTexSubImage3D(enum target,int level,
int xoffset,int yoffset,int zoffset,int x,int y,
sizei width,sizei height );
void CopyTexSubImage2D(enum target,int level,
int xoffset,int yoffset,int x,int y,sizei width,
sizei height );
void CopyTexSubImage1D(enum target,int level,
int xoffset,int x,int y,sizei width );
respecify only a rectangular subregion of an existing texel array. No change is
made to the internalformat, width, height, depth, or border parameters of the
speci?ed texel array, nor is any change made to texel values outside the speci-
?ed subregion. Currently the target arguments of TexSubImage1D and CopyTex-
SubImage1D must be TEXTURE_1D, the target arguments of TexSubImage2D
and CopyTexSubImage2D must be one of TEXTURE_2D, TEXTURE_1D_ARRAY,
TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP_POSITIVE_X, TEXTURE_CUBE_-
MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_POSITIVE_Y, TEXTURE_CUBE_-
MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z, or TEXTURE_CUBE_-
MAP_NEGATIVE_Z, and the target arguments of TexSubImage3D and CopyTex-
SubImage3D must beTEXTURE_3D orTEXTURE_2D_ARRAY. The level parameter
of each command speci?es the level of the texel array that is modi?ed. If level is
less than zero or greater than the base 2 logarithm of the maximum texture width,
height, or depth, the errorINVALID_VALUE is generated. If target isTEXTURE_-
OpenGL 3.1 - May 28, 20093.8. TEXTURING 131
RECTANGLE and level is not zero, the error INVALID_VALUE is generated. Tex-
SubImage3D arguments width, height, depth, format, type, and data match the
corresponding arguments to TexImage3D, meaning that they are speci?ed using
the same values, and have the same meanings. Likewise, TexSubImage2D argu-
ments width, height, format, type, and data match the corresponding arguments
to TexImage2D, and TexSubImage1D arguments width, format, type, and data
match the corresponding arguments to TexImage1D.
CopyTexSubImage3D and CopyTexSubImage2D arguments x, y, width,
1
and height match the corresponding arguments to CopyTexImage2D . CopyTex-
SubImage1D arguments x, y, and width match the corresponding arguments to
CopyTexImage1D. Each of the TexSubImage commands interprets and processes
pixel groups in exactly the manner of its TexImage counterpart, except that the as-
signment of R, G, B, A, depth, and stencil index pixel group values to the texture
components is controlled by the internalformat of the texel array, not by an argu-
ment to the command. The same constraints and errors apply to the TexSubImage
commands’ argument format and the internalformat of the texel array being re-
speci?ed as apply to the format and internalformat arguments of its TexImage
counterparts.
Arguments xoffset, yoffset, and zoffset of TexSubImage3D and CopyTex-
SubImage3D specify the lower left texel coordinates of a width-wide by height-
high by depth-deep rectangular subregion of the texel array. The depth argument
associated with CopyTexSubImage3D is always 1, because framebuffer memory
is two-dimensional - only a portion of a single s;t slice of a three-dimensional
texture is replaced by CopyTexSubImage3D.
Negative values of xoffset, yoffset, and zoffset correspond to the coordinates
of border texels, addressed as in ?gure 3.6. Takingw , h , d , w , h , andd to
s s s b b b
be the speci?ed width, height, depth, and border width, border height, and border
depth of the texel array, and takingx, y, z, w, h, andd to be the xoffset, yoffset,
zoffset, width, height, and depth argument values, any of the following relationships
generates the errorINVALID_VALUE:
x< w
b
x +w>w  w
s
b
y< h
b
y +h>h  h
s b
z< d
b
1
Because the framebuffer is inherently two-dimensional, there is no CopyTexImage3D com-
mand.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 132
z +d>d  d
s b
Counting from zero, thenth pixel group is assigned to the texel with internal integer
coordinates [i;j;k], where
i =x + (n modw)
n
j =y + (b c modh)
w
n
k =z + (b c modd
widthheight
Arguments xoffset and yoffset of TexSubImage2D and CopyTexSubImage2D
specify the lower left texel coordinates of a width-wide by height-high rectangular
subregion of the texel array. Negative values of xoffset and yoffset correspond to
the coordinates of border texels, addressed as in ?gure 3.6. Takingw ,h , andb
s s s
to be the speci?ed width, height, and border width of the texel array, and takingx,
y,w, andh to be the xoffset, yoffset, width, and height argument values, any of the
following relationships generates the errorINVALID_VALUE:
x< b
s
x +w>w  b
s s
y< b
s
y +h>h  b
s s
Counting from zero, thenth pixel group is assigned to the texel with internal integer
coordinates [i;j], where
i =x + (n modw)
n
j =y + (b c modh)
w
The xoffset argument of TexSubImage1D and CopyTexSubImage1D speci-
?es the left texel coordinate of a width-wide subregion of the texel array. Negative
values of xoffset correspond to the coordinates of border texels. Takingw andb
s s
to be the speci?ed width and border width of the texel array, andx andw to be the
xoffset and width argument values, either of the following relationships generates
the errorINVALID_VALUE:
x< b
s
x +w>w  b
s s
OpenGL 3.1 - May 28, 20093.8. TEXTURING 133
Counting from zero, thenth pixel group is assigned to the texel with internal integer
coordinates [i], where
i =x + (n modw)
Texture images with compressed internal formats may be stored in such a way
that it is not possible to modify an image with subimage commands without having
to decompress and recompress the texture image. Even if the image were modi-
?ed in this manner, it may not be possible to preserve the contents of some of
the texels outside the region being modi?ed. To avoid these complications, the
GL does not support arbitrary modi?cations to texture images with compressed
internal formats. Calling TexSubImage3D, CopyTexSubImage3D, TexSubIm-
age2D, CopyTexSubImage2D, TexSubImage1D, or CopyTexSubImage1D will
result in anINVALID_OPERATION error if xoffset, yoffset, or zoffset is not equal to
 b (border width). In addition, the contents of any texel outside the region mod-
s
i?ed by such a call are unde?ned. These restrictions may be relaxed for speci?c
compressed internal formats whose images are easily modi?ed.
If the internal format of the texture image being modi?ed is one of the spe-
ci?c RGTC formats described in table 3.14, the texture is stored using one of the
RGTC texture image encodings (see appendix C.1). Since RGTC images are easily
edited along 4 4 texel boundaries, the limitations on subimage location and size
are relaxed for TexSubImage2D, TexSubImage3D, CopyTexSubImage2D, and
CopyTexSubImage3D. These commands will generate anINVALID_OPERATION
error if one of the following conditions occurs:
 width is not a multiple of four, width + xoset is not equal to the value of
TEXTURE_WIDTH, and either xoffset or yoffset is non-zero.
 height is not a multiple of four, height + yoset is not equal to the value of
TEXTURE_HEIGHT, and either xoffset or yoffset is non-zero.
 xoffset or yoffset is not a multiple of four.
The contents of any 4 4 block of texels of an RGTC compressed texture
image that does not intersect the area being modi?ed are preserved during valid
TexSubImage* and CopyTexSubImage* calls.
Calling CopyTexSubImage3D, CopyTexImage2D, CopyTexSubImage2D,
CopyTexImage1D, or CopyTexSubImage1D will result in an INVALID_-
FRAMEBUFFER_OPERATION error if the object bound to READ_FRAMEBUFFER_-
BINDING is not framebuffer complete (see section 4.4.4).
OpenGL 3.1 - May 28, 20093.8. TEXTURING 134
Texture Copying Feedback Loops
Calling CopyTexSubImage3D, CopyTexImage2D, CopyTexSubImage2D,
CopyTexImage1D, or CopyTexSubImage1D will result in unde?ned behavior if
the destination texture image level is also bound to to the selected read buffer (see
section 4.3.1) of the read framebuffer. This situation is discussed in more detail in
the description of feedback loops in section 4.4.2.
3.8.3 Compressed Texture Images
Texture images may also be speci?ed or modi?ed using image data already stored
in a known compressed image format, such as the RGTC formats de?ned in ap-
pendix C, or additional formats de?ned by GL extensions.
The commands
void CompressedTexImage1D(enum target,int level,
enum internalformat,sizei width,int border,
sizei imageSize,void *data );
void CompressedTexImage2D(enum target,int level,
enum internalformat,sizei width,sizei height,
int border,sizei imageSize,void *data );
void CompressedTexImage3D(enum target,int level,
enum internalformat,sizei width,sizei height,
sizei depth,int border,sizei imageSize,void *data );
de?ne one-, two-, and three-dimensional texture images, respectively, with incom-
ing data stored in a speci?c compressed image format. The target, level, inter-
nalformat, width, height, depth, and border parameters have the same meaning as
in TexImage1D, TexImage2D, and TexImage3D, except that compressed rect-
angular texture formats are not supported. data refers to compressed image data
stored in the speci?c compressed image format corresponding to internalformat.
If a pixel unpack buffer is bound (as indicated by a non-zero value of PIXEL_-
UNPACK_BUFFER_BINDING), data is an offset into the pixel unpack buffer and the
compressed data is read from the buffer relative to this offset; otherwise, data is
a pointer to client memory and the compressed data is read from client memory
relative to the pointer.
If the target parameter to any of the CompressedTexImagenD commands is
TEXTURE_RECTANGLE or PROXY_TEXTURE_RECTANGLE, the error INVALID_-
ENUM is generated.
internalformat must be a supported speci?c compressed internal format. An
INVALID_ENUM error will be generated if any other values, including any of the
OpenGL 3.1 - May 28, 20093.8. TEXTURING 135
generic compressed internal formats, is speci?ed.
For all other compressed internal formats, the compressed image will be de-
coded according to the speci?cation de?ning the internalformat token. Com-
pressed texture images are treated as an array of imageSize ubytes relative to
data. If a pixel unpack buffer object is bound anddata +imageSize is greater
than the size of the pixel buffer, an INVALID_OPERATION error results. All pixel
storage modes are ignored when decoding a compressed texture image. If the im-
ageSize parameter is not consistent with the format, dimensions, and contents of
the compressed image, anINVALID_VALUE error results. If the compressed image
is not encoded according to the de?ned image format, the results of the call are
unde?ned.
Speci?c compressed internal formats may impose format-speci?c restrictions
on the use of the compressed image speci?cation calls or parameters. For example,
the compressed image format might be supported only for 2D textures, or might
not allow non-zero border values. Any such restrictions will be documented in the
extension speci?cation de?ning the compressed internal format; violating these
restrictions will result in anINVALID_OPERATION error.
Any restrictions imposed by speci?c compressed internal formats will be in-
variant, meaning that if the GL accepts and stores a texture image in compressed
form, providing the same image to CompressedTexImage1D, Compressed-
TexImage2D, or CompressedTexImage3D will not result in an INVALID_-
OPERATION error if the following restrictions are satis?ed:
 data points to a compressed texture image returned by GetCompressedTex-
Image (section 6.1.4).
 target, level, and internalformat match the target, level and format parame-
ters provided to the GetCompressedTexImage call returning data.
 width, height, depth, border, internalformat, and imageSize match the values
of TEXTURE_WIDTH, TEXTURE_HEIGHT, TEXTURE_DEPTH, TEXTURE_-
BORDER, TEXTURE_INTERNAL_FORMAT, and TEXTURE_COMPRESSED_-
IMAGE_SIZE for image level level in effect at the time of the GetCom-
pressedTexImage call returning data.
This guarantee applies not just to images returned by GetCompressedTexImage,
but also to any other properly encoded compressed texture image of the same size
and format.
If internalformat is one of the speci?c RGTC formats described in table 3.14,
the compressed image data is stored using one of the RGTC compressed texture
image encodings (see appendix C.1) The RGTC texture compression algorithm
OpenGL 3.1 - May 28, 20093.8. TEXTURING 136
supports only two-dimensional images without borders. If internalformat is an
RGTC format, CompressedTexImage1D will generate an INVALID_ENUM error;
CompressedTexImage2D will generate an INVALID_OPERATION error if bor-
der is non-zero or target isTEXTURE_RECTANGLE; and CompressedTexImage3D
will generate anINVALID_OPERATION error if border is non-zero or target is not
TEXTURE_2D_ARRAY.
If the data argument of CompressedTexImage1D, CompressedTexImage2D,
or CompressedTexImage3D is a null pointer (a zero-valued pointer in the C imple-
mentation), and the pixel unpack buffer object is zero, a texel array with unspeci-
?ed image contents is created, just as when a null pointer is passed to TexImage1D,
TexImage2D, or TexImage3D.
The commands
void CompressedTexSubImage1D(enum target,int level,
int xoffset,sizei width,enum format,sizei imageSize,
void *data );
void CompressedTexSubImage2D(enum target,int level,
int xoffset,int yoffset,sizei width,sizei height,
enum format,sizei imageSize,void *data );
void CompressedTexSubImage3D(enum target,int level,
int xoffset,int yoffset,int zoffset,sizei width,
sizei height,sizei depth,enum format,
sizei imageSize,void *data );
respecify only a rectangular region of an existing texel array, with incoming data
stored in a known compressed image format. The target, level, xoffset, yoffset, zoff-
set, width, height, and depth parameters have the same meaning as in TexSubIm-
age1D, TexSubImage2D, and TexSubImage3D. data points to compressed image
data stored in the compressed image format corresponding to format. Using any of
the generic compressed internal formats as format will result in anINVALID_ENUM
error.
If the target parameter to any of the CompressedTexSubImagenD com-
mands is TEXTURE_RECTANGLE or PROXY_TEXTURE_RECTANGLE, the error
INVALID_ENUM is generated.
The image pointed to by data and the imageSize parameter are interpreted
as though they were provided to CompressedTexImage1D, CompressedTexIm-
age2D, and CompressedTexImage3D. These commands do not provide for im-
age format conversion, so an INVALID_OPERATION error results if format does
not match the internal format of the texture image being modi?ed. If the image-
Size parameter is not consistent with the format, dimensions, and contents of the
compressed image (too little or too much data), anINVALID_VALUE error results.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 137
As with CompressedTexImage calls, compressed internal formats may have
additional restrictions on the use of the compressed image speci?cation calls or
parameters. Any such restrictions will be documented in the speci?cation de?n-
ing the compressed internal format; violating these restrictions will result in an
INVALID_OPERATION error.
Any restrictions imposed by speci?c compressed internal formats will be in-
variant, meaning that if the GL accepts and stores a texture image in compressed
form, providing the same image to CompressedTexSubImage1D, Compressed-
TexSubImage2D, CompressedTexSubImage3D will not result in anINVALID_-
OPERATION error if the following restrictions are satis?ed:
 data points to a compressed texture image returned by GetCompressedTex-
Image (section 6.1.4).
 target, level, and format match the target, level and format parameters pro-
vided to the GetCompressedTexImage call returning data.
 width, height, depth, format, and imageSize match the values ofTEXTURE_-
WIDTH, TEXTURE_HEIGHT, TEXTURE_DEPTH, TEXTURE_INTERNAL_-
FORMAT, and TEXTURE_COMPRESSED_IMAGE_SIZE for image level level
in effect at the time of the GetCompressedTexImage call returning data.
 width, height, depth, format match the values of TEXTURE_WIDTH,
TEXTURE_HEIGHT, TEXTURE_DEPTH, and TEXTURE_INTERNAL_FORMAT
currently in effect for image level level.
 xoffset, yoffset, and zoffset are all b, where b is the value of TEXTURE_-
BORDER currently in effect for image level level.
This guarantee applies not just to images returned by GetCompressedTexIm-
age, but also to any other properly encoded compressed texture image of the same
size.
Calling CompressedTexSubImage3D, CompressedTexSubImage2D, or
CompressedTexSubImage1D will result in an INVALID_OPERATION error if
xoffset, yoffset, or zoffset is not equal to b (border width), or if width, height,
s
and depth do not match the values of TEXTURE_WIDTH, TEXTURE_HEIGHT, or
TEXTURE_DEPTH, respectively. The contents of any texel outside the region mod-
i?ed by the call are unde?ned. These restrictions may be relaxed for speci?c com-
pressed internal formats whose images are easily modi?ed.
If internalformat is one of the speci?c RGTC formats described in table 3.14,
the texture is stored using one of the RGTC compressed texture image encod-
ings (see appendix C.1). If internalformat is an RGTC format, CompressedTex-
OpenGL 3.1 - May 28, 20093.8. TEXTURING 138
SubImage1D will generate an INVALID_ENUM error; CompressedTexSubIm-
age2D will generate an INVALID_OPERATION error if border is non-zero; and
CompressedTexSubImage3D will generate an INVALID_OPERATION error if
border is non-zero or target is notTEXTURE_2D_ARRAY. Since RGTC images are
easily edited along 44 texel boundaries, the limitations on subimage location and
size are relaxed for CompressedTexSubImage2D and CompressedTexSubIm-
age3D. These commands will result in an INVALID_OPERATION error if one of
the following conditions occurs:
 width is not a multiple of four, and width + xoset is not equal to the value
ofTEXTURE_WIDTH.
 height is not a multiple of four, and height +yoset is not equal to the value
ofTEXTURE_HEIGHT.
 xoffset or yoffset is not a multiple of four.
The contents of any 4 4 block of texels of an RGTC compressed texture
image that does not intersect the area being modi?ed are preserved during valid
TexSubImage* and CopyTexSubImage* calls.
3.8.4 Buffer Textures
In addition to one-, two-, and three-dimensional, one- and two-dimensional array,
and cube map textures described in previous sections, one additional type of texture
is supported. A buffer texture is similar to a one-dimensional texture. However,
unlike other texture types, the texel array is not stored as part of the texture. Instead,
a buffer object is attached to a buffer texture and the texel array is taken from that
buffer object’s data store. When the contents of a buffer object’s data store are
modi?ed, those changes are re?ected in the contents of any buffer texture to which
the buffer object is attached. Also unlike most other texture types, buffer textures
do not have multiple image levels; only a single data store is available.
The command
void TexBuffer(enum target, enum internalformat, uint
buffer );
attaches the storage for the buffer object named buffer to the active buffer texture,
and speci?es an internal format for the texel array found in the attached buffer
object. If buffer is zero, any buffer object attached to the buffer texture is detached,
and no new buffer object is attached. If buffer is non-zero, but is not the name
OpenGL 3.1 - May 28, 20093.8. TEXTURING 139
of an existing buffer object, the error INVALID_OPERATION is generated. target
must beTEXTURE_BUFFER. internalformat speci?es the storage format, and must
be one of the sized internal formats found in table 3.15.
When a buffer object is attached to a buffer texture, the buffer object’s data store
is taken as the texture’s texel array. The number of texels in the buffer texture’s
texel array is given by
 
buffer size
:
componentssizeof(base type)
where buffer size is the size of the buffer object, in basic machine units and
components and base type are the element count and base data type for elements,
as speci?ed in table 3.15. The number of texels in the texel array is then clamped
to the implementation-dependent limit MAX_TEXTURE_BUFFER_SIZE. When a
buffer texture is accessed in a shader, the results of a texel fetch are unde?ned
if the speci?ed texel coordinate is negative, or greater than or equal to the clamped
number of texels in the texel array.
When a buffer texture is accessed in a shader, an integer is provided to indicate
the texel coordinate being accessed. If no buffer object is bound to the buffer tex-
ture, the results of the texel access are unde?ned. Otherwise, the attached buffer
object’s data store is interpreted as an array of elements of the GL data type cor-
responding to internalformat. Each texel consists of one to four elements that are
mapped to texture components (R, G, B, and A). Elementm of the texel numbered
n is taken from elementncomponents +m of the attached buffer object’s data
store. Elements and texels are both numbered starting with zero. For texture for-
mats with signed or unsigned normalized ?xed-point components, the extracted
values are converted to ?oating-point using equations 2.1 or 2.3, respectively. The
components of the texture are then converted to an (R,G,B,A) vector according to
table 3.15, and returned to the shader as a four-component result vector with com-
ponents of the appropriate data type for the texture’s internal format. The base data
type, component count, normalized component information, and mapping of data
store elements to texture components is speci?ed in table 3.15.
In addition to attaching buffer objects to textures, buffer objects can be bound
to the buffer object target namedTEXTURE_BUFFER, in order to specify, modify, or
read the buffer object’s data store. The buffer object bound to TEXTURE_BUFFER
has no effect on rendering. A buffer object is bound toTEXTURE_BUFFER by call-
ing BindBuffer with target set toTEXTURE_BUFFER, as described in section 2.9.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 140
Sized Internal Format Base Type Components Norm Component
0 1 2 3
R8 ubyte 1 Yes R 0 0 1
R16 ushort 1 Yes R 0 0 1
R16F half 1 No R 0 0 1
R32F float 1 No R 0 0 1
R8I byte 1 No R 0 0 1
R16I short 1 No R 0 0 1
R32I int 1 No R 0 0 1
R8UI ubyte 1 No R 0 0 1
R16UI ushort 1 No R 0 0 1
R32UI uint 1 No R 0 0 1
RG8 ubyte 2 Yes R G 0 1
RG16 ushort 2 Yes R G 0 1
RG16F half 2 No R G 0 1
RG32F float 2 No R G 0 1
RG8I byte 2 No R G 0 1
RG16I short 2 No R G 0 1
RG32I int 2 No R G 0 1
RG8UI ubyte 2 No R G 0 1
RG16UI ushort 2 No R G 0 1
RG32UI uint 2 No R G 0 1
RGBA8 ubyte 4 Yes R G B A
RGBA16 ushort 4 Yes R G B A
RGBA16F half 4 No R G B A
RGBA32F float 4 No R G B A
RGBA8I byte 4 No R G B A
RGBA16I short 4 No R G B A
RGBA32I int 4 No R G B A
RGBA8UI ubyte 4 No R G B A
RGBA16UI ushort 4 No R G B A
RGBA32UI uint 4 No R G B A
Table 3.15: Internal formats for buffer textures. For each format, the data type
of each element is indicated in the “Base Type” column and the element count is
in the “Components” column. The “Norm” column indicates whether components
should be treated as normalized ?oating-point values. The “Component 0, 1, 2, and
3” columns indicate the mapping of each element of a texel to texture components.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 141
3.8.5 Texture Parameters
Various parameters control how the texel array is treated when speci?ed or
changed, and when applied to a fragment. Each parameter is set by calling
void TexParameterfifg(enum target,enum pname,T param );
void TexParameterfifgv(enum target,enum pname,
T *params );
void TexParameterIfi uigv(enum target,enum pname,
T *params );
taget is the target, eitherTEXTURE_1D,TEXTURE_2D,TEXTURE_3D,TEXTURE_-
1D_ARRAY,TEXTURE_2D_ARRAY. TEXTURE_RECTANGLE, orTEXTURE_CUBE_-
MAP. params is a symbolic constant indicating the parameter to be set; the possible
constants and corresponding parameters are summarized in table 3.16. In the ?rst
form of the command, param is a value to which to set a single-valued parameter;
in the remaining forms, params is an array of parameters whose type depends on
the parameter being set.
If the values for TEXTURE_BORDER_COLOR are speci?ed with TexParame-
terIiv or TexParameterIuiv, the values are unmodi?ed and stored with an internal
data type of integer. If speci?ed with TexParameteriv, they are converted to
?oating-point using equation 2.2. Otherwise the values are unmodi?ed and stored
as ?oating-point.
In the remainder of section 3.8, denote by lod , lod , level , and
min max
base
level the values of the texture parameters TEXTURE_MIN_LOD, TEXTURE_-
max
MAX_LOD,TEXTURE_BASE_LEVEL, andTEXTURE_MAX_LEVEL respectively.
Texture parameters for a cube map texture apply to the cube map as a whole;
the six distinct two-dimensional texture images use the texture parameters of the
cube map itself.
When target is TEXTURE_RECTANGLE, certain texture parameter values may
not be speci?ed. In this case, the error INVALID_ENUM is generated if the
TEXTURE_WRAP_S, TEXTURE_WRAP_T, or TEXTURE_WRAP_R parameter is set
to REPEAT or MIRRORED_REPEAT. The error INVALID_ENUM is generated if
TEXTURE_MIN_FILTER is set to a value other than NEAREST or LINEAR (no
mipmap ?ltering is permitted). The error INVALID_ENUM is generated if
TEXTURE_BASE_LEVEL is set to any value other than zero.
3.8.6 Depth Component Textures
Depth textures and the depth components of depth/stencil textures can be treated
as RED textures during texture ?ltering and application (see section 3.8.14). The
OpenGL 3.1 - May 28, 20093.8. TEXTURING 142
Name Type Legal Values
TEXTURE_WRAP_S enum CLAMP_TO_EDGE,REPEAT,
CLAMP_TO_BORDER,
MIRRORED_REPEAT
TEXTURE_WRAP_T enum CLAMP_TO_EDGE,REPEAT,
CLAMP_TO_BORDER,
MIRRORED_REPEAT
TEXTURE_WRAP_R enum CLAMP_TO_EDGE,REPEAT,
CLAMP_TO_BORDER,
MIRRORED_REPEAT
TEXTURE_MIN_FILTER enum NEAREST,
LINEAR,
NEAREST_MIPMAP_NEAREST,
NEAREST_MIPMAP_LINEAR,
LINEAR_MIPMAP_NEAREST,
LINEAR_MIPMAP_LINEAR,
TEXTURE_MAG_FILTER enum NEAREST,
LINEAR
TEXTURE_BORDER_COLOR 4 ?oats, any 4 values
integers, or
unsigned
integers
TEXTURE_MIN_LOD ?oat any value
TEXTURE_MAX_LOD ?oat any value
TEXTURE_BASE_LEVEL integer any non-negative integer
TEXTURE_MAX_LEVEL integer any non-negative integer
TEXTURE_LOD_BIAS ?oat any value
TEXTURE_COMPARE_MODE enum NONE, COMPARE_REF_TO_-
TEXTURE
TEXTURE_COMPARE_FUNC enum LEQUAL,GEQUAL
LESS,GREATER,
EQUAL,NOTEQUAL,
ALWAYS,NEVER
Table 3.16: Texture parameters and their values.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 143
Major Axis Direction Target s t m
c c a
+r TEXTURE_CUBE_MAP_POSITIVE_X  r  r r
x z y x
 r TEXTURE_CUBE_MAP_NEGATIVE_X r  r r
x z y x
+r TEXTURE_CUBE_MAP_POSITIVE_Y r r r
y x z y
 r TEXTURE_CUBE_MAP_NEGATIVE_Y r  r r
y x z y
+r TEXTURE_CUBE_MAP_POSITIVE_Z r  r r
z x y z
 r TEXTURE_CUBE_MAP_NEGATIVE_Z  r  r r
z x y z
Table 3.17: Selection of cube map images based on major axis direction of texture
coordinates.
initial state for depth and depth/stencil textures treats them asRED textures.
3.8.7 Cube Map Texture Selection
  
When cube map texturing is enabled, the s t r texture coordinates are treated
  
as a direction vector r r r emanating from the center of a cube (the q
x y z
coordinate can be ignored, since it merely scales the vector without affecting the
direction.) At texture application time, the interpolated per-fragment direction vec-
tor selects one of the cube map face’s two-dimensional images based on the largest
magnitude coordinate direction (the major axis direction). If two or more coor-
dinates have the identical magnitude, the implementation may de?ne the rule to
disambiguate this situation. The rule must be deterministic and depend only on
  
r r r . The target column in table 3.17 explains how the major axis direc-
x y z
tion maps to the two-dimensional image of a particular cube map target.
Using thes ,t , andm determined by the major axis direction as speci?ed in
c c a
  
table 3.17, an updated s t is calculated as follows:
 
1 s
c
s = + 1
2 jmj
a
 
1 t
c
t = + 1
2 jmj
a
  
This new s t is used to ?nd a texture value in the determined face’s two-
dimensional texture image using the rules given in sections 3.8.8 through 3.8.9.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 144
3.8.8 Texture Minification
Applying a texture to a primitive implies a mapping from texture image space to
framebuffer image space. In general, this mapping involves a reconstruction of
the sampled texture image, followed by a homogeneous warping implied by the
mapping to framebuffer space, then a ?ltering, followed ?nally by a resampling
of the ?ltered, warped, reconstructed image before applying it to a fragment. In
the GL this mapping is approximated by one of two simple ?ltering schemes. One
of these schemes is selected based on whether the mapping from texture space to
framebuffer space is deemed to magnify or minify the texture image.
Scale Factor and Level of Detail
The choice is governed by a scale factor(x;y) and the level-of-detail parameter
(x;y), de?ned as
 (x;y) = log [(x;y)] (3.17)
base
2
0
 (x;y) = (x;y) +clamp(bias +bias ) (3.18)
base texobj shader
8
0
lod ;  >lod
> max max
>
<
0 0
; lod  lod
min max
 = (3.19)
0
> lod ;  <lod
min min
>
:
undefined; lod >lod
min max
bias is the value of TEXTURE_LOD_BIAS for the bound texture object (as
texobj
described in section 3.8.5). bias is the value of the optional bias parameter
shader
in the texture lookup functions available to fragment shaders. If the texture access
is performed in a fragment shader without a provided bias, or outside a fragment
shader, thenbias is zero. The sum of these values is clamped to the range
shader
[ bias ;bias ] where bias is the value of the implementation de?ned
max max max
constantMAX_TEXTURE_LOD_BIAS.
If(x;y) is less than or equal to the constantc (see section 3.8.9) the texture
is said to be magni?ed; if it is greater, the texture is mini?ed. Sampling of mini?ed
textures is described in the remainder of this section, while sampling of magni?ed
textures is described in section 3.8.9.
The initial values of lod and lod are chosen so as to never clamp the
min max
normal range of. They may be respeci?ed for a speci?c texture by calling Tex-
Parameter[if] withpname set toTEXTURE_MIN_LOD orTEXTURE_MAX_LOD re-
spectively.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 145
Lets(x;y) be the function that associates ans texture coordinate with each set
of window coordinates (x;y) that lie within a primitive; de?net(x;y) andr(x;y)
analogously. Let
(
w + ; rectangular texture
t u
u(x;y) =
w s(x;y) + ; otherwise
t u
(
(3.20)
h + ; rectangular texture
t u
v(x;y) =
h t(x;y) + ; otherwise
t v
w(x;y) =d r(x;y) +
t w
wherew ,h , andd are as de?ned by equation 3.16 withw ,h , andd equal to
t t t s s s
the width, height, and depth of the image array whose level islevel . For a one-
base
dimensional or one-dimensional array texture, de?nev(x;y) = 0 andw(x;y) = 0;
for a two-dimensional, two-dimensional array, rectangular, or cube map texture,
de?new(x;y) = 0.
( ; ; ) are the texel offsets speci?ed in the OpenGL Shading Language
u v w
texture lookup functions that support offsets. If the texture function used does
not support offsets, all three shader offsets are taken to be zero. If any of the
offset values are outside the range of the implementation-de?ned values MIN_-
PROGRAM_TEXEL_OFFSET and MAX_PROGRAM_TEXEL_OFFSET, results of the
texture lookup are unde?ned.
For a polygon or point,  is given at a fragment with window coordinates (x;y)
by
8 9
s s
           
< 2 2 2 2 2 2=
@u @v @w @u @v @w
 = max + + ; + +
: @x @x @x @y @y @y ;
(3.21)
where@u=@x indicates the derivative ofu with respect to windowx, and similarly
for the other derivatives.
For a line, the formula is
s
      
2 2 2
@u @u @v @v @w @w
 = x + y + x + y + x + y l;
@x @y @x @y @x @y
(3.22)
where x = x  x and y = y  y with (x ;y ) and (x ;y ) being the
2 1 2 1 1 1 2 2
p
2 2
segment’s window coordinate endpoints andl = x + y .
OpenGL 3.1 - May 28, 20093.8. TEXTURING 146
While it is generally agreed that equations 3.21 and 3.22 give the best results
when texturing, they are often impractical to implement. Therefore, an imple-
mentation may approximate the ideal  with a function f(x;y) subject to these
conditions:
1. f(x;y) is continuous and monotonically increasing in each ofj@u=@xj,
j@u=@yj,j@v=@xj,j@v=@yj,j@w=@xj, andj@w=@yj
2. Let
   
   
@u @u
   
m = max ;
u
   
@x @y
   
 
   
@v @v
   
m = max ;
v
   
@x @y
   
   
@w @w
   
m = max ; :
w
   
@x @y
Then maxfm ;m ;m gf(x;y)m +m +m .
u v w u v w
Coordinate Wrapping and Texel Selection
After generatingu(x;y),v(x;y), andw(x;y), they may be clamped and wrapped
before sampling the texture, depending on the corresponding texture wrap modes.
Let
(
0
u (x;y) =
u(x;y); otherwise
(
0
v (x;y) =
v(x;y); otherwise
(
0
w (x;y) =
w(x;y); otherwise
whereclamp(a;b;c) returnsb ifa<b,c ifa>c, anda otherwise.
The value assigned to TEXTURE_MIN_FILTER is used to determine how the
texture value for a fragment is selected.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 147
When the value ofTEXTURE_MIN_FILTER isNEAREST, the texel in the image
0 0 0
array of level level that is nearest (in Manhattan distance) to (u;v;w ) is
base
obtained. Let (i;j;k) be integers such that
0
i =wrap(bu (x;y)c)
0
j =wrap(bv (x;y)c)
0
k =wrap(bw (x;y)c)
and the value returned bywrap() is de?ned in table 3.18. For a three-dimensional
texture, the texel at location (i;j;k) becomes the texture value. For two-
dimensional, two-dimensional array, rectangular, or cube map textures,k is irrele-
vant, and the texel at location (i;j) becomes the texture value. For one-dimensional
texture or one-dimensional array textures, j andk are irrelevant, and the texel at
locationi becomes the texture value.
For one- and two-dimensional array textures, the texel is obtained from image
layerl, where
(
clamp(bt + 0:5c; 0;h   1); for one-dimensional array textures
t
l =
clamp(br + 0:5c; 0;d   1); for two-dimensional array textures
t
Wrap mode Result ofwrap(coord)
CLAMP_TO_EDGE clamp(coord; 0;size  1)
CLAMP_TO_BORDER clamp(coord; 1;size)
REPEAT fmod(coord;size)
MIRRORED_REPEAT (size  1) mirror(fmod(coord; 2size) size)
a
Table 3.18: Texel location wrap mode application.fmod(a;b) returnsa bb c.
b
mirror(a) returnsa ifa 0, and (1 +a) otherwise. The values ofmode and
size are TEXTURE_WRAP_S andw , TEXTURE_WRAP_T andh , and TEXTURE_-
t t
WRAP_R andd when wrappingi,j, ork coordinates, respectively.
t
If the selected (i;j;k), (i;j), ori location refers to a border texel that satis?es
any of the conditions
i< b iw +b
s t s
j < b jh +b
s t s
k< b kd +b
s t s
OpenGL 3.1 - May 28, 20093.8. TEXTURING 148
then the border values de?ned by TEXTURE_BORDER_COLOR are used in place
of the non-existent texel. If the texture contains color components, the values of
TEXTURE_BORDER_COLOR are interpreted as an RGBA color to match the texture’s
internal format in a manner consistent with table 3.11. The internal data type of the
border values must be consistent with the type returned by the texture as described
in section 3.8, or the result is unde?ned. Border values are clamped before they are
used, according to the format in which texture components are stored. For signed
and unsigned normalized ?xed-point formats, border values are clamped to [ 1; 1]
and [0; 1], respectively. For ?oating-point and integer formats, border values are
clamped to the representable range of the format. If the texture contains depth
components, the ?rst component of TEXTURE_BORDER_COLOR is interpreted as a
depth value.
When the value of TEXTURE_MIN_FILTER is LINEAR, a 2 2 2 cube of
texels in the image array of levellevel is selected. Let
base
0
i =wrap(bu  0:5c)
0
0
j =wrap(bv   0:5c)
0
0
k =wrap(bw   0:5c)
0
0
i =wrap(bu  0:5c + 1)
1
0
j =wrap(bv   0:5c + 1)
1
0
k =wrap(bw   0:5c + 1)
1
0
alpha =frac(u  0:5)
0
beta =frac(v   0:5)
0
gamma =frac(w   0:5)
wherefrac(x) denotes the fractional part ofx.
For a three-dimensional texture, the texture value is found as
 = (1 )(1 )(1 ) +(1 )(1 )
i j k i j k
0 0 0 1 0 0
+ (1 )(1 ) +(1 )
i j k i j k
0 1 0 1 1 0
(3.23)
+ (1 )(1 ) +(1 )
i j k i j k
0 0 1 1 0 1
+ (1 ) +
i j k i j k
0 1 1 1 1 1
where is the texel at location (i;j;k) in the three-dimensional texture image.
ijk
For a two-dimensional, two-dimensional array, rectangular, or cube map tex-
ture,
OpenGL 3.1 - May 28, 20093.8. TEXTURING 149
 =(1 )(1 ) +(1 )
i j i j
0 0 1 0
+ (1 ) +
i j i j
0 1 1 1
where is the texel at location (i;j) in the two-dimensional texture image. For
ij
two-dimensional array textures, all texels are obtained from layerl, where
l =clamp(br + 0:5c; 0;d   1):
t
And for a one-dimensional or one-dimensional array texture,
 = (1 ) +
i i
0 1
where  is the texel at location i in the one-dimensional texture. For one-
i
dimensional array textures, both texels are obtained from layerl, where
l =clamp(bt + 0:5c; 0;h   1):
t
For any texel in the equation above that refers to a border texel outside the
de?ned range of the image, the texel value is taken from the texture border color as
withNEAREST ?ltering.
Rendering Feedback Loops
If all of the following conditions are satis?ed, then the value of the selected ,
ijk
 , or in the above equations is unde?ned instead of referring to the value of the
ij i
texel at location (i;j;k), (i;j), or (i) respectively. This situation is discussed in
more detail in the description of feedback loops in section 4.4.2.
 The currentDRAW_FRAMEBUFFER_BINDING names a framebuffer object F.
 The texture is attached to one of the attachment points, A, of framebuffer
object F.
 The value ofTEXTURE_MIN_FILTER isNEAREST orLINEAR, and the value
of FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL for attachment point A
is equal to the value ofTEXTURE_BASE_LEVEL
-or-
The value of TEXTURE_MIN_FILTER is NEAREST_MIPMAP_NEAREST,
NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, or LINEAR_-
MIPMAP_LINEAR, and the value of FRAMEBUFFER_ATTACHMENT_-
TEXTURE_LEVEL for attachment point A is within the the inclusive range
fromTEXTURE_BASE_LEVEL toq.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 150
Mipmapping
TEXTURE_MIN_FILTER values NEAREST_MIPMAP_NEAREST, NEAREST_-
MIPMAP_LINEAR, LINEAR_MIPMAP_NEAREST, and LINEAR_MIPMAP_LINEAR
each require the use of a mipmap. Rectangular textures do not support mipmap-
ping (it is an error to specify a mini?cation ?lter that requires mipmapping). A
mipmap is an ordered set of arrays representing the same image; each array has
a resolution lower than the previous one. If the image array of level level
base
has dimensions w h d , then there areblog (maxsize)c + 1 levels in the
t t t
2
mipmap. where
8
>w ; for 1D and 1D array textures
t
<
maxsize = max(w ;h ); for 2D, 2D array, and cube map textures
t t
>
:
max(w ;h ;d ); for 3D textures
t t t
Numbering the levels such that levellevel is the 0th level, theith array has
base
dimensions
w h d
t t t
max(1;b c) max(1;b c) max(1;b c)
w h d
d d d
where
i
w = 2
d
(
1; for 1D and 1D array textures
h =
d
i
2; otherwise
(
i
2; for 3D textures
d =
d
1; otherwise
until the last array is reached with dimension 1 1 1.
Each array in a mipmap is de?ned using TexImage3D, TexImage2D, Copy-
TexImage2D, TexImage1D, or CopyTexImage1D; the array being set is indicated
with the level-of-detail argument level. Level-of-detail numbers proceed from
level for the original texel array through p =blog (maxsize)c +level
base base
2
with each unit increase indicating an array of half the dimensions of the previous
one (rounded down to the next integer if fractional) as already described. All ar-
rays fromlevel throughq = minfp;level g must be de?ned, as discussed
max
base
in section 3.8.11.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 151
The values of level and level may be respeci?ed for a speci?c tex-
base max
ture by calling TexParameter[if] withpname set to TEXTURE_BASE_LEVEL or
TEXTURE_MAX_LEVEL respectively.
The errorINVALID_VALUE is generated if either value is negative.
The mipmap is used in conjunction with the level of detail to approximate the
application of an appropriately ?ltered texture to a fragment. Let c be the value
of at which the transition from mini?cation to magni?cation occurs (since this
discussion pertains to mini?cation, we are concerned only with values of where
>c).
For mipmap ?lters NEAREST_MIPMAP_NEAREST and LINEAR_MIPMAP_-
NEAREST, thedth mipmap array is selected, where
8
1
>level ; 
base
<
2
1 1 1
d = (3.24)
dlevel + + e  1; > ;level +q +
base base
2 2 2
>
:
1 1
q; > ;level +>q +
base
2 2
The rules for NEAREST or LINEAR ?ltering are then applied to the selected
array. Speci?cally, the coordinate (u;v;w) is computed as in equation 3.20, with
w ,h , andd equal to the width, height, and depth of the image array whose level
s s s
isd.
For mipmap ?lters NEAREST_MIPMAP_LINEAR and LINEAR_MIPMAP_-
LINEAR, the leveld andd mipmap arrays are selected, where
1 2
(
q; level +q
base
d = (3.25)
1
blevel +c; otherwise
base
(
q; level +q
base
d = (3.26)
2
d + 1; otherwise
1
The rules for NEAREST or LINEAR ?ltering are then applied to each of the
selected arrays, yielding two corresponding texture values and . Speci?cally,
1 2
for leveld , the coordinate (u;v;w) is computed as in equation 3.20, withw ,h ,
1 s s
andd equal to the width, height, and depth of the image array whose level isd .
s 1
0 0 0
For leveld the coordinate (u;v;w ) is computed as in equation 3.20, withw ,
2 s
h , andd equal to the width, height, and depth of the image array whose level is
s s
d .
2
The ?nal texture value is then found as
 = [1  frac()] + frac() :
1 2
OpenGL 3.1 - May 28, 20093.8. TEXTURING 152
Manual Mipmap Generation
Mipmaps can be generated manually with the command
void GenerateMipmap(enum target );
where target is one of TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_-
1D_ARRAY, TEXTURE_2D_ARRAY, or TEXTURE_CUBE_MAP. Mipmap generation
affects the texture image attached to target. For cube map textures, anINVALID_-
OPERATION error is generated if the texture bound to target is not cube complete,
as de?ned in section 3.8.11.
Mipmap generation replaces texel array levels level + 1 through q with
base
arrays derived from thelevel array, regardless of their previous contents. All
base
other mipmap arrays, including thelevel array, are left unchanged by this com-
base
putation.
The internal formats of the derived mipmap arrays all match those of the
level array, and the dimensions of the derived arrays follow the requirements
base
described in section 3.8.11.
The contents of the derived arrays are computed by repeated, ?ltered reduction
of thelevel array. For one- and two-dimensional array textures, each layer is
base
?ltered independently. No particular ?lter algorithm is required, though a box ?lter
is recommended as the default ?lter.
3.8.9 Texture Magnification
When  indicates magni?cation, the value assigned to TEXTURE_MAG_FILTER
determines how the texture value is obtained. There are two possible values
forTEXTURE_MAG_FILTER:NEAREST andLINEAR.NEAREST behaves exactly as
NEAREST forTEXTURE_MIN_FILTER andLINEAR behaves exactly asLINEAR for
TEXTURE_MIN_FILTER as described in section 3.8.8, including the texture coor-
dinate wrap modes speci?ed in table 3.18. The level-of-detaillevel texel array
base
is always used for magni?cation.
Implementations may either unconditionally assume c = 0 for the mini?ca-
tion vs. magni?cation switch-over point, or may choose to makec depend on the
combination of mini?cation and magni?cation modes as follows: if the magni?-
cation ?lter is given byLINEAR and the mini?cation ?lter is given byNEAREST_-
MIPMAP_NEAREST or NEAREST_MIPMAP_LINEAR, thenc = 0:5. This is done to
ensure that a mini?ed texture does not appear “sharper” than a magni?ed texture.
Otherwisec = 0.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 153
3.8.10 Combined Depth/Stencil Textures
If the texture image has a base internal format ofDEPTH_STENCIL, then the stencil
index texture component is ignored. The texture value does not include a stencil
index component, but includes only the depth component.
3.8.11 Texture Completeness
A texture is said to be complete if all the image arrays and texture parameters
required to utilize the texture for texture application are consistently de?ned. The
de?nition of completeness varies depending on the texture dimensionality.
For one-, two-, or three-dimensional textures and one- or two-dimensional ar-
ray textures, a texture is complete if the following conditions all hold true:
 The set of mipmap arrays level through q (where q is de?ned in the
base
Mipmapping discussion of section 3.8.8) were each speci?ed with the same
internal format.
 The dimensions of the arrays follow the sequence described in the Mipmap-
ping discussion of section 3.8.8.
 level level
base max
 Each dimension of thelevel array is positive.
base
 If the internal format of the arrays is integer (see (see table 3.12),
TEXTURE_MAG_FILTER must be NEAREST and TEXTURE_MIN_FILTER
must beNEAREST orNEAREST_MIPMAP_NEAREST.
Array levelsk wherek < level ork > q are insigni?cant to the de?nition of
base
completeness.
For cube map textures, a texture is cube complete if the following conditions
all hold true:
 Thelevel arrays of each of the six texture images making up the cube
base
map have identical, positive, and square dimensions.
 Thelevel arrays were each speci?ed with the same internal format.
base
Finally, a cube map texture is mipmap cube complete if, in addition to being
cube complete, each of the six texture images considered individually is complete.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 154
Effects of Completeness on Texture Application
Texture lookups performed in vertex and fragment shaders are affected by com-
pleteness of the texture being sampled as described in sections 2.11.7 and 3.9.2.
Effects of Completeness on Texture Image Specification
An implementation may allow a texture image array of level 1 or greater to be cre-
ated only if a mipmap complete set of image arrays consistent with the requested
array can be supported. A mipmap complete set of arrays is equivalent to a com-
plete set of arrays where level = 0 and level = 1000, and where the
base max
dimensions of the image array being created are understood to be half the corre-
sponding dimensions of the next lower numbered array (rounded down to the next
integer if fractional).
3.8.12 Texture State and Proxy State
The state necessary for texture can be divided into two categories. First, there
are the multiple sets of texel arrays (a single array for the rectangular texture tar-
get; one set of mipmap arrays each for the one-, two-, and three-dimensional and
one- and two-dimensional array texture targets; and six sets of mipmap arrays for
the cube map texture targets) and their number. Each array has associated with
it a width, height (two- and three-dimensional, rectangular, one-dimensional ar-
ray, and cube map only), and depth (three-dimensional and two-dimensional array
only), an integer describing the internal format of the image, integer values de-
scribing the resolutions of each of the red, green, blue, alpha, depth, and stencil
components of the image, integer values describing the type (unsigned normal-
ized, integer, ?oating-point, etc.) of each of the components, a boolean describing
whether the image is compressed or not, and an integer size of a compressed image.
Each initial texel array is null (zero width, height, and depth, internal formatRGBA,
component sizes set to zero and component types set toNONE, the compressed ?ag
set to FALSE, and a zero compressed size). The buffer texture target has asso-
ciated an integer containing the name of the buffer object that provided the data
store for the texture, initially zero, and an integer identifying the internal format of
the texture, initially R8. Next, there are the four sets of texture properties, corre-
sponding to the one-, two-, three-dimensional, and cube map texture targets. Each
set consists of the selected mini?cation and magni?cation ?lters, the wrap modes
fors,t (two- and three-dimensional and cube map only), andr (three-dimensional
only), the TEXTURE_BORDER_COLOR, two ?oating-point numbers describing the
minimum and maximum level of detail, two integers describing the base and max-
imum mipmap array, a boolean ?ag indicating whether the texture is resident,
OpenGL 3.1 - May 28, 20093.8. TEXTURING 155
and three integers describing the depth texture mode, compare mode, and com-
pare function. In the initial state, the value assigned to TEXTURE_MIN_FILTER
isNEAREST_MIPMAP_LINEAR, (except for rectangular textures, where the initial
value isLINEAR), and the value forTEXTURE_MAG_FILTER isLINEAR.s,t, andr
wrap modes are all set toREPEAT (except for rectangular textures, where the initial
value is CLAMP_TO_EDGE). The values of TEXTURE_MIN_LOD and TEXTURE_-
MAX_LOD are -1000 and 1000 respectively. The values ofTEXTURE_BASE_LEVEL
andTEXTURE_MAX_LEVEL are 0 and 1000 respectively. The value ofTEXTURE_-
BORDER_COLOR is (0,0,0,0). The values of TEXTURE_COMPARE_MODE, and
TEXTURE_COMPARE_FUNC are NONE, andLEQUAL respectively.
In addition to image arrays for the non-proxy texture targets described above,
partially instantiated image arrays are maintained for one-, two-, and three-
dimensional, rectangular, and one- and two-dimensional array textures. Addi-
tionally, a single proxy image array is maintained for the cube map texture. Each
proxy image array includes width, height, depth, and internal format state values,
as well as state for the red, green, blue, alpha, depth, and stencil component reso-
lutions and types. Proxy arrays do not include image data nor texture parameters.
When TexImage3D is executed with target speci?ed asPROXY_TEXTURE_3D, the
three-dimensional proxy state values of the speci?ed level-of-detail are recomputed
and updated. If the image array would not be supported by TexImage3D called
with target set toTEXTURE_3D, no error is generated, but the proxy width, height,
depth, and component resolutions are set to zero, and the component types are set
to NONE. If the image array would be supported by such a call to TexImage3D,
the proxy state values are set exactly as though the actual image array were being
speci?ed. No pixel data are transferred or processed in either case.
Proxy arrays for one- and two-dimensional textures and one- and two-
dimensional array textures are operated on in the same way when TexImage1D is
executed with target speci?ed as PROXY_TEXTURE_1D, TexImage2D is executed
with target speci?ed as PROXY_TEXTURE_2D, PROXY_TEXTURE_1D_ARRAY, or
PROXY_TEXTURE_RECTANGLE, or TexImage3D is executed with target speci?ed
asPROXY_TEXTURE_2D_ARRAY.
The cube map proxy arrays are operated on in the same manner when TexIm-
age2D is executed with the target ?eld speci?ed asPROXY_TEXTURE_CUBE_MAP,
with the addition that determining that a given cube map texture is supported with
PROXY_TEXTURE_CUBE_MAP indicates that all six of the cube map 2D images
are supported. Likewise, if the speci?edPROXY_TEXTURE_CUBE_MAP is not sup-
ported, none of the six cube map 2D images are supported.
There is no image or non-level-related state associated with proxy textures.
Therefore they may not be used as textures, and calling BindTexture, GetTex-
Image, GetTexParameteriv, or GetTexParameterfv with a proxy texture target
OpenGL 3.1 - May 28, 20093.8. TEXTURING 156
generates anINVALID_ENUM error.
3.8.13 Texture Objects
In addition to the default textures TEXTURE_1D, TEXTURE_2D, TEXTURE_-
3D, TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_RECTANGLE,
TEXTURE_BUFFER, and TEXTURE_CUBE_MAP, named one, two-, and three-
dimensional, one- and two-dimensional array, rectangular, buffer, and cube map
texture objects can be created and operated upon. The name space for texture
objects is the unsigned integers, with zero reserved by the GL.
A texture object is created by binding an unused name to one of these texture
targets. The binding is effected by calling
void BindTexture(enum target,uint texture );
with target set to the desired texture target and texture set to the unused name. The
resulting texture object is a new state vector, comprising all the state values listed
in section 3.8.12, set to the same initial values. The new texture object bound to
target is, and remains a texture of the dimensionality and type speci?ed by target
until it is deleted.
BindTexture may also be used to bind an existing texture object to any of
these targets. The error INVALID_OPERATION is generated if an attempt is made
to bind a texture object of different dimensionality than the speci?ed target. If the
bind is successful no change is made to the state of the bound texture object, and
any previous binding to target is broken.
BindTexture fails and an INVALID_OPERATION error is generated if texture
is not zero or a name returned from a previous call to GenTextures, or if such a
name has since been deleted with DeleteTextures.
While a texture object is bound, GL operations on the target to which it is
bound affect the bound object, and queries of the target to which it is bound return
state from the bound object. If texture mapping of the dimensionality of the target
to which a texture object is bound is enabled, the state of the bound texture object
directs the texturing operation.
In the initial state, TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_-
1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_RECTANGLE, TEXTURE_BUFFER,
and TEXTURE_CUBE_MAP have one-, two-, and three-dimensional, one- and two-
dimensional array, rectangular, buffer, and cube map texture state vectors re-
spectively associated with them. In order that access to these initial textures not
be lost, they are treated as texture objects all of whose names are 0. The ini-
tial one-, two-, three-dimensional, one- and two-dimensional array, rectangular,
OpenGL 3.1 - May 28, 20093.8. TEXTURING 157
buffer, and cube map texture is therefore operated upon, queried, and applied as
TEXTURE_1D, TEXTURE_2D, TEXTURE_3D, TEXTURE_1D_ARRAY, TEXTURE_-
2D_ARRAY, TEXTURE_RECTANGLE, TEXTURE_BUFFER, orTEXTURE_CUBE_MAP
respectively while 0 is bound to the corresponding targets.
Texture objects are deleted by calling
void DeleteTextures(sizei n,uint *textures );
textures contains n names of texture objects to be deleted. After a texture object
is deleted, it has no contents or dimensionality, and its name is again unused. If
a texture that is currently bound to any of the target bindings of BindTexture is
deleted, it is as though BindTexture had been executed with the same target and
texture zero. Additionally, special care must be taken when deleting a texture if any
of the images of the texture are attached to a framebuffer object. See section 4.4.2
for details.
Unused names in textures are silently ignored, as is the value zero.
The command
void GenTextures(sizei n,uint *textures );
returns n previously unused texture object names in textures. These names are
marked as used, for the purposes of GenTextures only, but they acquire texture
state and a dimensionality only when they are ?rst bound, just as if they were
unused.
The texture object name space, including the initial one-, two-, and three-
dimensional, one- and two-dimensional array, rectangular, buffer, and cube map
texture objects, is shared among all texture units. A texture object may be bound
to more than one texture unit simultaneously. After a texture object is bound, any
GL operations on that target object affect any other texture units to which the same
texture object is bound.
Texture binding is affected by the setting of the stateACTIVE_TEXTURE.
If a texture object is deleted, it as if all texture units which are bound to that
texture object are rebound to texture object zero.
3.8.14 Texture Comparison Modes
Texture values can also be computed according to a speci?ed comparison function.
Texture parameter TEXTURE_COMPARE_MODE speci?es the comparison operands,
and parameterTEXTURE_COMPARE_FUNC speci?es the comparison function.
OpenGL 3.1 - May 28, 20093.8. TEXTURING 158
Depth Texture Comparison Mode
If the currently bound texture’s base internal format is DEPTH_COMPONENT or
DEPTH_STENCIL, then TEXTURE_COMPARE_MODE and TEXTURE_COMPARE_-
FUNC control the output of the texture unit as described below. Otherwise, the
texture unit operates in the normal manner and texture comparison is bypassed.
LetD be the depth texture value andD be the reference value, provided
t ref
by the shader’s texture lookup function.
If the texture’s internal format indicates a ?xed-point depth texture, then D
t
and D are clamped to the range [0; 1]; otherwise no clamping is performed.
ref
Then the effective texture value is computed as follows:
If the value ofTEXTURE_COMPARE_MODE isNONE, then
r =D
t
If the value of TEXTURE_COMPARE_MODE is COMPARE_REF_TO_TEXTURE,
thenr depends on the texture comparison function as shown in table 3.19.
Texture Comparison Function Computed resultr
(
1:0; D D
ref t
LEQUAL r =
0:0; D >D
ref t
(
1:0; D D
ref t
GEQUAL r =
0:0; D <D
ref t
(
1:0; D <D
ref t
LESS r =
0:0; D D
t
ref
(
1:0; D >D
ref t
GREATER r =
0:0; D D
ref t
(
1:0; D =D
t
ref
EQUAL r =
0:0; D 6=D
ref t
(
1:0; D =6 D
ref t
NOTEQUAL r =
0:0; D =D
ref t
ALWAYS r = 1:0
NEVER r = 0:0
Table 3.19: Depth texture comparison functions.
The resultingr is assigned to R .
t
OpenGL 3.1 - May 28, 20093.8. TEXTURING 159
If the value of TEXTURE_MAG_FILTER is not NEAREST, or the value of
TEXTURE_MIN_FILTER is notNEAREST orNEAREST_MIPMAP_NEAREST, thenr
may be computed by comparing more than one depth texture value to the texture
reference value. The details of this are implementation-dependent, but r should
be a value in the range [0; 1] which is proportional to the number of comparison
passes or failures.
3.8.15 sRGB Texture Color Conversion
If the currently bound texture’s internal format is one of SRGB, SRGB8, SRGB_-
ALPHA, SRGB8_ALPHA8, COMPRESSED_SRGB, or COMPRESSED_SRGB_ALPHA,
the red, green, and blue components are converted from an sRGB color space to
a linear color space as part of ?ltering described in sections 3.8.8 and 3.8.9. Any
alpha component is left unchanged. Ideally, implementations should perform this
color conversion on each sample prior to ?ltering but implementations are allowed
to perform this conversion after ?ltering (though this post-?ltering approach is in-
ferior to converting from sRGB prior to ?ltering).
The conversion from an sRGB encoded component,c , to a linear component,
s
c , is as follows.
l
(
c
s
; c  0:04045
s
12:92
c =    (3.27)
l
2:4
c +0:055
s
; c > 0:04045
s
1:055
Assumec is the sRGB component in the range [0; 1].
s
3.8.16 Shared Exponent Texture Color Conversion
If the currently bound texture’s internal format is RGB9_E5, the red, green, blue,
and shared bits are converted to color components (prior to ?ltering) using shared
exponent decoding. The componentred ,green ,blue , andexp values (see
s s s shared
section 3.8.1) are treated as unsigned integers and are converted tored,green, and
blue as follows:
exp  B
shared
red =red 2
s
exp  B
shared
green =green 2
s
exp  B
shared
blue =blue 2
s
OpenGL 3.1 - May 28, 20093.9. FRAGMENTSHADERS 160
3.9 Fragment Shaders
The sequence of operations that are applied to fragments that result from rasterizing
a point, line segment, or polygon are described using a fragment shader.
A fragment shader is an array of strings containing source code for the opera-
tions that are meant to occur on each fragment that results from rasterization. The
language used for fragment shaders is described in the OpenGL Shading Language
Specification.
Fragment shaders are created as described in section 2.11.1 using a type pa-
rameter ofFRAGMENT_SHADER. They are attached to and used in program objects
as described in section 2.11.2.
When the program object currently in use includes a fragment shader, its frag-
ment shader is considered active, and is used to process fragments. If the program
object has no fragment shader, or no program object is currently in use, the results
of fragment shader execution are unde?ned.
3.9.1 Shader Variables
Fragment shaders can access uniforms belonging to the current shader object. The
amount of storage available for fragment shader uniform variables in the default
uniform block is speci?ed by the value of the implementation-dependent constant
MAX_FRAGMENT_UNIFORM_COMPONENTS. The total amount of combined storage
available for fragment shader uniform variables in all uniform blocks (includ-
ing the default uniform block) is speci?ed by the value of the implementation-
dependent constant MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS. These
values represent the numbers of individual ?oating-point, integer, or boolean val-
ues that can be held in uniform variable storage for a fragment shader. A uniform
matrix will consume no more than 4min(r;c) such values, wherer andc are
the number of rows and columns in the matrix. A link error will be generated if
an attempt is made to utilize more than the space available for fragment shader
uniform variables.
Fragment shaders can read varying variables that correspond to the attributes
of the fragments produced by rasterization. The OpenGL Shading Language Spec-
i?cation de?nes a set of built-in varying variables that can be be accessed by a
fragment shader. These built-in varying variables include data associated with a
fragment such as the fragment’s position.
Additionally, when a vertex shader is active, it may de?ne one or more varying
variables (see section 2.11.6 and the OpenGL Shading Language Specification).
These values are, if not ?at shaded, interpolated across the primitive being ren-
dered. The results of these interpolations are available when varying variables of
OpenGL 3.1 - May 28, 20093.9. FRAGMENTSHADERS 161
Texture Base Texture source color
Internal Format C A
s s
RED (R ; 0; 0) 1
t
RG (R ;G ; 0) 1
t t
RGB (R ;G ;B ) 1
t t t
RGBA (R ;G ;B ) A
t t t t
Table 3.20: Correspondence of ?ltered texture components to texture source com-
ponents.
the same name are de?ned in the fragment shader.
A fragment shader can also write to varying out variables. Values written to
these variables are used in the subsequent per-fragment operations. Varying out
variables can be used to write ?oating-point, integer or unsigned integer values des-
tined for buffers attached to a framebuffer object, or destined for color buffers at-
tached to the default framebuffer. The Shader Outputs subsection of section 3.9.2
describes how to direct these values to buffers.
3.9.2 Shader Execution
The executable version of the fragment shader is used to process incoming frag-
ment values that are the result of rasterization.
Texture Access
The Shader Only Texturing subsection of section 2.11.7 describes texture lookup
functionality accessible to a vertex shader. The texel fetch and texture size query
functionality described there also applies to fragment shaders.
When a texture lookup is performed in a fragment shader, the GL computes
the ?ltered texture value in the manner described in sections 3.8.8 and 3.8.9, and
converts it to a texture source colorC according to table 3.20. The GL returns a
s
four-component vector (R ;G ;B ;A ) to the fragment shader. For the purposes
s s s s
du du dv dv dw dw
of level-of-detail calculations, the derivatives , , , , and may be
dx dy dx dy dx dy
approximated by a differencing algorithm as detailed in section 8.8 of the OpenGL
Shading Language speci?cation.
Texture lookups involving textures with depth component data can either return
the depth data directly or return the results of a comparison with theD value (see
ref
section 3.8.14) used to perform the lookup. The comparison operation is requested
in the shader by using any of the shadow sampler types (sampler1DShadow,
OpenGL 3.1 - May 28, 20093.9. FRAGMENTSHADERS 162
sampler2DShadow, or sampler2DRectShadow), and in the texture using the
TEXTURE_COMPARE_MODE parameter. These requests must be consistent; the re-
sults of a texture lookup are unde?ned if:
 The sampler used in a texture lookup function is not one of the shadow
sampler types, the texture object’s internal format is DEPTH_COMPONENT
orDEPTH_STENCIL, and theTEXTURE_COMPARE_MODE is notNONE.
 The sampler used in a texture lookup function is one of the shadow sam-
pler types, the texture object’s internal format is DEPTH_COMPONENT or
DEPTH_STENCIL, and theTEXTURE_COMPARE_MODE isNONE.
 The sampler used in a texture lookup function is one of the shadow sampler
types, and the texture object’s internal format is not DEPTH_COMPONENT or
DEPTH_STENCIL.
The stencil index texture internal component is ignored if the base internal
format isDEPTH_STENCIL.
If a fragment shader uses a sampler whose associated texture object is not com-
plete, as de?ned in section 3.8.11, the texture image unit will return (R;G;B;A)
= (0; 0; 0; 1).
The number of separate texture units that can be accessed from within a
fragment shader during the rendering of a single primitive is speci?ed by the
implementation-dependent constantMAX_TEXTURE_IMAGE_UNITS.
Shader Inputs
The OpenGL Shading Language speci?cation describes the values that are avail-
able as inputs to the fragment shader.
The built-in variable gl_FragCoord holds the window coordinates x, y, z,
1
and for the fragment. Thez component of gl_FragCoord undergoes an im-
w
plied conversion to ?oating-point. This conversion must leave the values 0 and
1 invariant. Note that thisz component already has a polygon offset added in, if
1
enabled (see section 3.6.4). The value is computed from thew coordinate (see
c
w
section 2.12).
The built-in variable gl_FrontFacing is set to TRUE if the fragment is gen-
erated from a front-facing primitive, and FALSE otherwise. For fragments gener-
ated from triangle primitives (including ones resulting from primitives rendered
as points or lines), the determination is made by examining the sign of the area
computed by equation 3.8 of section 3.6.1 (including the possible reversal of this
sign controlled by FrontFace). If the sign is positive, fragments generated by the
OpenGL 3.1 - May 28, 20093.9. FRAGMENTSHADERS 163
primitive are front-facing; otherwise, they are back-facing. All other fragments are
considered front-facing.
The built-in variablegl_PrimitiveID is ?lled with the number of primitives
processed by the rasterizer since the last drawing command was called. The ?rst
primitive generated by a drawing command is numbered zero, and the primitive ID
counter is incremented after every individual point, line, or polygon primitive is
processed. For polygons drawn in point or line mode, the primitive ID counter is
incremented only once, even though multiple points or lines may be drawn.
Restarting a primitive using the primitive restart index (see section 2.8) has no
effect on the primitive ID counter.
gl_PrimitiveID is only de?ned under the same conditions that gl_-
VertexID is de?ned, as described under “Shader Inputs” in section 2.11.7.
Shader Outputs
The OpenGL Shading Language speci?cation describes the values that may be
output by a fragment shader. These outputs are split into two categories, user-
de?ned varying out variables and the built-in variables gl_FragColor, gl_-
FragData[n], and gl_FragDepth. If fragment color clamping is enabled and
the color buffer has an unsigned normalized ?xed-point, signed normalized ?xed-
point, or ?oating-point format, the ?nal fragment color, fragment data, or vary-
ing out variable values written by a fragment shader are clamped to the range
[0; 1]. Only user-de?ned varying out variables declared as a ?oating-point type are
clamped and may be converted. If fragment color clamping is disabled, or the color
buffer has an integer format, the ?nal fragment color, fragment data, or varying out
variable values are not modi?ed. For ?xed-point depth buffers, the ?nal fragment
depth written by a fragment shader is ?rst clamped to [0; 1] and then converted to
?xed-point as if it were a windowz value (see section 2.12.1). For ?oating-point
depth buffers, conversion is not performed but clamping is. Note that the depth
range computation is not applied here, only the conversion to ?xed-point.
Color values written by a fragment shader may be ?oating-point, signed inte-
ger, or unsigned integer. If the color buffer has an signed or unsigned normalized
?xed-point format, color values are assumed to be ?oating-point and are converted
to ?xed-point as described in equations 2.6 or 2.4, respectively; otherwise no type
conversion is applied. If the values written by the fragment shader do not match
the format(s) of the corresponding color buffer(s), the result is unde?ned.
Writing to gl_FragColor speci?es the fragment color (color number zero)
that will be used by subsequent stages of the pipeline. Writing to gl_-
FragData[n] speci?es the value of fragment color number n. Any colors, or
color components, associated with a fragment that are not written by the frag-
OpenGL 3.1 - May 28, 20093.9. FRAGMENTSHADERS 164
ment shader are unde?ned. A fragment shader may not statically assign values to
more than one of gl_FragColor, gl_FragData, and any user-de?ned varying
out variable. In this case, a compile or link error will result. A shader statically
assigns a value to a variable if, after pre-processing, it contains a statement that
would write to the variable, whether or not run-time ?ow of control will cause that
statement to be executed.
Writing to gl_FragDepth speci?es the depth value for the fragment being
processed. If the active fragment shader does not statically assign a value togl_-
FragDepth, then the depth value generated during rasterization is used by sub-
sequent stages of the pipeline. Otherwise, the value assigned to gl_FragDepth
is used, and is unde?ned for any fragments where statements assigning a value to
gl_FragDepth are not executed. Thus, if a shader statically assigns a value to
gl_FragDepth, then it is responsible for always writing it.
The binding of a user-de?ned varying out variable to a fragment color number
can be speci?ed explicitly. The command
void BindFragDataLocation(uint program,
uint colorNumber,const char *name );
speci?es that the varying out variable name in program should be bound to frag-
ment color colorNumber when the program is next linked. If name was bound
previously, its assigned binding is replaced with colorNumber. name must be a
null-terminated string. The errorINVALID_VALUE is generated if colorNumber is
equal or greater thanMAX_DRAW_BUFFERS. BindFragDataLocation has no effect
until the program is linked. In particular, it doesn’t modify the bindings of varying
out variables in a program that has already been linked. The error INVALID_-
OPERATION is generated if name starts with the reservedgl_ pre?x.
When a program is linked, any varying out variables without a binding spec-
i?ed through BindFragDataLocation will automatically be bound to fragment
colors by the GL. Such bindings can be queried using the command GetFrag-
DataLocation. LinkProgram will fail if the number of active outputs is greater
than the value of MAX_DRAW_BUFFERS. LinkProgram will also fail if more than
one varying out variable is bound to the same number. This type of aliasing is not
allowed.
BindFragDataLocation may be issued before any shader objects are attached
to a program object. Hence it is allowed to bind any name (except a name starting
with gl_) to a color number, including a name that is never used as a varying out
variable in any fragment shader object. Assigned bindings for variables that do not
exist are ignored.
After a program object has been linked successfully, the bindings of varying
out variable names to color numbers can be queried. The command
OpenGL 3.1 - May 28, 20093.10. ANTIALIASINGAPPLICATION 165
int GetFragDataLocation(uint program,const
char *name );
returns the number of the fragment color to which the varying out variable name
was bound when the program object program was last linked. name must be
a null-terminated string. If program has not been successfully linked, the error
INVALID_OPERATION is generated. If name is not a varying out variable, or if an
error occurs, -1 will be returned.
3.10 Antialiasing Application
If antialiasing is enabled for the primitive from which a rasterized fragment was
produced, then the computed coverage value is applied to the fragment. The value
is multiplied by the fragment’s alpha (A) value to yield a ?nal alpha value. The
coverage value is applied separately to each fragment color, and only applied if the
corresponding color buffer in the framebuffer has a ?xed- or ?oating-point format.
3.11 Multisample Point Fade
Finally, if multisampling is enabled and the rasterized fragment results from a point
primitive, then the computed fade factor from equation 3.2 is applied to the frag-
ment. The fade factor is multiplied by the fragment’s alpha value to yield a ?nal
alpha value. The fade factor is applied separately to each fragment color, and
only applied if the corresponding color buffer in the framebuffer has a ?xed- or
?oating-point format.
OpenGL 3.1 - May 28, 2009Chapter 4
Per-Fragment Operations and the
Framebuffer
The framebuffer, whether it is the default framebuffer or a framebuffer object (see
section 2.1), consists of a set of pixels arranged as a two-dimensional array. For
purposes of this discussion, each pixel in the framebuffer is simply a set of some
number of bits. The number of bits per pixel may vary depending on the GL im-
plementation, the type of framebuffer selected, and parameters speci?ed when the
framebuffer was created. Creation and management of the default framebuffer is
outside the scope of this speci?cation, while creation and management of frame-
buffer objects is described in detail in section 4.4.
Corresponding bits from each pixel in the framebuffer are grouped together
into a bitplane; each bitplane contains a single bit from each pixel. These bitplanes
are grouped into several logical buffers. These are the color, depth, and stencil
buffers. The color buffer actually consists of a number of buffers, and these color
buffers serve related but slightly different purposes depending on whether the GL
is bound to the default framebuffer or a framebuffer object.
For the default framebuffer, the color buffers are the front left buffer, the front
right buffer, the back left buffer, and the back right buffer. Typically the con-
tents of the front buffers are displayed on a color monitor while the contents of the
back buffers are invisible. (Monoscopic contexts display only the front left buffer;
stereoscopic contexts display both the front left and the front right buffers.) All
color buffers must have the same number of bitplanes, although an implementation
or context may choose not to provide right buffers, or back buffers at all. Further,
an implementation or context may choose not to provide depth or stencil buffers.
If no default framebuffer is associated with the GL context, the framebuffer is in-
complete except when a framebuffer object is bound (see sections 4.4.1 and 4.4.4).
1664.1. PER-FRAGMENTOPERATIONS 167
Framebuffer objects are not visible, and do not have any of the color buffers
present in the default framebuffer. Instead, the buffers of an framebuffer object
are speci?ed by attaching individual textures or renderbuffers (see section 4.4) to
a set of attachment points. A framebuffer object has an array of color buffer at-
tachment points, numbered zero throughn, a depth buffer attachment point, and
a stencil buffer attachment point. In order to be used for rendering, a framebuffer
object must be complete, as described in section 4.4.4. Not all attachments of a
framebuffer object need to be populated.
Each pixel in a color buffer consists of up to four color components. The four
color components are named R, G, B, and A, in that order; color buffers are not
required to have all four color components. R, G, B, and A components may be
represented as signed or unsigned normalized ?xed-point, ?oating-point, or signed
or unsigned integer values; all components must have the same representation.
Each pixel in a depth buffer consists of a single unsigned integer value in the format
described in section 2.12.1 or a ?oating-point value. Each pixel in a stencil buffer
consists of a single unsigned integer value.
The number of bitplanes in the color, depth, and stencil buffers is dependent
on the currently bound framebuffer. For the default framebuffer, the number of
bitplanes is ?xed. For framebuffer objects, the number of bitplanes in a given
logical buffer may change if the image attached to the corresponding attachment
point changes.
The GL has two active framebuffers; the draw framebuffer is the destination
for rendering operations, and the read framebuffer is the source for readback op-
erations. The same framebuffer may be used for both drawing and reading. Sec-
tion 4.4.1 describes the mechanism for controlling framebuffer usage.
1
The default framebuffer is initially used as the draw and read framebuffer ,
and the initial state of all provided bitplanes is unde?ned. The format and encod-
ing of buffers in the draw and read framebuffers can be queried as described in
section 6.1.3.
4.1 Per-Fragment Operations
A fragment produced by rasterization with window coordinates of (x ;y ) mod-
w w
i?es the pixel in the framebuffer at that location based on a number of parame-
ters and conditions. We describe these modi?cations and tests, diagrammed in
?gure 4.1, in the order in which they are performed. Figure 4.1 diagrams these
1
The window system binding API may allow associating a GL context with two separate “default
framebuffers” provided by the window system as the draw and read framebuffers, but if so, both
default framebuffers are referred to by the name zero at their respective binding points.
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 168
Fragment
(or sample) Pixel Multisample
Scissor
+ Ownership Fragment
Test
Associated Test Operations
Data
Occlusion Depth Buffer Stencil
Blending
Query Test Test
Framebuffer Framebuffer Framebuffer
SRGB To
Dithering Logicop
Conversion Framebuffer
Framebuffer
Figure 4.1. Per-fragment operations.
modi?cations and tests.
4.1.1 Pixel Ownership Test
The ?rst test is to determine if the pixel at location (x ;y ) in the framebuffer
w w
is currently owned by the GL (more precisely, by this GL context). If it is not,
the window system decides the fate the incoming fragment. Possible results are
that the fragment is discarded or that some subset of the subsequent per-fragment
operations are applied to the fragment. This test allows the window system to
control the GL’s behavior, for instance, when a GL window is obscured.
If the draw framebuffer is a framebuffer object (see section 4.2.1), the pixel
ownership test always passes, since the pixels of framebuffer objects are owned by
the GL, not the window system. If the draw framebuffer is the default framebuffer,
the window system controls pixel ownership.
4.1.2 Scissor Test
The scissor test determines if (x ;y ) lies within the scissor rectangle de?ned by
w w
four values. These values are set with
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 169
void Scissor(int left,int bottom,sizei width,
sizei height );
If left  x < left + width and bottom  y < bottom + height, then the
w w
scissor test passes. Otherwise, the test fails and the fragment is discarded. The
test is enabled or disabled using Enable or Disable using the constantSCISSOR_-
TEST. When disabled, it is as if the scissor test always passes. If either width or
height is less than zero, then the error INVALID_VALUE is generated. The state
required consists of four integer values and a bit indicating whether the test is
enabled or disabled. In the initial state, left = bottom = 0. width and height are
set to the width and height, respectively, of the window into which the GL is to
do its rendering. If the default framebuffer is bound but no default framebuffer is
associated with the GL context (see chapter 4), then width and height are initially
set to zero. Initially, the scissor test is disabled.
4.1.3 Multisample Fragment Operations
This step modi?es fragment alpha and coverage values based on the val-
ues of SAMPLE_ALPHA_TO_COVERAGE, SAMPLE_ALPHA_TO_ONE, SAMPLE_-
COVERAGE, SAMPLE_COVERAGE_VALUE, and SAMPLE_COVERAGE_INVERT. No
changes to the fragment alpha or coverage values are made at this step if
MULTISAMPLE is disabled, or if the value ofSAMPLE_BUFFERS is not one.
SAMPLE_ALPHA_TO_COVERAGE, SAMPLE_ALPHA_TO_ONE, and SAMPLE_-
COVERAGE are enabled and disabled by calling Enable and Disable with cap spec-
i?ed as one of the three token values. All three values are queried by calling IsEn-
abled with cap set to the desired token value. If SAMPLE_ALPHA_TO_COVERAGE
is enabled and the color buffer has a ?xed-point or ?oating-point format, a tempo-
rary coverage value is generated where each bit is determined by the alpha value at
the corresponding sample location. The temporary coverage value is then ANDed
with the fragment coverage value. Otherwise the fragment coverage value is un-
changed at this point. If multiple colors are written by a fragment shader, the alpha
value of fragment color zero is used to determine the temporary coverage value.
No speci?c algorithm is required for converting the sample alpha values to a
temporary coverage value. It is intended that the number of 1’s in the temporary
coverage be proportional to the set of alpha values for the fragment, with all 1’s
corresponding to the maximum of all alpha values, and all 0’s corresponding to
all alpha values being 0. The alpha values used to generate a coverage value are
clamped to the range [0; 1]. It is also intended that the algorithm be pseudo-random
in nature, to avoid image artifacts due to regular coverage sample locations. The
algorithm can and probably should be different at different pixel locations. If it
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 170
does differ, it should be de?ned relative to window, not screen, coordinates, so that
rendering results are invariant with respect to window position.
Next, if SAMPLE_ALPHA_TO_ONE is enabled, each alpha value is replaced
by the maximum representable alpha value. Otherwise, the alpha values are not
changed.
Finally, if SAMPLE_COVERAGE is enabled, the fragment coverage is ANDed
with another temporary coverage. This temporary coverage is generated in the
same manner as the one described above, but as a function of the value of
SAMPLE_COVERAGE_VALUE. The function need not be identical, but it must have
the same properties of proportionality and invariance. If SAMPLE_COVERAGE_-
INVERT is TRUE, the temporary coverage is inverted (all bit values are inverted)
before it is ANDed with the fragment coverage.
The values of SAMPLE_COVERAGE_VALUE and SAMPLE_COVERAGE_INVERT
are speci?ed by calling
void SampleCoverage(clampf value,boolean invert );
with value set to the desired coverage value, and invert set to TRUE or FALSE.
value is clamped to [0,1] before being stored as SAMPLE_COVERAGE_VALUE.
SAMPLE_COVERAGE_VALUE is queried by calling GetFloatv with pname set to
SAMPLE_COVERAGE_VALUE. SAMPLE_COVERAGE_INVERT is queried by calling
GetBooleanv with pname set toSAMPLE_COVERAGE_INVERT.
4.1.4 Stencil Test
The stencil test conditionally discards a fragment based on the outcome of a com-
parison between the value in the stencil buffer at location (x ;y ) and a reference
w w
value. The test is enabled or disabled with the Enable and Disable commands,
using the symbolic constant STENCIL_TEST. When disabled, the stencil test and
associated modi?cations are not made, and the fragment is always passed.
The stencil test is controlled with
void StencilFunc(enum func,int ref,uint mask );
void StencilFuncSeparate(enum face,enum func,int ref,
uint mask );
void StencilOp(enum sfail,enum dpfail,enum dppass );
void StencilOpSeparate(enum face,enum sfail,enum dpfail,
enum dppass );
There are two sets of stencil-related state, the front stencil state set and the
back stencil state set. Stencil tests and writes use the front set of stencil state
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 171
when processing fragments rasterized from non-polygon primitives (points and
lines) and front-facing polygon primitives while the back set of stencil state is
used when processing fragments rasterized from back-facing polygon primitives.
For the purposes of stencil testing, a primitive is still considered a polygon even if
the polygon is to be rasterized as points or lines due to the current polygon mode.
Whether a polygon is front- or back-facing is determined in the same manner used
for two-sided lighting and face culling (see section 3.6.1).
StencilFuncSeparate and StencilOpSeparate take a face argument which can
beFRONT,BACK, orFRONT_AND_BACK and indicates which set of state is affected.
StencilFunc and StencilOp set front and back stencil state to identical values.
StencilFunc and StencilFuncSeparate take three arguments that control
whether the stencil test passes or fails. ref is an integer reference value that is used
in the unsigned stencil comparison. Stencil comparison operations and queries of
s
ref clamp its value to the range [0; 2   1], where s is the number of bits in the
stencil buffer attached to the draw framebuffer. Thes least signi?cant bits of mask
are bitwise ANDed with both the reference and the stored stencil value, and the
resulting masked values are those that participate in the comparison controlled by
func. func is a symbolic constant that determines the stencil comparison function;
the eight symbolic constants areNEVER,ALWAYS,LESS,LEQUAL,EQUAL,GEQUAL,
GREATER, orNOTEQUAL. Accordingly, the stencil test passes never, always, and if
the masked reference value is less than, less than or equal to, equal to, greater than
or equal to, greater than, or not equal to the masked stored value in the stencil
buffer.
StencilOp and StencilOpSeparate take three arguments that indicate what
happens to the stored stencil value if this or certain subsequent tests fail or pass.
sfail indicates what action is taken if the stencil test fails. The symbolic constants
areKEEP,ZERO,REPLACE,INCR,DECR,INVERT,INCR_WRAP, andDECR_WRAP.
These correspond to keeping the current value, setting to zero, replacing with the
reference value, incrementing with saturation, decrementing with saturation, bit-
wise inverting it, incrementing without saturation, and decrementing without satu-
ration.
For purposes of increment and decrement, the stencil bits are considered as an
unsigned integer. Incrementing or decrementing with saturation clamps the stencil
value at 0 and the maximum representable value. Incrementing or decrementing
without saturation will wrap such that incrementing the maximum representable
value results in 0, and decrementing 0 results in the maximum representable value.
The same symbolic values are given to indicate the stencil action if the depth
buffer test (see section 4.1.5) fails (dpfail), or if it passes (dppass).
If the stencil test fails, the incoming fragment is discarded. The state required
consists of the most recent values passed to StencilFunc or StencilFuncSeparate
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 172
and to StencilOp or StencilOpSeparate, and a bit indicating whether stencil test-
ing is enabled or disabled. In the initial state, stenciling is disabled, the front and
back stencil reference value are both zero, the front and back stencil comparison
functions are bothALWAYS, and the front and back stencil mask are both set to the
s
value 2   1, wheres is greater than or equal to the number of bits in the deepest
stencil buffer supported by the GL implementation. Initially, all three front and
back stencil operations areKEEP.
If there is no stencil buffer, no stencil modi?cation can occur, and it is as if the
stencil tests always pass, regardless of any calls to StencilFunc.
4.1.5 Depth Buffer Test
The depth buffer test discards the incoming fragment if a depth comparison fails.
The comparison is enabled or disabled with the generic Enable and Disable com-
mands using the symbolic constantDEPTH_TEST. When disabled, the depth com-
parison and subsequent possible updates to the depth buffer value are bypassed and
the fragment is passed to the next operation. The stencil value, however, is modi-
?ed as indicated below as if the depth buffer test passed. If enabled, the comparison
takes place and the depth buffer and stencil value may subsequently be modi?ed.
The comparison is speci?ed with
void DepthFunc(enum func );
This command takes a single symbolic constant: one of NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GREATER, GEQUAL, NOTEQUAL. Accordingly, the depth buffer
test passes never, always, if the incoming fragment’s z value is less than, less
w
than or equal to, equal to, greater than, greater than or equal to, or not equal to
the depth value stored at the location given by the incoming fragment’s (x ;y )
w w
coordinates.
If the depth buffer test fails, the incoming fragment is discarded. The stencil
value at the fragment’s (x ;y ) coordinates is updated according to the function
w w
currently in effect for depth buffer test failure. Otherwise, the fragment continues
to the next operation and the value of the depth buffer at the fragment’s (x ;y )
w w
location is set to the fragment’sz value. In this case the stencil value is updated
w
according to the function currently in effect for depth buffer test success.
The necessary state is an eight-valued integer and a single bit indicating
whether depth buffering is enabled or disabled. In the initial state the function
isLESS and the test is disabled.
If there is no depth buffer, it is as if the depth buffer test always passes.
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 173
4.1.6 Occlusion Queries
Occlusion queries use query objects to track the number of fragments or samples
that pass the depth test. An occlusion query can be started and ?nished by calling
BeginQuery and EndQuery, respectively, with a target ofSAMPLES_PASSED.
When an occlusion query is started, the samples-passed count maintained by
the GL is set to zero. When an occlusion query is active, the samples-passed
count is incremented for each fragment that passes the depth test. If the value
ofSAMPLE_BUFFERS is 0, then the samples-passed count is incremented by 1 for
each fragment. If the value of SAMPLE_BUFFERS is 1, then the samples-passed
count is incremented by the number of samples whose coverage bit is set. How-
ever, implementations, at their discretion, may instead increase the samples-passed
count by the value ofSAMPLES if any sample in the fragment is covered.
When an occlusion query ?nishes and all fragments generated by commands
issued prior to EndQuery have been generated, the samples-passed count is written
to the corresponding query object as the query result value, and the query result for
that object is marked as available.
n
If the samples-passed count over?ows (exceeds the value 2   1, wheren is
the number of bits in the samples-passed count), its value becomes unde?ned. It is
recommended, but not required, that implementations handle this over?ow case by
n
saturating at 2   1 and incrementing no further.
The necessary state is a single bit indicating whether an occlusion query is
active, the identi?er of the currently active occlusion query, and a counter keeping
track of the number of samples that have passed.
4.1.7 Blending
Blending combines the incoming source fragment’s R, G, B, and A values with
the destination R, G, B, and A values stored in the framebuffer at the fragment’s
(x ;y ) location.
w w
Source and destination values are combined according to the blend equation,
quadruplets of source and destination weighting factors determined by the blend
functions, and a constant blend color to obtain a new set of R, G, B, and A values,
as described below.
If the color buffer is ?xed-point, the components of the source and destination
values and blend factors are clamped to [0; 1] prior to evaluating the blend equation.
If the color buffer is ?oating-point, no clamping occurs. The resulting four values
are sent to the next operation.
Blending applies only if the color buffer has a ?xed-point or ?oating-point
format. If the color buffer has an integer format, proceed to the next operation.
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 174
Blending is enabled or disabled for an individual draw buffer with the com-
mands
void Enablei(enum target,uint index );
void Disablei(enum target,uint index );
target is the symbolic constantBLEND and index is an integeri specifying the draw
buffer associated with the symbolic constant DRAW_BUFFERi. If the color buffer
associated withDRAW_BUFFERi is one ofFRONT,BACK,LEFT,RIGHT, orFRONT_-
AND_BACK (specifying multiple color buffers), then the state enabled or disabled is
applicable for all of the buffers. Blending can be enabled or disabled for all draw
buffers using Enable or Disable with the symbolic constant BLEND. If blending
is disabled for a particular draw buffer, or if logical operation on color values is
enabled (section 4.1.10), proceed to the next operation.
An INVALID_VALUE error is generated if index is greater than the value of
MAX_DRAW_BUFFERS minus one.
If multiple fragment colors are being written to multiple buffers (see sec-
tion 4.2.1), blending is computed and applied separately for each fragment color
and the corresponding buffer.
Blend Equation
Blending is controlled by the blend equations, de?ned by the commands
void BlendEquation(enum mode );
void BlendEquationSeparate(enum modeRGB,
enum modeAlpha );
BlendEquationSeparate argument modeRGB determines the RGB blend func-
tion while modeAlpha determines the alpha blend equation. BlendEquation ar-
gument mode determines both the RGB and alpha blend equations. modeRGB and
modeAlpha must each be one ofFUNC_ADD,FUNC_SUBTRACT,FUNC_REVERSE_-
SUBTRACT,MIN, orMAX.
Signed or unsigned normalized ?xed-point destination (framebuffer) compo-
nents are represented as described in section 2.1.5. Constant color compo-
nents, ?oating-point destination components, and source (fragment) components
are taken to be ?oating point values. If source components are represented in-
ternally by the GL as ?xed-point values, they are also interpreted according to
section 2.1.5.
Prior to blending, signed and unsigned normalized ?xed-point color compo-
nents undergo an implied conversion to ?oating-point using equations 2.1 and 2.3,
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 175
respectively. This conversion must leave the values 0 and 1 invariant. Blending
computations are treated as if carried out in ?oating-point.
If FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
to the destination buffer is SRGB (see section 6.1.3), the R, G, and B destination
color values (after conversion from ?xed-point to ?oating-point) are considered to
be encoded for the sRGB color space and hence must be linearized prior to their
use in blending. Each R, G, and B component is converted in the same fashion
described for sRGB texture components in section 3.8.15.
If FRAMEBUFFER_SRGB is disabled or the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING is notSRGB, no linearization is performed.
The resulting linearized R, G, and B and unmodi?ed A values are recombined
as the destination color used in blending computations.
Table 4.1 provides the corresponding per-component blend equations for each
mode, whether acting on RGB components for modeRGB or the alpha component
for modeAlpha.
In the table, the s subscript on a color component abbreviation (R, G, B, or
A) refers to the source color component for an incoming fragment, thed subscript
on a color component abbreviation refers to the destination color component at
the corresponding framebuffer location, and thec subscript on a color component
abbreviation refers to the constant blend color component. A color component ab-
breviation without a subscript refers to the new color component resulting from
blending. Additionally,S ,S ,S , andS are the red, green, blue, and alpha com-
r g b a
ponents of the source weighting factors determined by the source blend function,
and D , D , D , and D are the red, green, blue, and alpha components of the
r g b a
destination weighting factors determined by the destination blend function. Blend
functions are described below.
Blend Functions
The weighting factors used by the blend equation are determined by the blend
functions. Blend functions are speci?ed with the commands
void BlendFuncSeparate(enum srcRGB,enum dstRGB,
enum srcAlpha,enum dstAlpha );
void BlendFunc(enum src,enum dst );
BlendFuncSeparate arguments srcRGB and dstRGB determine the source and
destination RGB blend functions, respectively, while srcAlpha and dstAlpha deter-
mine the source and destination alpha blend functions. BlendFunc argument src
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 176
Mode RGB Components Alpha Component
FUNC_ADD R =R S +R D A =A S +A D
s r d r s a d a
G =G S +G D
s g d g
B =B S +B D
s b d b
FUNC_SUBTRACT R =R S  R D A =A S  A D
s r d r s a d a
G =G S  G D
s g d g
B =B S  B D
s b d b
FUNC_REVERSE_SUBTRACT R =R D  R S A =A D  A S
d r s r d a s a
G =G D  G S
g s g
d
B =B D  B S
d b s b
MIN R = min(R ;R ) A = min(A ;A )
s d s d
G = min(G ;G )
s
d
B = min(B ;B )
s d
MAX R = max(R ;R ) A = max(A ;A )
s d s d
G = max(G ;G )
s
d
B = max(B ;B )
s d
Table 4.1: RGB and alpha blend equations.
determines both RGB and alpha source functions, while dst determines both RGB
and alpha destination functions.
The possible source and destination blend functions and their corresponding
computed blend factors are summarized in table 4.2.
Blend Color
The constant colorC to be used in blending is speci?ed with the command
c
void BlendColor(clampf red,clampf green,clampf blue,
clampf alpha );
The constant color can be used in both the source and destination blending
functions
The state required for blending is two integers for the RGB and alpha blend
equations, four integers indicating the source and destination RGB and alpha
blending functions, four ?oating-point values to store the RGBA constant blend
color, and a bit indicating whether blending is enabled or disabled for each of the
MAX_DRAW_BUFFERS draw buffers.
The initial blend equations for RGB and alpha are bothFUNC_ADD. The initial
blending functions are ONE for the source RGB and alpha functions and ZERO
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 177
Function RGB Blend Factors Alpha Blend Factor
(S ;S ;S ) or (D ;D ;D ) S orD
r g r g a a
b b
ZERO (0; 0; 0) 0
ONE (1; 1; 1) 1
SRC_COLOR (R ;G ;B ) A
s s s s
ONE_MINUS_SRC_COLOR (1; 1; 1)  (R ;G ;B ) 1 A
s s s s
DST_COLOR (R ;G ;B ) A
d d d d
ONE_MINUS_DST_COLOR (1; 1; 1)  (R ;G ;B ) 1 A
d d d d
SRC_ALPHA (A ;A ;A ) A
s s s s
ONE_MINUS_SRC_ALPHA (1; 1; 1)  (A ;A ;A ) 1 A
s s s s
DST_ALPHA (A ;A ;A ) A
d d d d
ONE_MINUS_DST_ALPHA (1; 1; 1)  (A ;A ;A ) 1 A
d d d d
CONSTANT_COLOR (R ;G ;B ) A
c c c c
ONE_MINUS_CONSTANT_COLOR (1; 1; 1)  (R ;G ;B ) 1 A
c c c c
CONSTANT_ALPHA (A ;A ;A ) A
c c c c
ONE_MINUS_CONSTANT_ALPHA (1; 1; 1)  (A ;A ;A ) 1 A
c c c c
1 2
SRC_ALPHA_SATURATE (f;f;f) 1
Table 4.2: RGB and ALPHA source and destination blending functions and the
corresponding blend factors. Addition and subtraction of triplets is performed
component-wise.
1
SRC_ALPHA_SATURATE is valid only for source RGB and alpha blending func-
tions.
2
f = min(A ; 1 A ).
s d
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 178
for the destination RGB and alpha functions. The initial constant blend color is
(R; G; B; A) = (0; 0; 0; 0). Initially, blending is disabled for all draw buffers.
The value of the blend enable for draw bufferi can be queried by calling IsEn-
abledi with target BLEND and index i. The value of the blend enable for draw
buffer zero may also be queried by calling IsEnabled with valueBLEND.
Blending occurs once for each color buffer currently enabled for blending and
for writing (section 4.2.1) using each buffer’s color forC . If a color buffer has no
d
A value, thenA is taken to be 1.
d
4.1.8 sRGB Conversion
If FRAMEBUFFER_SRGB is enabled and the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING for the framebuffer attachment corresponding
to the destination buffer is SRGB (see section 6.1.3), the R, G, and B values after
blending are converted into the non-linear sRGB color space by computing
8
>
0:0; c  0
> l
>
>
<
12:92c; 0<c < 0:0031308
l l
c = (4.1)
s
0:41666
>
1:055c   0:055; 0:0031308c < 1
> l
l
>
>
:
1:0; c  1
l
wherec is the R, G, or B element andc is the result (effectively converted into an
l s
sRGB color space).
If FRAMEBUFFER_SRGB is disabled or the value of FRAMEBUFFER_-
ATTACHMENT_COLOR_ENCODING is notSRGB, then
c =c:
s l
The resulting c values for R, G, and B, and the unmodi?ed A form a new
s
RGBA color value. If the color buffer is ?xed-point, each component is clamped to
the range [0; 1] and then converted to a ?xed-point value using equation 2.4. The
resulting four values are sent to the subsequent dithering operation.
4.1.9 Dithering
Dithering selects between two representable color values or indices. A repre-
sentable value is a value that has an exact representation in the color buffer. Dither-
ing selects, for each color component, either the largest positive representable color
value (for that particular color component) that is less than or equal to the incoming
color component value,c, or the smallest negative representable color value that is
greater than or equal toc. The selection may depend on thex andy coordinates
w w
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 179
of the pixel, as well as on the exact value ofc. If one of the two values does not
exist, then the selection defaults to the other value.
Many dithering selection algorithms are possible, but an individual selection
must depend only on the incoming component value and the fragment’sx andy
window coordinates. If dithering is disabled, then each incoming color component
c is replaced with the largest positive representable color value (for that particular
component) that is less than or equal toc, or by the smallest negative representable
value, if no representable value is less than or equal toc.
Dithering is enabled with Enable and disabled with Disable using the symbolic
constant DITHER. The state required is thus a single bit. Initially, dithering is
enabled.
4.1.10 Logical Operation
Finally, a logical operation is applied between the incoming fragment’s color val-
ues and the color values stored at the corresponding location in the framebuffer.
The result replaces the values in the framebuffer at the fragment’s (x ;y ) coordi-
w w
nates. If the selected draw buffers refer to the same framebuffer-attachable image
more than once, then the values stored in that image are unde?ned.
The logical operation on color values is enabled or disabled with Enable or
Disable using the symbolic constantCOLOR_LOGIC_OP. If the logical operation is
enabled for color values, it is as if blending were disabled, regardless of the value
of BLEND. If multiple fragment colors are being written to multiple buffers (see
section 4.2.1), the logical operation is computed and applied separately for each
fragment color and the corresponding buffer.
Logical operation has no effect on a ?oating-point destination color buffer.
However, if logical operation is enabled, blending is still disabled.
The logical operation is selected by
void LogicOp(enum op );
op is a symbolic constant; the possible constants and corresponding operations are
enumerated in table 4.3. In this table,s is the value of the incoming fragment andd
is the value stored in the framebuffer. The numeric values assigned to the symbolic
constants are the same as those assigned to the corresponding symbolic values in
the X window system.
Logical operations are performed independently for each red, green, blue, and
alpha value of each color buffer that is selected for writing. The required state is
an integer indicating the logical operation, and a bit indicating whether the logical
operation is enabled or disabled. The initial state is for the logic operation to be
given byCOPY, and to be disabled.
OpenGL 3.1 - May 28, 20094.1. PER-FRAGMENTOPERATIONS 180
Argument value Operation
CLEAR 0
AND s^d
AND_REVERSE s^:d
COPY s
AND_INVERTED :s^d
NOOP d
XOR s xord
OR s_d
NOR :(s_d)
EQUIV :(s xord)
INVERT :d
OR_REVERSE s_:d
COPY_INVERTED :s
OR_INVERTED :s_d
NAND :(s^d)
SET all 1’s
Table 4.3: Arguments to LogicOp and their corresponding operations.
4.1.11 Additional Multisample Fragment Operations
If the DrawBuffer mode isNONE, no change is made to any multisample or color
buffer. Otherwise, fragment processing is as described below.
If MULTISAMPLE is enabled, and the value of SAMPLE_BUFFERS is one, the
stencil test, depth test, blending, dithering, and logical operations are performed
for each pixel sample, rather than just once for each fragment. Failure of the sten-
cil or depth test results in termination of the processing of that sample, rather than
discarding of the fragment. All operations are performed on the color, depth, and
stencil values stored in the multisample buffer (to be described in a following sec-
tion). The contents of the color buffers are not modi?ed at this point.
Stencil, depth, blending, dithering, and logical operations are performed for
a pixel sample only if that sample’s fragment coverage bit is a value of 1. If the
corresponding coverage bit is 0, no operations are performed for that sample.
If MULTISAMPLE is disabled, and the value of SAMPLE_BUFFERS is one, the
fragment may be treated exactly as described above, with optimization possible
because the fragment coverage must be set to full coverage. Further optimization
is allowed, however. An implementation may choose to identify a centermost sam-
ple, and to perform stencil and depth tests on only that sample. Regardless of the
OpenGL 3.1 - May 28, 20094.2. WHOLEFRAMEBUFFEROPERATIONS 181
outcome of the stencil test, all multisample buffer stencil sample values are set to
the appropriate new stencil value. If the depth test passes, all multisample buffer
depth sample values are set to the depth of the fragment’s centermost sample’s
depth value, and all multisample buffer color sample values are set to the color
value of the incoming fragment. Otherwise, no change is made to any multisample
buffer color or depth value.
After all operations have been completed on the multisample buffer, the sample
values for each color in the multisample buffer are combined to produce a single
color value, and that value is written into the corresponding color buffers selected
by DrawBuffer or DrawBuffers. An implementation may defer the writing of the
color buffers until a later time, but the state of the framebuffer must behave as if
the color buffers were updated as each fragment was processed. The method of
combination is not speci?ed. If the framebuffer contains sRGB values, then it
is recommended that the an average of sample values is computed in a linearized
space, as for blending (see section 4.1.7). Otherwise, a simple average computed
independently for each color component is recommended.
4.2 Whole Framebuffer Operations
The preceding sections described the operations that occur as individual fragments
are sent to the framebuffer. This section describes operations that control or affect
the whole framebuffer.
4.2.1 Selecting a Buffer for Writing
The ?rst such operation is controlling the color buffers into which each of the
fragment color values is written. This is accomplished with either DrawBuffer or
DrawBuffers.
The command
void DrawBuffer(enum buf );
de?nes the set of color buffers to which fragment color zero is written. buf
must be one of the values from tables 4.4 or 4.5. In addition, acceptable val-
ues for buf depend on whether the GL is using the default framebuffer (i.e.,
DRAW_FRAMEBUFFER_BINDING is zero), or a framebuffer object (i.e., DRAW_-
FRAMEBUFFER_BINDING is non-zero). In the initial state, the GL is bound to
the default framebuffer. For more information about framebuffer objects, see sec-
tion 4.4.
OpenGL 3.1 - May 28, 20094.2. WHOLEFRAMEBUFFEROPERATIONS 182
If the GL is bound to the default framebuffer, then buf must be one of the values
listed in table 4.4, which summarizes the constants and the buffers they indicate.
In this case, buf is a symbolic constant specifying zero, one, two, or four buffers
for writing. These constants refer to the four potentially visible buffers (front left,
front right, back left, and back right). Arguments that omit reference to LEFT or
RIGHT refer to both left and right buffers. Arguments that omit reference toFRONT
orBACK refer to both front and back buffers.
If the GL is bound to a framebuffer object, buf must be one of the values listed
in table 4.5, which summarizes the constants and the buffers they indicate. In
this case, buf is a symbolic constant specifying a single color buffer for writing.
Specifying COLOR_ATTACHMENTi enables drawing only to the image attached to
the framebuffer atCOLOR_ATTACHMENTi. EachCOLOR_ATTACHMENTi adheres to
COLOR_ATTACHMENTi = COLOR_ATTACHMENT0 +i. The intial value of DRAW_-
BUFFER for framebuffer objects isCOLOR_ATTACHMENT0.
If the GL is bound to the default framebuffer and DrawBuffer is supplied with
a constant (other thanNONE) that does not indicate any of the color buffers allocated
to the GL context, the errorINVALID_OPERATION results.
If the GL is bound to a framebuffer object and buf is one of the constants
from table 4.4, then the error INVALID_OPERATION results. If buf is COLOR_-
ATTACHMENTm and m is greater than or equal to the value of MAX_COLOR_-
ATTACHMENTS, then the errorINVALID_VALUE results.
If DrawBuffer is supplied with a constant that is legal for neither the default
framebuffer nor a framebuffer object, then the errorINVALID_ENUM results.
DrawBuffer will set the draw buffer for fragment colors other than zero to
NONE.
The command
void DrawBuffers(sizei n,const enum *bufs );
de?nes the draw buffers to which all fragment colors are written. n speci?es the
number of buffers in bufs. bufs is a pointer to an array of symbolic constants
specifying the buffer to which each fragment color is written.
Each buffer listed in bufs must be one of the values from tables 4.5 or 4.6. Oth-
erwise, an INVALID_ENUM error is generated. Further, acceptable values for the
constants in bufs depend on whether the GL is using the default framebuffer (i.e.,
DRAW_FRAMEBUFFER_BINDING is zero), or a framebuffer object (i.e., DRAW_-
FRAMEBUFFER_BINDING is non-zero). For more information about framebuffer
objects, see section 4.4.
If the GL is bound to the default framebuffer, then each of the constants must
be one of the values listed in table 4.6.
OpenGL 3.1 - May 28, 20094.2. WHOLEFRAMEBUFFEROPERATIONS 183
Symbolic Front Front Back Back
Constant Left Right Left Right
NONE
FRONT_LEFT 
FRONT_RIGHT 
BACK_LEFT 
BACK_RIGHT 
FRONT  
BACK  
LEFT  
RIGHT  
FRONT_AND_BACK    
Table 4.4: Arguments to DrawBuffer(s) and ReadBuffer when the context is
bound to a default framebuffer, and the buffers they indicate.
Symbolic Constant Meaning
NONE No buffer
COLOR_ATTACHMENTi (see caption) Output fragment color to image attached
at color attachment pointi
Table 4.5: Arguments to DrawBuffer(s) and ReadBuffer when the context is
bound to a framebuffer object, and the buffers they indicate. i in COLOR_-
ATTACHMENTi may range from zero to the value of MAX_COLOR_ATTACHMENTS
- 1.
Symbolic Front Front Back Back
Constant Left Right Left Right
NONE
FRONT_LEFT 
FRONT_RIGHT 
BACK_LEFT 
BACK_RIGHT 
Table 4.6: Arguments to DrawBuffers when the context is bound to the default
framebuffer, and the buffers they indicate.
OpenGL 3.1 - May 28, 20094.2. WHOLEFRAMEBUFFEROPERATIONS 184
If the GL is bound to an framebuffer object, then each of the constants must be
one of the values listed in table 4.5.
In both cases, the draw buffers being de?ned correspond in order to the re-
spective fragment colors. The draw buffer for fragment colors beyond n is set to
NONE.
The maximum number of draw buffers is implementation-dependent. The
number of draw buffers supported can be queried by calling GetIntegerv with the
symbolic constant MAX_DRAW_BUFFERS. An INVALID_VALUE error is generated
if n is greater thanMAX_DRAW_BUFFERS.
Except forNONE, a buffer may not appear more then once in the array pointed
to by bufs. Specifying a buffer more then once will result in the errorINVALID_-
OPERATION.
If a fragment shader writes to gl_FragColor, DrawBuffers speci?es a set
of draw buffers into which the single fragment color de?ned by gl_FragColor
is written. If a fragment shader writes to gl_FragData, or a user-de?ned vary-
ing out variable, DrawBuffers speci?es a set of draw buffers into which each of
the multiple output colors de?ned by these variables are separately written. If a
fragment shader writes to none of gl_FragColor, gl_FragData, nor any user-
de?ned varying out variables, the values of the fragment colors following shader
execution are unde?ned, and may differ for each fragment color.
For both the default framebuffer and framebuffer objects, the constantsFRONT,
BACK,LEFT,RIGHT, andFRONT_AND_BACK are not valid in the bufs array passed
to DrawBuffers, and will result in the error INVALID_OPERATION. This restric-
tion is because these constants may themselves refer to multiple buffers, as shown
in table 4.4.
If the GL is bound to the default framebuffer and DrawBuffers is supplied with
a constant (other thanNONE) that does not indicate any of the color buffers allocated
to the GL context by the window system, the errorINVALID_OPERATION will be
generated.
If the GL is bound to a framebuffer object and DrawBuffers is supplied with
a constant from table 4.6, or COLOR_ATTACHMENTm where m is greater than
or equal to the value of MAX_COLOR_ATTACHMENTS, then the error INVALID_-
OPERATION results.
Indicating a buffer or buffers using DrawBuffer or DrawBuffers causes sub-
sequent pixel color value writes to affect the indicated buffers.
SpecifyingNONE as the draw buffer for a fragment color will inhibit that frag-
ment color from being written to any buffer.
Monoscopic contexts include only left buffers, while stereoscopic contexts in-
clude both left and right buffers. Likewise, single buffered contexts include only
front buffers, while double buffered contexts include both front and back buffers.
OpenGL 3.1 - May 28, 20094.2. WHOLEFRAMEBUFFEROPERATIONS 185
The type of context is selected at GL initialization.
The state required to handle color buffer selection for each framebuffer is an
integer for each supported fragment color. For the default framebuffer, in the initial
state the draw buffer for fragment color zero is BACK if there is a back buffer;
FRONT if there is no back buffer; andNONE if no default framebuffer is associated
with the context. For framebuffer objects, in the initial state the draw buffer for
fragment color zero is COLOR_ATTACHMENT0. For both the default framebuffer
and framebuffer objects, the initial state of draw buffers for fragment colors other
then zero isNONE.
The value of the draw buffer selected for fragment colori can be queried by
calling GetIntegerv with the symbolic constant DRAW_BUFFERi. DRAW_BUFFER
is equivalent toDRAW_BUFFER0.
4.2.2 Fine Control of Buffer Updates
Writing of bits to each of the logical framebuffers after all per-fragment operations
have been performed may be masked. The commands
void ColorMask(boolean r,boolean g,boolean b,
boolean a );
void ColorMaski(uint buf,boolean r,boolean g,
boolean b,boolean a );
control writes to the active draw buffers.
ColorMask and ColorMaski are used to mask the writing of R, G, B and A
values to the draw buffer or buffers. ColorMaski sets the mask for a particular
draw buffer. The mask for DRAW_BUFFERi is modi?ed by passing i as the pa-
rameter buf. r, g, b, and a indicate whether R, G, B, or A values, respectively,
are written or not (a value of TRUE means that the corresponding value is writ-
ten). The mask speci?ed by r, g, b, and a is applied to the color buffer associated
withDRAW_BUFFERi. IfDRAW_BUFFERi is one ofFRONT,BACK,LEFT,RIGHT, or
FRONT_AND_BACK (specifying multiple color buffers) then the mask is applied to
all of the buffers.
ColorMask sets the mask for all draw buffers to the same values as speci?ed
by r, g, b, and a.
An INVALID_VALUE error is generated if index is greater than the value of
MAX_DRAW_BUFFERS minus one.
In the initial state, all color values are enabled for writing for all draw buffers.
The value of the color writemask for draw bufferi can be queried by calling
GetBooleani v with targetCOLOR_WRITEMASK and indexi. The value of the color
OpenGL 3.1 - May 28, 20094.2. WHOLEFRAMEBUFFEROPERATIONS 186
writemask for draw buffer zero may also be queried by calling GetBooleanv with
valueCOLOR_WRITEMASK.
The depth buffer can be enabled or disabled for writingz values using
w
void DepthMask(boolean mask );
If mask is non-zero, the depth buffer is enabled for writing; otherwise, it is disabled.
In the initial state, the depth buffer is enabled for writing.
The commands
void StencilMask(uint mask );
void StencilMaskSeparate(enum face,uint mask );
control the writing of particular bits into the stencil planes.
The least signi?cants bits of mask, wheres is the number of bits in the stencil
buffer, specify an integer mask. Where a 1 appears in this mask, the corresponding
bit in the stencil buffer is written; where a 0 appears, the bit is not written. The face
parameter of StencilMaskSeparate can be FRONT, BACK, or FRONT_AND_BACK
and indicates whether the front or back stencil mask state is affected. StencilMask
sets both front and back stencil mask state to identical values.
Fragments generated by front-facing primitives use the front mask and frag-
ments generated by back-facing primitives use the back mask (see section 4.1.4).
The clear operation always uses the front stencil write mask when clearing the
stencil buffer.
The state required for the various masking operations is two integers for the
front and back stencil values, and a bit for depth values. A set of four bits is also
required indicating which color components of an RGBA value should be written.
In the initial state, the integer masks are all ones, as are the bits controlling depth
value and RGBA component writing.
Fine Control of Multisample Buffer Updates
When the value ofSAMPLE_BUFFERS is one, ColorMask, DepthMask, and Sten-
cilMask or StencilMaskSeparate control the modi?cation of values in the multi-
sample buffer. The color mask has no effect on modi?cations to the color buffers.
If the color mask is entirely disabled, the color sample values must still be com-
bined (as described above) and the result used to replace the color values of the
buffers enabled by DrawBuffer.
OpenGL 3.1 - May 28, 20094.2. WHOLEFRAMEBUFFEROPERATIONS 187
4.2.3 Clearing the Buffers
The GL provides a means for setting portions of every pixel in a particular buffer
to the same value. The argument to
void Clear(bitfield buf );
is the bitwise OR of a number of values indicating which buffers are to be
cleared. The values areCOLOR_BUFFER_BIT, DEPTH_BUFFER_BIT,STENCIL_-
BUFFER_BIT, and indicating the buffers currently enabled for color writing, the
depth buffer, and the stencil buffer (see below), respectively. The value to which
each buffer is cleared depends on the setting of the clear value for that buffer. If the
mask is not a bitwise OR of the speci?ed values, then the error INVALID_VALUE
is generated.
void ClearColor(clampf r,clampf g,clampf b,
clampf a );
sets the clear value for ?xed- and ?oating-point color buffers. The speci?ed com-
ponents are stored as ?oating-point values.
The command
void ClearDepth(clampd d );
sets the depth value used when clearing the depth buffer. d is clamped to the
range [0; 1]. When clearing a ?xed-point depth buffer,d is converted to ?xed-point
according to the rules for a windowz value given in section 2.12.1. No conversion
is applied when clearing a ?oating-point depth buffer.
The command
void ClearStencil(int s );
takes a single integer argument that is the value to which to clear the stencil buffer.
s is masked to the number of bitplanes in the stencil buffer.
When Clear is called, the only per-fragment operations that are applied (if
enabled) are the pixel ownership test, the scissor test, and dithering. The masking
operations described in section 4.2.2 are also applied. If a buffer is not present,
then a Clear directed at that buffer has no effect. Unsigned normalized ?xed-
point and signed normalized ?xed-point RGBA color buffers are cleared to color
values derived by clamping each component of the clear color to the range [0; 1]
or [ 1; 1] respectively, then converting to ?xed-point using equations 2.4 or 2.6,
respectively. The result of clearing integer color buffers is unde?ned.
OpenGL 3.1 - May 28, 20094.2. WHOLEFRAMEBUFFEROPERATIONS 188
The state required for clearing is a clear value for each of the color buffer,
the depth buffer, and the stencil buffer. Initially, the RGBA color clear value is
(0; 0; 0; 0), the depth buffer clear value is 1.0, and the stencil buffer clear index is
0.
Individual buffers of the currently bound draw framebuffer may be cleared with
the command
void ClearBufferfif uigv(enum buffer,int drawbuffer,
const T *value );
where buffer and drawbuffer identify a buffer to clear, and value speci?es the value
or values to clear it to.
If buffer is COLOR, a particular draw buffer DRAW_BUFFERi is speci?ed by
passing i as the parameter drawbuffer, and value points to a four-element vec-
tor specifying the R, G, B, and A color to clear that draw buffer to. If the draw
buffer is one of FRONT, BACK, LEFT, RIGHT, or FRONT_AND_BACK, identifying
multiple buffers, each selected buffer is cleared to the same value. The Clear-
Bufferfv, ClearBufferiv, and ClearBufferuiv commands should be used to clear
?xed- and ?oating-point, signed integer, and unsigned integer color buffers respec-
tively. Clamping and conversion for ?xed-point color buffers are performed in the
same fashion as ClearColor.
If buffer is DEPTH, drawbuffer must be zero, and value points to the single
depth value to clear the depth buffer to. Clamping and type conversion for ?xed-
point depth buffers are performed in the same fashion as ClearDepth. Only Clear-
Bufferfv should be used to clear depth buffers.
If buffer is STENCIL, drawbuffer must be zero, and value points to the single
stencil value to clear the stencil buffer to. Masking and type conversion are per-
formed in the same fashion as ClearStencil. Only ClearBufferiv should be used
to clear stencil buffers.
The command
void ClearBuffer?(enum buffer,int drawbuffer,
float depth,int stencil );
clears both depth and stencil buffers of the currently bound draw framebuffer.
buffer must be DEPTH_STENCIL and drawbuffer must be zero. depth and sten-
cil are the values to clear the depth and stencil buffers to, respectively. Clamping
and type conversion of depth for ?xed-point depth buffers is performed in the same
fashion as ClearDepth. Masking of stencil for stencil buffers is performed in the
same fashion as ClearStencil. ClearBuffer? is equivalent to clearing the depth
OpenGL 3.1 - May 28, 20094.3. READINGANDCOPYINGPIXELS 189
and stencil buffers separately, but may be faster when a buffer of internal format
DEPTH_STENCIL is being cleared.
The result of ClearBuffer is unde?ned if no conversion between the type of
the speci?ed value and the type of the buffer being cleared is de?ned (for example,
if ClearBufferiv is called for a ?xed- or ?oating-point buffer, or if ClearBufferfv
is called for a signed or unsigned integer buffer). This is not an error.
When ClearBuffer is called, the same per-fragment and masking operations
de?ned for Clear are applied.
Errors
ClearBufferfif uigv generates anINVALID_ENUM error if buffer is notCOLOR,
DEPTH, orSTENCIL. ClearBuffer? generates anINVALID_ENUM error if buffer is
notDEPTH_STENCIL.
ClearBuffer generates anINVALID_VALUE error if buffer isCOLOR and draw-
buffer is less than zero, or greater than the value of MAX_DRAW_BUFFERS minus
one; or if buffer is DEPTH, STENCIL, or DEPTH_STENCIL and drawbuffer is not
zero.
Clearing the Multisample Buffer
The color samples of the multisample buffer are cleared when one or more color
buffers are cleared, as speci?ed by the Clear mask bit COLOR_BUFFER_BIT and
the DrawBuffer mode. If the DrawBuffer mode isNONE, the color samples of the
multisample buffer cannot be cleared using Clear.
If the Clear mask bits DEPTH_BUFFER_BIT or STENCIL_BUFFER_BIT are
set, then the corresponding depth or stencil samples, respectively, are cleared.
The ClearBuffer commands also clear color, depth, or stencil samples of mul-
tisample buffers corresponding to the speci?ed buffer.
4.3 Reading and Copying Pixels
Pixels may be read from the framebuffer using ReadPixels. BlitFramebuffer
can be used to copy a block of pixels from one portion of the framebuffer to another.
4.3.1 Reading Pixels
The method for reading pixels from the framebuffer and placing them in pixel pack
buffer or client memory is diagrammed in ?gure 4.2. We describe the stages of the
pixel reading process in the order in which they occur.
Initially, zero is bound for the PIXEL_PACK_BUFFER, indicating that image
read and query commands such as ReadPixels return pixel results into client mem-
OpenGL 3.1 - May 28, 20094.3. READINGANDCOPYINGPIXELS 190
RGBA pixel data in
Convert to float
Pixel Storage
Clamp to [0,1]
Operations
Pack
byte, short, int, float, or packed
pixel component data stream
Figure 4.2. Operation of ReadPixels. Operations in dashed boxes are not performed
for all data formats. Depth and stencil pixel paths are not shown.
ory pointer parameters. However, if a non-zero buffer object is bound as the current
pixel pack buffer, then the pointer parameter is treated as an offset into the desig-
nated buffer object.
Pixels are read using
void ReadPixels(int x,int y,sizei width,sizei height,
enum format,enum type,void *data );
The arguments after x and y to ReadPixels are described in section 3.7.2. The pixel
storage modes that apply to ReadPixels and other commands that query images
(see section 6.1) are summarized in table 4.7.
ReadPixels generates an INVALID_OPERATION error
if READ_FRAMEBUFFER_BINDING (see section 4.4) is non-zero, the read frame-
buffer is framebuffer complete, and the value of SAMPLE_BUFFERS for the read
framebuffer is greater than zero.
Obtaining Pixels from the Framebuffer
If the format isDEPTH_COMPONENT, then values are obtained from the depth buffer.
If there is no depth buffer, the errorINVALID_OPERATION occurs.
OpenGL 3.1 - May 28, 20094.3. READINGANDCOPYINGPIXELS 191
Parameter Name Type Initial Value Valid Range
PACK_SWAP_BYTES boolean FALSE TRUE/FALSE
PACK_LSB_FIRST boolean FALSE TRUE/FALSE
PACK_ROW_LENGTH integer 0 [0;1)
PACK_SKIP_ROWS integer 0 [0;1)
PACK_SKIP_PIXELS integer 0 [0;1)
PACK_ALIGNMENT integer 4 1,2,4,8
PACK_IMAGE_HEIGHT integer 0 [0;1)
PACK_SKIP_IMAGES integer 0 [0;1)
Table 4.7: PixelStore parameters pertaining to ReadPixels, and GetTexImage.
If there is a multisample buffer (the value of SAMPLE_BUFFERS is one), then
values are obtained from the depth samples in this buffer. It is recommended that
the depth value of the centermost sample be used, though implementations may
choose any function of the depth sample values at each pixel.
If the format is DEPTH_STENCIL, then values are taken from both the depth
buffer and the stencil buffer. If there is no depth buffer or if there is no stencil
buffer, then the error INVALID_OPERATION occurs. If the type parameter is not
UNSIGNED_INT_24_8 orFLOAT_32_UNSIGNED_INT_24_8_REV, then the error
INVALID_ENUM occurs.
If there is a multisample buffer, then values are obtained from the depth and
stencil samples in this buffer. It is recommended that the depth and stencil values of
the centermost sample be used, though implementations may choose any function
of the depth and stencil sample values at each pixel.
If the format isSTENCIL_INDEX, then values are taken from the stencil buffer;
again, if there is no stencil buffer, the errorINVALID_OPERATION occurs.
If there is a multisample buffer, then values are obtained from the stencil sam-
ples in this buffer. It is recommended that the stencil value of the centermost sam-
ple be used, though implementations may choose any function of the stencil sample
values at each pixel.
For all other formats, the read buffer from which values are obtained is one of
the color buffers; the selection of color buffer is controlled with ReadBuffer.
The command
void ReadBuffer(enum src );
takes a symbolic constant as argument. src must be one of the values from ta-
bles 4.4 or 4.5. Otherwise, an INVALID_ENUM error is generated. Further, the
OpenGL 3.1 - May 28, 20094.3. READINGANDCOPYINGPIXELS 192
acceptable values for src depend on whether the GL is using the default frame-
buffer (i.e.,READ_FRAMEBUFFER_BINDING is zero), or a framebuffer object (i.e.,
READ_FRAMEBUFFER_BINDING is non-zero). For more information about frame-
buffer objects, see section 4.4.
If the object bound toREAD_FRAMEBUFFER_BINDING is not framebuffer com-
plete (as de?ned in section 4.4.4), then ReadPixels generates the errorINVALID_-
FRAMEBUFFER_OPERATION. If ReadBuffer is supplied with a constant that is nei-
ther legal for the default framebuffer, nor legal for a framebuffer object, then the
errorINVALID_ENUM results.
WhenREAD_FRAMEBUFFER_BINDING is zero, i.e. the default framebuffer, src
must be one of the values listed in table 4.4, including NONE. FRONT_AND_BACK,
FRONT, and LEFT refer to the front left buffer, BACK refers to the back left buffer,
andRIGHT refers to the front right buffer. The other constants correspond directly
to the buffers that they name. If the requested buffer is missing, then the error
INVALID_OPERATION is generated. For the default framebuffer, the initial setting
for ReadBuffer isFRONT if there is no back buffer andBACK otherwise.
When the GL is using a framebuffer object, src must be one of the values listed
in table 4.5, including NONE. In a manner analogous to how the DRAW_BUFFERs
state is handled, specifyingCOLOR_ATTACHMENTi enables reading from the image
attached to the framebuffer atCOLOR_ATTACHMENTi. For framebuffer objects, the
initial setting for ReadBuffer isCOLOR_ATTACHMENT0.
ReadPixels generates anINVALID_OPERATION error if it attempts to select a
color buffer whileREAD_BUFFER isNONE.
ReadPixels obtains values from the selected buffer from each pixel with lower
left hand corner at (x +i;y +j) for 0  i < width and 0  j < height;
this pixel is said to be the ith pixel in the jth row. If any of these pixels lies
outside of the window allocated to the current GL context, or outside of the image
attached to the currently bound framebuffer object, then the values obtained for
those pixels are unde?ned. WhenREAD_FRAMEBUFFER_BINDING is zero, values
are also unde?ned for individual pixels that are not owned by the current context.
Otherwise, ReadPixels obtains values from the selected buffer, regardless of how
those values were placed there.
If format is one of RED,GREEN,BLUE,ALPHA,RG,RGB,RGBA,BGR, orBGRA,
then red, green, blue, and alpha values are obtained from the selected buffer at each
pixel location. If the framebuffer does not support alpha values then the A that is
obtained is 1.0.
If format is an integer format and the color buffer is not an integer format; if the
color buffer is an integer format and format is not an integer format; or if format
is an integer format and type is FLOAT or HALF_FLOAT, the error INVALID_-
OPERATION occurs.
OpenGL 3.1 - May 28, 20094.3. READINGANDCOPYINGPIXELS 193
When READ_FRAMEBUFFER_BINDING is non-zero, the red, green, blue, and
alpha values are obtained by ?rst reading the internal component values of the
corresponding value in the image attached to the selected logical buffer. Internal
components are converted to an RGBA color by taking each R, G, B, and A com-
ponent present according to the base internal format of the buffer (as shown in
table 3.11). If G, B, or A values are not present in the internal format, they are
taken to be zero, zero, and one respectively.
Conversion of RGBA values
This step applies only if format is notSTENCIL_INDEX,DEPTH_COMPONENT, or
DEPTH_STENCIL. The R, G, B, and A values form a group of elements.
For a signed or unsigned normalized ?xed-point color buffer, each element is
converted to ?oating-point using equations 2.3 or 2.1, respectively. For an integer
or ?oating-point color buffer, the elements are unmodi?ed.
Conversion of Depth values
This step applies only if format is DEPTH_COMPONENT or DEPTH_STENCIL and
the depth buffer uses a ?xed-point representation. An element is taken to be a
?xed-point value in [0; 1] withm bits, wherem is the number of bits in the depth
buffer (see section 2.12.1). No conversion is necessary if the depth buffer uses a
?oating-point representation.
Final Conversion
For an index, if the type is not FLOAT or HALF_FLOAT, ?nal conversion consists
of masking the index with the value given in table 4.8; if the type is FLOAT or
HALF_FLOAT, then the integer index is converted to a GL float or half data
value.
Read color clamping is controlled by calling
void ClampColor(enum target,enum clamp );
with target set to CLAMP_READ_COLOR. If clamp is TRUE, read color clamping is
enabled; if clamp isFALSE, read color clamping is disabled. If clamp isFIXED_-
ONLY, read color clamping is enabled if the selected read color buffer has ?xed-
point components.
For a ?oating-point RGBA color, if type is not one of FLOAT, HALF,
UNSIGNED_INT_5_9_9_9_REV, or UNSIGNED_INT_10F_11F_11F_REV; or if
OpenGL 3.1 - May 28, 20094.3. READINGANDCOPYINGPIXELS 194
type Parameter Index Mask
8
UNSIGNED_BYTE 2   1
7
BYTE 2   1
16
UNSIGNED_SHORT 2   1
15
SHORT 2   1
32
UNSIGNED_INT 2   1
31
INT 2   1
8
UNSIGNED_INT_24_8 2   1
8
FLOAT_32_UNSIGNED_INT_24_8_REV 2   1
Table 4.8: Index masks used by ReadPixels. Floating point data are not masked.
read color clamping is enabled, each component is ?rst clamped to [0; 1]. Then the
appropriate conversion formula from table 4.9 is applied to the component.
In the special case of calling ReadPixels with type ofUNSIGNED_INT_10F_-
11F_11F_REV and format ofRGB, conversion is performed as follows: the returned
data are packed into a series ofuint values. The red, green, and blue components
are converted to unsigned 11-bit ?oating-point, unsigned 11-bit ?oating-point, and
unsigned 10-bit ?oating point as described in sections 2.1.3 and 2.1.4. The result-
ing red 11 bits, green 11 bits, and blue 10 bits are then packed as the 1st, 2nd, and
3rd components of the UNSIGNED_INT_10F_11F_11F_REV format as shown in
table 3.8.
In the special case of calling ReadPixels with type of UNSIGNED_INT_5_-
9_9_9_REV and formatRGB, the conversion is performed as follows: the returned
data are packed into a series of uint values. The red, green, and blue compo-
nents are converted to red , green , blue , and exp integers as described
s s s shared
in section 3.8.1 when internalformat is RGB9_E5. The red , green , blue ,
s s s
and exp are then packed as the 1st, 2nd, 3rd, and 4th components of the
shared
UNSIGNED_INT_5_9_9_9_REV format as shown in table 3.8.
For an integer RGBA color, each component is clamped to the representable
range of type.
Placement in Pixel Pack Buffer or Client Memory
If a pixel pack buffer is bound (as indicated by a non-zero value ofPIXEL_PACK_-
BUFFER_BINDING), data is an offset into the pixel pack buffer and the pixels are
packed into the buffer relative to this offset; otherwise, data is a pointer to a block
client memory and the pixels are packed into the client memory relative to the
OpenGL 3.1 - May 28, 20094.3. READINGANDCOPYINGPIXELS 195
type Parameter GL Data Type Component
Conversion Formula
8
UNSIGNED_BYTE ubyte c = (2   1)f
8
(2 1)f 1
BYTE byte c =
2
16
UNSIGNED_SHORT ushort c = (2   1)f
16
(2  1)f 1
SHORT short c =
2
32
UNSIGNED_INT uint c = (2   1)f
32
(2  1)f 1
INT int c =
2
HALF_FLOAT half c =f
FLOAT float c =f
N
UNSIGNED_BYTE_3_3_2 ubyte c = (2   1)f
N
UNSIGNED_BYTE_2_3_3_REV ubyte c = (2   1)f
N
UNSIGNED_SHORT_5_6_5 ushort c = (2   1)f
N
UNSIGNED_SHORT_5_6_5_REV ushort c = (2   1)f
N
UNSIGNED_SHORT_4_4_4_4 ushort c = (2   1)f
N
UNSIGNED_SHORT_4_4_4_4_REV ushort c = (2   1)f
N
UNSIGNED_SHORT_5_5_5_1 ushort c = (2   1)f
N
UNSIGNED_SHORT_1_5_5_5_REV ushort c = (2   1)f
N
UNSIGNED_INT_8_8_8_8 uint c = (2   1)f
N
UNSIGNED_INT_8_8_8_8_REV uint c = (2   1)f
N
UNSIGNED_INT_10_10_10_2 uint c = (2   1)f
N
UNSIGNED_INT_2_10_10_10_REV uint c = (2   1)f
N
UNSIGNED_INT_24_8 uint c = (2   1)f
UNSIGNED_INT_10F_11F_11F_REV uint Special
UNSIGNED_INT_5_9_9_9_REV uint Special
FLOAT_32_UNSIGNED_INT_24_8_REV float c =f (depth only)
Table 4.9: Reversed component conversions, used when component data are being
returned to client memory. Color, normal, and depth components are converted
from the internal ?oating-point representation (f) to a datum of the speci?ed GL
data type (c) using the speci?ed equation. All arithmetic is done in the internal
?oating point format. These conversions apply to component data returned by GL
query commands and to components of pixel data returned to client memory. The
equations remain the same even if the implemented ranges of the GL data types are
greater than the minimum required ranges. (See table 2.2.) Equations withN as
the exponent are performed for each bit?eld of the packed data type, withN set to
the number of bits in the bit?eld.
OpenGL 3.1 - May 28, 20094.3. READINGANDCOPYINGPIXELS 196
pointer. If a pixel pack buffer object is bound and packing the pixel data according
to the pixel pack storage state would access memory beyond the size of the pixel
pack buffer’s memory size, anINVALID_OPERATION error results. If a pixel pack
buffer object is bound and data is not evenly divisible by the number of basic
machine units needed to store in memory the corresponding GL data type from
table 3.2 for the type parameter, anINVALID_OPERATION error results.
Groups of elements are placed in memory just as they are taken from mem-
ory when transferring pixel rectangles to the GL. That is, theith group of thejth
row (corresponding to theith pixel in thejth row) is placed in memory just where
the ith group of the jth row would be taken from when transferring pixels. See
Unpacking under section 3.7.1. The only difference is that the storage mode pa-
rameters whose names begin with PACK_ are used instead of those whose names
begin with UNPACK_. If the format is RED, GREEN, BLUE, or ALPHA, only the
corresponding single element is written. Likewise if the format is RG, RGB, or
BGR, only the corresponding two or three elements are written. Otherwise all the
elements of each group are written.
4.3.2 Copying Pixels
The command
void BlitFramebuffer(int srcX0,int srcY0,int srcX1,
int srcY1,int dstX0,int dstY0,int dstX1,int dstY1,
bitfield mask,enum ?lter );
transfers a rectangle of pixel values from one region of the read framebuffer to
another in the draw framebuffer.
mask is the bitwise OR of a number of values indicating which buffers are
to be copied. The values are COLOR_BUFFER_BIT, DEPTH_BUFFER_BIT, and
STENCIL_BUFFER_BIT, which are described in section 4.2.3. The pixels corre-
sponding to these buffers are copied from the source rectangle bounded by the lo-
cations (srcX0;srcY 0) and (srcX1;srcY 1) to the destination rectangle bounded
by the locations (dstX0;dstY 0) and (dstX1;dstY 1). The lower bounds of the
rectangle are inclusive, while the upper bounds are exclusive.
When the color buffer is transferred, values are taken from the read buffer of the
read framebuffer and written to each of the draw buffers of the draw framebuffer.
The actual region taken from the read framebuffer is limited to the intersection
of the source buffers being transferred, which may include the color buffer selected
by the read buffer, the depth buffer, and/or the stencil buffer depending on mask.
The actual region written to the draw framebuffer is limited to the intersection of
OpenGL 3.1 - May 28, 20094.3. READINGANDCOPYINGPIXELS 197
the destination buffers being written, which may include multiple draw buffers,
the depth buffer, and/or the stencil buffer depending on mask. Whether or not the
source or destination regions are altered due to these limits, the scaling and offset
applied to pixels being transferred is performed as though no such limits were
present.
If the source and destination rectangle dimensions do not match, the source im-
age is stretched to ?t the destination rectangle. ?lter must beLINEAR orNEAREST,
and speci?es the method of interpolation to be applied if the image is stretched.
LINEAR ?ltering is allowed only for the color buffer; if mask includes DEPTH_-
BUFFER_BIT or STENCIL_BUFFER_BIT, and ?lter is not NEAREST, no copy is
performed and an INVALID_OPERATION error is generated. If the source and
destination dimensions are identical, no ?ltering is applied. If either the source or
destination rectangle speci?es a negative width or height (X1<X0 orY 1<Y 0),
the image is reversed in the corresponding direction. If both the source and des-
tination rectangles specify a negative width or height for the same direction, no
reversal is performed. If a linear ?lter is selected and the rules of LINEAR sam-
pling would require sampling outside the bounds of a source buffer, it is as though
CLAMP_TO_EDGE texture sampling were being performed. If a linear ?lter is se-
lected and sampling would be required outside the bounds of the speci?ed source
region, but within the bounds of a source buffer, the implementation may choose
to clamp while sampling or not.
If the source and destination buffers are identical, and the source and destina-
tion rectangles overlap, the result of the blit operation is unde?ned.
Blit operations bypass the fragment pipeline. The only fragment operations
which affect a blit are the pixel ownership test and the scissor test.
If a buffer is speci?ed in mask and does not exist in both the read and draw
framebuffers, the corresponding bit is silently ignored.
If the color formats of the read and draw buffers do not match, and mask in-
cludes COLOR_BUFFER_BIT, pixel groups are converted to match the destination
format. However, colors are clamped only if all draw color buffers have ?xed-
point components. Format conversion is not supported for all data types, and an
INVALID_OPERATION error is generated under any of the following conditions:
 The read buffer contains ?oating-point values and any draw buffer does not
contain ?oating-point values.
 The read buffer contains non-?oating-point values and any draw buffer con-
tains ?oating-point values.
 The read buffer contains unsigned integer values and any draw buffer does
not contain unsigned integer values.
OpenGL 3.1 - May 28, 20094.3. READINGANDCOPYINGPIXELS 198
 The read buffer contains signed integer values and any draw buffer does not
contain signed integer values.
Calling BlitFramebuffer will result in an INVALID_FRAMEBUFFER_-
OPERATION error if the objects bound to DRAW_FRAMEBUFFER_BINDING and
READ_FRAMEBUFFER_BINDING are not framebuffer complete (section 4.4.4).
Calling BlitFramebuffer will result in anINVALID_OPERATION error if mask
includes DEPTH_BUFFER_BIT or STENCIL_BUFFER_BIT, and the source and
destination depth and stencil buffer formats do not match.
Calling BlitFramebuffer will result in anINVALID_OPERATION error if ?lter
isLINEAR and read buffer contains integer data.
If SAMPLE_BUFFERS for the read framebuffer is greater than zero and
SAMPLE_BUFFERS for the draw framebuffer is zero, the samples corresponding
to each pixel location in the source are converted to a single sample before being
written to the destination.
If SAMPLE_BUFFERS for the read framebuffer is zero and SAMPLE_BUFFERS
for the draw framebuffer is greater than zero, the value of the source sample is
replicated in each of the destination samples.
If SAMPLE_BUFFERS for either the read framebuffer or draw framebuffer is
greater than zero, no copy is performed and an INVALID_OPERATION error is
generated if the dimensions of the source and destination rectangles provided to
BlitFramebuffer are not identical, if the formats of the read and draw framebuffers
are not identical, or if the values ofSAMPLES for the read and draw buffers are not
identical.
IfSAMPLE_BUFFERS for both the read and draw framebuffers are greater than
zero, and the values ofSAMPLES for the read and draw framebuffers are identical,
the samples are copied without modi?cation from the read framebuffer to the draw
framebuffer. Otherwise, no copy is performed and anINVALID_OPERATION error
is generated. Note that the samples in the draw buffer are not guaranteed to be at
the same sample location as the read buffer, so rendering using this newly created
buffer can potentially have geometry cracks or incorrect antialiasing. This may
occur if the sizes of the framebuffers do not match, if the formats differ, or if
the source and destination rectangles are not de?ned with the same (X0;Y 0) and
(X1;Y 1) bounds.
4.3.3 Pixel Draw/Read State
The state required for pixel operations consists of the parameters that are set with
PixelStore, This state has been summarized in tables 3.1, Additional state in-
cludes an integer indicating the current setting of ReadBuffer, and a three-valued
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 199
integer controlling clamping during ?nal conversion. For the default framebuffer,
in the initial state the read buffer isBACK if there is a back buffer;FRONT if there is
no back buffer; and NONE if no default framebuffer is associated with the context.
The initial value of read color clamping isFIXED_ONLY. State set with PixelStore
is GL client state.
4.4 Framebuffer Objects
As described in chapter 1 and section 2.1, the GL renders into (and reads values
from) a framebuffer. GL de?nes two classes of framebuffers: window system-
provided and application-created.
Initially, the GL uses the default framebuffer. The storage, dimensions, allo-
cation, and format of the images attached to this framebuffer are managed entirely
by the window system. Consequently, the state of the default framebuffer, includ-
ing its images, can not be changed by the GL, nor can the default framebuffer be
deleted by the GL.
The routines described in the following sections, however, can be used to cre-
ate, destroy, and modify the state and attachments of framebuffer objects.
Framebuffer objects encapsulate the state of a framebuffer in a similar manner
to the way texture objects encapsulate the state of a texture. In particular, a frame-
buffer object encapsulates state necessary to describe a collection of color, depth,
and stencil logical buffers (other types of buffers are not allowed). For each logical
buffer, a framebuffer-attachable image can be attached to the framebuffer to store
the rendered output for that logical buffer. Examples of framebuffer-attachable im-
ages include texture images and renderbuffer images. Renderbuffers are described
further in section 4.4.2
By allowing the images of a renderbuffer to be attached to a framebuffer, the
GL provides a mechanism to support off-screen rendering. Further, by allowing the
images of a texture to be attached to a framebuffer, the GL provides a mechanism
to support render to texture.
4.4.1 Binding and Managing Framebuffer Objects
The default framebuffer for rendering and readback operations is provided by the
window system. In addition, named framebuffer objects can be created and oper-
ated upon. The namespace for framebuffer objects is the unsigned integers, with
zero reserved by the GL for the default framebuffer.
A framebuffer object is created by binding a name returned by GenFrame-
buffers (see below) to DRAW_FRAMEBUFFER or READ_FRAMEBUFFER. The bind-
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 200
ing is effected by calling
void BindFramebuffer(enum target,uint framebuffer );
with target set to the desired framebuffer target and framebuffer set to the frame-
buffer object name. The resulting framebuffer object is a new state vector, com-
prising all the state values listed in table 6.20, as well as one set of the state values
listed in table 6.21 for each attachment point of the framebuffer, set to the same
initial values. There areMAX_COLOR_ATTACHMENTS color attachment points, plus
one each for the depth and stencil attachment points.
BindFramebuffer may also be used to bind an existing framebuffer object
toDRAW_FRAMEBUFFER and/orREAD_FRAMEBUFFER. If the bind is successful no
change is made to the state of the bound framebuffer object, and any previous
binding to target is broken.
BindFramebuffer fails and an INVALID_OPERATION error is generated if
framebuffer is not zero or a name returned from a previous call to GenFrame-
buffers, or if such a name has since been deleted with DeleteFramebuffers.
If a framebuffer object is bound to DRAW_FRAMEBUFFER or READ_-
FRAMEBUFFER, it becomes the target for rendering or readback operations, respec-
tively, until it is deleted or another framebuffer is bound to the corresponding bind
point. Calling BindFramebuffer with target set to FRAMEBUFFER binds frame-
buffer to both the draw and read targets.
While a framebuffer object is bound, GL operations on the target to which it
is bound affect the images attached to the bound framebuffer object, and queries
of the target to which it is bound return state from the bound object. Queries of
the values speci?ed in tables 6.41 and 6.23 are derived from the framebuffer object
bound toDRAW_FRAMEBUFFER.
The initial state of DRAW_FRAMEBUFFER and READ_FRAMEBUFFER refers to
the default framebuffer. In order that access to the default framebuffer is not lost,
it is treated as a framebuffer object with the name of zero. The default framebuffer
is therefore rendered to and read from while zero is bound to the corresponding
targets. On some implementations, the properties of the default framebuffer can
change over time (e.g., in response to window system events such as attaching the
context to a new window system drawable.)
Framebuffer objects (those with a non-zero name) differ from the default
framebuffer in a few important ways. First and foremost, unlike the default frame-
buffer, framebuffer objects have modi?able attachment points for each logical
buffer in the framebuffer. Framebuffer-attachable images can be attached to and
detached from these attachment points, which are described further in section 4.4.2.
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 201
Also, the size and format of the images attached to framebuffer objectss are con-
trolled entirely within the GL interface, and are not affected by window system
events, such as pixel format selection, window resizes, and display mode changes.
Additionally, when rendering to or reading from an application created-
framebuffer object,
 The pixel ownership test always succeeds. In other words, framebuffer ob-
jects own all of their pixels.
 There are no visible color buffer bitplanes. This means there is no color
buffer corresponding to the back, front, left, or right color bitplanes.
 The only color buffer bitplanes are the ones de?ned by the frame-
buffer attachment points named COLOR_ATTACHMENT0 through COLOR_-
ATTACHMENTn.
 The only depth buffer bitplanes are the ones de?ned by the framebuffer at-
tachment pointDEPTH_ATTACHMENT.
 The only stencil buffer bitplanes are the ones de?ned by the framebuffer
attachment pointSTENCIL_ATTACHMENT.
 If the attachment sizes are not all identical, rendering will be limited to the
largest area that can ?t in all of the attachments (an intersection of rectangles
having a lower left of (0; 0) and an upper right of (width;height) for each
attachment).
 If the attachment sizes are not all identical, the values of pixels outside the
common intersection area after rendering are unde?ned.
Framebuffer objects are deleted by calling
void DeleteFramebuffers(sizei n,uint *framebuffers );
framebuffers contains n names of framebuffer objects to be deleted. After a frame-
buffer object is deleted, it has no attachments, and its name is again unused.
If a framebuffer that is currently bound to one or more of the targets DRAW_-
FRAMEBUFFER or READ_FRAMEBUFFER is deleted, it is as though BindFrame-
buffer had been executed with the corresponding target and framebuffer zero. Un-
used names in framebuffers are silently ignored, as is the value zero.
The command
void GenFramebuffers(sizei n,uint *ids );
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 202
returns n previously unused framebuffer object names in ids. These names are
marked as used, for the purposes of GenFramebuffers only, but they acquire state
and type only when they are ?rst bound, just as if they were unused.
The names bound to the draw and read framebuffer bindings can be queried by
calling GetIntegerv with the symbolic constantsDRAW_FRAMEBUFFER_BINDING
and READ_FRAMEBUFFER_BINDING, respectively. FRAMEBUFFER_BINDING is
equivalent toDRAW_FRAMEBUFFER_BINDING.
4.4.2 Attaching Images to Framebuffer Objects
Framebuffer-attachable images may be attached to, and detached from, framebuffer
objects. In contrast, the image attachments of the default framebuffer may not be
changed by the GL.
A single framebuffer-attachable image may be attached to multiple framebuffer
objects, potentially avoiding some data copies, and possibly decreasing memory
consumption.
For each logical buffer, a framebuffer object stores a set of state which de?nes
the logical buffer’s attachment point. The attachment point state contains enough
information to identify the single image attached to the attachment point, or to
indicate that no image is attached. The per-logical buffer attachment point state is
listed in table 6.21
There are two types of framebuffer-attachable images: the image of a render-
buffer object, and an image of a texture object.
Renderbuffer Objects
A renderbuffer is a data storage object containing a single image of a renderable
internal format. GL provides the methods described below to allocate and delete a
renderbuffer’s image, and to attach a renderbuffer’s image to a framebuffer object.
The name space for renderbuffer objects is the unsigned integers, with zero
reserved for the GL. A renderbuffer object is created by binding a name returned
by GenRenderbuffers (see below) toRENDERBUFFER. The binding is effected by
calling
void BindRenderbuffer(enum target,uint renderbuffer );
with target set to RENDERBUFFER and renderbuffer set to the renderbuffer object
name. If renderbuffer is not zero, then the resulting renderbuffer object is a new
state vector, initialized with a zero-sized memory buffer, and comprising the state
values listed in table 6.23. Any previous binding to target is broken.
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 203
BindRenderbuffer may also be used to bind an existing renderbuffer object.
If the bind is successful, no change is made to the state of the newly bound render-
buffer object, and any previous binding to target is broken.
While a renderbuffer object is bound, GL operations on the target to which it
is bound affect the bound renderbuffer object, and queries of the target to which a
renderbuffer object is bound return state from the bound object.
The name zero is reserved. A renderbuffer object cannot be created with the
name zero. If renderbuffer is zero, then any previous binding to target is broken
and the target binding is restored to the initial state.
In the initial state, the reserved name zero is bound toRENDERBUFFER. There is
no renderbuffer object corresponding to the name zero, so client attempts to modify
or query renderbuffer state for the targetRENDERBUFFER while zero is bound will
generate GL errors, as described in section 6.1.3.
The current RENDERBUFFER binding can be determined by calling GetInte-
gerv with the symbolic constantRENDERBUFFER_BINDING.
BindRenderbuffer fails and an INVALID_OPERATION error is generated if
renderbuffer is not zero or a name returned from a previous call to GenRender-
buffers, or if such a name has since been deleted with DeleteRenderbuffers.
Renderbuffer objects are deleted by calling
void DeleteRenderbuffers(sizei n,const
uint *renderbuffers );
where renderbuffers contains n names of renderbuffer objects to be deleted. After
a renderbuffer object is deleted, it has no contents, and its name is again unused. If
a renderbuffer that is currently bound toRENDERBUFFER is deleted, it is as though
BindRenderbuffer had been executed with the target RENDERBUFFER and name
of zero. Additionally, special care must be taken when deleting a renderbuffer if
the image of the renderbuffer is attached to a framebuffer object (see section 4.4.2).
Unused names in renderbuffers are silently ignored, as is the value zero.
The command
void GenRenderbuffers(sizei n,uint *renderbuffers );
returns n previously unused renderbuffer object names in renderbuffers. These
names are marked as used, for the purposes of GenRenderbuffers only, but they
acquire renderbuffer state only when they are ?rst bound, just as if they were un-
used.
The command
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 204
Sized Base S
Internal Format Internal Format bits
STENCIL_INDEX1 STENCIL_INDEX 1
STENCIL_INDEX4 STENCIL_INDEX 4
STENCIL_INDEX8 STENCIL_INDEX 8
STENCIL_INDEX16 STENCIL_INDEX 16
Table 4.10: Correspondence of sized internal formats to base internal formats for
formats that can be used only with renderbuffers.
void RenderbufferStorageMultisample(enum target,
sizei samples,enum internalformat,sizei width,
sizei height );
establishes the data storage, format, dimensions, and number of samples of a ren-
derbuffer object’s image. target must be RENDERBUFFER. internalformat must
be color-renderable, depth-renderable, or stencil-renderable (as de?ned in sec-
tion 4.4.4). width and height are the dimensions in pixels of the renderbuffer. If
either width or height is greater than MAX_RENDERBUFFER_SIZE, or if samples
is greater than MAX_SAMPLES, then the error INVALID_VALUE is generated. The
errorINVALID_OPERATION may be generated if internalformat is a signed or un-
signed integer format, samples is greater than one, and the implementation does
not support multisampled integer renderbuffers (see “Required Renderbuffer For-
mats” below). If the GL is unable to create a data store of the requested size, the
errorOUT_OF_MEMORY is generated.
Upon success, RenderbufferStorageMultisample deletes any existing data
store for the renderbuffer image and the contents of the data store after call-
ing RenderbufferStorageMultisample are unde?ned. RENDERBUFFER_WIDTH
is set to width, RENDERBUFFER_HEIGHT is set to height, and RENDERBUFFER_-
INTERNAL_FORMAT is set to internalformat.
If samples is zero, then RENDERBUFFER_SAMPLES is set to zero. Otherwise
samples represents a request for a desired minimum number of samples. Since
different implementations may support different sample counts for multisampled
rendering, the actual number of samples allocated for the renderbuffer image is
implementation-dependent. However, the resulting value for RENDERBUFFER_-
SAMPLES is guaranteed to be greater than or equal to samples and no more than the
next larger sample count supported by the implementation.
A GL implementation may vary its allocation of internal component resolution
based on any RenderbufferStorage parameter (except target), but the allocation
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 205
and chosen internal format must not be a function of any other state and cannot be
changed once they are established.
The command
void RenderbufferStorage(enum target,enum internalformat,
sizei width,sizei height );
is equivalent to calling RenderbufferStorageMultisample with samples equal to
zero.
Required Renderbuffer Formats
Implementations are required to support the same internal formats for renderbuffers
as the required formats for textures enumerated in section 3.8.1, with the excep-
tion of the color formats labelled “texture-only”. Requesting one of these internal
formats for a renderbuffer will allocate at least the internal component sizes and
exactly the component types shown for that format in tables 3.12- 3.13.
Implementations must support creation of renderbuffers in these required for-
mats with up to the value ofMAX_SAMPLES multisamples, with the exception that
the signed and unsigned integer formats are required only to support creation of
renderbuffers with one sample.
Attaching Renderbuffer Images to a Framebuffer
A renderbuffer can be attached as one of the logical buffers of the currently bound
framebuffer object by calling
void FramebufferRenderbuffer(enum target,
enum attachment,enum renderbuffertarget,
uint renderbuffer );
target must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. An INVALID_OPERATION
error is generated if the value of the corresponding binding is zero. attachment
should be set to one of the attachment points of the framebuffer listed in table 4.11.
renderbuffertarget must be RENDERBUFFER and renderbuffer should be set to
the name of the renderbuffer object to be attached to the framebuffer. render-
buffer must be either zero or the name of an existing renderbuffer object of type
renderbuffertarget, otherwise anINVALID_OPERATION error is generated. If ren-
derbuffer is zero, then the value of renderbuffertarget is ignored.
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 206
If renderbuffer is not zero and if FramebufferRenderbuffer is successful,
then the renderbuffer named renderbuffer will be used as the logical buffer iden-
ti?ed by attachment of the framebuffer currently bound to target. The value of
FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the speci?ed attachment point is
set toRENDERBUFFER and the value ofFRAMEBUFFER_ATTACHMENT_OBJECT_-
NAME is set to renderbuffer. All other state values of the attachment point speci?ed
by attachment are set to their default values listed in table 6.21. No change is made
to the state of the renderbuffer object and any previous attachment to the attach-
ment logical buffer of the framebuffer object bound to framebuffer target is broken.
If the attachment is not successful, then no change is made to the state of either the
renderbuffer object or the framebuffer object.
Calling FramebufferRenderbuffer with the renderbuffer name zero will de-
tach the image, if any, identi?ed by attachment, in the framebuffer currently bound
to target. All state values of the attachment point speci?ed by attachment in the
object bound to target are set to their default values listed in table 6.21.
Setting attachment to the value DEPTH_STENCIL_ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to be
set to renderbuffer, which should have base internal formatDEPTH_STENCIL.
If a renderbuffer object is deleted while its image is attached to one or more
attachment points in the currently bound framebuffer, then it is as if Framebuf-
ferRenderbuffer had been called, with a renderbuffer of 0, for each attachment
point to which this image was attached in the currently bound framebuffer. In
other words, this renderbuffer image is ?rst detached from all attachment points in
the currently bound framebuffer. Note that the renderbuffer image is speci?cally
not detached from any non-bound framebuffers. Detaching the image from any
non-bound framebuffers is the responsibility of the application.
Name of attachment
COLOR_ATTACHMENTi (see caption)
DEPTH_ATTACHMENT
STENCIL_ATTACHMENT
DEPTH_STENCIL_ATTACHMENT
Table 4.11: Framebuffer attachment points. i inCOLOR_ATTACHMENTi may range
from zero to the value ofMAX_COLOR_ATTACHMENTS - 1.
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 207
Attaching Texture Images to a Framebuffer
GL supports copying the rendered contents of the framebuffer into the images of
a texture object through the use of the routines CopyTexImage* and CopyTex-
SubImage*. Additionally, GL supports rendering directly into the images of a
texture object.
To render directly into a texture image, a speci?ed image from a texture object
can be attached as one of the logical buffers of the currently bound framebuffer ob-
ject by calling one of the following routines, depending on the type of the texture:
void FramebufferTexture1D(enum target,enum attachment,
enum textarget,uint texture,int level );
void FramebufferTexture2D(enum target,enum attachment,
enum textarget,uint texture,int level );
void FramebufferTexture3D(enum target,enum attachment,
enum textarget,uint texture,int level,int layer );
In all three routines, target must be DRAW_FRAMEBUFFER, READ_-
FRAMEBUFFER, or FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_-
FRAMEBUFFER. An INVALID_OPERATION error is generated if the value of the
corresponding binding is zero. attachment must be one of the attachment points of
the framebuffer listed in table 4.11.
If texture is zero, the image identi?ed by attachment, if any, will be detached
from the framebuffer currently bound to target. textarget, level, and layer are ig-
nored. All state values of the attachment point speci?ed by attachment are set to
their default values listed in table 6.21.
If texture is not zero, then texture must either name an existing texture
object with an target of textarget, or texture must name an existing cube map
texture and textarget must be one of TEXTURE_CUBE_MAP_POSITIVE_X,
TEXTURE_CUBE_MAP_POSITIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z,
TEXTURE_CUBE_MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_NEGATIVE_Y, or
TEXTURE_CUBE_MAP_NEGATIVE_Z. Otherwise, an INVALID_OPERATION error
is generated.
level speci?es the mipmap level of the texture image to be attached to the
framebuffer.
If textarget is TEXTURE_RECTANGLE, then level must be zero. If textar-
get is TEXTURE_3D, then level must be greater than or equal to zero and less
than or equal to log of the value of MAX_3D_TEXTURE_SIZE. If textarget is
2
one ofTEXTURE_CUBE_MAP_POSITIVE_X,TEXTURE_CUBE_MAP_POSITIVE_-
Y, TEXTURE_CUBE_MAP_POSITIVE_Z, TEXTURE_CUBE_MAP_NEGATIVE_-
X, TEXTURE_CUBE_MAP_NEGATIVE_Y, or TEXTURE_CUBE_MAP_NEGATIVE_Z,
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 208
then level must be greater than or equal to zero and less than or equal tolog of
2
the value of MAX_CUBE_MAP_TEXTURE_SIZE. For all other values of textarget,
level must be greater than or equal to zero and no larger thanlog of the value of
2
MAX_TEXTURE_SIZE. Otherwise, anINVALID_VALUE error is generated.
layer speci?es the layer of a 2-dimensional image within a 3-dimensional tex-
ture. An INVALID_VALUE error is generated if layer is larger than the value of
MAX_3D_TEXTURE_SIZE-1.
For FramebufferTexture1D, if texture is not zero, then textarget must be
TEXTURE_1D.
For FramebufferTexture2D, if texture is not zero, then textarget must be one
of TEXTURE_2D, TEXTURE_RECTANGLE, TEXTURE_CUBE_MAP_POSITIVE_X,
TEXTURE_CUBE_MAP_POSITIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_-
Z, TEXTURE_CUBE_MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_NEGATIVE_Y, or
TEXTURE_CUBE_MAP_NEGATIVE_Z.
For FramebufferTexture3D, if texture is not zero, then textarget must be
TEXTURE_3D.
If texture is not zero, and if FramebufferTexture* is successful, then the
speci?ed texture image will be used as the logical buffer identi?ed by attach-
ment of the framebuffer currently bound to target. The value ofFRAMEBUFFER_-
ATTACHMENT_OBJECT_TYPE for the speci?ed attachment point is set toTEXTURE
and the value of FRAMEBUFFER_ATTACHMENT_OBJECT_NAME is set to texture.
Additionally, the value ofFRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL for the
named attachment point is set to level. If texture is a cube map texture, then
the value of FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE for the
named attachment point is set to textarget. If texture is a 3D texture, then the
value of FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER for the named attach-
ment point is set to layer. All other state values of the attachment point speci?ed
by attachment are set to their default values listed in table 6.21. No change is made
to the state of the texture object, and any previous attachment to the attachment
logical buffer of the framebuffer object bound to framebuffer target is broken. If
the attachment is not successful, then no change is made to the state of either the
texture object or the framebuffer object.
Setting attachment to the value DEPTH_STENCIL_ATTACHMENT is a special
case causing both the depth and stencil attachments of the framebuffer object to
be set to texture. texture must have base internal format DEPTH_STENCIL, or the
depth and stencil framebuffer attachments will be incomplete (see section 4.4.4).
The command
void FramebufferTextureLayer(enum target,
enum attachment,uint texture,int level,int layer );
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 209
operates identically to FramebufferTexture3D, except that it attaches a single
layer of a three-dimensional texture or a one- or two-dimensional array texture.
layer is an integer indicating the layer number, and is treated identically to the
layer parameter in FramebufferTexture3D. The errorINVALID_VALUE is gener-
ated if texture is non-zero and layer is negative. The errorINVALID_OPERATION
is generated if texture is non-zero and is not the name of a three dimensional tex-
ture or one- or two-dimensional array texture. Unlike FramebufferTexture3D, no
textarget parameter is accepted.
If texture is non-zero and the command does not result in an error, the frame-
buffer attachment state corresponding to attachment is updated as in the other
FramebufferTexture commands, except that FRAMEBUFFER_ATTACHMENT_-
TEXTURE_LAYER is set to layer.
If a texture object is deleted while its image is attached to one or more attach-
ment points in the currently bound framebuffer, then it is as if FramebufferTex-
ture* had been called, with a texture of zero, for each attachment point to which
this image was attached in the currently bound framebuffer. In other words, this
texture image is ?rst detached from all attachment points in the currently bound
framebuffer. Note that the texture image is speci?cally not detached from any
other framebuffer objects. Detaching the texture image from any other framebuffer
objects is the responsibility of the application.
4.4.3 Feedback Loops Between Textures and the Framebuffer
A feedback loop may exist when a texture object is used as both the source and
destination of a GL operation. When a feedback loop exists, unde?ned behavior
results. This section describes rendering feedback loops (see section 3.8.8) and
texture copying feedback loops (see section 3.8.2) in more detail.
Rendering Feedback Loops
The mechanisms for attaching textures to a framebuffer object do not prevent a
one- or two-dimensional texture level, a face of a cube map texture level, or a
layer of a two-dimensional array or three-dimensional texture from being attached
to the draw framebuffer while the same texture is bound to a texture unit. While
this conditions holds, texturing operations accessing that image will produce unde-
?ned results, as described at the end of section 3.8.8. Conditions resulting in such
unde?ned behavior are de?ned in more detail below. Such unde?ned texturing
operations are likely to leave the ?nal results of fragment processing operations
unde?ned, and should be avoided.
Special precautions need to be taken to avoid attaching a texture image to the
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 210
currently bound framebuffer while the texture object is currently bound and en-
abled for texturing. Doing so could lead to the creation of a rendering feedback
loop between the writing of pixels by GL rendering operations and the simulta-
neous reading of those same pixels when used as texels in the currently bound
texture. In this scenario, the framebuffer will be considered framebuffer complete
(see section 4.4.4), but the values of fragments rendered while in this state will be
unde?ned. The values of texture samples may be unde?ned as well, as described
under “Rendering Feedback Loops” in section 3.8.8
Speci?cally, the values of rendered fragments are unde?ned if all of the fol-
lowing conditions are true:
 an image from texture object T is attached to the currently bound draw
framebuffer at attachment point A
 the texture object T is currently bound to a texture unit U, and
 the current programmable vertex and/or fragment processing state makes it
possible (see below) to sample from the texture object T bound to texture
unit U
while either of the following conditions are true:
 the value of TEXTURE_MIN_FILTER for texture object T is NEAREST or
LINEAR, and the value of FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL
for attachment point A is equal to the value of TEXTURE_BASE_LEVEL for
the texture object T
 the value of TEXTURE_MIN_FILTER for texture object T is one
of NEAREST_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_-
MIPMAP_NEAREST, or LINEAR_MIPMAP_LINEAR, and the value of
FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL for attachment point A is
within the the range speci?ed by the current values of TEXTURE_BASE_-
LEVEL toq, inclusive, for the texture object T. (q is de?ned in the Mipmap-
ping discussion of section 3.8.8).
For the purpose of this discussion, it is possible to sample from the texture
object T bound to texture unit U if the active fragment or vertex shader contains
any instructions that might sample from the texture object T bound to U, even if
those instructions might only be executed conditionally.
Note that if TEXTURE_BASE_LEVEL and TEXTURE_MAX_LEVEL exclude any
levels containing image(s) attached to the currently bound framebuffer, then the
above conditions will not be met (i.e., the above rule will not cause the values of
rendered fragments to be unde?ned.)
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 211
Texture Copying Feedback Loops
Similarly to rendering feedback loops, it is possible for a texture image to be
attached to the read framebuffer while the same texture image is the destination
of a CopyTexImage* operation, as described under “Texture Copying Feedback
Loops” in section 3.8.2. While this condition holds, a texture copying feedback
loop between the writing of texels by the copying operation and the reading of
those same texels when used as pixels in the read framebuffer may exist. In this
scenario, the values of texels written by the copying operation will be unde?ned
(in the same fashion that overlapping copies via BlitFramebuffer are unde?ned).
Speci?cally, the values of copied texels are unde?ned if all of the following
conditions are true:
 an image from texture object T is attached to the currently bound read frame-
buffer at attachment point A
 the selected read buffer is attachment point A
 T is bound to the texture target of a CopyTexImage* operation
 the level argument of the copying operation selects the same image that is
attached to A
4.4.4 Framebuffer Completeness
A framebuffer must be framebuffer complete to effectively be used as the draw or
read framebuffer of the GL.
The default framebuffer is always complete if it exists; however, if no default
framebuffer exists (no window system-provided drawable is associated with the
GL context), it is deemed to be incomplete.
A framebuffer object is said to be framebuffer complete if all of its attached
images, and all framebuffer parameters required to utilize the framebuffer for ren-
dering and reading, are consistently de?ned and meet the requirements de?ned
below. The rules of framebuffer completeness are dependent on the properties of
the attached images, and on certain implementation-dependent restrictions.
The internal formats of the attached images can affect the completeness of
the framebuffer, so it is useful to ?rst de?ne the relationship between the internal
format of an image and the attachment points to which it can be attached.
 The following base internal formats from table 3.11 are color-renderable:
RED, RG, RGB, and RGBA. The sized internal formats from table 3.12 that
have a color-renderable base internal format are also color-renderable. No
other formats, including compressed internal formats, are color-renderable.
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 212
 An internal format is depth-renderable if it is DEPTH_COMPONENT or one
of the formats from table 3.13 whose base internal format is DEPTH_-
COMPONENT orDEPTH_STENCIL. No other formats are depth-renderable.
 An internal format is stencil-renderable if it is STENCIL_INDEX or
DEPTH_STENCIL, if it is one of the STENCIL_INDEX formats from ta-
ble 4.10, or if it is one of the formats from table 3.13 whose base internal
format isDEPTH_STENCIL. No other formats are stencil-renderable.
Framebuffer Attachment Completeness
If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for the framebuffer
attachment point attachment is not NONE, then it is said that a framebuffer-
attachable image, named image, is attached to the framebuffer at the attachment
point. image is identi?ed by the state in attachment as described in section 4.4.2.
The framebuffer attachment point attachment is said to be framebuffer attach-
ment complete if the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE for
attachment isNONE (i.e., no image is attached), or if all of the following conditions
are true:
 image is a component of an existing object with the name speci?ed by
FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, and of the type speci?ed by
FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE.
 The width and height of image are non-zero.
 If FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is TEXTURE and
FRAMEBUFFER_ATTACHMENT_OBJECT_NAME names a three-dimensional
texture, then FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER must be
smaller than the depth of the texture.
 If FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is TEXTURE and
FRAMEBUFFER_ATTACHMENT_OBJECT_NAME names a one- or two-
dimensional array texture, then FRAMEBUFFER_ATTACHMENT_TEXTURE_-
LAYER must be smaller than the number of layers in the texture.
 If attachment is COLOR_ATTACHMENTi, then image must have a color-
renderable internal format.
 If attachment is DEPTH_ATTACHMENT, then image must have a depth-
renderable internal format.
 If attachment is STENCIL_ATTACHMENT, then image must have a stencil-
renderable internal format.
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 213
Whole Framebuffer Completeness
Each rule below is followed by an error token enclosed inf bracketsg. The mean-
ing of these errors is explained below and under “Effects of Framebuffer Com-
pleteness on Framebuffer Operations” later in section 4.4.4.
The framebuffer object target is said to be framebuffer complete if all the fol-
lowing conditions are true:
 target is the default framebuffer, and the default framebuffer exists.
fFRAMEBUFFER_UNDEFINEDg
 All framebuffer attachment points are framebuffer attachment complete.
fFRAMEBUFFER_INCOMPLETE_ATTACHMENTg
 There is at least one image attached to the framebuffer.
fFRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENTg
 The value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE must not be
NONE for any color attachment point(s) named byDRAW_BUFFERi.
fFRAMEBUFFER_INCOMPLETE_DRAW_BUFFERg
 If READ_BUFFER is not NONE, then the value of FRAMEBUFFER_-
ATTACHMENT_OBJECT_TYPE must not be NONE for the color attachment
point named byREAD_BUFFER.
fFRAMEBUFFER_INCOMPLETE_READ_BUFFERg
 The combination of internal formats of the attached images does not violate
an implementation-dependent set of restrictions.
fFRAMEBUFFER_UNSUPPORTEDg
 The value ofRENDERBUFFER_SAMPLES is the same for all attached render-
buffers; and, if the attached images are a mix of renderbuffers and textures,
the value ofRENDERBUFFER_SAMPLES is zero for all attached renderbuffers.
fFRAMEBUFFER_INCOMPLETE_MULTISAMPLEg
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 214
The token in brackets after each clause of the framebuffer completeness rules
speci?es the return value of CheckFramebufferStatus (see below) that is gen-
erated when that clause is violated. If more than one clause is violated, it is
implementation-dependent which value will be returned by CheckFramebuffer-
Status.
Performing any of the following actions may change whether the framebuffer
is considered complete or incomplete:
 Binding to a different framebuffer with BindFramebuffer.
 Attaching an image to the framebuffer with FramebufferTexture* or
FramebufferRenderbuffer.
 Detaching an image from the framebuffer with FramebufferTexture* or
FramebufferRenderbuffer.
 Changing the internal format of a texture image that is attached to the frame-
buffer by calling CopyTexImage* or CompressedTexImage*.
 Changing the internal format of a renderbuffer that is attached to the frame-
buffer by calling RenderbufferStorage.
 Deleting, with DeleteTextures or DeleteRenderbuffers, an object contain-
ing an image that is attached to a framebuffer object that is bound to the
framebuffer.
 Changing the read buffer or one of the draw buffers.
 Associating a different window system-provided drawable, or no drawable,
with the default framebuffer using a window system binding API such as
those described in section 1.6.2.
Although the GL de?nes a wide variety of internal formats for framebuffer-
attachable images, such as texture images and renderbuffer images, some imple-
mentations may not support rendering to particular combinations of internal for-
mats. If the combination of formats of the images attached to a framebuffer object
are not supported by the implementation, then the framebuffer is not complete un-
der the clause labeledFRAMEBUFFER_UNSUPPORTED.
Implementations are required to support certain combinations of framebuffer
internal formats as described under “Required Framebuffer Formats” in sec-
tion 4.4.4.
Because of the implementation-dependent clause of the framebuffer complete-
ness test in particular, and because framebuffer completeness can change when the
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 215
set of attached images is modi?ed, it is strongly advised, though not required, that
an application check to see if the framebuffer is complete prior to rendering. The
status of the framebuffer object currently bound to target can be queried by calling
enum CheckFramebufferStatus(enum target );
target must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or
FRAMEBUFFER. FRAMEBUFFER is equivalent to DRAW_FRAMEBUFFER. If
CheckFramebufferStatus generates an error, zero is returned.
Otherwise, a value is returned that identi?es whether or not the framebuffer
bound to target is complete, and if not complete the value identi?es one of the
rules of framebuffer completeness that is violated. If the framebuffer is complete,
thenFRAMEBUFFER_COMPLETE is returned.
The values of SAMPLE_BUFFERS and SAMPLES are derived from the at-
tachments of the currently bound framebuffer object. If the current DRAW_-
FRAMEBUFFER_BINDING is not framebuffer complete, then both SAMPLE_-
BUFFERS and SAMPLES are unde?ned. Otherwise, SAMPLES is equal to the value
of RENDERBUFFER_SAMPLES for the attached images (which all must have the
same value for RENDERBUFFER_SAMPLES). Further, SAMPLE_BUFFERS is one if
SAMPLES is non-zero. Otherwise,SAMPLE_BUFFERS is zero.
Required Framebuffer Formats
Implementations must support framebuffer objects with up to MAX_COLOR_-
ATTACHMENTS color attachments, a depth attachment, and a stencil attachment.
Each color attachment may be in any of the required color formats for textures
and renderbuffers described in sections 3.8.1 and 4.4.2. The depth attachment may
be in any of the required depth or combined depth+stencil formats described in
those sections, and the stencil attachment may be in any of the required combined
depth+stencil formats.
There must be at least one default framebuffer format allowing creation of a
default framebuffer supporting front-buffered rendering.
Effects of Framebuffer Completeness on Framebuffer Operations
Attempting to render to or read from a framebuffer which is not framebuffer com-
plete will generate an INVALID_FRAMEBUFFER_OPERATION error. This means
that rendering commands such as DrawArrays or one of the other drawing com-
mands de?ned in section 2.8.2, as well as commands that read the framebuffer
such as ReadPixels, CopyTexImage, and CopyTexSubImage, will generate the
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 216
errorINVALID_FRAMEBUFFER_OPERATION if called while the framebuffer is not
framebuffer complete.
4.4.5 Effects of Framebuffer State on Framebuffer Dependent Values
The values of the state variables listed in table 6.41 may change when a change
is made to DRAW_FRAMEBUFFER_BINDING, to the state of the currently bound
framebuffer object, or to an image attached to the currently bound framebuffer
object.
WhenDRAW_FRAMEBUFFER_BINDING is zero, the values of the state variables
listed in table 6.41 are implementation de?ned.
When DRAW_FRAMEBUFFER_BINDING is non-zero, if the currently bound
framebuffer object is not framebuffer complete, then the values of the state vari-
ables listed in table 6.41 are unde?ned.
When DRAW_FRAMEBUFFER_BINDING is non-zero and the currently bound
framebuffer object is framebuffer complete, then the values of the state variables
listed in table 6.41 are completely determined byDRAW_FRAMEBUFFER_BINDING,
the state of the currently bound framebuffer object, and the state of the images at-
tached to the currently bound framebuffer object. The actual sizes of the color,
depth, or stencil bit planes can be obtained by querying an attachment point us-
ing GetFramebufferAttachmentParameteriv, or querying the object attached to
that point. If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE at a par-
ticular attachment point is RENDERBUFFER, the sizes may be determined by call-
ing GetRenderbufferParameteriv as described in section 6.1.3. If the value of
FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE at a particular attachment point is
TEXTURE, the sizes may be determined by calling GetTexParameter, as described
in section 6.1.3.
4.4.6 Mapping between Pixel and Element in Attached Image
WhenDRAW_FRAMEBUFFER_BINDING is non-zero, an operation that writes to the
framebuffer modi?es the image attached to the selected logical buffer, and an oper-
ation that reads from the framebuffer reads from the image attached to the selected
logical buffer.
If the attached image is a renderbuffer image, then the window coordinates
(x ;y ) corresponds to the value in the renderbuffer image at the same coordi-
w w
nates.
If the attached image is a texture image, then the window coordinates (x ;y )
w w
correspond to the texel (i;j;k) from ?gure 3.6 as follows:
i = (x  b)
w
OpenGL 3.1 - May 28, 20094.4. FRAMEBUFFEROBJECTS 217
j = (y  b)
w
k = (layer b)
where b is the texture image’s border width and layer is the value of
FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER for the selected logical buffer.
For a two-dimensional texture, k andlayer are irrelevant; for a one-dimensional
texture,j,k, andlayer are irrelevant.
(x ;y ) corresponds to a border texel ifx ,y , orlayer is less than the border
w w w w
width, or ifx ,y , orlayer is greater than or equal to the border width plus the
w w
width, height, or depth, respectively, of the texture image.
Conversion to Framebuffer-Attachable Image Components
When an enabled color value is written to the framebuffer while the draw frame-
buffer binding is non-zero, for each draw buffer the R, G, B, and A values are
converted to internal components as described in table 3.11, according to the ta-
ble row corresponding to the internal format of the framebuffer-attachable image
attached to the selected logical buffer, and the resulting internal components are
written to the image attached to logical buffer. The masking operations described
in section 4.2.2 are also effective.
Conversion to RGBA Values
When a color value is read or is used as the source of a logical operation or blending
while the read framebuffer binding is non-zero, the components of the framebuffer-
attachable image that is attached to the logical buffer selected by READ_BUFFER
are ?rst converted to R, G, B, and A values according to table 3.20 and the internal
format of the attached image.
OpenGL 3.1 - May 28, 2009Chapter 5
Special Functions
This chapter describes additional GL functionality that does not ?t easily into any
of the preceding chapters. This functionality consists of ?ushing and ?nishing
(used to synchronize the GL command stream), and hints.
5.1 Flush and Finish
The command
void Flush(void );
indicates that all commands that have previously been sent to the GL must complete
in ?nite time.
The command
void Finish(void );
forces all previous GL commands to complete. Finish does not return until all
effects from previously issued commands on GL client and server state and the
framebuffer are fully realized.
5.2 Hints
Certain aspects of GL behavior, when there is room for variation, may be controlled
with hints. A hint is speci?ed using
void Hint(enum target,enum hint );
2185.2. HINTS 219
Target Hint description
LINE_SMOOTH_HINT Line sampling quality
POLYGON_SMOOTH_HINT Polygon sampling quality
TEXTURE_COMPRESSION_HINT Quality and performance of
texture image compression
FRAGMENT_SHADER_DERIVATIVE_HINT Derivative accuracy for fragment
processing built-in functions
dFdx,dFdy andfwidth
Table 5.1: Hint targets and descriptions.
target is a symbolic constant indicating the behavior to be controlled, and hint is a
symbolic constant indicating what type of behavior is desired. The possible targets
are described in table 5.1; for each target, hint must be one ofFASTEST, indicating
that the most ef?cient option should be chosen;NICEST, indicating that the highest
quality option should be chosen; and DONT_CARE, indicating no preference in the
matter.
For the texture compression hint, a hint ofFASTEST indicates that texture im-
ages should be compressed as quickly as possible, while NICEST indicates that
the texture images be compressed with as little image degradation as possible.
FASTEST should be used for one-time texture compression, and NICEST should
be used if the compression results are to be retrieved by GetCompressedTexIm-
age (section 6.1.4) for reuse.
The interpretation of hints is implementation-dependent. An implementation
may ignore them entirely.
The initial value of all hints isDONT_CARE.
OpenGL 3.1 - May 28, 2009Chapter 6
State and State Requests
The state required to describe the GL machine is enumerated in section 6.2. Most
state is set through the calls described in previous chapters, and can be queried
using the calls described in section 6.1.
6.1 Querying GL State
6.1.1 Simple Queries
Much of the GL state is completely identi?ed by symbolic constants. The values
of these state variables can be obtained using a set of Get commands. There are
four commands for obtaining simple state variables:
void GetBooleanv(enum value,boolean *data );
void GetIntegerv(enum value,int *data );
void GetFloatv(enum value,float *data );
void GetDoublev(enum value,double *data );
The commands obtain boolean, integer, ?oating-point, or double-precision state
variables. value is a symbolic constant indicating the state variable to return. data
is a pointer to a scalar or array of the indicated type in which to place the returned
data.
Indexed simple state variables are queried with the commands
void GetBooleani v(enum target,uint index,
boolean *data );
void GetIntegeri v(enum target,uint index,int *data );
2206.1. QUERYINGGLSTATE 221
target is the name of the indexed state and index is the index of the particular
element being queried. data is a pointer to a scalar or array of the indicated type in
which to place the returned data. An INVALID_VALUE error is generated if index
is outside the valid range for the indexed state target.
Finally,
boolean IsEnabled(enum value );
can be used to determine if value is currently enabled (as with Enable) or disabled,
and
boolean IsEnabledi(enum target,uint index );
can be used to determine if the indexed state corresponding to target and index is
enabled or disabled. AnINVALID_VALUE error is generated if index is outside the
valid range for the indexed state target.
6.1.2 Data Conversions
If a Get command is issued that returns value types different from the type of the
value being obtained, a type conversion is performed. If GetBooleanv is called, a
?oating-point or integer value converts toFALSE if and only if it is zero (otherwise
it converts toTRUE). If GetIntegerv (or any of the Get commands below) is called,
a boolean value of TRUE or FALSE is interpreted as 1 or 0, respectively, and a
?oating-point value is rounded to the nearest integer, unless the value is an RGBA
color component, a DepthRange value, or a depth buffer clear value. In these
cases, the Get command converts the ?oating-point value to an integer according
to theINT entry of table 4.9; a value not in [ 1; 1] converts to an unde?ned value.
If GetFloatv is called, a boolean value ofTRUE orFALSE is interpreted as 1:0 or
0:0, respectively, an integer is coerced to ?oating-point, and a double-precision
?oating-point value is converted to single-precision. Analogous conversions are
carried out in the case of GetDoublev. If a value is so large in magnitude that it
cannot be represented with the requested type, then the nearest value representable
using the requested type is returned.
Unless otherwise indicated, multi-valued state variables return their multiple
values in the same order as they are given as arguments to the commands that set
them. For instance, the two DepthRange parameters are returned in the order n
followed by f.
If fragment color clamping is enabled, querying of the texture border color,
blend color, and RGBA clear color will clamp the corresponding state values to
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 222
[0; 1] before returning them. This behavior provides compatibility with previous
versions of the GL that clamped these values when speci?ed.
Most texture state variables are quali?ed by the value ofACTIVE_TEXTURE to
determine which server texture state vector is queried. Table 6.12 indicates those
state variables which are quali?ed byACTIVE_TEXTURE during state queries. All
other texture state queries will result in anINVALID_OPERATION error if the value
of ACTIVE_TEXTURE is greater than or equal to MAX_COMBINED_TEXTURE_-
IMAGE_UNITS.
Vertex array state variables are quali?ed by the value of VERTEX_ARRAY_-
BINDING to determine which vertex array object is queried. Tables 6.3 and 6.4
de?ne the set of state stored in a vertex array object.
6.1.3 Enumerated Queries
Other commands exist to obtain state variables that are identi?ed by a category as
well as a symbolic constant.
The commands
void GetTexParameterfifgv(enum target,enum value,
T data );
void GetTexParameterIfi uigv(enum target,enum value,
T data );
place information about texture parameter value for the speci?ed target into data.
value must be one of the symbolic values in table 3.16.
target may be one ofTEXTURE_1D,TEXTURE_2D,TEXTURE_3D,TEXTURE_-
1D_ARRAY,TEXTURE_2D_ARRAY, TEXTURE_RECTANGLE, orTEXTURE_CUBE_-
MAP, indicating the currently bound one-, two-, three-dimensional, one- or two-
dimensional array, rectangular, or cube map texture object.
Querying valueTEXTURE_BORDER_COLOR with GetTexParameterIiv or Get-
TexParameterIuiv returns the border color values as signed integers or unsigned
integers, respectively; otherwise the values are returned as described in sec-
tion 6.1.2. If the border color is queried with a type that does not match the original
type with which it was speci?ed, the result is unde?ned.
void GetTexLevelParameterfifgv(enum target,int lod,
enum value,T data );
places information about texture image parameter value for level-of-detail lod of
the speci?ed target into data. value must be one of the symbolic values in ta-
ble 6.14.
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 223
target may be one ofTEXTURE_1D,TEXTURE_2D,TEXTURE_3D,TEXTURE_-
1D_ARRAY, TEXTURE_2D_ARRAY, TEXTURE_RECTANGLE, TEXTURE_CUBE_-
MAP_POSITIVE_X, TEXTURE_CUBE_MAP_NEGATIVE_X, TEXTURE_CUBE_-
MAP_POSITIVE_Y, TEXTURE_CUBE_MAP_NEGATIVE_Y, TEXTURE_CUBE_-
MAP_POSITIVE_Z, TEXTURE_CUBE_MAP_NEGATIVE_Z, PROXY_TEXTURE_1D,
PROXY_TEXTURE_2D, PROXY_TEXTURE_3D, PROXY_TEXTURE_1D_ARRAY,
PROXY_TEXTURE_2D_ARRAY, PROXY_TEXTURE_RECTANGLE, or PROXY_-
TEXTURE_CUBE_MAP, indicating the one-, two-, or three-dimensional texture,
one- or two-dimensional array texture, rectangular texture, one of the six
distinct 2D images making up the cube map texture object, or the one-, two-,
three-dimensional, one- or two-dimensional array, rectangular, or cube map proxy
state vector.
target may also beTEXTURE_BUFFER, indicating the texture buffer. In the case
lod must be zero or anINVALID_VALUE error is generated.
Note that TEXTURE_CUBE_MAP is not a valid target parameter for Get-
TexLevelParameter, because it does not specify a particular cube map face.
lod determines which level-of-detail’s state is returned. If lod is less than zero
or larger than the maximum allowable level-of-detail, then an INVALID_VALUE
error is generated.
For texture images with uncompressed internal formats, queries of
value TEXTURE_RED_TYPE, TEXTURE_GREEN_TYPE, TEXTURE_BLUE_TYPE,
TEXTURE_ALPHA_TYPE, and TEXTURE_DEPTH_TYPE return the data type used
to store the component. Types NONE, SIGNED_NORMALIZED, UNSIGNED_-
NORMALIZED, FLOAT, INT, and UNSIGNED_INT respectively indicate missing,
signed normalized ?xed-point, unsigned normalized ?xed-point, ?oating-point,
signed unnormalized integer, and unsigned unnormalized integer components.
Queries of value TEXTURE_RED_SIZE, TEXTURE_GREEN_SIZE, TEXTURE_-
BLUE_SIZE, TEXTURE_ALPHA_SIZE, TEXTURE_DEPTH_SIZE, TEXTURE_-
STENCIL_SIZE, andTEXTURE_SHARED_SIZE return the actual resolutions of the
stored image array components, not the resolutions speci?ed when the image array
was de?ned. For texture images with a compressed internal format, the resolutions
returned specify the component resolution of an uncompressed internal format that
produces an image of roughly the same quality as the compressed image in ques-
tion. Since the quality of the implementation’s compression algorithm is likely
data-dependent, the returned component sizes should be treated only as rough ap-
proximations.
Querying value TEXTURE_COMPRESSED_IMAGE_SIZE returns the size (in
ubytes) of the compressed texture image that would be returned by GetCom-
pressedTexImage (section 6.1.4). Querying TEXTURE_COMPRESSED_IMAGE_-
SIZE is not allowed on texture images with an uncompressed internal format or on
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 224
proxy targets and will result in anINVALID_OPERATION error if attempted.
Queries of value TEXTURE_WIDTH, TEXTURE_HEIGHT, TEXTURE_DEPTH,
and TEXTURE_BORDER return the width, height, depth, and border as speci?ed
when the image array was created. The internal format of the image array is queried
as TEXTURE_INTERNAL_FORMAT.
6.1.4 Texture Queries
The command
void GetTexImage(enum tex,int lod,enum format,
enum type,void *img );
is used to obtain texture images. It is somewhat different from the other Get* com-
mands; tex is a symbolic value indicating which texture (or texture face in the case
of a cube map texture target name) is to be obtained. TEXTURE_1D, TEXTURE_-
2D,TEXTURE_3D,TEXTURE_1D_ARRAY,TEXTURE_2D_ARRAY, and TEXTURE_-
RECTANGLE indicate a one-, two-, or three-dimensional, one- or two-dimensional
array, or rectangular texture respectively. TEXTURE_CUBE_MAP_POSITIVE_X,
TEXTURE_CUBE_MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_POSITIVE_Y,
TEXTURE_CUBE_MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z, and
TEXTURE_CUBE_MAP_NEGATIVE_Z indicate the respective face of a cube map
texture. lod is a level-of-detail number, format is a pixel format from table 3.3,
type is a pixel type from table 3.2.
Any of the following mismatches between format and the internal format of
the texture image will generate anINVALID_OPERATION error:
 format is a color format (one of the formats in table 3.3 whose target is the
color buffer) and the base internal format of the texture image is not a color
format.
 format is DEPTH_COMPONENT and the base internal format is not DEPTH_-
COMPONENT orDEPTH_STENCIL.
 format is DEPTH_STENCIL and the base internal format is not DEPTH_-
STENCIL.
 format is one of the integer formats in table 3.3 and the internal format of
the texture image is not integer, or format is not one of the integer formats in
table 3.3 and the internal format is integer.
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 225
GetTexImage obtains component groups from a texture image with the indi-
cated level-of-detail. If format is a color format then the components are assigned
among R, G, B, and A according to table 6.1, starting with the ?rst group in the
?rst row, and continuing by obtaining groups in order from each row and proceed-
ing from the ?rst row to the last, and from the ?rst image to the last for three-
dimensional textures. One- and two-dimensional array textures are treated as two-
and three-dimensional images, respectively, where the layers are treated as rows or
images. If format is DEPTH_COMPONENT, then each depth component is assigned
with the same ordering of rows and images. If format is DEPTH_STENCIL, then
each depth component and each stencil index is assigned with the same ordering
of rows and images.
These groups are then packed and placed in client or pixel buffer object mem-
ory. If a pixel pack buffer is bound (as indicated by a non-zero value ofPIXEL_-
PACK_BUFFER_BINDING), img is an offset into the pixel pack buffer; otherwise,
img is a pointer to client memory. Pixel storage modes that are applicable to
ReadPixels are applied.
For three-dimensional and two-dimensional array textures, pixel storage op-
erations are applied as if the image were two-dimensional, except that the addi-
tional pixel storage state valuesPACK_IMAGE_HEIGHT andPACK_SKIP_IMAGES
are applied. The correspondence of texels to memory locations is as de?ned for
TexImage3D in section 3.8.1.
The row length, number of rows, image depth, and number of images are de-
termined by the size of the texture image (including any borders). Calling Get-
TexImage with lod less than zero or larger than the maximum allowable causes
the error INVALID_VALUE. Calling GetTexImage with a format of STENCIL_-
INDEX causes the error INVALID_ENUM. Calling GetTexImage with a non-zero
lod when tex is TEXTURE_RECTANGLE causes the error INVALID_VALUE. If a
pixel pack buffer object is bound and packing the texture image into the buffer’s
memory would exceed the size of the buffer, an INVALID_OPERATION error re-
sults. If a pixel pack buffer object is bound and img is not evenly divisible by
the number of basic machine units needed to store in memory the GL data type
corresponding to type (see table 3.2), an INVALID_OPERATION error results.
The command
void GetCompressedTexImage(enum target,int lod,
void *img );
is used to obtain texture images stored in compressed form. The parameters tar-
get, lod, and img are interpreted in the same manner as in GetTexImage. When
called, GetCompressedTexImage writesnubytes of compressed image data to
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 226
Base Internal Format R G B A
RED R 0 0 1
i
RG R G 0 1
i i
RGB R G B 1
i i i
RGBA R G B A
i i i i
Table 6.1: Texture, table, and ?lter return values. R ,G ,B , andA are compo-
i i i i
nents of the internal format that are assigned to pixel values R, G, B, and A. If a
requested pixel value is not present in the internal format, the speci?ed constant
value is used.
the pixel pack buffer or client memory pointed to by img, where n is the value
of TEXTURE_COMPRESSED_IMAGE_SIZE for the texture. The compressed image
data is formatted according to the de?nition of the texture’s internal format. All
pixel storage modes are ignored when returning a compressed texture image.
Calling GetCompressedTexImage with an lod value less than zero or greater
than the maximum allowable causes anINVALID_VALUE error. Calling GetCom-
pressedTexImage with a texture image stored with an uncompressed internal for-
mat causes anINVALID_OPERATION error. If a pixel pack buffer object is bound
andimg +n is greater than the size of the buffer, anINVALID_OPERATION error
results.
The command
boolean IsTexture(uint texture );
returnsTRUE if texture is the name of a texture object. If texture is zero, or is a non-
zero value that is not the name of a texture object, or if an error condition occurs,
IsTexture returnsFALSE. A name returned by GenTextures, but not yet bound, is
not the name of a texture object.
6.1.5 String Queries
String queries return pointers to UTF-8 encoded, NULL-terminated static
1
strings describing properties of the current GL context . The command
ubyte *GetString(enum name );
accepts name values of RENDERER, VENDOR, VERSION, and SHADING_-
LANGUAGE_VERSION. The format of the RENDERER and VENDOR strings is
1
Applications making copies of these static strings should never use a ?xed-length buffer, because
the strings may grow unpredictably between releases, resulting in buffer over?ow when copying.
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 227
implementation-dependent. The VERSION and SHADING_LANGUAGE_VERSION
strings are laid out as follows:
<version number><space><vendor-speci?c information>
The version number is either of the form major number.minor number or major -
number.minor number.release number, where the numbers all have one or more
digits. The release number and vendor speci?c information are optional. How-
ever, if present, then they pertain to the server and their format and contents are
implementation-dependent.
GetString returns the version number (in the VERSION string) that can be
supported by the current GL context. Thus, if the client and server support different
versions a compatible version is returned.
The GL version may also be queried by calling GetIntegerv with values
MAJOR_VERSION and MINOR_VERSION, which respectively return the same val-
ues as major number and minor number in the VERSION string, and value
CONTEXT_FLAGS, which returns a set of ?ags de?ning additional properties of
a context. IfCONTEXT_FLAG_FORWARD_COMPATIBLE_BIT is set inCONTEXT_-
FLAGS, then the context is a forward-compatible context as de?ned in appendix E,
and the deprecated features described in that appendix are not supported; other-
wise the context is a full context, and all features described in the speci?cation are
supported.
Indexed strings are queried with the command
ubyte *GetStringi(enum name,uint index );
name is the name of the indexed state and index is the index of the particular ele-
ment being queried. name may only beEXTENSIONS, indicating that the extension
name corresponding to theindexth supported extension should be returned.index
may range from zero to the value of NUM_EXTENSIONS minus one. There is no
de?ned relationship between any particular extension name and theindex values;
an extension name may correspond to a differentindex in different GL contexts
and/or implementations.
An INVALID_VALUE error is generated if index is outside the valid range for
the indexed state name.
6.1.6 Asynchronous Queries
The command
boolean IsQuery(uint id );
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 228
returnsTRUE if id is the name of a query object. If id is zero, or if id is a non-zero
value that is not the name of a query object, IsQuery returnsFALSE.
Information about a query target can be queried with the command
void GetQueryiv(enum target,enum pname,int *params );
target identi?es the query target, and must be one of SAMPLES_PASSED for
occlusion queries or PRIMITIVES_GENERATED and TRANSFORM_FEEDBACK_-
PRIMITIVES_WRITTEN for primitive queries.
If pname isCURRENT_QUERY, the name of the currently active query for target, or
zero if no query is active, will be placed in params.
If pname isQUERY_COUNTER_BITS, the implementation-dependent number of
bits used to hold the query result for target will be placed in params. The number
of query counter bits may be zero, in which case the counter contains no useful
information.
For primitive queries (PRIMITIVES_GENERATED and TRANSFORM_-
FEEDBACK_PRIMITIVES_WRITTEN) if the number of bits is non-zero, the
minimum number of bits allowed is 32.
For occlusion queries (SAMPLES_PASSED), if the number of bits is non-zero,
the minimum number of bits allowed is a function of the implementation’s maxi-
mum viewport dimensions (MAX_VIEWPORT_DIMS). The counter must be able to
represent at least two overdraws for every pixel in the viewport. The formula to
compute the allowable minimum value (wheren is the minimum number of bits)
is
n = minf32;dlog (maxViewportWidthmaxViewportHeight 2)eg:
2
The state of a query object can be queried with the commands
void GetQueryObjectiv(uint id,enum pname,
int *params );
void GetQueryObjectuiv(uint id,enum pname,
uint *params );
If id is not the name of a query object, or if the query object named by id is currently
active, then anINVALID_OPERATION error is generated.
If pname isQUERY_RESULT, then the query object’s result value is returned as
a single integer in params. If the value is so large in magnitude that it cannot be
represented with the requested type, then the nearest value representable using the
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 229
requested type is returned. If the number of query counter bits for target is zero,
then the result is returned as a single integer with the value zero.
There may be an indeterminate delay before the above query returns. If pname
is QUERY_RESULT_AVAILABLE, FALSE is returned if such a delay would be re-
quired; otherwiseTRUE is returned. It must always be true that if any query object
returns a result available of TRUE, all queries of the same type issued prior to that
query must also returnTRUE.
Querying the state for any given query object forces that occlusion query to
complete within a ?nite amount of time.
If multiple queries are issued using the same object name prior to calling Get-
QueryObject[u]iv, the result and availability information returned will always be
from the last query issued. The results from any queries before the last one will be
lost if they are not retrieved before starting a new query on the same target and id.
6.1.7 Buffer Object Queries
The command
boolean IsBuffer(uint buffer );
returnsTRUE if buffer is the name of an buffer object. If buffer is zero, or if buffer is
a non-zero value that is not the name of an buffer object, IsBuffer returnsFALSE.
The command
void GetBufferParameteriv(enum target,enum pname,
int *data );
returns information about a bound buffer object. target must be one of the targets
listed in table 2.5, and pname must be one of the buffer object parameters in ta-
ble 2.6, other than BUFFER_MAP_POINTER. The value of the speci?ed parameter
of the buffer object bound to target is returned in data.
The command
void GetBufferSubData(enum target,intptr offset,
sizeiptr size,void *data );
queries the data contents of a buffer object. target must be one of the targets listed
in table 2.5. offset and size indicate the range of data in the buffer object that is
to be queried, in terms of basic machine units. data speci?es a region of client
memory, size basic machine units in length, into which the data is to be retrieved.
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 230
An error is generated if GetBufferSubData is executed for a buffer object that
is currently mapped.
While the data store of a buffer object is mapped, the pointer to the data store
can be queried by calling
void GetBufferPointerv(enum target,enum pname,
void **params );
with target set to one of the targets listed in table 2.5 and pname set toBUFFER_-
MAP_POINTER. The single buffer map pointer is returned in params. GetBuffer-
Pointerv returns the NULL pointer value if the buffer’s data store is not currently
mapped, or if the requesting client did not map the buffer object’s data store, and
the implementation is unable to support mappings on multiple clients.
To query which buffer objects are bound to the array of uniform buffer binding
points and will be used as the storage for active uniform blocks, call GetIntegeri v
with param set to UNIFORM_BUFFER_BINDING. index must be in the range zero
to the value of MAX_UNIFORM_BUFFER_BINDINGS - 1. The name of the buffer
object bound to index is returned in values. If no buffer object is bound for index,
zero is returned in values.
To query the starting offset or size of the range of each buffer object bind-
ing used for uniform buffers, call GetIntegeri v with param set to UNIFORM_-
BUFFER_START or UNIFORM_BUFFER_SIZE respectively. index must be in the
range zero to the value of MAX_UNIFORM_BUFFER_BINDINGS - 1. If the param-
eter (starting offset or size) was not speci?ed when the buffer object was bound,
zero is returned. If no buffer object is bound to index, -1 is returned.
To query which buffer objects are bound to the array of transform feedback
binding points and will be used when transform feedback is active, call GetInte-
geri v with param set toTRANSFORM_FEEDBACK_BUFFER_BINDING. index must
be in the range zero to the value of MAX_TRANSFORM_FEEDBACK_SEPARATE_-
ATTRIBS - 1. The name of the buffer object bound to index is returned in values.
If no buffer object is bound for index, zero is returned in values.
To query the starting offset or size of the range of each buffer object binding
used for transform feedback, call GetIntegeri v with param set toTRANSFORM_-
FEEDBACK_BUFFER_START or TRANSFORM_FEEDBACK_BUFFER_SIZE respec-
tively. index must be in the range 0 to the value ofMAX_TRANSFORM_FEEDBACK_-
SEPARATE_ATTRIBS - 1. If the parameter (starting offset or size) was not speci?ed
when the buffer object was bound, zero is returned. If no buffer object is bound to
index, -1 is returned.
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 231
6.1.8 Vertex Array Object Queries
The command
boolean IsVertexArray(uint array );
returns TRUE if array is the name of a vertex array object. If array is zero, or a
non-zero value that is not the name of a vertex array object, IsVertexArray returns
FALSE. No error is generated if array is not a valid vertex array object name.
6.1.9 Shader and Program Queries
State stored in shader or program objects can be queried by commands that ac-
cept shader or program object names. These commands will generate the error
INVALID_VALUE if the provided name is not the name of either a shader or pro-
gram object, and INVALID_OPERATION if the provided name identi?es an object
of the other type. If an error is generated, variables used to hold return values are
not modi?ed.
The command
boolean IsShader(uint shader );
returns TRUE if shader is the name of a shader object. If shader is zero, or a non-
zero value that is not the name of a shader object, IsShader returns FALSE. No
error is generated if shader is not a valid shader object name.
The command
void GetShaderiv(uint shader,enum pname,int *params );
returns properties of the shader object named shader in params. The parameter
value to return is speci?ed by pname.
If pname isSHADER_TYPE,VERTEX_SHADER is returned if shader is a vertex
shader object, and FRAGMENT_SHADER is returned if shader is a fragment shader
object. If pname is DELETE_STATUS, TRUE is returned if the shader has been
?agged for deletion and FALSE is returned otherwise. If pname is COMPILE_-
STATUS,TRUE is returned if the shader was last compiled successfully, andFALSE
is returned otherwise. If pname isINFO_LOG_LENGTH, the length of the info log,
including a null terminator, is returned. If there is no info log, zero is returned. If
pname isSHADER_SOURCE_LENGTH, the length of the concatenation of the source
strings making up the shader source, including a null terminator, is returned. If no
source has been de?ned, zero is returned.
The command
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 232
boolean IsProgram(uint program );
returnsTRUE if program is the name of a program object. If program is zero, or a
non-zero value that is not the name of a program object, IsProgram returnsFALSE.
No error is generated if program is not a valid program object name.
The command
void GetProgramiv(uint program,enum pname,
int *params );
returns properties of the program object named program in params. The parameter
value to return is speci?ed by pname.
If pname isDELETE_STATUS,TRUE is returned if the program has been ?agged
for deletion, and FALSE is returned otherwise. If pname is LINK_STATUS, TRUE
is returned if the program was last compiled successfully, and FALSE is returned
otherwise. If pname isVALIDATE_STATUS,TRUE is returned if the last call to Val-
idateProgram with program was successful, andFALSE is returned otherwise. If
pname isINFO_LOG_LENGTH, the length of the info log, including a null termina-
tor, is returned. If there is no info log, zero is returned. If pname is ATTACHED_-
SHADERS, the number of objects attached is returned. If pname is ACTIVE_-
ATTRIBUTES, the number of active attributes in program is returned. If no ac-
tive attributes exist, zero is returned. If pname is ACTIVE_ATTRIBUTE_MAX_-
LENGTH, the length of the longest active attribute name, including a null terminator,
is returned. If no active attributes exist, zero is returned. If pname is ACTIVE_-
UNIFORMS, the number of active uniforms is returned. If no active uniforms ex-
ist, zero is returned. If pname is ACTIVE_UNIFORM_MAX_LENGTH, the length of
the longest active uniform name, including a null terminator, is returned. If no
active uniforms exist, zero is returned. If pname is TRANSFORM_FEEDBACK_-
BUFFER_MODE, the buffer mode used when transform feedback is active is re-
turned. It can be one of SEPARATE_ATTRIBS or INTERLEAVED_ATTRIBS. If
pname is TRANSFORM_FEEDBACK_VARYINGS, the number of varying variables
to capture in transform feedback mode for the program is returned. If pname is
TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, the length of the longest vary-
ing name speci?ed to be used for transform feedback, including a null terminator,
is returned. If no varyings are used for transform feedback, zero is returned. If
pname isACTIVE_UNIFORM_BLOCKS, the number of uniform blocks for program
containing active uniforms is returned. If pname is ACTIVE_UNIFORM_BLOCK_-
MAX_NAME_LENGTH, the length of the longest active uniform block name, includ-
ing the null terminator, is returned.
The command
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 233
void GetAttachedShaders(uint program,sizei maxCount,
sizei *count,uint *shaders );
returns the names of shader objects attached to program in shaders. The actual
number of shader names written into shaders is returned in count. If no shaders are
attached, count is set to zero. If count is NULL then it is ignored. The maximum
number of shader names that may be written into shaders is speci?ed by maxCount.
The number of objects attached to program is given by can be queried by calling
GetProgramiv withATTACHED_SHADERS.
A string that contains information about the last compilation attempt on a
shader object or last link or validation attempt on a program object, called the
info log, can be obtained with the commands
void GetShaderInfoLog(uint shader,sizei bufSize,
sizei *length,char *infoLog );
void GetProgramInfoLog(uint program,sizei bufSize,
sizei *length,char *infoLog );
These commands return the info log string in infoLog. This string will be null-
terminated. The actual number of characters written into infoLog, excluding the
null terminator, is returned in length. If length isNULL, then no length is returned.
The maximum number of characters that may be written into infoLog, including
the null terminator, is speci?ed by bufSize. The number of characters in the info
log can be queried with GetShaderiv or GetProgramiv withINFO_LOG_LENGTH.
If shader is a shader object, the returned info log will either be an empty string or
it will contain information about the last compilation attempt for that object. If
program is a program object, the returned info log will either be an empty string or
it will contain information about the last link attempt or last validation attempt for
that object.
The info log is typically only useful during application development and an
application should not expect different GL implementations to produce identical
info logs.
The command
void GetShaderSource(uint shader,sizei bufSize,
sizei *length,char *source );
returns in source the string making up the source code for the shader object shader.
The string source will be null-terminated. The actual number of characters written
into source, excluding the null terminator, is returned in length. If length isNULL,
no length is returned. The maximum number of characters that may be written into
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 234
source, including the null terminator, is speci?ed by bufSize. The string source is
a concatenation of the strings passed to the GL using ShaderSource. The length
of this concatenation is given bySHADER_SOURCE_LENGTH, which can be queried
with GetShaderiv.
The commands
void GetVertexAttribdv(uint index,enum pname,
double *params );
void GetVertexAttribfv(uint index,enum pname,
float *params );
void GetVertexAttribiv(uint index,enum pname,
int *params );
void GetVertexAttribIiv(uint index,enum pname,
int *params );
void GetVertexAttribIuiv(uint index,enum pname,
uint *params );
obtain the vertex attribute state named by pname for the generic vertex attribute
numbered index and places the information in the array params. pname must
be one of VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, VERTEX_ATTRIB_-
ARRAY_ENABLED, VERTEX_ATTRIB_ARRAY_SIZE, VERTEX_ATTRIB_ARRAY_-
STRIDE, VERTEX_ATTRIB_ARRAY_TYPE, VERTEX_ATTRIB_ARRAY_-
NORMALIZED, VERTEX_ATTRIB_ARRAY_INTEGER, or CURRENT_VERTEX_-
ATTRIB. Note that all the queries exceptCURRENT_VERTEX_ATTRIB return values
stored in the currently bound vertex array object (the value of VERTEX_ARRAY_-
BINDING). If the zero object is bound, these values are client state. The error
INVALID_VALUE is generated if index is greater than or equal toMAX_VERTEX_-
ATTRIBS.
All but CURRENT_VERTEX_ATTRIB return information about generic vertex
attribute arrays. The enable state of a generic vertex attribute array is set by the
command EnableVertexAttribArray and cleared by DisableVertexAttribArray.
The size, stride, type, normalized ?ag, and unconverted integer ?ag are set by the
commands VertexAttribPointer and VertexAttribIPointer. The normalized ?ag
is always set to FALSE by VertexAttribIPointer. The unconverted integer ?ag is
always set toFALSE by VertexAttribPointer andTRUE by VertexAttribIPointer.
The query CURRENT_VERTEX_ATTRIB returns the current value for the
generic attribute index. GetVertexAttribdv and GetVertexAttribfv read and re-
turn the current attribute values as ?oating-point values; GetVertexAttribiv reads
them as ?oating-point values and converts them to integer values; GetVertexAt-
tribIiv reads and returns them as integers; GetVertexAttribIuiv reads and returns
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 235
them as unsigned integers. The results of the query are unde?ned if the current
attribute values are read using one data type but were speci?ed using a different
one.
The command
void GetVertexAttribPointerv(uint index,enum pname,
void **pointer );
obtains the pointer named pname for the vertex attribute numbered index and places
the information in the array pointer. pname must be VERTEX_ATTRIB_ARRAY_-
POINTER. The value returned is queried from the currently bound vertex array
object. If the zero object is bound, the value is queried from client state. An
INVALID_VALUE error is generated if index is greater than or equal to the value of
MAX_VERTEX_ATTRIBS.
The commands
void GetUniformfv(uint program,int location,
float *params );
void GetUniformiv(uint program,int location,
int *params );
void GetUniformuiv(uint program,int location,
uint *params );
return the value or values of the uniform at location location of the default uni-
form block for program object program in the array params. The type of the uni-
form at location determines the number of values returned. The errorINVALID_-
OPERATION is generated if program has not been linked successfully, or if location
is not a valid location for program. In order to query the values of an array of uni-
forms, a GetUniform* command needs to be issued for each array element. If the
uniform queried is a matrix, the values of the matrix are returned in column major
order. If an error occurred, params will not be modi?ed.
6.1.10 Framebuffer Object Queries
The command
boolean IsFramebuffer(uint framebuffer );
returnsTRUE if framebuffer is the name of an framebuffer object. If framebuffer is
zero, or if framebuffer is a non-zero value that is not the name of an framebuffer
object, IsFramebuffer returnFALSE.
The command
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 236
void GetFramebufferAttachmentParameteriv(enum target,
enum attachment,enum pname,int *params );
returns information about attachments of a bound framebuffer object. tar-
get must be DRAW_FRAMEBUFFER, READ_FRAMEBUFFER, or FRAMEBUFFER.
FRAMEBUFFER is equivalent toDRAW_FRAMEBUFFER.
If the default framebuffer is bound to target, then attachment must be one of
FRONT_LEFT, FRONT_RIGHT, BACK_LEFT, or BACK_RIGHT, identifying a color
buffer; DEPTH, identifying the depth buffer; or STENCIL, identifying the stencil
buffer.
If a framebuffer object is bound to target, then attachment must be one of the
attachment points of the framebuffer listed in table 4.11.
If attachment is DEPTH_STENCIL_ATTACHMENT, and different objects are
bound to the depth and stencil attachment points of target, the query will fail and
generate an INVALID_OPERATION error. If the same object is bound to both at-
tachment points, information about that object will be returned.
Upon successful return from GetFramebufferAttachmentParameteriv, if
pname is FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, then param will contain
one of NONE, FRAMEBUFFER_DEFAULT, TEXTURE, or RENDERBUFFER, identify-
ing the type of object which contains the attached image. Other values accepted
for pname depend on the type of object, as described below.
If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is NONE, no
framebuffer is bound to target. In this case querying pname FRAMEBUFFER_-
ATTACHMENT_OBJECT_NAME will return zero, and all other queries will generate
anINVALID_OPERATION error.
If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is not NONE,
these queries apply to all other framebuffer types:
 If pname is FRAMEBUFFER_ATTACHMENT_RED_SIZE, FRAMEBUFFER_-
ATTACHMENT_GREEN_SIZE, FRAMEBUFFER_ATTACHMENT_BLUE_-
SIZE, FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, FRAMEBUFFER_-
ATTACHMENT_DEPTH_SIZE, or FRAMEBUFFER_ATTACHMENT_-
STENCIL_SIZE, then param will contain the number of bits in the
corresponding red, green, blue, alpha, depth, or stencil component of the
speci?ed attachment. Zero is returned if the requested component is not
present in attachment.
 If pname is FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE, param will
contain the format of components of the speci?ed attachment, one of
FLOAT, INT, UNSIGNED_INT, SIGNED_NORMALIZED, or UNSIGNED_-
NORMALIZED for ?oating-point, signed integer, unsigned integer, signed
OpenGL 3.1 - May 28, 20096.1. QUERYINGGLSTATE 237
normalized ?xed-point, or unsigned normalized ?xed-point components re-
spectively. Only color buffers may have integer components.
 If pname is FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, param will
contain the encoding of components of the speci?ed attachment, one of
LINEAR or SRGB for linear or sRGB-encoded components, respectively.
Only color buffer components may be sRGB-encoded; such components
are treated as described in sections 4.1.7 and 4.1.8. For the default frame-
buffer, color encoding is determined by the implementation. For framebuffer
objects, components are sRGB-encoded if the internal format of a color
attachment is one of the color-renderable SRGB formats described in sec-
tion 3.8.15.
If the value of FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is
RENDERBUFFER, then
 If pname isFRAMEBUFFER_ATTACHMENT_OBJECT_NAME, params will con-
tain the name of the renderbuffer object which contains the attached image.
If the value ofFRAMEBUFFER_ATTACHMENT_OBJECT_TYPE isTEXTURE, then
 If pname isFRAMEBUFFER_ATTACHMENT_OBJECT_NAME, then params will
contain the name of the texture object which contains the attached image.
 If pname is FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, then params
will contain the mipmap level of the texture object which contains the at-
tached image.
 If pname isFRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE and
the texture object namedFRAMEBUFFER_ATTACHMENT_OBJECT_NAME is a
cube map texture, then params will contain the cube map face of the cube-
map texture object which contains the attached image. Otherwise params
will contain the value zero.
 If pname is FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER and the tex-
ture object namedFRAMEBUFFER_ATTACHMENT_OBJECT_NAME is a three-
dimensional texture or a one- or two-dimensional array texture, then params
will contain the number of the texture layer which contains the attached im-
age. Otherwise params will contain the value zero.
Any combinations of framebuffer type and pname not described above will
generate anINVALID_ENUM error.
OpenGL 3.1 - May 28, 20096.2. STATETABLES 238
6.1.11 Renderbuffer Object Queries
The command
boolean IsRenderbuffer(uint renderbuffer );
returns TRUE if renderbuffer is the name of a renderbuffer object. If renderbuffer
is zero, or if renderbuffer is a non-zero value that is not the name of a renderbuffer
object, IsRenderbuffer returnFALSE.
The command
void GetRenderbufferParameteriv(enum target,enum pname,
int params );
*
returns information about a bound renderbuffer object. target must be
RENDERBUFFER and pname must be one of the symbolic values in table 6.23. If
the renderbuffer currently bound to target is zero, then an INVALID_OPERATION
error is generated.
Upon successful return from GetRenderbufferParameteriv, if pname
is RENDERBUFFER_WIDTH, RENDERBUFFER_HEIGHT, RENDERBUFFER_-
INTERNAL_FORMAT, or RENDERBUFFER_SAMPLES, then params will contain
the width in pixels, height in pixels, internal format, or number of samples,
respectively, of the image of the renderbuffer currently bound to target.
If pname is RENDERBUFFER_RED_SIZE, RENDERBUFFER_GREEN_-
SIZE, RENDERBUFFER_BLUE_SIZE, RENDERBUFFER_ALPHA_SIZE,
RENDERBUFFER_DEPTH_SIZE, or RENDERBUFFER_STENCIL_SIZE, then
params will contain the actual resolutions (not the resolutions speci?ed when
the image array was de?ned) for the red, green, blue, alpha depth, or stencil
components, respectively, of the image of the renderbuffer currently bound to
target.
Otherwise, anINVALID_ENUM error is generated.
In the tables that follow, a type is indicated for each variable. Table 6.2 explains
these types. The type actually identi?es all state associated with the indicated
description; in certain cases only a portion of this state is returned. This is the case
with textures, where only the selected texture or texture parameter is returned.
TheM andm entries for initial minmax table values represent the maximum
and minimum possible representable values, respectively.
6.2 State Tables
The tables on the following pages indicate which state variables are obtained with
what commands. State variables that can be obtained using any of GetBooleanv,
OpenGL 3.1 - May 28, 20096.2. STATETABLES 239
Type code Explanation
B Boolean
BMU Basic machine units
C Color (?oating-point R, G, B, and A values)
Z Integer
+
Z Non-negative integer or enumerated token value
Z ,Z k-valued integer (k indicatesk is minimum)
k k
R Floating-point number
+
R Non-negative ?oating-point number
[a;b]
R Floating-point number in the range [a;b]
k
R k-tuple of ?oating-point numbers
S NULL-terminated string
I Image
Y Pointer (data type unspeci?ed)
ntype n copies of typetype (n indicatesn is minimum)
Table 6.2: State Variable Types
GetIntegerv, GetFloatv, or GetDoublev are listed with just one of these com-
mands – the one that is most appropriate given the type of the data to be returned.
These state variables cannot be obtained using IsEnabled. However, state vari-
ables for which IsEnabled is listed as the query command can also be obtained
using GetBooleanv, GetIntegerv, GetFloatv, and GetDoublev. State variables
for which any other command is listed as the query command can be obtained by
using that command or any of its typed variants, although information may be lost
when not using the listed command. Unless otherwise speci?ed, when ?oating-
point state is returned as integer values or integer state is returned as ?oating-point
values it is converted in the fashion described in section 6.1.2.
OpenGL 3.1 - May 28, 20096.2. STATETABLES 240
Table 6.3. Vertex Array Object State (cont.)
OpenGL 3.1 - May 28, 2009
Get
Initial
Get value Type Command Value Description Sec.
GetVertexAttribiv Vertex attrib array enable
VERTEX ATTRIB ARRAY ENABLED 16B FALSE 2.8
GetVertexAttribiv
VERTEX ATTRIB ARRAY SIZE 16Z 4 Vertex attrib array size 2.8
GetVertexAttribiv
+
VERTEX ATTRIB ARRAY STRIDE 16Z 0 Vertex attrib array stride 2.8
GetVertexAttribiv
VERTEX ATTRIB ARRAY TYPE 16Z FLOAT Vertex attrib array type 2.8
9
GetVertexAttribiv Vertex attrib array nor-
VERTEX ATTRIB ARRAY NORMALIZED 16B FALSE 2.8
malized
GetVertexAttribiv Vertex attrib array has
VERTEX ATTRIB ARRAY INTEGER 16B FALSE 2.8
unconverted integers
GetVertex- Vertex attrib array
VERTEX ATTRIB ARRAY POINTER 16Y NULL 2.8
AttribPointerv pointer6.2. STATETABLES 241
Table 6.4. Vertex Array Object State (cont.)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Element array buffer
+
ELEMENT ARRAY BUFFER BINDING Z GetIntegerv 0 2.9.5
binding
Attribute array buffer
+
VERTEX ATTRIB ARRAY BUFFER BINDING 16Z GetVertexAttribiv 0 2.9
binding6.2. STATETABLES 242
Table 6.5. Vertex Array Data (not in Vertex Array objects)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
+
ARRAY BUFFER BINDING Z GetIntegerv 0 Current buffer binding 2.9
Current vertex array ob-
+
GetIntegerv
VERTEX ARRAY BINDING Z 0 2.10
ject binding
PRIMITIVE RESTART B IsEnabled FALSE Primitive restart enable 2.8
+
PRIMITIVE RESTART INDEX Z GetIntegerv 0 Primitive restart index 2.86.2. STATETABLES 243
Table 6.6. Buffer Object State
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
– nBMU GetBufferSubData - Buffer data 2.9
+
BUFFER SIZE nZ GetBufferParameteriv 0 Buffer data size 2.9
BUFFER USAGE nZ GetBufferParameteriv STATIC_DRAW Buffer usage pattern 2.9
9
BUFFER ACCESS nZ GetBufferParameteriv READ_WRITE Buffer access ?ag 2.9
3
+
BUFFER ACCESS FLAGS nZ GetBufferParameteriv 0 Extended buffer access ?ag 2.9
BUFFER MAPPED nB GetBufferParameteriv FALSE Buffer map ?ag 2.9
BUFFER MAP POINTER nY GetBufferPointerv NULL Mapped buffer pointer 2.9
+
BUFFER MAP OFFSET nZ GetBufferParameteriv 0 Start of mapped buffer range 2.9
+
Size of mapped buffer range
BUFFER MAP LENGTH nZ GetBufferParameteriv 0 2.96.2. STATETABLES 244
Table 6.7. Transformation state
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
VIEWPORT 4Z GetIntegerv see 2.12.1 Viewport origin & extent 2.12.1
+
DEPTH RANGE 2R GetFloatv 0,1 Depth range near & far 2.12.1
ith user clipping plane
CLIP DISTANCEi 6B IsEnabled FALSE 2.17
enabled6.2. STATETABLES 245
Table 6.8. Coloring
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
CLAMP READ COLOR Z GetIntegerv FIXED_ONLY Read color clamping 4.3.1
36.2. STATETABLES 246
Table 6.9. Rasterization
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
+
POINT SIZE R GetFloatv 1.0 Point size 3.4
+
POINT FADE THRESHOLD SIZE R GetFloatv 1.0 Threshold for alpha attenuation 3.4
POINT SPRITE COORD ORIGIN Z GetIntegerv UPPER_LEFT Origin orientation for point sprites 3.4
2
+
LINE WIDTH R GetFloatv 1.0 Line width 3.5
LINE SMOOTH B IsEnabled FALSE Line antialiasing on 3.56.2. STATETABLES 247
Table 6.10. Rasterization (cont.)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
CULL FACE B IsEnabled FALSE Polygon culling enabled 3.6.1
CULL FACE MODE Z GetIntegerv BACK Cull front-/back-facing polygons 3.6.1
3
Polygon frontface CW/CCW indica-
FRONT FACE Z GetIntegerv CCW 3.6.1
2
tor
POLYGON SMOOTH B IsEnabled FALSE Polygon antialiasing on 3.6
POLYGON OFFSET FACTOR R GetFloatv 0 Polygon offset factor 3.6.4
POLYGON OFFSET UNITS R GetFloatv 0 Polygon offset units 3.6.4
Polygon offset enable for POINT
POLYGON OFFSET POINT B IsEnabled FALSE 3.6.4
mode rasterization
Polygon offset enable for LINE
POLYGON OFFSET LINE B IsEnabled FALSE 3.6.4
mode rasterization
Polygon offset enable for FILL
POLYGON OFFSET FILL B IsEnabled FALSE 3.6.4
mode rasterization6.2. STATETABLES 248
Table 6.11. Multisampling
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Multisample rasterization
MULTISAMPLE B IsEnabled TRUE 3.3.1
SAMPLE ALPHA TO COVERAGE B IsEnabled FALSE Modify coverage from alpha 4.1.3
SAMPLE ALPHA TO ONE B IsEnabled FALSE Set alpha to maximum 4.1.3
SAMPLE COVERAGE B IsEnabled FALSE Mask to modify coverage 4.1.3
+
SAMPLE COVERAGE VALUE R GetFloatv 1 Coverage mask value 4.1.3
SAMPLE COVERAGE INVERT B GetBooleanv FALSE Invert coverage mask value 4.1.36.2. STATETABLES 249
Table 6.12. Textures (state per texture unit and binding point)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Texture object bound to
+
TEXTURE BINDING xD 323Z GetIntegerv 0 3.8.13
TEXTURE_xD
Texture object bound to
+
TEXTURE BINDING 1D ARRAY 32Z GetIntegerv 0 3.8.13
TEXTURE_1D_ARRAY
Texture object bound to
+
TEXTURE BINDING 2D ARRAY 32Z GetIntegerv 0 3.8.13
TEXTURE_2D_ARRAY
Texture object bound
+
TEXTURE BINDING RECTANGLE 32Z GetIntegerv 0 to TEXTURE_- 3.8.13
RECTANGLE
Texture object bound to
+
TEXTURE BINDING BUFFER 32Z GetIntegerv 0 3.8.13
TEXTURE_BUFFER
Texture object bound to
+
TEXTURE BINDING CUBE MAP 32Z GetIntegerv 0 3.8.13
TEXTURE_CUBE_MAP
xD texture image at l.o.d.
TEXTURE xD nI GetTexImage see 3.8 3.8
i
1D texture array image at
TEXTURE 1D ARRAY
nI GetTexImage see 3.8 3.8
rowi
2D texture array image at
TEXTURE 2D ARRAY nI GetTexImage see 3.8 3.8
slicei
Rectangular texture im-
TEXTURE RECTANGLE nI GetTexImage see 3.8 3.8
age at l.o.d. zero
+x face cube map tex-
TEXTURE CUBE MAP POSITIVE X nI GetTexImage see 3.8.1 3.8.1
ture image at l.o.d.i
 x face cube map tex-
TEXTURE CUBE MAP NEGATIVE X nI GetTexImage see 3.8.1 3.8.1
ture image at l.o.d.i
+y face cube map texture
TEXTURE CUBE MAP POSITIVE Y nI GetTexImage see 3.8.1 3.8.1
image at l.o.d.i
 y face cube map texture
TEXTURE CUBE MAP NEGATIVE Y nI GetTexImage see 3.8.1 3.8.1
image at l.o.d.i
+z face cube map texture
TEXTURE CUBE MAP POSITIVE Z nI GetTexImage see 3.8.1 3.8.1
image at l.o.d.i
 z face cube map texture
TEXTURE CUBE MAP NEGATIVE Z nI GetTexImage see 3.8.1 3.8.1
image at l.o.d.i6.2. STATETABLES 250
Table 6.13. Textures (state per texture object)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
TEXTURE BORDER COLOR nC GetTexParameter 0,0,0,0 Border color 3.8
TEXTURE MIN FILTER nZ GetTexParameter see sec. 3.8.12 Minification function 3.8.8
6
TEXTURE MAG FILTER nZ GetTexParameter LINEAR Magnification function 3.8.9
2
TEXTURE WRAP S nZ GetTexParameter see sec. 3.8.12 Texcoords wrap mode 3.8.8
4
Texcoord t wrap mode
TEXTURE WRAP T nZ GetTexParameter see sec. 3.8.12 (2D, 3D, cube map tex- 3.8.8
4
tures only)
Texcoord r wrap mode
TEXTURE WRAP R nZ GetTexParameter see sec. 3.8.12 3.8.8
4
(3D textures only)
TEXTURE MIN LOD nR GetTexParameterfv -1000 Minimum level of detail 3.8
TEXTURE MAX LOD nR GetTexParameterfv 1000 Maximum level of detail 3.8
+
TEXTURE BASE LEVEL Base texture array
nZ GetTexParameterfv 0 3.8
+
TEXTURE MAX LEVEL nZ GetTexParameterfv 1000 Max. texture array level 3.8
Texture level of detail
TEXTURE LOD BIAS nR GetTexParameterfv 0.0 3.8.8
bias (bias )
texobj
TEXTURE COMPARE MODE nZ GetTexParameteriv NONE Comparison mode 3.8.14
2
TEXTURE COMPARE FUNC nZ GetTexParameteriv LEQUAL Comparison function 3.8.14
86.2. STATETABLES 251
Table 6.14. Textures (state per texture image)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
+
TEXTURE WIDTH nZ GetTexLevelParameter 0 Speci?ed width 3.8
+
TEXTURE HEIGHT nZ GetTexLevelParameter 0 Speci?ed height (2D/3D) 3.8
+
TEXTURE DEPTH nZ GetTexLevelParameter 0 Speci?ed depth (3D) 3.8
Internal format (see sec-
TEXTURE INTERNAL FORMAT nZ GetTexLevelParameter RGBA orR8 3.8
68
tion 3.8.12)
Component resolution (x
is RED, GREEN, BLUE,
+
TEXTURE x SIZE n 6Z GetTexLevelParameter 0 3.8
ALPHA, DEPTH, or
STENCIL)
Shared exponent ?eld
+
TEXTURE SHARED SIZE nZ GetTexLevelParameter 0 3.8
resolution
Component type (x is
TEXTURE x TYPE nZ GetTexLevelParameter NONE RED, GREEN, BLUE, 6.1.3
5
ALPHA, orDEPTH)
True if image has a com-
TEXTURE COMPRESSED nB GetTexLevelParameter FALSE 3.8.3
pressed internal format
Size (in ubytes) of
+
TEXTURE COMPRESSED IMAGE SIZE nZ GetTexLevelParameter 0 3.8.3
compressed image
Buffer object bound as
TEXTURE BUFFER DATA STORE BIND- the data store for the ac-
+
nZ GetTexLevelParameter 0 3.8.13
ING tive image unit’s buffer
texture6.2. STATETABLES 252
Table 6.15. Texture Environment and Generation
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
ACTIVE TEXTURE Z GetIntegerv TEXTURE0 Active texture unit selector 2.7
326.2. STATETABLES 253
Table 6.16. Pixel Operations
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
SCISSOR TEST B IsEnabled FALSE Scissoring enabled 4.1.2
SCISSOR BOX 4Z GetIntegerv see 4.1.2 Scissor box 4.1.2
STENCIL TEST B IsEnabled FALSE Stenciling enabled 4.1.4
STENCIL FUNC Z GetIntegerv ALWAYS Front stencil function 4.1.4
8
+
Front stencil mask
STENCIL VALUE MASK Z GetIntegerv see 4.1.4 4.1.4
+
STENCIL REF Z GetIntegerv 0 Front stencil reference value 4.1.4
STENCIL FAIL Z GetIntegerv KEEP Front stencil fail action 4.1.4
8
Front stencil depth buffer fail action
STENCIL PASS DEPTH FAIL Z GetIntegerv KEEP 4.1.4
8
Front stencil depth buffer pass ac-
STENCIL PASS DEPTH PASS Z GetIntegerv KEEP 4.1.4
8
tion
Back stencil function
STENCIL BACK FUNC Z GetIntegerv ALWAYS 4.1.4
8
+
STENCIL BACK VALUE MASK Z GetIntegerv see 4.1.4 Back stencil mask 4.1.4
+
STENCIL BACK REF Z GetIntegerv 0 Back stencil reference value 4.1.4
STENCIL BACK FAIL Z GetIntegerv KEEP Back stencil fail action 4.1.4
8
STENCIL BACK PASS DEPTH FAIL Z GetIntegerv KEEP Back stencil depth buffer fail action 4.1.4
8
Back stencil depth buffer pass action
STENCIL BACK PASS DEPTH PASS Z GetIntegerv KEEP 4.1.4
86.2. STATETABLES 254
Table 6.17. Pixel Operations (cont.)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
DEPTH TEST B IsEnabled FALSE Depth buffer enabled 4.1.5
Depth buffer test func-
DEPTH FUNC Z GetIntegerv LESS 4.1.5
8
tion
Blending enabled for
BLEND 1B IsEnabledi FALSE 4.1.7
draw bufferi
Blending source RGB
BLEND SRC RGB (v1.3:BLEND SRC) Z GetIntegerv ONE 4.1.7
15
function
Blending source A func-
BLEND SRC ALPHA Z GetIntegerv ONE 4.1.7
15
tion
Blending dest. RGB
BLEND DST RGB (v1.3:BLEND DST) Z GetIntegerv ZERO 4.1.7
14
function
Blending dest. A func-
BLEND DST ALPHA Z GetIntegerv ZERO 4.1.7
14
tion
BLEND EQUATION RGB (v1.5: BLEND -
Z GetIntegerv FUNC_ADD RGB blending equation 4.1.7
5
EQUATION)
BLEND EQUATION ALPHA Z GetIntegerv FUNC_ADD Alpha blending equation 4.1.7
5
BLEND COLOR C GetFloatv 0,0,0,0 Constant blend color 4.1.7
sRGB update and blend-
FRAMEBUFFER SRGB B IsEnabled FALSE 4.1.7
ing enable
DITHER B IsEnabled TRUE Dithering enabled 4.1.9
COLOR LOGIC OP B IsEnabled FALSE Color logic op enabled 4.1.10
LOGIC OP MODE Z GetIntegerv COPY Logic op function 4.1.10
166.2. STATETABLES 255
Table 6.18. Framebuffer Control
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Color write en-
COLOR WRITEMASK 14B GetBooleani v (TRUE,TRUE,TRUE,TRUE) ables (R,G,B,A) 4.2.2
for draw bufferi
Depth buffer en-
DEPTH WRITEMASK B GetBooleanv TRUE 4.2.2
abled for writing
Front stencil
+
STENCIL WRITEMASK Z GetIntegerv 1’s 4.2.2
buffer writemask
Back stencil
+
STENCIL BACK WRITEMASK Z GetIntegerv 1’s 4.2.2
buffer writemask
Color buffer clear
COLOR CLEAR VALUE C GetFloatv 0,0,0,0 4.2.3
value
Depth buffer clear
+
DEPTH CLEAR VALUE R GetIntegerv 1 4.2.3
value
Stencil clear
+
STENCIL CLEAR VALUE Z GetIntegerv 0 4.2.3
value6.2. STATETABLES 256
Table 6.19. Framebuffer (state per target binding point)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Framebuffer object bound to
+
DRAW FRAMEBUFFER BINDING Z GetIntegerv 0 4.4.1
DRAW_FRAMEBUFFER
Framebuffer object bound to
+
READ FRAMEBUFFER BINDING Z GetIntegerv 0 4.4.1
READ_FRAMEBUFFER6.2. STATETABLES 257
Table 6.20. Framebuffer (state per framebuffer object)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Draw buffer selected for color out-
DRAW BUFFERi 1Z GetIntegerv see 4.2.1 4.2.1
11
puti
READ BUFFER Z GetIntegerv see 4.3.1 Read source buffer 4.3.1
116.2. STATETABLES 258
Table 6.21. Framebuffer (state per attachment point)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
GetFramebuffer- Type of image attached
FRAMEBUFFER ATTACHMENT OBJECT TYPE Z Attachment- NONE to framebuffer attach- 4.4.2
Parameteriv ment point
GetFramebuffer- Name of object at-
FRAMEBUFFER ATTACHMENT OBJECT NAME Z Attachment- 0 tached to framebuffer 4.4.2
Parameteriv attachment point
GetFramebuffer- Mipmap level of texture
FRAMEBUFFER ATTACHMENT TEXTURE LEVEL Z Attachment- 0 image attached, if object 4.4.2
Parameteriv attached is texture
Cubemap face of texture
GetFramebuffer-
image attached, if object
+
FRAMEBUFFER ATTACHMENT TEXTURE CUBE MAP FACE Z Attachment- NONE 4.4.2
attached is cubemap tex-
Parameteriv
ture
GetFramebuffer- Layer of texture image
FRAMEBUFFER ATTACHMENT TEXTURE LAYER Z Attachment- 0 attached, if object at- 4.4.2
Parameteriv tached is 3D texture
GetFramebuffer-
Encoding of components
FRAMEBUFFER ATTACHMENT COLOR ENCODING Z Attachment- - 6.1.3
2
in the attached image
Parameteriv
GetFramebuffer-
Data type of components
FRAMEBUFFER ATTACHMENT COMPONENT TYPE Z Attachment- - 6.1.3
4
in the attached image
Parameteriv
Size in bits of attached
GetFramebuffer- image’s x component; x
+
FRAMEBUFFER ATTACHMENT x SIZE Z Attachment- - is RED, GREEN, BLUE, 6.1.3
Parameteriv ALPHA, DEPTH, or
STENCIL6.2. STATETABLES 259
Table 6.22. Renderbuffer (state per target and binding point)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Renderbuffer object bound to
RENDERBUFFER BINDING Z GetIntegerv 0 4.4.2
RENDERBUFFER6.2. STATETABLES 260
Table 6.23. Renderbuffer (state per renderbuffer object)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
+
RENDERBUFFER WIDTH Z GetRenderbufferParameteriv 0 Width of renderbuffer 4.4.2
+
Height of renderbuffer
RENDERBUFFER HEIGHT Z GetRenderbufferParameteriv 0 4.4.2
+
RENDERBUFFER INTERNAL FORMAT Z GetRenderbufferParameteriv RGBA Internal format of renderbuffer 4.4.2
Size in bits of renderbuffer image’s
+
RENDERBUFFER RED SIZE Z GetRenderbufferParameteriv 0 4.4.2
red component
Size in bits of renderbuffer image’s
+
RENDERBUFFER GREEN SIZE Z GetRenderbufferParameteriv 0 4.4.2
green component
Size in bits of renderbuffer image’s
+
RENDERBUFFER BLUE SIZE Z GetRenderbufferParameteriv 0 4.4.2
blue component
Size in bits of renderbuffer image’s
+
RENDERBUFFER ALPHA SIZE Z GetRenderbufferParameteriv 0 4.4.2
alpha component
Size in bits of renderbuffer image’s
+
RENDERBUFFER DEPTH SIZE Z GetRenderbufferParameteriv 0 4.4.2
depth component
Size in bits of renderbuffer image’s
+
RENDERBUFFER STENCIL SIZE Z GetRenderbufferParameteriv 0 4.4.2
stencil component
+
RENDERBUFFER SAMPLES Z GetRenderbufferParameteriv 0 Number of samples 4.4.26.2. STATETABLES 261
Table 6.24. Pixels
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
UNPACK SWAP BYTES B GetBooleanv FALSE Value ofUNPACK_SWAP_BYTES 3.7.1
UNPACK LSB FIRST B GetBooleanv FALSE Value ofUNPACK_LSB_FIRST 3.7.1
Value of UNPACK_IMAGE_-
+
UNPACK IMAGE HEIGHT Z GetIntegerv 0 3.7.1
HEIGHT
+
UNPACK SKIP IMAGES Z GetIntegerv 0 Value ofUNPACK_SKIP_IMAGES 3.7.1
+
UNPACK ROW LENGTH Z GetIntegerv 0 Value ofUNPACK_ROW_LENGTH 3.7.1
+
UNPACK SKIP ROWS Z GetIntegerv 0 Value ofUNPACK_SKIP_ROWS 3.7.1
+
Value ofUNPACK_SKIP_PIXELS
UNPACK SKIP PIXELS Z GetIntegerv 0 3.7.1
+
UNPACK ALIGNMENT Z GetIntegerv 4 Value ofUNPACK_ALIGNMENT 3.7.1
PACK SWAP BYTES B GetBooleanv FALSE Value ofPACK_SWAP_BYTES 4.3.1
PACK LSB FIRST B GetBooleanv FALSE Value ofPACK_LSB_FIRST 4.3.1
+
PACK IMAGE HEIGHT Z GetIntegerv 0 Value ofPACK_IMAGE_HEIGHT 4.3.1
+
PACK SKIP IMAGES Z GetIntegerv 0 Value ofPACK_SKIP_IMAGES 4.3.1
+
PACK ROW LENGTH Z GetIntegerv 0 Value ofPACK_ROW_LENGTH 4.3.1
+
PACK SKIP ROWS Z GetIntegerv 0 Value ofPACK_SKIP_ROWS 4.3.1
+
PACK SKIP PIXELS Z GetIntegerv 0 Value ofPACK_SKIP_PIXELS 4.3.1
+
Value ofPACK_ALIGNMENT
PACK ALIGNMENT Z GetIntegerv 4 4.3.1
+
PIXEL PACK BUFFER BINDING Z GetIntegerv 0 Pixel pack buffer binding 4.3.1
+
Pixel unpack buffer binding
PIXEL UNPACK BUFFER BINDING Z GetIntegerv 0 6.1.76.2. STATETABLES 262
Table 6.25. Shader Object State
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
SHADER TYPE Z GetShaderiv - Type of shader (vertex or fragment) 2.11.1
2
DELETE STATUS B GetShaderiv FALSE Shader ?agged for deletion 2.11.1
COMPILE STATUS B GetShaderiv FALSE Last compile succeeded 2.11.1
- S GetShaderInfoLog empty string Info log for shader objects 6.1.9
+
INFO LOG LENGTH Z GetShaderiv 0 Length of info log 6.1.9
- S GetShaderSource empty string Source code for a shader 2.11.1
+
SHADER SOURCE LENGTH Z GetShaderiv 0 Length of source code 6.1.96.2. STATETABLES 263
Table 6.26. Program Object State
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Name of current program
+
CURRENT PROGRAM Z GetIntegerv 0 2.11.2
object
DELETE STATUS B GetProgramiv FALSE Program object deleted 2.11.2
Last link attempt suc-
LINK STATUS B GetProgramiv FALSE 2.11.2
ceeded
Last validate attempt suc-
VALIDATE STATUS B GetProgramiv FALSE 2.11.2
ceeded
Number of attached
+
ATTACHED SHADERS Z GetProgramiv 0 6.1.9
shader objects
+
- 0Z GetAttachedShaders empty Shader objects attached 6.1.9
Info log for program ob-
- S GetProgramInfoLog empty 6.1.9
ject
+
INFO LOG LENGTH Z GetProgramiv 0 Length of info log 2.11.4
Number of active uni-
+
ACTIVE UNIFORMS Z GetProgramiv 0 2.11.4
forms
Location of active uni-
- 0Z GetUniformLocation – 6.1.9
forms
+
- 0Z GetActiveUniform – Size of active uniform 2.11.4
+
- 0Z GetActiveUniform – Type of active uniform 2.11.4
- 0char GetActiveUniform empty Name of active uniform 2.11.4
Maximum active uniform
+
ACTIVE UNIFORM MAX LENGTH Z GetProgramiv 0 6.1.9
name length
512R GetUniform 0 Uniform value 2.11.4
Number of active at-
+
ACTIVE ATTRIBUTES
Z GetProgramiv 0 2.11.3
tributes6.2. STATETABLES 264
Table 6.27. Program Object State (cont.)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
GetAttribLocation Location of active generic
- 0Z – 2.11.3
attribute
+
- 0Z GetActiveAttrib – Size of active attribute 2.11.3
+
- 0Z GetActiveAttrib – Type of active attribute 2.11.3
- 0char GetActiveAttrib empty Name of active attribute 2.11.3
Maximum active attribute
+
ACTIVE ATTRIBUTE MAX LENGTH Z GetProgramiv 0 6.1.9
name length
TRANSFORM FEEDBACK BUFFER - INTERLEAVED_- Transform feedback mode
Z GetProgramiv 6.1.9
2
MODE ATTRIBS for the program
TRANSFORM FEEDBACK VARY- Number of varyings to
+
Z GetProgramiv 0 6.1.9
INGS stream to buffer object(s)
TRANSFORM FEEDBACK VARY- Maximum transform feed-
+
Z GetProgramiv 0 6.1.9
ING MAX LENGTH back varying name length
GetTransform- Size of each transform
+
- Z - 2.11.6
FeedbackVarying feedback varying variable
GetTransform- Type of each transform
+
- Z - 2.11.6
FeedbackVarying feedback varying variable
GetTransform- Name of each transform
+
- -
0 char 2.11.6
FeedbackVarying feedback varying variable6.2. STATETABLES 265
Table 6.28. Program Object State (cont.)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Uniform buffer object
bound to the context for
+
UNIFORM BUFFER BINDING GetIntegerv 0
Z 2.11.4
buffer object manipula-
tion
Uniform buffer object
+
UNIFORM BUFFER BINDING nZ GetIntegeri v 0 bound to the speci?ed 2.11.4
context binding point
Number of active uni-
+
ACTIVE UNIFORM BLOCKS Z GetProgramiv 0 form blocks in a program 2.11.4
ACTIVE UNIFORM BLOCK MAX - Length of longest active
+
Z GetProgramiv 0 2.11.4
NAME LENGTH uniform block name
GetActiveUniformsiv
UNIFORM TYPE 0Z - Type of active uniform 2.11.4
27
GetActiveUniformsiv
+
UNIFORM SIZE 0Z - Size of active uniform 2.11.4
GetActiveUniformsiv
+
UNIFORM NAME LENGTH 0Z - Uniform name length 2.11.4
GetActiveUniformsiv
UNIFORM BLOCK INDEX 0Z - Uniform block index 2.11.4
GetActiveUniformsiv
UNIFORM OFFSET 0Z - Uniform buffer offset 2.11.46.2. STATETABLES 266
Table 6.29. Program Object State (cont.)
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
GetActiveUniformsiv Uniform buffer array
UNIFORM ARRAY STRIDE 0Z - 2.11.4
stride
GetActiveUniformsiv Uniform buffer intra-
UNIFORM MATRIX STRIDE 0Z - 2.11.4
matrix stride
GetActiveUniformsiv Whether uniform is a
+
UNIFORM IS ROW MAJOR 0Z - 2.11.4
row-major matrix
Uniform buffer binding
GetActive-
points associated with
+
UNIFORM BLOCK BINDING UniformBlockiv 0
Z 2.11.4
the speci?ed uniform
block
GetActive- Size of the storage
+
UNIFORM BLOCK DATA SIZE Z UniformBlockiv - needed to hold this 2.11.4
uniform block’s data
GetActive- Count of active uniforms
UNIFORM BLOCK ACTIVE UNI-
+
Z UniformBlockiv - in the speci?ed uniform 2.11.4
FORMS
block
GetActive- Array of active uniform
UNIFORM BLOCK ACTIVE UNI-
+
nZ UniformBlockiv - indices of the speci?ed 2.11.4
FORM INDICES
uniform block
GetActive- True if uniform block
UNIFORM BLOCK REFERENCED -
B UniformBlockiv 0 is actively referenced by 2.11.4
BY VERTEX SHADER
the vertex stage
GetActive- True if uniform block
UNIFORM BLOCK REFERENCED -
B UniformBlockiv 0 is actively referenced by 2.11.4
BY FRAGMENT SHADER
the fragment stage6.2. STATETABLES 267
Table 6.30. Vertex Shader State
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Current generic vertex attribute val-
4
CURRENT VERTEX ATTRIB 16R GetVertexAttribfv 0.0,0.0,0.0,1.0 2.7
ues
VERTEX PROGRAM POINT SIZE B IsEnabled FALSE Point size mode 3.46.2. STATETABLES 268
Table 6.31. Query Object State
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
+
QUERY RESULT Z GetQueryObjectuiv 0 Query object result 6.1.6
QUERY RESULT AVAILABLE B GetQueryObjectiv FALSE Is the query object result available? 6.1.66.2. STATETABLES 269
Table 6.32. Transform Feedback State
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Buffer object bound to
+
TRANSFORM FEEDBACK BUFFER BINDING Z GetIntegerv 0 generic bind point for 6.1.7
transform feedback
Buffer object bound to
+
TRANSFORM FEEDBACK BUFFER BINDING nxZ GetIntegeri v 0 each transform feedback 6.1.7
attribute stream
Start offset of binding
+
range for each transform
TRANSFORM FEEDBACK BUFFER START nxZ GetIntegeri v 0 6.1.7
feedback attrib. stream
Size of binding range for
+
TRANSFORM FEEDBACK BUFFER SIZE nZ GetIntegeri v 0 each transform feedback 6.1.7
attrib. stream
Max number of compo-
nents to write to a single
+
MAX TRANSFORM FEEDBACK INTERLEAVED COMPONENTS Z GetIntegerv 64 2.15
buffer in interleaved mode
Max number of separate at-
tributes or vayings that can
+
MAX TRANSFORM FEEDBACK SEPARATE ATTRIBS Z GetIntegerv 4 2.15
be captured in transform
feedback
Max number of compo-
+
nents per attribute or vary-
MAX TRANSFORM FEEDBACK SEPARATE COMPONENTS Z GetIntegerv 4 2.15
ing in separate mode6.2. STATETABLES 270
Table 6.33. Hints
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
LINE SMOOTH HINT Z GetIntegerv DONT_CARE Line smooth hint 5.2
3
Polygon smooth hint
POLYGON SMOOTH HINT Z GetIntegerv DONT_CARE 5.2
3
TEXTURE COMPRESSION HINT Z GetIntegerv DONT_CARE Texture compression quality hint 5.2
3
Fragment shader derivative accu-
FRAGMENT SHADER DERIVATIVE HINT Z GetIntegerv DONT_CARE 5.2
3
racy hint6.2. STATETABLES 271
Table 6.34. Implementation Dependent Values
OpenGL 3.1 - May 28, 2009
Get Minimum
Get value Type Command Value Description Sec.
Maximum number of user clipping
+
MAX CLIP DISTANCES Z GetIntegerv 8 2.17
planes
Number of bits of subpixel precision
+
SUBPIXEL BITS Z GetIntegerv 4 3
in screenx andy
w w
Maximum 3D texture image dimen-
+
MAX 3D TEXTURE SIZE Z GetIntegerv 256 3.8.1
sion
Maximum 2D/1D texture image di-
+
MAX TEXTURE SIZE Z GetIntegerv 1024 3.8.1
mension
Maximum number of layers for tex-
+
MAX ARRAY TEXTURE LAYERS Z GetIntegerv 256 3.8.1
ture arrays
Maximum absolute texture level of
+
MAX TEXTURE LOD BIAS R GetFloatv 2.0 3.8.8
detail bias
Maximum cube map texture image
+
MAX CUBE MAP TEXTURE SIZE Z GetIntegerv 1024 3.8.1
dimension
Maximum width and height of ren-
+
MAX RENDERBUFFER SIZE Z GetIntegerv 1024 4.4.2
derbuffers6.2. STATETABLES 272
Table 6.35. Implementation Dependent Values (cont.)
OpenGL 3.1 - May 28, 2009
Get Minimum
Get value Type Command Value Description Sec.
Maximum viewport
+
MAX VIEWPORT DIMS 2Z GetIntegerv see 2.12.1 2.12.1
dimensions
Range (lo to hi) of point
+
POINT SIZE RANGE 2R GetFloatv 1,1 3.4
sprite sizes
Point sprite size granular-
+
POINT SIZE GRANULARITY R GetFloatv – 3.4
ity6.2. STATETABLES 273
Table 6.36. Implementation Dependent Values (cont.)
OpenGL 3.1 - May 28, 2009
Get Minimum
Get value Type Command Value Description Sec.
Range (lo to hi) of aliased
+
ALIASED LINE WIDTH RANGE 2R GetFloatv 1,1 3.5
line widths
SMOOTH LINE WIDTH RANGE (v1.1: LINE WIDTH - Range (lo to hi) of an-
+
2R GetFloatv 1,1 3.5
RANGE) tialiased line widths
SMOOTH LINE WIDTH GRANULARITY (v1.1: LINE - Antialiased line width
+
R GetFloatv – 3.5
WIDTH GRANULARITY) granularity
Recommended
max. number of
+
MAX ELEMENTS INDICES GetIntegerv
Z – 2.8
DrawRangeElements
indices
Recommended
max. number of
+
MAX ELEMENTS VERTICES Z GetIntegerv – 2.8
DrawRangeElements
vertices
Enumerated compressed
+
COMPRESSED TEXTURE FORMATS 4Z GetIntegerv - 3.8.3
texture formats
Number of compressed
NUM COMPRESSED TEXTURE FORMATS Z GetIntegerv 4 3.8.3
texture formats
No. of addressable texels
+
MAX TEXTURE BUFFER SIZE Z GetIntegerv 65536 3.8.4
for buffer textures
Max. width & height of
+
MAX RECTANGLE TEXTURE SIZE Z GetIntegerv 1024 3.8.1
rectangular textures6.2. STATETABLES 274
Table 6.37. Implementation Dependent Values (cont.)
OpenGL 3.1 - May 28, 2009
Get Minimum
Get value Type Command Value Description Sec.
Asynchronous query
+
QUERY COUNTER BITS 3Z GetQueryiv see 6.1.6 6.1.6
counter bits
Supported individual ex-
EXTENSIONS GetStringi
0S – 6.1.4
tension names
Number of individual ex-
+
NUM EXTENSIONS Z GetIntegerv – 6.1.4
tension names
Major version number
+
MAJOR VERSION Z GetIntegerv – 6.1.4
supported
Minor version number
+
MINOR VERSION Z GetIntegerv – 6.1.4
supported
Context full/forward-
+
CONTEXT FLAGS Z GetIntegerv – 6.1.4
compatible ?ag
RENDERER S GetString – Renderer string 6.1.4
Shading Language ver-
SHADING LANGUAGE VERSION GetString
S – 6.1.4
sion supported
VENDOR S GetString – Vendor string 6.1.4
OpenGL version sup-
VERSION S GetString – 6.1.4
ported6.2. STATETABLES 275
Table 6.38. Implementation Dependent Values (cont.)
OpenGL 3.1 - May 28, 2009
Get Minimum
Get value Type Command Value Description Sec.
Number of active vertex
+
MAX VERTEX ATTRIBS Z GetIntegerv 16 2.7
attributes
Number of components
+
MAX VERTEX UNIFORM COMPONENTS Z GetIntegerv 1024 for vertex shader uniform 2.11.4
variables
Number of components
+
MAX VARYING COMPONENTS Z GetIntegerv 64 2.11.6
for varying variables
Total number of texture
+
MAX COMBINED TEXTURE IMAGE UNITS GetIntegerv units accessible by the
Z 32 2.11.7
GL
Number of texture image
+
MAX VERTEX TEXTURE IMAGE UNITS Z GetIntegerv 16 units accessible by a ver- 2.11.7
tex shader
Number of texture image
+
MAX TEXTURE IMAGE UNITS Z GetIntegerv 16 units accessible by frag- 2.11.7
ment processing
Number of components
+
MAX FRAGMENT UNIFORM COMPONENTS Z GetIntegerv 1024 for frag. shader uniform 3.9.1
variables
Minimum texel offset al-
MIN PROGRAM TEXEL OFFSET GetIntegerv
Z -8 2.11.7
lowed in lookup
Maximum texel offset al-
MAX PROGRAM TEXEL OFFSET Z GetIntegerv 7 2.11.7
lowed in lookup6.2. STATETABLES 276
Table 6.39. Implementation Dependent Values (cont.)
OpenGL 3.1 - May 28, 2009
Get Minimum
Get value Type Command Value Description Sec.
Max number of vertex
+
MAX VERTEX UNIFORM BLOCKS Z GetIntegerv 12 uniform buffers per pro- 2.11.4
gram
Max number of fragment
+
MAX FRAGMENT UNIFORM BLOCKS Z GetIntegerv 12 uniform buffers per pro- 2.11.4
gram
Max number of uniform
+
MAX COMBINED UNIFORM BLOCKS Z GetIntegerv 24 2.11.4
buffers per program
Max number of uniform
+
MAX UNIFORM BUFFER BINDINGS Z GetIntegerv 24 buffer binding points on 2.11.4
the context
Max size in basic ma-
+
MAX UNIFORM BLOCK SIZE Z GetIntegerv 16384 chine units of a uniform 2.11.4
block
Minimum required align-
+
UNIFORM BUFFER OFFSET ALIGNMENT Z GetIntegerv 1 ment for uniform buffer 2.11.4
sizes and offsets6.2. STATETABLES 277
Table 6.40. Implementation Dependent Values (cont.)
(1) The minimum value for each stage isMAX_stage_UNIFORM_BLOCKS
MAX_stage_UNIFORM_BLOCK_SIZE +MAX_stage_UNIFORM_COMPONENTS
OpenGL 3.1 - May 28, 2009
Get Minimum
Get value Type Command Value Description Sec.
Number of words for ver-
tex shader uniform vari-
+ 1
MAX VERTEX UNIFORM COMPONENTS Z GetIntegerv 2.11.4
ables in default uniform
block
Number of words for
fragment shader uniform
+ 1
MAX FRAGMENT UNIFORM COMPONENTS Z GetIntegerv 2.11.4
variables in default uni-
form block
Number of words for
vertex shader uniform
MAX COMBINED VERTEX UNIFORM COMPO-
+ 1
Z GetIntegerv variables in all uni- 2.11.4
NENTS
form blocks (including
default)
Number of words for
fragment shader uniform
MAX COMBINED FRAGMENT UNIFORM COMPO-
+ 1
Z GetIntegerv variables in all uni- 2.11.4
NENTS
form blocks (including
default)6.2. STATETABLES 278
Table 6.41. Framebuffer Dependent Values
OpenGL 3.1 - May 28, 2009
Get Minimum
Get value Type Command Value Description Sec.
Maximum number of active draw
+
MAX DRAW BUFFERS Z GetIntegerv 8 4.2.1
buffers
DOUBLEBUFFER B GetBooleanv – True if front & back buffers exist 4.2.1
STEREO B GetBooleanv – True if left & right buffers exist 6
+
SAMPLE BUFFERS Z GetIntegerv 0 Number of multisample buffers 3.3.1
+
SAMPLES Z GetIntegerv 0 Coverage mask size 3.3.1
Maximum number of FBO attach-
+
MAX COLOR ATTACHMENTS Z GetIntegerv 8 4.4.2
ment points for color buffers
Maximum number of samples sup-
+
MAX SAMPLES Z GetIntegerv 4 4.4.2
ported for multisampling6.2. STATETABLES 279
Table 6.42. Miscellaneous
OpenGL 3.1 - May 28, 2009
Get Initial
Get value Type Command Value Description Sec.
Current error code(s)
– nZ GetError 0 2.5
5
– nB – FALSE True if there is a corresponding error 2.5
B – FALSE Occlusion query active 4.1.6
+
CURRENT QUERY 3Z GetQueryiv 0 Active query object names 6.1.6
Buffer object bound to copy buffer
+
COPY READ BUFFER Z GetIntegerv 0 2.9.3
“read” bind point
Buffer object bound to copy buffer
+
COPY WRITE BUFFER Z GetIntegerv 0 2.9.3
“write” bind point
Buffer object bound to texture buffer
+
TEXTURE BUFFER Z GetIntegerv 0 3.8.13
bind pointAppendix A
Invariance
The OpenGL speci?cation is not pixel exact. It therefore does not guarantee an ex-
act match between images produced by different GL implementations. However,
the speci?cation does specify exact matches, in some cases, for images produced
by the same implementation. The purpose of this appendix is to identify and pro-
vide justi?cation for those cases that require exact matches.
A.1 Repeatability
The obvious and most fundamental case is repeated issuance of a series of GL com-
mands. For any given GL and framebuffer state vector, and for any GL command,
the resulting GL and framebuffer state must be identical whenever the command is
executed on that initial GL and framebuffer state.
One purpose of repeatability is avoidance of visual artifacts when a double-
buffered scene is redrawn. If rendering is not repeatable, swapping between two
buffers rendered with the same command sequence may result in visible changes
in the image. Such false motion is distracting to the viewer. Another reason for
repeatability is testability.
Repeatability, while important, is a weak requirement. Given only repeata-
bility as a requirement, two scenes rendered with one (small) polygon changed
in position might differ at every pixel. Such a difference, while within the law
of repeatability, is certainly not within its spirit. Additional invariance rules are
desirable to ensure useful operation.
280A.2. MULTI-PASSALGORITHMS 281
A.2 Multi-pass Algorithms
Invariance is necessary for a whole set of useful multi-pass algorithms. Such al-
gorithms render multiple times, each time with a different GL mode vector, to
eventually produce a result in the framebuffer. Examples of these algorithms in-
clude:
 “Erasing” a primitive from the framebuffer by redrawing it, either in a dif-
ferent color or using the XOR logical operation.
 Using stencil operations to compute capping planes.
On the other hand, invariance rules can greatly increase the complexity of high-
performance implementations of the GL. Even the weak repeatability requirement
signi?cantly constrains a parallel implementation of the GL. Because GL imple-
mentations are required to implement ALL GL capabilities, not just a convenient
subset, those that utilize hardware acceleration are expected to alternate between
hardware and software modules based on the current GL mode vector. A strong
invariance requirement forces the behavior of the hardware and software modules
to be identical, something that may be very dif?cult to achieve (for example, if the
hardware does ?oating-point operations with different precision than the software).
What is desired is a compromise that results in many compliant, high-
performance implementations, and in many software vendors choosing to port to
OpenGL.
A.3 Invariance Rules
For a given instantiation of an OpenGL rendering context:
Rule 1 For any given GL and framebuffer state vector, and for any given GL com-
mand, the resulting GL and framebuffer state must be identical each time the com-
mand is executed on that initial GL and framebuffer state.
Rule 2 Changes to the following state values have no side effects (the use of any
other state value is not affected by the change):
Required:
 Framebuffer contents (all bitplanes)
 The color buffers enabled for writing
 Scissor parameters (other than enable)
OpenGL 3.1 - May 28, 2009A.4. WHATALLTHISMEANS 282
 Writemasks (color, depth, stencil)
 Clear values (color, depth, stencil)
Strongly suggested:
 Stencil parameters (other than enable)
 Depth test parameters (other than enable)
 Blend parameters (other than enable)
 Logical operation parameters (other than enable)
 Pixel storage state
 Polygon offset parameters (other than enables, and except as they affect
the depth values of fragments)
Corollary 1 Fragment generation is invariant with respect to the state values
marked with in Rule 2.
Rule 3 The arithmetic of each per-fragment operation is invariant except with re-
spect to parameters that directly control it.
Corollary 2 Images rendered into different color buffers sharing the same frame-
buffer, either simultaneously or separately using the same command sequence, are
pixel identical.
Rule 4 The same vertex or fragment shader will produce the same result when
run multiple times with the same input. The wording ’the same shader’ means a
program object that is populated with the same source strings, which are compiled
and then linked, possibly multiple times, and which program object is then executed
using the same GL state vector.
Rule 5 All fragment shaders that either conditionally or unconditionally assign
gl_FragCoord.z to gl_FragDepth are depth-invariant with respect to each
other, for those fragments where the assignment to gl_FragDepth actually is
done.
A.4 What All This Means
Hardware accelerated GL implementations are expected to default to software op-
eration when some GL state vectors are encountered. Even the weak repeatability
requirement means, for example, that OpenGL implementations cannot apply hys-
teresis to this swap, but must instead guarantee that a given mode vector implies
OpenGL 3.1 - May 28, 2009A.4. WHATALLTHISMEANS 283
that a subsequent command always is executed in either the hardware or the soft-
ware machine.
The stronger invariance rules constrain when the switch from hardware to soft-
ware rendering can occur, given that the software and hardware renderers are not
pixel identical. For example, the switch can be made when blending is enabled or
disabled, but it should not be made when a change is made to the blending param-
eters.
Because ?oating point values may be represented using different formats in dif-
ferent renderers (hardware and software), many OpenGL state values may change
subtly when renderers are swapped. This is the type of state value change that Rule
1 seeks to avoid.
OpenGL 3.1 - May 28, 2009Appendix B
Corollaries
The following observations are derived from the body and the other appendixes of
the speci?cation. Absence of an observation from this list in no way impugns its
veracity.
1. The error semantics of upward compatible OpenGL revisions may change,
and features deprecated in a previous revision may be removed. Otherwise,
only additions can be made to upward compatible revisions.
2. GL query commands are not required to satisfy the semantics of the Flush
or the Finish commands. All that is required is that the queried state be con-
sistent with complete execution of all previously executed GL commands.
3. Application speci?ed point size and line width must be returned as speci?ed
when queried. Implementation-dependent clamping affects the values only
while they are in use.
4. The mask speci?ed as the third argument to StencilFunc affects the operands
of the stencil comparison function, but has no direct effect on the update of
the stencil buffer. The mask speci?ed by StencilMask has no effect on the
stencil comparison function; it limits the effect of the update of the stencil
buffer.
5. Polygon shading is completed before the polygon mode is interpreted. If the
shade model isFLAT, all of the points or lines generated by a single polygon
will have the same color.
6. There is no atomicity requirement for OpenGL rendering commands, even
at the fragment level.
284285
7. Because rasterization of non-antialiased polygons is point sampled, poly-
gons that have no area generate no fragments when they are rasterized in
FILL mode, and the fragments generated by the rasterization of “narrow”
polygons may not form a continuous array.
8. OpenGL does not force left- or right-handedness on any of its coordinates
systems.
9. (No pixel dropouts or duplicates.) Let two polygons share an identical edge
(that is, there exist vertices A and B of an edge of one polygon, and vertices
C and D of an edge of the other polygon, and the coordinates of vertex A
(resp. B) are identical to those of vertex C (resp. D), and the state of the the
coordinate transfomations is identical when A, B, C, and D are speci?ed).
Then, when the fragments produced by rasterization of both polygons are
taken together, each fragment intersecting the interior of the shared edge is
produced exactly once.
10. Dithering algorithms may be different for different components. In particu-
lar, alpha may be dithered differently from red, green, or blue, and an imple-
mentation may choose to not dither alpha at all.
OpenGL 3.1 - May 28, 2009Appendix C
Compressed Texture Image
Formats
C.1 RGTC Compressed Texture Image Formats
Compressed texture images stored using the RGTC compressed image encodings
are represented as a collection of 4 4 texel blocks, where each block contains
64 or 128 bits of texel data. The image is encoded as a normal 2D raster image in
which each 4 4 block is treated as a single pixel. If an RGTC image has a width
or height that is not a multiple of four, the data corresponding to texels outside
the image are irrelevant and unde?ned.
When an RGTC image with a width of w, height of h, and block size of block-
size (8 or 16 bytes) is decoded, the corresponding image size (in bytes) is:
w h
d ed eblocksize:
4 4
When decoding an RGTC image, the block containing the texel at offset (x;y)
begins at an offset (in bytes) relative to the base of the image of:
 
w y x
blocksize d eb c +b c :
4 4 4
The data corresponding to a speci?c texel (x;y) are extracted from a 44 texel
block using a relative (x;y) value of
(x mod 4;y mod 4):
There are four distinct RGTC image formats:
286C.1. RGTCCOMPRESSEDTEXTUREIMAGEFORMATS 287
C.1.1 FormatCOMPRESSED_RED_RGTC1
Each 4 4 block of texels consists of 64 bits of unsigned red image data.
Each red image data block is encoded as a sequence of 8 bytes, called (in order
of increasing address):
red ;red ;bits ;bits ;bits ;bits ;bits ;bits
0 1 0 1 2 3 4 5
The 6bits bytes of the block are decoded into a 48-bit bit vector:

bits =bits +256(bits + 256 (bits + 256 (bits + 256 (bits + 256bits ))))
0 1 2 3 4 5
red and red are 8-bit unsigned integers that are unpacked to red values
0 1
RED andRED
0 1
bits is a 48-bit unsigned integer, from which a three-bit control code is ex-
tracted for a texel at location (x;y) in the block using:
code(x;y) =bits [3 (4y +x) + 2::: 3 (4y +x) + 0]
where bit 47 is the most signi?cant and bit 0 is the least signi?cant bit.
The red valueR for a texel at location (x;y) in the block is given by:
8
>RED ; red >red ;code(x;y) = 0
0 0 1
>
>
>
>
>RED ; red >red ;code(x;y) = 1
1 0 1
>
>
>
6RED +RED
> 0 1
> red >red ;code(x;y) = 2
0 1
> 7;
>
>
5RED +2RED
> 0 1
> red >red ;code(x;y) = 3
0 1
>
7;
>
>
4RED +3RED
>
0 1
>
red >red ;code(x;y) = 4
0 1
>
7;
>
>
>3RED +4RED
0 1
>
red >red ;code(x;y) = 5
0 1
>
7;
>
>
>2RED +5RED
0 1
>
red >red ;code(x;y) = 6
> 0 1
7;
>
>
<
RED +6RED
0 1
red >red ;code(x;y) = 7
0 1
7;
R =
>
RED ; red red ;code(x;y) = 0
> 0 0 1
>
>
>
>
RED ; red red ;code(x;y) = 1
>
1 0 1
>
>
>
4RED +RED
0 1
>
red red ;code(x;y) = 2
> 0 1
5;
>
>
>3RED +2RED
0 1
>
red red ;code(x;y) = 3
>
0 1
> 5;
>
>
2RED +3RED
0 1
>
> red red ;code(x;y) = 4
0 1
5;
>
>
>
RED +4RED
0 1
>
red red ;code(x;y) = 5
>
0 1
> 5;
>
>
>
>RED ; red red ;code(x;y) = 6
min 0 1
>
>
:
RED ; red red ;code(x;y) = 7
max 0 1
OpenGL 3.1 - May 28, 2009C.1. RGTCCOMPRESSEDTEXTUREIMAGEFORMATS 288
RED andRED are 0.0 and 1.0 respectively.
min max
Since the decoded texel has a red format, the resulting RGBA value for the
texel is (R; 0; 0; 1).
C.1.2 FormatCOMPRESSED_SIGNED_RED_RGTC1
Each 4 4 block of texels consists of 64 bits of signed red image data. The red
values of a texel are extracted in the same way as COMPRESSED_RED_RGTC1 ex-
ceptred 0,red 1,RED 0,RED 1,RED , andRED are signed values
min max
de?ned as follows:
red andred are 8-bit signed (two’s complement) integers.
0 1
(
red
0
red > 128
0
127:0;
RED =
0
 1:0; red = 128
0
(
red
1
red > 128
1
127:0;
RED =
1
 1:0; red = 128
1
RED = 1:0
min
RED = 1:0
max
CAVEAT for signedred andred values: the expressionsred > red and
0 1 0 1
red red above are considered unde?ned (read: may vary by implementation)
0 1
whenred = 127 andred = 128. This is because ifred were remapped to
0 1 0
-127 prior to the comparison to reduce the latency of a hardware decompressor, the
expressions would reverse their logic. Encoders for the signed red-green formats
should avoid encoding blocks wherered = 127 andred = 128.
0 1
C.1.3 FormatCOMPRESSED_RG_RGTC2
Each 4 4 block of texels consists of 64 bits of compressed unsigned red image
data followed by 64 bits of compressed unsigned green image data.
The ?rst 64 bits of compressed red are decoded exactly like COMPRESSED_-
RED_RGTC1 above.
The second 64 bits of compressed green are decoded exactly like
COMPRESSED_RED_RGTC1 above except the decoded value R for this second
block is considered the resulting green valueG.
Since the decoded texel has a red-green format, the resulting RGBA value for
the texel is (R;G; 0; 1).
OpenGL 3.1 - May 28, 2009C.1. RGTCCOMPRESSEDTEXTUREIMAGEFORMATS 289
C.1.4 FormatCOMPRESSED_SIGNED_RG_RGTC2
Each 4 4 block of texels consists of 64 bits of compressed signed red image data
followed by 64 bits of compressed signed green image data.
The ?rst 64 bits of compressed red are decoded exactly like COMPRESSED_-
SIGNED_RED_RGTC1 above.
The second 64 bits of compressed green are decoded exactly like
COMPRESSED_SIGNED_RED_RGTC1 above except the decoded value R for this
second block is considered the resulting green valueG.
Since this image has a red-green format, the resulting RGBA value is
(R;G; 0; 1).
OpenGL 3.1 - May 28, 2009Appendix D
Shared Objects and Multiple
Contexts
State that can be shared between contexts includes pixel and vertex buffer objects,
program and shader objects, and texture objects (except for the texture objects
named zero).
Framebuffer, query, and vertex array objects are not shared.
D.1 Object Deletion Behavior
After an object is deleted, its name is immediately marked unused. Caution should
be taken when deleting an object attached to a container object (such as a buffer
object attached to a vertex array object, or a renderbuffer or texture attached to a
framebuffer object), or a shared object bound in multiple contexts. Following its
deletion, the object’s name may be returned by Gen* commands, even though
the underlying object state and data may still be referred to by container objects,
or in use by contexts other than the one in which the object was deleted. Such
a container or other context may continue using the object, and may still contain
state identifying its name as being currently bound, until such time as the container
object is deleted, the attachment point of the container object is changed to refer to
another object, or another attempt to bind or attach the name is made in that context.
Since the name is marked unused, binding the name will create a new object with
the same name, and attaching the name will generate an error. The underlying
storage backing a deleted object will not be reclaimed by the GL until all references
to the object from container object attachment points or context binding points are
removed.
290D.2. PROPAGATINGSTATECHANGES 291
D.2 Propagating State Changes
Data is information the GL implementation does not have to inspect, and does not
have an operational effect. Currently, data consists of:
 Pixels in the framebuffer.
 The contents of textures and renderbuffers.
 The contents of buffer objects.
State determines the con?guration of the rendering pipeline and the driver does
have to inspect.
In hardware-accelerated GL implementations, state typically lives in GPU reg-
isters, while data typically lives in GPU memory.
When the state of an object T is changed, such changes are not always imme-
diately visible, and do not always immediately affect GL operations involving that
object. Changes to an object may occur via any of the following means:
 State-setting commands, such as TexParameter.
 Data-setting commands, such as TexSubImage* or BufferSubData.
 Data-setting through rendering to attached renderbuffers or transform feed-
back operations.
 Commands that affect both state and data, such as TexImage* and Buffer-
Data.
 Changes to mapped buffer data followed by a command such as Unmap-
Buffer or FlushMappedBufferRange.
The object T is considered to have been changed once such a command has
1
completed. Completion of a command may be determined only by calling Fin-
ish.
1
The GL already speci?es that a single context processes commands in the order they are received.
This means that a change to an object in a context at time t must be completed by the time a command
issued in the same context at timet+1 uses the result of that change.
OpenGL 3.1 - May 28, 2009D.2. PROPAGATINGSTATECHANGES 292
D.2.1 De?nitions
In the remainder of this section, the following terminology is used:
 An object T is directly attached to the current context if it has been bound to
one of the context binding points. Examples include but are not limited to
bound textures, bound framebuffers, bound vertex arrays, and current pro-
grams.
 T is indirectly attached to the current context if it is attached to another ob-
ject C, referred to as a container object, and C is itself directly or indirectly
attached. Examples include but are not limited to renderbuffers or textures
attached to framebuffers; buffers attached to vertex arrays; and shaders at-
tached to programs.
 An object T which is directly attached to the current context may be re-
attached by re-binding T at the same bind point. An object T which is indi-
rectly attached to the current context may be re-attached by re-attaching the
container object C to which T is attached.
Corollary: re-binding C to the current context re-attaches C and its hierarchy
of contained objects.
D.2.2 Rules
The following rules must be obeyed by all GL implementations:
Rule 1 If the state of object T is changed in the current context while T is directly
or indirectly attached, then all operations on T will use that new state in the current
context.
Note: The intent of this rule is to address state changes in a single context only.
The multi-context case is handled by the other rules.
Note: “Updates” via rendering or transform feedback are treated consistently
with update via GL commands. Once EndTransformFeedback has been issued,
any command in the same context that uses the results of the transform feedback
operation will see the results. If a feedback loop is setup between rendering and
transform feedback (see above), results will be unde?ned.
Rule 2 While a container object C is bound, any changes made to C’s attachments
in the current context are guaranteed to be seen. To guarantee seeing changes
made in another context to objects attached to C must be completed in that other
context (by calling Finish) prior to C being bound. Changes made in another
OpenGL 3.1 - May 28, 2009D.2. PROPAGATINGSTATECHANGES 293
context without calling Finish, or after C is bound in the current context, are not
guaranteed to be seen.
Rule 3 State changes to shared objects are not automatically propagated between
contexts. If the state of a shared object T is changed in a context other than the
current context, and T is already directly or indirectly attached to the current con-
text, any operations on the current context involving T via those attachments are
not guaranteed to use its new state.
Rule 4 If the state of a shared object T is changed in a context other than the cur-
rent context, and T is already directly or indirectly attached to the current context
at multiple attachment or bind points, it must be attached or re-attached to at least
one binding point in the current context in order for the new state of T to be visible
in the current context.
Note: “Attached or re-attached” means either attaching an object to a binding
point it wasn’t already attached to, or attaching an object again to a binding point
it was already attached.
Note: This rule also applies to the pointer to the data store of an object. The
pointer itself is state, while the content of the data store are data, not state. To
guarantee that another context sees data updates to an object, you should attach
or re-attach the object in that context, since the pointer to the data store could have
changed.
Note: To be sure that a data update, as the result of a transform-feedback
operation in another context, is visible in the current context, the app needs to make
sure that the command EndTransformFeedback has completed (using Finish).
Example: If a texture image is bound to multiple texture bind points and the
texture is modi?ed in another context, re-binding the texture at any one of the tex-
ture bind points is suf?cient to cause the modi?cations to be visible at all texture
bind points.
OpenGL 3.1 - May 28, 2009Appendix E
The Deprecation Model
OpenGL 3.0 introduces a deprecation model in which certain features may be
marked as deprecated. Deprecated features are expected to be completely removed
from a future version of OpenGL. Deprecated features are summarized in sec-
tion E.1.
To aid developers in writing applications which will run on such future ver-
sions, it is possible to create an OpenGL 3.0 context which does not support dep-
recated features. Such a context is called a forward compatible context, while a
context supporting all OpenGL 3.0 features is called a full context. Forward com-
patible contexts cannot restore deprecated functionality through extensions, but
they may support additional, non-deprecated functionality through extensions.
Pro?les allow de?ning subsets of OpenGL functionality targeted to speci?c ap-
plication domains. While OpenGL 3.0 only de?nes a single pro?le, future versions
may introduce pro?les addressing domains such as workstation, gaming, and em-
bedded. Implementations are not required to support all de?ned pro?les, but must
support at least one pro?le.
To enable application control of deprecation and pro?les, new context creation
APIs have been de?ned as extensions to GLX and WGL. These APIs allow spec-
ifying a particular version, pro?le, and full or forward compatible status, and will
either create a context compatible with the request, or fail (if, for example, request-
ing an OpenGL version or pro?le not supported by the implementation),
Only the ARB may de?ne OpenGL pro?les and deprecated features.
E.1 Pro?les and Deprecated Features of OpenGL 3.0
OpenGL 3.0 de?nes a single pro?le, and all OpenGL 3.0 implementations must
support that pro?le.
294E.1. PROFILESANDDEPRECATEDFEATURESOFOPENGL3.0 295
The features deprecated in OpenGL 3.0 are summarized below, together with
the sections of the speci?cation in which they are de?ned. Functions which are
completely deprecated will generate an INVALID_OPERATION error if called in
a forward-compatible context. Functions which are partially deprecated (e.g. no
longer accept some parameter values) will generate the errors appropriate for any
other unrecognized value of that parameter when a deprecated value is passed in a
forward-compatible context.
 Application-generated object names - the names of all object types, such as
buffer, query, and texture objects, must be generated using the correspond-
ing Gen* commands. Trying to bind an object name not returned by a Gen*
command will result in an INVALID_OPERATION error. This behavior is
already the case for framebuffer, renderbuffer, and vertex array objects. Ob-
ject types which have default objects (objects named zero) , such as vertex
array, framebuffer, and texture objects, may also bind the default object, even
though it is not returned by Gen*.
 Color index mode - No color index visuals are supplied by the window
system-binding APIs such as GLX and WGL, so the default framebuffer
is always in RGBA mode. All language and state related to color index
mode vertex, rasterization, and fragment processing behavior is removed.
COLOR_INDEX formats are also deprecated.
 OpenGL Shading Language versions 1.10 and 1.20. These versions of the
shading language depend on many API features that have also been depre-
cated.
 Begin / End primitive speci?cation - Begin, End, and EdgeFlag*; Color*,
FogCoord*, Index*, Normal3*, SecondaryColor3*, TexCoord*, Vertex*
Vertex*; and all associated state. Vertex arrays and array drawing com-
mands must be used to draw primitives. However, VertexAttrib* and the
current vertex attribute state are retained in order to provide default attribute
values for disabled attribute arrays.
 Edge ?ags and ?xed-function vertex processing - ColorPointer, EdgeFlag-
Pointer, FogCoordPointer, IndexPointer, NormalPointer, Secondary-
ColorPointer, TexCoordPointer, VertexPointer, EnableClientState, Dis-
ableClientState, and InterleavedArrays, ClientActiveTexture; Frus-
tum, LoadIdentity, LoadMatrix, LoadTransposeMatrix, MatrixMode,
MultMatrix, MultTransposeMatrix, Ortho, PopMatrix, PushMatrix,
Rotate, Scale, and Translate; Enable/Disable targets RESCALE_NORMAL
OpenGL 3.1 - May 28, 2009E.1. PROFILESANDDEPRECATEDFEATURESOFOPENGL3.0 296
and NORMALIZE; TexGen* and Enable/Disable targets TEXTURE_-
GEN_ , Material*, Light*, LightModel*, and ColorMaterial, Shade-
*
Model, and Enable/Disable targetsLIGHTING.VERTEX_PROGRAM_TWO_-
SIDE, LIGHTi, and COLOR_MATERIAL; ClipPlane; and all associated
?xed-function vertex array, multitexture, matrix and matrix stack, normal
and texture coordinate, lighting, and clipping state. A vertex shader must be
de?ned in order to draw primitives.
Language referring to edge ?ags in the current speci?cation is modi?ed as
though all edge ?ags areTRUE.
Note that the FrontFace and ClampColor commands are not deprecated,
as they still affect other non-deprecated functionality; however, the Clam-
pColor targetsCLAMP_VERTEX_COLOR andCLAMP_FRAGMENT_COLOR are
deprecated.
 Client vertex and index arrays - all vertex array attribute and element array
index pointers must refer to buffer objects. The default vertex array object
(the name zero) is also deprecated. Calling VertexAttribPointer when no
buffer object or no vertex array object is bound will generate anINVALID_-
OPERATION error, as will calling any array drawing command when no ver-
tex array object is bound.
 Rectangles - Rect*.
 Current raster position - RasterPos* and WindowPos*, and all associated
state.
 Two-sided color selection - Enable target VERTEX_PROGRAM_TWO_-
SIDE; OpenGL Shading Language builtins gl_BackColor and gl_-
BackSecondaryColor; and all associated state.
 Non-sprite points - Enable/Disable targets POINT_SMOOTH and POINT_-
SPRITE, and all associated state. Point rasterization is always performed as
thoughPOINT_SPRITE were enabled.
 Wide lines and line stipple - LineWidth is not deprecated, but values greater
than 1.0 will generate an INVALID_VALUE error; LineStipple and En-
able/Disable target LINE_STIPPLE, and all associated state.
 Quadrilateral and polygon primitives - vertex array drawing modes
POLYGON, QUADS, and QUAD_STRIP, related descriptions of rasterization
of non-triangle polygons, and all associated state.
OpenGL 3.1 - May 28, 2009E.1. PROFILESANDDEPRECATEDFEATURESOFOPENGL3.0 297
 Separate polygon draw mode - PolygonMode face values of FRONT and
BACK; polygons are always drawn in the same mode, no matter which face
is being rasterized.
 Polygon Stipple - PolygonStipple and Enable/Disable target POLYGON_-
STIPPLE, and all associated state.
 Pixel transfer modes and operations - all pixel transfer modes, including
pixel maps, shift and bias, color table lookup, color matrix, and convolu-
tion commands and state, and all associated state and commands de?ning
that state.
 Pixel drawing - DrawPixels and PixelZoom. However, the language de-
scribing pixel rectangles in section 3.7 is retained as it is required for Tex-
Image* and ReadPixels.
 Bitmaps - Bitmap and theBITMAP external format.
 Legacy OpenGL 1.0 pixel formats - the values 1, 2, 3, and 4 are no longer
accepted as internal formats by TexImage* or any other command taking
an internal format argument. The initial internal format of a texel array is
RGBA instead of 1. TEXTURE_COMPONENTS is deprecated; always use
TEXTURE_INTERNAL_FORMAT.
 Legacy pixel formats - all ALPHA, LUMINANCE, LUMINANCE_ALPHA, and
INTENSITY external and internal formats, including compressed, ?oating-
point, and integer variants; all references to luminance and intensity formats
elsewhere in the speci?cation, including conversion to and from those for-
mats; and all associated state. including state describing the allocation or
format of luminance and intensity texture or framebuffer components.
 Depth texture mode - DEPTH_TEXTURE_MODE. Section 3.8.14 is to be
changed so thatr is returned to texture samplers directly, and the OpenGL
Shading Language 1.30 Specification is to be changed so that (r;r;r; 1) is
always returned from depth texture samplers in this case.
 Texture wrap mode CLAMP - CLAMP is no longer accepted as a value of
texture parameters TEXTURE_WRAP_S, TEXTURE_WRAP_T, or TEXTURE_-
WRAP_R.
 Texture borders - the border value to TexImage* must always be zero, or
an INVALID_VALUE error is generated (section 3.8.1); all language in sec-
tion 3.8 referring to nonzero border widths during texture image speci?cation
and texture sampling; and all associated state.
OpenGL 3.1 - May 28, 2009E.1. PROFILESANDDEPRECATEDFEATURESOFOPENGL3.0 298
 Automatic mipmap generation - TexParameter* target GENERATE_-
MIPMAP, and all associated state.
 Fixed-function fragment processing - AreTexturesResident, Prioritize-
Textures, and TexParameter target TEXTURE_PRIORITY; TexEnv target
TEXTURE_ENV, and all associated parameters; TexEnv target TEXTURE_-
FILTER_CONTROL, and parameter nameTEXTURE_LOD_BIAS; Enable tar-
gets of all dimensionalities (TEXTURE_1D, TEXTURE_2D, TEXTURE_3D,
TEXTURE_1D_ARRAY, TEXTURE_2D_ARRAY, and TEXTURE_CUBE_MAP);
Enable target COLOR_SUM; Enable target FOG, Fog, and all associated pa-
rameters; the implementation-dependent values MAX_TEXTURE_UNITS and
MAX_TEXTURE_COORDS; and all associated state.
 Alpha test - AlphaFunc and Enable/Disable target ALPHA_TEST, and all
associated state.
 Accumulation buffers - ClearAccum, andACCUM_BUFFER_BIT is not valid
as a bit in the argument to Clear (section 4.2.3); Accum; the ACCUM_ _-
*
BITS framebuffer state describing the size of accumulation buffer compo-
nents; and all associated state.
Window system-binding APIs such as GLX and WGL may choose to either
not expose window con?gs containing accumulation buffers, or to ignore
accumulation buffers when the default framebuffer bound to a GL context
contains them.
 Pixel copying - CopyPixels (the comments also applying to CopyTexImage
will be moved to section 3.8.2).
 Auxiliary color buffers, includingAUXi targets of the default framebuffer.
 Context framebuffer size queries - RED_BITS, GREEN_BITS, BLUE_BITS,
ALPHA_BITS,DEPTH_BITS, andSTENCIL_BITS.
 Evaluators - Map*, EvalCoord*, MapGrid*, EvalMesh*, EvalPoint*, and
all evaluator map enables, and all associated state.
 Selection and feedback modes - RenderMode, InitNames, PopName,
PushName, LoadName, and SelectBuffer; FeedbackBuffer and
PassThrough; and all associated state.
 Display lists - NewList, EndList, CallList, CallLists, ListBase, GenLists,
IsList, and DeleteLists; all references to display lists and behavior when
OpenGL 3.1 - May 28, 2009E.1. PROFILESANDDEPRECATEDFEATURESOFOPENGL3.0 299
compiling commands into display lists elsewhere in the speci?cation; and all
associated state.
 Hints - the PERSPECTIVE_CORRECTION_HINT, POINT_SMOOTH_HINT,
FOG_HINT, andGENERATE_MIPMAP_HINT targets to Hint (section 5.2).
 Attribute stacks - PushAttrib, PushClientAttrib, PopAttrib, Pop-
ClientAttrib, the MAX_ATTRIB_STACK_DEPTH, MAX_CLIENT_ATTRIB_-
STACK_DEPTH, ATTRIB_STACK_DEPTH, andCLIENT_ATTRIB_STACK_-
DEPTH state, the client and server attribute stacks, and the values ALL_-
ATTRIB_BITS and CLIENT_ALL_ATTRIB_BITS.
 Uni?ed extension string -EXTENSIONS target to GetString.
 Token names and queries - all token names and queries not otherwise men-
tioned above for deprecated state, as well as all query entry points where all
valid targets of that query are deprecated state (chapter 6 and the state tables)
OpenGL 3.1 - May 28, 2009Appendix F
Version 3.0 and Before
OpenGL version 3.0, released on August 11, 2008, is the eighth revision since
the original version 1.0. When using a full 3.0 context, OpenGL 3.0 is upward
compatible with earlier versions, meaning that any program that runs with a 2.1 or
earlier GL implementation will also run unchanged with a 3.0 GL implementation.
OpenGL 3.0 context creation is done using a window system binding API, and
on most platforms a new command, de?ned by extensions introduced along with
OpenGL 3.0, must be called to create a 3.0 context. Calling the older context
creation commands will return an OpenGL 2.1 context. When using a forward
compatible context, many OpenGL 2.1 features are not supported.
Following are brief descriptions of changes and additions to OpenGL 3.0. De-
scriptions of changes and additions in earlier versions of OpenGL (versions 1.1,
1.2, 1.2.1, 1.3, 1.4, 1.5, 2.0, and 2.1) are omitted in this speci?cation, but may be
found in the OpenGL 3.0 Specification, available on the World Wide Web at URL
http://www.opengl.org/registry/
F.1 New Features
New features in OpenGL 3.0, including the extension or extensions if any on which
they were based, include:
 API support for the new texture lookup, texture format, and integer and un-
signed integer capabilities of the OpenGL Shading Language 1.30 speci?ca-
tion (GL_EXT_gpu_shader4).
 Conditional rendering (GL_NV_conditional_render).
300F.2. DEPRECATIONMODEL 301
 Fine control over mapping buffer subranges into client space and ?ushing
modi?ed data (GL_APPLE_flush_buffer_range).
 Floating-point color and depth internal formats for textures and ren-
derbuffers (GL_ARB_color_buffer_float, GL_NV_depth_buffer_-
float, GL_ARB_texture_float, GL_EXT_packed_float, and GL_-
EXT_texture_shared_exponent).
 Framebuffer objects (GL_EXT_framebuffer_object).
 Half-?oat (16-bit) vertex array and pixel data formats (GL_NV_half_float
andGL_ARB_half_float_pixel).
 Multisample stretch blit functionality (GL_EXT_framebuffer_-
multisample andGL_EXT_framebuffer_blit).
 Non-normalized integer color internal formats for textures and renderbuffers
(GL_EXT_texture_integer).
 One- and two-dimensional layered texture targets (GL_EXT_texture_-
array).
 Packed depth/stencil internal formats for combined depth+stencil textures
and renderbuffers (GL_EXT_packed_depth_stencil).
 Per-color-attachment blend enables and color writemasks (GL_EXT_draw_-
buffers2).
 RGTC speci?c internal compressed formats
(GL_EXT_texture_compression_rgtc).
 Single- and double-channel (R andRG) internal formats for textures and ren-
derbuffers.
 Transform feedback (GL_EXT_transform_feedback).
 Vertex array objects (GL_APPLE_vertex_array_object).
 sRGB framebuffer mode (GL_EXT_framebuffer_sRGB)
F.2 Deprecation Model
OpenGL 3.0 introduces a deprecation model in which certain features may be
marked as deprecated. The deprecation model is described in detail in appendix E,
together with a summary of features deprecated in OpenGL 3.0.
OpenGL 3.1 - May 28, 2009F.3. CHANGEDTOKENS 302
New Token Name Old Token Name
COMPARE_REF_TO_TEXTURE COMPARE_R_TO_TEXTURE
MAX_VARYING_COMPONENTS MAX_VARYING_FLOATS
MAX_CLIP_DISTANCES MAX_CLIP_PLANES
CLIP_DISTANCEi CLIP_PLANEi
Table F.1: New token names and the old names they replace.
F.3 Changed Tokens
New token names are introduced to be used in place of old, inconsistent names.
However, the old token names continue to be supported, for backwards compati-
bility with code written for previous versions of OpenGL. The new names, and the
old names they replace, are shown in table F.1.
F.4 Change Log
Minor corrections to the OpenGL 3.0 Specification were made after its initial re-
lease.
Changes in the draft of September 23, 2008:
 Changed ClearBuffer* in section 4.2.3 to use DEPTH and STENCIL
buffer names. Changed GetFramebufferAttachmentParameteriv in sec-
tion 6.1.10 to accept only DEPTH and STENCIL to identify default frame-
buffer depth and stencil buffers, and only DEPTH_ATTACHMENT and
STENCIL_ATTACMENT to identify framebuffer object depth and stencil
buffers (bug 3744).
Changes in the draft of September 18, 2008:
 Added missing close-brace to ArrayElement pseudocode in section 2.8
(bug 3897).
 Noted in section 2.13 that BeginQuery will generate an INVALID_-
OPERATION error when called with an existing query object name whose
type does not match the speci?ed target (bug 3712).
 Add description of gl_ClipDistance to shader outputs in section 2.11.7
and note that only one ofgl_ClipVertex andgl_ClipDistance should
be written by a shader (bug 3898).
OpenGL 3.1 - May 28, 2009F.4. CHANGELOG 303
 Changed ClearBuffer* in section 4.2.3 to indirect through the draw
buffer state by specifying the buffer type and draw buffer number, rather
than the attachment name; also changed to accept DEPTH_BUFFER /
DEPTH_ATTACHMENT andSTENCIL_BUFFER /STENCIL_ATTACHMENT in-
terchangeably, to reduce inconsistency between clearing the default frame-
buffer and framebuffer objects. Likewise changed GetFramebufferAttach-
mentParameteriv in section 6.1.10 to accept DEPTH_BUFFER / DEPTH_-
ATTACHMENT andSTENCIL_BUFFER /STENCIL_ATTACMENT interchange-
ably (bug 3744).
 Add proper type suf?x to query commands in tables 6.3 and 6.30 (Mark
Kilgard).
 Update deprecation list in section E.1 to itemize deprecated state for two-
sided color selection and include per-texture-unit LOD bias (bug 3735).
Changes in the draft of August 28, 2008:
 Sections 2.9, 2.9.1; tables 2.6, 2.7, and 6.6 - move buffer map/unmap
calls into their own subsection and rewrite MapBuffer in terms of Map-
BufferRange. Add buffer stateBUFFER_ACCESS_FLAGS,BUFFER_MAP_-
OFFSET,BUFFER_MAP_LENGTH. Make MapBuffer and MapBufferRange
errors consistent (bug 3601).
 Section 2.10 - Extend INVALID_OPERATION error to any array pointer-
setting command called to specify a client array while a vertex array object
is bound, not just VertexAttrib*Pointer (bug 3696).
 Sections 2.12.1, 4.1.2, 4.2.1, and 4.3.3 - de?ne initial state when a context is
bound with no default framebuffer - null viewport and scissor region, draw
buffer = read buffer =NONE, max viewport dims = max(display size - if any,
max renderbuffer size). Viewport/scissor language added to the GLX and
WGL create context extension specs as well (bug 2941).
 Section 2.15 - de?ne “word-aligned” to be a multiple of 4 (e.g. 32 bits) (bug
3624).
 Section 6.1.7 - Moved GetBufferParameteriv query from section 6.1.3
and changed formal argument specifying the parameter name from value
to pname (side effect of bug 3697).
 Section 6.1.10 - Moved GetFramebufferAttachmentiv query from sec-
tion 6.1.3. Querying framebuffer attachment parameters other than object
OpenGL 3.1 - May 28, 2009F.5. CREDITSANDACKNOWLEDGEMENTS 304
type and name when no attachment is present is an INVALID_ENUM error.
Querying texture parameters (level, cube map face, or layer) for a render-
buffer attachment is also anINVALID_ENUM error (note that this was allowed
in previous versions of the extension but the return values were not speci?ed;
it should clearly be an error as are other parameters that don’t exist for the
type of attachment present). Also reorganized the description of this com-
mand quite a bit to improve readability and remove redundancy and internal
inconsistencies (bug 3697).
 Section 6.1.11 - Moved GetRenderbufferParameteriv query from sec-
tion 6.1.3 (side effect of bug 3697).
 Appendix D.1 - add language to clarify that attachments to an object affect
its reference count, and that object storage doesn’t go away until there are no
references remaining (bug 3725).
 Appendix E.1 - removeTEXTURE_BORDER_COLOR andCLAMP_TO_BORDER
mode from the deprecated feature list; they were put in by accident (bug
3750).
 Appendix F - Cite GL_EXT_texture_array instead of GL_EXT_-
geometry_shader4 as the source of 1D/2D array texture functionality. Fix
a typo. Add change log relative to initial 3.0 spec release.
F.5 Credits and Acknowledgements
OpenGL 3.0 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 3.0, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including speci?c functionality developed in the form of
new ARB extensions together with OpenGL 3.0. In addition, many people partic-
ipated in developing earlier vendor andEXT extensions on which the OpenGL 3.0
functionality is based in part; those individuals are listed in the respective extension
speci?cations in the OpenGL Extension Registry.
Aaftab Munshi, Apple
Alain Bouchard, Matrox
Alexis Mather, AMD (Chair, ARB Marketing TSG)
Andreas Wolf, AMD
Avi Shapira, Graphic Remedy
OpenGL 3.1 - May 28, 2009F.5. CREDITSANDACKNOWLEDGEMENTS 305
Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
Benjamin Lipchak, AMD
Benji Bowman, Imagination Technologies
Bill Licea-Kane, AMD (Chair, ARB Shading Language TSG)
Bob Beretta, Apple
Brent Insko, Intel
Brian Paul, Tungsten Graphics
Bruce Merry, ARM (Detailed speci?cation review)
Cass Everitt, NVIDIA
Chris Dodd, NVIDIA
Daniel Horowitz, NVIDIA
Daniel Koch, Transgaming (Framebuffer objects, half ?oat vertex formats, and
instanced rendering)
Daniel Omachi, Apple
Dave Shreiner, ARM
Eric Boumaour, AMD
Eskil Steenberg, Obsession
Evan Hart, NVIDIA
Folker Schamel, Spinor GMBH
Gavriel State, Transgaming
Geoff Stahl, Apple
Georg Kolling, Imagination Technologies
Gregory Prisament, NVIDIA
Guillaume Portier, HI Corp
Ian Romanick, IBM / Intel (Vertex array objects; GLX protocol)
James Helferty, Transgaming (Instanced rendering)
James Jones, NVIDIA
Jamie Gennis, NVIDIA
Jason Green, Transgaming
Jeff Bolz, NVIDIA
Jeff Juliano, NVIDIA
Jeremy Sandmel, Apple (Chair, ARB Nextgen (OpenGL 3.0) TSG)
John Kessenich, Intel (OpenGL Shading Language Specification Editor; depre-
cation model)
John Rosasco, Apple
Jon Leech, Independent (Chair, ARB Ecosystem TSG; OpenGL API Speci?ca-
tion Editor; R/RG image formats and new context creation APIs)
Marc Olano, U. Maryland
Mark Callow, HI Corp
Mark Kilgard, NVIDIA (Many extensions on which OpenGL 3.0 features were
OpenGL 3.1 - May 28, 2009F.5. CREDITSANDACKNOWLEDGEMENTS 306
based)
Matti Paavola, Nokia
Michael Gold, NVIDIA (Framebuffer objects and instanced rendering)
Neil Trevett, NVIDIA (President, Khronos Group)
Nick Burns, Apple
Nick Haemel, AMD
Pat Brown, NVIDIA (Many extensions on which OpenGL 3.0 features were
based; detailed speci?cation review)
Paul Martz, SimAuthor
Paul Ramsey, Sun
Pierre Boudier, AMD (Floating-point depth buffers)
Rob Barris, Blizzard (Framebuffer object and map buffer range)
Robert Palmer, Symbian
Robert Simpson, AMD
Steve Demlow, Vital Images
Thomas Roell, NVIDIA
Timo Suoranta, Futuremark
Tom Longo, AMD
Tom Olson, TI (Chair, Khronos OpenGL ES Working Group)
Travis Bryson, Sun
Yaki Tebeka, Graphic Remedy
Yanjun Zhang, S3 Graphics
Zack Rusin, Tungsten Graphics
The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.
OpenGL 3.1 - May 28, 2009Appendix G
Version 3.1
OpenGL version 3.1, released on March 24, 2009, is the ninth revision since the
original version 1.0.
Unlike earlier versions of OpenGL, OpenGL 3.1 is not upward compatible with
earlier versions. The commands and interfaces identi?ed as deprecated in OpenGL
3.0 (see appendix F) have been removed from OpenGL 3.1 entirely, with the
following exception:
 Wide lines have not been removed, and calling LineWidth with values
greater than 1.0 is not an error.
Implementations may restore such removed features using the GL_ARB_-
compatibility extension discussed in section G.2.
Following are brief descriptions of changes and additions to OpenGL 3.1.
G.1 New Features
New features in OpenGL 3.1, including the extension or extensions if any on which
they were based, include:
 Support for OpenGL Shading Language 1.30 and 1.40.
 Instanced rendering with a per-instance counter accessible to vertex shaders
(GL_ARB_draw_instanced).
 Data copying between buffer objects (GL_ARB_copy_buffer).
 Primitive restart (GL_NV_primitive_restart). Because client en-
able/disable no longer exists in OpenGL 3.1, the PRIMITIVE_RESTART
307G.2. DEPRECATIONMODEL 308
state has become server state, unlike the NV extension where it is client
state. As a result, the numeric values assigned toPRIMITIVE_RESTART and
PRIMITIVE_RESTART_INDEX differ from theNV versions of those tokens.
 At least 16 texture image units must be accessible to vertex shaders, in addi-
tion to the 16 already guaranteed to be accessible to fragment shaders.
 Texture buffer objects (GL_ARB_texture_buffer_object).
 Rectangular textures (GL_ARB_texture_rectangle).
 Uniform buffer objects (GL_ARB_uniform_buffer_object).
 Signed normalized texture component formats.
G.2 Deprecation Model
The features marked as deprecated in OpenGL 3.0 (see section E) have been re-
moved from OpenGL 3.1 (with the exception of line widths greater than one, which
are retained).
As described by the deprecation model, features removed from OpenGL 3.0
have been moved into the new extensionGL_ARB_compatibility. If an imple-
mentation chooses to provide this extension, it restores all features deprecated by
OpenGL 3.0 and removed from OpenGL 3.1. This extension may only be provided
in an OpenGL 3.1 or later context version.
Because of the complexity of describing this extension relative to the OpenGL
3.1 core speci?cation, it is not written up as a separate document, unlike other ex-
tensions in the extension registry. Instead, an alternate version of this speci?cation
document has been generated with the deprecated material still present, but marked
in a distinct color.
No additional features are deprecated in OpenGL 3.1.
G.3 Change Log
Changes in the speci?cation update of May 28, 2009:
 Update MAX_CLIP_DISTANCES from 6 to 8 in section 2.17 and table 6.34,
to match GLSL (bug 4803).
 Accept null pointers in CompressedTexImage* (section 3.8.3) and treat
them the same as for the corresponding TexImage* commands (bug 4863).
OpenGL 3.1 - May 28, 2009G.4. CREDITSANDACKNOWLEDGEMENTS 309
 Relax error conditions when specifying RGTC format texture images (sec-
tion 3.8.2) and subimages (section 3.8.3) so that non-power-of-two RGTC
images may be speci?ed (also see section C.1), and edits to partial tiles at
the edge of such an image made (bug 4856).
 Relaxed texture magni?cation switch-over point calculation in section 3.8.9
(bug 4392).
 Clarify initial value of stencil value masks in section 4.1.4 and table 6.16
(bug 4378).
 Change FramebufferTextureLayer in section 4.4.2 to generate
INVALID_VALUE for negative layer only if texture is non-zero (bug
4084).
 Clarify RenderbufferStorageMultisample language in section 4.4.2 to al-
low, but not require creation of multisampled integer renderbuffers with more
one sample (bug 4396).
 Added language to section 6.1.4 disallowing data-type format mismatches
between internal and external texture formats in GetTexImage (bug 4163).
 Change initial value of FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_-
MAP_FACE in table 6.21 toNONE (bug 4407).
 Brought extension list in appendix H.3 up to date and correctly described
extensions introduced along with OpenGL 3.0 and OpenGL 3.1 which im-
plement subsets of new functionality in those versions to enable older hard-
ware.
 Added missing contributors to the OpenGL 3.1 contributor list.
G.4 Credits and Acknowledgements
OpenGL 3.1 is the result of the contributions of many people and companies.
Members of the Khronos OpenGL ARB Working Group during the development
of OpenGL 3.1, including the company that they represented at the time of their
contributions, follow. Some major contributions made by individuals are listed to-
gether with their name, including speci?c functionality developed in the form of
new ARB extensions together with OpenGL 3.1. In addition, many people partic-
ipated in developing earlier vendor andEXT extensions on which the OpenGL 3.1
functionality is based in part; those individuals are listed in the respective extension
speci?cations in the OpenGL Extension Registry.
OpenGL 3.1 - May 28, 2009G.4. CREDITSANDACKNOWLEDGEMENTS 310
Alexis Mather, AMD (Chair, ARB Marketing TSG)
Avi Shapira, Graphic Remedy
Barthold Lichtenbelt, NVIDIA (Chair, Khronos OpenGL ARB Working Group)
Benjamin Lipchak, Apple (Uniform buffer objects)
Bill Licea-Kane, AMD (Chair, ARB Shading Language TSG; signed normalized
texture formats)
Brent Insko, Intel
Brian Paul, Tungsten Graphics
Bruce Merry, ARM (Detailed speci?cation review)
Christopher Webb, NVIDIA
Daniel Koch, Transgaming
Daniel Omachi, Apple
Eric Werness, NVIDIA
Gavriel State, Transgaming
Geoff Stahl, Apple
Gregory Roth, NVIDIA
Ian Romanick, Intel
James Helferty, Transgaming
James Jones, NVIDIA
Jeff Bolz, NVIDIA (Buffer to buffer copies)
Jeremy Sandmel, Apple (Chair, ARB Nextgen (OpenGL 3.1) TSG; uniform
buffer objects)
John Kessenich, Intel (OpenGL Shading Language Specification Editor)
John Rosasco, Apple (Uniform buffer objects)
Jon Leech, Independent (OpenGL API Specification Editor)
Mark Callow, HI Corp
Mark Kilgard, NVIDIA (Many extensions on which OpenGL 3.0 features were
based)
Matt Craighead, NVIDIA
Michael Gold, NVIDIA
Neil Trevett, NVIDIA (President, Khronos Group)
Nick Haemel, AMD
Pat Brown, NVIDIA (Many extensions on which OpenGL 3.0 features were
based; detailed speci?cation review)
Paul Martz, SimAuthor
Pierre Boudier, AMD
Rob Barris, Blizzard
Tom Olson, TI (Chair, Khronos OpenGL ES Working Group)
Yaki Tebeka, Graphic Remedy
Yanjun Zhang, S3 Graphics
OpenGL 3.1 - May 28, 2009G.4. CREDITSANDACKNOWLEDGEMENTS 311
The ARB gratefully acknowledges administrative support by the members of
Gold Standard Group, including Andrew Riegel, Elizabeth Riegel, Glenn Freder-
icks, and Michelle Clark, and technical support from James Riordon, webmaster
of Khronos.org and OpenGL.org.
OpenGL 3.1 - May 28, 2009Appendix H
Extension Registry, Header Files,
and ARB Extensions
H.1 Extension Registry
Many extensions to the OpenGL API have been de?ned by vendors, groups of
vendors, and the OpenGL ARB. In order not to compromise the readability of
the GL Specification, such extensions are not integrated into the core language;
instead, they are made available online in the OpenGL Extension Registry, together
with extensions to window system binding APIs, such as GLX and WGL, and with
speci?cations for OpenGL, GLX, and related APIs.
Extensions are documented as changes to a particular version of the Speci?ca-
tion. The Registry is available on the World Wide Web at URL
http://www.opengl.org/registry/
H.2 Header Files
Historically, C and C++ source code calling OpenGL was to#include a single
header ?le, <GL/gl.h>. In addition to the core OpenGL API, the APIs for all
extensions provided by an implementation were de?ned in this header.
When platforms became common where the OpenGL SDK (library and header
?les) were not necessarily obtained from the same source as the OpenGL driver,
such as Microsoft Windows and Linux, <GL/gl.h> could not always be kept
in sync with new core API versions and extensions supported by drivers. At this
time the OpenGL ARB de?ned a new header, <GL/glext.h>, which could be
obtained directly from the OpenGL Extension Registry (see section H.1). The
312H.3. ARBEXTENSIONS 313
combination of <GL/gl.h> and <GL/glext.h> always de?nes APIs for the
latest core OpenGL version as well as for all extensions de?ned in the Registry.
With the introduction of OpenGL 3.1, many features were removed from the
core API. The deprecation model does not allow reintroduction of these features ex-
cept via the specialGL_ARB_compatibility extension (see section G.2). While
it is possible to continue using <GL/gl.h> and <GL/glext.h>, new header
?les are de?ned for OpenGL 3.1 and future versions. The ARB recommends using
these headers for any new application which is written to the OpenGL 3.1 core
without using any of the features removed from OpenGL 3.0. The header ?les so
de?ned are:
 <GL3/gl3.h>, which will always de?ne the core API of the current ver-
sion of OpenGL, and only that API. It does not include APIs for features
removed by OpenGL 3.1. Initially it contains only the APIs in OpenGL 3.1.
 <GL3/gl3ext.h>, which will always de?ne APIs for registered exten-
sions which may be provided by an OpenGL 3.1 implementation that does
not support the GL_ARB_compatibility extension. Most currently de-
?ned extensions cannot be provided by such an implementation, since they
depend on features no longer present in OpenGL 3.1.
By using <GL3/gl3.h> and <GL3/gl3ext.h>, instead of the legacy
<GL/gl.h> and <GL/glext.h>, newly developed applications are given in-
creased protection against accidentally using a “legacy” feature that has been re-
moved from OpenGL 3.1. This can assist in developing applications on a GL
implementation that supports GL_ARB_compatibility when the application is
also intended to run on other platforms supporting only the core OpenGL 3.1 API.
Developers should always be able to download <GL3/gl3.h> and
<GL3/gl3ext.h> from the Registry, with these headers replacing, or being used
in place of older versions that may be provided by a platform SDK.
H.3 ARB Extensions
OpenGL extensions that have been approved by the OpenGL Architectural Review
Board (ARB) are summarized in this section. ARB extensions are not required
to be supported by a conformant OpenGL implementation, but are expected to be
widely available; they de?ne functionality that is likely to move into the required
feature set in a future revision of the speci?cation.
OpenGL 3.1 - May 28, 2009H.3. ARBEXTENSIONS 314
H.3.1 Naming Conventions
To distinguish ARB extensions from core OpenGL features and from vendor-
speci?c extensions, the following naming conventions are used:
 A unique name string of the form ”GL_ARB_name” is associated with each
extension. If the extension is supported by an implementation, this string will
be among theEXTENSIONS strings returned by GetStringi, as described in
section 6.1.4.
 All functions de?ned by the extension will have names of the form Func-
tionARB
 All enumerants de?ned by the extension will have names of the form
NAME_ARB.
 In additional to OpenGL extensions, there are also ARB extensions to the
related GLX and WGL APIs. Such extensions have name strings pre?xed by
"GLX_" and"WGL_" respectively. Not all GLX and WGL ARB extensions
are described here, but all such extensions are included in the registry.
H.3.2 Promoting Extensions to Core Features
ARB extensions can be promoted to required core features in later revisions of
OpenGL. When this occurs, the extension speci?cations are merged into the core
speci?cation. Functions and enumerants that are part of such promoted extensions
will have the ARB af?x removed.
GL implementations of such later revisions should continue to export the name
strings of promoted extensions in theEXTENSIONS strings and continue to support
the ARB-af?xed versions of functions and enumerants as a transition aid.
For descriptions of extensions promoted to core features in OpenGL 1.3 and
beyond, see the corresponding version of the OpenGL speci?cation, or the de-
scriptions of that version in version-speci?c appendices to later versions of the
speci?cation.
H.3.3 Multitexture
The name string for multitexture isGL_ARB_multitexture. It was promoted to
a core feature in OpenGL 1.3.
OpenGL 3.1 - May 28, 2009H.3. ARBEXTENSIONS 315
H.3.4 Transpose Matrix
The name string for transpose matrix is GL_ARB_transpose_matrix. It was
promoted to a core feature in OpenGL 1.3.
H.3.5 Multisample
The name string for multisample isGL_ARB_multisample. It was promoted to a
core feature in OpenGL 1.3.
H.3.6 Texture Add Environment Mode
The name string for texture add mode is GL_ARB_texture_env_add. It was
promoted to a core feature in OpenGL 1.3.
H.3.7 Cube Map Textures
The name string for cube mapping is GL_ARB_texture_cube_map. It was pro-
moted to a core feature in OpenGL 1.3.
H.3.8 Compressed Textures
The name string for compressed textures isGL_ARB_texture_compression. It
was promoted to a core feature in OpenGL 1.3.
H.3.9 Texture Border Clamp
The name string for texture border clamp isGL_ARB_texture_border_clamp.
It was promoted to a core feature in OpenGL 1.3.
H.3.10 Point Parameters
The name string for point parameters is GL_ARB_point_parameters. It was
promoted to a core features in OpenGL 1.4.
H.3.11 Vertex Blend
Vertex blending replaces the single model-view transformation with multiple ver-
tex units. Each unit has its own transform matrix and an associated current weight.
Vertices are transformed by all the enabled units, scaled by their respective weights,
and summed to create the eye-space vertex. Normals are similarly transformed by
the inverse transpose of the model-view matrices.
OpenGL 3.1 - May 28, 2009H.3. ARBEXTENSIONS 316
The name string for vertex blend isGL_ARB_vertex_blend.
H.3.12 Matrix Palette
Matrix palette extends vertex blending to include a palette of model-view matrices.
Each vertex may be transformed by a different set of matrices chosen from the
palette.
The name string for matrix palette isGL_ARB_matrix_palette.
H.3.13 Texture Combine Environment Mode
The name string for texture combine mode isGL_ARB_texture_env_combine.
It was promoted to a core feature in OpenGL 1.3.
H.3.14 Texture Crossbar Environment Mode
The name string for texture crossbar is GL_ARB_texture_env_crossbar. It
was promoted to a core features in OpenGL 1.4.
H.3.15 Texture Dot3 Environment Mode
The name string for DOT3 is GL_ARB_texture_env_dot3. It was promoted to
a core feature in OpenGL 1.3.
H.3.16 Texture Mirrored Repeat
The name string for texture mirrored repeat is GL_ARB_texture_mirrored_-
repeat. It was promoted to a core feature in OpenGL 1.4.
H.3.17 Depth Texture
The name string for depth texture is GL_ARB_depth_texture. It was promoted
to a core feature in OpenGL 1.4.
H.3.18 Shadow
The name string for shadow isGL_ARB_shadow. It was promoted to a core feature
in OpenGL 1.4.
OpenGL 3.1 - May 28, 2009H.3. ARBEXTENSIONS 317
H.3.19 Shadow Ambient
Shadow ambient extends the basic image-based shadow functionality by allowing
a texture value speci?ed by the TEXTURE_COMPARE_FAIL_VALUE_ARB texture
parameter to be returned when the texture comparison fails. This may be used for
ambient lighting of shadowed fragments and other advanced lighting effects.
The name string for shadow ambient isGL_ARB_shadow_ambient.
H.3.20 Window Raster Position
The name string for window raster position isGL_ARB_window_pos. It was pro-
moted to a core feature in OpenGL 1.4.
H.3.21 Low-Level Vertex Programming
Application-de?ned vertex programs may be speci?ed in a new low-level program-
ming language, replacing the standard ?xed-function vertex transformation, light-
ing, and texture coordinate generation pipeline. Vertex programs enable many new
effects and are an important ?rst step towards future graphics pipelines that will be
fully programmable in an unrestricted, high-level shading language.
The name string for low-level vertex programming is GL_ARB_vertex_-
program.
H.3.22 Low-Level Fragment Programming
Application-de?ned fragment programs may be speci?ed in the same low-level lan-
guage asGL_ARB_vertex_program, replacing the standard ?xed-function vertex
texturing, fog, and color sum operations.
The name string for low-level fragment programming is GL_ARB_-
fragment_program.
H.3.23 Buffer Objects
The name string for buffer objects is GL_ARB_vertex_buffer_object. It was
promoted to a core feature in OpenGL 1.5.
H.3.24 Occlusion Queries
The name string for occlusion queries is GL_ARB_occlusion_query. It was
promoted to a core feature in OpenGL 1.5.
OpenGL 3.1 - May 28, 2009H.3. ARBEXTENSIONS 318
H.3.25 Shader Objects
The name string for shader objects is GL_ARB_shader_objects. It was pro-
moted to a core feature in OpenGL 2.0.
H.3.26 High-Level Vertex Programming
The name string for high-level vertex programming isGL_ARB_vertex_shader.
It was promoted to a core feature in OpenGL 2.0.
H.3.27 High-Level Fragment Programming
The name string for high-level fragment programming is GL_ARB_fragment_-
shader. It was promoted to a core feature in OpenGL 2.0.
H.3.28 OpenGL Shading Language
The name string for the OpenGL Shading Language is GL_ARB_shading_-
language_100. The presence of this extension string indicates that programs
written in version 1 of the Shading Language are accepted by OpenGL. It was
promoted to a core feature in OpenGL 2.0.
H.3.29 Non-Power-Of-Two Textures
The name string for non-power-of-two textures is GL_ARB_texture_non_-
power_of_two. It was promoted to a core feature in OpenGL 2.0.
H.3.30 Point Sprites
The name string for point sprites isGL_ARB_point_sprite. It was promoted to
a core feature in OpenGL 2.0.
H.3.31 Fragment Program Shadow
Fragment program shadow extends low-level fragment programs de?ned with
GL_ARB_fragment_program to add shadow 1D, 2D, and 3D texture targets, and
remove the interaction withGL_ARB_shadow.
The name string for fragment program shadow is GL_ARB_fragment_-
program_shadow.
OpenGL 3.1 - May 28, 2009H.3. ARBEXTENSIONS 319
H.3.32 Multiple Render Targets
The name string for multiple render targets is GL_ARB_draw_buffers. It was
promoted to a core feature in OpenGL 2.0.
H.3.33 Rectangular Textures
Rectangular textures de?ne a new texture target TEXTURE_RECTANGLE_ARB that
supports 2D textures without requiring power-of-two dimensions. Rectangular
textures are useful for storing video images that do not have power-of-two sizes
(POTS). Resampling artifacts are avoided and less texture memory may be re-
quired. They are are also useful for shadow maps and window-space texturing.
These textures are accessed by dimension-dependent (aka non-normalized) texture
coordinates.
Rectangular textures are a restricted version of non-power-of-two textures. The
differences are that rectangular textures are supported only for 2D; they require a
new texture target; and the new target uses non-normalized texture coordinates.
The name string for texture rectangles is GL_ARB_texture_rectangle. It
was promoted to a core feature in OpenGL 3.1.
H.3.34 Floating-Point Color Buffers
Floating-point color buffers can represent values outside the normal [0; 1] range
of colors in the ?xed-function OpenGL pipeline. This group of related exten-
sions enables controlling clamping of vertex colors, fragment colors throughout the
pipeline, and pixel data read back to client memory, and also includes WGL and
GLX extensions for creating frame buffers with ?oating-point color components
(referred to in GLX as framebuffer con?gurations, and in WGL as pixel formats).
The name strings for ?oating-point color buffers are GL_ARB_color_-
buffer_float, GLX_ARB_fbconfig_float, and WGL_ARB_pixel_-
format_float. GL_ARB_color_buffer_float was promoted to a core
feature in OpenGL 3.0.
H.3.35 Half-Precision Floating Point
This extension de?nes the representation of a 16-bit ?oating point data format, and
a correspondingtype argument which may be used to specify and read back pixel
and texture images stored in this format in client memory. Half-precision ?oats are
smaller than full precision ?oats, but provide a larger dynamic range than similarly
sized (short) data types.
OpenGL 3.1 - May 28, 2009H.3. ARBEXTENSIONS 320
The name string for half-precision ?oating point is GL_ARB_half_float_-
pixel. It was promoted to a core feature in OpenGL 3.0.
H.3.36 Floating-Point Textures
Floating-point textures stored in both 32- and 16-bit formats may be de?ned using
new internalformat arguments to commands which specify and read back texture
images.
The name string for ?oating-point textures is GL_ARB_texture_float. It
was promoted to a core feature in OpenGL 3.0.
H.3.37 Pixel Buffer Objects
The buffer object interface is expanded by adding two new binding targets for
buffer objects, the pixel pack and unpack buffers. This permits buffer objects to be
used to store pixel data as well as vertex array data. Pixel-drawing and -reading
commands using data in pixel buffer objects may operate at greatly improved per-
formance compared to data in client memory.
The name string for pixel buffer objects isGL_ARB_pixel_buffer_object.
It was promoted to a core feature in OpenGL 2.1.
H.3.38 Floating-Point Depth Buffers
The name string for ?oating-point depth buffers is GL_ARB_depth_buffer_-
float. This extension is equivalent to new core functionality introduced in
OpenGL 3.0, based on the earlierGL_NV_depth_buffer_float extension, and
is provided to enable this functionality in older drivers.
H.3.39 Instanced Rendering
The name string for instanced rendering is GL_ARB_draw_instanced. It was
promoted to a core feature in OpenGL 3.1.
H.3.40 Framebuffer Objects
The name string for framebuffer objects isGL_ARB_framebuffer_object. This
extension is equivalent to new core functionality introduced in OpenGL 3.0, based
on the earlier GL_EXT_framebuffer_object, GL_EXT_framebuffer_-
multisample, and GL_EXT_framebuffer_blit extensions, and is provided
to enable this functionality in older drivers.
OpenGL 3.1 - May 28, 2009H.3. ARBEXTENSIONS 321
H.3.41 sRGB Framebuffers
The name string for sRGB framebuffers is GL_ARB_framebuffer_sRGB. It was
promoted to a core feature in OpenGL 3.0. This extension is equivalent to new
core functionality introduced in OpenGL 3.0, based on the earlier GL_EXT_-
framebuffer_sRGB extension, and is provided to enable this functionality in
older drivers.
To create sRGB format surface for use on display devices, an additional pixel
format (con?g) attribute is required in the window system integration layer. The
name strings for the GLX and WGL sRGB pixel format interfaces areGLX_ARB_-
framebuffer_sRGB andWGL_ARB_framebuffer_sRGB respectively.
H.3.42 Geometry Shaders
This extension de?nes a new shader type called a geometry shader. Geometry
shaders are run after vertices are transformed, but prior to the remaining ?xed-
function vertex processing, and may generate new vertices for, or remove vertices
from the primitive assembly process.
The name string for geometry shaders isGL_ARB_geometry_shader4.
H.3.43 Half-Precision Vertex Data
The name string for half-precision vertex data GL_ARB_half_float_vertex.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlierGL_NV_half_float extension, and is provided to enable this
functionality in older drivers.
H.3.44 Instanced Rendering
.
This instanced rendering interface is a less-capable form of GL_ARB_draw_-
instanced which can be supported on older hardware.
The name string for instance rendering isGL_ARB_instanced_arrays.
H.3.45 Flexible Buffer Mapping
The name string for ?exible buffer mapping is GL_ARB_map_buffer_range.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlier GL_APPLE_flush_buffer_range extension, and is pro-
vided to enable this functionality in older drivers.
OpenGL 3.1 - May 28, 2009H.3. ARBEXTENSIONS 322
H.3.46 Texture Buffer Objects
The name string for texture buffer objects is GL_ARB_texture_buffer_-
object. It was promoted to a core feature in OpenGL 3.1.
H.3.47 RGTC Texture Compression Formats
The name string for RGTC texture compression formats is GL_ARB_texture_-
compression_rgtc. This extension is equivalent to new core functionality intro-
duced in OpenGL 3.0, based on the earlier GL_EXT_texture_compression_-
rgtc extension, and is provided to enable this functionality in older drivers.
It was promoted to a core feature in OpenGL 3.0.
H.3.48 One- and Two-Component Texture Formats
The name string for one- and two-component texture formats is GL_ARB_-
texture_rg. It was promoted to a core feature in OpenGL 3.0. This extension is
equivalent to new core functionality introduced in OpenGL 3.0, and is provided to
enable this functionality in older drivers.
H.3.49 Vertex Array Objects
The name string for vertex array objects is GL_ARB_vertex_array_object.
This extension is equivalent to new core functionality introduced in OpenGL 3.0,
based on the earlier GL_APPLE_vertex_array_object extension, and is pro-
vided to enable this functionality in older drivers.
It was promoted to a core feature in OpenGL 3.0.
H.3.50 Versioned Context Creation
Starting with OpenGL 3.0, a new context creation interface is required in the win-
dow system integration layer. This interface speci?es the context version required
as well as other attributes of the context.
The name strings for the GLX and WGL context creation interfaces areGLX_-
ARB_create_context andWGL_ARB_create_context respectively.
H.3.51 Uniform Buffer Objects
The name string for uniform buffer objects is GL_ARB_uniform_buffer_-
object. This extension is equivalent to new core functionality introduced in
OpenGL 3.1 and is provided to enable this functionality in older drivers.
OpenGL 3.1 - May 28, 2009H.3. ARBEXTENSIONS 323
H.3.52 Restoration of features removed from OpenGL 3.0
OpenGL 3.1 removes a large number of features that were marked deprecated
in OpenGL 3.0 (see appendix G.2). GL implementations needing to maintain
these features to support existing applications may do so, following the depreca-
tion model, by exporting an extension string indicating those features are present.
Applications written for OpenGL 3.1 should not depend on any of the features cor-
responding to this extension, since they will not be available on all platforms with
3.1 implementations.
The name string for restoration of features deprecated by OpenGL 3.0 isGL_-
ARB_compatibility.
H.3.53 Fast Buffer-to-Buffer Copies
The name string for fast buffer-to-buffer copies is GL_ARB_copy_buffer. This
extension is equivalent to new core functionality introduced in OpenGL 3.1 and is
provided to enable this functionality in older drivers.
H.3.54 Shader Texture Level of Detail Control
The name string for shader texture level of detail control is GL_ARB_shader_-
texture_lod. This extension is equivalent to new core functions introduced in
OpenGL Shading Language 1.30 and is provided to enable this functionality in
older versions of the shading language.
OpenGL 3.1 - May 28, 2009Index
*CopyBufferSubData, 38 ALPHA BITS, 298
*GetString, 226 ALPHA TEST, 298
*GetStringi, 227 AlphaFunc, 298
*MapBuffer, 37 ALWAYS, 142, 158, 171, 172, 253
*MapBufferRange, 34 AND, 180
*Pointer, 41 AND INVERTED, 180
-, 262–264 AND REVERSE, 180
–, 279 Antialiasing, 95
AreTexturesResident, 298
279
ARRAY BUFFER, 31, 39, 41
Accum, 298
ARRAY BUFFER BINDING, 39, 242
ACCUM * BITS, 298
ArrayElement, 302
ACCUM BUFFER BIT, 298
ATTACHED SHADERS, 232, 233, 263
ACTIVE ATTRIBUTE MAX -
AttachShader, 44
LENGTH, 47, 232, 264
ATTRIB STACK DEPTH, 299
ACTIVE ATTRIBUTES, 47, 232, 263
AUXi, 298
ACTIVE TEXTURE, 115, 157, 222,
BACK, 96, 171, 174, 182–186, 188,
252
192, 199, 247, 297
ACTIVE UNIFORM BLOCK -
BACK LEFT, 183, 236
MAX NAME LENGTH, 232,
BACK RIGHT, 183, 236
265
Begin, 295
ACTIVE UNIFORM BLOCKS, 51,
BeginConditionalRender, 77
52, 232, 265
BeginQuery, 75, 76, 81, 173, 302
ACTIVE UNIFORM -
BeginTransformFeedback, 78–80
MAX LENGTH, 54, 55, 232,
BGR, 106, 192, 196
263
BGR INTEGER, 106
ACTIVE UNIFORMS, 53, 54, 232, 263
BGRA, 106, 108, 113, 192
ActiveTexture, 64, 115
BGRA INTEGER, 106
ALIASED LINE WIDTH RANGE,
BindAttribLocation, 48
273
BindBuffer, 30, 32, 40, 63, 79, 139
ALL ATTRIB BITS, 299
BindBufferBase, 63, 79, 80
ALPHA, 177, 192, 196, 251, 258, 297
324INDEX 325
BindBufferRange, 63, 64, 79, 80 BUFFER MAP OFFSET, 31, 33, 36,
BindFragDataLocation, 164 38, 243, 303
BindFramebuffer, 200, 201, 214 BUFFER MAP POINTER, 31, 33, 36,
BindRenderbuffer, 202, 203 38, 229, 230, 243
BindTexture, 64, 115, 155–157 BUFFER MAPPED, 31, 33, 36, 38, 243
BindVertexArray, 41 BUFFER SIZE, 31, 33, 34, 36, 37, 63,
BITMAP, 297 79, 243
Bitmap, 297 BUFFER USAGE, 31, 33, 35, 243
BLEND, 174, 178, 179, 254 BufferData, 32, 33, 50, 291
BLEND COLOR, 254 BufferSubData, 34, 50, 291
BLEND DST ALPHA, 254 bvec2, 56, 58
BLEND DST RGB bvec3, 56
(v1.3:BLEND DST), 254 bvec4, 56
BLEND EQUATION ALPHA, 254 BYTE, 24, 105, 194, 195
BLEND EQUA-
CallList, 298
TION RGB (v1.5: BLEND -
CallLists, 298
EQUATION), 254
CCW, 96, 247
BLEND SRC ALPHA, 254
CheckFramebufferStatus, 214, 215
BLEND SRC RGB
CLAMP, 297
(v1.3:BLEND SRC), 254
CLAMP FRAGMENT COLOR, 296
BlendColor, 176
CLAMP READ COLOR, 193, 245
BlendEquation, 174
CLAMP TO BORDER, 142, 147, 304
BlendEquationSeparate, 174
CLAMP TO EDGE, 142, 147, 155, 197
BlendFunc, 175
CLAMP VERTEX COLOR, 296
BlendFuncSeparate, 175
ClampColor, 193, 296
BlitFramebuffer, 189, 196, 198, 211
CLEAR, 180
BLUE, 106, 192, 196, 251, 258
Clear, 77, 85, 187, 189, 298
BLUE BITS, 298
ClearAccum, 298
BLUE INTEGER, 106
ClearBuffer, 189
BOOL, 56
ClearBuffer*, 77, 85, 302, 303
bool, 56, 60
ClearBufferfif uigv, 188, 189
BOOL VEC2, 56
ClearBuffer?, 188, 189
BOOL VEC3, 56
ClearBufferfv, 188, 189
BOOL VEC4, 56
ClearBufferiv, 188, 189
BUFFER ACCESS, 31, 33, 36, 243
ClearBufferuiv, 188
BUFFER ACCESS FLAGS, 31, 33, 36,
ClearColor, 187, 188
38, 243, 303
ClearDepth, 187, 188
BUFFER MAP LENGTH, 31, 33, 36,
ClearStencil, 187, 188
38, 243, 303
CLIENT ALL ATTRIB BITS, 299
OpenGL 3.1 - May 28, 2009INDEX 326
CLIENT ATTRIB STACK DEPTH, COMPRESSED SIGNED -
299 RED RGTC1, 119, 124, 288,
ClientActiveTexture, 295 289
CLIP DISTANCEi, 82, 244, 302 COMPRESSED SIGNED RG -
CLIP DISTANCE0, 82 RGTC2, 119, 124, 289
CLIP PLANEi, 302 COMPRESSED SRGB, 124, 159
ClipPlane, 296 COMPRESSED SRGB ALPHA, 124,
COLOR, 129, 188, 189 159
Color*, 295 COMPRESSED TEXTURE FOR-
COLOR ATTACHMENTi, 182, 183, MATS, 118, 273
192, 206, 212 CompressedTexImage, 137
COLOR ATTACHMENTm, 182, 184 CompressedTexImagenD, 134
COLOR ATTACHMENTn, 201 CompressedTexImage*, 214, 308
COLOR ATTACHMENT0, 182, 185, CompressedTexImage1D, 134–136
192, 201 CompressedTexImage2D, 134–136
COLOR BUFFER BIT, 187, 189, 196, CompressedTexImage3D, 134–136
197 CompressedTexSubImagenD, 136
COLOR CLEAR VALUE, 255 CompressedTexSubImage1D, 136–138
COLOR INDEX, 295 CompressedTexSubImage2D, 136–138
COLOR LOGIC OP, 179, 254 CompressedTexSubImage3D, 136–138
COLOR MATERIAL, 296 CONSTANT ALPHA, 177
COLOR SUM, 298 CONSTANT COLOR, 177
COLOR WRITEMASK, 185, 186, 255 CONTEXT FLAG FORWARD COM-
ColorMask, 185, 186 PATIBLE BIT, 227
ColorMaski, 185 CONTEXT FLAGS, 227, 274
ColorMaterial, 296 COPY, 179, 180, 254
ColorPointer, 295 COPY INVERTED, 180
COMPARE R TO TEXTURE, 302 COPY READ BUFFER, 31, 39, 279
COMPARE REF TO TEXTURE, 142, COPY WRITE BUFFER, 31, 39, 279
158, 302 CopyPixels, 298
COMPILE STATUS, 43, 231, 262 CopyTexImage, 215, 298
CompileShader, 43 CopyTexImage*, 207, 211, 214
COMPRESSED RED, 124 CopyTexImage1D, 129–131, 133, 134,
COMPRESSED RED RGTC1, 119, 150
124, 287, 288 CopyTexImage2D, 127, 129–131, 133,
COMPRESSED RG, 124 134, 150
COMPRESSED RG RGTC2, 119, CopyTexImage3D, 131
124, 288 CopyTexSubImage, 215
COMPRESSED RGB, 124 CopyTexSubImage*, 133, 138, 207
COMPRESSED RGBA, 124 CopyTexSubImage1D, 130–134
OpenGL 3.1 - May 28, 2009INDEX 327
CopyTexSubImage2D, 130–134 224, 225
CopyTexSubImage3D, 130, 131, 133, DEPTH COMPONENT16, 119, 123
134 DEPTH COMPONENT24, 119, 123
CreateProgram, 44 DEPTH COMPONENT32, 123
CreateShader, 42 DEPTH COMPONENT32F, 119, 123
CULL FACE, 96, 247 DEPTH FUNC, 254
CULL FACE MODE, 247 DEPTH RANGE, 244
CullFace, 96, 100 DEPTH STENCIL, 70, 104, 106, 108,
CURRENT PROGRAM, 263 113, 114, 116, 117, 123, 129,
CURRENT QUERY, 228, 279 153, 158, 162, 188, 189, 191,
CURRENT VERTEX ATTRIB, 234, 193, 206, 208, 212, 224, 225
267 DEPTH STENCIL ATTACHMENT,
CW, 96 206, 208, 236
DEPTH TEST, 172, 254
DECR, 171
DEPTH TEXTURE MODE, 297
DECR WRAP, 171
DEPTH WRITEMASK, 255
DELETE STATUS, 44, 231, 232, 262,
DepthFunc, 172
263
DepthMask, 186
DeleteBuffers, 30, 32
DepthRange, 74, 221
DeleteFramebuffers, 200, 201
DetachShader, 44
DeleteLists, 298
dFdx, 219
DeleteProgram, 46
dFdy, 219
DeleteQueries, 76
Disable, 26, 82, 85, 88, 89, 91, 95, 96,
DeleteRenderbuffers, 203, 214
100, 169, 170, 172, 174, 179,
DeleteShader, 43, 44
295–298
DeleteTextures, 156, 157, 214
DisableClientState, 295
DeleteVertexArrays, 41
Disablei, 174
DEPTH, 129, 188, 189, 236, 251, 258,
DisableVertexAttribArray, 25, 234
302
DITHER, 179, 254
DEPTH24 STENCIL8, 119, 123
DONT CARE, 219, 270
DEPTH32F STENCIL8, 119, 123
DOUBLE, 24
DEPTH ATTACHMENT, 201, 206,
DOUBLEBUFFER, 278
212, 302, 303
DRAW BUFFER, 182, 185, 192
DEPTH BITS, 298
DRAW BUFFERi, 174, 185, 188, 213,
DEPTH BUFFER, 303
257
DEPTH BUFFER BIT, 187, 189, 196–
DRAW BUFFER0, 185
198
DRAW FRAMEBUFFER,
DEPTH CLEAR VALUE, 255
199–201, 205, 207, 215, 236,
DEPTH COMPONENT, 70, 106, 117,
256
123, 158, 162, 190, 193, 212,
DRAW FRAMEBUFFER BINDING,
OpenGL 3.1 - May 28, 2009INDEX 328
149, 181, 182, 198, 202, 215, FALSE, 31, 33, 38, 43, 45, 58, 71–73,
216, 256 101, 102, 154, 162, 170, 191,
DrawArrays, 19, 21, 26, 27, 29, 39, 41, 193, 221, 226, 228, 229, 231,
70, 78, 215 232, 234, 235, 238, 240, 242–
DrawArraysInstanced, 29 244, 246–248, 251, 253, 254,
DrawBuffer, 180–184, 186, 189 261–263, 267, 268, 279
DrawBuffers, 181–184 FASTEST, 219
DrawElements, 26–29, 40, 41 FeedbackBuffer, 298
DrawElementsInstanced, 29, 40 FILL, 98, 100, 101, 247, 285
DrawPixels, 297 Finish, 218, 284, 291–293
DrawRangeElements, 28, 40, 273 FIXED ONLY, 193, 199, 245
DST ALPHA, 177 FLAT, 284
DST COLOR, 177 FLOAT, 24, 30, 47, 56, 104, 105, 117,
DYNAMIC COPY, 31, 33 192, 193, 195, 223, 236, 240
DYNAMIC DRAW, 31, 33 ?oat, 46, 56, 60
DYNAMIC READ, 31, 33 FLOAT 32 UNSIGNED INT -
24 8 REV, 104, 105, 108, 112,
EdgeFlag*, 295
191, 194, 195
EdgeFlagPointer, 295
FLOAT MAT2, 47, 56
ELEMENT ARRAY BUFFER, 31, 40
FLOAT MAT2x3, 47, 56
ELEMENT ARRAY BUFFER BIND-
FLOAT MAT2x4, 47, 56
ING, 241
FLOAT MAT3, 47, 56
Enable, 26, 82, 85, 88, 89, 91, 95, 96,
FLOAT MAT3x2, 47, 56
100, 169, 170, 172, 174, 179,
FLOAT MAT3x4, 47, 56
221, 295–298
FLOAT MAT4, 47, 56
EnableClientState, 295
FLOAT MAT4x2, 47, 56
Enablei, 174
FLOAT MAT4x3, 47, 56
EnableVertexAttribArray, 25, 41, 234
FLOAT VEC2, 47, 56
End, 295
FLOAT VEC3, 47, 56
EndConditionalRender, 77
FLOAT VEC4, 47, 56
EndList, 298
Flush, 218, 284
EndQuery, 76, 173
FlushMappedBufferRange, 35, 37, 291
EndTransformFeedback, 78, 292, 293
FOG, 298
EQUAL, 142, 158, 171, 172
Fog, 298
EQUIV, 180
FOG HINT, 299
EvalCoord*, 298
FogCoord*, 295
EvalMesh*, 298
FogCoordPointer, 295
EvalPoint*, 298
FRAGMENT SHADER, 160, 231
EXTENSIONS, 227, 274, 299, 314
FRAGMENT SHADER DERIVA-
TIVE HINT, 219, 270
OpenGL 3.1 - May 28, 2009INDEX 329
FRAMEBUFFER, 200, 205, 207, 215, FRAMEBUFFER COMPLETE, 215
236 FRAMEBUFFER DEFAULT, 236
FRAMEBUFFER ATTACHMENT x - FRAMEBUFFER INCOMPLETE AT-
SIZE, 258 TACHMENT, 213
FRAMEBUFFER ATTACHMENT - FRAMEBUFFER INCOMPLETE -
ALPHA SIZE, 236 DRAW BUFFER, 213
FRAMEBUFFER ATTACHMENT - FRAMEBUFFER INCOMPLETE -
BLUE SIZE, 236 MISSING ATTACHMENT,
FRAMEBUFFER ATTACHMENT - 213
COLOR ENCODING, 175, FRAMEBUFFER INCOMPLETE -
178, 237, 258 MULTISAMPLE, 213
FRAMEBUFFER ATTACHMENT - FRAMEBUFFER INCOMPLETE -
COMPONENT TYPE, 236, READ BUFFER, 213
258 FRAMEBUFFER SRGB, 175, 178,
FRAMEBUFFER ATTACHMENT - 254
DEPTH SIZE, 236 FRAMEBUFFER UNDEFINED, 213
FRAMEBUFFER ATTACHMENT - FRAMEBUFFER UNSUPPORTED,
GREEN SIZE, 236 213, 214
FRAMEBUFFER ATTACH- FramebufferRenderbuffer, 205, 206,
MENT OBJECT NAME, 206, 214
208, 212, 236, 237, 258 FramebufferTexture, 209
FRAMEBUFFER ATTACH- FramebufferTexture*, 208, 209, 214
MENT OBJECT TYPE, 206, FramebufferTexture1D, 207, 208
208, 212, 213, 216, 236, 237, FramebufferTexture2D, 207, 208
258 FramebufferTexture3D, 207–209
FRAMEBUFFER ATTACHMENT - FramebufferTextureLayer, 208, 309
RED SIZE, 236 FRONT, 96, 171, 174, 182–186, 188,
FRAMEBUFFER ATTACHMENT - 192, 199, 297
STENCIL SIZE, 236 FRONT AND BACK, 96, 98, 171, 174,
FRAMEBUFFER ATTACHMENT - 183–186, 188, 192
TEXTURE - FRONT FACE, 247
CUBE MAP FACE, 208, 237, FRONT LEFT, 183, 236
258, 309 FRONT RIGHT, 183, 236
FRAMEBUFFER ATTACHMENT - FrontFace, 96, 162, 296
TEXTURE LAYER, 208, 209, Frustum, 295
212, 217, 237, 258 FUNC ADD, 174, 176, 254
FRAMEBUFFER ATTACHMENT - FUNC REVERSE SUBTRACT, 174,
TEXTURE LEVEL, 149, 208, 176
210, 237, 258 FUNC SUBTRACT, 174, 176
FRAMEBUFFER BINDING, 202 fwidth, 219
OpenGL 3.1 - May 28, 2009INDEX 330
Gen*, 290, 295 GetIntegeri v, 220, 230, 265, 269
GenBuffers, 30, 32 GetIntegerv, 28, 52, 59, 60, 63, 87, 184,
GENERATE MIPMAP, 298 185, 202, 203, 220, 221, 227,
GENERATE MIPMAP HINT, 299 239, 241, 242, 244–247, 249,
GenerateMipmap, 152 252–257, 259, 261, 263, 265,
GenFramebuffers, 199–202 269–279
GenLists, 298 GetProgramInfoLog, 45, 233, 263
GenQueries, 76 GetProgramiv, 45, 47, 51, 53, 54, 66,
GenRenderbuffers, 202, 203 67, 71, 232, 233, 263–265
GenTextures, 156, 157, 226 GetQueryiv, 228, 274, 279
GenVertexArrays, 40, 41 GetQueryObject[u]iv, 229
GEQUAL, 142, 158, 171, 172 GetQueryObjectiv, 228, 268
Get, 75, 220, 221 GetQueryObjectuiv, 228, 268
GetActiveUniformBlockiv, 266 GetRenderbufferParameteriv, 260
GetActiveAttrib, 46, 47, 67, 264 GetRenderbufferParameteriv, 216, 238,
GetActiveUniform, 54–56, 59, 263 304
GetActiveUniformBlockiv, 51 GetShaderInfoLog, 43, 233, 262
GetActiveUniformBlockName, 51 GetShaderiv, 43, 44, 231, 233, 234, 262
GetActiveUniformName, 53, 54 GetShaderSource, 233, 262
GetActiveUniformsiv, 54–56, 265, 266 GetString, 227, 274, 299
GetAttachedShaders, 233, 263 GetStringi, 274, 314
GetAttribLocation, 47, 48, 264 GetTexImage, 155, 191, 224, 225, 249,
GetBooleani v, 185, 220, 255 309
GetBooleanv, 170, 186, 220, 221, 238, GetTexLevelParameter, 222, 223, 251
239, 248, 255, 261, 278 GetTexParameter, 216, 222, 250
GetBufferParameteriv, 229, 243, 303 GetTexParameterfv, 155, 250
GetBufferPointerv, 230, 243 GetTexParameterI, 222
GetBufferSubData, 229, 230, 243 GetTexParameterIiv, 222
GetCompressedTexImage, 135, 137, GetTexParameterIuiv, 222
219, 223, 225, 226 GetTexParameteriv, 155, 250
GetDoublev, 220, 221, 239 GetTransformFeedbackVarying, 264
GetError, 18, 279 GetTransformFeedbackVarying, 66, 67
GetFloatv, 13, 170, 220, 221, 239, 244, GetUniform, 263
246–248, 254, 255, 271–273 GetUniform*, 235
GetFragDataLocation, 164, 165 GetUniformBlockIndex, 50, 51
GetFramebufferAttachment- GetUniformfv, 235
Parameteriv, 258 GetUniformIndices, 53–55
GetFramebufferAttachmentiv, 303 GetUniformiv, 235
GetFramebufferAttachmentParameteriv, GetUniformLocation, 50, 54, 55, 64,
216, 236, 302, 303 263
OpenGL 3.1 - May 28, 2009INDEX 331
GetUniformuiv, 235 GL ARB shader texture lod, 323
GetVertexAttribPointerv, 240 GL ARB shading language 100, 318
GetVertexAttribdv, 234 GL ARB shadow, 316, 318
GetVertexAttribfv, 234, 267 GL ARB shadow ambient, 317
GetVertexAttribIiv, 234 GL ARB texture border clamp, 315
GetVertexAttribIuiv, 234 GL ARB texture buffer object, 308,
GetVertexAttribiv, 234, 240, 241 322
GetVertexAttribPointerv, 235 GL ARB texture compression, 315
GL APPLE ?ush buffer range, 301, GL ARB texture compression rgtc,
321 322
GL APPLE vertex array object, 301, GL ARB texture cube map, 315
322 GL ARB texture env add, 315
GL ARB color buffer ?oat, 301, 319 GL ARB texture env combine, 316
GL ARB compatibility, 307, 308, 313, GL ARB texture env crossbar, 316
323 GL ARB texture env dot3, 316
GL ARB copy buffer, 307, 323 GL ARB texture ?oat, 301, 320
GL ARB depth buffer ?oat, 320 GL ARB texture mirrored repeat, 316
GL ARB depth texture, 316 GL ARB texture non power of two,
GL ARB draw buffers, 319 318
GL ARB draw instanced, 307, 320, GL ARB texture rectangle, 308, 319
321 GL ARB texture rg, 322
GL ARB fragment program, 317, 318 GL ARB transpose matrix, 315
GL ARB fragment program shadow, GL ARB uniform buffer object, 308,
318 322
GL ARB fragment shader, 318 GL ARB vertex array object, 322
GL ARB framebuffer object, 320 GL ARB vertex blend, 316
GL ARB framebuffer sRGB, 321 GL ARB vertex buffer object, 317
GL ARB geometry shader4, 321 GL ARB vertex program, 317
GL ARB half ?oat pixel, 301, 320 GL ARB vertex shader, 318
GL ARB half ?oat vertex, 321 GL ARB window pos, 317
GL ARB instanced arrays, 321 GL ARB name, 314
GL ARB map buffer range, 321 gl BackColor, 296
GL ARB matrix palette, 316 gl BackSecondaryColor, 296
GL ARB multisample, 315 gl ClipDistance, 70, 302
GL ARB multitexture, 314 gl ClipDistance[], 81
GL ARB occlusion query, 317 gl ClipVertex, 302
GL ARB pixel buffer object, 320 GL EXT draw buffers2, 301
GL ARB point parameters, 315 GL EXT framebuffer blit, 301, 320
GL ARB point sprite, 318 GL EXT framebuffer multisample,
GL ARB shader objects, 318 301, 320
OpenGL 3.1 - May 28, 2009INDEX 332
GL EXT framebuffer object, 301, 320 Hint, 218, 299
GL EXT framebuffer sRGB, 301, 321
INCR, 171
GL EXT geometry shader4, 304
INCR WRAP, 171
GL EXT gpu shader4, 300
Index*, 295
GL EXT packed depth stencil, 301
IndexPointer, 295
GL EXT packed ?oat, 301
INFO LOG LENGTH, 231–233, 262,
GL EXT texture array, 301, 304
263
GL EXT texture compression rgtc,
InitNames, 298
301, 322
INT, 24, 47, 56, 105, 194, 195, 223, 236
GL EXT texture integer, 301
int, 56, 60
GL EXT texture shared exponent, 301
INT SAMPLER 1D, 56
GL EXT transform feedback, 301
INT SAMPLER 1D ARRAY, 56
gl FragColor, 163, 164, 184
INT SAMPLER 2D, 56
gl FragCoord, 162
INT SAMPLER 2D ARRAY, 56
gl FragCoord.z, 282
INT SAMPLER 3D, 56
gl FragData, 164, 184
INT SAMPLER CUBE, 56
gl FragData[n], 163
INT VEC2, 47, 56
gl FragDepth, 163, 164, 282
INT VEC3, 47, 56
gl FrontFacing, 162
INT VEC4, 47, 56
gl InstanceID, 28, 70
INTENSITY, 297
GL NV conditional render, 300
INTERLEAVED ATTRIBS, 65, 66, 79,
GL NV depth buffer ?oat, 301, 320
232, 264
GL NV half ?oat, 301, 321
InterleavedArrays, 295
GL NV primitive restart, 307
INVALID ENUM, 18, 19, 37, 104, 115,
gl PointCoord, 89
129, 134, 136, 138, 141, 156,
gl PointSize, 88
182, 189, 191, 192, 225, 237,
gl Position, 65, 70, 73
238, 304
gl PrimitiveID, 163
INVALID FRAMEBUFFER OPERA-
gl VertexID, 70, 163
TION, 19, 129, 133, 192, 198,
GLX ARB create context, 322
215, 216
GLX ARB fbcon?g ?oat, 319
INVALID INDEX, 51, 53
GLX ARB framebuffer sRGB, 321
INVALID OPERATION, 19, 32, 34,
GREATER, 142, 158, 171, 172
36–39, 41, 42, 44, 45, 48, 50,
GREEN, 106, 192, 196, 251, 258
58, 59, 64, 66, 71, 76–78, 80,
GREEN BITS, 298
104, 108, 115, 117, 125, 129,
GREEN INTEGER, 106
133, 135–139, 152, 156, 164,
HALF, 193 165, 182, 184, 190–192, 196–
HALF FLOAT, 24, 105, 117, 192, 193, 198, 200, 203–205, 207, 209,
195 222, 224–226, 228, 231, 235,
OpenGL 3.1 - May 28, 2009INDEX 333
236, 238, 295, 296, 302, 303 Light*, 296
INVALID VALUE, 18, 19, 24–28, 34, LIGHTING, 296
36, 37, 39, 42, 47, 48, 51–54, LightModel*, 296
63, 65, 66, 75, 77, 79, 88, 89, LINE, 98, 100, 247
91, 101, 117, 124–126, 129– LINE LOOP, 21, 78
132, 135, 136, 151, 164, 169, LINE SMOOTH, 91, 95, 246
174, 182, 184, 185, 187, 189, LINE SMOOTH HINT, 219, 270
204, 208, 209, 221, 223, 225– LINE STIPPLE, 296
227, 231, 234, 235, 296, 297, LINE STRIP, 21, 78
309 LINE WIDTH, 246
INVERT, 171, 180 LINEAR, 68, 141, 142, 148, 149, 151,
isampler1D, 56 152, 155, 197, 198, 210, 237,
isampler1DArray, 56 250
isampler2D, 56 LINEAR MIPMAP LINEAR, 142,
isampler2DArray, 56 149–151, 210
isampler3D, 56 LINEAR MIPMAP NEAREST, 142,
isamplerCube, 56 149–151, 210
IsBuffer, 229 LINES, 21, 78
IsEnabled, 169, 178, 221, 239, 242, 244, LineStipple, 296
246–248, 253, 254, 267 LineWidth, 91, 296, 307
IsEnabledi, 178, 221, 254 LINK STATUS, 45, 232, 263
IsFramebuffer, 235 LinkProgram, 44, 45, 47, 48, 51, 53, 54,
IsList, 298 63, 64, 66, 80, 164
IsProgram, 232 ListBase, 298
IsQuery, 227, 228 LoadIdentity, 295
IsRenderbuffer, 238 LoadMatrix, 295
IsShader, 231 LoadName, 298
IsTexture, 226 LoadTransposeMatrix, 295
IsVertexArray, 231 LOGIC OP MODE, 254
ivec2, 56 LogicOp, 179, 180
ivec3, 56 LOWER LEFT, 89, 90
ivec4, 56 LUMINANCE, 297
LUMINANCE ALPHA, 297
KEEP, 171, 172, 253
MAJOR VERSION, 227, 274
layout, 61
Map*, 298
LEFT, 174, 182–185, 188, 192
MAP FLUSH EXPLICIT BIT, 35–37
LEQUAL, 142, 155, 158, 171, 172, 250
MAP INVALIDATE BUFFER BIT,
LESS, 142, 158, 171, 172, 254
35, 36
LIGHTi, 296
OpenGL 3.1 - May 28, 2009INDEX 334
MAP INVALIDATE RANGE BIT, 35, 275
36 MAX COMBINED UNIFORM -
MAP READ BIT, 34–37 BLOCKS, 60, 276
MAP UNSYNCHRONIZED BIT, 35, MAX COMBINED VERTEX UNI-
36 FORM COMPONENTS, 49,
MAP WRITE BIT, 34–37 277
MapBuffer, 34, 37, 50, 63, 79, 80, 303 MAX CUBE MAP TEXTURE SIZE,
MapBufferRange, 34–37, 303 125, 208, 271
MapGrid*, 298 MAX DRAW BUFFERS, 164, 174,
matC, 60, 61 176, 184, 185, 189, 278
matCxR, 60, 61 MAX ELEMENTS INDICES, 28, 273
mat2, 46, 56 MAX ELEMENTS VERTICES, 28,
mat2x3, 46, 56 273
mat2x4, 46, 56 MAX FRAGMENT UNIFORM -
mat3, 46, 56 BLOCKS, 59, 276
mat3x2, 46, 56 MAX FRAGMENT UNI-
mat3x4, 46, 56 FORM COMPONENTS, 160,
mat4, 46, 56 275, 277
mat4x2, 46, 56 MAX PROGRAM TEXEL OFFSET,
mat4x3, 46, 56 145, 275
Material*, 296 MAX RECTANGLE TEXTURE -
MatrixMode, 295 SIZE, 125, 273
MAX, 174, 176 MAX RENDERBUFFER SIZE, 204,
MAX 3D TEXTURE SIZE, 125, 207, 271
208, 271 MAX SAMPLES, 204, 205, 278
MAX ARRAY TEXTURE LAYERS, MAX TEXTURE BUFFER SIZE,
125, 271 139, 273
MAX ATTRIB STACK DEPTH, 299 MAX TEXTURE COORDS, 298
MAX CLIENT ATTRIB STACK - MAX TEXTURE IMAGE UNITS, 69,
DEPTH, 299 162, 275
MAX CLIP DISTANCES, 271, 302, MAX TEXTURE LOD BIAS, 144,
308 271
MAX CLIP PLANES, 302 MAX TEXTURE SIZE, 125, 208, 271
MAX COLOR ATTACHMENTS, MAX TEXTURE UNITS, 298
182–184, 200, 206, 215, 278 MAX TRANSFORM FEEDBACK -
MAX COMBINED FRAGMENT - INTERLEAVED COMPO-
UNIFORM COMPONENTS, NENTS, 66, 269
160, 277 MAX TRANSFORM FEEDBACK -
MAX COMBINED TEXTURE - SEPARATE ATTRIBS, 65,
IMAGE UNITS, 69, 115, 222, 79, 80, 230, 269
OpenGL 3.1 - May 28, 2009INDEX 335
MAX TRANSFORM FEEDBACK - NewList, 298
SEPARATE COMPONENTS, NICEST, 219
66, 269 NO ERROR, 18
MAX UNIFORM BLOCK SIZE, 52, NONE, 70, 142, 154, 155, 158, 162,
276 180, 182–185, 189, 192, 199,
MAX UNIFORM BUFFER BIND- 212, 213, 223, 236, 250, 251,
INGS, 63, 230, 276 258, 303, 309
MAX VARYING COMPONENTS, 65, NOOP, 180
275, 302 noperspective, 83
MAX VARYING FLOATS, 302 NOR, 180
MAX VERTEX ATTRIBS, 23–26, 29, Normal3*, 295
46, 48, 234, 235, 275 NORMALIZE, 296
MAX VERTEX TEXTURE IMAGE - NormalPointer, 295
UNITS, 69, 275 NOTEQUAL, 142, 158, 171, 172
MAX VERTEX UNIFORM - NULL, 30, 31, 33, 36, 40, 41, 43, 47,
BLOCKS, 59, 276 51, 54, 67, 230, 233, 239, 240,
MAX VERTEX UNIFORM COMPO- 243
NENTS, 49, 275, 277 NUM COMPRESSED TEXTURE -
MAX VIEWPORT DIMS, 228, 272 FORMATS, 118, 273
MIN, 174, 176 NUM EXTENSIONS, 227, 274
MIN PROGRAM TEXEL OFFSET, NV, 308
145, 275
ONE, 176, 177, 254
MINOR VERSION, 227, 274
ONE MINUS CONSTANT ALPHA,
MIRRORED REPEAT, 141, 142, 147
177
MultiDrawArrays, 27
ONE MINUS CONSTANT COLOR,
MultiDrawElements, 28, 40
177
MULTISAMPLE, 88, 90, 95, 100, 169,
ONE MINUS DST ALPHA, 177
180, 248
ONE MINUS DST COLOR, 177
MultMatrix, 295
ONE MINUS SRC ALPHA, 177
MultTransposeMatrix, 295
ONE MINUS SRC COLOR, 177
NAND, 180 OR, 180
NEAREST, 68, 141, 142, 147, 149, OR INVERTED, 180
151–153, 159, 197, 210 OR REVERSE, 180
NEAREST MIPMAP - Ortho, 295
LINEAR, 142, 149–152, 155, OUT OF MEMORY, 18, 19, 34, 36,
210 204
NEAREST MIPMAP NEAREST, 142,
PACK ALIGNMENT, 191, 261
149–153, 159, 210
NEVER, 142, 158, 171, 172
OpenGL 3.1 - May 28, 2009INDEX 336
PACK IMAGE HEIGHT, 191, 225, POLYGON SMOOTH, 95, 100, 247
261 POLYGON SMOOTH HINT, 219, 270
PACK LSB FIRST, 191, 261 POLYGON STIPPLE, 297
PACK ROW LENGTH, 191, 261 PolygonMode, 98, 100, 101, 297
PACK SKIP IMAGES, 191, 225, 261 PolygonOffset, 99
PACK SKIP PIXELS, 191, 261 PolygonStipple, 297
PACK SKIP ROWS, 191, 261 PopAttrib, 299
PACK SWAP BYTES, 191, 261 PopClientAttrib, 299
PassThrough, 298 PopMatrix, 295
PERSPECTIVE CORRECTION - PopName, 298
HINT, 299 PRIMITIVE RESTART, 26, 242, 307,
PIXEL PACK BUFFER, 31, 102, 189 308
PIXEL PACK BUFFER BINDING, PRIMITIVE RESTART INDEX, 242,
194, 225, 261 308
PIXEL UNPACK BUFFER, 31, 102 PrimitiveRestartIndex, 26
PIXEL UNPACK BUFFER BIND- PRIMITIVES GENERATED, 81, 228
ING, 104, 134, 261 PrioritizeTextures, 298
PixelStore, 101, 102, 191, 198, 199 PROXY TEXTURE 1D, 117, 127, 155,
PixelZoom, 297 223
POINT, 98, 100, 247 PROXY TEXTURE 1D ARRAY, 117,
POINT FADE THRESHOLD SIZE, 126, 155, 223
89, 246 PROXY TEXTURE 2D, 117, 126, 155,
POINT SIZE, 246 223
POINT SIZE GRANULARITY, 272 PROXY TEXTURE 2D ARRAY, 116,
POINT SIZE RANGE, 272 117, 155, 223
POINT SMOOTH, 296 PROXY TEXTURE 3D, 116, 155, 223
POINT SMOOTH HINT, 299 PROXY TEXTURE CUBE MAP, 117,
POINT SPRITE, 296 126, 155, 223
POINT SPRITE COORD ORIGIN, PROXY TEXTURE RECTANGLE,
89, 90, 246 117, 126, 134, 136, 155, 223
PointParameter, 89 PushAttrib, 299
PointParameter*, 89 PushClientAttrib, 299
POINTS, 21, 78, 98 PushMatrix, 295
PointSize, 88 PushName, 298
POLYGON, 296
QUAD STRIP, 296
POLYGON OFFSET FACTOR, 247
QUADS, 296
POLYGON OFFSET FILL, 100, 247
QUERY BY REGION NO WAIT, 77
POLYGON OFFSET LINE, 100, 247
QUERY BY REGION WAIT, 77
POLYGON OFFSET POINT, 100, 247
QUERY COUNTER BITS, 228, 274
POLYGON OFFSET UNITS, 247
OpenGL 3.1 - May 28, 2009INDEX 337
QUERY NO WAIT, 77 RED INTEGER, 106
QUERY RESULT, 228, 268 RENDERBUFFER, 202–206, 216,
QUERY RESULT AVAILABLE, 229, 236–238, 259
268 RENDERBUFFER ALPHA SIZE,
QUERY WAIT, 77 238, 260
RENDERBUFFER BINDING, 203,
R, 301
259
G11F B10F, 119, 122
R11F
RENDERBUFFER BLUE SIZE, 238,
R16, 119, 121, 140
260
R16 SNORM, 119, 121
RENDERBUFFER DEPTH SIZE,
R16F, 119, 121, 140
238, 260
R16I, 119, 122, 140
RENDERBUFFER GREEN SIZE,
R16UI, 119, 122, 140
238, 260
R32F, 119, 121, 140
RENDERBUFFER HEIGHT, 204, 238,
R32I, 119, 122, 140
260
R32UI, 119, 122, 140
RENDERBUFFER INTERNAL FOR-
R3 G3 B2, 121
MAT, 204, 238, 260
R8, 119, 121, 140, 154, 251
RENDERBUFFER RED SIZE, 238,
R8 SNORM, 119, 121
260
R8I, 119, 122, 140
RENDERBUFFER SAMPLES, 204,
R8UI, 119, 122, 140
213, 215, 238, 260
RASTERIZER DISCARD, 85
RENDERBUFFER STENCIL SIZE,
RasterPos*, 296
238, 260
READ BUFFER, 192, 213, 217, 257
RENDERBUFFER WIDTH, 204, 238,
READ FRAMEBUFFER,
260
199–201, 205, 207, 215, 236,
RenderbufferStorage, 204, 205, 214
256
RenderbufferStorageMultisample, 204,
READ FRAMEBUFFER BINDING,
205, 309
129, 133, 190, 192, 193, 198,
RENDERER, 226, 274
202, 256
RenderMode, 298
READ ONLY, 31, 36, 37
REPEAT, 141, 142, 147, 155
READ WRITE, 31, 33, 36, 37, 243
REPLACE, 171
ReadBuffer, 183, 191, 192, 198
RESCALE NORMAL, 295
ReadPixels, 80, 101, 107, 129, 189–
RG, 106, 117, 121, 122, 124, 161, 192,
192, 194, 215, 225, 297
196, 211, 226, 301
Rect*, 296
RG16, 119, 121, 140
RED, 106, 117, 121, 122, 124, 141, 143,
RG16 SNORM, 119, 121
161, 192, 196, 211, 226, 251,
RG16F, 119, 121, 140
258
RG16I, 119, 122, 140
RED BITS, 298
RG16UI, 119, 122, 140
OpenGL 3.1 - May 28, 2009INDEX 338
RG32F, 119, 121, 140 RGBA2, 121
RG32I, 119, 122, 140 RGBA32F, 119, 122, 140
RG32UI, 119, 122, 140 RGBA32I, 119, 122, 140
RG8, 119, 121, 140 RGBA32UI, 119, 122, 140
RG8 SNORM, 119, 121 RGBA4, 121
RG8I, 119, 122, 140 RGBA8, 119, 121, 140
RG8UI, 119, 122, 140 RGBA8 SNORM, 119, 121
RG INTEGER, 106 RGBA8I, 119, 122, 140
RGB, 106, 108, 113, 117, 120–122, RGBA8UI, 119, 122, 140
124, 161, 177, 192, 194, 196, RGBA INTEGER, 106
211, 226 RIGHT, 174, 182–185, 188, 192
RGB10, 121 Rotate, 295
RGB10 A2, 119, 121
SAMPLE ALPHA TO COVERAGE,
RGB12, 121
169, 248
RGB16, 119, 121
SAMPLE ALPHA TO ONE, 169, 170,
RGB16 SNORM, 119, 121
248
RGB16F, 119, 121
SAMPLE BUFFERS, 87, 90, 95, 100,
RGB16I, 119, 122
129, 169, 173, 180, 186, 190,
RGB16UI, 119, 122
191, 198, 215, 278
RGB32F, 119, 121
SAMPLE COVERAGE, 169, 170, 248
RGB32I, 119, 122
SAMPLE COVERAGE INVERT, 169,
RGB32UI, 119, 122
170, 248
RGB4, 121
SAMPLE COVERAGE VALUE, 169,
RGB5, 121
170, 248
RGB5 A1, 121
SampleCoverage, 170
RGB8, 119, 121
sampler1D, 56
RGB8 SNORM, 119, 121
sampler1DArray, 56
RGB8I, 119, 122
sampler1DArrayShadow, 56
RGB8UI, 119, 122
sampler1DShadow, 56, 69, 161
RGB9 E5, 119, 122, 159, 194
sampler2D, 56, 64
RGB INTEGER, 106
sampler2DArray, 56
RGBA, 106, 108, 113, 117, 121, 122,
sampler2DArrayShadow, 56
124, 154, 161, 192, 211, 226,
sampler2DRect, 56
251, 260, 297
sampler2DRectShadow, 56, 69, 162
RGBA12, 121
sampler2DShadow, 56, 69, 162
RGBA16, 119, 121, 140
sampler3D, 56
RGBA16 SNORM, 119, 121
SAMPLER 1D, 56
RGBA16F, 119, 121, 140
SAMPLER 1D ARRAY, 56
RGBA16I, 119, 122, 140
RGBA16UI, 119, 122, 140
OpenGL 3.1 - May 28, 2009INDEX 339
SAMPLER 1D ARRAY SHADOW, SMOOTH LINE WIDTH RANGE
56 (v1.1: LINE WIDTH -
SAMPLER 1D SHADOW, 56 RANGE), 273
SAMPLER 2D, 56 SRC ALPHA, 177
SAMPLER 2D ARRAY, 56 SRC ALPHA SATURATE, 177
SAMPLER 2D ARRAY SHADOW, SRC COLOR, 177
56 SRGB, 159, 175, 178, 237
SAMPLER 2D RECT, 56 SRGB8, 119, 121, 159
SAMPLER 2D RECT SHADOW, 56 SRGB8 ALPHA8, 119, 121, 159
SAMPLER 2D SHADOW, 56 SRGB ALPHA, 159
SAMPLER 3D, 56 STATIC COPY, 31, 33
SAMPLER CUBE, 56 STATIC DRAW, 31, 33, 243
SAMPLER CUBE SHADOW, 56 STATIC READ, 31, 33
samplerCube, 56 std140, 52, 61
samplerCubeShadow, 56 STENCIL, 188, 189, 236, 251, 258, 302
SAMPLES, 87, 88, 173, 198, 215, 278 STENCIL ATTACHMENT, 201, 206,
SAMPLES PASSED, 77, 173, 228 212, 303
Scale, 295 STENCIL ATTACMENT, 302, 303
Scissor, 169 STENCIL BACK FAIL, 253
SCISSOR BOX, 253 STENCIL BACK FUNC, 253
SCISSOR TEST, 169, 253 STENCIL BACK PASS DEPTH -
SecondaryColor3*, 295 FAIL, 253
SecondaryColorPointer, 295 STENCIL BACK PASS DEPTH -
SelectBuffer, 298 PASS, 253
SEPARATE ATTRIBS, 65, 66, 79, 80, STENCIL BACK REF, 253
232 STENCIL BACK VALUE MASK, 253
SET, 180 STENCIL BACK WRITEMASK, 255
ShadeModel, 296 STENCIL BITS, 298
SHADER SOURCE LENGTH, 231, STENCIL BUFFER, 303
234, 262 STENCIL BUFFER BIT, 187, 189,
SHADER TYPE, 72, 231, 262 196–198
ShaderSource, 43, 234 STENCIL CLEAR VALUE, 255
SHADING LANGUAGE VERSION, STENCIL FAIL, 253
226, 227, 274 STENCIL FUNC, 253
SHORT, 24, 105, 194, 195 STENCIL INDEX, 106, 116, 191, 193,
SIGNED NORMALIZED, 223, 236 204, 212, 225
SMOOTH LINE WIDTH GRANU- STENCIL INDEX1, 204
LARITY STENCIL INDEX16, 204
(v1.1: LINE WIDTH GRAN- STENCIL INDEX4, 204
ULARITY), 273 STENCIL INDEX8, 204
OpenGL 3.1 - May 28, 2009INDEX 340
STENCIL PASS DEPTH FAIL, 253 TexSubImage, 131
STENCIL PASS DEPTH PASS, 253 TexSubImage*, 133, 138, 291
STENCIL REF, 253 TexSubImage*D, 101
STENCIL TEST, 170, 253 TexSubImage1D, 102, 130–133, 136
STENCIL VALUE MASK, 253 TexSubImage2D, 102, 130–133, 136
STENCIL WRITEMASK, 255 TexSubImage3D, 102, 130, 131, 133,
StencilFunc, 170–172, 284 136
StencilFuncSeparate, 170, 171 TEXTURE, 208, 212, 216, 236, 237
StencilMask, 186, 284 TEXTUREi, 115
StencilMaskSeparate, 186 TEXTURE0, 115, 252
StencilOp, 170–172 TEXTURE x SIZE, 251
StencilOpSeparate, 170–172 TEXTURE x TYPE, 251
STEREO, 278 TEXTURE xD, 249
STREAM COPY, 31, 32 TEXTURE 1D, 117, 127, 130, 141,
STREAM DRAW, 31, 32 152, 156, 157, 208, 222–224,
STREAM READ, 31, 32 298
SUBPIXEL BITS, 271 TEXTURE 1D ARRAY, 117, 126, 129,
130, 141, 152, 156, 157, 222–
TexBuffer, 138
224, 249, 298
TexCoord*, 295
TEXTURE 2D, 64, 117, 126, 129, 130,
TexCoordPointer, 295
141, 152, 156, 157, 208, 222–
TexEnv, 298
224, 298
TexGen*, 296
TEXTURE 2D ARRAY, 116, 117, 124,
TexImage, 115, 131
130, 136, 138, 141, 152, 156,
TexImage*, 107, 291, 297, 308
157, 222–224, 249, 298
TexImage*D, 101, 102
TEXTURE 3D, 116, 124, 130, 141,
TexImage1D, 102, 123, 126, 127, 129–
152, 155–157, 207, 208, 222–
131, 134, 136, 150, 155
224, 298
TexImage2D, 102, 123, 126, 127, 129,
TEXTURE ALPHA SIZE, 223
131, 134, 136, 150, 155
TEXTURE ALPHA TYPE, 223
TexImage3D, 102, 115, 116, 123, 124,
TEXTURE BASE LEVEL, 141, 142,
126, 127, 131, 134, 136, 150,
149, 151, 155, 210, 250
155, 225
TEXTURE BINDING xD, 249
TexParameter, 115, 141, 291, 298
TEXTURE BINDING 1D ARRAY,
TexParameter*, 298
249
TexParameter[if], 144, 151
TEXTURE BINDING 2D ARRAY,
TexParameterI, 141
249
TexParameterIiv, 141
TEXTURE BINDING BUFFER, 249
TexParameterIuiv, 141
TEXTURE BINDING CUBE MAP,
TexParameteriv, 141
249
OpenGL 3.1 - May 28, 2009INDEX 341
TEXTURE BINDING RECTANGLE, ITIVE X, 126, 129, 130, 143,
249 207, 208, 223, 224, 249
TEXTURE BLUE SIZE, 223 TEXTURE CUBE MAP POS-
TEXTURE BLUE TYPE, 223 ITIVE Y, 126, 129, 130, 143,
TEXTURE BORDER, 135, 137, 224 207, 208, 223, 224, 249
TEXTURE BORDER COLOR, 141, TEXTURE CUBE MAP POS-
142, 148, 154, 155, 222, 250, ITIVE Z, 126, 129, 130, 143,
304 207, 208, 223, 224, 249
TEXTURE BUFFER, 31, 139, 156, TEXTURE DEPTH, 135, 137, 224, 251
157, 223, 249, 279 TEXTURE DEPTH SIZE, 223
TEXTURE BUFFER DATA STORE - TEXTURE DEPTH TYPE, 223
BINDING, 251 TEXTURE ENV, 298
TEXTURE COMPARE FAIL - TEXTURE FILTER CONTROL, 298
VALUE ARB, 317 TEXTURE GEN *, 296
TEXTURE COMPARE FUNC, 142, TEXTURE GREEN SIZE, 223
155, 157, 158, 250 TEXTURE GREEN TYPE, 223
TEXTURE COMPARE - TEXTURE HEIGHT, 133, 135, 137,
MODE, 69, 70, 142, 155, 157, 138, 224, 251
158, 162, 250 TEXTURE INTERNAL FORMAT,
TEXTURE COMPONENTS, 297 135, 137, 224, 251, 297
TEXTURE COMPRESSED, 251 TEXTURE LOD BIAS, 142, 144, 250,
TEXTURE COMPRESSED - 298
IMAGE SIZE, 135, 137, 223, TEXTURE MAG FILTER, 142, 152,
226, 251 153, 155, 159, 250
TEXTURE COMPRESSION HINT, TEXTURE MAX LEVEL, 141, 142,
219, 270 151, 155, 210, 250
TEXTURE CUBE MAP, 117, 126, TEXTURE MAX LOD, 141, 142, 144,
141, 152, 156, 157, 222, 223, 155, 250
249, 298 TEXTURE MIN FILTER, 141, 142,
TEXTURE CUBE MAP *, 126 146–150, 152, 153, 155, 159,
TEXTURE CUBE MAP NEG- 210, 250
ATIVE X, 126, 129, 130, 143, TEXTURE MIN LOD, 141, 142, 144,
207, 208, 223, 224, 249 155, 250
TEXTURE CUBE MAP NEG- TEXTURE PRIORITY, 298
ATIVE Y, 126, 129, 130, 143, TEXTURE RECTANGLE, 117, 126,
207, 208, 223, 224, 249 129–131, 134, 136, 141, 156,
TEXTURE CUBE MAP NEG- 157, 207, 208, 222–225, 249
ATIVE Z, 126, 129, 130, 143, TEXTURE RECTANGLE ARB, 319
207, 208, 223, 224, 249 TEXTURE RED SIZE, 223
TEXTURE CUBE MAP POS- TEXTURE RED TYPE, 223
OpenGL 3.1 - May 28, 2009INDEX 342
TEXTURE SHARED SIZE, 223, 251 uint, 60
TEXTURE STENCIL SIZE, 223 Uniform, 14, 57
TEXTURE WIDTH, 133, 135, 137, Uniform*, 49, 50, 58, 59, 64
138, 224, 251 Uniform*ffvg, 58
TEXTURE WRAP R, 141, 142, 147, Uniform*ifvg, 58
250, 297 Uniform*uifvg, 58
TEXTURE WRAP S, 141, 142, 147, Uniform1f, 15
250, 297 Uniform1i, 14
TEXTURE WRAP T, 141, 142, 147, Uniform1ifvg, 58, 64
250, 297 Uniform1iv, 58
TRANSFORM FEEDBACK - Uniform2fif uig*, 58
BUFFER, 31, 79, 80 Uniform2f, 15
TRANSFORM FEEDBACK - Uniform2i, 15
BUFFER BINDING, 230, 269 Uniform3f, 15
TRANSFORM FEEDBACK - Uniform3i, 15
BUFFER MODE, 232, 264 Uniform4f, 13, 15
TRANSFORM FEEDBACK - Uniform4ffvg, 59
BUFFER SIZE, 230, 269 Uniform4i, 15
TRANSFORM FEEDBACK - Uniform4ifvg, 59
BUFFER START, 230, 269 UNIFORM ARRAY STRIDE, 57, 61,
TRANSFORM FEEDBACK - 266
PRIMITIVES WRITTEN, 80, UNIFORM BLOCK ACTIVE UNI-
81, 228 FORM INDICES, 52, 266
TRANSFORM FEEDBACK VARY- UNIFORM BLOCK ACTIVE UNI-
ING MAX LENGTH, 67, FORMS, 52, 266
232, 264 UNIFORM BLOCK BINDING, 52,
TRANSFORM - 266
FEEDBACK VARYINGS, 66, UNIFORM BLOCK DATA SIZE, 52,
232, 264 64, 266
TransformFeedbackVaryings, 65, 66, 80 UNIFORM BLOCK INDEX, 57, 265
Translate, 295 UNIFORM BLOCK NAME -
TRIANGLE FAN, 22, 78 LENGTH, 52
TRIANGLE STRIP, 21, 22, 78 UNIFORM BLOCK REFERENCED -
TRIANGLES, 22, 78 BY FRAGMENT SHADER,
TRUE, 25, 31, 36, 38, 43, 45, 58, 71, 52, 266
101, 102, 162, 170, 185, 191, UNIFORM BLOCK REFERENCED -
193, 221, 226, 228, 229, 231, BY VERTEX SHADER, 52,
232, 234, 235, 238, 248, 254, 266
255, 296 UNIFORM BUFFER, 31, 63
UNIFORM BUFFER BINDING, 230,
OpenGL 3.1 - May 28, 2009INDEX 343
265 UNSIGNED BYTE 3 3 2, 105, 108,
UNIFORM BUFFER OFFSET - 109, 195
ALIGNMENT, 63, 276 UNSIGNED INT, 24, 27, 47, 56, 105,
UNIFORM BUFFER SIZE, 230 194, 195, 223, 236
UNIFORM BUFFER START, 230 UNSIGNED INT 10 10 10 2, 105,
UNIFORM IS ROW MAJOR, 57, 266 108, 111, 195
UNIFORM MATRIX STRIDE, 57, 60, UNSIGNED INT 10F -
61, 266 11F 11F REV, 105, 108, 111,
UNIFORM NAME LENGTH, 55, 265 113, 117, 193–195
UNIFORM OFFSET, 57, 265 UNSIGNED INT 24 8, 104, 105, 108,
UNIFORM SIZE, 55, 265 111, 191, 194, 195
UNIFORM TYPE, 55, 265 UNSIGNED INT 2 10 10 10 REV,
Uniformf1,2,3,4gui, 57 105, 108, 111, 195
Uniformf1,2,3,4guiv, 57 UNSIGNED INT 5 9 9 9 REV,
UniformBlockBinding, 63, 64 105, 108, 111, 113, 117, 120,
UniformMatrix2x4fv, 58 193–195
UniformMatrix3fv, 59 UNSIGNED INT 8 8 8 8, 105, 108,
UniformMatrixf234gfv, 57, 58 111, 195
UniformMatrixf2x3,3x2,2x4,4x2,3x4,4x3UNSIGNEDgfv, INT 8 8 8 8 REV, 105,
57, 58 108, 111, 195
UnmapBuffer, 35, 37, 38, 50, 291 UNSIGNED INT SAMPLER 1D, 56
UNPACK ALIGNMENT, 102, 107, UNSIGNED INT SAMPLER 1D AR-
116, 261 RAY, 56
UNPACK IMAGE HEIGHT, 102, 116, UNSIGNED INT SAMPLER 2D, 56
261 UNSIGNED INT SAMPLER 2D AR-
UNPACK LSB FIRST, 102, 261 RAY, 56
UNPACK ROW LENGTH, 102, 104, UNSIGNED INT SAMPLER 3D, 56
107, 116, 261 UNSIGNED INT SAMPLER CUBE,
UNPACK SKIP IMAGES, 102, 116, 56
126, 261 UNSIGNED INT VEC2, 47, 56
UNPACK SKIP PIXELS, 102, 107, UNSIGNED INT VEC3, 47, 56
261 UNSIGNED INT VEC4, 47, 56
UNPACK SKIP ROWS, 102, 107, 261 UNSIGNED NORMALIZED, 223, 236
UNPACK SWAP BYTES, 102, 104, UNSIGNED SHORT, 24, 27, 105, 194,
106, 261 195
unsigned int, 56 UNSIGNED SHORT 1 5 5 5 REV,
UNSIGNED BYTE, 24, 27, 105, 194, 105, 108, 110, 195
195 UNSIGNED SHORT 4 4 4 4, 105,
UNSIGNED BYTE 2 3 3 REV, 105, 108, 110, 195
108, 109, 195 UNSIGNED SHORT 4 4 4 4 REV,
OpenGL 3.1 - May 28, 2009INDEX 344
105, 108, 110, 195 VERTEX ATTRIB ARRAY SIZE,
UNSIGNED SHORT 5 5 5 1, 105, 234, 240
108, 110, 195 VERTEX ATTRIB ARRAY STRIDE,
UNSIGNED SHORT 5 6 5, 105, 108, 234, 240
110, 195 VERTEX ATTRIB ARRAY TYPE,
UNSIGNED SHORT 5 6 5 REV, 105, 234, 240
108, 110, 195 VERTEX PROGRAM POINT SIZE,
UPPER LEFT, 89, 90, 246 89, 267
usampler1D, 56 VERTEX PROGRAM TWO SIDE,
usampler1DArray, 56 296
usampler2D, 56 VERTEX SHADER, 42, 231
usampler2DArray, 56 VertexAttrib, 23, 77
usampler3D, 56 VertexAttrib*, 23, 24, 46, 295
usamplerCube, 56 VertexAttrib1*, 23
UseProgram, 45, 67, 80 VertexAttrib2*, 23
uvec2, 56 VertexAttrib3*, 23
uvec3, 56 VertexAttrib4, 23
uvec4, 56 VertexAttrib4*, 23
VertexAttrib4N, 23
VALIDATE STATUS, 71, 232, 263
VertexAttrib4Nub, 23
ValidateProgram, 71, 232
VertexAttribI, 23
vec2, 46, 56
VertexAttribI4, 24
vec3, 46, 56
VertexAttribIPointer, 24, 25, 234
vec4, 46, 56, 59
VertexAttribPointer, 24, 25, 39, 41, 234,
VENDOR, 226, 274
296
VERSION, 226, 227, 274
VertexPointer, 295
Vertex*, 295
VIEWPORT, 244
VERTEX ARRAY BINDING, 222,
Viewport, 74
234, 242
VERTEX ATTRIB ARRAY - WGL ARB create context, 322
BUFFER BINDING, 39, 234, WGL ARB framebuffer sRGB, 321
241 WGL ARB pixel format ?oat, 319
VERTEX ATTRIB ARRAY EN- WindowPos*, 296
ABLED, 234, 240 WRITE ONLY, 31, 36, 37
VERTEX ATTRIB ARRAY INTE-
XOR, 180
GER, 234, 240
VERTEX ATTRIB ARRAY NOR-
ZERO, 171, 176, 177, 254
MALIZED, 234, 240
VERTEX ATTRIB ARRAY -
POINTER, 235, 240
OpenGL 3.1 - May 28, 2009