R
TheOpenGL GraphicsSystem:
ASpecification
(Version2.1-December1,2006)
MarkSegal
KurtAkeley
Editor (version 1.1): Chris Frazier
Editor (versions 1.2-2.1): Jon Leech
Editor (version 2.0): Pat BrownCopyrightc 1992-2006SiliconGraphics,Inc.
Thisdocumentcontainsunpublishedinformationof
SiliconGraphics,Inc.
This document is protected by copyright, and contains information proprietary to
Silicon Graphics, Inc. Any copying, adaptation, distribution, public performance,
or public display of this document without the express written consent of Silicon
Graphics, Inc. is strictly prohibited. The receipt or possession of this document
does not convey any rights to reproduce, disclose, or distribute its contents, or to
manufacture,use,orsellanythingthatitmaydescribe,inwholeorinpart.
U.S.GovernmentRestrictedRightsLegend
Use,duplication,ordisclosurebytheGovernmentissubjecttorestrictionssetforth
in FAR 52.227.19(c)(2) or subparagraph (c)(1)(ii) of the Rights in Technical Data
andComputerSoftwareclauseatDFARS252.227-7013and/orinsimilarorsucces-
sorclausesintheFARortheDODorNASAFARSupplement. Unpublishedrights
reservedunderthecopyrightlawsoftheUnitedStates. Contractor/manufactureris
SiliconGraphics,Inc.,1600AmphitheatreParkway,MountainView,CA94043.
OpenGLisaregisteredtrademarkofSiliconGraphics,Inc.
UnixisaregisteredtrademarkofTheOpenGroup.
The”X”deviceandXWindowsSystemaretrademarksof
TheOpenGroup.Contents
1 Introduction 1
1.1 FormattingofOptionalFeatures . . . . . . . . . . . . . . . . . . 1
1.2 WhatistheOpenGLGraphicsSystem? . . . . . . . . . . . . . . 1
1.3 Programmer’sViewofOpenGL . . . . . . . . . . . . . . . . . . 2
1.4 Implementor’sViewofOpenGL . . . . . . . . . . . . . . . . . . 2
1.5 OurView . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.6 CompanionDocuments . . . . . . . . . . . . . . . . . . . . . . . 3
2 OpenGLOperation 4
2.1 OpenGLFundamentals . . . . . . . . . . . . . . . . . . . . . . . 4
2.1.1 Floating-PointComputation . . . . . . . . . . . . . . . . 6
2.2 GLState . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.3 GLCommandSyntax . . . . . . . . . . . . . . . . . . . . . . . . 7
2.4 BasicGLOperation . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.5 GLErrors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.6 Begin/EndParadigm . . . . . . . . . . . . . . . . . . . . . . . . 12
2.6.1 BeginandEnd . . . . . . . . . . . . . . . . . . . . . . . 15
2.6.2 PolygonEdges . . . . . . . . . . . . . . . . . . . . . . . 19
2.6.3 GLCommandswithinBegin/End . . . . . . . . . . . . . 19
2.7 VertexSpecification . . . . . . . . . . . . . . . . . . . . . . . . . 20
2.8 VertexArrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.9 BufferObjects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
2.9.1 VertexArraysinBufferObjects . . . . . . . . . . . . . . 38
2.9.2 ArrayIndicesinBufferObjects . . . . . . . . . . . . . . 39
2.9.3 BufferObjectState . . . . . . . . . . . . . . . . . . . . . 39
2.10 Rectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
2.11 CoordinateTransformations . . . . . . . . . . . . . . . . . . . . 40
2.11.1 ControllingtheViewport . . . . . . . . . . . . . . . . . . 42
2.11.2 Matrices. . . . . . . . . . . . . . . . . . . . . . . . . . . 43
iii CONTENTS
2.11.3 NormalTransformation. . . . . . . . . . . . . . . . . . . 48
2.11.4 GeneratingTextureCoordinates . . . . . . . . . . . . . . 50
2.12 Clipping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
2.13 CurrentRasterPosition . . . . . . . . . . . . . . . . . . . . . . . 54
2.14 ColorsandColoring . . . . . . . . . . . . . . . . . . . . . . . . . 57
2.14.1 Lighting . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
2.14.2 LightingParameterSpecification . . . . . . . . . . . . . . 64
2.14.3 ColorMaterial . . . . . . . . . . . . . . . . . . . . . . . 66
2.14.4 LightingState . . . . . . . . . . . . . . . . . . . . . . . . 68
2.14.5 ColorIndexLighting . . . . . . . . . . . . . . . . . . . . 68
2.14.6 ClampingorMasking . . . . . . . . . . . . . . . . . . . 69
2.14.7 Flatshading . . . . . . . . . . . . . . . . . . . . . . . . . 69
2.14.8 ColorandAssociatedDataClipping . . . . . . . . . . . . 70
2.14.9 FinalColorProcessing . . . . . . . . . . . . . . . . . . . 71
2.15 VertexShaders . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
2.15.1 ShaderObjects . . . . . . . . . . . . . . . . . . . . . . . 72
2.15.2 ProgramObjects . . . . . . . . . . . . . . . . . . . . . . 73
2.15.3 ShaderVariables . . . . . . . . . . . . . . . . . . . . . . 75
2.15.4 ShaderExecution . . . . . . . . . . . . . . . . . . . . . . 84
2.15.5 RequiredState . . . . . . . . . . . . . . . . . . . . . . . 88
3 Rasterization 90
3.1 Invariance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
3.2 Antialiasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
3.2.1 Multisampling . . . . . . . . . . . . . . . . . . . . . . . 93
3.3 Points . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
3.3.1 BasicPointRasterization . . . . . . . . . . . . . . . . . . 97
3.3.2 PointRasterizationState . . . . . . . . . . . . . . . . . . 101
3.3.3 PointMultisampleRasterization . . . . . . . . . . . . . . 101
3.4 LineSegments . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
3.4.1 BasicLineSegmentRasterization . . . . . . . . . . . . . 102
3.4.2 OtherLineSegment Features . . . . . . . . . . . . . . . . 104
3.4.3 LineRasterizationState . . . . . . . . . . . . . . . . . . 107
3.4.4 LineMultisampleRasterization . . . . . . . . . . . . . . 107
3.5 Polygons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
3.5.1 BasicPolygonRasterization . . . . . . . . . . . . . . . . 108
3.5.2 Stippling . . . . . . . . . . . . . . . . . . . . . . . . . . 110
3.5.3 Antialiasing . . . . . . . . . . . . . . . . . . . . . . . . . 111
3.5.4 OptionsControllingPolygonRasterization . . . . . . . . 111
3.5.5 DepthOffset . . . . . . . . . . . . . . . . . . . . . . . . 111
Version2.1-December1,2006CONTENTS iii
3.5.6 PolygonMultisampleRasterization . . . . . . . . . . . . 113
3.5.7 PolygonRasterizationState . . . . . . . . . . . . . . . . 113
3.6 PixelRectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
3.6.1 PixelStorageModesandPixelBufferObjects . . . . . . . 114
3.6.2 TheImagingSubset . . . . . . . . . . . . . . . . . . . . 115
3.6.3 PixelTransferModes . . . . . . . . . . . . . . . . . . . . 116
3.6.4 RasterizationofPixelRectangles . . . . . . . . . . . . . 127
3.6.5 PixelTransferOperations . . . . . . . . . . . . . . . . . 138
3.6.6 PixelRectangleMultisampleRasterization . . . . . . . . 148
3.7 Bitmaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
3.8 Texturing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150
3.8.1 TextureImageSpecification . . . . . . . . . . . . . . . . 151
3.8.2 AlternateTextureImageSpecificationCommands . . . . 159
3.8.3 CompressedTextureImages . . . . . . . . . . . . . . . . 165
3.8.4 TextureParameters . . . . . . . . . . . . . . . . . . . . . 168
3.8.5 DepthComponentTextures . . . . . . . . . . . . . . . . 170
3.8.6 CubeMapTextureSelection . . . . . . . . . . . . . . . . 170
3.8.7 TextureWrapModes . . . . . . . . . . . . . . . . . . . . 171
3.8.8 TextureMinification . . . . . . . . . . . . . . . . . . . . 172
3.8.9 TextureMagnification . . . . . . . . . . . . . . . . . . . 178
3.8.10 TextureCompleteness . . . . . . . . . . . . . . . . . . . 179
3.8.11 TextureStateandProxyState . . . . . . . . . . . . . . . 180
3.8.12 TextureObjects . . . . . . . . . . . . . . . . . . . . . . . 182
3.8.13 TextureEnvironmentsandTextureFunctions . . . . . . . 184
3.8.14 TextureComparisonModes . . . . . . . . . . . . . . . . 187
3.8.15 sRGBTextureColorConversion . . . . . . . . . . . . . . 191
3.8.16 TextureApplication. . . . . . . . . . . . . . . . . . . . . 191
3.9 ColorSum . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
3.10 Fog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
3.11 FragmentShaders . . . . . . . . . . . . . . . . . . . . . . . . . . 196
3.11.1 ShaderVariables . . . . . . . . . . . . . . . . . . . . . . 196
3.11.2 ShaderExecution . . . . . . . . . . . . . . . . . . . . . . 197
3.12 AntialiasingApplication . . . . . . . . . . . . . . . . . . . . . . 199
3.13 MultisamplePointFade . . . . . . . . . . . . . . . . . . . . . . . 200
4 Per-FragmentOperationsandtheFramebuffer 201
4.1 Per-FragmentOperations . . . . . . . . . . . . . . . . . . . . . . 202
4.1.1 PixelOwnershipTest . . . . . . . . . . . . . . . . . . . . 202
4.1.2 ScissorTest . . . . . . . . . . . . . . . . . . . . . . . . . 203
4.1.3 MultisampleFragmentOperations . . . . . . . . . . . . . 203
Version2.1-December1,2006iv CONTENTS
4.1.4 AlphaTest . . . . . . . . . . . . . . . . . . . . . . . . . 204
4.1.5 StencilTest . . . . . . . . . . . . . . . . . . . . . . . . . 205
4.1.6 DepthBufferTest . . . . . . . . . . . . . . . . . . . . . . 206
4.1.7 OcclusionQueries . . . . . . . . . . . . . . . . . . . . . 207
4.1.8 Blending . . . . . . . . . . . . . . . . . . . . . . . . . . 209
4.1.9 Dithering . . . . . . . . . . . . . . . . . . . . . . . . . . 212
4.1.10 LogicalOperation . . . . . . . . . . . . . . . . . . . . . 213
4.1.11 AdditionalMultisampleFragmentOperations . . . . . . . 213
4.2 WholeFramebufferOperations . . . . . . . . . . . . . . . . . . . 215
4.2.1 SelectingaBufferforWriting . . . . . . . . . . . . . . . 215
4.2.2 FineControlofBufferUpdates . . . . . . . . . . . . . . 217
4.2.3 ClearingtheBuffers . . . . . . . . . . . . . . . . . . . . 218
4.2.4 TheAccumulationBuffer . . . . . . . . . . . . . . . . . 220
4.3 Drawing,Reading,andCopyingPixels . . . . . . . . . . . . . . . 221
4.3.1 WritingtotheStencilBuffer . . . . . . . . . . . . . . . . 221
4.3.2 ReadingPixels . . . . . . . . . . . . . . . . . . . . . . . 222
4.3.3 CopyingPixels . . . . . . . . . . . . . . . . . . . . . . . 226
4.3.4 PixelDraw/ReadState . . . . . . . . . . . . . . . . . . . 229
5 SpecialFunctions 230
5.1 Evaluators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
5.2 Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236
5.3 Feedback . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
5.4 DisplayLists . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
5.5 FlushandFinish . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
5.6 Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
6 StateandStateRequests 247
6.1 QueryingGLState . . . . . . . . . . . . . . . . . . . . . . . . . 247
6.1.1 SimpleQueries . . . . . . . . . . . . . . . . . . . . . . . 247
6.1.2 DataConversions . . . . . . . . . . . . . . . . . . . . . . 248
6.1.3 EnumeratedQueries . . . . . . . . . . . . . . . . . . . . 249
6.1.4 TextureQueries . . . . . . . . . . . . . . . . . . . . . . . 251
6.1.5 StippleQuery . . . . . . . . . . . . . . . . . . . . . . . . 253
6.1.6 ColorMatrixQuery. . . . . . . . . . . . . . . . . . . . . 253
6.1.7 ColorTableQuery . . . . . . . . . . . . . . . . . . . . . 254
6.1.8 ConvolutionQuery . . . . . . . . . . . . . . . . . . . . . 254
6.1.9 HistogramQuery . . . . . . . . . . . . . . . . . . . . . . 255
6.1.10 MinmaxQuery . . . . . . . . . . . . . . . . . . . . . . . 256
6.1.11 PointerandStringQueries . . . . . . . . . . . . . . . . . 257
Version2.1-December1,2006CONTENTS v
6.1.12 OcclusionQueries . . . . . . . . . . . . . . . . . . . . . 258
6.1.13 BufferObjectQueries . . . . . . . . . . . . . . . . . . . 259
6.1.14 ShaderandProgramQueries . . . . . . . . . . . . . . . . 260
6.1.15 SavingandRestoringState . . . . . . . . . . . . . . . . . 264
6.2 StateTables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
A Invariance 304
A.1 Repeatability . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304
A.2 Multi-passAlgorithms . . . . . . . . . . . . . . . . . . . . . . . 305
A.3 InvarianceRules . . . . . . . . . . . . . . . . . . . . . . . . . . . 305
A.4 WhatAllThisMeans . . . . . . . . . . . . . . . . . . . . . . . . 307
B Corollaries 308
C Version1.1 311
C.1 VertexArray . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
C.2 PolygonOffset . . . . . . . . . . . . . . . . . . . . . . . . . . . 312
C.3 LogicalOperation . . . . . . . . . . . . . . . . . . . . . . . . . . 312
C.4 TextureImageFormats . . . . . . . . . . . . . . . . . . . . . . . 312
C.5 TextureReplaceEnvironment . . . . . . . . . . . . . . . . . . . . 312
C.6 TextureProxies . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
C.7 CopyTextureandSubtexture . . . . . . . . . . . . . . . . . . . . 313
C.8 TextureObjects . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
C.9 OtherChanges . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
C.10 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 314
D Version1.2 316
D.1 Three-DimensionalTexturing . . . . . . . . . . . . . . . . . . . . 316
D.2 BGRAPixelFormats . . . . . . . . . . . . . . . . . . . . . . . . 316
D.3 PackedPixelFormats . . . . . . . . . . . . . . . . . . . . . . . . 317
D.4 NormalRescaling . . . . . . . . . . . . . . . . . . . . . . . . . . 317
D.5 SeparateSpecularColor . . . . . . . . . . . . . . . . . . . . . . 317
D.6 TextureCoordinateEdgeClamping . . . . . . . . . . . . . . . . 317
D.7 TextureLevelofDetailControl . . . . . . . . . . . . . . . . . . . 318
D.8 VertexArrayDrawElementRange . . . . . . . . . . . . . . . . . 318
D.9 ImagingSubset . . . . . . . . . . . . . . . . . . . . . . . . . . . 318
D.9.1 ColorTables . . . . . . . . . . . . . . . . . . . . . . . . 318
D.9.2 Convolution . . . . . . . . . . . . . . . . . . . . . . . . . 319
D.9.3 ColorMatrix . . . . . . . . . . . . . . . . . . . . . . . . 319
D.9.4 PixelPipelineStatistics . . . . . . . . . . . . . . . . . . . 320
Version2.1-December1,2006vi CONTENTS
D.9.5 ConstantBlendColor . . . . . . . . . . . . . . . . . . . . 320
D.9.6 NewBlendingEquations . . . . . . . . . . . . . . . . . . 320
D.10 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 320
E Version1.2.1 324
F Version1.3 325
F.1 CompressedTextures . . . . . . . . . . . . . . . . . . . . . . . . 325
F.2 CubeMapTextures . . . . . . . . . . . . . . . . . . . . . . . . . 325
F.3 Multisample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
F.4 Multitexture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 326
F.5 TextureAddEnvironmentMode . . . . . . . . . . . . . . . . . . 327
F.6 TextureCombineEnvironmentMode . . . . . . . . . . . . . . . 327
F.7 TextureDot3EnvironmentMode . . . . . . . . . . . . . . . . . . 327
F.8 TextureBorderClamp . . . . . . . . . . . . . . . . . . . . . . . 327
F.9 TransposeMatrix . . . . . . . . . . . . . . . . . . . . . . . . . . 328
F.10 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 328
G Version1.4 333
G.1 AutomaticMipmapGeneration . . . . . . . . . . . . . . . . . . . 333
G.2 BlendSquaring . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
G.3 ChangestotheImagingSubset . . . . . . . . . . . . . . . . . . . 334
G.4 DepthTexturesandShadows . . . . . . . . . . . . . . . . . . . . 334
G.5 FogCoordinate . . . . . . . . . . . . . . . . . . . . . . . . . . . 334
G.6 MultipleDrawArrays . . . . . . . . . . . . . . . . . . . . . . . . 334
G.7 PointParameters . . . . . . . . . . . . . . . . . . . . . . . . . . 335
G.8 SecondaryColor . . . . . . . . . . . . . . . . . . . . . . . . . . 335
G.9 SeparateBlendFunctions . . . . . . . . . . . . . . . . . . . . . . 335
G.10 StencilWrap . . . . . . . . . . . . . . . . . . . . . . . . . . . . 335
G.11 TextureCrossbarEnvironmentMode . . . . . . . . . . . . . . . . 335
G.12 TextureLODBias . . . . . . . . . . . . . . . . . . . . . . . . . . 336
G.13 TextureMirroredRepeat . . . . . . . . . . . . . . . . . . . . . . 336
G.14 WindowRasterPosition . . . . . . . . . . . . . . . . . . . . . . 336
G.15 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 336
H Version1.5 339
H.1 BufferObjects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
H.2 OcclusionQueries . . . . . . . . . . . . . . . . . . . . . . . . . . 340
H.3 ShadowFunctions . . . . . . . . . . . . . . . . . . . . . . . . . . 340
H.4 ChangedTokens . . . . . . . . . . . . . . . . . . . . . . . . . . . 340
Version2.1-December1,2006CONTENTS vii
H.5 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 340
I Version2.0 345
I.1 ProgrammableShading . . . . . . . . . . . . . . . . . . . . . . . 345
I.1.1 ShaderObjects . . . . . . . . . . . . . . . . . . . . . . . 345
I.1.2 ShaderPrograms . . . . . . . . . . . . . . . . . . . . . . 345
I.1.3 OpenGLShadingLanguage . . . . . . . . . . . . . . . . 346
I.1.4 ChangesToShaderAPIs . . . . . . . . . . . . . . . . . . 346
I.2 MultipleRenderTargets . . . . . . . . . . . . . . . . . . . . . . 346
I.3 Non-Power-Of-TwoTextures . . . . . . . . . . . . . . . . . . . . 346
I.4 PointSprites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347
I.5 SeparateBlendEquation . . . . . . . . . . . . . . . . . . . . . . 347
I.6 SeparateStencil . . . . . . . . . . . . . . . . . . . . . . . . . . . 347
I.7 OtherChanges . . . . . . . . . . . . . . . . . . . . . . . . . . . 347
I.8 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 349
J Version2.1 351
J.1 OpenGLShadingLanguage . . . . . . . . . . . . . . . . . . . . 351
J.2 Non-SquareMatrices . . . . . . . . . . . . . . . . . . . . . . . . 351
J.3 PixelBufferObjects . . . . . . . . . . . . . . . . . . . . . . . . . 351
J.4 sRGBTextures . . . . . . . . . . . . . . . . . . . . . . . . . . . 352
J.5 OtherChanges . . . . . . . . . . . . . . . . . . . . . . . . . . . 352
J.6 Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . . 354
K ARBExtensions 356
K.1 NamingConventions . . . . . . . . . . . . . . . . . . . . . . . . 356
K.2 PromotingExtensionstoCoreFeatures . . . . . . . . . . . . . . 357
K.3 Multitexture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357
K.4 TransposeMatrix . . . . . . . . . . . . . . . . . . . . . . . . . . 357
K.5 Multisample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357
K.6 TextureAddEnvironmentMode . . . . . . . . . . . . . . . . . . 358
K.7 CubeMapTextures . . . . . . . . . . . . . . . . . . . . . . . . . 358
K.8 CompressedTextures . . . . . . . . . . . . . . . . . . . . . . . . 358
K.9 TextureBorderClamp . . . . . . . . . . . . . . . . . . . . . . . 358
K.10 PointParameters . . . . . . . . . . . . . . . . . . . . . . . . . . 358
K.11 VertexBlend . . . . . . . . . . . . . . . . . . . . . . . . . . . . 358
K.12 MatrixPalette . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
K.13 TextureCombineEnvironmentMode . . . . . . . . . . . . . . . 359
K.14 TextureCrossbarEnvironmentMode . . . . . . . . . . . . . . . . 359
K.15 TextureDot3EnvironmentMode . . . . . . . . . . . . . . . . . . 359
Version2.1-December1,2006viii CONTENTS
K.16 TextureMirroredRepeat . . . . . . . . . . . . . . . . . . . . . . 359
K.17 DepthTexture . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
K.18 Shadow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
K.19 ShadowAmbient . . . . . . . . . . . . . . . . . . . . . . . . . . 360
K.20 WindowRasterPosition . . . . . . . . . . . . . . . . . . . . . . 360
K.21 Low-LevelVertexProgramming . . . . . . . . . . . . . . . . . . 360
K.22 Low-LevelFragmentProgramming . . . . . . . . . . . . . . . . 360
K.23 BufferObjects . . . . . . . . . . . . . . . . . . . . . . . . . . . . 360
K.24 OcclusionQueries . . . . . . . . . . . . . . . . . . . . . . . . . . 361
K.25 ShaderObjects . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
K.26 High-LevelVertexProgramming . . . . . . . . . . . . . . . . . . 361
K.27 High-LevelFragmentProgramming . . . . . . . . . . . . . . . . 361
K.28 OpenGLShadingLanguage . . . . . . . . . . . . . . . . . . . . 361
K.29 Non-Power-Of-TwoTextures . . . . . . . . . . . . . . . . . . . . 361
K.30 PointSprites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362
K.31 FragmentProgramShadow . . . . . . . . . . . . . . . . . . . . . 362
K.32 MultipleRenderTargets . . . . . . . . . . . . . . . . . . . . . . 362
K.33 RectangularTextures . . . . . . . . . . . . . . . . . . . . . . . . 362
K.34 Floating-PointColorBuffers . . . . . . . . . . . . . . . . . . . . 362
K.35 Half-PrecisionFloatingPoint . . . . . . . . . . . . . . . . . . . . 363
K.36 Floating-PointTextures . . . . . . . . . . . . . . . . . . . . . . . 363
K.37 PixelBufferObjects . . . . . . . . . . . . . . . . . . . . . . . . . 363
Version2.1-December1,2006ListofFigures
2.1 BlockdiagramoftheGL. . . . . . . . . . . . . . . . . . . . . . . 10
2.2 Creation of a processed vertex from a transformed vertex and cur-
rentvalues. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
2.3 Primitiveassemblyandprocessing. . . . . . . . . . . . . . . . . . 13
2.4 Trianglestrips,fans,andindependenttriangles. . . . . . . . . . . 16
2.5 Quadrilateralstripsandindependentquadrilaterals. . . . . . . . . 18
2.6 Vertextransformationsequence. . . . . . . . . . . . . . . . . . . 41
2.7 Currentrasterposition. . . . . . . . . . . . . . . . . . . . . . . . 55
2.8 ProcessingofRGBAcolors. . . . . . . . . . . . . . . . . . . . . 57
2.9 Processingofcolorindices. . . . . . . . . . . . . . . . . . . . . . 57
2.10 ColorMaterialoperation. . . . . . . . . . . . . . . . . . . . . . . 66
3.1 Rasterization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
3.2 Rasterizationofnon-antialiasedwidepoints. . . . . . . . . . . . . 97
3.3 Rasterizationofantialiasedwidepoints. . . . . . . . . . . . . . . 97
3.4 VisualizationofBresenham’salgorithm. . . . . . . . . . . . . . . 102
3.5 Rasterizationofnon-antialiasedwidelines. . . . . . . . . . . . . 105
3.6 Theregionusedinrasterizinganantialiasedlinesegment. . . . . 106
3.7 OperationofDrawPixels. . . . . . . . . . . . . . . . . . . . . . 127
3.8 Selectingasubimagefromanimage . . . . . . . . . . . . . . . . 131
3.9 Abitmapanditsassociatedparameters. . . . . . . . . . . . . . . 149
3.10 Atextureimageandthecoordinatesusedtoaccessit. . . . . . . . 159
3.11 Multitexturepipeline. . . . . . . . . . . . . . . . . . . . . . . . . 192
4.1 Per-fragmentoperations. . . . . . . . . . . . . . . . . . . . . . . 202
4.2 OperationofReadPixels. . . . . . . . . . . . . . . . . . . . . . . 222
4.3 OperationofCopyPixels. . . . . . . . . . . . . . . . . . . . . . . 226
5.1 MapEvaluation. . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
5.2 Feedbacksyntax. . . . . . . . . . . . . . . . . . . . . . . . . . . 241
ixListofTables
2.1 GLcommandsuf?xes . . . . . . . . . . . . . . . . . . . . . . . . 8
2.2 GLdatatypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
2.3 SummaryofGLerrors . . . . . . . . . . . . . . . . . . . . . . . 12
2.4 Vertexarraysizes(valuespervertex)anddatatypes . . . . . . . . 25
2.5 VariablesthatdirecttheexecutionofInterleavedArrays. . . . . . 32
2.6 Bufferobjectparametersandtheirvalues. . . . . . . . . . . . . . 34
2.7 Bufferobjectinitialstate. . . . . . . . . . . . . . . . . . . . . . . 36
2.8 BufferobjectstatesetbyMapBuffer. . . . . . . . . . . . . . . . 37
2.9 Componentconversions . . . . . . . . . . . . . . . . . . . . . . . 59
2.10 Summaryoflightingparameters. . . . . . . . . . . . . . . . . . . 61
2.11 Correspondenceoflightingparametersymbolstonames. . . . . . 65
2.12 Polygon?atshadingcolorselection. . . . . . . . . . . . . . . . . 70
3.1 PixelStoreparameters. . . . . . . . . . . . . . . . . . . . . . . . 115
3.2 PixelTransferparameters. . . . . . . . . . . . . . . . . . . . . . 117
3.3 PixelMapparameters. . . . . . . . . . . . . . . . . . . . . . . . 118
3.4 Colortablenames. . . . . . . . . . . . . . . . . . . . . . . . . . 119
3.5 DrawPixelsandReadPixelstypes. . . . . . . . . . . . . . . . . . 129
3.6 DrawPixelsandReadPixelsformats. . . . . . . . . . . . . . . . 130
3.7 SwapBytesbitordering. . . . . . . . . . . . . . . . . . . . . . . 130
3.8 Packedpixelformats. . . . . . . . . . . . . . . . . . . . . . . . . 132
3.9 UNSIGNED BYTEformats. Bitnumbersareindicatedforeachcom-
ponent. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
3.10 UNSIGNED SHORTformats . . . . . . . . . . . . . . . . . . . . . 134
3.11 UNSIGNED INTformats . . . . . . . . . . . . . . . . . . . . . . . 135
3.12 Packedpixel?eldassignments. . . . . . . . . . . . . . . . . . . . 136
3.13 Colortablelookup. . . . . . . . . . . . . . . . . . . . . . . . . . 141
3.14 Computationof?lteredcolorcomponents. . . . . . . . . . . . . . 142
xLISTOFTABLES xi
3.15 Conversion from RGBA and depth pixel components to internal
texture,table,or?ltercomponents. . . . . . . . . . . . . . . . . . 152
3.16 Correspondenceofsizedinternalformatstobaseinternalformats. 155
3.17 Genericandspeci?ccompressedinternalformats. . . . . . . . . . 155
3.18 Textureparametersandtheirvalues. . . . . . . . . . . . . . . . . 169
3.19 Selectionofcubemapimages. . . . . . . . . . . . . . . . . . . . 170
3.20 Correspondenceof?lteredtexturecomponents. . . . . . . . . . . 186
3.21 TexturefunctionsREPLACE,MODULATE,andDECAL . . . . . . . . 186
3.22 TexturefunctionsBLENDandADD. . . . . . . . . . . . . . . . . . 187
3.23 COMBINEtexturefunctions. . . . . . . . . . . . . . . . . . . . . . 188
3.24 ArgumentsforCOMBINE RGBfunctions. . . . . . . . . . . . . . . 189
3.25 ArgumentsforCOMBINE ALPHAfunctions. . . . . . . . . . . . . 189
3.26 Depthtexturecomparisonfunctions. . . . . . . . . . . . . . . . . 190
4.1 RGBandAlphablendequations. . . . . . . . . . . . . . . . . . . 210
4.2 Blendingfunctions. . . . . . . . . . . . . . . . . . . . . . . . . . 211
4.3 ArgumentstoLogicOpandtheircorrespondingoperations. . . . . 214
4.4 ArgumentstoDrawBufferandthebuffersthattheyindicate. . . . 216
4.5 PixelStoreparameters. . . . . . . . . . . . . . . . . . . . . . . . 224
4.6 ReadPixelsindexmasks. . . . . . . . . . . . . . . . . . . . . . . 226
4.7 ReadPixelsGLdatatypesandreversedcomponentconversionfor-
mulas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
5.1 Valuesspeci?edbythe targettoMap1. . . . . . . . . . . . . . . 231
5.2 Correspondenceoffeedbacktypetonumberofvaluespervertex. . 240
5.3 Hinttargetsanddescriptions . . . . . . . . . . . . . . . . . . . . 246
6.1 Texture,table,and?lterreturnvalues. . . . . . . . . . . . . . . . 253
6.2 Attributegroups . . . . . . . . . . . . . . . . . . . . . . . . . . . 265
6.3 StateVariableTypes. . . . . . . . . . . . . . . . . . . . . . . . . 267
6.4 GLInternalbegin-endstatevariables(inaccessible) . . . . . . . . 269
6.5 CurrentValuesandAssociatedData . . . . . . . . . . . . . . . . 270
6.6 VertexArrayData . . . . . . . . . . . . . . . . . . . . . . . . . . 271
6.7 VertexArrayData(cont.) . . . . . . . . . . . . . . . . . . . . . . 272
6.8 VertexArrayData(cont.) . . . . . . . . . . . . . . . . . . . . . . 273
6.9 BufferObjectState . . . . . . . . . . . . . . . . . . . . . . . . . 274
6.10 Transformationstate . . . . . . . . . . . . . . . . . . . . . . . . 275
6.11 Coloring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276
6.12 Lighting(seealsotable2.10fordefaults) . . . . . . . . . . . . . 277
6.13 Lighting(cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
Version2.1-December1,2006xii LISTOFTABLES
6.14 Rasterization . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
6.15 Multisampling . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
6.16 Textures(statepertextureunitandbindingpoint) . . . . . . . . . 281
6.17 Textures(statepertextureobject) . . . . . . . . . . . . . . . . . . 282
6.18 Textures(statepertextureimage) . . . . . . . . . . . . . . . . . . 283
6.19 TextureEnvironmentandGeneration . . . . . . . . . . . . . . . . 284
6.20 PixelOperations . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
6.21 PixelOperations(cont.) . . . . . . . . . . . . . . . . . . . . . . . 286
6.22 FramebufferControl . . . . . . . . . . . . . . . . . . . . . . . . 287
6.23 Pixels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 288
6.24 Pixels(cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
6.25 Pixels(cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
6.26 Pixels(cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 291
6.27 Pixels(cont.) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 292
6.28 Evaluators(GetMaptakesamapname) . . . . . . . . . . . . . . 293
6.29 ShaderObjectState . . . . . . . . . . . . . . . . . . . . . . . . . 294
6.30 ProgramObjectState . . . . . . . . . . . . . . . . . . . . . . . . 295
6.31 VertexShaderState . . . . . . . . . . . . . . . . . . . . . . . . . 296
6.32 Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 297
6.33 ImplementationDependentValues . . . . . . . . . . . . . . . . . 298
6.34 ImplementationDependentValues(cont.) . . . . . . . . . . . . . 299
6.35 ImplementationDependentValues(cont.) . . . . . . . . . . . . . 300
6.36 ImplementationDependentValues(cont.) . . . . . . . . . . . . . 301
6.37 ImplementationDependentPixelDepths . . . . . . . . . . . . . . 302
6.38 Miscellaneous . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
H.1 Newtokennames . . . . . . . . . . . . . . . . . . . . . . . . . . 341
Version2.1-December1,2006Chapter 1
Introduction
ThisdocumentdescribestheOpenGLgraphicssystem: whatitis,howitacts,and
what is required to implement it. We assume that the reader has at least a rudi-
mentary understanding of computer graphics. This means familiarity with the es-
sentialsofcomputergraphicsalgorithmsaswellasfamiliaritywithbasicgraphics
hardwareandassociatedterms.
1.1 FormattingofOptionalFeatures
Startingwithversion1.2ofOpenGL,somefeaturesinthespeci?cationareconsid-
eredoptional;anOpenGLimplementationmayormaynotchoosetoprovidethem
(seesection3.6.2).
Portions of the speci?cation which are optional are so described where the
optional features are ?rst de?ned (see section 3.6.2). State table entries which are
optionalaretypeset againstagraybackground .
1.2 WhatistheOpenGLGraphicsSystem?
OpenGL (for “Open Graphics Library”) is a software interface to graphics hard-
ware. The interface consists of a set of several hundred procedures and functions
that allow a programmer to specify the objects and operations involved in produc-
ing high-quality graphical images, speci?cally color images of three-dimensional
objects.
Most of OpenGL requires that the graphics hardware contain a framebuffer.
ManyOpenGLcallspertaintodrawingobjectssuchaspoints,lines,polygons,and
bitmaps, but the way that some of this drawing occurs (such as when antialiasing
12 CHAPTER1. INTRODUCTION
or texturing is enabled) relies on the existence of a framebuffer. Further, some of
OpenGLisspeci?callyconcernedwithframebuffermanipulation.
1.3 Programmer’sViewofOpenGL
To the programmer, OpenGL is a set of commands that allow the speci?cation of
geometricobjectsintwoorthreedimensions,togetherwithcommandsthatcontrol
how these objects are rendered into the framebuffer. For the most part, OpenGL
providesanimmediate-modeinterface,meaningthatspecifyinganobjectcausesit
tobedrawn.
A typical program that uses OpenGL begins with calls to open a window into
theframebufferintowhichtheprogramwilldraw. Then,callsaremadetoallocate
a GL context and associate it with the window. Once a GL context is allocated,
the programmer is free to issue OpenGL commands. Some calls are used to draw
simple geometric objects (i.e. points, line segments, and polygons), while others
affect the rendering of these primitives including how they are lit or colored and
how they are mapped from the user’s two- or three-dimensional model space to
the two-dimensional screen. There are also calls to effect direct control of the
framebuffer,suchasreadingandwritingpixels.
1.4 Implementor’sViewofOpenGL
To the implementor, OpenGL is a set of commands that affect the operation of
graphics hardware. If the hardware consists only of an addressable framebuffer,
then OpenGL must be implemented almost entirely on the host CPU. More typi-
cally, the graphics hardware may comprise varying degrees of graphics accelera-
tion,fromarastersubsystemcapableofrenderingtwo-dimensionallinesandpoly-
gons to sophisticated ?oating-point processors capable of transforming and com-
puting on geometric data. The OpenGL implementor’s task is to provide the CPU
software interface while dividing the work for each OpenGL command between
theCPUandthegraphicshardware. Thisdivisionmustbetailoredtotheavailable
graphicshardwaretoobtainoptimumperformanceincarryingoutOpenGLcalls.
OpenGLmaintainsaconsiderableamountofstateinformation. Thisstatecon-
trols how objects are drawn into the framebuffer. Some of this state is directly
availabletotheuser: heorshecanmakecallstoobtainitsvalue. Someofit,how-
ever,isvisibleonlybytheeffectithasonwhatisdrawn. Oneofthemaingoalsof
thisspeci?cationistomakeOpenGLstateinformationexplicit,toelucidatehowit
changes,andtoindicatewhatitseffectsare.
Version2.1-December1,20061.5. OURVIEW 3
1.5 OurView
We view OpenGL as a state machine that controls a set of speci?c drawing oper-
ations. This model should engender a speci?cation that satis?es the needs of both
programmersandimplementors. Itdoesnot,however,necessarilyprovideamodel
forimplementation. Animplementationmustproduceresultsconformingtothose
producedbythespeci?edmethods,buttheremaybewaystocarryoutaparticular
computationthataremoreef?cientthantheonespeci?ed.
1.6 CompanionDocuments
This speci?cation should be read together with a companion document titled The
OpenGLShadingLanguage. Thelatterdocument(referredtoastheOpenGLShad-
ingLanguageSpecificationhereafter)de?nesthesyntaxandsemanticsofthepro-
gramming language used to write vertex and fragment shaders (see sections 2.15
and 3.11). These sections may include references to concepts and terms (such as
shadinglanguagevariabletypes)de?nedinthecompaniondocument.
OpenGL2.0implementationsareguaranteedtosupportatleastversion1.10of
theshadinglanguage;theactualversionsupportedmaybequeriedasdescribedin
section6.1.11.
Version2.1-December1,2006Chapter 2
OpenGLOperation
2.1 OpenGLFundamentals
OpenGL (henceforth, the “GL”) is concerned only with rendering into a frame-
buffer (and reading values stored in that framebuffer). There is no support for
other peripherals sometimes associated with graphics hardware, such as mice and
keyboards. Programmersmustrelyonothermechanismstoobtainuserinput.
TheGLdraws primitivessubjecttoanumberofselectablemodes. Eachprim-
itive is a point, line segment, polygon, or pixel rectangle. Each mode may be
changed independently; the setting of one does not affect the settings of others
(although many modes may interact to determine what eventually ends up in the
framebuffer). Modes are set, primitives speci?ed, and other GL operations de-
scribedbysending commandsintheformoffunctionorprocedurecalls.
Primitives are de?ned by a group of one or more vertices. A vertex de?nes a
point,anendpointofanedge,oracornerofapolygonwheretwoedgesmeet. Data
(consistingofpositionalcoordinates,colors,normals,andtexturecoordinates)are
associated with a vertex and each vertex is processed independently, in order, and
in the same way. The only exception to this rule is if the group of vertices must
be clipped so that the indicated primitive ?ts within a speci?ed region; in this
case vertex data may be modi?ed and new vertices created. The type of clipping
dependsonwhichprimitivethegroupofverticesrepresents.
Commands are always processed in the order in which they are received, al-
though there may be an indeterminate delay before the effects of a command are
realized. This means, for example, that one primitive must be drawn completely
before any subsequent one can affect the framebuffer. It also means that queries
and pixel read operations return state consistent with complete execution of all
previouslyinvokedGLcommands,exceptwhereexplicitlyspeci?edotherwise. In
42.1. OPENGLFUNDAMENTALS 5
general,theeffectsofaGLcommandoneitherGLmodesortheframebuffermust
becompletebeforeanysubsequentcommandcanhaveanysucheffects.
In the GL, data binding occurs on call. This means that data passed to a com-
mand are interpreted when that command is received. Even if the command re-
quires a pointer to data, those data are interpreted when the call is made, and any
subsequent changes to the data have no effect on the GL (unless the same pointer
isusedinasubsequentcommand).
TheGLprovidesdirectcontroloverthefundamentaloperationsof3Dand2D
graphics. This includes speci?cation of such parameters as transformation matri-
ces, lighting equation coef?cients, antialiasing methods, and pixel update opera-
tors. It does not provide a means for describing or modeling complex geometric
objects. AnotherwaytodescribethissituationistosaythattheGLprovidesmech-
anisms to describe how complex geometric objects are to be rendered rather than
mechanismstodescribethecomplexobjectsthemselves.
The model for interpretation of GL commands is client-server. That is, a pro-
gram (the client) issues commands, and these commands are interpreted and pro-
cessed by the GL (the server). The server may or may not operate on the same
computer as the client. In this sense, the GL is “network-transparent.” A server
may maintain a number of GL contexts, each of which is an encapsulation of cur-
rentGLstate. Aclientmaychoosetoconnecttoanyoneofthesecontexts. Issuing
GLcommandswhentheprogramisnotconnectedtoacontextresultsinunde?ned
behavior.
The effects of GL commands on the framebuffer are ultimately controlled by
the window system that allocates framebuffer resources. It is the window sys-
tem that determines which portions of the framebuffer the GL may access at any
given time and that communicates to the GL how those portions are structured.
Therefore,therearenoGLcommandstocon?guretheframebufferorinitializethe
GL. Similarly, display of framebuffer contents on a CRT monitor (including the
transformationofindividualframebuffervaluesbysuchtechniquesasgammacor-
rection) is not addressed by the GL. Framebuffer con?guration occurs outside of
the GL in conjunction with the window system; the initialization of a GL context
occurswhenthewindowsystemallocatesawindowforGLrendering.
The GL is designed to be run on a range of graphics platforms with varying
graphics capabilities and performance. To accommodate this variety, we specify
idealbehaviorinsteadofactualbehaviorforcertainGLoperations. Incaseswhere
deviation from the ideal is allowed, we also specify the rules that an implemen-
tation must obey if it is to approximate the ideal behavior usefully. This allowed
variation in GL behavior implies that two distinct GL implementations may not
agreepixelforpixelwhenpresentedwiththesameinputevenwhenrunonidenti-
calframebuffercon?gurations.
Version2.1-December1,20066 CHAPTER2. OPENGLOPERATION
Finally, command names, constants, and types are pre?xed in the GL (by gl,
GL , andGL, respectively inC) to reduce name clashes with other packages. The
pre?xesareomittedinthisdocumentforclarity.
2.1.1 Floating-PointComputation
The GL must perform a number of ?oating-point operations during the course of
its operation. We do not specify how ?oating-point numbers are to be represented
or how operations on them are to be performed. We require simply that numbers’
?oating-point parts contain enough bits and that their exponent ?elds are large
enough so that individual results of ?oating-point operations are accurate to about
5
1 part in 10 . The maximum representable magnitude of a ?oating-point number
32
usedtorepresentpositional,normal,ortexturecoordinatesmustbeatleast2 ;the
10
maximum representable magnitude for colors must be at least 2 . The maximum
32
representable magnitude for all other ?oating-point values must be at least 2 .
x· 0 = 0· x = 0 for any non-in?nite and non-NaN x. 1· x = x· 1 = x.
0
x+0 = 0+x =x. 0 = 1. (Occasionallyfurtherrequirementswillbespeci?ed.)
Mostsingle-precision?oating-pointformatsmeettheserequirements.
Any representable ?oating-point value is legal as input to a GL command that
requires ?oating-point data. The result of providing a value that is not a ?oating-
pointnumbertosuchacommandisunspeci?ed,butmustnotleadtoGLinterrup-
tionortermination. InIEEEarithmetic,forexample,providinganegativezeroora
denormalizednumbertoaGLcommandyieldspredictableresults,whileproviding
aNaNoranin?nityyieldsunspeci?edresults.
Some calculations require division. In such cases (including implied divisions
required by vector normalizations), a division by zero produces an unspeci?ed re-
sultbutmustnotleadtoGLinterruptionortermination.
2.2 GLState
The GL maintains considerable state. This document enumerates each state vari-
able and describes how each variable can be changed. For purposes of discussion,
statevariablesarecategorizedsomewhatarbitrarilybytheirfunction. Althoughwe
describe the operations that the GL performs on the framebuffer, the framebuffer
isnotapartofGLstate.
We distinguish two types of state. The ?rst type of state, called GL server
state, resides in the GL server. The majority of GL state falls into this category.
The second type of state, called GL client state, resides in the GL client. Unless
otherwise speci?ed, all state referred to in this document is GL server state; GL
Version2.1-December1,20062.3. GLCOMMANDSYNTAX 7
client state is speci?cally identi?ed. Each instance of a GL context implies one
complete set of GL server state; each connection from a client to a server implies
asetofbothGLclientstateandGLserverstate.
While an implementation of the GL may be hardware dependent, this discus-
sionisindependentofthespeci?chardwareonwhichaGLisimplemented. Weare
therefore concerned with the state of graphics hardware only when it corresponds
preciselytoGLstate.
2.3 GLCommandSyntax
GLcommandsarefunctionsorprocedures. Variousgroupsofcommandsperform
the same operation but differ in how arguments are supplied to them. To conve-
nientlyaccommodatethisvariation,weadoptanotationfordescribingcommands
andtheirarguments.
GL commands are formed from a name followed, depending on the particular
command,byupto4characters. The?rstcharacterindicatesthenumberofvalues
oftheindicatedtypethatmustbepresentedtothecommand. Thesecondcharacter
or character pair indicates the speci?c type of the arguments: 8-bit integer, 16-bit
integer,32-bitinteger,single-precision?oating-point,ordouble-precision?oating-
point. The ?nal character, if present, is v, indicating that the command takes a
pointertoanarray(avector)ofvaluesratherthanaseriesofindividualarguments.
Twospeci?cexamplescomefromtheVertexcommand:
void Vertex3f(float x,float y,float z);
and
void Vertex2sv(short v[2]);
TheseexamplesshowtheANSICdeclarationsforthesecommands. Ingeneral,
1
acommanddeclarationhastheform
rtypeName{1234}{bsifdubusui}{v}
( [args ,] T arg1 ,... , T argN [, args] );
rtype is the return type of the function. The braces ({}) enclose a series of char-
acters (or character pairs) of which one is selected.  indicates no character. The
arguments enclosed in brackets ([args ,] and [, args]) may or may not be present.
1
The declarations shown in this document apply to ANSI C. Languages such as C++ and Ada
thatallowpassingofargumenttypeinformationadmitsimplerdeclarationsandfewerentrypoints.
Version2.1-December1,20068 CHAPTER2. OPENGLOPERATION
Letter CorrespondingGLType
b byte
s short
i int
f float
d double
ub ubyte
us ushort
ui uint
Table2.1: Correspondenceofcommandsuf?xletterstoGLargumenttypes. Refer
totable2.2forde?nitionsoftheGLtypes.
TheN argumentsarg1throughargN havetypeT,whichcorrespondstooneofthe
type letters or letter pairs as indicated in table 2.1 (if there are no letters, then the
arguments’typeisgivenexplicitly). Ifthe?nalcharacterisnotv, thenN isgiven
bythedigit1,2,3,or4(ifthereisnodigit,thenthenumberofargumentsis?xed).
If the ?nal character is v, then only arg1 is present and it is an array of N values
oftheindicatedtype. Finally,weindicateanunsignedtypebytheshorthandof
prependingautothebeginningofthetypename(sothat,forinstance,unsigned
charisabbreviateduchar).
Forexample,
void Normal3{fd}(T arg);
indicatesthetwodeclarations
void Normal3f(float arg1,float arg2,float arg3);
void Normal3d(double arg1,double arg2,double arg3);
while
void Normal3{fd}v(T arg);
meansthetwodeclarations
void Normal3fv(float arg[3]);
void Normal3dv(double arg[3]);
Argumentswhosetypeis?xed(i.e. notindicatedbyasuf?xonthecommand)
areofoneof14types(orpointerstooneofthese). Thesetypesaresummarizedin
table2.2.
Version2.1-December1,20062.3. GLCOMMANDSYNTAX 9
GLType Minimum Description
BitWidth
boolean 1 Boolean
byte 8 signed2’scomplementbinaryinteger
ubyte 8 unsignedbinaryinteger
char 8 charactersmakingupstrings
short 16 signed2’scomplementbinaryinteger
ushort 16 unsignedbinaryinteger
int 32 signed2’scomplementbinaryinteger
uint 32 unsignedbinaryinteger
sizei 32 Non-negativebinaryintegersize
enum 32 Enumeratedbinaryintegervalue
intptr ptrbits signed2’scomplementbinaryinteger
sizeiptr ptrbits Non-negativebinaryintegersize
bitfield 32 Bit?eld
float 32 Floating-pointvalue
clampf 32 Floating-pointvalueclampedto [0,1]
double 64 Floating-pointvalue
clampd 64 Floating-pointvalueclampedto [0,1]
Table 2.2: GL data types. GL types are not C types. Thus, for example, GL
type int is referred to as GLint outside this document, and is not necessarily
equivalent to the C type int. An implementation may use more bits than the
number indicated in the table to represent a GL type. Correct interpretation of
integervaluesoutsidetheminimumrangeisnotrequired,however.
ptrbits is the number of bits required to represent a pointer type; in other words,
typesintptrandsizeiptrmustbesuf?cientlylargeastostoreanyaddress.
Version2.1-December1,200610 CHAPTER2. OPENGLOPERATION
Display
  List
Per?Vertex
Per?
Operations
Rasteriz?
Evaluator Fragment Framebuffer
Primitive ation
Operations
Assembly
Texture
Memory
Pixel
Operations
Figure2.1. BlockdiagramoftheGL.
2.4 BasicGLOperation
Figure 2.1 shows a schematic diagram of the GL. Commands enter the GL on the
left. Some commands specify geometric objects to be drawn while others control
how the objects are handled by the various stages. Most commands may be ac-
cumulated in a display list for processing by the GL at a later time. Otherwise,
commandsareeffectivelysentthroughaprocessingpipeline.
The ?rst stage provides an ef?cient means for approximating curve and sur-
face geometry by evaluating polynomial functions of input values. The next stage
operates on geometric primitives described by vertices: points, line segments, and
polygons. In this stage vertices are transformed and lit, and primitives are clipped
to a viewing volume in preparation for the next stage, rasterization. The rasterizer
producesaseriesofframebufferaddressesandvaluesusingatwo-dimensionalde-
scription of a point, line segment, or polygon. Each fragment so produced is fed
to the next stage that performs operations on individual fragments before they ?-
nally alter the framebuffer. These operations include conditional updates into the
framebufferbasedonincomingandpreviouslystoreddepthvalues(toeffectdepth
buffering), blending of incoming fragment colors with stored colors, as well as
maskingandotherlogicaloperationsonfragmentvalues.
Finally,thereisawaytobypassthevertexprocessingportionofthepipelineto
sendablockoffragmentsdirectlytotheindividualfragmentoperations,eventually
causingablockofpixelstobewrittentotheframebuffer;valuesmayalsoberead
Version2.1-December1,20062.5. GLERRORS 11
backfromtheframebufferorcopiedfromoneportionoftheframebuffertoanother.
Thesetransfersmayincludesometypeofdecodingorencoding.
This ordering ismeant only as a tool fordescribing the GL, not as astrict rule
of how the GL is implemented, and we present it only as a means to organize the
various operations of the GL. Objects such as curved surfaces, for instance, may
betransformedbeforetheyareconvertedtopolygons.
2.5 GLErrors
The GL detects only a subset of those conditions that could be considered errors.
This is because in many cases error checking would adversely impact the perfor-
manceofanerror-freeprogram.
Thecommand
enum GetError(void);
is used to obtain error information. Each detectable error is assigned a numeric
code. When an error is detected, a ?ag is set and the code is recorded. Further
errors, if they occur, do not affect this recorded code. When GetError is called,
thecodeisreturnedandthe?agiscleared,sothatafurthererrorwillagainrecord
itscode. IfacalltoGetErrorreturnsNO ERROR,thentherehasbeennodetectable
errorsincethelastcalltoGetError(orsincetheGLwasinitialized).
Toallowfordistributedimplementations,theremaybeseveral?ag-codepairs.
In this case, after a call to GetError returns a value other than NO ERROR each
subsequentcallreturnsthenon-zerocodeofadistinct?ag-codepair(inunspeci?ed
order),untilallnon- NO ERRORcodeshavebeenreturned. Whentherearenomore
non- NO ERRORerrorcodes,all?agsarereset. Thisschemerequiressomepositive
number of pairs of a ?ag bit and an integer. The initial state of all ?ags is cleared
andtheinitialvalueofallcodesisNO ERROR.
Table2.3summarizesGLerrors. Currently,whenanerror?agisset,resultsof
GL operation are unde?ned only if OUT OF MEMORY has occurred. In other cases,
thecommandgeneratingtheerrorisignoredsothatithasnoeffectonGLstateor
framebuffercontents. Ifthegeneratingcommandreturnsavalue,itreturnszero. If
thegeneratingcommandmodi?esvaluesthroughapointerargument,nochangeis
madetothesevalues. TheseerrorsemanticsapplyonlytoGLerrors,nottosystem
errors such as memory access errors. This behavior is the current behavior; the
actionoftheGLinthepresenceoferrorsissubjecttochange.
Several error generation conditions are implicit in the description of every GL
command:
Version2.1-December1,200612 CHAPTER2. OPENGLOPERATION
Error Description Offending com-
mandignored?
INVALID ENUM enumargumentoutofrange Yes
INVALID VALUE Numericargumentoutofrange Yes
INVALID OPERATION Operationillegalincurrentstate Yes
STACK OVERFLOW Command would cause a stack Yes
over?ow
STACK UNDERFLOW Command would cause a stack Yes
under?ow
OUT OF MEMORY Not enough memory left to exe- Unknown
cutecommand
TABLE TOO LARGE Thespeci?edtableistoolarge Yes
Table2.3: SummaryofGLerrors
• If a command that requires an enumerated value is passed a symbolic con-
stant that is not one of those speci?ed as allowable for that command, the
error INVALID ENUM is generated. This is the case even if the argument is
a pointer to a symbolic constant, if the value pointed to is not allowable for
thegivencommand.
• If a negative number is provided where an argument of type sizei or
sizeiptrisspeci?ed,theerrorINVALID VALUEisgenerated.
• If memory is exhausted as a side effect of the execution of a command, the
errorOUT OF MEMORYmaybegenerated.
Otherwise, errorsaregeneratedonlyforconditionsthatareexplicitlydescribedin
thisspeci?cation.
2.6 Begin/EndParadigm
In the GL, most geometric objects are drawn by enclosing a series of coordinate
sets that specify vertices and optionally normals, texture coordinates, and colors
between Begin/End pairs. There are ten geometric objects that are drawn this
way: points,linesegments,linesegmentloops,separatedlinesegments,polygons,
trianglestrips,trianglefans,separatedtriangles,quadrilateralstrips,andseparated
quadrilaterals.
Version2.1-December1,20062.6. BEGIN/ENDPARADIGM 13
Each vertex is speci?ed with two, three, or four coordinates. In addition, a
current normal, multiple current texture coordinate sets, multiple current generic
vertex attributes, current color, current secondary color, and current fog coor-
dinate may be used in processing each vertex. Normals are used by the GL in
lightingcalculations; thecurrentnormalisathree-dimensionalvectorthatmaybe
setbysendingthreecoordinatesthatspecifyit. Texturecoordinatesdeterminehow
a texture image is mapped onto a primitive. Multiple sets of texture coordinates
may be used to specify how multiple texture images are mapped onto a primitive.
The number of texture units supported is implementation dependent but must be
at least two. The number of texture units supported can be queried with the state
MAX TEXTURE UNITS. Generic vertex attributes can be accessed from within ver-
tex shaders (section 2.15) and used to compute values for consumption by later
processingstages.
Primaryandsecondarycolorsareassociatedwitheachvertex(seesection3.9).
Theseassociatedcolorsareeitherbasedonthecurrentcolorandcurrentsecondary
color or produced by lighting, depending on whether or not lighting is enabled.
Texture and fog coordinates are similarly associated with each vertex. Multiple
setsoftexturecoordinatesmaybeassociatedwithavertex. Figure2.2summarizes
the association of auxiliary data with a transformed vertex to produce a processed
vertex.
ThecurrentvaluesarepartofGLstate. Verticesandnormalsaretransformed,
colors may be affected or replaced by lighting, and texture coordinates are trans-
formed and possibly affected by a texture coordinate generation function. The
processingindicatedforeachcurrentvalueisappliedforeachvertexthatissentto
theGL.
The methods by which vertices, normals, texture coordinates, fog coordinate,
genericattributes,andcolorsaresenttotheGL,aswellashownormalsaretrans-
formedandhowverticesaremappedtothetwo-dimensionalscreen,arediscussed
later.
Before colors have been assigned to a vertex, the state required by a vertex
is the vertex’s coordinates, the current normal, the current edge ?ag (see sec-
tion 2.6.2), the current material properties (see section 2.14.2), the current fog co-
ordinate,themultiplegenericvertexattributesets,andthemultiplecurrenttexture
coordinate sets. Because color assignment is done vertex-by-vertex, a processed
vertex comprises the vertex’s coordinates, its edge ?ag, its fog coordinate, its as-
signedcolors,anditsmultipletexturecoordinatesets.
Figure2.3showsthesequenceofoperationsthatbuildsa primitive(point,line
segment, or polygon) from a sequence of vertices. After a primitive is formed, it
is clipped to a viewing volume. This may alter the primitive by altering vertex
coordinates, texturecoordinates, andcolors. Inthecaseoflineandpolygonprim-
Version2.1-December1,200614 CHAPTER2. OPENGLOPERATION
Vertex
Coordinates In
vertex / normal
Transformed
transformation
Coordinates
Current
Normal
Processed
Vertex
Out
Current
lighting
Associated
Colors & 
Data
Materials
(Colors, Edge Flag,
Fog and Texture
Coordinates)
Current
Edge Flag & 
Fog Coord
Current
texture
Texture texgen
matrix 0
Coord Set 0
Current
texture
Texture texgen
matrix 1
Coord Set 1
Current
texture
Texture texgen
matrix 2
Coord Set 2
Current
texture
Texture texgen
matrix 3
Coord Set 3
Figure2.2. Associationofcurrentvalueswithavertex. Theheavylinedboxesrep-
resentGLstate. Fourtextureunitsareshown;however,multitexturingmaysupport
adifferentnumberofunitsdependingontheimplementation.
Version2.1-December1,20062.6. BEGIN/ENDPARADIGM 15
Point culling;
Line Segment
Point,
 or Polygon
Coordinates
Line Segment, or
Clipping
Processed
Polygon Rasterization
Vertices
Associated
(Primitive)
Data
Color
Assembly
Processing
Begin/End
State
Figure2.3. Primitiveassemblyandprocessing.
itives, clipping may insert new vertices into the primitive. The vertices de?ning a
primitivetoberasterizedhavetexturecoordinatesandcolorsassociatedwiththem.
2.6.1 BeginandEnd
Vertices making up one of the supported geometric object types are speci?ed by
enclosingcommandsde?ningthoseverticesbetweenthetwocommands
void Begin(enum mode);
void End(void);
Thereisnolimitonthenumberofverticesthatmaybespeci?edbetweenaBegin
andanEnd.
Points. Aseriesofindividualpointsmaybespeci?edbycallingBeginwithan
argumentvalueofPOINTS.NospecialstateneedbekeptbetweenBeginandEnd
inthiscase,sinceeachpointisindependentofpreviousandfollowingpoints.
Line Strips. A series of one or more connected line segments is speci?ed by
enclosingaseriesoftwoormoreendpointswithinaBegin/EndpairwhenBeginis
called with LINE STRIP. In this case, the ?rst vertex speci?es the ?rst segment’s
start point while the second vertex speci?es the ?rst segment’s endpoint and the
second segment’s start point. In general, the ith vertex (for i > 1) speci?es the
beginning of the ith segment and the end of the i? 1st. The last vertex speci?es
theendofthelastsegment. Ifonlyonevertexisspeci?edbetweentheBegin/End
pair,thennoprimitiveisgenerated.
Version2.1-December1,200616 CHAPTER2. OPENGLOPERATION
Therequiredstateconsistsoftheprocessedvertexproducedfromthelastver-
tex that was sent (so that a line segment can be generated from it to the current
vertex),andaboolean?agindicatingifthecurrentvertexisthe?rstvertex.
Line Loops. Line loops, speci?ed with the LINE LOOP argument value to
Begin,arethesameaslinestripsexceptthata?nalsegmentisaddedfromthe?nal
speci?ed vertex to the ?rst vertex. The additional state consists of the processed
?rstvertex.
SeparateLines. Individuallinesegments,eachspeci?edbyapairofvertices,
are generated by surrounding vertex pairs with Begin and End when the value
of the argument to Begin is LINES. In this case, the ?rst two vertices between a
BeginandEndpairde?nethe?rstsegment,withsubsequentpairsofverticeseach
de?ningonemoresegment. Ifthenumberofspeci?edverticesisodd,thenthelast
oneisignored. Thestaterequiredisthesameasforlinesbutitisuseddifferently: a
vertexholdingthe?rstvertexofthecurrentsegment,andaboolean?agindicating
whetherthecurrentvertexisoddoreven(asegmentstartorend).
Polygons. A polygon is described by specifying its boundary as a series of
line segments. When Begin is called with POLYGON, the bounding line segments
are speci?ed in the same way as line loops. Depending on the current state of the
GL,apolygonmayberenderedinoneofseveralwayssuchasoutliningitsborder
or ?lling its interior. A polygon described with fewer than three vertices does not
generateaprimitive.
Only convex polygons are guaranteed to be drawn correctly by the GL. If a
speci?edpolygonisnonconvexwhenprojectedontothewindow,thentherendered
polygon need only lie within the convex hull of the projected vertices de?ning its
boundary.
The state required to support polygons consists of at least two processed ver-
tices (more than two are never required, although an implementation may use
more); this is because a convex polygon can be rasterized as its vertices arrive,
before all of them have been speci?ed. The order of the vertices is signi?cant in
lightingandpolygonrasterization(seesections2.14.1and3.5.1).
Trianglestrips. Atrianglestripisaseriesoftrianglesconnectedalongshared
edges. A triangle strip is speci?ed by giving a series of de?ning vertices between
a Begin/End pair when Begin is called with TRIANGLE STRIP. In this case, the
?rst three vertices de?ne the ?rst triangle (and their order is signi?cant, just as for
polygons). Each subsequent vertex de?nes a new triangle using that point along
with two vertices from the previous triangle. A Begin/End pair enclosing fewer
thanthreevertices,whenTRIANGLE STRIPhasbeensuppliedtoBegin,produces
noprimitive. See?gure2.4.
The state required to support triangle strips consists of a ?ag indicating if the
?rst triangle has been completed, two stored processed vertices, (called vertex A
Version2.1-December1,20062.6. BEGIN/ENDPARADIGM 17
4
2 2 2
3 6
4
4
5
5
1
1 3 5 1 3
(a) (b) (c)
Figure 2.4. (a) A triangle strip. (b) A triangle fan. (c) Independent triangles. The
numbers give the sequencing of the vertices between Begin and End. Note that in
(a)and(b)triangleedgeorderingisdeterminedbythe?rsttriangle,whilein(c)the
orderofeachtriangle’sedgesisindependentoftheothertriangles.
andvertexB),andaonebitpointerindicatingwhichstoredvertexwillbereplaced
with the next vertex. After a Begin(TRIANGLE STRIP), the pointer is initialized
topointtovertexA.EachvertexsentbetweenaBegin/Endpairtogglesthepointer.
Therefore, the ?rst vertex is stored as vertex A, the second stored as vertex B, the
third stored as vertex A, and so on. Any vertex after the second one sent forms a
trianglefromvertexA,vertexB,andthecurrentvertex(inthatorder).
Trianglefans. Atrianglefanisthesameasatrianglestripwithoneexception:
each vertex after the ?rst always replaces vertex B of the two stored vertices. The
vertices of a triangle fan are enclosed between Begin and End when the value of
theargumenttoBeginisTRIANGLE FAN.
Separate Triangles. Separate triangles are speci?ed by placing vertices be-
tweenBeginandEndwhenthevalueoftheargumenttoBeginisTRIANGLES.In
this case, The 3i + 1st, 3i + 2nd, and 3i + 3rd vertices (in that order) determine
a triangle for each i = 0,1,...,n? 1, where there are 3n +k vertices between
the Begin and End. k is either 0, 1, or 2; if k is not zero, the ?nal k vertices are
ignored. For each triangle, vertex A is vertex 3i and vertex B is vertex 3i + 1.
Otherwise,separatetrianglesarethesameasatrianglestrip.
The rules given for polygons also apply to each triangle generated from a tri-
anglestrip,trianglefanorfromseparatetriangles.
Quadrilateral (quad) strips. Quad strips generate a series of edge-sharing
quadrilaterals from vertices appearing between Begin and End, when Begin is
Version2.1-December1,200618 CHAPTER2. OPENGLOPERATION
2 4 6 2 3 6 7
5 1 4 5 8
1 3
(a) (b)
Figure2.5. (a)Aquadstrip. (b)Independentquads. Thenumbersgivethesequenc-
ingoftheverticesbetweenBeginandEnd.
called with QUAD STRIP. If the m vertices between the Begin and End are
v ,...,v , where v is the jth speci?ed vertex, then quad i has vertices (in or-
1 m j
der)v ,v ,v ,andv withi = 0,...,bm/2c. Thestaterequiredisthus
2i 2i+1 2i+3 2i+2
three processed vertices, to store the last two vertices of the previous quad along
with the third vertex (the ?rst new vertex) of the current quad, a ?ag to indicate
when the ?rst quad has been completed, and a one-bit counter to count members
ofavertexpair. See?gure2.5.
Aquadstripwithfewerthanfourverticesgeneratesnoprimitive. Ifthenumber
of vertices speci?ed for a quadrilateral strip between Begin and End is odd, the
?nalvertexisignored.
Separate Quadrilaterals Separate quads are just like quad strips except that
each group of four vertices, the 4j + 1st, the 4j + 2nd, the 4j + 3rd, and the
4j + 4th, generate a single quad, for j = 0,1,...,n? 1. The total number of
verticesbetweenBeginandEndis 4n+k, where 0? k? 3; ifk isnotzero, the
?nal k vertices are ignored. Separate quads are generated by calling Begin with
theargumentvalueQUADS.
Therulesgivenforpolygonsalsoapplytoeachquadgeneratedinaquadstrip
orfromseparatequads.
ThestaterequiredforBeginandEndconsistsofaneleven-valuedintegerindi-
catingeitheroneofthetenpossibleBegin/Endmodes,orthatnoBegin/Endmode
isbeingprocessed.
Version2.1-December1,20062.6. BEGIN/ENDPARADIGM 19
2.6.2 PolygonEdges
Each edge of each primitive generated from a polygon, triangle strip, triangle fan,
separate triangle set, quadrilateral strip, or separate quadrilateral set, is ?agged as
either boundary or non-boundary . These classi?cations are used during polygon
rasterization;somemodesaffecttheinterpretationofpolygonboundaryedges(see
section 3.5.4). By default, all edges are boundary edges, but the ?agging of poly-
gons,separatetriangles,orseparatequadrilateralsmaybealteredbycalling
void EdgeFlag(boolean ?ag);
void EdgeFlagv(boolean *?ag);
to change the value of a ?ag bit. If ?ag is zero, then the ?ag bit is set toFALSE; if
?agisnon-zero,thenthe?agbitissetto TRUE.
When Begin is supplied with one of the argument values POLYGON,
TRIANGLES, or QUADS, each vertex speci?ed within a Begin and End pair be-
ginsanedge. Iftheedge?agbitisTRUE,theneachspeci?edvertexbeginsanedge
that is ?agged as boundary. If the bit isFALSE, then induced edges are ?agged as
non-boundary.
Thestaterequiredforedge?aggingconsistsofonecurrent?agbit. Initially,the
bitisTRUE.Inaddition,eachprocessedvertexofanassembledpolygonalprimitive
mustbeaugmentedwithabitindicatingwhetherornottheedgebeginningonthat
vertexisboundaryornon-boundary.
2.6.3 GLCommandswithinBegin/End
TheonlyGLcommandsthatareallowedwithinanyBegin/Endpairsarethecom-
mandsforspecifyingvertexcoordinates,vertexcolors,normalcoordinates,texture
coordinates, generic vertex attributes, and fog coordinates (Vertex, Color, Sec-
ondaryColor, Index, Normal, TexCoord and MultiTexCoord, VertexAttrib,
FogCoord), the ArrayElement command (see section 2.8), the EvalCoord and
EvalPoint commands (see section 5.1), commands for specifying lighting mate-
rial parameters (Material commands; see section 2.14.2), display list invocation
commands(CallListandCallLists;seesection5.4),andtheEdgeFlagcommand.
Executing any other GL command between the execution of Begin and the corre-
sponding execution of End results in the error INVALID OPERATION. Executing
Begin after Begin has already been executed but before an End is executed gen-
erates the INVALID OPERATION error, as does executing End without a previous
correspondingBegin.
Execution of the commands EnableClientState, DisableClientState, Push-
ClientAttrib, PopClientAttrib, ColorPointer, FogCoordPointer, EdgeFlag-
Version2.1-December1,200620 CHAPTER2. OPENGLOPERATION
Pointer, IndexPointer, NormalPointer, TexCoordPointer, SecondaryCol-
orPointer, VertexPointer, VertexAttribPointer, ClientActiveTexture, Inter-
leavedArrays, and PixelStore is not allowed within any Begin/End pair, but an
errormayormaynotbegeneratedifsuchexecutionoccurs. Ifanerrorisnotgen-
erated,GLoperationisunde?ned. (Thesecommandsaredescribedinsections2.8,
3.6.1,andchapter6.)
2.7 VertexSpecification
Verticesarespeci?edbygivingtheircoordinatesintwo,three,orfourdimensions.
ThisisdoneusingoneofseveralversionsoftheVertexcommand:
void Vertex{234}{sifd}(T coords);
void Vertex{234}{sifd}v(T coords);
A call to any Vertex command speci?es four coordinates: x, y, z, and w. The
x coordinate is the ?rst coordinate, y is second, z is third, and w is fourth. A
call to Vertex2 sets the x and y coordinates; the z coordinate is implicitly set to
zero and thew coordinate to one. Vertex3 setsx, y, andz to the provided values
and w to one. Vertex4 sets all four coordinates, allowing the speci?cation of an
arbitrarypointinprojectivethree-space. Invokinga Vertexcommandoutsideofa
Begin/Endpairresultsinunde?nedbehavior.
Currentvaluesareusedinassociatingauxiliarydatawithavertexasdescribed
insection2.6. Acurrentvaluemaybechangedatanytimebyissuinganappropri-
atecommand. Thecommands
void TexCoord{1234}{sifd}(T coords);
void TexCoord{1234}{sifd}v(T coords);
specify the current homogeneous texture coordinates, named s, t, r, and q. The
TexCoord1 family of commands set thes coordinate to the provided single argu-
mentwhilesettingtandr to0andq to1. Similarly,TexCoord2setssandttothe
speci?edvalues,r to0andq to1;TexCoord3setss,t, andr, withq setto1, and
TexCoord4setsallfourtexturecoordinates.
Implementations must support at least two sets of texture coordinates. The
commands
void MultiTexCoord{1234}{sifd}(enum texture,T coords)
void MultiTexCoord{1234}{sifd}v(enum texture,T
coords)
Version2.1-December1,20062.7. VERTEXSPECIFICATION 21
takethecoordinatesettobemodi?edasthetextureparameter. textureisasymbolic
constant of the form TEXTUREi, indicating that texture coordinate set i is to be
modi?ed. The constants obey TEXTUREi = TEXTURE0+i (i is in the range 0 to
k?1,wherek istheimplementation-dependentnumberoftexturecoordinatesets
de?nedbyMAX TEXTURE COORDS).
The TexCoord commands are exactly equivalent to the corresponding Multi-
TexCoordcommandswith texturesettoTEXTURE0.
Gets of CURRENT TEXTURE COORDS return the texture coordinate set de?ned
bythevalueofACTIVE TEXTURE.
Specifyinganinvalidtexturecoordinatesetforthe textureargumentofMulti-
TexCoordresultsinunde?nedbehavior.
Thecurrentnormalissetusing
void Normal3{bsifd}(T coords);
void Normal3{bsifd}v(T coords);
Byte, short, or integer values passed to Normal are converted to ?oating-point
valuesasindicatedforthecorresponding(signed)typeintable2.9.
Thecurrentfogcoordinateissetusing
void FogCoord{fd}(T coord);
void FogCoord{fd}v(T coord);
There are several ways to set the current color and secondary color. The GL
stores a current single-valued color index, as well as a current four-valued RGBA
color and secondary color. Either the index or the color and secondary color are
signi?cantdependingastheGLisin color index modeor RGBA mode. Themode
selectionismadewhentheGLisinitialized.
ThecommandstosetRGBAcolorsare
void Color{34}{bsifdubusui}(T components);
void Color{34}{bsifdubusui}v(T components);
void SecondaryColor3{bsifdubusui}(T components);
void SecondaryColor3{bsifdubusui}v(T components);
The Color command has two major variants: Color3 and Color4. The four value
versionssetallfourvalues. ThethreevalueversionssetR,G,andBtotheprovided
values; Aissetto1.0. (Theconversionofintegercolorcomponents (R,G,B,and
A)to?oating-pointvaluesisdiscussedinsection 2.14.)
The secondary color has only the three value versions. Secondary A is always
setto1.0.
Version2.1-December1,200622 CHAPTER2. OPENGLOPERATION
VersionsoftheColorandSecondaryColorcommandsthattake?oating-point
values accept values nominally between 0.0 and 1.0. 0.0 corresponds to the min-
imum while 1.0 corresponds to the maximum (machine dependent) value that a
component may take on in the framebuffer (see section 2.14 on colors and color-
ing). Valuesoutside[0,1]arenotclamped.
Thecommand
void Index{sifdub}(T index);
void Index{sifdub}v(T index);
updates the current (single-valued) color index. It takes one argument, the value
to which the current color index should be set. Values outside the (machine-
dependent)representablerangeofcolorindicesarenotclamped.
Vertex shaders (see section 2.15) can be written to access an array of 4-
componentgenericvertexattributesinadditiontotheconventionalattributesspec-
i?edpreviously. The?rstslotofthisarrayisnumbered0,andthesizeofthearray
isspeci?edbytheimplementation-dependentconstant MAX VERTEX ATTRIBS.
Thecommands
void VertexAttrib{1234}{sfd}(uint index,T values);
void VertexAttrib{123}{sfd}v(uint index,T values);
void VertexAttrib4{bsifdubusui}v(uint index,T values);
canbeusedtoloadthegivenvalue(s)intothegenericattributeatslotindex,whose
components are named x, y, z, and w. The VertexAttrib1* family of commands
setsthexcoordinatetotheprovidedsingleargumentwhilesettingyandzto0and
w to 1. Similarly, VertexAttrib2* commands set x and y to the speci?ed values,
z to 0 and w to 1; VertexAttrib3* commands set x, y, and z, with w set to 1, and
VertexAttrib4*commandssetallfourcoordinates. TheerrorINVALID VALUEis
generatedif indexisgreaterthanorequaltoMAX VERTEX ATTRIBS.
Thecommands
void VertexAttrib4Nub(uint index,T values);
void VertexAttrib4N{bsiubusui}v(uint index,T values);
also specify vertex attributes with ?xed-point coordinates that are scaled to a nor-
malizedrange,accordingtotable2.9.
The VertexAttrib* entry points de?ned earlier can also be used to load at-
tributesdeclaredasa matrixinavertexshader. Eachcolumnofamatrixtakesup
onegeneric4-componentattributeslotoutofthe MAX VERTEX ATTRIBSavailable
Version2.1-December1,20062.8. VERTEXARRAYS 23
slots. Matrices are loaded into these slots in column major order. Matrix columns
needtobeloadedinincreasingslotnumbers.
Setting generic vertex attribute zero speci?es a vertex; the four vertex coordi-
nates are taken from the values of attribute zero. A Vertex2, Vertex3, or Vertex4
commandiscompletelyequivalenttothecorrespondingVertexAttrib*command
withanindexofzero. Settinganyothergenericvertexattributeupdatesthecurrent
valuesoftheattribute. Therearenocurrentvaluesforvertexattributezero.
There is no aliasing among generic attributes and conventional attributes. In
other words, an application can set all MAX VERTEX ATTRIBS generic attributes
and all conventional attributes without fear of one particular attribute overwriting
thevalueofanotherattribute.
Thestaterequiredtosupportvertexspeci?cationconsistsoffour?oating-point
numbers per texture coordinate set to store the current texture coordinates s, t, r,
and q, three ?oating-point numbers to store the three coordinates of the current
normal,one?oating-pointnumbertostorethecurrentfogcoordinate,four?oating-
pointvaluestostorethecurrentRGBAcolor,four?oating-pointvaluestostorethe
current RGBA secondary color, one ?oating-point value to store the current color
index, and MAX VERTEX ATTRIBS? 1 four-component ?oating-point vectors to
storegenericvertexattributes.
There is no notion of a current vertex, so no state is devoted to vertex coor-
dinates or generic attribute zero. The initial texture coordinates are (s,t,r,q) =
(0,0,0,1) for each texture coordinate set. The initial current normal has coor-
dinates (0,0,1). The initial fog coordinate is zero. The initial RGBA color is
(R,G,B,A) = (1,1,1,1) and the initial RGBA secondary color is (0,0,0,1).
The initial color index is 1. The initial values for all generic vertex attributes are
(0,0,0,1).
2.8 VertexArrays
The vertex speci?cation commands described in section 2.7 accept data in almost
any format, but their use requires many command executions to specify even sim-
ple geometry. Vertex data may also be placed into arrays that are stored in the
client’s address space. Blocks of data in these arrays may then be used to spec-
ify multiple geometric primitives through the execution of a single GL command.
The client may specify up to seven plus the values of MAX TEXTURE COORDS and
MAX VERTEX ATTRIBSarrays: oneeachtostorevertexcoordinates,normals,col-
ors, secondary colors, color indices, edge ?ags, fog coordinates, two or more tex-
turecoordinatesets,andoneormoregenericvertexattributes. Thecommands
Version2.1-December1,200624 CHAPTER2. OPENGLOPERATION
void VertexPointer(int size,enum type,sizei stride,
void *pointer);
void NormalPointer(enum type,sizei stride,
void *pointer);
void ColorPointer(int size,enum type,sizei stride,
void *pointer);
void SecondaryColorPointer(int size,enum type,
sizei stride,void *pointer);
void IndexPointer(enum type,sizei stride,void *pointer);
void EdgeFlagPointer(sizei stride,void *pointer);
void FogCoordPointer(enum type,sizei stride,
void *pointer);
void TexCoordPointer(int size,enum type,sizei stride,
void *pointer);
void VertexAttribPointer(uint index,int size,enum type,
boolean normalized,sizei stride,const
void *pointer);
describe the locations and organizations of these arrays. For each command,
type speci?es the data type of the values stored in the array. Because edge ?ags
are always type boolean, EdgeFlagPointer has no type argument. size, when
present, indicates the number of values per vertex that are stored in the array.
Because normals are always speci?ed with three values, NormalPointer has no
size argument. Likewise, because color indices and edge ?ags are always spec-
i?ed with a single value, IndexPointer and EdgeFlagPointer also have no size
argument. Table 2.4 indicates the allowable values for size and type (when
present). For type the values BYTE, SHORT, INT, FLOAT, and DOUBLE indicate
types byte, short, int, float, and double, respectively; and the values
UNSIGNED BYTE, UNSIGNED SHORT, and UNSIGNED INT indicate typesubyte,
ushort, anduint, respectively. The error INVALID VALUE is generated if size
isspeci?edwithavalueotherthanthatindicatedinthetable.
The index parameter in the VertexAttribPointer command identi?es the
genericvertexattributearraybeingdescribed. TheerrorINVALID VALUEisgener-
atedifindexisgreaterthanorequaltoMAX VERTEX ATTRIBS.Thenormalizedpa-
rameterintheVertexAttribPointercommandidenti?eswhether?xed-pointtypes
Version2.1-December1,20062.8. VERTEXARRAYS 25
Command Sizes Normalized Types
VertexPointer 2,3,4 no short,int,float,double
NormalPointer 3 yes byte, short, int, float,
double
ColorPointer 3,4 yes byte, ubyte, short,
ushort, int, uint, float,
double
SecondaryColorPointer 3 yes byte, ubyte, short,
ushort, int, uint, float,
double
IndexPointer 1 no ubyte, short, int, float,
double
FogCoordPointer 1 - float,double
TexCoordPointer 1,2,3,4 no short,int,float,double
EdgeFlagPointer 1 no boolean
VertexAttribPointer 1,2,3,4 ?ag byte, ubyte, short,
ushort, int, uint, float,
double
Table2.4: Vertexarraysizes(valuespervertex)anddatatypes. The”normalized”
column indicates whether ?xed-point types are accepted directly or normalized
to [0,1] (for unsigned types) or [?1,1] (for signed types). For generic vertex at-
tributes, ?xed-point data are normalized if and only if the VertexAttribPointer
normalized?agisset.
Version2.1-December1,200626 CHAPTER2. OPENGLOPERATION
should be normalized when converted to ?oating-point. If normalized is TRUE,
?xed-point data are converted as speci?ed in table 2.9; otherwise, the ?xed-point
valuesareconverteddirectly.
Theone,two,three,orfourvaluesinanarraythatcorrespondtoasinglevertex
comprise an array element. The values within each array element are stored se-
quentially in memory. If stride is speci?ed as zero, then array elements are stored
sequentially as well. The error INVALID VALUE is generated if stride is negative.
Otherwise pointers to the ith and (i + 1)st elements of an array differ by stride
basicmachineunits(typicallyunsignedbytes),thepointertothe(i+1)stelement
being greater. For each command, pointer speci?es the location in memory of the
?rstvalueofthe?rstelementofthearraybeingspeci?ed.
Anindividualarrayisenabledordisabledbycallingoneof
void EnableClientState(enum array);
void DisableClientState(enum array);
with array set to VERTEX ARRAY, NORMAL ARRAY, COLOR ARRAY,
SECONDARY COLOR ARRAY, INDEX ARRAY, EDGE FLAG ARRAY,
FOG COORD ARRAY, or TEXTURE COORD ARRAY, for the vertex, normal, color,
secondarycolor,colorindex,edge?ag,fogcoordinate,ortexturecoordinatearray,
respectively.
An individual generic vertex attribute array is enabled or disabled by calling
oneof
void EnableVertexAttribArray(uint index);
void DisableVertexAttribArray(uint index);
where index identi?es the generic vertex attribute array to enable or disable.
The error INVALID VALUE is generated if index is greater than or equal to
MAX VERTEX ATTRIBS.
Thecommand
void ClientActiveTexture(enum texture);
is used to select the vertex array client state parameters to be modi?ed by
theTexCoordPointercommandandthearrayaffectedbyEnableClientStateand
DisableClientState with parameter TEXTURE COORD ARRAY. This command sets
the client state variable CLIENT ACTIVE TEXTURE. Each texture coordinate set
has a client state vector which is selected when this command is invoked. This
state vector includes the vertex array state. This call also selects the texture coor-
dinatesetstateusedforqueriesofclientstate.
Version2.1-December1,20062.8. VERTEXARRAYS 27
Specifying an invalid texture generates the errorINVALID ENUM. Valid values
of texture are the same as for the MultiTexCoord commands described in sec-
tion2.7.
Thecommand
void ArrayElement(int i);
transfers the ith element of every enabled array to the GL. The effect of
ArrayElement(i)isthesameastheeffectofthecommandsequence
if (normalarrayenabled)
Normal3[type]v(normalarrayelementi);
if (colorarrayenabled)
Color[size][type]v(colorarrayelementi);
if (secondarycolorarrayenabled)
SecondaryColor3[type]v(secondarycolorarrayelementi);
if (fogcoordinatearrayenabled)
FogCoord[type]v(fogcoordinatearrayelementi);
for (j = 0; j < textureUnits; j++) {
if (texturecoordinatesetjarrayenabled)
MultiTexCoord[size][type]v(TEXTURE0+j,texturecoordinatesetjarrayelementi);
if (colorindexarrayenabled)
Index[type]v(colorindexarrayelementi);
if (edge?agarrayenabled)
EdgeFlagv(edge?agarrayelementi);
for (j = 1; j < genericAttributes; j++) {
if (genericvertexattributejarrayenabled) {
if (genericvertexattributejarraynormalization?agisset,and
typeisnotFLOATorDOUBLE)
VertexAttrib[size]N[type]v(j,genericvertexattributejarrayelementi);
else
VertexAttrib[size][type]v(j,genericvertexattributejarrayelementi);
}
}
if (genericattributearray0enabled) {
if (genericvertexattribute0arraynormalization?agisset,and
typeisnotFLOATorDOUBLE)
VertexAttrib[size]N[type]v(0,genericvertexattribute0arrayelementi);
else
VertexAttrib[size][type]v(0,genericvertexattribute0arrayelementi);
Version2.1-December1,200628 CHAPTER2. OPENGLOPERATION
} else if (vertexarrayenabled) {
Vertex[size][type]v(vertexarrayelementi);
}
where textureUnits and genericAttributes give the number of texture coordinate
sets and generic vertex attributes supported by the implementation, respectively.
”[size]” and ”[type]” correspond to the size and type of the corresponding array.
For generic vertex attributes, it is assumed that a complete set of vertex attribute
commandsexists,eventhoughnotallsuchfunctionsareprovidedbytheGL.
Changes made to array data between the execution of Begin and the corre-
spondingexecutionofEndmayaffectcallstoArrayElementthataremadewithin
the same Begin/End period in non-sequential ways. That is, a call to ArrayEle-
mentthatprecedesachangetoarraydatamayaccessthechangeddata,andacall
thatfollowsachangetoarraydatamayaccessoriginaldata.
Specifying i < 0 results in unde?ned behavior. Generating the error
INVALID VALUEisrecommendedinthiscase.
Thecommand
void DrawArrays(enum mode,int ?rst,sizei count);
constructs a sequence of geometric primitives using elements first through
first + count? 1 of each enabled array. mode speci?es what kind of primi-
tives are constructed; it accepts the same token values as the mode parameter of
theBegincommand. Theeffectof
DrawArrays(mode,first,count);
isthesameastheeffectofthecommandsequence
if (modeorcountisinvalid)
generateappropriateerror
else {
Begin(mode);
for (int i = 0; i < count; i++)
ArrayElement(first+i);
End();
}
with one exception: the current normal coordinates, color, secondary color, color
index, edge ?ag, fog coordinate, texture coordinates, and generic attributes are
each indeterminate after execution of DrawArrays, if the corresponding array is
Version2.1-December1,20062.8. VERTEXARRAYS 29
enabled. Current values corresponding to disabled arrays are not modi?ed by the
executionofDrawArrays.
Specifying first < 0 results in unde?ned behavior. Generating the error
INVALID VALUEisrecommendedinthiscase.
Thecommand
void MultiDrawArrays(enum mode,int *?rst,
sizei *count,sizei primcount);
behaves identically to DrawArrays except that primcount separate ranges of
elementsarespeci?edinstead. Ithasthesameeffectas:
for (i = 0; i < primcount; i++) {
if (count[i] > 0)
DrawArrays(mode, first[i], count[i]);
}
Thecommand
void DrawElements(enum mode,sizei count,enum type,
void *indices);
constructs a sequence of geometric primitives using the count elements
whose indices are stored in indices. type must be one of UNSIGNED BYTE,
UNSIGNED SHORT,orUNSIGNED INT,indicatingthatthevaluesin indicesarein-
dices of GL type ubyte, ushort, or uint respectively. mode speci?es what
kind of primitives are constructed; it accepts the same token values as the mode
parameteroftheBegincommand. Theeffectof
DrawElements(mode,count,type,indices);
isthesameastheeffectofthecommandsequence
if (mode,count,ortypeisinvalid)
generateappropriateerror
else {
Begin(mode);
for (int i = 0; i < count; i++)
ArrayElement(indices[i]);
End();
}
Version2.1-December1,200630 CHAPTER2. OPENGLOPERATION
with one exception: the current normal coordinates, color, secondary color, color
index,edge?ag,fogcoordinate,texturecoordinates,andgenericattributesareeach
indeterminate after the execution of DrawElements, if the corresponding array is
enabled. Current values corresponding to disabled arrays are not modi?ed by the
executionofDrawElements.
Thecommand
void MultiDrawElements(enum mode,sizei *count,
enum type,void **indices,sizei primcount);
behaves identically to DrawElements except that primcount separate lists of
elementsarespeci?edinstead. Ithasthesameeffectas:
for (i = 0; i < primcount; i++) {
if (count[i]) > 0)
DrawElements(mode, count[i], type, indices[i]);
}
Thecommand
void DrawRangeElements(enum mode,uint start,
uint end,sizei count,enum type,void *indices);
is a restricted form of DrawElements. mode, count, type, and indices match the
correspondingargumentstoDrawElements,withtheadditionalconstraintthatall
valuesinthearray indicesmustliebetween startand endinclusive.
Implementationsdenoterecommendedmaximumamountsofvertexandindex
data, which may be queried by calling GetIntegerv with the symbolic constants
MAX ELEMENTS VERTICES and MAX ELEMENTS INDICES. Ifend?start+1 is
greater than the value of MAX ELEMENTS VERTICES, or if count is greater than
the value of MAX ELEMENTS INDICES, then the call may operate at reduced per-
formance. There is no requirement that all vertices in the range [start,end] be
referenced. However, the implementation may partially process unused vertices,
reducingperformancefromwhatcouldbeachievedwithanoptimalindexset.
The error INVALID VALUE is generated ifend < start. Invalid mode, count,
or type parameters generate the same errors as would the corresponding call to
DrawElements. It is an error for indices to lie outside the range [start,end], but
implementations may not check for this. Such indices will cause implementation-
dependentbehavior.
Thecommand
Version2.1-December1,20062.8. VERTEXARRAYS 31
void InterleavedArrays(enum format,sizei stride,
void *pointer);
ef?ciently initializes the six arrays and their enables to one of 14 con-
?gurations. format must be one of 14 symbolic constants: V2F,
V3F, C4UB V2F, C4UB V3F, C3F V3F, N3F V3F, C4F N3F V3F, T2F V3F,
T4F V4F, T2F C4UB V3F, T2F C3F V3F, T2F N3F V3F, T2F C4F N3F V3F, or
T4F C4F N3F V4F.
Theeffectof
InterleavedArrays(format,stride,pointer);
isthesameastheeffectofthecommandsequence
if (formatorstrideisinvalid)
generateappropriateerror
else {
int str;
sete ,e ,e ,s ,s ,s ,t ,p ,p ,p ,andsasafunction
t c n t c v c c n v
oftable2.5andthevalueofformat.
str=stride;
if (striszero)
str=s;
DisableClientState(EDGE FLAG ARRAY);
DisableClientState(INDEX ARRAY);
DisableClientState(SECONDARY COLOR ARRAY);
DisableClientState(FOG COORD ARRAY);
if (e ) {
t
EnableClientState(TEXTURE COORD ARRAY);
TexCoordPointer(s ,FLOAT,str,pointer);
t
} else
DisableClientState(TEXTURE COORD ARRAY);
if (e ) {
c
EnableClientState(COLOR ARRAY);
ColorPointer(s ,t ,str,pointer+p );
c c c
} else
DisableClientState(COLOR ARRAY);
if (e ) {
n
EnableClientState(NORMAL ARRAY);
NormalPointer(FLOAT,str,pointer+p );
n
} else
Version2.1-December1,200632 CHAPTER2. OPENGLOPERATION
format e e e s s s t
t c n t c v c
V2F False False False 2
V3F False False False 3
C4UB V2F False True False 4 2 UNSIGNED BYTE
C4UB V3F False True False 4 3 UNSIGNED BYTE
C3F V3F False True False 3 3 FLOAT
N3F V3F False False True 3
C4F N3F V3F False True True 4 3 FLOAT
T2F V3F True False False 2 3
T4F V4F True False False 4 4
T2F C4UB V3F True True False 2 4 3 UNSIGNED BYTE
T2F C3F V3F True True False 2 3 3 FLOAT
T2F N3F V3F True False True 2 3
T2F C4F N3F V3F True True True 2 4 3 FLOAT
T4F C4F N3F V4F True True True 4 4 4 FLOAT
format p p p s
c n v
V2F 0 2f
V3F 0 3f
C4UB V2F 0 c c+2f
C4UB V3F 0 c c+3f
C3F V3F 0 3f 6f
N3F V3F 0 3f 6f
C4F N3F V3F 0 4f 7f 10f
T2F V3F 2f 5f
T4F V4F 4f 8f
T2F C4UB V3F 2f c+2f c+5f
T2F C3F V3F 2f 5f 8f
T2F N3F V3F 2f 5f 8f
T2F C4F N3F V3F 2f 6f 9f 12f
T4F C4F N3F V4F 4f 8f 11f 15f
Table 2.5: Variables that direct the execution of InterleavedArrays. f is
sizeof(FLOAT). c is 4 times sizeof(UNSIGNED BYTE), rounded up to
the nearest multiple of f. All pointer arithmetic is performed in units of
sizeof(UNSIGNED BYTE).
Version2.1-December1,20062.9. BUFFEROBJECTS 33
DisableClientState(NORMAL ARRAY);
EnableClientState(VERTEX ARRAY);
VertexPointer(s ,FLOAT,str,pointer+p );
v v
}
Ifthenumberofsupportedtextureunits(thevalueofMAX TEXTURE COORDS)
is m and the number of supported generic vertex attributes (the value of
MAX VERTEX ATTRIBS) is n, then the client state required to implement vertex
arrays consists of an integer for the client active texture unit selector, 7 +m+n
boolean values, 7 + m + n memory pointers, 7 + m + n integer stride values,
7+m+nsymbolicconstantsrepresentingarraytypes,3+m+nintegersrepre-
senting values per element, andn boolean values indicating normalization. In the
initialstate,theclientactivetextureunitselectorisTEXTURE0,thebooleanvalues
are each false, the memory pointers are each NULL, the strides are each zero, the
array types are each FLOAT, and the integers representing values per element are
eachfour.
2.9 BufferObjects
The vertex data arrays described in section 2.8 are stored in client memory. It
is sometimes desirable to store frequently used client data, such as vertex array
and pixel data, in high-performance server memory. GL buffer objects provide a
mechanismthatclientscanusetoallocate,initialize,andrenderfromsuchmemory.
The name space for buffer objects is the unsigned integers, with zero reserved
fortheGL.Abufferobjectiscreatedbybindinganunusednameto abuffertarget.
Thebindingiseffectedbycalling
void BindBuffer(enum target,uint buffer);
target must be one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. The ARRAY BUFFER target is
discussed in section 2.9.1. The ELEMENT ARRAY BUFFER target is discussed in
section 2.9.2. The PIXEL UNPACK BUFFER and PIXEL PACK BUFFER targets are
discussedlaterinsections3.6,4.3.2,and6.1. Ifthebufferobjectnamedbufferhas
not been previously bound or has been deleted since the last binding, the GL cre-
atesanewstatevector,initializedwithazero-sizedmemorybufferandcomprising
thestatevalueslistedintable2.6.
BindBuffer may also be used to bind an existing buffer object. If the bind is
successfulnochangeismadetothestateofthenewlyboundbufferobject,andany
previousbindingto targetisbroken.
Version2.1-December1,200634 CHAPTER2. OPENGLOPERATION
Name Type InitialValue LegalValues
BUFFER SIZE integer 0 anynon-negativeinteger
BUFFER USAGE enum STATIC DRAW STREAM DRAW,STREAM READ,
STREAM COPY,STATIC DRAW,
STATIC READ,STATIC COPY,
DYNAMIC DRAW,DYNAMIC READ,
DYNAMIC COPY
BUFFER ACCESS enum READ WRITE READ ONLY,WRITE ONLY,
READ WRITE
BUFFER MAPPED boolean FALSE TRUE,FALSE
BUFFER MAP POINTER void* NULL address
Table2.6: Bufferobjectparametersandtheirvalues.
Whileabufferobjectisbound,GLoperationsonthetargettowhichitisbound
affect the bound buffer object, and queries of the target to which a buffer object is
boundreturnstatefromtheboundobject.
Initially, each buffer object target is bound to zero. There is no buffer object
correspondingtothenamezero,soclientattemptstomodifyorquerybufferobject
stateforatargetboundtozerogenerateanINVALID OPERATIONerror.
Bufferobjectsaredeletedbycalling
void DeleteBuffers(sizei n,const uint *buffers);
buffers contains n names of buffer objects to be deleted. After a buffer object is
deleted it has no contents, and its name is again unused. Unused names in buffers
aresilentlyignored,asisthevaluezero.
Thecommand
void GenBuffers(sizei n,uint *buffers);
returns n previously unused buffer object names in buffers. These names are
markedasused,forthepurposesofGenBuffersonly,buttheyacquirebufferstate
onlywhentheyare?rstbound,justasiftheywereunused.
While a buffer object is bound, any GL operations on that object affect any
other bindings of that object. If a buffer object is deleted while it is bound, all
bindings to that object in the current context (i.e. in the thread that called Delete-
Buffers) are reset to zero. Bindings to that buffer in other contexts and other
threads are not affected, but attempting to use a deleted buffer in another thread
Version2.1-December1,20062.9. BUFFEROBJECTS 35
produces unde?ned results, including but not limited to possible GL errors and
rendering corruption. Using adeleted bufferin another contextor threadmay not,
however,resultinprogramtermination.
Thedatastoreofabufferobjectiscreatedandinitializedbycalling
void BufferData(enum target,sizeiptr size,const
void *data,enum usage);
with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER, size set to the size of the data
storeinbasicmachineunits,anddatapointingtothesourcedatainclientmemory.
If data is non-null, then the source data is copied to the buffer object’s data store.
If dataisnull,thenthecontentsofthebufferobject’sdatastoreareunde?ned.
usage is speci?ed as one of nine enumerated values, indicating the expected
applicationusagepatternofthedatastore. Thevaluesare:
STREAM DRAW The data store contents will be speci?ed once by the application,
andusedatmostafewtimesasthesourceforGLdrawingandimagespeci-
?cationcommands.
STREAM READ The data store contents will be speci?ed once by reading data
fromtheGL,andqueriedatmostafewtimesbytheapplication.
STREAM COPY The data store contents will be speci?ed once by reading data
fromtheGL,andusedatmostafewtimesasthesourceforGLdrawingand
imagespeci?cationcommands.
STATIC DRAW The data store contents will be speci?ed once by the application,
and used many times as the source for GL drawing and image speci?cation
commands.
STATIC READ The data store contents will be speci?ed once by reading data
fromtheGL,andqueriedmanytimesbytheapplication.
STATIC COPY The data store contents will be speci?ed once by reading data
from theGL, and usedmany timesas the sourcefor GL drawingand image
speci?cationcommands.
DYNAMIC DRAW The data store contents will be respeci?ed repeatedly by the ap-
plication, and used many times as the source for GL drawing and image
speci?cationcommands.
Version2.1-December1,200636 CHAPTER2. OPENGLOPERATION
Name Value
BUFFER SIZE size
BUFFER USAGE usage
BUFFER ACCESS READ WRITE
BUFFER MAPPED FALSE
BUFFER MAP POINTER NULL
Table2.7: Bufferobjectinitialstate.
DYNAMIC READ The data store contents will be respeci?ed repeatedly by reading
datafromtheGL,andqueriedmanytimesbytheapplication.
DYNAMIC COPY The data store contents will be respeci?ed repeatedly by reading
data from the GL, and used many times as the source for GL drawing and
imagespeci?cationcommands.
usage is provided as a performance hint only. The speci?ed usage value does
notconstraintheactualusagepatternofthedatastore.
BufferData deletes any existing data store, and sets the values of the buffer
object’sstatevariablesasshownintable2.7.
Clientsmustaligndataelementsconsistentwiththerequirementsoftheclient
platform,withanadditionalbase-levelrequirementthatanoffsetwithinabufferto
adatumcomprisingN basicmachineunitsbeamultipleofN.
If the GL is unable to create a data store of the requested size, the error
OUT OF MEMORYisgenerated.
To modify some or all of the data contained in a buffer object’s data store, the
clientmayusethecommand
void BufferSubData(enum target,intptr offset,
sizeiptr size,const void *data);
with target set to ARRAY BUFFER. offset and size indicate the range of data in the
bufferobjectthatistobereplaced,intermsofbasicmachineunits. dataspeci?esa
regionofclientmemorysizebasicmachineunitsinlength,containingthedatathat
replace thespeci?ed bufferrange. AnINVALID VALUE error isgenerated if offset
orsizeislessthanzero,orifoffset+sizeisgreaterthanthevalueofBUFFER SIZE.
Theentiredatastoreofabufferobjectcanbemappedintotheclient’saddress
spacebycalling
void *MapBuffer(enum target,enum access);
Version2.1-December1,20062.9. BUFFEROBJECTS 37
Name Value
BUFFER ACCESS access
BUFFER MAPPED TRUE
BUFFER MAP POINTER pointertothedatastore
Table2.8: BufferobjectstatesetbyMapBuffer.
with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. If the GL is able to map the
buffer object’s data store into the client’s address space, MapBuffer returns the
pointer value to the data store. If the buffer data store is already in the mapped
state, MapBuffer returns NULL, and an INVALID OPERATION error is generated.
Otherwise MapBuffer returns NULL, and the error OUT OF MEMORY is generated.
access is speci?ed as one of READ ONLY, WRITE ONLY, or READ WRITE, indicat-
ingtheoperationsthattheclientmayperformonthedatastorethroughthepointer
whilethedatastoreismapped.
MapBuffersetsbufferobjectstatevaluesasshownintable2.8.
Non- NULLpointersreturnedbyMapBuffermaybeusedbytheclienttomod-
ify and query buffer object data, consistent with the access rules of the mapping,
while the mapping remains valid. No GL error is generated if the pointer is
used to attempt to modify a READ ONLY data store, or to attempt to read from a
WRITE ONLYdatastore,butoperationmaybeslowandsystemerrors(possiblyin-
cluding program termination) may result. Pointer values returned by MapBuffer
may not be passed as parameter values to GL commands. For example, they may
not be used to specify array pointers, or to specify or query pixel or texture image
data; such actions produce unde?ned results, although implementations may not
checkforsuchbehaviorforperformancereasons.
CallingBufferSubData to modify the data store of a mapped buffer will gen-
erateanINVALID OPERATIONerror.
Mappings to the data stores of buffer objects may have nonstandard perfor-
mancecharacteristics. Forexample,suchmappingsmaybemarkedasuncacheable
regions of memory, and in such cases reading from them may be very slow. To
ensureoptimalperformance,theclientshouldusethemappinginafashionconsis-
tent with the values ofBUFFER USAGE andBUFFER ACCESS. Using a mapping in
afashioninconsistentwiththesevaluesisliabletobemultipleordersofmagnitude
slowerthanusingnormalmemory.
After the client has speci?ed the contents of a mapped data store, and before
thedatainthatstorearedereferencedbyanyGLcommands,themappingmustbe
Version2.1-December1,200638 CHAPTER2. OPENGLOPERATION
relinquishedbycalling
boolean UnmapBuffer(enum target);
with target set to one of ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL UNPACK BUFFER, or PIXEL PACK BUFFER. Unmapping a mapped buffer
object invalidates the pointers to its data store and sets the object’s
BUFFER MAPPEDstatetoFALSEanditsBUFFER MAP POINTERstatetoNULL.
UnmapBuffer returns TRUE unless data values in the buffer’s data store have
become corrupted during the period that the buffer was mapped. Such corruption
canbetheresultofascreenresolutionchangeorotherwindow-system-dependent
eventthatcausessystemheapssuchasthoseforhigh-performancegraphicsmem-
ory to be discarded. GL implementations must guarantee that such corruption can
occur only during the periods that a buffer’s data store is mapped. If such corrup-
tion has occurred, UnmapBuffer returns FALSE, and the contents of the buffer’s
datastorebecomeunde?ned.
Ifthebufferdatastoreisalreadyintheunmappedstate,UnmapBufferreturns
FALSE, and an INVALID OPERATION error is generated. However, unmapping
thatoccursasasideeffectofbufferdeletionorreinitializationisnotanerror.
2.9.1 VertexArraysinBufferObjects
Blocks of vertex array data may be stored in buffer objects with the same format
and layout options supported for client-side vertex arrays. However, it is expected
thatGLimplementationswill(atminimum)beoptimizedfordatawithallcompo-
nents represented as ?oats, as well as for color data with components represented
aseither?oatsorunsignedbytes.
A buffer object binding point is added to the client state associated with
each vertex array type. The commands that specify the locations and or-
ganizations of vertex arrays copy the buffer object name that is bound to
ARRAY BUFFER to the binding point corresponding to the vertex array of the
type being speci?ed. For example, the NormalPointer command copies the
value of ARRAY BUFFER BINDING (the queriable name of the buffer bind-
ing corresponding to the target ARRAY BUFFER) to the client state variable
NORMAL ARRAY BUFFER BINDING.
Rendering commands ArrayElement, DrawArrays, DrawElements,
DrawRangeElements, MultiDrawArrays, and MultiDrawElements operate as
previouslyde?ned,exceptthatdataforenabledvertexandattribarraysaresourced
from buffers if the array’s buffer binding is non-zero. When an array is sourced
fromabufferobject,thepointervalueofthatarrayisusedtocomputeanoffset,in
Version2.1-December1,20062.9. BUFFEROBJECTS 39
basicmachineunits,intothedatastoreofthebufferobject. Thisoffsetiscomputed
bysubtractinganullpointerfromthepointervalue,wherebothpointersaretreated
aspointerstobasicmachineunits.
It is acceptable for vertex or attrib arrays to be sourced from any combination
ofclientmemoryandvariousbufferobjectsduringasinglerenderingoperation.
Attemptstosourcedatafromacurrentlymappedbufferobjectwillgeneratean
INVALID OPERATIONerror.
2.9.2 ArrayIndicesinBufferObjects
Blocks of array indices may be stored in buffer objects with the same format op-
tions that are supported for client-side index arrays. Initially zero is bound to
ELEMENT ARRAY BUFFER, indicating that DrawElements and DrawRangeEle-
ments are to source their indices from arrays passed as their indices parameters,
andthatMultiDrawElementsistosourceitsindicesfromthearrayofpointersto
arrayspassedinasits indicesparameter.
A buffer object is bound to ELEMENT ARRAY BUFFER by calling BindBuffer
withtargetsettoELEMENT ARRAY BUFFER,andbuffersettothenameofthebuffer
object. If no corresponding buffer object exists, one is initialized as de?ned in
section2.9.
While a non-zero buffer object name is bound to ELEMENT ARRAY BUFFER,
DrawElements and DrawRangeElements source their indices from that buffer
object, using their indices parameters as offsets into the buffer object in the same
fashion as described in section 2.9.1. MultiDrawElements also sources its in-
dicesfromthatbufferobject,usingitsindicesparameterasapointertoanarrayof
pointersthatrepresentoffsetsintothebufferobject.
Buffer objects created by binding an unused name to ARRAY BUFFER and to
ELEMENT ARRAY BUFFERareformallyequivalent,buttheGLmaymakedifferent
choices about storage implementation based on the initial binding. In some cases
performancewillbeoptimizedbystoringindicesandarraydatainseparatebuffer
objects,andbycreatingthosebufferobjectswiththecorrespondingbindingpoints.
2.9.3 BufferObjectState
Thestaterequiredtosupportbufferobjectsconsistsofbindingnamesforthearray
buffer, element buffer, pixel unpack buffer, and pixel pack buffer. Additionally,
each vertex array has an associated binding so there is a buffer object binding for
each of the vertex array, normal array, color array, index array, multiple texture
coordinatearrays,edge?agarray,secondarycolorarray,fogcoordinatearray,and
vertexattributearrays. Theinitialvaluesforallbufferobjectbindingsiszero.
Version2.1-December1,200640 CHAPTER2. OPENGLOPERATION
Thestateofeachbufferobjectconsistsofabuffersizeinbasicmachineunits,
ausageparameter,anaccessparameter,amappedboolean,apointertothemapped
buffer(NULLifunmapped),andthesizedarrayofbasicmachineunitsforthebuffer
data.
2.10 Rectangles
There is a set of GL commands to support ef?cient speci?cation of rectangles as
twocornervertices.
void Rect{sifd}(T x1,T y1,T x2,T y2);
void Rect{sifd}v(T v1[2],T v2[2]);
Each command takes either four arguments organized as two consecutive pairs of
(x,y) coordinates, or two pointers to arrays each of which contains an x value
followedbyay value. TheeffectoftheRectcommand
Rect(x ,y ,x ,y );
1 1 2 2
isexactlythesameasthefollowingsequenceofcommands:
Begin(POLYGON);
Vertex2(x ,y );
1 1
Vertex2(x ,y );
2 1
Vertex2(x ,y );
2 2
Vertex2(x ,y );
1 2
End();
The appropriate Vertex2 command would be invoked depending on which of the
Rectcommandsisissued.
2.11 CoordinateTransformations
This section and the following discussion through section 2.14 describe the state
values and operations necessary for transforming vertex attributes according to a
?xed-functionality method. An alternate programmable method for transforming
vertexattributesisdescribedinsection2.15.
Vertices,normals,andtexturecoordinatesaretransformedbeforetheircoordi-
natesareusedtoproduceanimageintheframebuffer. Webeginwithadescription
of how vertex coordinates are transformed and how this transformation is con-
trolled.
Version2.1-December1,20062.11. COORDINATETRANSFORMATIONS 41
Normalized
Projection
Model?View
Clip
Object Eye
Perspective Device
Division
Coordinates Coordinates Coordinates Coordinates
Matrix Matrix
Viewport Window
Transformation
Coordinates
Figure2.6. Vertextransformationsequence.
Figure 2.6 diagrams the sequence of transformations that are applied to ver-
tices. The vertex coordinates that are presented to the GL are termed object co-
ordinates. The model-view matrix is applied to these coordinates to yield eye co-
ordinates. Then another matrix, called the projection matrix, is applied to eye
coordinates to yield clip coordinates. A perspective division is carried out on clip
coordinates to yield normalized device coordinates. A ?nal viewport transforma-
tionisappliedtoconvertthesecoordinatesinto window coordinates.
Objectcoordinates,eyecoordinates,andclipcoordinatesarefour-dimensional,
consisting ofx, y, z, andw coordinates (in that order). The model-view and pro-
jectionmatricesarethus4?4.
? ?
x
o
? ?
y
o
? ?
Ifavertexinobjectcoordinatesisgivenby andthemodel-viewmatrix
? ?
z
o
w
o
isM,thenthevertex’seyecoordinatesarefoundas
? ? ? ?
x x
e o
? ? ? ?
y y
e o
? ? ? ?
=M .
? ? ? ?
z z
e o
w w
e o
Version2.1-December1,200642 CHAPTER2. OPENGLOPERATION
Similarly,ifP istheprojectionmatrix,thenthevertex’sclipcoordinatesare
? ? ? ?
x x
c e
? ? ? ?
y y
c e
? ? ? ?
=P .
? ? ? ?
z z
c e
w w
c e
Thevertex’snormalizeddevicecoordinatesarethen
? ? ? ?
x x /w
d c c
? ? ? ?
y = y /w .
d c c
z z /w
d c c
2.11.1 ControllingtheViewport
The viewport transformation is determined by the viewport’s width and height in
pixels,p andp ,respectively,anditscenter(o ,o )(alsoinpixels). Thevertex’s
x y x y
? ?
x
w
? ?
windowcoordinates, y ,aregivenby
w
z
w
? ? ? ?
x (p /2)x +o
w x d x
? ? ? ?
y = (p /2)y +o .
w y d y
z [(f?n)/2]z +(n+f)/2
w d
Thefactorandoffsetappliedtoz encodedbynandf aresetusing
d
void DepthRange(clampd n,clampd f);
Eachofnandfareclampedtoliewithin[0,1],asareallargumentsoftypeclampd
orclampf. z istakentoberepresentedin?xed-pointwithatleastasmanybits
w
as there are in the depth buffer of the framebuffer. We assume that the ?xed-point
m m
representationusedrepresentseachvaluek/(2 ?1),wherek?{0,1,...,2 ?
1},ask (e.g. 1.0isrepresentedinbinaryasastringofallones).
Viewporttransformationparametersarespeci?edusing
void Viewport(int x,int y,sizei w,sizei h);
where x and y give the x and y window coordinates of the viewport’s lower left
cornerandwandhgivetheviewport’swidthandheight,respectively. Theviewport
parameters shown in the above equations are found from these values as o =
x
x+w/2ando =y +h/2;p =w,p =h.
y x y
Version2.1-December1,20062.11. COORDINATETRANSFORMATIONS 43
Viewport width and height are clamped to implementation-dependent maxi-
mums when speci?ed. The maximum width and height may be found by issuing
anappropriateGetcommand(seechapter6). Themaximumviewportdimensions
must be greater than or equal to the visible dimensions of the display being ren-
deredto. INVALID VALUEisgeneratedifeither wor hisnegative.
The state required to implement the viewport transformation is four integers
and two clamped ?oating-point values. In the initial state, w and h are set to the
width and height, respectively, of the window into which the GL is to do its ren-
dering. o ando are set tow/2 andh/2, respectively. n andf are set to 0.0 and
x y
1.0,respectively.
2.11.2 Matrices
The projection matrix and model-view matrix are set and modi?ed with a variety
ofcommands. Theaffectedmatrixisdeterminedbythecurrentmatrixmode. The
currentmatrixmodeissetwith
void MatrixMode(enum mode);
which takes one of the pre-de?ned constants TEXTURE, MODELVIEW, COLOR, or
PROJECTIONastheargumentvalue. TEXTUREisdescribedlaterinsection2.11.2,
andCOLORisdescribedinsection3.6.3. IfthecurrentmatrixmodeisMODELVIEW,
thenmatrixoperationsapplytothemodel-viewmatrix;if PROJECTION,thenthey
applytotheprojectionmatrix.
Thetwobasiccommandsforaffectingthecurrentmatrixare
void LoadMatrix{fd}(T m[16]);
void MultMatrix{fd}(T m[16]);
LoadMatrix takes a pointer to a 4?4 matrix stored in column-major order as 16
consecutive?oating-pointvalues,i.e. as
? ?
a a a a
1 5 9 13
? ?
a a a a
2 6 10 14
? ?
.
? ?
a a a a
3 7 11 15
a a a a
4 8 12 16
(This differs from the standard row-major C ordering for matrix elements. If the
standardorderingisused,allofthesubsequenttransformationequationsaretrans-
posed,andthecolumnsrepresentingvectorsbecomerows.)
Thespeci?edmatrixreplacesthecurrentmatrixwiththeonepointedto. Mult-
Matrix takes the same type argument as LoadMatrix, but multiplies the current
Version2.1-December1,200644 CHAPTER2. OPENGLOPERATION
matrixbytheonepointedtoandreplacesthecurrentmatrixwiththeproduct. IfC
is the current matrix and M is the matrix pointed to by MultMatrix’s argument,
0
thentheresultingcurrentmatrix,C ,is
0
C =C·M.
Thecommands
void LoadTransposeMatrix{fd}(T m[16]);
void MultTransposeMatrix{fd}(T m[16]);
takepointersto4?4matricesstoredinrow-majororderas16consecutive?oating-
pointvalues,i.e. as
? ?
a a a a
1 2 3 4
? ?
a a a a
5 6 7 8
? ?
.
? ?
a a a a
9 10 11 12
a a a a
13 14 15 16
Theeffectof
LoadTransposeMatrix[fd](m);
isthesameastheeffectof
T
LoadMatrix[fd](m );
Theeffectof
MultTransposeMatrix[fd](m);
isthesameastheeffectof
T
MultMatrix[fd](m );
Thecommand
void LoadIdentity(void);
effectivelycallsLoadMatrixwiththeidentitymatrix:
? ?
1 0 0 0
? ?
0 1 0 0
? ?
.
? ?
0 0 1 0
0 0 0 1
There are a variety of other commands that manipulate matrices. Rotate,
Translate,Scale,Frustum, andOrthomanipulatethecurrentmatrix. Eachcom-
putesamatrixandtheninvokesMultMatrixwiththismatrix. Inthecaseof
Version2.1-December1,20062.11. COORDINATETRANSFORMATIONS 45
void Rotate{fd}(T?,T x,T y,T z);
? gives an angle of rotation in degrees; the coordinates of a vectorv are given by
T
v = (xy z) . Thecomputedmatrixisacounter-clockwiserotationabouttheline
through the origin with the speci?ed axis when that axis is pointing up (i.e. the
right-handruledeterminesthesenseoftherotationangle). Thematrixisthus
? ?
0
? ?
R 0
? ?
.
? ?
0
0 0 0 1
T
0 0 0
Letu =v/||v|| = (x y z ) . If
? ?
0 0
0 ?z y
0 0
? ?
S = z 0 ?x
0 0
?y x 0
then
T T
R =uu +cos?(I?uu )+sin?S.
Theargumentsto
void Translate{fd}(T x,T y,T z);
T
give the coordinates of a translation vector as (x y z) . The resulting matrix is a
translationbythespeci?edvector:
? ?
1 0 0 x
? ?
0 1 0 y
? ?
.
? ?
0 0 1 z
0 0 0 1
void Scale{fd}(T x,T y,T z);
producesageneralscalingalongthex-, y-,and z-axes. Thecorrespondingmatrix
is
? ?
x 0 0 0
? ?
0 y 0 0
? ?
.
? ?
0 0 z 0
0 0 0 1
For
Version2.1-December1,200646 CHAPTER2. OPENGLOPERATION
void Frustum(double l,double r,double b,double t,
double n,double f);
T T
thecoordinates(lb?n) and(rt?n) specifythepointsonthenearclipping
plane that are mapped to the lower left and upper right corners of the window,
T
respectively (assuming that the eye is located at (0 0 0) ). f gives the distance
fromtheeyetothefarclippingplane. Ifeithernorf islessthanorequaltozero,
l isequaltor,bisequaltot,ornisequaltof,theerrorINVALID VALUEresults.
Thecorrespondingmatrixis
? ?
2n r+l
0 0
r?l r?l
? 2n t+b ?
0 0
? ?
t?b t?b
? ?.
f+n 2fn
? ?
0 0 ? ?
f?n f?n
0 0 ?1 0
void Ortho(double l,double r,double b,double t,
double n,double f);
T T
describes a matrix that produces parallel projection. (l b ?n) and (r t ?n)
specify the points on the near clipping plane that are mapped to the lower left and
upper right corners of the window, respectively. f gives the distance from the eye
to the far clipping plane. If l is equal to r, b is equal to t, or n is equal to f, the
errorINVALID VALUEresults. Thecorrespondingmatrixis
? ?
2 r+l
0 0 ?
r?l r?l
? ?
2 t+b
0 0 ?
? ?
t?b t?b
? ?.
f+n
2
? ?
0 0 ? ?
f?n f?n
0 0 0 1
For each texture coordinate set, a 4?4 matrix is applied to the corresponding
texturecoordinates. Thismatrixisappliedas
? ?? ?
m m m m s
1 5 9 13
? ?? ?
m m m m t
2 6 10 14
? ?? ?
,
? ?? ?
m m m m r
3 7 11 15
m m m m q
4 8 12 16
where the left matrix is the current texture matrix. The matrix is applied to the
coordinatesresultingfromtexturecoordinategeneration(whichmaysimplybethe
currenttexturecoordinates),andtheresultingtransformedcoordinatesbecomethe
texturecoordinatesassociatedwithavertex. SettingthematrixmodetoTEXTURE
causesthealreadydescribedmatrixoperationstoapplytothetexturematrix.
Thecommand
Version2.1-December1,20062.11. COORDINATETRANSFORMATIONS 47
void ActiveTexture(enum texture);
speci?estheactivetextureunitselector,ACTIVE TEXTURE.Eachtextureunitcon-
tains up to two distinct sub-units: a texture coordinate processing unit (consisting
of a texture matrix stack and texture coordinate generation state) and a texture
imageunit(consistingofallthetexturestatede?nedinsection3.8). Inimplemen-
tations with a different number of supported texture coordinate sets and texture
imageunits,sometextureunitsmayconsistofonlyoneofthetwosub-units.
The active texture unit selector speci?es the texture coordinate set accessed
by commands involving texture coordinate processing. Such commands include
those accessing the current matrix stack (if MATRIX MODE is TEXTURE), TexEnv
commands controlling point sprite coordinate replacement (see section 3.3), Tex-
Gen (section 2.11.4), Enable/Disable (if any texture coordinate generation enum
isselected), aswellasqueriesofthecurrenttexturecoordinatesandcurrentraster
texturecoordinates. Ifthetexturecoordinatesetnumbercorrespondingtothecur-
rent value of ACTIVE TEXTURE is greater than or equal to the implementation-
dependent constant MAX TEXTURE COORDS, the error INVALID OPERATION is
generatedbyanysuchcommand.
The active texture unit selector also selects the texture image unit accessed
by commands involving texture image processing (section 3.8). Such commands
include all variants of TexEnv (except for those controlling point sprite coordi-
nate replacement), TexParameter, and TexImage commands, BindTexture, En-
able/Disable for any texture target (e.g., TEXTURE 2D), and queries of all such
state. If the texture image unit number corresponding to the current value of
ACTIVE TEXTURE is greater than or equal to the implementation-dependent con-
stantMAX COMBINED TEXTURE IMAGE UNITS,theerrorINVALID OPERATIONis
generatedbyanysuchcommand.
ActiveTexturegeneratestheerrorINVALID ENUMifaninvalidtextureisspec-
i?ed. texture is a symbolic constant of the form TEXTUREi, indicating that tex-
ture unit i is to be modi?ed. The constants obey TEXTUREi = TEXTURE0 +i (i
is in the range 0 to k? 1, where k is the larger of MAX TEXTURE COORDS and
MAX COMBINED TEXTURE IMAGE UNITS).
For backwards compatibility, the implementation-dependent
constant MAX TEXTURE UNITS speci?es the number of conventional texture units
supportedbytheimplementation. Itsvaluemustbenolargerthantheminimumof
MAX TEXTURE COORDSandMAX COMBINED TEXTURE IMAGE UNITS.
There is a stack of matrices for each of matrix modes MODELVIEW,
PROJECTION, and COLOR, and for each texture unit. For MODELVIEW mode, the
stack depth is at least 32 (that is, there is a stack of at least 32 model-view ma-
trices). For the other modes, the depth is at least 2. Texture matrix stacks for all
Version2.1-December1,200648 CHAPTER2. OPENGLOPERATION
textureunitshavethesamedepth. Thecurrentmatrixinanymodeisthematrixon
thetopofthestackforthatmode.
void PushMatrix(void);
pushesthestackdownbyone,duplicatingthecurrentmatrixinboththetopofthe
stackandtheentrybelowit.
void PopMatrix(void);
pops the top entry off of the stack, replacing the current matrix with the matrix
that was the second entry in the stack. The pushing or popping takes place on the
stackcorrespondingtothecurrentmatrixmode. Poppingamatrixoffastackwith
onlyoneentrygeneratestheerrorSTACK UNDERFLOW;pushingamatrixontoafull
stackgeneratesSTACK OVERFLOW.
When the current matrix mode is TEXTURE, the texture matrix stack of the
activetextureunitispushedorpopped.
The state required to implement transformations consists of an integer for the
active texture unit selector, a four-valued integer indicating the current matrix
mode, one stack of at least two 4?4 matrices for each of COLOR, PROJECTION,
and each texture coordinate set, TEXTURE; and a stack of at least 32 4?4 matri-
ces for MODELVIEW. Each matrix stack has an associated stack pointer. Initially,
there is only one matrix on each stack, and all matrices are set to the identity.
The initial active texture unit selector isTEXTURE0, and the initial matrix mode is
MODELVIEW.
2.11.3 NormalTransformation
Finally, we consider how the model-view matrix and transformation state affect
normals. Before use in lighting, normals are transformed to eye coordinates by a
matrix derived from the model-view matrix. Rescaling and normalization opera-
tions are performed on the transformed normals to make them unit length prior to
useinlighting. Rescalingandnormalizationarecontrolledby
void Enable(enum target);
and
void Disable(enum target);
Version2.1-December1,20062.11. COORDINATETRANSFORMATIONS 49
with target equal to RESCALE NORMAL or NORMALIZE. This requires two bits of
state. Theinitialstateisfornormalsnottoberescaledornormalized.
If the model-view matrix is M, then the normal is transformed to eye coordi-
natesby:
?1
0 0 0 0
(n n n q ) = (n n n q)·M
x y z x y z
? ?
x
? ?
y
? ?
where,if aretheassociatedvertexcoordinates,then
? ?
z
w
?
?
0, w = 0,
?
?
? ?
?
?
x
q = ? ? (2.1)
?
(n n n ) y
x y z
?
?
?
?
z
?
, w =6 0
w
Implementationsmaychooseinsteadtotransform(n n n )toeyecoor-
x y z
dinatesusing
?1
0 0 0
(n n n ) = (n n n )·M
x y z x y z u
whereM istheupperleftmost3x3matrixtakenfromM.
u
Rescalemultipliesthetransformednormalsbyascalefactor
00 00 00 0 0 0
(n n n ) =f (n n n )
x y z x y z
If rescaling is disabled, then f = 1. If rescaling is enabled, then f is computed
?1
as(m denotesthematrixelementinrowiandcolumnj ofM ,numberingthe
ij
topmostrowofthematrixasrow1andtheleftmostcolumnascolumn1)
1
v
f =
2 2 2
m +m +m
31 32 33
NotethatifthenormalssenttoGLwereunitlengthandthemodel-viewmatrix
uniformlyscalesspace,thenrescalemakesthetransformednormalsunitlength.
Alternatively,animplementationmaychoosefas
1
q
f =
2 2 2
0 0 0
n +n +n
x y z
recomputingf foreachnormal. Thismakesallnon-zerolengthnormalsunitlength
regardlessoftheirinputlengthandthenatureofthemodel-viewmatrix.
Version2.1-December1,200650 CHAPTER2. OPENGLOPERATION
Afterrescaling,the?naltransformednormalusedinlighting,n ,iscomputed
f
as
00 00 00
n =m(n n n )
f x y z
Ifnormalizationisdisabled,thenm = 1. Otherwise
1
m = q
2 2 2
00 00 00
n +n +n
x y z
Because we specify neither the ?oating-point format nor the means for matrix
inversion, we cannot specify behavior in the case of a poorly-conditioned (nearly
singular) model-view matrix M. In case of an exactly singular matrix, the trans-
formednormalisunde?ned. IftheGLimplementationdeterminesthatthemodel-
view matrix is uninvertible, then the entries in the inverted matrix are arbitrary. In
any case, neither normal transformation nor use of the transformed normal may
leadtoGLinterruptionortermination.
2.11.4 GeneratingTextureCoordinates
Texture coordinates associated with a vertex may either be taken from the current
texturecoordinatesorgeneratedaccordingtoafunctiondependentonvertexcoor-
dinates. Thecommand
void TexGen{ifd}(enum coord,enum pname,T param);
void TexGen{ifd}v(enum coord,enum pname,T params);
controls texture coordinate generation. coord must be one of the constants S, T,
R, or Q, indicating that the pertinent coordinate is the s, t, r, or q coordinate, re-
spectively. In the ?rst form of the command, param is a symbolic constant speci-
fying a single-valued texture generation parameter; in the second form, params is
a pointer to an array of values that specify texture generation parameters. pname
mustbeoneofthethreesymbolicconstantsTEXTURE GEN MODE,OBJECT PLANE,
or EYE PLANE. If pname is TEXTURE GEN MODE, then either params points to
or param is an integer that is one of the symbolic constants OBJECT LINEAR,
EYE LINEAR,SPHERE MAP,REFLECTION MAP,orNORMAL MAP.
If TEXTURE GEN MODE indicates OBJECT LINEAR, then the generation func-
tionforthecoordinateindicatedby coordis
g =p x +p y +p z +p w .
1 o 2 o 3 o 4 o
x ,y ,z ,andw aretheobjectcoordinatesofthevertex. p ,...,p arespeci?ed
o o o o 1 4
bycallingTexGenwithpnamesettoOBJECT PLANEinwhichcaseparamspoints
Version2.1-December1,20062.11. COORDINATETRANSFORMATIONS 51
to an array containing p ,...,p . There is a distinct group of plane equation co-
1 4
ef?cients for each texture coordinate; coord indicates the coordinate to which the
speci?edcoef?cientspertain.
IfTEXTURE GEN MODEindicatesEYE LINEAR,thenthefunctionis
0 0 0 0
g =p x +p y +p z +p w
e e e e
1 2 3 4
where
?1
0 0 0 0
(p p p p ) = (p p p p )M
1 2 3 4
1 2 3 4
x , y , z , and w are the eye coordinates of the vertex. p ,...,p are set by
e e e e 1 4
calling TexGen with pname set to EYE PLANE in correspondence with setting the
coef?cients in the OBJECT PLANE case. M is the model-view matrix in effect
whenp ,...,p arespeci?ed. Computedtexturecoordinatesmaybeinaccurateor
1 4
unde?nedifM ispoorlyconditionedorsingular.
When used with a suitably constructed texture image, calling TexGen with
TEXTURE GEN MODE indicating SPHERE MAP can simulate the re?ected image of
a spherical environment on a polygon. SPHERE MAP texture coordinates are gen-
erated as follows. Denote the unit vector pointing from the origin to the vertex
(in eye coordinates) byu. Denote the current normal, after transformation to eye
T
coordinates,byn . Letr = (r r r ) ,there?ectionvector,begivenby
f x y z
T
r =u?2n (n u),
f f
q
2
2 2
and let m = 2 r +r +(r +1) . Then the value assigned to an s coordinate
z
x y
1
(the ?rstTexGen argument value isS) iss = r /m+ ; the value assigned to at
x
2
1
coordinate ist = r /m+ . Calling TexGen with a coord of either R or Q when
y
2
pnameindicatesSPHERE MAPgeneratestheerrorINVALID ENUM.
If TEXTURE GEN MODE indicates REFLECTION MAP, compute the re?ection
vectorr as described for the SPHERE MAP mode. Then the value assigned to an
scoordinateiss =r ;thevalueassignedtoatcoordinateist =r ;andthevalue
x y
assigned to an r coordinate is r = r . Calling TexGen with a coord of Q when
z
pnameindicatesREFLECTION MAPgeneratestheerrorINVALID ENUM.
IfTEXTURE GEN MODE indicatesNORMAL MAP, compute the normal vectorn
f
as described in section 2.11.3. Then the value assigned to an s coordinate is s =
n ; the value assigned to at coordinate ist = n ; and the value assigned to an
f f
x y
r coordinateisr = n (thevaluesn ,n ,andn arethecomponentsofn .)
f f f f f
z x y z
Calling TexGen with a coord of Q when pname indicates NORMAL MAP generates
theerrorINVALID ENUM.
A texture coordinate generation function is enabled or disabled using En-
able and Disable with an argument of TEXTURE GEN S, TEXTURE GEN T,
Version2.1-December1,200652 CHAPTER2. OPENGLOPERATION
TEXTURE GEN R,orTEXTURE GEN Q(eachindicatesthecorrespondingtextureco-
ordinate). When enabled, the speci?ed texture coordinate is computed according
to the current EYE LINEAR, OBJECT LINEAR or SPHERE MAP speci?cation, de-
pending on the current setting of TEXTURE GEN MODE for that coordinate. When
disabled, subsequent vertices will take the indicated texture coordinate from the
currenttexturecoordinates.
Thestaterequiredfortexturecoordinategenerationforeachtextureunitcom-
prises a ?ve-valued integer for each coordinate indicating coordinate generation
mode,andabitforeachcoordinatetoindicatewhethertexturecoordinategenera-
tion is enabled or disabled. In addition, four coef?cients are required for the four
coordinatesforeachofEYE LINEARandOBJECT LINEAR.Theinitialstatehasthe
texture generation function disabled for all texture coordinates. The initial values
ofp forsareall0exceptp whichisone;fortallthep arezeroexceptp ,which
i 1 i 2
is 1. The values of p for r and q are all 0. These values of p apply for both the
i i
EYE LINEARandOBJECT LINEARversions. Initiallyalltexturegenerationmodes
areEYE LINEAR.
2.12 Clipping
Primitives are clipped to the clip volume. In clip coordinates, the view volume is
de?nedby
?w ?x ?w
c c c
?w ?y ?w
c c c
?w ?z ?w .
c c c
This view volume may be further restricted by as many as n client-de?ned clip
planes to generate the clip volume. (n is an implementation dependent maximum
that must be at least 6.) Each client-de?ned plane speci?es a half-space. The clip
volumeistheintersectionofallsuchhalf-spaceswiththeviewvolume(ifthereno
client-de?nedclipplanesareenabled,theclipvolumeistheviewvolume).
Aclient-de?nedclipplaneisspeci?edwith
void ClipPlane(enum p,double eqn[4]);
Thevalueofthe?rstargument,p,isasymbolicconstant,CLIP PLANEi,whereiis
anintegerbetween0andn?1,indicatingoneofnclient-de?nedclipplanes. eqn
isanarrayoffourdouble-precision?oating-pointvalues. Thesearethecoef?cients
of a plane equation in object coordinates: p , p , p , and p (in that order). The
1 2 3 4
inverseofthecurrentmodel-viewmatrixisappliedtothesecoef?cients,atthetime
theyarespeci?ed,yielding
?1
0 0 0 0
(p p p p ) = (p p p p )M
1 2 3 4
1 2 3 4
Version2.1-December1,20062.12. CLIPPING 53
(whereM is the current model-view matrix; the resulting plane equation is unde-
?nedifM issingularandmaybeinaccurateifM ispoorly-conditioned)toobtain
the plane equation coef?cients in eyecoordinates. All points with eye coordinates
T
(x y z w ) thatsatisfy
e e e e
? ?
x
e
? ?
y
e
0 0 0 0
? ?
(p p p p ) ? 0
1 2 3 4
? ?
z
e
w
e
lie in the half-space de?ned by the plane; points that do not satisfy this condition
donotlieinthehalf-space.
T
When a vertex shader is active, the vector (x y z w ) is no longer
e e e e
computed. Instead,thevalueofthegl ClipVertexbuilt-invariableisusedinits
place. Ifgl ClipVertexisnotwrittenbythevertexshader,itsvalueisunde?ned,
which implies that the results of clipping to any client-de?ned clip planes are also
unde?ned. Theusermust ensurethattheclip vertexandclient-de?ned clipplanes
arede?nedinthesamecoordinatespace.
Client-de?ned clip planes are enabled with the generic Enable command and
disabled with the Disable command. The value of the argument to either com-
mand is CLIP PLANEi where i is an integer between 0 and n; specifying a value
of i enables or disables the plane equation with index i. The constants obey
CLIP PLANEi = CLIP PLANE0+i.
If the primitive under consideration is a point, then clipping passes it un-
changed if it lies within the clip volume; otherwise, it is discarded. If the prim-
itive is a line segment, then clipping does nothing to it if it lies entirely within the
clip volume and discards it if it lies entirely outside the volume. If part of the line
segment lies in the volume and part lies outside, then the line segment is clipped
and new vertex coordinates are computed for one or both vertices. A clipped line
segment endpoint lies on both the original line segment and the boundary of the
clipvolume.
This clipping produces a value, 0? t? 1, for each clipped vertex. If the
coordinatesofaclippedvertexarePandtheoriginalvertices’coordinatesareP
1
andP ,thentisgivenby
2
P =tP +(1?t)P .
1 2
The value oft is used in color, secondary color, texture coordinate, and fog coor-
dinateclipping(section2.14.8).
If the primitive is a polygon, then it is passed if every one of its edges lies
entirelyinsidetheclipvolumeandeitherclippedordiscardedotherwise. Polygon
Version2.1-December1,200654 CHAPTER2. OPENGLOPERATION
clippingmaycausepolygonedgestobeclipped,butbecausepolygonconnectivity
mustbemaintained,theseclippededgesareconnectedbynewedgesthatliealong
the clip volume’s boundary. Thus, clipping may require the introduction of new
verticesintoapolygon. Edge?agsareassociatedwiththeseverticessothatedges
introducedbyclippingare?aggedasboundary(edge?agTRUE),andsothatorig-
inal edges of the polygon that become cut off at these vertices retain their original
?ags.
If it happens that a polygon intersects an edge of the clip volume’s boundary,
then the clipped polygon must include a point on this boundary edge. This point
mustlieintheintersectionoftheboundaryedgeandtheconvexhullofthevertices
oftheoriginalpolygon. Weimposethisrequirementbecausethepolygonmaynot
beexactlyplanar.
Primitives rendered with clip planes must satisfy a complementarity crite-
0 0 0 0
rion. Suppose a single clip plane with coef?cients (p p p p ) (or a num-
1 2 3 4
ber of similarly speci?ed clip planes) is enabled and a series of primitives are
drawn. Next, suppose that the original clip plane is respeci?ed with coef?cients
0 0 0 0
(?p ?p ?p ?p ) (and correspondingly for any other clip planes) and
1 2 3 4
the primitives are drawn again (and the GL is otherwise in the same state). In this
case,primitivesmustnotbemissinganypixels,normayanypixelsbedrawntwice
inregionswherethoseprimitivesarecutbytheclipplanes.
Thestaterequiredforclippingisatleast6setsofplaneequations(eachconsist-
ing of four double-precision ?oating-point coef?cients) and at least 6 correspond-
ingbitsindicatingwhichoftheseclient-de?nedplaneequationsareenabled. Inthe
initialstate,allclient-de?nedplaneequationcoef?cientsarezeroandallplanesare
disabled.
2.13 CurrentRasterPosition
The current raster position is used by commands that directly affect pixels in the
framebuffer. These commands, which bypass vertex transformation and primitive
assembly, are described in the next chapter. The current raster position, however,
sharessomeofthecharacteristicsofavertex.
Thecurrentrasterpositionissetusingoneofthecommands
void RasterPos{234}{sifd}(T coords);
void RasterPos{234}{sifd}v(T coords);
RasterPos4 takes four values indicating x, y, z, and w. RasterPos3 (or Raster-
Pos2) is analogous, but sets onlyx, y, andz withw implicitly set to 1 (or onlyx
andy withz implicitlysetto0andw implicitlysetto1).
Version2.1-December1,20062.13. CURRENTRASTERPOSITION 55
GetsofCURRENT RASTER TEXTURE COORDSareaffectedbythesettingofthe
stateACTIVE TEXTURE.
The coordinates are treated as if they were speci?ed in a Vertex command. If
a vertex shader is active, this vertex shader is executed using the x, y, z, and w
coordinates as the object coordinates of the vertex. Otherwise, the x, y, z, and
w coordinates are transformed by the current model-view and projection matri-
ces. These coordinates, along with current values, are used to generate primary
and secondary colors and texture coordinates just as is done for a vertex. The col-
orsandtexturecoordinatessoproducedreplacethecolorsandtexturecoordinates
stored in the current raster position’s associated data. If a vertex shader is active
then the current raster distance is set to the value of the shader built in varying
gl FogFragCoord. Otherwise, if the value of the fog source (see section 3.10)
is FOG COORD, then the current raster distance is set to the value of the current
fog coordinate. Otherwise, the current raster distance is set to the distance from
the origin of the eye coordinate system to the vertex as transformed by only the
current model-view matrix. This distance may be approximated as discussed in
section3.10.
Since vertex shaders may be executed when the raster position is set, any at-
tributesnotwrittenbytheshaderwillresultinunde?nedstateinthecurrentraster
position. Vertex shaders should output all varying variables that would be used
whenrasterizingpixelprimitivesusingthecurrentrasterposition.
The transformed coordinates are passed to clipping as if they represented a
point. If the “point” is not culled, then the projection to window coordinates is
computed (section 2.11) and saved as the current raster position, and the valid
bit is set. If the “point” is culled, the current raster position and its associated
data become indeterminate and the valid bit is cleared. Figure 2.7 summarizes the
behaviorofthecurrentrasterposition.
Alternately, the current raster position may be set by one of the WindowPos
commands:
void WindowPos{23}{ifds}(T coords);
void WindowPos{23}{ifds}v(const T coords );
WindowPos3 takes three values indicating x, y and z, while WindowPos2
takes two values indicating x and y with z implicitly set to 0. The current raster
position,(x ,y ,z ,w ),isde?nedby:
w w w c
x =x
w
y =y
w
Version2.1-December1,200656 CHAPTER2. OPENGLOPERATION
Valid
Rasterpos In
Clip Project
Raster
Position
Vertex/Normal
Current
Transformation
Normal
Raster
Distance
Current
Lighting
Color & 
Materials
Associated
Texture
Data
Texgen
Current Matrix 0
Texture
Current
Coord Set 0
Raster
Position
Texture
Texgen
Matrix 1
Current
Texture
Coord Set 1
Texture
Texgen
Current Matrix 2
Texture
Coord Set 2
Texture
Texgen
Current Matrix 3
Texture
Coord Set 3
Figure 2.7. The current raster position and how it is set. Four texture units are
shown;however,multitexturingmaysupportadifferentnumberofunitsdepending
ontheimplementation.
Version2.1-December1,20062.14. COLORSANDCOLORING 57
?
?
n, z? 0
?
z = f, z? 1
w
?
?
n+z(f?n), otherwise
w = 1
c
wherenandf arethevaluespassedtoDepthRange(seesection2.11.1).
Lighting, texture coordinate generation and transformation, and clipping are
not performed by theWindowPos functions. Instead, in RGBA mode, the current
raster color and secondary color are obtained by clamping each component of the
current color and secondary color, respectively, to [0,1]. In color index mode, the
currentrastercolorindexissettothecurrentcolorindex. Thecurrentrastertexture
coordinatesaresettothecurrenttexturecoordinates,andthevalidbitisset.
If the value of the fog source is FOG COORD SRC, then the current raster dis-
tanceissettothevalueofthecurrentfogcoordinate. Otherwise,therasterdistance
issetto0.
The current raster position requires six single-precision ?oating-point values
foritsx ,y ,andz windowcoordinates,itsw clipcoordinate,itsrasterdistance
w w w c
(used as the fog coordinate in raster processing), a single valid bit, four ?oating-
pointvaluestostorethecurrentRGBAcolor,four?oating-pointvaluestostorethe
current RGBA secondary color, one ?oating-point value to store the current color
index, and 4 ?oating-point values for texture coordinates for each texture unit. In
the initial state, the coordinates and texture coordinates are all (0,0,0,1), the eye
coordinate distance is 0, the fog coordinate is 0, the valid bit is set, the associated
RGBAcoloris(1,1,1,1),theassociatedRGBAsecondarycoloris(0,0,0,1),and
the associated color index color is 1. In RGBA mode, the associated color index
always has its initial value; in color index mode, the RGBA color and secondary
coloralwaysmaintaintheirinitialvalues.
2.14 ColorsandColoring
Figures 2.8 and 2.9 diagram the processing of RGBA colors and color indices be-
forerasterization. Incomingcolorsarriveinoneofseveralformats. Table2.9sum-
marizes the conversions that take place on R, G, B, and A components depending
on which version of the Color command was invoked to specify the components.
As a result of limited precision, some converted values will not be represented
exactly. Incolorindexmode,asingle-valuedcolorindexisnotmapped.
Version2.1-December1,200658 CHAPTER2. OPENGLOPERATION
Convert to
k
[0,2 ?1]
[0.0,1.0]
Current
Clamp to
RGBA
[0.0, 1.0]
Color Lighting
Convert to
k k
[?2 ,2 ?1]
[?1.0,1.0]
float
Color
Clipping
Flatshade?
Convert to
fixed?point
Primitive
Clipping
Figure 2.8. Processing of RGBA colors. The heavy dotted lines indicate both pri-
mary and secondary vertex colors, which are processed in the same fashion. See
table2.9fortheinterpretationofk.
Convert to
n
[0,2 ?1]
Current
float
Mask to
Color
float
n
Index Lighting
[0.0, 2 ?1]
Color
Clipping
Flatshade?
Convert to
fixed?point
Primitive
Clipping
Figure2.9. Processingofcolorindices. nisthenumberofbitsinacolorindex.
Version2.1-December1,20062.14. COLORSANDCOLORING 59
GLType Conversion
8
ubyte c/(2 ?1)
8
byte (2c+1)/(2 ?1)
16
ushort c/(2 ?1)
16
short (2c+1)/(2 ?1)
32
uint c/(2 ?1)
32
int (2c+1)/(2 ?1)
?oat c
double c
Table 2.9: Component conversions. Color, normal, and depth components, (c),
are converted to an internal ?oating-point representation, ( f), using the equations
in this table. All arithmetic is done in the internal ?oating point format. These
conversions apply to components speci?edas parameters to GL commands and to
componentsinpixeldata. Theequationsremainthesameeveniftheimplemented
ranges of the GL data types are greater than the minimum required ranges. (Refer
totable2.2)
Next, lighting, if enabled, produces either a color index or primary and sec-
ondary colors. If lighting is disabled, the current color index or current color
(primary color) and current secondary color are used in further processing. After
lighting, RGBA colors are clamped to the range [0,1]. A color index is converted
to ?xed-point and then its integer portion is masked (see section 2.14.6). After
clamping or masking, a primitive may be ?atshaded, indicating that all vertices of
the primitive are to have the same colors. Finally, if a primitive is clipped, then
colors (and texture coordinates) must be computed at the vertices introduced or
modi?edbyclipping.
2.14.1 Lighting
GL lighting computes colors for each vertex sent to the GL. This is accomplished
byapplyinganequationde?nedbyaclient-speci?edlightingmodeltoacollection
of parameters that can include the vertex coordinates, the coordinates of one or
morelightsources,thecurrentnormal,andparametersde?ningthecharacteristics
of the light sources and a current material. The following discussion assumes that
theGLisinRGBAmode. (Colorindexlightingisdescribedinsection2.14.5.)
Lighting is turned on or off using the generic Enable or Disable commands
withthesymbolicvalueLIGHTING.Iflightingisoff,thecurrentcolorandcurrent
Version2.1-December1,200660 CHAPTER2. OPENGLOPERATION
secondary color are assigned to the vertex primary and secondary color, respec-
tively. If lighting is on, colors computed from the current lighting parameters are
assignedtothevertexprimaryandsecondarycolors.
LightingOperation
A lighting parameter is of one of ?ve types: color, position, direction, real, or
boolean. A color parameter consists of four ?oating-point values, one for each of
R, G, B, and A, in that order. There are no restrictions on the allowable values for
these parameters. A position parameter consists of four ?oating-point coordinates
(x, y, z, and w) that specify a position in object coordinates (w may be zero,
indicating a point at in?nity in the direction given by x, y, and z). A direction
parameter consists of three ?oating-point coordinates ( x, y, and z) that specify a
direction in object coordinates. A real parameter is one ?oating-point value. The
variousvaluesandtheirtypesaresummarizedintable2.10. Theresultofalighting
computation is unde?ned if a value for a parameter is speci?ed that is outside the
rangegivenforthatparameterinthetable.
Therearenlightsources,indexedbyi = 0,...,n?1. (nisanimplementation
dependent maximum that must be at least 8.) Note that the default values ford
cli
ands differfori = 0andi> 0.
cli
Before specifying the way that lighting computes colors, we introduce oper-
ators and notation that simplify the expressions involved. If c and c are col-
1 2
ors without alpha where c = (r ,g ,b ) and c = (r ,g ,b ), then de?ne
1 1 1 1 2 2 2 2
c ?c = (r r ,g g ,b b ). Addition of colors is accomplished by addition of
1 2 1 2 1 2 1 2
thecomponents. Multiplicationofcolorsbyascalarmeansmultiplyingeachcom-
ponentbythatscalar. Ifd andd aredirections,thende?ne
1 2
d d = max{d ·d ,0}.
1 2 1 2
(Directions are taken to have three coordinates.) IfP andP are (homogeneous,
1 2
???>
withfourcoordinates)pointsthenletP P betheunitvectorthatpointsfromP
1 2 1
toP . NotethatifP hasazerow coordinateandP hasnon-zero w coordinate,
2 2 1
???>
thenP P is the unit vector corresponding to the direction speci?ed by the x, y,
1 2
and z coordinates ofP ; ifP has a zero w coordinate andP has a non-zero w
2 1 2
???>
coordinate thenP P is the unit vector that is the negative of that corresponding
1 2
to the direction speci?ed byP . If bothP andP have zerow coordinates, then
1 1 2
???>
P P is the unit vector obtained by normalizing the direction corresponding to
1 2
P ?P .
2 1
?
Ifd is an arbitrary direction, then letd be the unit vector ind’s direction. Let
kP Pk be the distance between P and P . Finally, let V be the point corre-
1 2 1 2
Version2.1-December1,20062.14. COLORSANDCOLORING 61
Parameter Type DefaultValue Description
MaterialParameters
a color (0.2,0.2,0.2,1.0) ambientcolorofmaterial
cm
d color (0.8,0.8,0.8,1.0) diffusecolorofmaterial
cm
s color (0.0,0.0,0.0,1.0) specularcolorofmaterial
cm
e color (0.0,0.0,0.0,1.0) emissivecolorofmaterial
cm
s real 0.0 specular exponent (range:
rm
[0.0,128.0])
a real 0.0 ambientcolorindex
m
d real 1.0 diffusecolorindex
m
s real 1.0 specularcolorindex
m
LightSourceParameters
a color (0.0,0.0,0.0,1.0) ambientintensityoflighti
cli
d (i = 0) color (1.0,1.0,1.0,1.0) diffuseintensityoflight0
cli
d (i> 0) color (0.0,0.0,0.0,1.0) diffuseintensityoflighti
cli
s (i = 0) color (1.0,1.0,1.0,1.0) specularintensityoflight0
cli
s (i> 0) color (0.0,0.0,0.0,1.0) specularintensityoflighti
cli
P position (0.0,0.0,1.0,0.0) positionoflighti
pli
s direction (0.0,0.0,?1.0) directionofspotlightforlighti
dli
s real 0.0 spotlight exponent for light i
rli
(range: [0.0,128.0])
c real 180.0 spotlightcutoffangleforlighti
rli
(range: [0.0,90.0],180.0)
k real 1.0 constant attenuation factor for
0i
lighti(range: [0.0,?))
k real 0.0 linear attenuation factor for
1i
lighti(range: [0.0,?))
k real 0.0 quadratic attenuation factor for
2i
lighti(range: [0.0,?))
LightingModelParameters
a color (0.2,0.2,0.2,1.0) ambientcolorofscene
cs
v boolean FALSE viewer assumed to be at
bs
(0,0,0) in eye coordinates
(TRUE)or(0,0,?)(FALSE)
c enum SINGLE COLOR controlscomputationofcolors
es
t boolean FALSE usetwo-sidedlightingmode
bs
Table 2.10: Summary of lighting parameters. The range of individual color com-
ponentsis(??,+?).
Version2.1-December1,200662 CHAPTER2. OPENGLOPERATION
spondingtothevertexbeinglit,andnbethecorrespondingnormal. LetP bethe
e
eyepoint((0,0,0,1)ineyecoordinates).
Lightingproducestwocolorsatavertex: aprimarycolorc andasecondary
pri
colorc . Thevaluesofc andc dependonthelightmodelcolorcontrol,c .
sec pri sec es
Ifc = SINGLE COLOR,thentheequationstocomputec andc are
es pri sec
c = e
pri cm
+ a ?a
cm cs
n?1
X
+ (att )(spot )[a ?a
i i cm cli
??>
i=0
+ (nVP )d ?d
pli cm cli
s
? rm
+ (f )(nh ) s ?s ]
i i cm cli
c = (0,0,0,1)
sec
Ifc = SEPARATE SPECULAR COLOR,then
es
c = e
pri cm
+ a ?a
cm cs
n?1
X
+ (att )(spot )[a ?a
i i cm cli
??>
i=0
+ (nVP )d ?d ]
pli cm cli
n?1
X
s
? rm
c = (att )(spot )(f )(nh ) s ?s
sec i i i i cm cli
i=0
where
(
??>
1, nVP 6= 0,
pli
f = (2.2)
i
0, otherwise,
(
??> ??>
VP +VP, v = TRUE,
pli e bs
h = (2.3)
??>
i
T
VP +(0 0 1) , v = FALSE,
pli bs
?
1
?
, ifP ’sw =6 0,
?
pli
2
k + k kVP k + k kVP k
0i 1i pli 2i pli
att = (2.4)
i
?
?
1.0, otherwise.
Version2.1-December1,20062.14. COLORSANDCOLORING 63
?
???> ???>
s
rli
?
(P V?s ) , c 6= 180.0,P V?s ? cos(c ),
? pli dli rli pli dli rli
???>
spot = (2.5)
0.0, c 6= 180.0,P V?s < cos(c ),
i
rli pli dli rli
?
?
1.0, c = 180.0.
rli
Allcomputationsarecarriedoutineyecoordinates.
The value of A produced by lighting is the alpha value associated withd .
cm
Aisalwaysassociatedwiththeprimarycolorc ;thealphacomponentofc is
pri sec
always1.
Resultsoflightingareunde?nedifthew coordinate(w ineyecoordinates)of
e
V iszero.
Lighting may operate in two-sided mode (t = TRUE), in which a front color
bs
is computed with one set of material parameters (the front material) and a back
color is computed with a second set of material parameters (the back material).
Thissecondcomputationreplacesnwith?n. Ift = FALSE,thenthebackcolor
bs
andfrontcolorarebothassignedthecolorcomputedusingthefrontmaterialwith
n.
Additionally,vertexshaderscanoperateintwo-sidedcolormode. Whenaver-
texshaderisactive,frontandbackcolorscanbecomputedbythevertexshaderand
written to the gl FrontColor, gl BackColor, gl FrontSecondaryColor
and gl BackSecondaryColor outputs. If VERTEX PROGRAM TWO SIDE is en-
abled, the GL chooses between front and back colors, as described below. Oth-
erwise, the front color output is always selected. Two-sided color mode is
enabled and disabled by calling Enable or Disable with the symbolic value
VERTEX PROGRAM TWO SIDE.
Theselectionbetweenbackandfrontcolorsdependsontheprimitiveofwhich
the vertex being lit is a part. If the primitive is a point or a line segment, the front
colorisalwaysselected. Ifitisapolygon,thentheselectionisbasedonthesignof
the(clippedorunclipped)polygon’ssignedareacomputedinwindowcoordinates.
Onewaytocomputethisareais
n?1
X
1
i i?1 i?1 i
a = x y ?x y (2.6)
w w w w
2
i=0
i i
where x and y are the x and y window coordinates of the ith vertex of the
w w
n-vertexpolygon(verticesarenumberedstartingatzeroforpurposesofthiscom-
putation)andi?1is(i+1) modn. Theinterpretationofthesignofthisvalueis
controlledwith
void FrontFace(enum dir);
SettingdirtoCCW(correspondingtocounter-clockwiseorientationoftheprojected
polygon in window coordinates) indicates that if a? 0, then the color of each
Version2.1-December1,200664 CHAPTER2. OPENGLOPERATION
vertex of the polygon becomes the back color computed for that vertex while if
a > 0,thenthefrontcolorisselected. If dirisCW,thenaisreplacedby?ainthe
aboveinequalities. Thisrequiresonebitofstate;initially,itindicatesCCW.
2.14.2 LightingParameterSpecification
Lighting parameters are divided into three categories: material parameters, light
sourceparameters,andlightingmodelparameters(seetable2.10). Setsoflighting
parametersarespeci?edwith
void Material{if}(enum face,enum pname,T param);
void Material{if}v(enum face,enum pname,T params);
void Light{if}(enum light,enum pname,T param);
void Light{if}v(enum light,enum pname,T params);
void LightModel{if}(enum pname,T param);
void LightModel{if}v(enum pname,T params);
pname is a symbolic constant indicating which parameter is to be set (see ta-
ble 2.11). In the vector versions of the commands, params is a pointer to a group
ofvaluestowhichtosettheindicatedparameter. Thenumberofvaluespointedto
dependsontheparameterbeingset. Inthenon-vectorversions, paramisavalueto
whichtosetasingle-valuedparameter. (If paramcorrespondstoamulti-valuedpa-
rameter, the errorINVALID ENUM results.) For theMaterial command, face must
beoneofFRONT,BACK,orFRONT AND BACK,indicatingthatthepropertynameof
thefrontorbackmaterial,orboth,respectively,shouldbeset. InthecaseofLight,
light is a symbolic constant of the form LIGHTi, indicating that light i is to have
thespeci?edparameterset. TheconstantsobeyLIGHTi = LIGHT0+i.
Table 2.11 gives, for each of the three parameter groups, the correspondence
betweenthepre-de?nedconstantnamesandtheirnamesinthelightingequations,
along with the number of values that must be speci?ed with each. Color param-
eters speci?ed with Material and Light are converted to ?oating-point values
(if speci?ed as integers) as indicated in table 2.9 for signed integers. The error
INVALID VALUEoccursifaspeci?edlightingparameterliesoutsidetheallowable
rangegivenintable2.10. (Thesymbol“?”indicatesthemaximumrepresentable
magnitudefortheindicatedtype.)
Material properties can be changed inside a Begin/End pair by calling Ma-
terial. However, when a vertex shader is active such property changes are not
guaranteedtoupdatematerialparameters,de?nedintable2.11,untilthefollowing
Endcommand.
Version2.1-December1,20062.14. COLORSANDCOLORING 65
Parameter Name Numberofvalues
MaterialParameters(Material)
a AMBIENT 4
cm
d DIFFUSE 4
cm
a ,d AMBIENT AND DIFFUSE 4
cm cm
s SPECULAR 4
cm
e EMISSION 4
cm
s SHININESS 1
rm
a ,d ,s COLOR INDEXES 3
m m m
LightSourceParameters(Light)
a AMBIENT 4
cli
d DIFFUSE 4
cli
s SPECULAR 4
cli
P POSITION 4
pli
s SPOT DIRECTION 3
dli
s SPOT EXPONENT 1
rli
c SPOT CUTOFF 1
rli
k CONSTANT ATTENUATION 1
0
k LINEAR ATTENUATION 1
1
k QUADRATIC ATTENUATION 1
2
LightingModelParameters(LightModel)
a LIGHT MODEL AMBIENT 4
cs
v LIGHT MODEL LOCAL VIEWER 1
bs
t LIGHT MODEL TWO SIDE 1
bs
c LIGHT MODEL COLOR CONTROL 1
es
Table 2.11: Correspondence of lighting parameter symbols to names.
AMBIENT AND DIFFUSEisusedtoseta andd tothesamevalue.
cm cm
Version2.1-December1,200666 CHAPTER2. OPENGLOPERATION
The current model-view matrix is applied to the position parameter indicated
with Light for a particular light source when that position is speci?ed. These
transformedvaluesarethevaluesusedinthelightingequation.
Thespotlightdirectionistransformedwhenitisspeci?edusingonlytheupper
leftmost3x3portionofthemodel-viewmatrix. Thatis,if M istheupperleft3x3
u
matrixtakenfromthecurrentmodel-viewmatrix M,thenthespotlightdirection
? ?
d
x
? ?
d
y
d
z
istransformedto
? ? ? ?
0
d d
x
x
0
? ? ? ?
d =M d .
u y
y
0
d d
z
z
AnindividuallightisenabledordisabledbycallingEnableorDisablewiththe
symbolicvalueLIGHTi(iisintherange0ton?1,wherenistheimplementation-
dependent number of lights). If light i is disabled, the ith term in the lighting
equationiseffectivelyremovedfromthesummation.
2.14.3 ColorMaterial
It is possible to attach one or more material properties to the current color, so
that they continuously track its component values. This behavior is enabled and
disabledbycallingEnableorDisablewiththesymbolicvalueCOLOR MATERIAL.
Thecommandthatcontrolswhichofthesemodesisselectedis
void ColorMaterial(enum face,enum mode);
face is one of FRONT, BACK, or FRONT AND BACK, indicating whether the front
material, back material, or both are affected by the current color. mode is one
of EMISSION, AMBIENT, DIFFUSE, SPECULAR, or AMBIENT AND DIFFUSE and
speci?es which material property or properties track the current color. If mode is
EMISSION,AMBIENT,DIFFUSE,orSPECULAR,thenthevalueofe ,a ,d or
cm cm cm
s ,respectively,willtrackthecurrentcolor. If modeisAMBIENT AND DIFFUSE,
cm
botha andd trackthecurrentcolor. Thereplacementsmadetomaterialprop-
cm cm
ertiesarepermanent;thereplacedvaluesremainuntilchangedbyeithersendinga
newcolororbysettinganewmaterialvaluewhenColorMaterialisnotcurrently
enabled to override that particular value. When COLOR MATERIAL is enabled, the
indicated parameter or parameters always track the current color. For instance,
calling
Version2.1-December1,20062.14. COLORSANDCOLORING 67
Current
Color*() To subsequent vertex operations
Color
Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
and ColorMaterial mode is AMBIENT or AMBIENT_AND_DIFFUSE,
and ColorMaterial is enabled. Down otherwise.
Front Ambient
To lighting equations
Color
Material*(FRONT,AMBIENT)
Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
and ColorMaterial mode is DIFFUSE or AMBIENT_AND_DIFFUSE,
and ColorMaterial is enabled. Down otherwise.
Front Diffuse
To lighting equations
Color
Material*(FRONT,DIFFUSE)
Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
and ColorMaterial mode is SPECULAR, and ColorMaterial is
enabled. Down otherwise.
Front Specular
To lighting equations
Color
Material*(FRONT,SPECULAR)
Up while ColorMaterial face is FRONT or FRONT_AND_BACK,
and ColorMaterial mode is EMISSION, and ColorMaterial is
enabled. Down otherwise.
Front Emission
To lighting equations
Color
Material*(FRONT,EMISSION)
State values flow along this path only when a command is issued
State values flow continuously along this path
Figure 2.10. ColorMaterial operation. Material properties are continuously up-
dated from the current color while ColorMaterial is enabled and has the appro-
priate mode. Only the front material properties are included in this ?gure. The
back material properties are treated identically, except that face must be BACK or
FRONT AND BACK.
Version2.1-December1,200668 CHAPTER2. OPENGLOPERATION
ColorMaterial(FRONT,AMBIENT)
while COLOR MATERIAL is enabled sets the front materiala to the value of the
cm
currentcolor.
Material properties can be changed inside a Begin/End pair indirectly by en-
abling ColorMaterial mode and making Color calls. However, when a vertex
shader is active such property changes are not guaranteed to update material pa-
rameters,de?nedintable2.11,untilthefollowingEndcommand.
2.14.4 LightingState
The state required for lighting consists of all of the lighting parameters (front
and back material parameters, lighting model parameters, and at least 8 sets of
light parameters), a bit indicating whether a back color distinct from the front
color should be computed, at least 8 bits to indicate which lights are enabled,
a ?ve-valued variable indicating the current ColorMaterial mode, a bit indicat-
ing whether or not COLOR MATERIAL is enabled, and a single bit to indicate
whether lighting is enabled or disabled. In the initial state, all lighting parame-
ters have their default values. Back color evaluation does not take place, Color-
MaterialisFRONT AND BACKandAMBIENT AND DIFFUSE,andbothlightingand
COLOR MATERIALaredisabled.
2.14.5 ColorIndexLighting
A simpli?ed lighting computation applies in color index mode that uses many of
theparameterscontrollingRGBAlighting,butnoneoftheRGBAmaterialparam-
eters. First, the RGBA diffuse and specular intensities of light i (d and s ,
cli cli
respectively) determine color index diffuse and specular light intensities, d and
li
s from
li
d = (.30)R(d )+(.59)G(d )+(.11)B(d )
li cli cli cli
and
s = (.30)R(s )+(.59)G(s )+(.11)B(s ).
li cli cli cli
R(x)indicatestheRcomponentofthecolorxandsimilarlyforG(x)andB(x).
Next,let
n
X
s
? rm
s = (att )(spot )(s )(f )(nh )
i i li i i
i=0
where att and spot are given by equations 2.4 and 2.5, respectively, and f and
i i i
0
?
h are given by equations 2.2 and 2.3, respectively. Let s = min{s,1}. Finally,
i
Version2.1-December1,20062.14. COLORSANDCOLORING 69
let
n
X
??>
d = (att )(spot )(d )(nVP ).
i i li pli
i=0
Thencolorindexlightingproducesavaluec,givenby
0 0
c =a +d(1?s)(d ?a )+s(s ?a ).
m m m m m
The?nalcolorindexis
0
c = min{c,s }.
m
Thevaluesa ,d ands arematerialpropertiesdescribedintables2.10and2.11.
m m m
Any ambient light intensities are incorporated into a . As with RGBA lighting,
m
disabled lights cause the corresponding terms from the summations to be omitted.
The interpretation oft and the calculation of front and back colors is carried out
bs
ashasalreadybeendescribedforRGBAlighting.
The values a , d , and s are set with Material using a pname of
m m m
COLOR INDEXES. Their initial values are 0, 1, and 1, respectively. The additional
stateconsistsofthree?oating-pointvalues. ThesevalueshavenoeffectonRGBA
lighting.
2.14.6 ClampingorMasking
After lighting (whether enabled or not), all components of both primary and sec-
ondarycolorsareclampedtotherange[0,1].
Foracolorindex,theindexis?rstconvertedto?xed-pointwithanunspeci?ed
number of bits to the right of the binary point; the nearest ?xed-point value is
selected. Then, the bits to the right of the binary point are left alone while the
n
integerportionismasked(bitwiseANDed)with2 ?1,wherenisthenumberof
bitsinacolorinthecolorindexbuffer(buffersarediscussedinchapter4).
2.14.7 Flatshading
A primitive may be ?atshaded, meaning that all vertices of the primitive are as-
signed the same color index or the same primary and secondary colors. These
colors are the colors of the vertex that spawned the primitive. For a point, these
are the colors associated with the point. For a line segment, they are the colors of
thesecond(?nal)vertexofthesegment. Forapolygon,theycomefromaselected
vertex depending on how the polygon was generated. Table 2.12 summarizes the
possibilities.
Flatshadingiscontrolledby
Version2.1-December1,200670 CHAPTER2. OPENGLOPERATION
Primitivetypeofpolygoni Vertex
singlepolygon(i? 1) 1
trianglestrip i+2
trianglefan i+2
independenttriangle 3i
quadstrip 2i+2
independentquad 4i
Table 2.12: Polygon ?atshading color selection. The colors used for ?atshading
the ith polygon generated by the indicated Begin/End type are derived from the
currentcolor(iflightingisdisabled)ineffectwhentheindicatedvertexisspeci?ed.
If lighting is enabled, the colors are produced by lighting the indicated vertex.
Verticesarenumbered1throughn,wherenisthenumberofverticesbetweenthe
Begin/Endpair.
void ShadeModel(enum mode);
mode value must be either of the symbolic constants SMOOTH or FLAT. If mode is
SMOOTH (the initial state), vertex colors are treated individually. If mode is FLAT,
?atshadingisturnedon. ShadeModelthusrequiresonebitofstate.
2.14.8 ColorandAssociatedDataClipping
After lighting, clamping or masking and possible ?atshading, colors are clipped.
Thosecolorsassociatedwithavertexthatlieswithintheclipvolumeareunaffected
by clipping. If a primitive is clipped, however, the colors assigned to vertices
producedbyclippingareclippedcolors.
LetthecolorsassignedtothetwoverticesP andP ofanunclippededgebe
1 2
c andc . Thevalueoft(section2.12)foraclippedpointPisusedtoobtainthe
1 2
colorassociatedwithPas
c =tc +(1?t)c .
1 2
(For a color index color, multiplying a color by a scalar means multiplying the
indexbythescalar. ForanRGBAcolor,itmeansmultiplyingeachofR,G,B,and
Abythescalar. Bothprimaryandsecondarycolorsaretreatedinthesamefashion.)
Polygon clipping may create a clipped vertex along an edge of the clip volume’s
boundary. This situation is handled by noting that polygon clipping proceeds by
clippingagainstoneplaneoftheclipvolume’sboundaryatatime. Colorclipping
Version2.1-December1,20062.15. VERTEXSHADERS 71
is done in the same way, so that clipped points always occur at the intersection of
polygonedges(possiblyalreadyclipped)withtheclipvolume’sboundary.
Texture and fog coordinates, vertex shader varying variables (section 2.15.3),
andpointsizescomputedonapervertexbasismustalsobeclippedwhenaprimi-
tiveisclipped. Themethodisexactlyanalogoustothatusedforcolorclipping.
2.14.9 FinalColorProcessing
For an RGBA color, each color component (which lies in [0,1]) is converted
(by rounding to nearest) to a ?xed-point value with m bits. We assume that
m
the ?xed-point representation used represents each value k/(2 ? 1), where
m
k ? {0,1,...,2 ? 1}, as k (e.g. 1.0 is represented in binary as a string of
all ones). m must be at least as large as the number of bits in the corresponding
component of the framebuffer. m must be at least 2 for A if the framebuffer does
not contain an A component, or if there is only 1 bit of A in the framebuffer. A
colorindexisconverted(byroundingtonearest)toa?xed-pointvaluewithatleast
asmanybitsasthereareinthecolorindexportionoftheframebuffer.
m
Because a number of the formk/(2 ?1) may not be represented exactly as
a limited-precision ?oating-point quantity, we place a further requirement on the
?xed-pointconversionofRGBAcomponents. Supposethatlightingisdisabled,the
colorassociatedwithavertexhasnotbeenclipped,andoneofColorub,Colorus,
or Colorui was used to specify that color. When these conditions are satis?ed, an
RGBAcomponentmustconverttoavaluethatmatchesthecomponentasspeci?ed
in the Color command: if m is less than the number of bits b with which the
componentwasspeci?ed,thentheconvertedvaluemustequalthemostsigni?cant
mbitsofthespeci?edvalue;otherwise,themostsigni?cantbbitsoftheconverted
valuemustequalthespeci?edvalue.
2.15 VertexShaders
The sequence of operations described in sections 2.11 through 2.14 is a ?xed-
function method for processing vertex data. Applications can more generally de-
scribetheoperationsthatoccuronvertexvaluesandtheirassociateddatabyusing
a vertex shader.
Avertexshaderisanarrayofstringscontainingsourcecodefortheoperations
that are meant to occur on each vertex that is processed. The language used for
vertexshadersisdescribedintheOpenGLShadingLanguageSpecification.
To use a vertex shader, shader source code is ?rst loaded into a shader object
and then compiled. One or more vertex shader objects are then attached to a pro-
Version2.1-December1,200672 CHAPTER2. OPENGLOPERATION
gram object. A program object is then linked, which generates executable code
from all the compiled shader objects attached to the program. When a linked
program object is used as the current program object, the executable code for the
vertexshadersitcontainsisusedtoprocessvertices.
In addition to vertex shaders, fragment shaders can be created, compiled, and
linked into program objects. Fragment shaders affect the processing of fragments
during rasterization, and are described in section 3.11. A single program object
cancontainbothvertexandfragmentshaders.
When the program object currently in use includes a vertex shader, its vertex
shader is considered active and is used to process vertices. If the program object
has no vertex shader, or no program object is currently in use, the ?xed-function
methodforprocessingverticesisusedinstead.
2.15.1 ShaderObjects
The source code that makes up a program that gets executed by one of the pro-
grammablestagesisencapsulatedinoneormore shader objects.
The name space for shader objects is the unsigned integers, with zero re-
servedfortheGL.Thisnamespaceissharedwithprogramobjects. Thefollowing
sections de?ne commands that operate on shader and program objects by name.
Commands that accept shader or program object names will generate the error
INVALID VALUE if the provided name is not the name of either a shader or pro-
gram object and INVALID OPERATION if the provided name identi?es an object
thatisnottheexpectedtype.
Tocreateashaderobject,usethecommand
uint CreateShader(enum type);
Theshaderobjectisemptywhenitiscreated. Thetypeargumentspeci?esthetype
of shader object to be created. For vertex shaders, type must beVERTEX SHADER.
A non-zero name that can be used to reference the shader object is returned. If an
erroroccurs,zerowillbereturned.
Thecommand
void ShaderSource(uint shader,sizei count,const
char **string,const int *length);
loadssource codeinto theshader objectnamed shader. stringisan arrayof count
pointers to optionally null-terminated character strings that make up the source
code. Thelengthargumentisanarraywiththenumberofcharsineachstring(the
Version2.1-December1,20062.15. VERTEXSHADERS 73
string length). If an element in length is negative, its accompanying string is null-
terminated. IflengthisNULL,allstringsinthestringargumentareconsiderednull-
terminated. The ShaderSource command sets the source code for the shader to
thetextstringsinthestringarray. Ifshaderpreviouslyhadsourcecodeloadedinto
it, the existing source code is completely replaced. Any length passed in excludes
thenullterminatorinitscount.
Thestringsthatareloadedintoashaderobjectareexpectedtoformthesource
codeforavalidshaderasde?nedintheOpenGLShadingLanguageSpecification.
Once the source code for a shader has been loaded, a shader object can be
compiledwiththecommand
void CompileShader(uint shader);
Each shader object has a boolean status, COMPILE STATUS, that is modi?ed as
a result of compilation. This status can be queried with GetShaderiv (see sec-
tion6.1.14). ThisstatuswillbesettoTRUEif shaderwascompiledwithouterrors
and is ready for use, and FALSE otherwise. Compilation can fail for a variety of
reasons as listed in the OpenGL Shading Language Specification. If Compile-
Shader failed, any information about a previous compile is lost. Thus a failed
compiledoesnotrestoretheoldstateof shader.
Changing the source code of a shader object with ShaderSource does not
changeitscompilestatusorthecompiledshadercode.
Each shader object has an information log, which is a text string that is over-
written as a result of compilation. This information log can be queried with Get-
ShaderInfoLog to obtain more information about the compilation attempt (see
section6.1.14).
Shaderobjectscanbedeletedwiththecommand
void DeleteShader(uint shader);
If shader is not attached to any program object, it is deleted immediately. Oth-
erwise, shader is ?agged for deletion and will be deleted when it is no longer
attached to any program object. If an object is ?agged for deletion, its boolean
status bit DELETE STATUS is set to true. The value of DELETE STATUS can be
queriedwithGetShaderiv(seesection6.1.14). DeleteShaderwillsilentlyignore
thevaluezero.
2.15.2 ProgramObjects
The shader objects that are to be used by the programmable stages of the GL are
collected together to form a program object. The programs that are executed by
Version2.1-December1,200674 CHAPTER2. OPENGLOPERATION
these programmable stages are called executables. All information necessary for
de?ning an executable is encapsulated in a program object. A program object is
createdwiththecommand
uint CreateProgram(void);
Program objects are empty when they are created. A non-zero name that can be
used to reference the program object is returned. If an error occurs, 0 will be
returned.
Toattachashaderobjecttoaprogramobject,usethecommand
void AttachShader(uint program,uint shader);
The errorINVALID OPERATION is generated if shader is already attached to pro-
gram.
Shader objects may be attached to program objects before source code has
beenloadedintotheshaderobject, orbeforetheshaderobjecthasbeencompiled.
Multiple shader objects of the same type may be attached to a single program
object,andasingleshaderobjectmaybeattachedtomorethanoneprogramobject.
Todetachashaderobjectfromaprogramobject,usethecommand
void DetachShader(uint program,uint shader);
TheerrorINVALID OPERATIONisgeneratedifshaderisnotattachedtoprogram.
If shader has been ?agged for deletion and is not attached to any other program
object,itisdeleted.
In order to use the shader objects contained in a program object, the program
objectmustbelinked. Thecommand
void LinkProgram(uint program);
will link the program object named program. Each program object has a boolean
status, LINK STATUS, that is modi?ed as a result of linking. This status can be
queriedwithGetProgramiv(seesection6.1.14). ThisstatuswillbesettoTRUEif
a valid executable is created, and FALSE otherwise. Linking can fail for a variety
of reasons as speci?ed in the OpenGL Shading Language Specification. Linking
will also fail if one or more of the shader objects, attached to program are not
compiled successfully, or if more active uniform or active sampler variables are
used in program than allowed (see section 2.15.3). If LinkProgram failed, any
informationaboutapreviouslinkofthatprogramobjectislost. Thus,afailedlink
doesnotrestoretheoldstateof program.
Version2.1-December1,20062.15. VERTEXSHADERS 75
Each program object has an information log that is overwritten as a result of a
link operation. This information log can be queried with GetProgramInfoLog to
obtainmoreinformationaboutthelinkoperationorthevalidationinformation(see
section6.1.14).
If a valid executable is created, it can be made part of the current rendering
statewiththecommand
void UseProgram(uint program);
This command will install the executable code as part of current rendering state if
the program object program contains valid executable code, i.e. has been linked
successfully. If UseProgram is called with program set to 0, it is as if the GL
had no programmable stages and the ?xed-function paths will be used instead.
If program has not been successfully linked, the error INVALID OPERATION is
generatedandthecurrentrenderingstateisnotmodi?ed.
While a program object is in use, applications are free to modify attached
shader objects, compile attached shader objects, attach additional shader objects,
and detach shader objects. These operations do not affect the link status or exe-
cutablecodeoftheprogramobject.
Iftheprogramobjectthatisinuseisre-linkedsuccessfully,the LinkProgram
commandwillinstallthegeneratedexecutablecodeaspartofthecurrentrendering
stateifthespeci?edprogramobjectwasalreadyinuseasaresultofapreviouscall
toUseProgram.
If that program object that is in use is re-linked unsuccessfully, the link status
will be set to FALSE, but existing executable and associated state will remain part
of the current rendering state until a subsequent call to UseProgram removes it
fromuse. Aftersuchaprogramisremovedfromuse,itcannotbemadepartofthe
currentrenderingstateuntilitissuccessfullyre-linked.
Programobjectscanbedeletedwiththecommand
void DeleteProgram(uint program);
IfprogramisnotthecurrentprogramforanyGLcontext,itisdeletedimmediately.
Otherwise,programis?aggedfordeletionandwillbedeletedwhenitisnolonger
the current program for any context. When a program object is deleted, all shader
objects attached to it are detached. DeleteProgram will silently ignore the value
zero.
2.15.3 ShaderVariables
Avertexshadercanreferenceanumberofvariablesasitexecutes. Vertexattributes
are the per-vertex values speci?ed in section 2.7. Uniforms are per-program vari-
Version2.1-December1,200676 CHAPTER2. OPENGLOPERATION
ables that are constant during program execution. Samplers are a special form of
uniformusedfortexturing(section3.8). Varying variablesholdtheresultsofver-
tex shader execution that are used later in the pipeline. The following sections
describeeachofthesevariabletypes.
VertexAttributes
Vertex shaders can access built-in vertex attribute variables corresponding to the
per-vertex state set by commands such as Vertex, Normal, Color. Vertex shaders
can also de?ne named attribute variables, which are bound to the generic vertex
attributes that are set by VertexAttrib*. This binding can be speci?ed by the ap-
plication before the program is linked, or automatically assigned by the GL when
theprogramislinked.
Whenanattributevariabledeclaredasafloat,vec2,vec3orvec4isbound
to a generic attribute indexi, its value(s) are taken from thex, (x,y), (x,y,z), or
(x,y,z,w) components, respectively, of the generic attributei. When an attribute
variable is declared as a mat2, mat3x2 or mat4x2, its matrix columns are taken
fromthe(x,y)componentsofgenericattributesiandi+1(mat2),fromattributes
i throughi+2 (mat3x2), or from attributesi throughi+3 (mat4x2). When an
attribute variable is declared as a mat2x3, mat3 or mat4x3, its matrix columns
aretakenfromthe(x,y,z)componentsofgenericattributesiandi+1(mat2x3),
fromattributesithroughi+2(mat3),orfromattributesithroughi+3(mat4x3).
When an attribute variable is declared as a mat2x4, mat3x4 or mat4, its matrix
columnsaretakenfromthe(x,y,z,w)componentsofgenericattributesiandi+1
(mat2x4), from attributes i through i+ 2 (mat3x4), or from attributes i through
i+3(mat4).
Anattributevariable(eitherconventionalorgeneric)isconsideredactiveifitis
determinedbythecompilerandlinkerthattheattributemaybeaccessedwhenthe
shaderisexecuted. Attributevariablesthataredeclaredinavertexshaderbutnever
usedwillnotcountagainstthelimit. Incaseswherethecompilerandlinkercannot
makeaconclusivedetermination,anattributewillbeconsideredactive. Aprogram
object will fail to link if the sum of the active generic and active conventional
attributesexceedsMAX VERTEX ATTRIBS.
To determine the set of active vertex attributes used by a program, and to de-
terminetheirtypes,usethecommand:
void GetActiveAttrib(uint program,uint index,
sizei bufSize,sizei *length,int *size,enum *type,
char *name);
Version2.1-December1,20062.15. VERTEXSHADERS 77
This command provides information about the attribute selected by index. An in-
dexof0selectsthe?rstactiveattribute,andanindexofACTIVE ATTRIBUTES?1
selectsthelastactiveattribute. ThevalueofACTIVE ATTRIBUTEScanbequeried
with GetProgramiv (see section 6.1.14). If index is greater than or equal to
ACTIVE ATTRIBUTES, the error INVALID VALUE is generated. Note that index
simply identi?es a member in a list of active attributes, and has no relation to the
genericattributethatthecorrespondingvariableisboundto.
The parameter program is the name of a program object for which the com-
mandLinkProgramhasbeenissuedinthepast. Itisnotnecessaryforprogramto
have been linked successfully. The link could have failed because the number of
activeattributesexceededthelimit.
The name of the selected attribute is returned as a null-terminated string in
name. Theactualnumberofcharacterswrittenintoname,excludingthenulltermi-
nator,isreturnedinlength. IflengthisNULL,nolengthisreturned. Themaximum
numberofcharactersthatmaybewritteninto name,includingthenullterminator,
is speci?ed by bufSize. The returned attribute name can be the name of a generic
attribute or a conventional attribute (which begin with the pre?x "gl ", see the
OpenGL Shading Language speci?cation for a complete list). The length of the
longestattributenamein programisgivenbyACTIVE ATTRIBUTE MAX LENGTH,
whichcanbequeriedwithGetProgramiv(seesection6.1.14).
For the selected attribute, the type of the attribute is returned into type.
The size of the attribute is returned into size. The value in size is in
units of the type returned in type. The type returned can be any of
FLOAT, FLOAT VEC2, FLOAT VEC3, FLOAT VEC4, FLOAT MAT2, FLOAT MAT3,
FLOAT MAT4,FLOAT MAT2x3,FLOAT MAT2x4,FLOAT MAT3x2,FLOAT MAT3x4,
FLOAT MAT4x2,orFLOAT MAT4x3.
If an error occurred, the return parameters length, size, type and name will be
unmodi?ed.
This command will return as much information about active attributes as pos-
sible. Ifnoinformationisavailable, lengthwillbesettozeroand namewillbean
empty string. This situation could arise ifGetActiveAttrib is issued after a failed
link.
After a program object has been linked successfully, the bindings of attribute
variablenamestoindicescanbequeried. Thecommand
int GetAttribLocation(uintprogram,const char*name);
returnsthegenericattributeindexthattheattributevariablenamednamewasbound
towhentheprogramobjectnamed programwaslastlinked. namemustbeanull-
terminated string. If name is active and is an attribute matrix,GetAttribLocation
Version2.1-December1,200678 CHAPTER2. OPENGLOPERATION
returns the index of the ?rst column of that matrix. If program has not been suc-
cessfully linked, the error INVALID OPERATION is generated. If name is not an
activeattribute,if nameisaconventionalattribute,orifanerroroccurs,-1willbe
returned.
The binding of an attribute variable to a generic attribute index can also be
speci?edexplicitly. Thecommand
void BindAttribLocation(uint program,uint index,const
char *name);
speci?es that the attribute variable named name in program program should be
bound to generic vertex attribute index when the program is next linked. If name
wasboundpreviously,itsassignedbindingisreplacedwith index. namemustbea
nullterminatedstring. TheerrorINVALID VALUEisgeneratedif indexisequalor
greater than MAX VERTEX ATTRIBS. BindAttribLocation has no effect until the
program is linked. In particular, it doesn’t modify the bindings of active attribute
variablesinaprogramthathasalreadybeenlinked.
Built-in attribute variables are automatically bound to conventional attributes,
and can not have an assigned binding. The error INVALID OPERATION is gener-
atedif namestartswiththereserved"gl "pre?x.
When a program is linked, any active attributes without a binding speci?ed
through BindAttribLocation will be automatically be bound to vertex attributes
bytheGL.SuchbindingscanbequeriedusingthecommandGetAttribLocation.
LinkProgramwillfailiftheassignedbindingofanactiveattributevariablewould
causetheGLtoreferenceanon-existantgenericattribute(onegreaterthanorequal
to MAX VERTEX ATTRIBS). LinkProgram will fail if the attribute bindings as-
signedbyBindAttribLocationdonotleavenotenoughspacetoassignalocation
foranactivematrixattribute,whichrequiresmultiplecontiguousgenericattributes.
LinkProgramwillalsofailifthevertexshadersusedintheprogramobjectcontain
assignments(notremovedduringpre-processing)toanattributevariableboundto
genericattributezeroandtotheconventionalvertexposition(gl Vertex).
BindAttribLocation may be issued before any vertex shader objects are at-
tached to a program object. Hence it is allowed to bind any name (except a name
startingwith"gl ")toanindex,includinganamethatisneverusedasanattribute
in any vertex shader object. Assigned bindings for attribute variables that do not
existorarenotactiveareignored.
The values of generic attributes sent to generic attribute index i are part of
current state, just like the conventional attributes. If a new program object has
been made active, then these values will be tracked by the GL in such a way that
the same values will be observed by attributes in the new program object that are
alsoboundtoindexi.
Version2.1-December1,20062.15. VERTEXSHADERS 79
It is possible for an application to bind more than one attribute name to the
same location. This is referred to as aliasing. This will only work if only one of
the aliased attributes is active in the executable program, or if no path through the
shader consumes more than one attribute of a set of attributes aliased to the same
location. Alinkerrorcanoccurifthelinkerdeterminesthateverypaththroughthe
shader consumes multiple aliased attributes, but implementations are not required
togenerateanerrorinthiscase. Thecompilerandlinkerareallowedtoassumethat
no aliasing is done, and may employ optimizations that work only in the absence
ofaliasing. Itisnotpossibletoaliasgenericattributeswithconventionalones.
UniformVariables
Shaderscandeclarenameduniformvariables,asdescribedintheOpenGLShading
Language Specification. Values for these uniforms are constant over a primitive,
and typically they are constant across many primitives. Uniforms are program
object-speci?c state. They retain their values once loaded, and their values are
restored whenever a program object is used, as long as the program object has not
been re-linked. A uniform is considered active if it is determined by the compiler
and linker that the uniform will actually be accessed when the executable code
is executed. In cases where the compiler and linker cannot make a conclusive
determination,theuniformwillbeconsideredactive.
The amount of storage available for uniform variables accessed by
a vertex shader is speci?ed by the implementation dependent constant
MAX VERTEX UNIFORM COMPONENTS. This value represents the number of indi-
vidual?oating-point,integer,orbooleanvaluesthatcanbeheldinuniformvariable
storage for a vertex shader. A link error will be generated if an attempt is made to
utilizemorethanthespaceavailableforvertexshaderuniformvariables.
When a program is successfully linked, all active uniforms belonging to the
programobjectareinitializedtozero(FALSEforbooleans). Asuccessfullinkwill
alsogeneratealocationforeachactiveuniform. Thevaluesofactiveuniformscan
be changed using this location and the appropriate Uniform* command (see be-
low). These locations are invalidated and new ones assigned after each successful
re-link.
To?ndthelocationofanactiveuniformvariablewithinaprogramobject,use
thecommand
int GetUniformLocation(uint program,const
char *name);
This command will return the location of uniform variable name. name must be a
null terminated string, without white space. The value -1 will be returned if name
Version2.1-December1,200680 CHAPTER2. OPENGLOPERATION
doesnotcorrespondtoanactiveuniformvariablenameinprogramorifnamestarts
with the reserved pre?x"gl ". If program has not been successfully linked, the
error INVALID OPERATION is generated. After a program is linked, the location
ofauniformvariablewillnotchange,unlesstheprogramisre-linked.
A valid name cannot be a structure, an array of structures, or any portion of
a single vector or a matrix. In order to identify a valid name, the "." (dot) and
"[]"operatorscanbeusedinnametospecifyamemberofastructureorelement
ofanarray.
The?rstelementofauniformarrayisidenti?edusingthenameoftheuniform
array appended with"[0]". Except if the last part of the string name indicates a
uniform array, then the location of the ?rst element of that array can be retrieved
by either using the name of the uniform array, or the name of the uniform array
appendedwith"[0]".
To determine the set of active uniform attributes used by a program, and to
determinetheirsizesandtypes,usethecommand:
void GetActiveUniform(uint program,uint index,
sizei bufSize,sizei *length,int *size,enum *type,
char *name);
This command provides information about the uniform selected by index. An in-
dex of 0 selects the ?rst active uniform, and an index of ACTIVE UNIFORMS? 1
selects the last active uniform. The value of ACTIVE UNIFORMS can be queried
with GetProgramiv (see section 6.1.14). If index is greater than or equal to
ACTIVE UNIFORMS,theerrorINVALID VALUEisgenerated. Notethat indexsim-
ply identi?es a member in a list of active uniforms, and has no relation to the
locationassignedtothecorrespondinguniformvariable.
Theparameterprogramisanameofaprogramobjectforwhichthecommand
LinkProgram has been issued in the past. It is not necessary for program to have
been linked successfully. The link could have failed because the number of active
uniformsexceededthelimit.
If an error occurred, the return parameters length, size, type and name will be
unmodi?ed.
For the selected uniform, the uniform name is returned into name. The string
name will be null terminated. The actual number of characters written into name,
excluding the null terminator, is returned in length. If length isNULL, no length is
returned. The maximum number of characters that may be written into name, in-
cluding the null terminator, is speci?ed by bufSize. The returned uniform name
can be the name of built-in uniform state as well. The complete list of built-
in uniform state is described in section 7.5 of the OpenGL Shading Language
Version2.1-December1,20062.15. VERTEXSHADERS 81
speci?cation. The length of the longest uniform name in program is given by
ACTIVE UNIFORM MAX LENGTH, which can be queried with GetProgramiv (see
section6.1.14).
Each uniform variable, declared in a shader, is broken down into one or more
strings using the "." (dot) and "[]" operators, if necessary, to the point that it
is legal to pass each string back into GetUniformLocation. Each of these strings
constitutesoneactiveuniform,andeachstringisassignedanindex.
For the selected uniform, the type of the uniform is returned into
type. The size of the uniform is returned into size. The value in
size is in units of the type returned in type. The type returned can be
any of FLOAT, FLOAT VEC2, FLOAT VEC3, FLOAT VEC4, INT, INT VEC2,
INT VEC3,INT VEC4,BOOL,BOOL VEC2,BOOL VEC3,BOOL VEC4,FLOAT MAT2,
FLOAT MAT3, FLOAT MAT4, FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2,
FLOAT MAT3x4, FLOAT MAT4x2, FLOAT MAT4x3, SAMPLER 1D, SAMPLER 2D,
SAMPLER 3D,SAMPLER CUBE,SAMPLER 1D SHADOW,orSAMPLER 2D SHADOW.
If one or more elements of an array are active, GetActiveUniform will return
the name of the array in name, subject to the restrictions listed above. The type of
thearrayisreturnedintype. Thesizeparametercontainsthehighestarrayelement
index used, plus one. The compiler or linker determines the highest index used.
TherewillbeonlyoneactiveuniformreportedbytheGLperuniformarray.
GetActiveUniform will return as much information about active uniforms as
possible. Ifnoinformationisavailable, lengthwillbesettozeroand namewillbe
an empty string. This situation could arise if GetActiveUniform is issued after a
failedlink.
Toloadvaluesintotheuniformvariablesoftheprogramobjectthatiscurrently
inuse,usethecommands
void Uniform{1234}{if}(int location,T value);
void Uniform{1234}{if}v(int location,sizei count,
T value);
void UniformMatrix{234}fv(int location,sizei count,
boolean transpose,const float *value);
void UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv(
int location,sizei count,boolean transpose,const
float *value);
The given values are loaded into the uniform variable location identi?ed by loca-
tion.
TheUniform*f{v}commandswillloadcountsetsofonetofour?oating-point
valuesintoauniformlocationde?nedasa?oat,a?oating-pointvector,anarrayof
?oats,oranarrayof?oating-pointvectors.
Version2.1-December1,200682 CHAPTER2. OPENGLOPERATION
The Uniform*i{v} commands will load count sets of one to four integer val-
ues into a uniform location de?ned as a sampler, an integer, an integer vector, an
array of samplers, an array of integers, or an array of integer vectors. Only the
Uniform1i{v}commandscanbeusedtoloadsamplervalues(seebelow).
TheUniformMatrix{234}fvcommandswillloadcount2?2,3?3,or4?4
matrices(correspondingto2,3,or4inthecommandname)of?oating-pointvalues
into a uniform location de?ned as a matrix or an array of matrices. If transpose
is FALSE, the matrix is speci?ed in column major order, otherwise in row major
order.
TheUniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fvcommandswillloadcount
2?3,3?2,2?4,4?2,3?4,or4?3matrices(correspondingtothenumbersinthe
commandname)of?oating-pointvaluesintoauniformlocationde?nedasamatrix
or an array of matrices. The ?rst number in the command name is the number of
columns; the second is the number of rows. For example, UniformMatrix2x4fv
is used to load a matrix consisting of two columns and four rows. If transpose
is FALSE, the matrix is speci?ed in column major order, otherwise in row major
order.
When loading values for a uniform declared as a boolean, a boolean vector,
an array of booleans, or an array of boolean vectors, both the Uniform*i{v} and
Uniform*f{v} set of commands can be used to load boolean values. Type con-
version is done by the GL. The uniform is set to FALSE if the input value is 0 or
0.0f, and set to TRUE otherwise. The Uniform* command used must match the
size of the uniform, as declared in the shader. For example, to load a uniform
declared as a bvec2, either Uniform2i{v} or Uniform2f{v} can be used. An
INVALID OPERATION error will be generated if an attempt is made to use a non-
matchingUniform*command. InthisexampleusingUniform1ivwouldgenerate
anerror.
For all other uniform types the Uniform* command used must match the size
and type of the uniform, as declared in the shader. No type conversions are done.
For example, to load a uniform declared as a vec4, Uniform4f{v} must be used.
Toloada3x3matrix,UniformMatrix3fvmustbeused. AnINVALID OPERATION
error will be generated if an attempt is made to use a non-matching Uniform*
command. Inthisexample,usingUniform4i{v}wouldgenerateanerror.
When loading N elements starting at an arbitrary position k in a uniform de-
clared as an array, elements k through k + N? 1 in the array will be replaced
with the new values. Values for any array element that exceeds the highest array
elementindexused,asreportedbyGetActiveUniform,willbeignoredbytheGL.
If the value of location is -1, the Uniform* commands will silently ignore the
datapassedin,andthecurrentuniformvalueswillnotbechanged.
Ifanyofthefollowingconditionsoccur,anINVALID OPERATIONerrorisgen-
Version2.1-December1,20062.15. VERTEXSHADERS 83
eratedbytheUniform*commands,andnouniformvaluesarechanged:
• if the size indicated in the name of the Uniform* command used does not
matchthesizeoftheuniformdeclaredintheshader,
• if the uniform declared in the shader is not of type boolean and the type
indicated in the name of the Uniform* command used does not match the
typeoftheuniform,
• if countisgreaterthanone, andtheuniformdeclaredintheshaderisnotan
arrayvariable,
• if no variable with a location of location exists in the program object cur-
rentlyinuseand locationisnot-1,or
• ifthereisnoprogramobjectcurrentlyinuse.
Samplers
Samplers are special uniforms used in the OpenGL Shading Language to identify
the texture object used for each texture lookup. The value of a sampler indicates
thetextureimageunitbeingaccessed. Settingasampler’svaluetoiselectstexture
image unit number i. The values of i range from zero to the implementation-
dependentmaximumsupportednumberoftextureimageunits.
The type of the sampler identi?es the target on the texture image unit. The
texture object bound to that texture image unit’s target is then used for the texture
lookup. Forexample,avariableoftypesampler2DselectstargetTEXTURE 2Don
its texture image unit. Binding of texture objects to targets is done as usual with
BindTexture. Selecting the texture image unit to bind to is done as usual with
ActiveTexture.
ThelocationofasamplerneedstobequeriedwithGetUniformLocation,just
likeanyuniformvariable. SamplervaluesneedtobesetbycallingUniform1i{v}.
Loading samplers with any of the other Uniform* entry points is not allowed and
willresultinanINVALID OPERATIONerror.
It is not allowed to have variables of different sampler types pointing to the
same texture image unit within a program object. This situation can only be de-
tected at the next rendering command issued, and an INVALID OPERATION error
willthenbegenerated.
Active samplers are samplers actually being used in a program object. The
LinkProgram command determines if a sampler is active or not. The LinkPro-
gram command will attempt to determine if the active samplers in the shader(s)
Version2.1-December1,200684 CHAPTER2. OPENGLOPERATION
contained in the program object exceed the maximum allowable limits. If it de-
termines that the count of active samplers exceeds the allowable limits, then the
link fails (these limits can be different for different types of shaders). Each active
sampler variable counts against the limit, even if multiple samplers refer to the
same texture image unit. If this cannot be determined at link time, for example if
the program object only contains a vertex shader, then it will be determined at the
next rendering command issued, and an INVALID OPERATION error will then be
generated.
VaryingVariables
Avertexshadermayde?neoneormore varyingvariables(seetheOpenGLShad-
ing Language speci?cation). These values are expected to be interpolated across
theprimitivebeingrendered. TheOpenGLShadingLanguagespeci?cationde?nes
a set of built-in varying variables for vertex shaders that correspond to the values
requiredforthe?xed-functionprocessingthatoccursaftervertexprocessing.
Thenumberofinterpolatorsavailableforprocessingvaryingvariablesisgiven
bytheimplementation-dependentconstant MAX VARYING FLOATS.Thisvaluerep-
resents the number of individual ?oating-point values that can be interpolated;
varyingvariablesdeclaredasvectors,matrices,andarrayswillallconsumemulti-
ple interpolators. When a program is linked, all components of any varying vari-
able written by a vertex shader, or read by a fragment shader, will count against
this limit. The transformed vertex position (gl Position) is not a varying vari-
able and does not count against this limit. A program whose shaders access more
than MAX VARYING FLOATS components worth of varying variables may fail to
link,unlessdevice-dependentoptimizationsareabletomaketheprogram?twithin
availablehardwareresources.
2.15.4 ShaderExecution
Ifasuccessfullylinkedprogramobjectthatcontainsavertexshaderismadecurrent
by calling UseProgram, the executable version of the vertex shader is used to
process incoming vertex values rather than the ?xed-function vertex processing
describedinsections2.11through2.14. Inparticular,
• The model-view and projection matrices are not applied to vertex coordi-
nates(section2.11).
• Thetexturematricesarenotappliedtotexturecoordinates(section2.11.2).
• Normalsarenottransformedtoeyecoordinates,andarenotrescaledornor-
malized(section2.11.3).
Version2.1-December1,20062.15. VERTEXSHADERS 85
• Normalization of AUTO NORMAL evaluated normals is not performed. (sec-
tion5.1).
• Texturecoordinatesarenotgeneratedautomatically(section2.11.4).
• Pervertexlightingisnotperformed(section2.14.1).
• Colormaterialcomputationsarenotperformed(section2.14.3).
• Colorindexlightingisnotperformed(section2.14.5).
• All of the above applies when setting the current raster position (sec-
tion2.13).
The following operations are applied to vertex values that are the result of
executingthevertexshader:
• Colorclampingormasking(section2.14.6).
• Perspectivedivisiononclipcoordinates(section2.11).
• Viewportmapping,includingdepthrangescaling(section2.11.1).
• Clipping,includingclient-de?nedclipplanes(section 2.12).
• Frontfacedetermination(section2.14.1).
• Flat-shading(section 2.14.7).
• Color,texturecoordinate,fog,point-sizeandgenericattributeclipping(sec-
tion2.14.8).
• Finalcolorprocessing(section2.14.9.
There are several special considerations for vertex shader execution described
inthefollowingsections.
TextureAccess
Vertex shaders have the ability to do a lookup into a texture map, if sup-
ported by the GL implementation. The maximum number of texture image units
available to a vertex shader is MAX VERTEX TEXTURE IMAGE UNITS; a maxi-
mum number of zero indicates that the GL implemenation does not support
texture accesses in vertex shaders. The maximum number of texture image
units available to the fragment stage of the GL is MAX TEXTURE IMAGE UNITS.
Version2.1-December1,200686 CHAPTER2. OPENGLOPERATION
Both the vertex shader and fragment processing combined cannot use more
than MAX COMBINED TEXTURE IMAGE UNITS texture image units. If both
the vertex shader and the fragment processing stage access the same texture
image unit, then that counts as using two texture image units against the
MAX COMBINED TEXTURE IMAGE UNITSlimit.
Whenatexturelookupisperformedinavertexshader,the?lteredtexturevalue
? is computed in the manner described in sections 3.8.8 and 3.8.9, and converted
it to a texture source color C according to table 3.20 (section 3.8.13). A four-
s
componentvector(R ,G ,B ,A )isreturnedtothevertexshader.
s s s s
Inavertexshader,itisnotpossibletoperformautomaticlevel-of-detailcalcu-
lations using partial derivatives of the texture coordinates with respect to window
coordinatesasdescribedinsection3.8.8. Hence,thereisnoautomaticselectionof
an image array level. Minification or magni?cation of a texture map is controlled
by a level-of-detail value optionally passed as an argument in the texture lookup
functions. Ifthetexturelookupfunctionsuppliesanexplicitlevel-of-detailvalue l,
thenthepre-biaslevel-of-detailvalue ? (x,y) =l (replacingequation3.18). If
base
the texture lookup function does not supply an explicit level-of-detail value, then
? (x,y) = 0. The scale factor ?(x,y) and its approximation function f(x,y)
base
(seeequation3.21)areignored.
Texture lookups involving textures with depth component data can either re-
turn the depth data directly or return the results of a comparison with the r tex-
ture coordinate used to perform the lookup, as described in section 3.8.14. The
comparison operation is requested in the shader by using the shadow sampler
types (sampler1DShadow or sampler2DShadow) and in the texture using the
TEXTURE COMPARE MODE parameter. These requests must be consistent; the re-
sultsofatexturelookupareunde?nedif:
• The sampler used in a texture lookup function is of type sampler1D or
sampler2D,andthetextureobject’sinternalformatisDEPTH COMPONENT,
andtheTEXTURE COMPARE MODEisnotNONE.
• Thesamplerusedinatexturelookupfunctionisoftypesampler1DShadow
or sampler2DShadow, and the texture object’s internal format is
DEPTH COMPONENT,andtheTEXTURE COMPARE MODEisNONE.
• Thesamplerusedinatexturelookupfunctionisoftypesampler1DShadow
or sampler2DShadow, and the texture object’s internal format is not
DEPTH COMPONENT.
Ifavertexshaderusesasamplerwheretheassociatedtextureobjectisnotcom-
plete, as de?ned in section 3.8.10, the texture image unit will return (R,G,B,A)
=(0,0,0,1).
Version2.1-December1,20062.15. VERTEXSHADERS 87
PositionInvariance
Ifavertexshaderusesthebuilt-infunction ftransformtogenerateavertexposi-
tion, then this generally guarantees that the transformed position will be the same
whetherusingthisvertexshaderorthe?xed-functionpipeline. Thisallowsforcor-
rectmulti-passrenderingalgorithms,wheresomepassesuse?xed-functionvertex
transformationandotherpassesuseavertexshader. Ifavertexshaderdoesnotuse
ftransform to generate a position, transformed positions are not guaranteed to
match,evenifthesequenceofinstructionsusedtocomputethepositionmatchthe
sequenceoftransformationsdescribedinsection2.11.
Validation
It is not always possible to determine at link time if a program object actually
will execute. Therefore validation is done when the ?rst rendering command is
issued, to determine if the currently active program object can be executed. If
it cannot be executed then no fragments will be rendered, and Begin, Raster-
Pos, or any command that performs an implicit Begin will generate the error
INVALID OPERATION.
This error is generated by Begin, RasterPos, or any command that performs
animplicitBeginif:
• anytwoactivesamplersinthecurrentprogramobjectareofdifferenttypes,
butrefertothesametextureimageunit,
• any active sampler in the current program object refers to a texture image
unit where ?xed-function fragment processing accesses a texture target that
doesnotmatchthesamplertype,or
• the sum of the number of active samplers in the program and the number of
texture image units enabled for ?xed-function fragment processing exceeds
thecombinedlimitonthetotalnumberoftextureimageunitsallowed.
Fixed-function fragment processing operations will be performed if the pro-
gramobjectinusehasnofragmentshader.
The INVALID OPERATION error reported by these rendering commands may
notprovideenoughinformationto?ndoutwhythecurrentlyactiveprogramobject
would not execute. No information at all is available about a program object that
would still execute, but is inef?cient or suboptimal given the current GL state. As
adevelopmentaid,usethecommand
void ValidateProgram(uint program);
Version2.1-December1,200688 CHAPTER2. OPENGLOPERATION
tovalidatetheprogramobjectprogramagainstthecurrentGLstate. Eachprogram
object has a boolean status, VALIDATE STATUS, that is modi?ed as a result of
validation. This status can be queried with GetProgramiv (see section 6.1.14).
If validation succeeded this status will be set to TRUE, otherwise it will be set to
FALSE.Ifvalidationsucceededtheprogramobjectisguaranteedtoexecute,given
the current GL state. If validation failed, the program object is guaranteed to not
execute,giventhecurrentGLstate.
ValidateProgram will check for all the conditions that could lead to an
INVALID OPERATIONerrorwhenrenderingcommandsareissued,andmaycheck
for other conditions as well. For example, it could give a hint on how to optimize
some piece of shader code. The information log of program is overwritten with
information on the results of the validation, which could be an empty string. The
results written to the information log are typically only useful during application
development; an application should not expect different GL implementations to
produceidenticalinformation.
A shader should not fail to compile, and a program object should not fail to
link due to lack of instruction space or lack of temporary variables. Implementa-
tionsshouldensurethatallvalidshadersandprogramobjectsmaybesuccessfully
compiled,linkedandexecuted.
Unde?nedBehavior
When using array or matrix variables in a shader, it is possible to access a vari-
able with an index computed at run time that is outside the declared extent of the
variable. Such out-of-bounds reads will return unde?ned values; out-of-bounds
writeswillhaveunde?nedresultsandcouldcorruptothervariablesusedbyshader
or the GL. The level of protection provided against such errors in the shader is
implementation-dependent.
2.15.5 RequiredState
The GL maintains state to indicate which shader and program object names are in
use. Initially,noshaderorprogramobjectsexist,andnonamesareinuse.
Thestaterequiredpershaderobjectconsistsof:
• Anunsignedintegerspecifyingtheshaderobjectname.
• AnintegerholdingthevalueofSHADER TYPE.
• Abooleanholdingthedeletestatus,initiallyFALSE.
• Abooleanholdingthestatusofthelastcompile,initiallyFALSE.
Version2.1-December1,20062.15. VERTEXSHADERS 89
• Anarrayoftypecharcontainingtheinformationlog,initiallyempty.
• Anintegerholdingthelengthoftheinformationlog.
• An array of type char containing the concatenated shader string, initially
empty.
• Anintegerholdingthelengthoftheconcatenatedshaderstring.
Thestaterequiredperprogramobjectconsistsof:
• Anunsignedintegerindicatingtheprogramobjectobjectname.
• Abooleanholdingthedeletestatus,initiallyFALSE.
• Abooleanholdingthestatusofthelastlinkattempt,initiallyFALSE.
• Abooleanholdingthestatusofthelastvalidationattempt,initallyFALSE.
• Anintegerholdingthenumberofattachedshaderobjects.
• A list of unsigned integers to keep track of the names of the shader objects
attached.
• Anarrayoftypecharcontainingtheinformationlog,initiallyempty.
• Anintegerholdingthelengthoftheinformationlog.
• Anintegerholdingthenumberofactiveuniforms.
• For each active uniform, three integers, holding its location, size, and type,
andanarrayoftypecharholdingitsname.
• Anarrayofwordsthatholdthevaluesofeachactiveuniform.
• Anintegerholdingthenumberofactiveattributes.
• For each active attribute, three integers holding its location, size, and type,
andanarrayoftypecharholdingitsname.
Additionalstaterequiredtosupportvertexshadersconsistsof:
• A bit indicating whether or not vertex program two-sided color mode is en-
abled,initiallydisabled.
• A bit indicating whether or not vertex program point size mode (sec-
tion3.3.1)isenabled,initiallydisabled.
Additionally,oneunsignedintegerisrequiredtoholdthenameofthecurrentpro-
gramobject,ifany.
Version2.1-December1,2006Chapter 3
Rasterization
Rasterizationistheprocessbywhichaprimitiveisconvertedtoatwo-dimensional
image. Each point of this image contains such information as color and depth.
Thus, rasterizing a primitive consists of two parts. The ?rst is to determine which
squaresofanintegergridinwindowcoordinatesareoccupiedbytheprimitive. The
secondisassigningadepthvalueandoneormorecolorvaluestoeachsuchsquare.
TheresultsofthisprocessarepassedontothenextstageoftheGL(per-fragment
operations), which uses the information to update the appropriate locations in the
framebuffer. Figure 3.1 diagrams the rasterization process. The color values as-
signed to a fragment are initially determined by the rasterization operations (sec-
tions 3.3 through 3.7) and modi?ed by either the execution of the texturing, color
sum, and fog operations de?ned in sections 3.8, 3.9, and 3.10, or by a fragment
shader as de?ned in section 3.11. The ?nal depth value is initially determined by
therasterizationoperationsandmaybemodi?edorreplacedbyafragmentshader.
Theresultsfromrasterizingapoint,line,polygon,pixelrectangleorbitmapcanbe
routedthroughafragmentshader.
Agridsquarealongwithitsparametersofassignedcolors,z (depth),fogcoor-
dinate,andtexturecoordinatesiscalledafragment;theparametersarecollectively
dubbedthefragment’sassociateddata. Afragmentislocatedbyitslowerleftcor-
ner,whichliesonintegergridcoordinates. Rasterizationoperationsalsorefertoa
fragment’s center, which is offset by (1/2,1/2) from its lower left corner (and so
liesonhalf-integercoordinates).
GridsquaresneednotactuallybesquareintheGL.Rasterizationrulesarenot
affectedbytheactualaspectratioofthegridsquares. Displayofnon-squaregrids,
however, will cause rasterized points and line segments to appear fatter in one
direction than the other. We assume that fragments are square, since it simpli?es
antialiasingandtexturing.
9091
FRAGMENT_PROGRAM enable
Point
Rasterization
From
Line
Primitive
Rasterization
Fragment
Assembly
Texturing
Program
Polygon
Rasterization
Color Sum
Pixel
DrawPixels
Rectangle
Rasterization
Bitmap Fog
Bitmap
Rasterization
Fragments
Figure3.1. Rasterization.
Version2.1-December1,200692 CHAPTER3. RASTERIZATION
Severalfactorsaffectrasterization. Linesandpolygonsmaybestippled. Points
maybegivendifferingdiametersandlinesegmentsdifferingwidths. Apoint,line
segment,orpolygonmaybeantialiased.
3.1 Invariance
0
Consideraprimitivep obtainedbytranslatingaprimitivepthroughanoffset(x,y)
0
in window coordinates, wherex andy are integers. As long as neitherp norp is
0 0
clipped, it must be the case that each fragmentf produced fromp is identical to
0
a corresponding fragment f from p except that the center of f is offset by (x,y)
fromthecenteroff.
3.2 Antialiasing
Antialiasing of a point, line, or polygon is effected in one of two ways depending
onwhethertheGLisinRGBAorcolorindexmode.
In RGBA mode, the R, G, and B values of the rasterized fragment are left
unaffected, but the A value is multiplied by a ?oating-point value in the range
[0,1]thatdescribesafragment’sscreenpixelcoverage. Theper-fragmentstageof
the GL can be set up to use the A value to blend the incoming fragment with the
correspondingpixelalreadypresentintheframebuffer.
In color index mode, the least signi?cantb bits (to the left of the binary point)
ofthecolorindexareusedforantialiasing;b = min{4,m},wheremisthenumber
of bits in the color index portion of the framebuffer. The antialiasing process sets
theseb bits based on the fragment’s coverage value: the bits are set to zero for no
coverageandtoallonesforcompletecoverage.
Thedetailsofhowantialiasedfragmentcoveragevaluesarecomputedaredif-
?cult to specify in general. The reason is that high-quality antialiasing may take
into account perceptual issues as well as characteristics of the monitor on which
the contents of the framebuffer are displayed. Such details cannot be addressed
within the scope of this document. Further, the coverage value computed for a
fragment of some primitive may depend on the primitive’s relationship to a num-
berofgridsquaresneighboringtheonecorrespondingtothefragment,andnotjust
on the fragment’s grid square. Another consideration is that accurate calculation
of coverage values may be computationally expensive; consequently we allow a
given GL implementation to approximate true coverage values by using a fast but
notentirelyaccuratecoveragecomputation.
In light of these considerations, we chose to specify the behavior of exact an-
tialiasing in the prototypical case that each displayed pixel is a perfect square of
Version2.1-December1,20063.2. ANTIALIASING 93
uniformintensity. Thesquareiscalledafragmentsquareandhaslowerleftcorner
(x,y)andupperrightcorner(x+1,y+1). Werecognizethatthissimplebox?lter
may not produce the most favorable antialiasing results, but it provides a simple,
well-de?nedmodel.
A GL implementation may use other methods to perform antialiasing, subject
tothefollowingconditions:
1. Iff andf aretwofragments,andtheportionoff coveredbysomeprim-
1 2 1
itiveisasubsetofthecorrespondingportionoff coveredbytheprimitive,
2
then the coverage computed for f must be less than or equal to that com-
1
putedforf .
2
2. The coverage computation for a fragment f must be local: it may depend
onlyonf’srelationshiptotheboundaryoftheprimitivebeingrasterized. It
maynotdependonf’sxandy coordinates.
Anotherpropertythatisdesirable,butnotrequired,is:
3. The sum of the coverage values for all fragments produced by rasterizing a
particular primitive must be constant, independent of any rigid motions in
window coordinates, as long as none of those fragments lies along window
edges.
Insomeimplementations, varying degreesofantialiasingqualitymay beobtained
by providing GL hints (section 5.6), allowing a user to make an image quality
versusspeedtradeoff.
3.2.1 Multisampling
Multisampling is a mechanism to antialias all GL primitives: points, lines, poly-
gons,bitmaps,andimages. Thetechniqueistosampleallprimitivesmultipletimes
at each pixel. The color sample values are resolved to a single, displayable color
each time a pixel is updated, so the antialiasing appears to be automatic at the
applicationlevel. Becauseeachsampleincludescolor,depth,andstencilinforma-
tion, the color (including texture operation), depth, and stencil functions perform
equivalentlytothesingle-samplemode.
Anadditionalbuffer,calledthemultisamplebuffer,isaddedtotheframebuffer.
Pixel sample values, including color, depth, and stencil values, are stored in this
buffer. Samples contain separate color values for each fragment color. When
the framebuffer includes a multisample buffer, it does not include depth or sten-
cil buffers, even if the multisample buffer does not store depth or stencil values.
Version2.1-December1,200694 CHAPTER3. RASTERIZATION
Color buffers (left, right, front, back, and aux) do coexist with the multisample
buffer,however.
Multisample antialiasing is most valuable for rendering polygons, because it
requiresnosortingforhiddensurfaceelimination,anditcorrectlyhandlesadjacent
polygons, object silhouettes, and even intersecting polygons. If only points or
lines are being rendered, the “smooth” antialiasing mechanism provided by the
base GL may result in a higher quality image. This mechanism is designed to
allow multisample and smooth antialiasing techniques to be alternated during the
renderingofasinglescene.
If the value of SAMPLE BUFFERS is one, the rasterization of all primi-
tives is changed, and is referred to as multisample rasterization. Otherwise,
primitive rasterization is referred to as single-sample rasterization. The value
of SAMPLE BUFFERS is queried by calling GetIntegerv with pname set to
SAMPLE BUFFERS.
During multisample rendering the contents of a pixel fragment are changed
in two ways. First, each fragment includes a coverage value with SAMPLES bits.
ThevalueofSAMPLESisanimplementation-dependentconstant,andisqueriedby
callingGetIntegervwith pnamesettoSAMPLES.
Second, each fragment includesSAMPLES depth values, color values, and sets
of texture coordinates, instead of the single depth value, color value, and set of
texturecoordinatesthatismaintainedinsingle-samplerenderingmode. Animple-
mentation may choose to assign the same color value and the same set of texture
coordinates to more than one sample. The location for evaluating the color value
and the set of texture coordinates can be anywhere within the pixel including the
fragmentcenteroranyofthesamplelocations. Thecolorvalueandthesetoftex-
ture coordinates need not be evaluated at the same location. Each pixel fragment
thusconsistsofintegerxandygridcoordinates,SAMPLEScoloranddepthvalues,
SAMPLES sets of texture coordinates, and a coverage value with a maximum of
SAMPLESbits.
Multisample rasterization is enabled or disabled by callingEnable orDisable
withthesymbolicconstantMULTISAMPLE.
If MULTISAMPLE is disabled, multisample rasterization of all primitives is
equivalent to single-sample (fragment-center) rasterization, except that the frag-
ment coverage value is set to full coverage. The color and depth values and the
sets of texture coordinates may all be set to the values that would have been as-
signedbysingle-samplerasterization,ortheymaybeassignedasdescribedbelow
formultisamplerasterization.
IfMULTISAMPLEisenabled,multisamplerasterizationofallprimitivesdiffers
substantially from single-sample rasterization. It is understood that each pixel in
the framebuffer has SAMPLES locations associated with it. These locations are
Version2.1-December1,20063.3. POINTS 95
exact positions, rather than regions or areas, and each is referred to as a sample
point. The sample points associated with a pixel may be located inside or outside
of the unit square that is considered to bound the pixel. Furthermore, the relative
locations of sample points may be identical for each pixel in the framebuffer, or
theymaydiffer.
If the sample locations differ per pixel, they should be aligned to window, not
screen, boundaries. Otherwise rendering results will be window-position speci?c.
The invariance requirement described in section 3.1 is relaxed for all multisample
rasterization,becausethesamplelocationsmaybeafunctionofpixellocation.
Itisnotpossibletoquerytheactualsamplelocationsofapixel.
3.3 Points
Ifavertexshaderisnotactive,thentherasterizationofpointsiscontrolledwith
void PointSize(float size);
size speci?es the requested size of a point. The default value is 1.0. A value less
thanorequaltozeroresultsintheerrorINVALID VALUE.
The requested point size is multiplied with a distance attenuation factor,
clampedtoaspeci?edpointsizerange,andfurtherclampedtotheimplementation-
dependentpointsizerangetoproducethederivedpointsize:
s
 !
 
1
derived size =clamp size?
2
a+b?d+c?d
wheredistheeye-coordinatedistancefromtheeye, (0,0,0,1)ineyecoordinates,
tothevertex,anda,b,andcaredistanceattenuationfunctioncoef?cients.
Ifmultisamplingisnotenabled,thederivedsizeispassedontorasterizationas
thepointwidth.
If a vertex shader is active and vertex program point size mode is enabled,
then the derived point size is taken from the (potentially clipped) shader builtin
gl PointSizeandclampedtotheimplementation-dependentpointsizerange. If
the value written togl PointSize is less than or equal to zero, results are unde-
?ned. If a vertex shader is active and vertex program point size mode is disabled,
then the derived point size is taken from the point size state as speci?ed by the
PointSizecommand. Inthiscasenodistanceattenuationisperformed. Vertexpro-
gram point size mode is enabled and disabled by calling Enable or Disable with
thesymbolicvalueVERTEX PROGRAM POINT SIZE.
Version2.1-December1,200696 CHAPTER3. RASTERIZATION
If multisampling is enabled, an implementation may optionally fade the point
alpha (see section 3.13) instead of allowing the point width to go below a given
threshold. Inthiscase,thewidthoftherasterizedpointis
(
derived size derived size?threshold
width = (3.1)
threshold otherwise
andthefadefactoriscomputedasfollows:
?
?
1 derived size?threshold
 
2
fade = (3.2)
derived size
?
otherwise
threshold
Thedistanceattenuationfunctioncoef?cientsa,b,andc,theboundsofthe?rst
pointsizerangeclamp,andthepointfadethreshold,arespeci?edwith
void PointParameter{if}(enum pname,T param);
void PointParameter{if}v(enum pname,const T params);
If pname is POINT SIZE MIN or POINT SIZE MAX, then param speci-
?es, or params points to the lower or upper bound respectively to which
the derived point size is clamped. If the lower bound is greater than
the upper bound, the point size after clamping is unde?ned. If pname is
POINT DISTANCE ATTENUATION, then params points to the coef?cients a, b,
and c. If pname is POINT FADE THRESHOLD SIZE, then param speci?es,
or params points to the point fade threshold. Values of POINT SIZE MIN,
POINT SIZE MAX, or POINT FADE THRESHOLD SIZE less than zero result in the
errorINVALID VALUE.
PointantialiasingisenabledordisabledbycallingEnableorDisablewiththe
symbolic constantPOINT SMOOTH. The default state is for point antialiasing to be
disabled.
Point sprites are enabled or disabled by calling Enable or Disable with the
symbolic constant POINT SPRITE. The default state is for point sprites to be dis-
abled. When point sprites are enabled, the state of the point antialiasing enable is
ignored.
ThepointspritetexturecoordinatereplacementmodeissetwithoneoftheTex-
Env* commands described in section 3.8.13, where target is POINT SPRITE and
pname is COORD REPLACE. The possible values for param are FALSE and TRUE.
The default value for each texture coordinate set is for point sprite texture coordi-
natereplacementtobedisabled.
The point sprite texture coordinate origin is set with the PointParame-
ter* commands where pname is POINT SPRITE COORD ORIGIN and param is
LOWER LEFTorUPPER LEFT.ThedefaultvalueisUPPER LEFT.
Version2.1-December1,20063.3. POINTS 97
3.3.1 BasicPointRasterization
In the default state, a point is rasterized by truncating its x and y coordinates
w w
(recall that the subscripts indicate that these are x and y window coordinates) to
integers. This (x,y) address, along with data derived from the data associated
with the vertex corresponding to the point, is sent as a single fragment to the per-
fragmentstageoftheGL.
Theeffectofapointwidthotherthan1.0dependsonthestateofpointantialias-
ingandpointsprites. Ifantialiasingandpointspritesaredisabled,theactualwidth
is determined by rounding the supplied width to the nearest integer, then clamp-
ing it to the implementation-dependent maximum non-antialiased point width.
This implementation-dependent value must be no less than the implementation-
dependentmaximumantialiasedpointwidth,roundedtothenearestintegervalue,
andinanyeventnolessthan1. Ifroundingthespeci?edwidthresultsinthevalue
0,thenitisasifthevaluewere1. Iftheresultingwidthisodd,thenthepoint
1 1
(x,y) = (bx c+ ,by c+ )
w w
2 2
is computed from the vertex’sx andy , and a square grid of the odd width cen-
w w
tered at (x,y) de?nes the centers of the rasterized fragments (recall that fragment
centerslieathalf-integerwindowcoordinatevalues). Ifthewidthiseven,thenthe
centerpointis
1 1
(x,y) = (bx + c,by + c);
w w
2 2
the rasterized fragment centers are the half-integer window coordinate values
withinthesquareoftheevenwidthcenteredon(x,y). See?gure3.2.
Version2.1-December1,200698 CHAPTER3. RASTERIZATION
5.5
4.5
     
           
3.5
     
2.5
1.5
0.5
0.5 1.5 2.5 3.5 4.5 5.5 0.5 1.5 2.5 3.5 4.5 5.5
Odd Width Even Width
Figure3.2. Rasterizationofnon-antialiasedwidepoints. Thecrossesshowfragment
centers produced by rasterization for any point that lies within the shaded region.
Thedottedgridlineslieonhalf-integercoordinates.
Version2.1-December1,20063.3. POINTS 99
6.0
5.0
                             
                             
                             
                             
4.0
                             
                             
                             
                             
3.0
                             
                             
                             
                             
2.0
                             
                             
                             
                             
1.0
0.0
0.0 1.0 2.0 3.0 4.0 5.0 6.0
Figure 3.3. Rasterization of antialiased wide points. The black dot indicates the
point to be rasterized. The shaded region has the speci?ed width. The X marks
indicate those fragment centers produced by rasterization. A fragment’s computed
coverage value is based on the portion of the shaded region that covers the corre-
spondingfragmentsquare. Solidlineslieonintegercoordinates.
Version2.1-December1,2006100 CHAPTER3. RASTERIZATION
All fragments produced in rasterizing a non-antialiased point are assigned the
sameassociateddata,whicharethoseofthevertexcorrespondingtothepoint.
Ifantialiasingisenabledandpointspritesaredisabled,thenpointrasterization
producesafragmentforeachfragmentsquarethatintersectstheregionlyingwithin
the circle having diameter equal to the current point width and centered at the
point’s(x ,y )(?gure3.3). Thecoveragevalueforeachfragmentisthewindow
w w
coordinate area of the intersection of the circular region with the corresponding
fragment square (but see section 3.2). This value is saved and used in the ?nal
step of rasterization (section 3.12). The data associated with each fragment are
otherwisethedataassociatedwiththepointbeingrasterized.
Not all widths need be supported when point antialiasing is on, but the width
1.0 must be provided. If an unsupported width is requested, the nearest supported
width is used instead. The range of supported widths and the width of evenly-
spacedgradationswithinthatrangeareimplementationdependent. Therangeand
gradationsmaybeobtainedusingthequerymechanismdescribedinchapter6. If,
forinstance,thewidthrangeisfrom0.1to2.0andthegradationwidthis0.1,then
thewidths0.1,0.2,...,1.9,2.0aresupported.
If point sprites are enabled, then point rasterization produces a fragment for
each framebuffer pixel whose center lies inside a square centered at the point’s
(x ,y ),withsidelengthequaltothecurrentpointsize.
w w
All fragments produced in rasterizing a point sprite are assigned the same as-
sociated data, which are those of the vertex corresponding to the point. How-
ever, for each texture coordinate set where COORD REPLACE is TRUE, these
texture coordinates are replaced with point sprite texture coordinates. The s
coordinate varies from 0 to 1 across the point horizontally left-to-right. If
POINT SPRITE COORD ORIGIN is LOWER LEFT, the t coordinate varies from 0
to 1 vertically bottom-to-top. Otherwise if the point sprite texture coordinate ori-
gin is UPPER LEFT, the t coordinate varies from 0 to 1 vertically top-to-bottom.
Ther andq coordinatesarereplacedwiththeconstants0and1,respectively.
Thefollowingformulaisusedtoevaluatethesandtcoordinates:
 
1
x + ?x
f w
1 2
s = + (3.3)
2 size
?
1
y + ?y
( f w)
?
1 2
+ ,POINT SPRITE COORD ORIGIN = LOWER LEFT
2 size
t =
1
y + ?y
( w)
? f
1 2
? ,POINT SPRITE COORD ORIGIN = UPPER LEFT
2 size
(3.4)
wheresize is the point’s size,x andy are the (integral) window coordinates of
f f
Version2.1-December1,20063.4. LINESEGMENTS 101
the fragment, andx andy are the exact, unrounded window coordinates of the
w w
vertexforthepoint.
The widths supported for point sprites must be a superset of those supported
for antialiased points. There is no requirement that these widths must be equally
spaced. If an unsupported width is requested, the nearest supported width is used
instead.
3.3.2 PointRasterizationState
Thestaterequiredtocontrolpointrasterizationconsistsofthe?oating-pointpoint
width,three?oating-pointvaluesspecifyingtheminimumandmaximumpointsize
andthepointfadethresholdsize,three?oating-pointvaluesspecifyingthedistance
attenuationcoef?cients,abitindicatingwhetherornotantialiasingisenabled,abit
forthepointspritetexturecoordinatereplacementmodeforeachtexturecoordinate
set,andabitforthepointspritetexturecoordinateorigin.
3.3.3 PointMultisampleRasterization
IfMULTISAMPLEisenabled,andthevalueofSAMPLE BUFFERSisone,thenpoints
arerasterizedusingthefollowingalgorithm,regardlessofwhetherpointantialias-
ing (POINT SMOOTH) is enabled or disabled. Point rasterization produces a frag-
ment for each framebuffer pixel with one or more sample points that intersect a
region centered at the point’s (x ,y ). This region is a circle having diameter
w w
equal to the current point width if POINT SPRITE is disabled, or a square with
side equal to the current point width if POINT SPRITE is enabled. Coverage bits
thatcorrespondtosamplepointsthatintersecttheregionare1,othercoveragebits
are 0. All data associated with each sample for the fragment are the data associ-
atedwiththepointbeingrasterized,withtheexceptionoftexturecoordinateswhen
POINT SPRITEisenabled;thesetexturecoordinatesarecomputedasdescribedin
section3.3.
Point size range and number of gradations are equivalent to those supported
for antialiased points when POINT SPRITE is disabled. The set of point sizes
supported is equivalent to those for point sprites without multisample when
POINT SPRITEisenabled.
3.4 LineSegments
A line segment results from a line strip Begin/End object, a line loop, or a se-
ries of separate line segments. Line segment rasterization is controlled by several
variables. Linewidth,whichmaybesetbycalling
Version2.1-December1,2006102 CHAPTER3. RASTERIZATION
void LineWidth(float width);
with an appropriate positive ?oating-point width, controls the width of rasterized
line segments. The default width is 1.0. Values less than or equal to 0.0 generate
the error INVALID VALUE. Antialiasing is controlled with Enable and Disable
usingthesymbolicconstantLINE SMOOTH.Finally,linesegmentsmaybestippled.
StipplingiscontrolledbyaGLcommandthatsetsa stipple pattern(seebelow).
3.4.1 BasicLineSegmentRasterization
Line segment rasterization begins by characterizing the segment as either x-major
or y-major . x-major line segments have slope in the closed interval [?1,1]; all
other line segments arey-major (slope is determined by the segment’s endpoints).
Weshallspecifyrasterizationonlyforx-majorsegmentsexceptincaseswherethe
modi?cationsfory-majorsegmentsarenotself-evident.
Ideally, the GL uses a “diamond-exit” rule to determine those fragments that
areproducedbyrasterizingalinesegment. Foreachfragmentf withcenteratwin-
dowcoordinatesx andy ,de?neadiamond-shapedregionthatistheintersection
f f
offourhalfplanes:
R ={(x,y)||x?x|+|y?y|< 1/2.}
f f f
Essentially,alinesegmentstartingatp andendingatp producesthosefrag-
a b
mentsf forwhichthesegmentintersectsR ,exceptifp iscontainedinR . See
f b f
?gure3.4.
Toavoiddif?cultieswhenanendpointliesonaboundaryofR we(inprinci-
f
ple) perturb the supplied endpoints by a tiny amount. Letp andp have window
a b
0
coordinates (x ,y ) and (x ,y ), respectively. Obtain the perturbed endpointsp
a a b b
a
2 0 2
given by (x ,y )?(, ) andp given by (x ,y )?(, ). Rasterizing the line
a a b b
b
segment starting atp and ending atp produces those fragmentsf for which the
a b
0 0 0
segmentstartingatp andendingonp intersectsR ,exceptifp iscontainedin
f
a
b b
R .  is chosen to be so small that rasterizing the line segment produces the same
f
fragmentswhen? issubstitutedforforany0<??.
When p and p lie on fragment centers, this characterization of fragments
a b
reduces to Bresenham’s algorithm with one modi?cation: lines produced in this
descriptionare“half-open,”meaningthatthe?nalfragment(correspondingto p )
b
isnotdrawn. Thismeansthatwhenrasterizingaseriesofconnectedlinesegments,
sharedendpointswillbeproducedonlyonceratherthantwice(aswouldoccurwith
Bresenham’salgorithm).
Becausetheinitialand?nalconditionsofthediamond-exitrulemaybedif?cult
to implement, other line segment rasterization algorithms are allowed, subject to
thefollowingrules:
Version2.1-December1,20063.4. LINESEGMENTS 103
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
                                                 
Figure 3.4. Visualization of Bresenham’s algorithm. A portion of a line segment is
shown. Adiamondshapedregionofheight1isplacedaroundeachfragmentcenter;
thoseregionsthatthelinesegmentexitscauserasterizationtoproducecorrespond-
ingfragments.
1. Thecoordinatesofafragmentproducedbythealgorithmmaynotdeviateby
morethanoneunitineitherxorywindowcoordinatesfromacorresponding
fragmentproducedbythediamond-exitrule.
2. The total number of fragments produced by the algorithm may differ from
thatproducedbythediamond-exitrulebynomorethanone.
3. Foranx-majorline, notwofragmentsmaybeproducedthatlieinthesame
window-coordinate column (for a y-major line, no two fragments may ap-
pearinthesamerow).
4. Iftwolinesegmentsshareacommonendpoint,andbothsegmentsareeither
x-major(bothleft-to-rightorbothright-to-left)or y-major(bothbottom-to-
top or both top-to-bottom), then rasterizing both segments may not produce
duplicate fragments, nor may any fragments be omitted so as to interrupt
continuityoftheconnectedsegments.
Next we must specify how the data associated with each rasterized fragment
are obtained. Let the window coordinates of a produced fragment center be given
byp = (x ,y )andletp = (x ,y )andp = (x ,y ). Set
r d d a a a b b b
Version2.1-December1,2006104 CHAPTER3. RASTERIZATION
(p ?p )·(p ?p )
r a b a
t = . (3.5)
2
kp ?pk
b a
(Note that t = 0 atp and t = 1 atp .) The value of an associated datum f for
a b
the fragment, whether it be primary or secondary R, G, B, or A (in RGBA mode)
or a color index (in color index mode), the fog coordinate, an s, t, r, or q texture
coordinate,ortheclipw coordinate,isfoundas
(1?t)f /w +tf /w
a a b b
f = (3.6)
(1?t)/w +t/w
a
b
where f and f are the data associated with the starting and ending endpoints of
a b
thesegment,respectively;w andw aretheclipw coordinatesofthestartingand
a b
ending endpoints of the segments, respectively. However, depth values for lines
mustbeinterpolatedby
z = (1?t)z +tz (3.7)
a b
where z and z are the depth values of the starting and ending endpoints of the
a b
segment,respectively.
3.4.2 OtherLineSegment Features
We have just described the rasterization of non-antialiased line segments of width
one using the default line stipple of FFFF . We now describe the rasterization
16
oflinesegmentsforgeneralvaluesofthelinesegmentrasterizationparameters.
LineStipple
Thecommand
void LineStipple(int factor,ushort pattern);
de?nesa line stipple. patternisanunsignedshortinteger. The line stippleistaken
from the lowest order 16 bits of pattern. It determines those fragments that are
to be drawn when the line is rasterized. factor is a count that is used to modify
theeffectivelinestipplebycausingeachbitin line stippletobeused factortimes.
factor isclampedtotherange[1,256]. Linestipplingmaybeenabledordisabled
usingEnableorDisablewiththeconstantLINE STIPPLE.Whendisabled,itisas
ifthelinestipplehasitsdefaultvalue.
Line stippling masks certain fragments that are produced by rasterization so
thattheyarenotsenttotheper-fragmentstageoftheGL.Themaskingisachieved
Version2.1-December1,20063.4. LINESEGMENTS 105
using three parameters: the 16-bit line stipple p, the line repeat count r, and an
integerstipplecounters. Let
b =bs/rc mod 16,
Then a fragment is produced if the bth bit of p is 1, and not produced otherwise.
The bits of p are numbered with 0 being the least signi?cant and 15 being the
most signi?cant. The initial value of s is zero; s is incremented after production
of each fragment of a line segment (fragments are produced in order, beginning at
the starting point and working towards the ending point). s is reset to 0 whenever
aBeginoccurs,andbeforeeverylinesegmentinagroupofindependentsegments
(asspeci?edwhenBeginisinvokedwithLINES).
Ifthelinesegmenthasbeenclipped,thenthevalueofsatthebeginningofthe
linesegmentisindeterminate.
WideLines
The actual width of non-antialiased lines is determined by rounding the supplied
width to the nearest integer, then clamping it to the implementation-dependent
maximum non-antialiased line width. This implementation-dependent value must
be no less than the implementation-dependent maximum antialiased line width,
rounded to the nearest integer value, and in any event no less than 1. If rounding
thespeci?edwidthresultsinthevalue0,thenitisasifthevaluewere1.
Non-antialiased line segments of width other than one are rasterized by off-
setting them in the minor direction (for an x-major line, the minor direction is
y, and for a y-major line, the minor direction is x) and replicating fragments in
the minor direction (see ?gure 3.5). Let w be the width rounded to the nearest
integer (if w = 0, then it is as if w = 1). If the line segment has endpoints
given by (x ,y ) and (x ,y ) in window coordinates, the segment with endpoints
0 0 1 1
(x ,y ?(w?1)/2)and(x ,y ?(w?1)/2)israsterized,butinsteadofasingle
0 0 1 1
fragment, a column of fragments of heightw (a row of fragments of lengthw for
a y-major segment) is produced at each x (y for y-major) location. The lowest
fragmentofthiscolumnisthefragmentthatwouldbeproducedbyrasterizingthe
segment of width 1 with the modi?ed coordinates. The whole column is not pro-
duced if the stipple bit for the column’s x location is zero; otherwise, the whole
columnisproduced.
Antialiasing
Rasterized antialiased line segments produce fragments whose fragment squares
intersectarectanglecenteredonthelinesegment. Twooftheedgesareparallelto
Version2.1-December1,2006106 CHAPTER3. RASTERIZATION
width = 2 width = 3
Figure 3.5. Rasterization of non-antialiased wide lines. x-major line segments are
shown. The heavy line segment is the one speci?ed to be rasterized; the light seg-
ment is the offset segment used for rasterization. x marks indicate the fragment
centersproducedbyrasterization.
thespeci?edlinesegment; eachisatadistanceofone-halfthecurrentwidthfrom
that segment: one above the segment and one below it. The other two edges pass
through the line endpoints and are perpendicular to the direction of the speci?ed
line segment. Coverage values are computed for each fragment by computing the
area of the intersection of the rectangle with the fragment square (see ?gure 3.6;
seealsosection3.2). Equation3.6isusedtocomputeassociateddatavaluesjustas
withnon-antialiasedlines;equation 3.5isusedto?ndthevalueoftforeachfrag-
ment whose square is intersected by the line segment’s rectangle. Not all widths
needbesupportedforlinesegmentantialiasing,butwidth1.0antialiasedsegments
must be provided. As with the point width, a GL implementation may be queried
fortherangeandnumberofgradationsofavailableantialiasedlinewidths.
For purposes of antialiasing, a stippled line is considered to be a sequence of
contiguousrectanglescenteredonthelinesegment. Eachrectanglehaswidthequal
tothecurrentlinewidthandlengthequalto1pixel(exceptthelast,whichmaybe
shorter). These rectangles are numbered from 0 to n, starting with the rectangle
incident on the starting endpoint of the segment. Each of these rectangles is ei-
ther eliminated or produced according to the procedure given under LineStipple,
above,where“fragment”isreplacedwith“rectangle.” Eachrectanglesoproduced
Version2.1-December1,20063.4. LINESEGMENTS 107
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
                                       
Figure 3.6. The region used in rasterizing and ?nding corresponding coverage val-
uesforanantialiasedlinesegment(anx-majorlinesegmentisshown).
israsterizedasifitwereanantialiasedpolygon,describedbelow(butculling,non-
defaultsettingsofPolygonMode,andpolygonstipplingarenotapplied).
3.4.3 LineRasterizationState
The state required for line rasterization consists of the ?oating-point line width, a
16-bit line stipple, the line stipple repeat count, a bit indicating whether stippling
is enabled or disabled, and a bit indicating whether line antialiasing is on or off.
In addition, during rasterization, an integer stipple counter must be maintained to
implementlinestippling. Theinitialvalueofthelinewidthis1.0. Theinitialvalue
of the line stipple is FFFF (a stipple of all ones). The initial value of the line
16
stipplerepeatcountisone. Theinitialstateoflinestipplingisdisabled. Theinitial
stateoflinesegmentantialiasingisdisabled.
3.4.4 LineMultisampleRasterization
IfMULTISAMPLEisenabled,andthevalueofSAMPLE BUFFERSisone,thenlines
arerasterizedusingthefollowingalgorithm,regardlessofwhetherlineantialiasing
(LINE SMOOTH)isenabledordisabled. Linerasterizationproducesafragmentfor
eachframebufferpixelwithoneormoresamplepointsthatintersecttherectangular
region that is described in the Antialiasing portion of section 3.4.2 (Other Line
Segment Features). Iflinestipplingisenabled,therectangularregionissubdivided
Version2.1-December1,2006108 CHAPTER3. RASTERIZATION
into adjacent unit-length rectangles, with some rectangles eliminated according to
theproceduregiveninsection3.4.2,where“fragment”isreplacedby“rectangle”.
Coveragebitsthatcorrespondtosamplepointsthatintersectaretainedrectan-
gleare1,othercoveragebitsare0. Eachcolor,depth,andsetoftexturecoordinates
is produced by substituting the corresponding sample location into equation 3.5,
then using the result to evaluate equation 3.7. An implementation may choose to
assign the same color value and the same set of texture coordinates to more than
one sample by evaluating equation 3.5 at any location within the pixel including
thefragmentcenteroranyoneofthesamplelocations,thensubstitutingintoequa-
tion 3.6. The color value and the set of texture coordinates need not be evaluated
atthesamelocation.
Line width range and number of gradations are equivalent to those supported
forantialiasedlines.
3.5 Polygons
A polygon results from a polygon Begin/End object, a triangle resulting from a
triangle strip, triangle fan, or series of separate triangles, or a quadrilateral arising
from a quadrilateral strip, series of separate quadrilaterals, or a Rect command.
Like points and line segments, polygon rasterization is controlled by several vari-
ables. Polygon antialiasing is controlled with Enable and Disable with the sym-
bolic constant POLYGON SMOOTH. The analog to line segment stippling for poly-
gonsispolygonstippling,describedbelow.
3.5.1 BasicPolygonRasterization
The?rststepofpolygonrasterizationistodetermineifthepolygonis back facing
orfrontfacing. Thisdeterminationismadebyexaminingthesignoftheareacom-
putedbyequation2.6ofsection2.14.1(includingthepossiblereversalofthissign
as indicated by the last call to FrontFace). If this sign is positive, the polygon is
frontfacing;otherwise,itisbackfacing. Thisdeterminationisusedinconjunction
withtheCullFaceenablebitandmodevaluetodecidewhetherornotaparticular
polygonisrasterized. TheCullFacemodeissetbycalling
void CullFace(enum mode);
mode is a symbolic constant: one of FRONT, BACK or FRONT AND BACK. Culling
is enabled or disabled with Enable or Disable using the symbolic constant
CULL FACE. Front facing polygons are rasterized if either culling is disabled or
Version2.1-December1,20063.5. POLYGONS 109
the CullFace mode is BACK while back facing polygons are rasterized only if ei-
ther culling is disabled or the CullFace mode is FRONT. The initial setting of the
CullFacemodeisBACK.Initially,cullingisdisabled.
The rule for determining which fragments are produced by polygon rasteriza-
tion is called point sampling. The two-dimensional projection obtained by taking
the x and y window coordinates of the polygon’s vertices is formed. Fragment
centers that lie inside of this polygon are produced by rasterization. Special treat-
ment is given to a fragment whose center lies on a polygon boundary edge. In
such a case we require that if two polygons lie on either side of a common edge
(with identical endpoints) on which a fragment center lies, then exactly one of the
polygonsresultsintheproductionofthefragmentduringrasterization.
As for the data associated with each fragment produced by rasterizing a poly-
gon, we begin by specifying how these values are produced for fragments in a
triangle. De?nebarycentriccoordinatesforatriangle. Barycentriccoordinatesare
a set of three numbers, a, b, and c, each in the range [0,1], with a +b +c = 1.
These coordinates uniquely specify any pointp within the triangle or on the trian-
gle’sboundaryas
p =ap +bp +cp ,
a b c
wherep ,p ,andp aretheverticesofthetriangle. a,b,andccanbefoundas
a b c
A(pp p ) A(pp p ) A(pp p )
b c a c a b
a = , b = , c = ,
A(p p p ) A(p p p ) A(p p p )
a b c a b c a b c
whereA(lmn)denotestheareainwindowcoordinatesofthetrianglewithvertices
l,m,andn.
Denoteanassociateddatumatp ,p ,orp asf ,f ,orf ,respectively. Then
a b c a b c
thevaluef ofadatumatafragmentproducedbyrasterizingatriangleisgivenby
af /w +bf /w +cf /w
a a b b c c
f = (3.8)
a/w +b/w +c/w
a b c
where w , w and w are the clip w coordinates of p , p , and p , respectively.
a c a c
b b
a, b, and c are the barycentric coordinates of the fragment for which the data are
produced. a, b, and c must correspond precisely to the exact coordinates of the
center of the fragment. Another way of saying this is that the data associated with
a fragment must be sampled at the fragment’s center. However, depth values for
polygonsmustbeinterpolatedby
z =az +bz +cz ,
a b c
wherez ,z ,andz arethedepthvaluesofp ,p ,andp ,respectively.
a b c a b c
Version2.1-December1,2006110 CHAPTER3. RASTERIZATION
Forapolygonwithmorethanthreeedges,werequireonlythataconvexcom-
bination of the values of the datum at the polygon’s vertices can be used to obtain
the value assigned to each fragment produced by the rasterization algorithm. That
is,itmustbethecasethatateveryfragment
n
X
f = a f
i i
i=1
wheren is the number of vertices in the polygon,f is the value of thef at vertex
i
P
n
i; for each i 0? a ? 1 and a = 1. The values of the a may differ from
i i i
i=1
fragmenttofragment,butatvertexi,a = 0,j6=ianda = 1.
j i
One algorithm that achieves the required behavior is to triangulate a polygon
(without adding any vertices) and then treat each triangle individually as already
discussed. A scan-line rasterizer that linearly interpolates data along each edge
and then linearly interpolates data across each horizontal span from edge to edge
alsosatis?estherestrictions(inthiscase,thenumeratoranddenominatorofequa-
tion 3.8 should be iterated independently and a division performed for each frag-
ment).
3.5.2 Stippling
Polygonstipplingworksmuchthesamewayaslinestippling,maskingoutcertain
fragments produced by rasterization so that they are not sent to the next stage of
theGL.Thisisthecaseregardlessofthestateofpolygonantialiasing. Stipplingis
controlledwith
void PolygonStipple(ubyte *pattern);
patternisapointertomemoryintowhicha32?32patternispacked. Thepattern
is unpacked from memory according to the procedure given in section 3.6.4 for
DrawPixels;itisasiftheheightandwidthpassedtothatcommandwerebothequal
to 32, the type were BITMAP, and the format were COLOR INDEX. The unpacked
values (before any conversion or arithmetic would have been performed) form a
stipplepatternofzerosandones.
If x and y are the window coordinates of a rasterized polygon fragment,
w w
then that fragment is sent to the next stage of the GL if and only if the bit of the
pattern(x mod 32,y mod 32)is1.
w w
Polygon stippling may be enabled or disabled with Enable or Disable using
theconstantPOLYGON STIPPLE.Whendisabled,itisasifthestipplepatternwere
allones.
Version2.1-December1,20063.5. POLYGONS 111
3.5.3 Antialiasing
Polygon antialiasing rasterizes a polygon by producing a fragment wherever the
interiorofthepolygonintersectsthatfragment’ssquare. Acoveragevalueiscom-
puted at each such fragment, and this value is saved to be applied as described
in section 3.12. An associated datum is assigned to a fragment by integrating the
datum’s value over the region of the intersection of the fragment square with the
polygon’sinterioranddividingthisintegratedvaluebytheareaoftheintersection.
Forafragmentsquarelyingentirelywithinthepolygon,thevalueofadatumatthe
fragment’scentermaybeusedinsteadofintegratingthevalueacrossthefragment.
Polygon stippling operates in the same way whether polygon antialiasing is
enabledornot. Thepolygonpointsamplingrulede?nedinsection3.5.1,however,
isnotenforcedforantialiasedpolygons.
3.5.4 OptionsControllingPolygonRasterization
Theinterpretationofpolygonsforrasterizationiscontrolledusing
void PolygonMode(enum face,enum mode);
face is one of FRONT, BACK, or FRONT AND BACK, indicating that the rasterizing
method described by mode replaces the rasterizing method for front facing poly-
gons, back facing polygons, or both front and back facing polygons, respectively.
mode is one of the symbolic constants POINT, LINE, or FILL. Calling Polygon-
ModewithPOINTcausescertainverticesofapolygontobetreated,forrasteriza-
tion purposes, just as if they were enclosed within a Begin(POINT) and End pair.
Theverticesselectedforthistreatmentarethosethathavebeentaggedashavinga
polygonboundaryedgebeginningonthem(seesection2.6.2). LINEcausesedges
that are tagged as boundary to be rasterized as line segments. (The line stipple
counter is reset at the beginning of the ?rst rasterized edge of the polygon, but
notforsubsequentedges.) FILListhedefaultmodeofpolygonrasterization,cor-
responding to the description in sections 3.5.1, 3.5.2, and 3.5.3. Note that these
modesaffectonlythe?nalrasterizationofpolygons: inparticular,apolygon’sver-
ticesarelit,andthepolygonisclippedandpossiblyculledbeforethesemodesare
applied.
Polygon antialiasing applies only to the FILL state of PolygonMode. For
POINT or LINE, point antialiasing or line segment antialiasing, respectively, ap-
ply.
Version2.1-December1,2006112 CHAPTER3. RASTERIZATION
3.5.5 DepthOffset
The depth values of all fragments generated by the rasterization of a polygon may
be offset by a single value that is computed for that polygon. The function that
determinesthisvalueisspeci?edbycalling
void PolygonOffset(float factor,float units);
factor scales the maximum depth slope of the polygon, and units scales an im-
plementation dependent constant that relates to the usable resolution of the depth
buffer. Theresultingvaluesaresummedtoproducethepolygonoffsetvalue. Both
factorand unitsmaybeeitherpositiveornegative.
Themaximumdepthslopemofatriangleis
s
   
2 2
?z ?z
w w
m = + (3.9)
?x ?y
w w
where(x ,y ,z )isapointonthetriangle. mmaybeapproximatedas
w w w
   
 
   
?z ?z
w w
   
m = max , . (3.10)
   
?x ?y
w w
Ifthe polygonhasmore thanthree vertices, oneor morevaluesofmmaybe used
duringrasterization. Eachmaytakeanyvalueintherange[min,max],wheremin
andmaxarethesmallestandlargestvaluesobtainedbyevaluatingequation3.9or
equation3.10forthetrianglesformedbyallthree-vertexcombinations.
The minimum resolvable differencer is an implementation constant. It is the
smallest difference in window coordinate z values that is guaranteed to remain
distinctthroughoutpolygonrasterizationandinthedepthbuffer. Allpairsoffrag-
mentsgeneratedbytherasterizationoftwopolygonswithotherwiseidenticalver-
tices,butz valuesthatdifferbyr,willhavedistinctdepthvalues.
w
Theoffsetvalueoforapolygonis
o =m?factor+r?units. (3.11)
miscomputedasdescribedabove,asafunctionofdepthvaluesintherange[0,1],
andoisappliedtodepthvaluesinthesamerange.
BooleanstatevaluesPOLYGON OFFSET POINT,POLYGON OFFSET LINE,and
POLYGON OFFSET FILL determine whether o is applied during the rasterization
of polygons in POINT, LINE, and FILL modes. These boolean state values are
enabledanddisabledasargumentvaluestothecommandsEnableandDisable. If
POLYGON OFFSET POINT is enabled, o is added to the depth value of each frag-
ment produced by the rasterization of a polygon in POINT mode. Likewise, if
Version2.1-December1,20063.5. POLYGONS 113
POLYGON OFFSET LINE or POLYGON OFFSET FILL is enabled, o is added to the
depth value of each fragment produced by the rasterization of a polygon in LINE
orFILLmodes,respectively.
Fragmentdepthvaluesarealwayslimitedtotherange[0,1],eitherbyclamping
afteroffsetadditionisperformed(preferred),orbyclampingthevertexvaluesused
intherasterizationofthepolygon.
3.5.6 PolygonMultisampleRasterization
IfMULTISAMPLEisenabledandthevalueofSAMPLE BUFFERSisone, thenpoly-
gons are rasterized using the following algorithm, regardless of whether polygon
antialiasing(POLYGON SMOOTH)isenabledordisabled. Polygonrasterizationpro-
duces a fragment for each framebuffer pixel with one or more sample points that
satisfy the point sampling criteria described in section 3.5.1, including the special
treatment for sample points that lie on a polygon boundary edge. If a polygon is
culled,basedonitsorientationandtheCullFacemode,thennofragmentsarepro-
ducedduringrasterization. Fragmentsareculledbythepolygonstipplejustasthey
areforaliasedandantialiasedpolygons.
Coverage bits that correspond to sample points that satisfy the point sampling
criteria are 1, other coverage bits are 0. Each color, depth, and set of texture co-
ordinates is produced by substituting the corresponding sample location into the
barycentric equations described in section 3.5.1, using the approximation to equa-
tion 3.8 that omits w components. An implementation may choose to assign the
same color value and the same set of texture coordinates to more than one sample
bybarycentricevaluationusinganylocationwiththepixelincludingthefragment
center or one of the sample locations. The color value and the set of texture coor-
dinatesneednotbeevaluatedatthesamelocation.
The rasterization described above applies only to the FILL state of Polygon-
Mode. For POINT and LINE, the rasterizations described in sections 3.3.3 (Point
MultisampleRasterization)and 3.4.4(LineMultisampleRasterization)apply.
3.5.7 PolygonRasterizationState
The state required for polygon rasterization consists of a polygon stipple pattern,
whether stippling is enabled or disabled, the current state of polygon antialiasing
(enabled or disabled), the current values of the PolygonMode setting for each of
front and back facing polygons, whether point, line, and ?ll mode polygon offsets
are enabled or disabled, and the factor and bias values of the polygon offset equa-
tion. Theinitialstipplepatternisallones;initiallystipplingisdisabled. Theinitial
setting of polygon antialiasing is disabled. The initial state for PolygonMode is
Version2.1-December1,2006114 CHAPTER3. RASTERIZATION
FILL for both front and back facing polygons. The initial polygon offset factor
andbiasvaluesareboth0;initiallypolygonoffsetisdisabledforallmodes.
3.6 PixelRectangles
Rectanglesofcolor,depth,andcertainothervaluesmaybeconvertedtofragments
using the DrawPixels command (described in section 3.6.4). Some of the param-
eters and operations governing the operation of DrawPixels are shared by Read-
Pixels(usedtoobtainpixelvaluesfromtheframebuffer)andCopyPixels(usedto
copypixelsfromoneframebufferlocationtoanother);thediscussionofReadPix-
els and CopyPixels, however, is deferred until chapter 4 after the framebuffer has
been discussed in detail. Nevertheless, we note in this section when parameters
andstatepertainingtoDrawPixelsalsopertaintoReadPixelsorCopyPixels.
A number of parameters control the encoding of pixels in buffer object or
clientmemory (forreadingandwriting)andhowpixelsareprocessedbeforebeing
placedinorafterbeingreadfromtheframebuffer(forreading, writing, andcopy-
ing). These parameters are set with three commands: PixelStore, PixelTransfer,
andPixelMap.
3.6.1 PixelStorageModesandPixelBufferObjects
PixelstoragemodesaffecttheoperationofDrawPixelsandReadPixels(aswellas
other commands; see sections 3.5.2, 3.7, and 3.8) when one of these commands is
issued. Thismaydifferfromthetimethatthecommandisexecutedifthecommand
isplacedinadisplaylist(seesection5.4). Pixelstoragemodesaresetwith
void PixelStore{if}(enum pname,T param);
pname is a symbolic constant indicating a parameter to be set, and param is the
value to set it to. Table 3.1 summarizes the pixel storage parameters, their types,
their initial values, and their allowable ranges. Setting a parameter to a value out-
sidethegivenrangeresultsintheerrorINVALID VALUE.
The version of PixelStore that takes a ?oating-point value may be used to
set any type of parameter; if the parameter is boolean, then it is set to FALSE if
the passed value is 0.0 and TRUE otherwise, while if the parameter is an integer,
then the passed value is rounded to the nearest integer. The integer version of
the command may also be used to set any type of parameter; if the parameter is
boolean,thenitissettoFALSEifthepassedvalueis0andTRUEotherwise,while
if the parameter is a ?oating-point value, then the passed value is converted to
?oating-point.
Version2.1-December1,20063.6. PIXELRECTANGLES 115
ParameterName Type InitialValue ValidRange
UNPACK SWAP BYTES boolean FALSE TRUE/FALSE
UNPACK LSB FIRST boolean FALSE TRUE/FALSE
UNPACK ROW LENGTH integer 0 [0,?)
UNPACK SKIP ROWS integer 0 [0,?)
UNPACK SKIP PIXELS integer 0 [0,?)
UNPACK ALIGNMENT integer 4 1,2,4,8
UNPACK IMAGE HEIGHT integer 0 [0,?)
UNPACK SKIP IMAGES integer 0 [0,?)
Table 3.1: PixelStore parameters pertaining to one or more of DrawPixels, Col-
orTable, ColorSubTable, ConvolutionFilter1D, ConvolutionFilter2D, Separa-
bleFilter2D, PolygonStipple, TexImage1D, TexImage2D, TexImage3D, Tex-
SubImage1D,TexSubImage2D,andTexSubImage3D.
In addition to storing pixel data in client memory, pixel data may also
be stored in buffer objects (described in section 2.9). The current pixel un-
pack and pack buffer objects are designated by the PIXEL UNPACK BUFFER and
PIXEL PACK BUFFERtargetsrespectively.
Initially, zero is bound for the PIXEL UNPACK BUFFER, indicating that image
speci?cation commands such asDrawPixels source their pixels from clientmem-
orypointerparameters. However,ifanon-zerobufferobjectisboundasthecurrent
pixel unpack buffer, then the pointer parameter is treated as an offset into the des-
ignatedbufferobject.
3.6.2 TheImagingSubset
Some pixel transfer and per-fragment operations are only made available in GL
implementations which incorporate the optional imaging subset. The imaging
subset includes both new commands, and new enumerants allowed as parame-
ters to existing commands. If the subset is supported, all of these calls and enu-
merants must be implemented as described later in the GL speci?cation. If the
subset is not supported, calling any unsupported command generates the error
INVALID OPERATION, and using any of the new enumerants generates the error
INVALID ENUM.
Theindividualoperationsavailableonlyintheimagingsubsetaredescribedin
section3.6.3. Imagingsubsetoperationsinclude:
1. Color tables, including all commands and enumerants described in sub-
Version2.1-December1,2006116 CHAPTER3. RASTERIZATION
sections Color Table Specification, Alternate Color Table Specification
Commands, Color Table State and Proxy State, Color Table Lookup,
PostConvolutionColorTableLookup,andPostColorMatrixColorTa-
bleLookup,aswellasthequerycommandsdescribedinsection6.1.7.
2. Convolution, including all commands and enumerants described in sub-
sections Convolution Filter Specification, Alternate Convolution Filter
Specification Commands, and Convolution, as well as the query com-
mandsdescribedinsection6.1.8.
3. Color matrix, including all commands and enumerants described in subsec-
tions Color Matrix Specification and Color Matrix Transformation, as
wellasthesimplequerycommandsdescribedinsection6.1.6.
4. Histogram and minmax, including all commands and enumerants described
in subsections Histogram Table Specification, Histogram State and
Proxy State, Histogram, Minmax Table Specification, and Minmax, as
wellasthequerycommandsdescribedinsection6.1.9andsection6.1.10.
The imaging subset is supported only if the EXTENSIONS string includes
the substring "GL ARB imaging". Querying EXTENSIONS is described in sec-
tion6.1.11.
If the imaging subset is not supported, the related pixel transfer operations are
notperformed;pixelsarepassedunchangedtothenextoperation.
3.6.3 PixelTransferModes
PixeltransfermodesaffecttheoperationofDrawPixels(section3.6.4),ReadPix-
els (section 4.3.2), and CopyPixels (section 4.3.3) at the time when one of these
commands is executed (which may differ from the time the command is issued).
Somepixeltransfermodesaresetwith
void PixelTransfer{if}(enum param,T value);
paramisasymbolicconstantindicatingaparametertobeset,andvalueisthevalue
to set it to. Table 3.2 summarizes the pixel transfer parameters that are set with
PixelTransfer, their types, their initial values, and their allowable ranges. Setting
aparametertoavalueoutsidethegivenrangeresultsintheerrorINVALID VALUE.
The same versions of the command exist as for PixelStore, and the same rules
applytoacceptingandconvertingpassedvaluestosetparameters.
Thepixelmaplookuptablesaresetwith
Version2.1-December1,20063.6. PIXELRECTANGLES 117
ParameterName Type InitialValue ValidRange
MAP COLOR boolean FALSE TRUE/FALSE
MAP STENCIL boolean FALSE TRUE/FALSE
INDEX SHIFT integer 0 (??,?)
INDEX OFFSET integer 0 (??,?)
x SCALE ?oat 1.0 (??,?)
DEPTH SCALE ?oat 1.0 (??,?)
x BIAS ?oat 0.0 (??,?)
DEPTH BIAS ?oat 0.0 (??,?)
POST CONVOLUTION x SCALE ?oat 1.0 (??,?)
POST CONVOLUTION x BIAS ?oat 0.0 (??,?)
POST COLOR MATRIX x SCALE ?oat 1.0 (??,?)
POST COLOR MATRIX x BIAS ?oat 0.0 (??,?)
Table3.2: PixelTransferparameters. xisRED,GREEN,BLUE,orALPHA.
void PixelMap{uiusf}v(enum map,sizei size,T values);
map is a symbolic map name, indicating the map to set, size indicates the size of
themap, and valuesreferstoanarrayof sizemapvalues
The entries of a table may be speci?ed using one of three types: single-
precision?oating-point, unsignedshortinteger, orunsignedinteger, dependingon
which of the three versions of PixelMap is called. A table entry is converted
to the appropriate type when it is speci?ed. An entry giving a color component
value is converted according to table 2.9. An entry giving a color index value
is converted from an unsigned short integer or unsigned integer to ?oating-point.
An entry giving a stencil index is converted from single-precision ?oating-point
to an integer by rounding to nearest. The various tables and their initial sizes
and entries are summarized in table 3.3. A table that takes an index as an ad-
n
dress must have size = 2 or the error INVALID VALUE results. The maximum
allowable size of each table is speci?ed by the implementation dependent value
MAX PIXEL MAP TABLE, but must be at least 32 (a single maximum applies to all
tables). The error INVALID VALUE is generated if a size larger than the imple-
mentedmaximum,orlessthanone,isgiventoPixelMap.
If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), values is an offset into the pixel unpack
buffer; otherwise, valuesisapointertoclientmemory. Allpixelstorageandpixel
transfermodesareignoredwhenspecifyingapixelmap. nmachineunitsareread
wherenisthesizeofthepixelmaptimesthesizeofafloat,uint,orushort
Version2.1-December1,2006118 CHAPTER3. RASTERIZATION
MapName Address Value Init. Size Init. Value
PIXEL MAP I TO I coloridx coloridx 1 0.0
PIXEL MAP S TO S stencilidx stencilidx 1 0
PIXEL MAP I TO R coloridx R 1 0.0
PIXEL MAP I TO G coloridx G 1 0.0
PIXEL MAP I TO B coloridx B 1 0.0
PIXEL MAP I TO A coloridx A 1 0.0
PIXEL MAP R TO R R R 1 0.0
PIXEL MAP G TO G G G 1 0.0
PIXEL MAP B TO B B B 1 0.0
PIXEL MAP A TO A A A 1 0.0
Table3.3: PixelMapparameters.
datum in basic machine units, depending on the respective PixelMap version. If
a pixel unpack buffer object is bound anddata+n is greater than the size of the
pixelbuffer,anINVALID OPERATIONerrorresults. Ifapixelunpackbufferobject
is bound and values is not evenly divisible by the number of basic machine units
neededtostoreinmemoryafloat,uint,orushortdatumdependingontheir
respectivePixelMapversion,anINVALID OPERATIONerrorresults.
ColorTableSpecification
Colorlookuptablesarespeci?edwith
void ColorTable(enum target,enum internalformat,
sizei width,enum format,enum type,void *data);
target must be one of the regular color table names listed in table 3.4 to de?ne
the table. A proxy table name is a special case discussed later in this section.
width, format, type, and data specify an image in memory with the same mean-
ing and allowed values as the corresponding arguments to DrawPixels (see sec-
tion 3.6.4), with height taken to be 1. The maximum allowable width of a table
isimplementation-dependent,butmustbeatleast32. The formatsCOLOR INDEX,
DEPTH COMPONENT,andSTENCIL INDEXandthe typeBITMAParenotallowed.
Thespeci?edimageistakenfrommemoryandprocessedjustasifDrawPixels
werecalled,stoppingafterthe?nalexpansiontoRGBA.TheR,G,B,andAcom-
ponentsofeachpixelarethenscaledbythefourCOLOR TABLE SCALEparameters,
Version2.1-December1,20063.6. PIXELRECTANGLES 119
TableName Type
COLOR TABLE regular
POST CONVOLUTION COLOR TABLE
POST COLOR MATRIX COLOR TABLE
PROXY COLOR TABLE proxy
PROXY POST CONVOLUTION COLOR TABLE
PROXY POST COLOR MATRIX COLOR TABLE
Table 3.4: Color table names. Regular tables have associated image data. Proxy
tableshavenoimagedata,andareusedonlytodetermineifanimagecanbeloaded
intothecorrespondingregulartable.
biased by the four COLOR TABLE BIAS parameters, and clamped to [0,1]. These
parametersaresetbycallingColorTableParameterfvasdescribedbelow.
Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format speci?ed by (or derived from) inter-
nalformat, inthesamemannerasfortextures(section3.8.1). internalformatmust
be one of the formats in table 3.15 or table 3.16, other than the DEPTH formats in
thosetables.
The color lookup table is rede?ned to have width entries, each with the speci-
?ed internal format. The table is formed with indices 0 throughwidth?1. Table
locationiisspeci?edbytheithimagepixel,countingfromzero.
The error INVALID VALUE is generated if width is not zero or a non-negative
power of two. The error TABLE TOO LARGE is generated if the speci?ed color
lookuptableistoolargefortheimplementation.
Thescaleandbiasparametersforatablearespeci?edbycalling
void ColorTableParameter{if}v(enum target,enum pname,
T params);
target must be a regular color table name. pname is one of COLOR TABLE SCALE
orCOLOR TABLE BIAS.paramspointstoanarrayoffourvalues: red,green,blue,
andalpha,inthatorder.
AGLimplementationmayvaryitsallocationofinternalcomponentresolution
based on any ColorTable parameter, but the allocation must not be a function of
any other factor, and cannot be changed once it is established. Allocations must
beinvariant; thesameallocationmustbemadeeachtimeacolortableisspeci?ed
with the same parameter values. These allocation rules also apply to proxy color
tables,whicharedescribedlaterinthissection.
Version2.1-December1,2006120 CHAPTER3. RASTERIZATION
AlternateColorTableSpecificationCommands
Colortablesmayalsobespeci?edusingimagedatatakendirectlyfromtheframe-
buffer,andportionsofexistingtablesmayberespeci?ed.
Thecommand
void CopyColorTable(enum target,enum internalformat,
int x,int y,sizei width);
de?nes a color table in exactly the manner of ColorTable, except that table data
are taken from the framebuffer, rather than from client memory. target must be a
regularcolortablename. x,y,andwidthcorrespondpreciselytothecorresponding
arguments of CopyPixels (refer to section 4.3.3); they specify the image’s width
and the lower left (x,y) coordinates of the framebuffer region to be copied. The
image is taken from the framebuffer exactly as if these arguments were passed to
CopyPixelswithargumenttypesettoCOLORandheightsetto1,stoppingafterthe
?nalexpansiontoRGBA.
SubsequentprocessingisidenticaltothatdescribedforColorTable,beginning
withscalingbyCOLOR TABLE SCALE.Parameterstarget,internalformatandwidth
are speci?ed using the same values, with the same meanings, as the equivalent
argumentsofColorTable. formatistakentobeRGBA.
Twoadditionalcommands,
void ColorSubTable(enum target,sizei start,sizei count,
enum format,enum type,void *data);
void CopyColorSubTable(enum target,sizei start,int x,
int y,sizei count);
respecifyonlyaportionofanexistingcolortable. Nochangeismadetothe inter-
nalformator widthparametersofthespeci?edcolortable,norisanychangemade
to table entries outside the speci?ed portion. target must be a regular color table
name.
ColorSubTableargumentsformat,type,anddatamatchthecorrespondingar-
guments to ColorTable, meaning that they are speci?ed using the same values,
andhavethesamemeanings. Likewise,CopyColorSubTablearguments x, y,and
countmatchthex,y,andwidthargumentsofCopyColorTable. BothoftheColor-
SubTable commands interpret and process pixel groups in exactly the manner of
theirColorTable counterparts, except that the assignment of R, G, B, and A pixel
group values to the color table components is controlled by the internalformat of
thetable,notbyanargumenttothecommand.
Version2.1-December1,20063.6. PIXELRECTANGLES 121
ArgumentsstartandcountofColorSubTableandCopyColorSubTablespec-
ify a subregion of the color table starting at index start and ending at index
start + count? 1. Counting from zero, the nth pixel group is assigned to the
table entry with index count + n. The error INVALID VALUE is generated if
start+count>width.
ColorTableStateandProxyState
The state necessary for color tables can be divided into two categories. For each
of the three tables, there is an array of values. Each array has associated with it
a width, an integer describing the internal format of the table, six integer values
describing the resolutions of each of the red, green, blue, alpha, luminance, and
intensitycomponentsofthetable,andtwogroupsoffour?oating-pointnumbersto
storethetablescaleandbias. Eachinitialarrayisnull(zerowidth,internalformat
RGBA, with zero-sized components). The initial value of the scale parameters is
(1,1,1,1)andtheinitialvalueofthebiasparametersis(0,0,0,0).
Inadditiontothecolorlookuptables,partiallyinstantiatedproxycolorlookup
tables are maintained. Each proxy table includes width and internal format state
values, as well as state for the red, green, blue, alpha, luminance, and intensity
component resolutions. Proxy tables do not include image data, nor do they in-
clude scale and bias parameters. When ColorTable is executed with target speci-
?edasoneoftheproxycolortablenameslistedintable3.4,theproxystatevalues
ofthetablearerecomputedandupdated. Ifthetableistoolarge,noerrorisgener-
ated,buttheproxyformat,widthandcomponentresolutionsaresettozero. Ifthe
color table would be accommodated by ColorTable called with target set to the
corresponding regular table name (COLOR TABLE is the regular name correspond-
ing to PROXY COLOR TABLE, for example), the proxy state values are set exactly
asthoughtheregulartablewerebeingspeci?ed. CallingColorTablewithaproxy
targethasnoeffectontheimageorstateofanyactualcolortable.
There is no image associated with any of the proxy targets. They cannot be
used as color tables, and they must never be queried using GetColorTable. The
errorINVALID ENUMisgeneratedifthisisattempted.
ConvolutionFilterSpecification
Atwo-dimensionalconvolution?lterimageisspeci?edbycalling
void ConvolutionFilter2D(enum target,enum internalformat,
sizei width,sizei height,enum format,enum type,
void *data);
Version2.1-December1,2006122 CHAPTER3. RASTERIZATION
targetmustbeCONVOLUTION 2D. width, height, format, type,and dataspecifyan
imageinmemorywiththesamemeaningandallowedvaluesasthecorresponding
parameters to DrawPixels. The formats COLOR INDEX, DEPTH COMPONENT, and
STENCIL INDEXandthe typeBITMAParenotallowed.
The speci?ed image is extracted from memory and processed just as if
DrawPixels were called, stopping after the ?nal expansion to RGBA. The
R, G, B, and A components of each pixel are then scaled by the four two-
dimensional CONVOLUTION FILTER SCALE parameters and biased by the four
two-dimensional CONVOLUTION FILTER BIASparameters. Theseparametersare
set by calling ConvolutionParameterfv as described below. No clamping takes
placeatanytimeduringthisprocess.
Components are then selected from the resulting R, G, B, and A values to
obtain a table with the base internal format speci?ed by (or derived from) inter-
nalformat, inthesamemannerasfortextures(section3.8.1). internalformatmust
be one of the formats in table 3.15 or table 3.16, other than the DEPTH formats in
thosetables.
The red, green, blue, alpha, luminance, and/or intensity components of the
pixels are stored in ?oating point, rather than integer format. They form a two-
dimensional image indexed with coordinatesi,j such thati increases from left to
right, starting at zero, and j increases from bottom to top, also starting at zero.
Imagelocationi,j isspeci?edbytheNthpixel,countingfromzero,where
N =i+j?width
The error INVALID VALUE is generated if width or height is greater
than the maximum supported value. These values are queried with Get-
ConvolutionParameteriv, setting target to CONVOLUTION 2D and pname to
MAX CONVOLUTION WIDTHorMAX CONVOLUTION HEIGHT,respectively.
The scale and bias parameters for a two-dimensional ?lter are speci?ed by
calling
void ConvolutionParameter{if}v(enum target,enum pname,
T params);
with target CONVOLUTION 2D. pname is one of CONVOLUTION FILTER SCALE
or CONVOLUTION FILTER BIAS. params points to an array of four values: red,
green,blue,andalpha,inthatorder.
Aone-dimensionalconvolution?lterisde?nedusing
void ConvolutionFilter1D(enum target,enum internalformat,
sizei width,enum format,enum type,void *data);
Version2.1-December1,20063.6. PIXELRECTANGLES 123
target must be CONVOLUTION 1D. internalformat, width, format, and type have
identical semantics and accept the same values as do their two-dimensional coun-
terparts. datamustpointtoaone-dimensionalimage,however.
TheimageisextractedfrommemoryandprocessedasifConvolutionFilter2D
were called with a height of 1, except that it is scaled and biased by the one-
dimensional CONVOLUTION FILTER SCALE and CONVOLUTION FILTER BIAS
parameters. These parameters are speci?ed exactly as the two-dimensional
parameters, except that ConvolutionParameterfv is called with target
CONVOLUTION 1D.
Theimageisformedwithcoordinatesisuchthatiincreasesfromlefttoright,
startingatzero. Imagelocationiisspeci?edbytheithpixel,countingfromzero.
The error INVALID VALUE is generated if width is greater than the maximum
supportedvalue. ThisvalueisqueriedusingGetConvolutionParameteriv,setting
targettoCONVOLUTION 1Dand pnametoMAX CONVOLUTION WIDTH.
Special facilities are provided for the de?nition of two-dimensional sepa-
rable ?lters – ?lters whose image can be represented as the product of two
one-dimensional images, rather than as full two-dimensional images. A two-
dimensionalseparableconvolution?lterisspeci?edwith
void SeparableFilter2D(enum target,enum internalformat,
sizei width,sizei height,enum format,enum type,
void *row,void *column);
target must be SEPARABLE 2D. internalformat speci?es the formats of the table
entries of the two one-dimensional images that will be retained. row points to a
widthpixelwideimageofthespeci?ed formatand type. columnpointstoa height
pixelhighimage,alsoofthespeci?ed formatand type.
The two images are extracted from memory and processed as if Convolu-
tionFilter1D were called separately for each, except that each image is scaled
and biased by the two-dimensional separable CONVOLUTION FILTER SCALE and
CONVOLUTION FILTER BIASparameters. These parametersare speci?edexactly
astheone-dimensionalandtwo-dimensionalparameters,exceptthat Convolution-
Parameteriviscalledwith targetSEPARABLE 2D.
AlternateConvolutionFilterSpecificationCommands
One and two-dimensional ?lters may also be speci?ed using image data taken di-
rectlyfromtheframebuffer.
Thecommand
Version2.1-December1,2006124 CHAPTER3. RASTERIZATION
void CopyConvolutionFilter2D(enum target,
enum internalformat,int x,int y,sizei width,
sizei height);
de?nes a two-dimensional ?lter in exactly the manner of ConvolutionFilter2D,
exceptthatimagedataaretakenfromtheframebuffer,ratherthanfromclientmem-
ory. targetmustbeCONVOLUTION 2D.x,y,width,andheightcorrespondprecisely
tothecorrespondingargumentsofCopyPixels(refertosection4.3.3);theyspecify
the image’s width and height, and the lower left (x,y) coordinates of the frame-
buffer region to be copied. The image is taken from the framebuffer exactly as
if these arguments were passed to CopyPixels with argument type set to COLOR,
stoppingafterthe?nalexpansiontoRGBA.
SubsequentprocessingisidenticaltothatdescribedforConvolutionFilter2D,
beginning with scaling by CONVOLUTION FILTER SCALE. Parameters target, in-
ternalformat, width,and heightarespeci?edusingthesamevalues,withthesame
meanings,astheequivalentargumentsofConvolutionFilter2D.formatistakento
beRGBA.
Thecommand
void CopyConvolutionFilter1D(enum target,
enum internalformat,int x,int y,sizei width);
de?nes a one-dimensional ?lter in exactly the manner of ConvolutionFilter1D,
exceptthatimagedataaretakenfromtheframebuffer,ratherthanfromclientmem-
ory. target must beCONVOLUTION 1D. x, y, and width correspond precisely to the
corresponding arguments of CopyPixels (refer to section 4.3.3); they specify the
image’s width and the lower left (x,y) coordinates of the framebuffer region to
be copied. The image is taken from the framebuffer exactly as if these arguments
were passed to CopyPixels with argument type set to COLOR and height set to 1,
stoppingafterthe?nalexpansiontoRGBA.
SubsequentprocessingisidenticaltothatdescribedforConvolutionFilter1D,
beginning with scaling by CONVOLUTION FILTER SCALE. Parameters target, in-
ternalformat, and width are speci?ed using the same values, with the same mean-
ings, as the equivalent arguments of ConvolutionFilter2D. format is taken to be
RGBA.
ConvolutionFilterState
The required state for convolution ?lters includes a one-dimensional image array,
two one-dimensional image arrays for the separable ?lter, and a two-dimensional
imagearray. Each?lterhasassociatedwithitawidthandheight(two-dimensional
Version2.1-December1,20063.6. PIXELRECTANGLES 125
andseparableonly), anintegerdescribingtheinternalformatofthe?lter, andtwo
groupsoffour?oating-pointnumberstostorethe?lterscaleandbias.
Each initial convolution ?lter is null (zero width and height, internal format
RGBA, with zero-sized components). The initial value of all scale parameters is
(1,1,1,1)andtheinitialvalueofallbiasparametersis(0,0,0,0).
ColorMatrixSpecification
Setting the matrix mode to COLOR causes the matrix operations described in sec-
tion 2.11.2 to apply to the top matrix on the color matrix stack. All matrix opera-
tionshavethesameeffectonthecolormatrixastheydoontheothermatrices.
HistogramTableSpecification
Thehistogramtableisspeci?edwith
void Histogram(enum target,sizei width,
enum internalformat,boolean sink);
target must be HISTOGRAM if a histogram table is to be speci?ed. target value
PROXY HISTOGRAM is a special case discussed later in this section. width speci-
?es the number of entries in the histogram table, and internalformat speci?es the
format of each table entry. The maximum allowable width of the histogram table
is implementation-dependent, but must be at least 32. sink speci?es whether pixel
groups will be consumed by the histogram operation (TRUE) or passed on to the
minmaxoperation(FALSE).
If no error results from the execution of Histogram, the speci?ed histogram
table is rede?ned to have width entries, each with the speci?ed internal format.
Theentriesareindexed0throughwidth?1. Eachcomponentineachentryisset
tozero. Thevaluesintheprevioushistogramtable,ifany,arelost.
The error INVALID VALUE is generated if width is not zero or a non-negative
poweroftwo. TheerrorTABLE TOO LARGEisgeneratedifthespeci?edhistogram
tableistoolargefortheimplementation. TheerrorINVALID ENUMisgeneratedif
internalformat is not one of the formats in table 3.15 or table 3.16, or is 1, 2, 3, 4,
oranyoftheDEPTHorINTENSITYformatsinthosetables.
AGLimplementationmayvaryitsallocationofinternalcomponentresolution
basedonanyHistogramparameter,buttheallocationmustnotbeafunctionofany
otherfactor,andcannotbechangedonceitisestablished. Inparticular,allocations
must be invariant; the same allocation must be made each time a histogram is
speci?ed with the same parameter values. These allocation rules also apply to the
proxyhistogram,whichisdescribedlaterinthissection.
Version2.1-December1,2006126 CHAPTER3. RASTERIZATION
HistogramStateandProxyState
The state necessary for histogram operation is an array of values, with which is
associated a width, an integer describing the internal format of the histogram, ?ve
integer values describing the resolutions of each of the red, green, blue, alpha,
and luminance components of the table, and a ?ag indicating whether or not pixel
groupsareconsumedbytheoperation. Theinitialarrayisnull(zerowidth,internal
formatRGBA,withzero-sizedcomponents). Theinitialvalueofthe?agisfalse.
Inadditiontothehistogramtable,apartiallyinstantiatedproxyhistogramtable
is maintained. It includes width, internal format, and red, green, blue, alpha, and
luminancecomponentresolutions. Theproxytabledoesnotincludeimagedataor
the ?ag. When Histogram is executed with target set to PROXY HISTOGRAM, the
proxystatevaluesarerecomputedandupdated. Ifthehistogramarrayistoolarge,
no error is generated, but the proxy format, width, and component resolutions are
set to zero. If the histogram table would be accomodated by Histogram called
with target set to HISTOGRAM, the proxy state values are set exactly as though
the actual histogram table were being speci?ed. Calling Histogram with target
PROXY HISTOGRAMhasnoeffectontheactualhistogramtable.
There is no image associated with PROXY HISTOGRAM. It cannot be used as
a histogram, and its image must never queried using GetHistogram. The error
INVALID ENUMresultsifthisisattempted.
MinmaxTableSpecification
Theminmaxtableisspeci?edwith
void Minmax(enum target,enum internalformat,
boolean sink);
target must be MINMAX. internalformat speci?es the format of the table entries.
sink speci?es whether pixel groups will be consumed by the minmax operation
(TRUE)orpassedonto?nalconversion(FALSE).
The error INVALID ENUM is generated if internalformat is not one of the for-
matsintable3.15ortable3.16,oris1,2,3,4,oranyoftheDEPTHorINTENSITY
formats in those tables. The resulting table always has 2 entries, each with values
correspondingonlytothecomponentsoftheinternalformat.
The state necessary for minmax operation is a table containing two elements
(the ?rst element stores the minimum values, the second stores the maximum val-
ues), an integer describing the internal format of the table, and a ?ag indicating
whether or not pixel groups are consumed by the operation. The initial state is
a minimum table entry set to the maximum representable value and a maximum
Version2.1-December1,20063.6. PIXELRECTANGLES 127
table entry set to the minimum representable value. Internal format is set toRGBA
andtheinitialvalueofthe?agisfalse.
3.6.4 RasterizationofPixelRectangles
The process of drawing pixels encoded in buffer object or client memory is dia-
grammedin?gure3.7. Wedescribethestagesofthisprocessintheorderinwhich
theyoccur.
Pixelsaredrawnusing
void DrawPixels(sizei width,sizei height,enum format,
enum type,void *data);
format is a symbolic constant indicating what the values in memory represent.
width and height are the width and height, respectively, of the pixel rectangle to
be drawn. data refers to the data to be drawn. The correspondence between
the twenty type token values and the GL data types they indicate is given in ta-
ble 3.5. If the GL is in color index mode and format is not one of COLOR INDEX,
STENCIL INDEX,orDEPTH COMPONENT,thentheerrorINVALID OPERATIONoc-
curs. If type isBITMAP and format is notCOLOR INDEX orSTENCIL INDEX then
theerrorINVALID ENUMoccurs. Someadditionalconstraintsonthecombinations
of formatand typevaluesthatareacceptedare discussedbelow.
Unpacking
Dataaretakenfrom thecurrentlyboundpixelunpackbufferorclientmemory asa
sequenceofsignedorunsignedbytes(GLdatatypesbyteandubyte),signedor
unsigned short integers (GL data typesshort andushort), signed or unsigned
integers (GL data types int and uint), or ?oating point values (GL data type
float). These elements are grouped into sets of one, two, three, or four values,
depending on the format, to form a group. Table 3.6 summarizes the format of
groups obtained from memory; it also indicates those formats that yield indices
andthosethatyieldcomponents.
If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), data is an offset into the pixel unpack buffer
andthepixelsareunpackedfromthebufferrelativetothisoffset;otherwise,datais
apointertoclientmemoryandthepixelsareunpackedfromclientmemoryrelative
tothepointer. Ifapixelunpackbufferobjectisboundandunpackingthepixeldata
accordingtotheprocessdescribedbelowwouldaccessmemorybeyondthesizeof
thepixelunpackbuffer’smemorysize,anINVALID OPERATIONerrorresults. Ifa
pixelunpackbufferobjectisboundand dataisnotevenlydivisiblebythenumber
Version2.1-December1,2006128 CHAPTER3. RASTERIZATION
byte, short, int, or float pixel
data stream (index or component)
                                                             
                                                             
                                                             
unpack
                                                             
                                                             
RGBA, L color
                                                             
index
                                                             
convert
                          Pixel Storage                                   
to float
                                                             
Operations
                                                             
                                                             
convert
                                                             
L to RGB
                                                             
                                                               
                                                               
                                                               
Pixel Transfer
scale shift
                                                               
Operations
and bias and offset
                                                               
                                                               
                                                               
                                                               
RGBA to RGBA index to RGBA index to index 
                                                               
lookup lookup lookup
                                                               
                                                               
                                                               
color table 
                                                               
lookup
                                                               
                                                               
                                                               
post
                                                               
convolution color table 
color matrix
      scale a      nd bias                  lookup                                 
                                                               
                                                               
                                                               
post color table histogram
                                                               
convolution lookup
                                                               
                                                               
                                                               
                                                               
color matrix minmax
      scale and bias                                                         
                                                               
                                                               
mask to
final
clamp
n
conversion
to [0,1] (2 ? 1)
RGBA pixel
color index pixel
data out data out
Figure3.7. OperationofDrawPixels. OutputisRGBApixelsiftheGLisinRGBA
mode, color index pixels otherwise. Operations in dashed boxes may be enabled
or disabled. RGBA and color index pixel paths are shown; depth and stencil pixel
Version2.1-December1,2006
pathsarenotshown.3.6. PIXELRECTANGLES 129
typeParameter Corresponding Special
TokenName GLDataType Interpretation
UNSIGNED BYTE ubyte No
BITMAP ubyte Yes
BYTE byte No
UNSIGNED SHORT ushort No
SHORT short No
UNSIGNED INT uint No
INT int No
FLOAT float No
UNSIGNED BYTE 3 3 2 ubyte Yes
UNSIGNED BYTE 2 3 3 REV ubyte Yes
UNSIGNED SHORT 5 6 5 ushort Yes
UNSIGNED SHORT 5 6 5 REV ushort Yes
UNSIGNED SHORT 4 4 4 4 ushort Yes
UNSIGNED SHORT 4 4 4 4 REV ushort Yes
UNSIGNED SHORT 5 5 5 1 ushort Yes
UNSIGNED SHORT 1 5 5 5 REV ushort Yes
UNSIGNED INT 8 8 8 8 uint Yes
UNSIGNED INT 8 8 8 8 REV uint Yes
UNSIGNED INT 10 10 10 2 uint Yes
UNSIGNED INT 2 10 10 10 REV uint Yes
Table3.5: DrawPixelsandReadPixelstypeparametervaluesandthecorrespond-
ing GL data types. Refer to table 2.2 for de?nitions of GL data types. Special
interpretationsaredescribedneartheendofsection3.6.4.
Version2.1-December1,2006130 CHAPTER3. RASTERIZATION
FormatName ElementMeaningandOrder TargetBuffer
COLOR INDEX ColorIndex Color
STENCIL INDEX StencilIndex Stencil
DEPTH COMPONENT Depth Depth
RED R Color
GREEN G Color
BLUE B Color
ALPHA A Color
RGB R,G,B Color
RGBA R,G,B,A Color
BGR B,G,R Color
BGRA B,G,R,A Color
LUMINANCE Luminance Color
LUMINANCE ALPHA Luminance,A Color
Table 3.6: DrawPixels and ReadPixels formats. The second column gives a de-
scription of and the number and order of elements in a group. Unless speci?ed as
anindex,formatsyieldcomponents.
ofbasicmachineunitsneededtostoreinmemorythecorrespondingGLdatatype
fromtable3.5forthe typeparameter,anINVALID OPERATIONerrorresults.
By default the values of each GL data type are interpreted as they would be
speci?ed in the language of the client’s GL binding. If UNPACK SWAP BYTES is
enabled, however, then the values are interpreted with the bit orderings modi?ed
as per table 3.7. The modi?ed bit orderings are de?ned only if the GL data type
ubyte has eight bits, and then for each speci?c GL data type only if that type is
representedwith8,16,or32bits.
The groups in memory are treated as being arranged in a rectangle. This
ElementSize DefaultBitOrdering Modi?edBitOrdering
8bit [7..0] [7..0]
16bit [15..0] [7..0][15..8]
32bit [31..0] [7..0][15..8][23..16][31..24]
Table 3.7: Bit ordering modi?cation of elements when UNPACK SWAP BYTES is
enabled. Thesereorderingsarede?nedonlywhenGLdatatypeubytehas8bits,
andthenonlyforGLdatatypeswith8,16,or32bits. Bit0istheleastsigni?cant.
Version2.1-December1,20063.6. PIXELRECTANGLES 131
rectangle consists of a series of rows, with the ?rst element of the ?rst group
of the ?rst row pointed to by the pointer passed to DrawPixels. If the value of
UNPACK ROW LENGTHisnotpositive,thenthenumberofgroupsinarowis width;
otherwise the number of groups is UNPACK ROW LENGTH. If p indicates the loca-
tioninmemoryofthe?rstelementofthe?rstrow,thenthe?rstelementoftheNth
rowisindicatedby
p+Nk (3.12)
whereN istherownumber(countingfromzero)andkisde?nedas
(
nl s?a,
k = (3.13)
a/sdsnl/ae s<a
where n is the number of elements in a group, l is the number of groups in
the row, a is the value of UNPACK ALIGNMENT, and s is the size, in units of GL
ubytes,ofanelement. Ifthenumberofbitsperelementisnot1, 2, 4,or8times
thenumberofbitsinaGLubyte,thenk =nl forallvaluesofa.
There is a mechanism for selecting a sub-rectangle of groups from a
larger containing rectangle. This mechanism relies on three integer parameters:
UNPACK ROW LENGTH, UNPACK SKIP ROWS, and UNPACK SKIP PIXELS. Before
obtainingthe?rstgroupfrommemory,thepointersuppliedtoDrawPixelsiseffec-
tivelyadvancedby(UNPACK SKIP PIXELS)n+(UNPACK SKIP ROWS)kelements.
Thenwidthgroupsareobtainedfromcontiguouselementsinmemory(withoutad-
vancingthepointer),afterwhichthepointerisadvancedbykelements. heightsets
of widthgroupsofvaluesareobtainedthisway. See?gure3.8.
Calling DrawPixels with a type of UNSIGNED BYTE 3 3 2,
UNSIGNED BYTE 2 3 3 REV, UNSIGNED SHORT 5 6 5,
UNSIGNED SHORT 5 6 5 REV, UNSIGNED SHORT 4 4 4 4,
UNSIGNED SHORT 4 4 4 4 REV, UNSIGNED SHORT 5 5 5 1,
UNSIGNED SHORT 1 5 5 5 REV, UNSIGNED INT 8 8 8 8,
UNSIGNED INT 8 8 8 8 REV, UNSIGNED INT 10 10 10 2, or
UNSIGNED INT 2 10 10 10 REV is a special case in which all the compo-
nents of each group are packed into a single unsigned byte, unsigned short, or
unsigned int, depending on the type. The number of components per packed pixel
is?xedbythetype,andmustmatchthenumberofcomponentspergroupindicated
by the format parameter, as listed in table 3.8. The errorINVALID OPERATION is
generated if a mismatch occurs. This constraint also holds for all other functions
thatacceptorreturnpixeldatausing typeand formatparameterstode?nethetype
andformatofthatdata.
Version2.1-December1,2006132 CHAPTER3. RASTERIZATION
ROW_LENGTH
                   
                   
                   
                   
      subimage             
                   
                   
SKIP_PIXELS
                   
SKIP_ROWS
Figure 3.8. Selecting a subimage from an image. The indicated parameter names
arepre?xedbyUNPACK forDrawPixelsandbyPACK forReadPixels.
typeParameter GLData Numberof Matching
TokenName Type Components PixelFormats
UNSIGNED BYTE 3 3 2 ubyte 3 RGB
UNSIGNED BYTE 2 3 3 REV ubyte 3 RGB
UNSIGNED SHORT 5 6 5 ushort 3 RGB
UNSIGNED SHORT 5 6 5 REV ushort 3 RGB
UNSIGNED SHORT 4 4 4 4 ushort 4 RGBA,BGRA
UNSIGNED SHORT 4 4 4 4 REV ushort 4 RGBA,BGRA
UNSIGNED SHORT 5 5 5 1 ushort 4 RGBA,BGRA
UNSIGNED SHORT 1 5 5 5 REV ushort 4 RGBA,BGRA
UNSIGNED INT 8 8 8 8 uint 4 RGBA,BGRA
UNSIGNED INT 8 8 8 8 REV uint 4 RGBA,BGRA
UNSIGNED INT 10 10 10 2 uint 4 RGBA,BGRA
UNSIGNED INT 2 10 10 10 REV uint 4 RGBA,BGRA
Table3.8: Packedpixelformats.
Version2.1-December1,20063.6. PIXELRECTANGLES 133
Bit?eld locations of the ?rst, second, third, and fourth components of each
packed pixel type are illustrated in tables 3.9, 3.10, and 3.11. Each bit?eld is
interpreted as an unsigned integer value. If the base GL type is supported with
more than the minimum precision (e.g. a 9-bit byte) the packed components are
right-justi?edinthepixel.
Components are normally packed with the ?rst component in the most signif-
icant bits of the bit?eld, and successive component occupying progressively less
signi?cantlocations. Typeswhosetokennamesendwith REVreversethecompo-
nent packing order from least to most signi?cant locations. In all cases, the most
signi?cant bit of each component is packed in the most signi?cant bit location of
itslocationinthebit?eld.
UNSIGNED BYTE 3 3 2:
7 6 5 4 3 2 1 0
1stComponent 2nd 3rd
UNSIGNED BYTE 2 3 3 REV:
7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
Table 3.9: UNSIGNED BYTE formats. Bit numbers are indicated for each compo-
nent.
Version2.1-December1,2006134 CHAPTER3. RASTERIZATION
UNSIGNED SHORT 5 6 5:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd
UNSIGNED SHORT 5 6 5 REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
3rd 2nd 1stComponent
UNSIGNED SHORT 4 4 4 4:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED SHORT 4 4 4 4 REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED SHORT 5 5 5 1:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED SHORT 1 5 5 5 REV:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
Table3.10: UNSIGNED SHORTformats
Version2.1-December1,20063.6. PIXELRECTANGLES 135
UNSIGNED INT 8 8 8 8:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED INT 8 8 8 8 REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
UNSIGNED INT 10 10 10 2:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1stComponent 2nd 3rd 4th
UNSIGNED INT 2 10 10 10 REV:
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
4th 3rd 2nd 1stComponent
Table3.11: UNSIGNED INTformats
Version2.1-December1,2006136 CHAPTER3. RASTERIZATION
Format First Second Third Fourth
Component Component Component Component
RGB red green blue
RGBA red green blue alpha
BGRA blue green red alpha
Table3.12: Packedpixel?eldassignments.
The assignment of component to ?elds in the packed pixel is as described in
table3.12.
Byte swapping, if enabled, is performed before the component are extracted
from each pixel. The above discussions of row length and image extraction are
valid for packed pixels, if “group” is substituted for “component” and the number
ofcomponentspergroupisunderstoodtobeone.
Calling DrawPixels with a type ofBITMAP is a special case in which the data
are a series of GL ubyte values. Each ubyte value speci?es 8 1-bit elements
with its 8 least-signi?cant bits. The 8 single-bit elements are ordered from most
signi?canttoleastsigni?cantifthevalueofUNPACK LSB FIRSTisFALSE;other-
wise, the ordering is from least signi?cant to most signi?cant. The values of bits
otherthanthe8leastsigni?cantineachubytearenotsigni?cant.
The?rstelementofthe?rstrowisthe?rstbit(asde?nedabove)oftheubyte
pointed to by the pointer passed to DrawPixels. The ?rst element of the second
rowisthe?rstbit(againasde?nedabove)oftheubyteatlocationp+k, where
k iscomputedas
 
l
k =a (3.14)
8a
Thereisamechanismforselectingasub-rectangleofelementsfroma BITMAP
image as well. Before obtaining the ?rst element from memory, the pointer sup-
plied toDrawPixels is effectively advanced byUNPACK SKIP ROWS?kubytes.
ThenUNPACK SKIP PIXELS1-bitelementsareignored,andthesubsequent width
1-bitelementsareobtained,withoutadvancingthe ubytepointer,afterwhichthe
pointer is advanced byk ubytes. height sets of width elements are obtained this
way.
Conversionto?oating-point
This step applies only to groups of components. It is not performed on indices.
Eachelementinagroupisconvertedtoa?oating-pointvalueaccordingtotheap-
Version2.1-December1,20063.6. PIXELRECTANGLES 137
propriateformulaintable2.9(section2.14). Forpackedpixeltypes,eachelement
N
inthegroupisconvertedbycomputingc/(2 ?1),wherecistheunsignedinte-
ger value of the bit?eld containing the element andN is the number of bits in the
bit?eld.
ConversiontoRGB
ThisstepisappliedonlyiftheformatisLUMINANCEorLUMINANCE ALPHA.Ifthe
format is LUMINANCE, then each group of one element is converted to a group of
R, G, and B (three) elements by copying the original single element into each of
the three new elements. If the format is LUMINANCE ALPHA, then each group of
twoelementsisconvertedtoagroupofR,G,B,andA(four)elementsbycopying
the ?rst original element into each of the ?rst three new elements and copying the
secondoriginalelementtotheA(fourth)newelement.
FinalExpansiontoRGBA
This step is performed only for non-depth component groups. Each group is con-
vertedtoagroupof4elementsasfollows: ifagroupdoesnotcontainanAelement,
thenAisaddedandsetto1.0. IfanyofR,G,orBismissingfromthegroup,each
missingelementisaddedandassignedavalueof0.0.
PixelTransferOperations
This step is actually a sequence of steps. Because the pixel transfer operations
are performed equivalently during the drawing, copying, and reading of pixels,
and during the speci?cation of texture images (either from memory or from the
framebuffer), they are described separately in section 3.6.5. After the processing
described in that section is completed, groups are processed as described in the
followingsections.
FinalConversion
For a color index, ?nal conversion consists of masking the bits of the index to the
n
leftofthebinarypointby2 ?1,wherenisthenumberofbitsinanindexbuffer.
ForRGBAcomponents,eachelementisclampedto[0,1]. Theresultingvaluesare
convertedto?xed-pointaccordingtotherulesgiveninsection 2.14.9(FinalColor
Processing).
Foradepthcomponent,anelementis?rstclampedto[0,1]andthenconverted
to ?xed-point as if it were a window z value (see section 2.11.1, Controlling the
Viewport).
Version2.1-December1,2006138 CHAPTER3. RASTERIZATION
n
Stencil indices are masked by 2 ? 1, where n is the number of bits in the
stencilbuffer.
ConversiontoFragments
Theconversionofagrouptofragmentsiscontrolledwith
void PixelZoom(floatz ,floatz );
x y
Let (x ,y ) be the current raster position (section 2.13). (If the current raster
rp rp
position is invalid, then DrawPixels is ignored; pixel transfer operations do not
updatethehistogramorminmaxtables,andnofragmentsaregenerated. However,
thehistogramandminmaxtablesareupdatedevenifthecorrespondingfragments
are later rejected by the pixel ownership (section 4.1.1) or scissor (section 4.1.2)
tests.) Ifaparticulargroup(indexorcomponents)isthenthinarowandbelongsto
themth row, consider the region in window coordinates bounded by the rectangle
withcorners
(x +z n,y +z m) and (x +z (n+1),y +z (m+1))
rp x rp y rp x rp y
(either z or z may be negative). A fragment representing group (n,m) is pro-
x y
duced for each framebuffer pixel inside, or on the bottom or left boundary, of this
rectangle
A fragment arising from a group consisting of color data takes on the color
indexorcolorcomponentsofthegroupandthecurrentrasterposition’sassociated
depth value, while a fragment arising from a depth component takes that compo-
nent’s depth value and the current raster position’s associated color index or color
components. Inbothcases,thefogcoordinateistakenfromthecurrentrasterposi-
tion’sassociatedrasterdistance,thesecondarycoloristakenfromthecurrentraster
position’s associated secondary color, and texture coordinates are taken from the
currentrasterposition’sassociatedtexturecoordinates. GroupsarisingfromDraw-
Pixelswitha formatofSTENCIL INDEXaretreatedspeciallyandaredescribedin
section4.3.1.
3.6.5 PixelTransferOperations
TheGLde?nesfourkindsofpixelgroups:
1. RGBAcomponent: Eachgroupcomprisesfourcolorcomponents: red,green,
blue,andalpha.
2. Depth component: Eachgroupcomprisesasingledepthcomponent.
Version2.1-December1,20063.6. PIXELRECTANGLES 139
3. Color index: Eachgroupcomprisesasinglecolorindex.
4. Stencil index: Eachgroupcomprisesasinglestencilindex.
Eachoperationdescribedinthissectionisappliedsequentiallytoeachpixelgroup
in an image. Many operations are applied only to pixel groups of certain kinds; if
anoperationisnotapplicabletoagivengroup,itisskipped.
ArithmeticonComponents
This step applies only to RGBA component and depth component groups. Each
component is multiplied by an appropriate signed scale factor: RED SCALE for an
Rcomponent,GREEN SCALEforaGcomponent,BLUE SCALEforaBcomponent,
andALPHA SCALE for an A component, orDEPTH SCALE for a depth component.
Then the result is added to the appropriate signed bias: RED BIAS, GREEN BIAS,
BLUE BIAS,ALPHA BIAS,orDEPTH BIAS.
ArithmeticonIndices
This step applies only to color index and stencil index groups. If the index is a
?oating-point value, it is converted to ?xed-point, with an unspeci?ed number of
bits to the right of the binary point and at leastdlog (MAX PIXEL MAP TABLE)e
2
bits to the left of the binary point. Indices that are already integers remain so; any
fractionbitsintheresulting?xed-pointvaluearezero.
The ?xed-point index is then shifted by |INDEX SHIFT| bits, left if
INDEX SHIFT> 0andrightotherwise. Ineithercasetheshiftiszero-?lled. Then,
thesignedintegeroffsetINDEX OFFSETisaddedtotheindex.
RGBAtoRGBALookup
ThisstepappliesonlytoRGBAcomponentgroups,andisskippedifMAP COLORis
FALSE.First,eachcomponentisclampedtotherange[0,1]. Thereisatableassoci-
atedwitheachoftheR,G,B,andAcomponentelements: PIXEL MAP R TO Rfor
R, PIXEL MAP G TO G for G, PIXEL MAP B TO B for B, and PIXEL MAP A TO A
for A. Each element is multiplied by an integer one less than the size of the corre-
sponding table, and, for each element, an address is found by rounding this value
to the nearest integer. For each element, the addressed value in the corresponding
tablereplacestheelement.
Version2.1-December1,2006140 CHAPTER3. RASTERIZATION
ColorIndexLookup
This step applies only to color index groups. If the GL command that invokes the
pixeltransferoperationrequiresthatRGBAcomponentpixelgroupsbegenerated,
then a conversion is performed at this step. RGBA component pixel groups are
requiredif
1. Thegroupswillberasterized,andtheGLisinRGBAmode,or
2. Thegroupswillbeloadedasanimageintotexturememory,or
3. The groups will be returned to client memory with a format other than
COLOR INDEX.
If RGBA component groups are required, then the integer part of the in-
dex is used to reference 4 tables of color components: PIXEL MAP I TO R,
PIXEL MAP I TO G, PIXEL MAP I TO B, and PIXEL MAP I TO A. Each of these
n
tables must have 2 entries for some integer value of n (n may be different for
each table). For each table, the index is ?rst rounded to the nearest integer; the
n
result is ANDed with 2 ? 1, and the resulting value used as an address into the
table. The indexed value becomes an R, G, B, or A value, as appropriate. The
group of four elements so obtained replaces the index, changing the group’s type
toRGBAcomponent.
If RGBA component groups are not required, and if MAP COLOR is enabled,
then the index is looked up in the PIXEL MAP I TO I table (otherwise, the index
n
is not looked up). Again, the table must have 2 entries for some integer n. The
n
index is ?rst rounded to the nearest integer; the result is ANDed with 2 ?1, and
theresultingvalueusedasanaddressintothetable. Thevalueinthetablereplaces
theindex. The?oating-pointtablevalueis?rstroundedtoa?xed-pointvaluewith
unspeci?edprecision. Thegroup’styperemainscolorindex.
StencilIndexLookup
This step applies only to stencil index groups. If MAP STENCIL is enabled, then
theindexislookedupinthePIXEL MAP S TO Stable(otherwise, theindexisnot
n
looked up). The table must have 2 entries for some integern. The integer index
n
is ANDed with 2 ? 1, and the resulting value used as an address into the table.
Theintegervalueinthetablereplacestheindex.
ColorTableLookup
This step applies only to RGBA component groups. Color table lookup is only
done if COLOR TABLE is enabled. If a zero-width table is enabled, no lookup is
Version2.1-December1,20063.6. PIXELRECTANGLES 141
BaseInternalFormat R G B A
ALPHA A
t
LUMINANCE L L L
t t t
LUMINANCE ALPHA L L L A
t t t t
INTENSITY I I I I
t t t t
RGB R G B
t t t
RGBA R G B A
t t t t
Table 3.13: Color table lookup. R , G , B , A , L , and I are color table values
t t t t t t
that are assigned to pixel components R, G, B, and A depending on the table
format. When there is no assignment, the component value is left unchanged by
lookup.
performed.
The internal format of the table determines which components of the group
will be replaced (see table 3.13). The components to be replaced are converted
to indices by clamping to [0,1], multiplying by an integer one less than the width
of the table, and rounding to the nearest integer. Components are replaced by the
tableentryattheindex.
The required state is one bit indicating whether color table lookup is enabled
ordisabled. Intheinitialstate,lookupisdisabled.
Convolution
This step applies only to RGBA component groups. If CONVOLUTION 1D
is enabled, the one-dimensional convolution ?lter is applied only to the one-
dimensional texture images passed to TexImage1D, TexSubImage1D, Copy-
TexImage1D, and CopyTexSubImage1D. If CONVOLUTION 2D is enabled, the
two-dimensional convolution ?lter is applied only to the two-dimensional im-
ages passed to DrawPixels, CopyPixels, ReadPixels, TexImage2D, TexSubIm-
age2D, CopyTexImage2D, CopyTexSubImage2D, and CopyTexSubImage3D.
If SEPARABLE 2D is enabled, and CONVOLUTION 2D is disabled, the separable
two-dimensionalconvolution?lterisinsteadappliedtheseimages.
The convolution operation is a sum of products of source image pixels and
convolution ?lter pixels. Source image pixels always have four components: red,
green, blue, and alpha, denoted in the equations below as R , G , B , and A .
s s s s
Filter pixels may be stored in one of ?ve formats, with 1, 2, 3, or 4 components.
These components are denoted as R , G , B , A , L , and I in the equations
f f f f f f
below. The result of the convolution operation is the 4-tuple R,G,B,A. Depending
Version2.1-December1,2006142 CHAPTER3. RASTERIZATION
BaseFilterFormat R G B A
ALPHA R G B A ?A
s s s s f
LUMINANCE R ?L G ?L B ?L A
s f s f s f s
LUMINANCE ALPHA R ?L G ?L B ?L A ?A
s f s f s f s f
INTENSITY R ?I G ?I B ?I A ?I
s f s f s f s f
RGB R ?R G ?G B ?B A
s f s f s f s
RGBA R ?R G ?G B ?B A ?A
s f s f s f s f
Table 3.14: Computation of ?ltered color components depending on ?lter image
format. C?F indicatestheconvolutionofimagecomponentC with?lterF.
on the internal format of the ?lter, individual color components of each source
image pixel are convolved with one ?lter component, or are passed unmodi?ed.
Therulesforthisarede?nedintable3.14.
The convolution operation is de?ned differently for each of the three convolu-
tion ?lters. The variables W and H refer to the dimensions of the convolution
f f
?lter. ThevariablesW andH refertothedimensionsofthesourcepixelimage.
s s
Theconvolutionequationsarede?nedasfollows,whereC referstothe?ltered
result, C refers to the one- or two-dimensional convolution ?lter, and C and
f row
C refer to the two one-dimensional ?lters comprising the two-dimensional
column
0
separable?lter. C dependsonthesourceimagecolorC andtheconvolutionbor-
s
s
dermodeasdescribedbelow. C ,the?lteredoutputimage,dependsonallofthese
r
variables and is described separately for each border mode. The pixel indexing
nomenclature is decribed in the Convolution Filter Specification subsection of
section3.6.3.
One-dimensional?lter:
W ?1
f
X
0 0 0
C[i] = C [i +n]?C [n]
f
s
n=0
Two-dimensional?lter:
W ?1H ?1
f f
X X
0 0 0 0 0
C[i,j ] = C [i +n,j +m]?C [n,m]
f
s
n=0 m=0
Two-dimensionalseparable?lter:
W ?1H ?1
f f
X X
0 0 0 0 0
C[i,j ] = C [i +n,j +m]?C [n]?C [m]
row column
s
n=0 m=0
Version2.1-December1,20063.6. PIXELRECTANGLES 143
IfW ofaone-dimensional?lteriszero,then C[i]isalwayssettozero. Like-
f
wise, if eitherW orH of a two-dimensional ?lter is zero, then C[i,j] is always
f f
settozero.
The convolution border mode for a speci?c convolution ?lter is speci?ed by
calling
void ConvolutionParameter{if}(enum target,enum pname,
T param);
wheretargetisthenameofthe?lter,pnameisCONVOLUTION BORDER MODE,and
paramisoneofREDUCE,CONSTANT BORDERorREPLICATE BORDER.
BorderModeREDUCE
The width and height of source images convolved with border mode REDUCE are
reduced by W ? 1 and H ? 1, respectively. If this reduction would generate
f f
a resulting image with zero or negative width and/or height, the output is simply
null,withnoerrorgenerated. Thecoordinatesoftheimagethatresultsfromacon-
volutionwithbordermodeREDUCEarezerothroughW ?W inwidth, andzero
s f
throughH ?H inheight. Incaseswhereerrorscanresultfromthespeci?cation
s f
of invalid image dimensions, it is these resulting dimensions that are tested, not
thedimensionsofthesourceimage. (Aspeci?cexampleisTexImage1DandTex-
Image2D, which specify constraints for image dimensions. Even if TexImage1D
or TexImage2D is called with a null pixel pointer, the dimensions of the result-
ingtextureimagearethosethatwouldresultfromtheconvolutionofthespeci?ed
image).
0
When the border mode is REDUCE, C equals the source image color C and
s
s
C equalsthe?lteredresultC.
r
For the remaining border modes, de?ne C =bW /2c and C =bH /2c.
w f h f
Thecoordinates(C ,C )de?nethecenteroftheconvolution?lter.
w h
BorderModeCONSTANT BORDER
If the convolution border mode is CONSTANT BORDER, the output image has the
same dimensions as the source image. The result of the convolution is the same
as if the source image were surrounded by pixels with the same color as the
current convolution border color. Whenever the convolution ?lter extends be-
yond one of the edges of the source image, the constant-color border pixels are
used as input to the ?lter. The current convolution border color is set by call-
ing ConvolutionParameterfv or ConvolutionParameteriv with pname set to
CONVOLUTION BORDER COLOR and params containing four values that comprise
Version2.1-December1,2006144 CHAPTER3. RASTERIZATION
the RGBA color to be used as the image border. Integer color components are
interpreted linearly such that the most positive integer maps to 1.0, and the most
negative integer maps to -1.0. Floating point color components are not clamped
whentheyarespeci?ed.
Foraone-dimensional?lter,theresultcolorisde?nedby
C [i] =C[i?C ]
r w
0 0 0
whereC[i]iscomputedusingthefollowingequationforC [i]:
s
(
0 0
C [i], 0?i <W
0 0 s s
C [i] =
s
C , otherwise
c
andC istheconvolutionbordercolor.
c
For a two-dimensional or two-dimensional separable ?lter, the result color is
de?nedby
C [i,j] =C[i?C ,j?C ]
r w h
0 0 0 0 0
whereC[i,j ]iscomputedusingthefollowingequationforC [i,j ]:
s
(
0 0 0 0
C [i,j ], 0?i <W ,0?j <H
0 0 0 s s s
C [i,j ] =
s
C , otherwise
c
BorderModeREPLICATE BORDER
The convolution border mode REPLICATE BORDER also produces an output im-
age with the same dimensions as the source image. The behavior of this mode is
identical to that of the CONSTANT BORDER mode except for the treatment of pixel
locations where the convolution ?lter extends beyond the edge of the source im-
age. For these locations, it is as if the outermost one-pixel border of the source
image was replicated. Conceptually, each pixel in the leftmost one-pixel column
of the source image is replicatedC times to provide additional image data along
w
the left edge, each pixel in the rightmost one-pixel column is replicated C times
w
to provide additional image data along the right edge, and each pixel value in the
topandbottomone-pixelrowsisreplicatedtocreate C rowsofimagedataalong
h
thetopandbottomedges. Thepixelvalueateachcornerisalsoreplicatedinorder
toprovidedatafortheconvolutionoperationateachcornerofthesourceimage.
Foraone-dimensional?lter,theresultcolorisde?nedby
C [i] =C[i?C ]
r w
Version2.1-December1,20063.6. PIXELRECTANGLES 145
0 0 0
whereC[i]iscomputedusingthefollowingequationforC [i]:
s
0 0 0
C [i] =C [clamp(i,W )]
s s
s
andtheclampingfunctionclamp(val,max)isde?nedas
?
?
0, val < 0
?
clamp(val,max) = val, 0?val <max
?
?
max?1, val?max
For a two-dimensional or two-dimensional separable ?lter, the result color is
de?nedby
C [i,j] =C[i?C ,j?C ]
r w h
0 0 0 0 0
whereC[i,j ]iscomputedusingthefollowingequationforC [i,j ]:
s
0 0 0 0 0
C [i,j ] =C [clamp(i,W ),clamp(j ,H )]
s s s
s
If a convolution operation is performed, each component of
the resulting image is scaled by the corresponding PixelTrans-
fer parameters: POST CONVOLUTION RED SCALE for an R com-
ponent, POST CONVOLUTION GREEN SCALE for a G compo-
nent, POST CONVOLUTION BLUE SCALE for a B component, and
POST CONVOLUTION ALPHA SCALE for an A component. The result
is added to the corresponding bias: POST CONVOLUTION RED BIAS,
POST CONVOLUTION GREEN BIAS, POST CONVOLUTION BLUE BIAS, or
POST CONVOLUTION ALPHA BIAS.
The required state is three bits indicating whether each of one-dimensional,
two-dimensional,orseparabletwo-dimensionalconvolutionisenabledordisabled,
anintegerdescribingthecurrentconvolutionbordermode, andfour?oating-point
values specifying the convolution border color. In the initial state, all convolu-
tion operations are disabled, the border mode is REDUCE, and the border color is
(0,0,0,0).
PostConvolutionColorTableLookup
This step applies only to RGBA component groups. Post convolution color
table lookup is enabled or disabled by calling Enable or Disable with
the symbolic constant POST CONVOLUTION COLOR TABLE. The post convo-
lution table is de?ned by calling ColorTable with a target argument of
Version2.1-December1,2006146 CHAPTER3. RASTERIZATION
POST CONVOLUTION COLOR TABLE. In all other respects, operation is identical
tocolortablelookup,asde?nedearlierinsection3.6.5.
The required state is one bit indicating whether post convolution table lookup
isenabledordisabled. Intheinitialstate,lookupisdisabled.
ColorMatrixTransformation
This step applies only to RGBA component groups. The components are
transformed by the color matrix. Each transformed component is multiplied
by an appropriate signed scale factor: POST COLOR MATRIX RED SCALE
for an R component, POST COLOR MATRIX GREEN SCALE for a G
component, POST COLOR MATRIX BLUE SCALE for a B component,
and POST COLOR MATRIX ALPHA SCALE for an A component. The
result is added to a signed bias: POST COLOR MATRIX RED BIAS,
POST COLOR MATRIX GREEN BIAS, POST COLOR MATRIX BLUE BIAS, or
POST COLOR MATRIX ALPHA BIAS. The resulting components replace each
componentoftheoriginalgroup.
Thatis, ifM isthecolormatrix, asubscriptofsrepresentsthescaletermfor
c
acomponent,andasubscriptofbrepresentsthebiasterm,thenthecomponents
? ?
R
? ?
G
? ?
? ?
B
A
aretransformedto
? ? ? ? ? ? ? ?
0
R R 0 0 0 R R
s
b
0
? ? ? ? ? ? ? ?
G 0 G 0 0 G G
s b
? ? ? ? ? ? ? ?
= M + .
c
0
? ? ? ? ? ? ? ?
B 0 0 B 0 B B
s b
0
A 0 0 0 A A A
s b
PostColorMatrixColorTableLookup
This step applies only to RGBA component groups. Post color matrix
color table lookup is enabled or disabled by calling Enable or Disable
with the symbolic constant POST COLOR MATRIX COLOR TABLE. The post color
matrix table is de?ned by calling ColorTable with a target argument of
POST COLOR MATRIX COLOR TABLE. In all other respects, operation is identical
tocolortablelookup,asde?nedinsection3.6.5.
The required state is one bit indicating whether post color matrix lookup is
enabledordisabled. Intheinitialstate,lookupisdisabled.
Version2.1-December1,20063.6. PIXELRECTANGLES 147
Histogram
This step applies only to RGBA component groups. Histogram operation is
enabled or disabled by calling Enable or Disable with the symbolic constant
HISTOGRAM.
If the width of the table is non-zero, then indices R , G , B , and A are de-
i i i i
rivedfromthered,green,blue,andalphacomponentsofeachpixelgroup(without
modifying these components) by clamping each component to [0,1] , multiplying
by one less than the width of the histogram table, and rounding to the nearest in-
teger. If the format of the HISTOGRAM table includes red or luminance, the red or
luminance component of histogram entryR is incremented by one. If the format
i
of the HISTOGRAM table includes green, the green component of histogram entry
G is incremented by one. The blue and alpha components of histogram entries
i
B and A are incremented in the same way. If a histogram entry component is
i i
incremented beyond its maximum value, its value becomes unde?ned; this is not
anerror.
If the Histogram sink parameter is FALSE, histogram operation has no effect
on thestreamof pixelgroups beingprocessed. Otherwise, all RGBApixel groups
are discarded immediately after the histogram operation is completed. Because
histogram precedes minmax, no minmax operation is performed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
valuesarereturned. However,textureobjectstateismodi?edwhetherornotpixel
groupsarediscarded.
Minmax
This step applies only to RGBA component groups. Minmax operation is enabled
ordisabledbycallingEnableorDisablewiththesymbolicconstantMINMAX.
If the format of the minmax table includes red or luminance, the red compo-
nent value replaces the red or luminance value in the minimum table element if
and only if it is less than that component. Likewise, if the format includes red or
luminanceandtheredcomponentofthegroupisgreaterthantheredorluminance
valueinthemaximumelement,theredgroupcomponentreplacestheredorlumi-
nance maximum component. If the format of the table includes green, the green
group component conditionally replaces the green minimum and/or maximum if
it is smaller or larger, respectively. The blue and alpha group components are
similarly tested and replaced, if the table format includes blue and/or alpha. The
internal type of the minimum and maximum component values is ?oating point,
with at least the same representable range as a ?oating point number used to rep-
resent colors (section 2.1.1). There are no semantics de?ned for the treatment of
Version2.1-December1,2006148 CHAPTER3. RASTERIZATION
groupcomponentvaluesthatareoutsidetherepresentablerange.
If the Minmax sink parameter is FALSE, minmax operation has no effect on
thestreamofpixelgroupsbeingprocessed. Otherwise,allRGBApixelgroupsare
discarded immediately after the minmax operation is completed. No pixel frag-
ments are generated, no change is made to texture memory contents, and no pixel
valuesarereturned. However,textureobjectstateismodi?edwhetherornotpixel
groupsarediscarded.
3.6.6 PixelRectangleMultisampleRasterization
IfMULTISAMPLEisenabled,andthevalueofSAMPLE BUFFERSisone,thenpixel
rectangles are rasterized using the following algorithm. Let (X ,Y ) be the cur-
rp rp
rent raster position. (If the current raster position is invalid, then DrawPixels is
ignored.) If a particular group (index or components) is the nth in a row and be-
longs to the mth row, consider the region in window coordinates bounded by the
rectanglewithcorners
(X +Z ?n,Y +Z ?m)
rp x rp y
and
(X +Z ?(n+1),Y +Z ?(m+1))
rp x rp y
whereZ andZ arethepixelzoomfactorsspeci?edbyPixelZoom,andmayeach
x y
be either positive or negative. A fragment representing group (n,m) is produced
for each framebuffer pixel with one or more sample points that lie inside, or on
thebottomorleftboundary,ofthisrectangle. Eachfragmentsoproducedtakesits
associated data from the group and from the current raster position, in a manner
consistentwiththediscussionintheConversiontoFragmentssubsectionofsec-
tion 3.6.4. All depth and color sample values are assigned the same value, taken
either from their group (for depth and color component groups) or from the cur-
rent raster position (if they are not). All sample values are assigned the same fog
coordinate and the same set of texture coordinates, taken from the current raster
position.
A single pixel rectangle will generate multiple, perhaps very many fragments
forthesameframebufferpixel,dependingonthepixelzoomfactors.
3.7 Bitmaps
Bitmaps are rectangles of zeros and ones specifying a particular pattern of frag-
mentstobeproduced. Eachofthesefragmentshasthesameassociateddata. These
dataarethoseassociatedwiththe current raster position.
Version2.1-December1,20063.7. BITMAPS 149
 ! !   !                
 ! !   !                
" " # " #  ! # !     !                                     
" " # " #   #                                  
$" "$ %# "$ %#   %#                                        
$ $ % $ % %            
&$ &$ ’% $& %’ %’                  
& & ’ & ’ ’            
& & ’ & ’ ’                        
                 
                                   
                       
                                      
h = 12
                       
                             
           
                 
           
           
           
           
y
 = 1.0                  
bo
           
           
x
 = 2.5
bo
w = 8
Figure3.9. Abitmapanditsassociatedparameters. x andy arenotshown.
bi bi
Bitmapsaresentusing
void Bitmap(sizeiw,sizeih,floatx ,floaty ,
bo bo
floatx ,floaty ,ubyte *data);
bi bi
w and h comprise the integer width and height of the rectangular bitmap, respec-
tively. (x ,y ) gives the ?oating-point x and y values of the bitmap’s origin.
bo bo
(x ,y ) gives the ?oating-point x and y increments that are added to the raster
bi bi
positionafterthebitmapisrasterized. dataisapointertoabitmap.
Like a polygon pattern, a bitmap is unpacked from memory according to the
procedure given in section 3.6.4 for DrawPixels; it is as if the width and height
passedtothatcommandwereequaltowandh,respectively,thetypewereBITMAP,
and the format were COLOR INDEX. The unpacked values (before any conversion
orarithmeticwouldhavebeenperformed)formastipplepatternofzerosandones.
See?gure3.9.
AbitmapsentusingBitmapisrasterizedasfollows. First,ifthecurrentraster
position is invalid (the valid bit is reset), the bitmap is ignored. Otherwise, a rect-
angulararrayoffragmentsisconstructed,withlowerleftcornerat
(x ,y ) = (bx ?x c,by ?y c)
ll ll rp bo rp bo
Version2.1-December1,2006150 CHAPTER3. RASTERIZATION
andupperrightcornerat(x +w,y +h)wherewandharethewidthandheightof
ll ll
thebitmap,respectively. Fragmentsinthearrayareproducedifthecorresponding
bit in the bitmap is 1 and not produced otherwise. The associated data for each
fragment are those associated with the current raster position. Once the fragments
havebeenproduced,thecurrentrasterpositionisupdated:
(x ,y )< (x +x ,y +y ).
rp rp rp bi rp bi
Thez andw valuesofthecurrentrasterpositionremainunchanged.
BitmapMultisampleRasterization
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, then
bitmaps are rasterized using the following algorithm. If the current raster position
is invalid, the bitmap is ignored. Otherwise, a screen-aligned array of pixel-size
rectangles is constructed, with its lower left corner at (X ,Y ), and its upper
rp rp
right corner at (X + w,Y + h), where w and h are the width and height of
rp rp
the bitmap. Rectangles in this array are eliminated if the corresponding bit in the
bitmap is 0, and are retained otherwise. Bitmap rasterization produces a fragment
for each framebuffer pixel with one or more sample points either inside or on the
bottomorleftedgeofaretainedrectangle.
Coverage bits that correspond to sample points either inside or on the bottom
orleftedgeofaretainedrectangleare1, othercoveragebitsare0. Theassociated
dataforeachsamplearethoseassociatedwiththecurrentrasterposition. Oncethe
fragments have been produced, the current raster position is updated exactly as it
isinthesingle-samplerasterizationcase.
3.8 Texturing
Texturing maps a portion of one or more speci?ed images onto each primitive for
whichtexturingisenabled. Thismappingisaccomplishedbyusingthecolorofan
imageatthelocationindicatedbyatexturecoordinateset’s(s,t,r,q)cordinates.
Implementations must support texturing using at least two images at a time.
Each fragment or vertex carries multiple sets of texture coordinates (s,t,r,q)
whichareusedtoindexseparateimagestoproducecolorvalueswhicharecollec-
tivelyusedtomodifytheresultingtransformedvertexorfragmentcolor. Texturing
is speci?ed only for RGBA mode; its use in color index mode is unde?ned. The
followingsubsections(uptoandincludingsection3.8.8)specifytheGLoperation
withasingletextureandsection3.8.16speci?esthedetailsofhowmultipletexture
unitsinteract.
Version2.1-December1,20063.8. TEXTURING 151
The GL provides two ways to specify the details of how texturing of a prim-
itive is effected. The ?rst is referred to as ?xed-functionality, and is described in
this section. The second is referred to as a fragment shader, and is described in
section 3.11. The speci?cation of the image to be texture mapped and the means
by which the image is ?ltered when applied to the primitive are common to both
methods and are discussed in this section. The ?xed functionality method for de-
termining what RGBA value is produced is also described in this section. If a
fragmentshaderisactive,themethodfordeterminingtheRGBAvalueisspeci?ed
by an application-supplied fragment shader as described in the OpenGL Shading
LanguageSpecification.
When no fragment shader is active, the coordinates used for texturing are
(s/q,t/q,r/q), derived from the original texture coordinates (s,t,r,q). If the q
texture coordinate is less than or equal to zero, the coordinates used for texturing
are unde?ned. When a fragment shader is active, the (s,t,r,q) coordinates are
available to the fragment shader. The coordinates used for texturing in a fragment
shaderarede?nedbytheOpenGLShadingLanguageSpecification.
3.8.1 TextureImageSpecification
Thecommand
void TexImage3D(enumtarget,intlevel,intinternalformat,
sizei width,sizei height,sizei depth,int border,
enum format,enum type,void *data);
is used to specify a three-dimensional texture image. target must be ei-
ther TEXTURE 3D, or PROXY TEXTURE 3D in the special case discussed in sec-
tion 3.8.11. format, type, and data match the corresponding arguments to Draw-
Pixels(refertosection3.6.4);theyspecifytheformatoftheimagedata,thetypeof
those data, and a reference to the image data in the currently bound pixel unpack
bufferorclientmemory. The formatSTENCIL INDEXisnotallowed.
The groups in memory are treated as being arranged in a sequence of ad-
jacent rectangles. Each rectangle is a two-dimensional image, whose size and
organization are speci?ed by the width and height parameters to TexImage3D.
ThevaluesofUNPACK ROW LENGTHandUNPACK ALIGNMENTcontroltherow-to-
row spacing in these images in the same manner as DrawPixels. If the value of
the integer parameter UNPACK IMAGE HEIGHT is not positive, then the number
of rows in each two-dimensional image is height; otherwise the number of rows
is UNPACK IMAGE HEIGHT. Each two-dimensional image comprises an integral
numberofrows,andisexactlyadjacenttoitsneighborimages.
Version2.1-December1,2006152 CHAPTER3. RASTERIZATION
BaseInternalFormat RGBAandDepthValues InternalComponents
ALPHA A A
DEPTH COMPONENT Depth D
LUMINANCE R L
LUMINANCE ALPHA R,A L,A
INTENSITY R I
RGB R,G,B R,G,B
RGBA R,G,B,A R,G,B,A
Table 3.15: Conversion from RGBA and depth pixel components to internal tex-
ture,table,or?ltercomponents. Seesection3.8.13foradescriptionofthetexture
componentsR,G,B,A,L,I,andD.
The mechanism for selecting a sub-volume of a three-dimensional image re-
lies on the integer parameter UNPACK SKIP IMAGES. If UNPACK SKIP IMAGES
ispositive,thepointerisadvancedbyUNPACK SKIP IMAGEStimesthenumberof
elementsinonetwo-dimensionalimagebeforeobtainingthe?rstgroupfrommem-
ory. Then depth two-dimensional images are processed, each having a subimage
extractedinthesamemannerasDrawPixels.
The selected groups are processed exactly as for DrawPixels, stopping just
before ?nal conversion. Each R, G, B, A, or depth value so generated is clamped
to[0,1].
Components are then selected from the resulting R, G, B, A, or depth values
to obtain a texture with the base internal format speci?ed by (or derived from)
internalformat. Table 3.15 summarizes the mapping of R, G, B, A, and depth val-
ues to texture components, as a function of the base internal format of the texture
image. internalformat may be speci?ed as one of the seven internal format sym-
bolic constants listed in table 3.15, as one of the sized internal format symbolic
constantslistedintable3.16, asoneofthesixgenericcompressedinternalformat
symbolic constants listed in table 3.17, or as one of the speci?c compressed in-
ternal format symbolic constants (if listed in table 3.17). internalformat may (for
backwards compatibility with the 1.0 version of the GL) also take on the integer
values 1, 2, 3, and 4, which are equivalent to symbolic constants LUMINANCE,
LUMINANCE ALPHA,RGB, andRGBA respectively. Specifying a value for internal-
formatthatisnotoneoftheabovevaluesgeneratestheerrorINVALID VALUE.
Textures with a base internal format of DEPTH COMPONENT are supported by
textureimagespeci?cationcommandsonlyiftargetisTEXTURE 1D,TEXTURE 2D,
PROXY TEXTURE 1D or PROXY TEXTURE 2D. Using this format in conjunction
Version2.1-December1,20063.8. TEXTURING 153
withanyother targetwillresultinanINVALID OPERATIONerror.
TextureswithabaseinternalformatofDEPTH COMPONENTrequiredepthcom-
ponent data; textures with other base internal formats require RGBA component
data. The error INVALID OPERATION is generated if the base internal format is
DEPTH COMPONENT and format is not DEPTH COMPONENT, or if the base internal
formatisnotDEPTH COMPONENTand formatisDEPTH COMPONENT.
The GL provides no speci?c compressed internal formats but does provide a
mechanism to obtain token values for such formats provided by extensions. The
number of speci?c compressed internal formats supported by the renderer can
be obtained by querying the value ofNUM COMPRESSED TEXTURE FORMATS. The
set of speci?c compressed internal formats supported by the renderer can be ob-
tained by querying the value of COMPRESSED TEXTURE FORMATS. The only val-
uesreturnedbythisqueryarethosecorrespondingtoformatssuitableforgeneral-
purposeusage. Therendererwillnotenumerateformatswithrestrictionsthatneed
tobespeci?callyunderstoodpriortouse.
Genericcompressedinternalformatsareneveruseddirectlyastheinternalfor-
mats of texture images. If internalformat is one of the six generic compressed
internal formats, its value is replaced by the symbolic constant for a speci?c com-
pressed internal format of the GL’s choosing with the same base internal format.
Ifnospeci?ccompressedformatisavailable,internalformatisinsteadreplacedby
the corresponding base internal format. If internalformat is given as or mapped
to a speci?c compressed internal format, but the GL can not support images com-
pressed in the chosen internal format for any reason (e.g., the compression format
mightnotsupport3Dtexturesorborders), internalformatisreplacedbythecorre-
spondingbaseinternalformatandthetextureimagewillnotbecompressedbythe
GL.
Theinternalcomponentresolutionisthenumberofbitsallocatedtoeachvalue
in a texture image. If internalformat is speci?ed as a base internal format, the GL
stores the resulting texture with internal component resolutions of its own choos-
ing. If a sized internal format is speci?ed, the mapping of the R, G, B, A, and
depthvaluestotexturecomponentsisequivalenttothemappingofthecorrespond-
ing base internal format’s components, as speci?ed in table 3.15, and the memory
allocation per texture component is assigned by the GL to match the allocations
listedintable3.16ascloselyaspossible. (Thede?nitionofcloselyisleftuptothe
implementation. However, a non-zero number of bits must be allocated for each
component whose desired allocation in table 3.16 is non-zero, and zero bits must
beallocatedforallothercomponents). Implementationsarerequiredtosupportat
leastoneallocationofinternalcomponentresolutionforeachbaseinternalformat.
Version2.1-December1,2006154 CHAPTER3. RASTERIZATION
Sized Base R G B A L I D
InternalFormat InternalFormat bits bits bits bits bits bits bits
ALPHA4 ALPHA 4
ALPHA8 ALPHA 8
ALPHA12 ALPHA 12
ALPHA16 ALPHA 16
DEPTH COMPONENT16 DEPTH COMPONENT 16
DEPTH COMPONENT24 DEPTH COMPONENT 24
DEPTH COMPONENT32 DEPTH COMPONENT 32
LUMINANCE4 LUMINANCE 4
LUMINANCE8 LUMINANCE 8
LUMINANCE12 LUMINANCE 12
LUMINANCE16 LUMINANCE 16
LUMINANCE4 ALPHA4 LUMINANCE ALPHA 4 4
LUMINANCE6 ALPHA2 LUMINANCE ALPHA 2 6
LUMINANCE8 ALPHA8 LUMINANCE ALPHA 8 8
LUMINANCE12 ALPHA4 LUMINANCE ALPHA 4 12
LUMINANCE12 ALPHA12 LUMINANCE ALPHA 12 12
LUMINANCE16 ALPHA16 LUMINANCE ALPHA 16 16
INTENSITY4 INTENSITY 4
INTENSITY8 INTENSITY 8
INTENSITY12 INTENSITY 12
INTENSITY16 INTENSITY 16
R3 G3 B2 RGB 3 3 2
RGB4 RGB 4 4 4
RGB5 RGB 5 5 5
RGB8 RGB 8 8 8
RGB10 RGB 10 10 10
RGB12 RGB 12 12 12
RGB16 RGB 16 16 16
RGBA2 RGBA 2 2 2 2
RGBA4 RGBA 4 4 4 4
RGB5 A1 RGBA 5 5 5 1
RGBA8 RGBA 8 8 8 8
RGB10 A2 RGBA 10 10 10 2
RGBA12 RGBA 12 12 12 12
RGBA16 RGBA 16 16 16 16
Sizedinternalformatscontinuedonnextpage
Version2.1-December1,20063.8. TEXTURING 155
Sizedinternalformatscontinuedfrompreviouspage
Sized Base R G B A L I D
InternalFormat InternalFormat bits bits bits bits bits bits bits
SRGB8 RGB 8 8 8
SRGB8 ALPHA8 RGBA 8 8 8 8
SLUMINANCE LUMINANCE 8
SLUMINANCE ALPHA8 LUMINANCE ALPHA 8 8
Table 3.16: Correspondence of sized internal formats to base in-
ternal formats, and desired component resolutions for each sized
internalformat.
CompressedInternalFormat BaseInternalFormat Type
COMPRESSED ALPHA ALPHA Generic
COMPRESSED LUMINANCE LUMINANCE Generic
COMPRESSED LUMINANCE ALPHA LUMINANCE ALPHA Generic
COMPRESSED INTENSITY INTENSITY Generic
COMPRESSED RGB RGB Generic
COMPRESSED RGBA RGBA Generic
COMPRESSED SRGB RGB Generic
COMPRESSED SRGB ALPHA RGBA Generic
COMPRESSED SLUMINANCE LUMINANCE Generic
COMPRESSED SLUMINANCE ALPHA LUMINANCE ALPHA Generic
Table3.17: Genericandspeci?ccompressedinternalformats. Nospeci?cformats
are de?ned by OpenGL 2.1; however, several speci?c speci?c compression types
arede?nedinGLextensions.
If a compressed internal format is speci?ed, the mapping of the R, G, B, and
A values to texture components is equivalent to the mapping of the corresponding
base internalformat’s components, asspeci?ed in table3.15. The speci?edimage
iscompressedusinga(possiblylossy)compressionalgorithmchosenbytheGL.
AGLimplementationmayvaryitsallocationofinternalcomponentresolution
or compressed internal format based on any TexImage3D, TexImage2D (see be-
low),orTexImage1D(seebelow)parameter(excepttarget),buttheallocationand
chosencompressedimageformatmustnotbeafunctionofanyotherstateandcan-
not be changed once they are established. In addition, the choice of a compressed
Version2.1-December1,2006156 CHAPTER3. RASTERIZATION
image format may not be affected by the data parameter. Allocations must be in-
variant; the same allocation and compressed image format must be chosen each
timeatextureimageisspeci?edwiththesameparametervalues. Theseallocation
rulesalsoapplytoproxytextures,whicharedescribedinsection3.8.11.
The image itself (referred to by data) is a sequence of groups of values. The
?rst group is the lower left back corner of the texture image. Subsequent groups
?lloutrowsofwidthwidthfromlefttoright;heightrowsarestackedfrombottom
to top forming a single two-dimensional image slice; and depth slices are stacked
frombacktofront. Whenthe?nalR,G,B,andAcomponentshavebeencomputed
for a group, they are assigned to components of a texel as described by table 3.15.
Counting from zero, each resulting Nth texel is assigned internal integer coordi-
nates(i,j,k),where
i = (N modwidth)?b
s
N
j = (b c modheight)?b
s
width
N
k = (b c moddepth)?b
s
width?height
andb is the speci?ed border width. Thus the last two-dimensional image slice of
s
thethree-dimensionalimageisindexedwiththehighestvalueof k.
Each color component is converted (by rounding to nearest) to a ?xed-point
value with n bits, where n is the number of bits of storage allocated to that com-
ponent in the image array. We assume that the ?xed-point representation used
n n
represents each valuek/(2 ?1), wherek?{0,1,...,2 ?1}, ask (e.g. 1.0 is
representedinbinaryasastringofallones).
ThelevelargumenttoTexImage3Disanintegerlevel-of-detail number. Levels
of detail are discussed below, under Mipmapping. The main texture image has a
levelofdetailnumberof0. Ifalevel-of-detaillessthanzeroisspeci?ed,theerror
INVALID VALUEisgenerated.
The border argument to TexImage3D is a border width. The signi?cance of
bordersisdescribedbelow. Theborderwidthaffectsthedimensionsofthetexture
image: let
w =w +2b (3.15)
s t s
h =h +2b (3.16)
s t s
d =d +2b (3.17)
s t s
Version2.1-December1,20063.8. TEXTURING 157
wherew ,h , andd are the speci?ed image width, depth, and depth, andw ,
s s s t
h ,andd arethedimensionsofthetextureimageinternaltotheborder. Ifw ,h ,
t t t t
ord arelessthanzero,thentheerrorINVALID VALUEisgenerated.
t
An image with zero width, height, or depth indicates the null texture. If
the null texture is speci?ed for the level-of-detail speci?ed by texture parameter
TEXTURE BASE LEVEL(seesection3.8.4),itisasiftexturingweredisabled.
Currently, themaximumborderwidthb is1. Ifb islessthanzero, orgreater
t s
thanb ,thentheerrorINVALID VALUEisgenerated.
t
Themaximumallowablewidth,height,ordepthofathree-dimensionaltexture
image is an implementation dependent function of the level-of-detail and internal
k?lod
formatoftheresultingimagearray. Itmustbeatleast2 +2b forimagearrays
t
oflevel-of-detail 0throughk,wherekisthelogbase2ofMAX 3D TEXTURE SIZE,
lod is the level-of-detail of the image array, and b is the maximum border width.
t
It may be zero for image arrays of any level-of-detail greater than k. The error
INVALID VALUEisgeneratedifthespeci?edimageistoolargetobestoredunder
anyconditions.
If a pixel unpack buffer object is bound and storing texture data would access
memorybeyondtheendofthepixelunpackbuffer,anINVALID OPERATIONerror
results.
In a similar fashion, the maximum allowable width of a one- or two-
dimensional texture image, and the maximum allowable height of a two-
k?lod
dimensional texture image, must be at least 2 +2b for image arrays of level
t
0 throughk, wherek is the log base 2 of MAX TEXTURE SIZE. The maximum al-
lowable width and height of a cube map texture must be the same, and must be at
k?lod
least 2 +2b for image arrays level 0 throughk, wherek is the log base 2 of
t
MAX CUBE MAP TEXTURE SIZE.
An implementation may allow an image array of level 0 to be created only if
thatsingleimagearraycanbesupported. Additionalconstraintsonthecreationof
imagearraysoflevel1orgreateraredescribedinmoredetailinsection3.8.10.
Thecommand
void TexImage2D(enum target,int level,
int internalformat,sizei width,sizei height,
int border,enum format,enum type,void *data);
is used to specify a two-dimensional texture image. target must
be one of TEXTURE 2D for a two-dimensional texture, or one of
TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y, TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, or TEXTURE CUBE MAP NEGATIVE Z for
Version2.1-December1,2006158 CHAPTER3. RASTERIZATION
a cube map texture. Additionally, target may be either PROXY TEXTURE 2D for
a two-dimensional proxy texture or PROXY TEXTURE CUBE MAP for a cube map
proxytextureinthespecialcasediscussedinsection3.8.11. Theotherparameters
matchthecorrespondingparametersofTexImage3D.
For the purposes of decoding the texture image, TexImage2D is equivalent to
callingTexImage3Dwithcorrespondingargumentsand depthof1,exceptthat
• The depthoftheimageisalways1regardlessofthevalueof border.
• Convolution will be performed on the image (possibly changing its width
and height)ifSEPARABLE 2DorCONVOLUTION 2Disenabled.
• UNPACK SKIP IMAGESisignored.
Atwo-dimensionaltextureconsistsofasingletwo-dimensionaltextureimage.
A cube map texture is a set of six two-dimensional texture images. The six cube
map texture targets form a single cube map texture though each target names a
distinct face of the cube map. TheTEXTURE CUBE MAP targets listed above up-
*
datetheirappropriatecubemapface2Dtextureimage. Notethatthesixcubemap
two-dimensionalimagetokenssuchas TEXTURE CUBE MAP POSITIVE Xareused
when specifying, updating, or querying one of a cube map’s six two-dimensional
images, but when enabling cube map texturing or binding to a cube map texture
object(thatiswhenthecubemapisaccessedasawholeasopposedtoaparticular
two-dimensionalimage),the TEXTURE CUBE MAPtargetisspeci?ed.
When the target parameter to TexImage2D is one of the six cube map two-
dimensionalimagetargets,theerrorINVALID VALUEisgeneratedifthewidthand
heightparametersarenotequal.
Finally,thecommand
void TexImage1D(enum target,int level,
int internalformat,sizei width,int border,
enum format,enum type,void *data);
is used to specify a one-dimensional texture image. target must be either
TEXTURE 1D, or PROXY TEXTURE 1D in the special case discussed in sec-
tion3.8.11.)
For the purposes of decoding the texture image, TexImage1D is equivalent to
callingTexImage2Dwithcorrespondingargumentsand heightof1,exceptthat
• The heightoftheimageisalways1regardlessofthevalueof border.
Version2.1-December1,20063.8. TEXTURING 159
• Convolution will be performed on the image (possibly changing its width)
onlyifCONVOLUTION 1Disenabled.
TheimageindicatedtotheGLbytheimagepointerisdecodedandcopiedinto
the GL’s internal memory. This copying effectively places the decoded image in-
sideaborderofthemaximumallowablewidthb whetherornotaborderhasbeen
t
1
speci?ed (see ?gure 3.10) . If no border or a border smaller than the maximum
allowable width has been speci?ed, then the image is still stored as if it were sur-
rounded by a border of the maximum possible width. Any excess border (which
surrounds the speci?ed image, including any border) is assigned unspeci?ed val-
ues. Atwo-dimensionaltexturehasaborderonlyatitsleft, right, top, andbottom
ends,andaone-dimensionaltexturehasaborderonlyatitsleftandrightends.
Weshallrefertothe(possiblyborderaugmented)decodedimageasthetexture
array. A three-dimensional texture array has width, height, and depth w ,h , and
s s
d as de?ned respectively in equations 3.15, 3.16, and 3.17. A two-dimensional
s
texture array has depthd = 1, with heighth and widthw as above, and a one-
s s s
dimensionaltexturearrayhasdepthd = 1,heighth = 1,andwidthw asabove.
s s s
Anelement(i,j,k)ofthetexturearrayiscalledatexel(foratwo-dimensional
texture,k is irrelevant; for a one-dimensional texture, j andk are both irrelevant).
The texture value used in texturing a fragment is determined by that fragment’s
associated (s,t,r) coordinates, but may not correspond to any actual texel. See
?gure3.10.
Ifthe dataargumentofTexImage1D,TexImage2D,orTexImage3Disanull
pointer (a zero-valued pointer in the C implementation), and the pixel unpack
buffer object is zero, a one-, two-, or three-dimensional texture array is created
with the speci?ed target, level, internalformat, border, width, height, and depth,
but with unspeci?ed image contents. In this case no pixel values are accessed
in client memory, and no pixel processing is performed. Errors are generated,
however, exactly as though the data pointer were valid. Otherwise if the pixel
unpack buffer object is non-zero, the data argument is treatedly normally to refer
tothebeginningofthepixelunpackbufferobject’sdata.
3.8.2 AlternateTextureImageSpecificationCommands
Two-dimensional and one-dimensional texture images may also be speci?ed us-
ing image data taken directly from the framebuffer, and rectangular subregions of
existingtextureimagesmayberespeci?ed.
Thecommand
1
Figure3.10needstoshowathree-dimensionaltextureimage.
Version2.1-December1,2006160 CHAPTER3. RASTERIZATION
5.0
4
1.0
3
?
2
t v j
?
1
0
0.0
?1
?1.0
?1 0 1 2 3 4 5 6 7 8
i
?1.0 u 9.0
0.0 s 1.0
Figure 3.10. A texture image and the coordinates used to access it. This is a two-
dimensional texture with n = 3 and m = 2. A one-dimensional texture would
consistofasinglehorizontalstrip. ?and?,valuesusedinblendingadjacenttexels
toobtainatexturevalue,arealsoshown.
Version2.1-December1,20063.8. TEXTURING 161
void CopyTexImage2D(enum target,int level,
enum internalformat,int x,int y,sizei width,
sizei height,int border);
de?nes a two-dimensional texture array in exactly the manner of TexIm-
age2D, except that the image data are taken from the framebuffer rather
than from client memory. Currently, target must be one of TEXTURE 2D,
TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y, TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, or TEXTURE CUBE MAP NEGATIVE Z. x, y,
width,and heightcorrespondpreciselytothecorrespondingargumentstoCopyP-
ixels (refer to section 4.3.3); they specify the image’s width and height, and the
lower left (x,y) coordinates of the framebuffer region to be copied. The im-
age is taken from the framebuffer exactly as if these arguments were passed to
CopyPixels with argument type set to COLOR or DEPTH, depending on internal-
format, stopping after pixel transfer processing is complete. RGBA data is taken
from the current color buffer while depth component data is taken from the depth
buffer. If depth component data is required and no depth buffer is present, the
error INVALID OPERATION is generated. Subsequent processing is identical to
that described for TexImage2D, beginning with clamping of the R, G, B, A, or
depthvaluesfromtheresultingpixelgroups. Parameterslevel,internalformat,and
border are speci?ed using the same values, with the same meanings, as the equiv-
alent arguments of TexImage2D, except that internalformat may not be speci?ed
as 1, 2, 3, or 4. An invalid value speci?ed for internalformat generates the error
INVALID ENUM.Theconstraintsonwidth,height,andborderareexactlythosefor
theequivalentargumentsofTexImage2D.
When the target parameter to CopyTexImage2D is one of the six cube map
two-dimensionalimagetargets,theerror INVALID VALUEisgeneratedifthewidth
and heightparametersarenotequal.
Thecommand
void CopyTexImage1D(enum target,int level,
enum internalformat,int x,int y,sizei width,
int border);
de?nes a one-dimensional texture array in exactly the manner of TexImage1D,
except that the image data are taken from the framebuffer, rather than from client
memory. Currently, target must be TEXTURE 1D. For the purposes of decoding
the texture image, CopyTexImage1D is equivalent to calling CopyTexImage2D
withcorrespondingargumentsand heightof1, exceptthatthe heightoftheimage
Version2.1-December1,2006162 CHAPTER3. RASTERIZATION
is always 1, regardless of the value of border. level, internalformat, and border
are speci?ed using the same values, with the same meanings, as the equivalent
arguments of TexImage1D, except that internalformat may not be speci?ed as 1,
2,3, or4. The constraints on width and border are exactly those of the equivalent
argumentsofTexImage1D.
Sixadditionalcommands,
void TexSubImage3D(enum target,int level,int xoffset,
int yoffset,int zoffset,sizei width,sizei height,
sizei depth,enum format,enum type,void *data);
void TexSubImage2D(enum target,int level,int xoffset,
int yoffset,sizei width,sizei height,enum format,
enum type,void *data);
void TexSubImage1D(enum target,int level,int xoffset,
sizei width,enum format,enum type,void *data);
void CopyTexSubImage3D(enum target,int level,
int xoffset,int yoffset,int zoffset,int x,int y,
sizei width,sizei height);
void CopyTexSubImage2D(enum target,int level,
int xoffset,int yoffset,int x,int y,sizei width,
sizei height);
void CopyTexSubImage1D(enum target,int level,
int xoffset,int x,int y,sizei width);
respecify only a rectangular subregion of an existing texture array. No change
is made to the internalformat, width, height, depth, or border parameters
of the speci?ed texture array, nor is any change made to texel values out-
side the speci?ed subregion. Currently the target arguments of TexSubIm-
age1D and CopyTexSubImage1D must be TEXTURE 1D, the target arguments
of TexSubImage2D and CopyTexSubImage2D must be one of TEXTURE 2D,
TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y, TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z,orTEXTURE CUBE MAP NEGATIVE Z,andthe
target arguments of TexSubImage3D and CopyTexSubImage3D must be
TEXTURE 3D. The level parameter of each command speci?es the level of the tex-
ture array that is modi?ed. If level is less than zero or greater than the base 2 log-
arithmofthemaximumtexturewidth,height,ordepth,theerrorINVALID VALUE
isgenerated.
TexSubImage3Dargumentswidth,height,depth,format,type,anddatamatch
the corresponding arguments to TexImage3D, meaning that they are speci?ed us-
ing the same values, and have the same meanings. Likewise, TexSubImage2D
Version2.1-December1,20063.8. TEXTURING 163
arguments width, height, format, type, and data match the corresponding argu-
ments to TexImage2D, and TexSubImage1D arguments width, format, type, and
datamatchthecorrespondingargumentstoTexImage1D.
CopyTexSubImage3D and CopyTexSubImage2D arguments x, y, width,
2
and height match the corresponding arguments toCopyTexImage2D .CopyTex-
SubImage1D arguments x, y, and width match the corresponding arguments to
CopyTexImage1D.EachoftheTexSubImagecommandsinterpretsandprocesses
pixelgroupsinexactlythemannerofitsTexImagecounterpart,exceptthattheas-
signment of R, G, B, A, and depth pixel group values to the texture components
is controlled by the internalformat of the texture array, not by an argument to the
command. ThesameconstraintsanderrorsapplytotheTexSubImagecommands’
argument format and the internalformat of the texture array being respeci?ed as
applytothe formatand internalformatargumentsofitsTexImagecounterparts.
Arguments xoffset, yoffset, and zoffset of TexSubImage3D and CopyTex-
SubImage3D specify the lower left texel coordinates of a width-wide by height-
highbydepth-deeprectangularsubregionofthetexturearray. The depthargument
associated with CopyTexSubImage3D is always 1, because framebuffer memory
is two-dimensional - only a portion of a single s,t slice of a three-dimensional
textureisreplacedbyCopyTexSubImage3D.
Negative values of xoffset, yoffset, and zoffset correspond to the coordinates
of border texels, addressed as in ?gure 3.10. Taking w , h , d , and b to be the
s s s s
speci?ed width, height, depth, and border width of the texture array, and takingx,
y,z,w,h,anddtobethexoffset,yoffset,zoffset,width,height,anddepthargument
values,anyofthefollowingrelationshipsgeneratestheerrorINVALID VALUE:
x<?b
s
x+w >w ?b
s s
y <?b
s
y +h>h ?b
s s
z <?b
s
z +d>d ?b
s s
Countingfromzero,thenthpixelgroupisassignedtothetexelwithinternalinteger
coordinates[i,j,k],where
i =x+(n modw)
2
Because the framebuffer is inherently two-dimensional, there is no CopyTexImage3D com-
mand.
Version2.1-December1,2006164 CHAPTER3. RASTERIZATION
n
j =y +(b c modh)
w
n
k =z +(b c modd
width?height
ArgumentsxoffsetandyoffsetofTexSubImage2DandCopyTexSubImage2D
specifythelowerlefttexelcoordinatesofa width-wideby height-highrectangular
subregionofthetexturearray. Negativevaluesof xoffsetand yoffsetcorrespondto
thecoordinatesofbordertexels,addressedasin?gure3.10. Takingw ,h ,andb
s s s
to be the speci?ed width, height, and border width of the texture array, and taking
x,y,w, andh to be the xoffset, yoffset, width, and height argument values, any of
thefollowingrelationshipsgeneratestheerrorINVALID VALUE:
x<?b
s
x+w >w ?b
s s
y <?b
s
y +h>h ?b
s s
Countingfromzero,thenthpixelgroupisassignedtothetexelwithinternalinteger
coordinates[i,j],where
i =x+(n modw)
n
j =y +(b c modh)
w
The xoffset argument of TexSubImage1D and CopyTexSubImage1D speci-
?es the left texel coordinate of a width-wide subregion of the texture array. Neg-
ative values of xoffset correspond to the coordinates of border texels. Taking w
s
and b to be the speci?ed width and border width of the texture array, and x and
s
w tobethexoffsetandwidthargumentvalues,eitherofthefollowingrelationships
generatestheerrorINVALID VALUE:
x<?b
s
x+w >w ?b
s s
Countingfromzero,thenthpixelgroupisassignedtothetexelwithinternalinteger
coordinates[i],where
i =x+(n modw)
Textureimageswithcompressedinternalformatsmaybestoredinsuchaway
thatitisnotpossibletomodifyanimagewithsubimagecommandswithouthaving
Version2.1-December1,20063.8. TEXTURING 165
to decompress and recompress the texture image. Even if the image were modi-
?ed in this manner, it may not be possible to preserve the contents of some of
the texels outside the region being modi?ed. To avoid these complications, the
GL does not support arbitrary modi?cations to texture images with compressed
internal formats. Calling TexSubImage3D, CopyTexSubImage3D, TexSubIm-
age2D,CopyTexSubImage2D,TexSubImage1D,orCopyTexSubImage1Dwill
resultinanINVALID OPERATIONerrorif xoffset, yoffset,or zoffsetisnotequalto
?b (border width). In addition, the contents of any texel outside the region mod-
s
i?ed by such a call are unde?ned. These restrictions may be relaxed for speci?c
compressedinternalformatswhoseimagesareeasilymodi?ed.
3.8.3 CompressedTextureImages
Textureimagesmayalso bespeci?edormodi?edusingimage data alreadystored
in a known compressed image format. The GL currently de?nes no such formats,
butprovidesmechanismsforGLextensionsthatdo.
Thecommands
void CompressedTexImage1D(enum target,int level,
enum internalformat,sizei width,int border,
sizei imageSize,void *data);
void CompressedTexImage2D(enum target,int level,
enum internalformat,sizei width,sizei height,
int border,sizei imageSize,void *data);
void CompressedTexImage3D(enum target,int level,
enum internalformat,sizei width,sizei height,
sizei depth,int border,sizei imageSize,void *data);
de?neone-,two-,andthree-dimensionaltextureimages,respectively,withincom-
ing data stored in a speci?c compressed image format. The target, level, inter-
nalformat, width, height, depth, and border parameters have the same meaning
as in TexImage1D, TexImage2D, and TexImage3D. data refers to compressed
image data stored in the compressed image format corresponding to internal-
format. If a pixel unpack buffer is bound (as indicated by a non-zero value of
PIXEL UNPACK BUFFER BINDING), data is an offset into the pixel unpack buffer
and the compressed data is read from the buffer relative to this offset; otherwise,
data is a pointer to client memory and the compressed data is read from client
memory relative to the pointer. Since the GL provides no speci?c image formats,
using any of the six generic compressed internal formats as internalformat will
resultinanINVALID ENUMerror.
Version2.1-December1,2006166 CHAPTER3. RASTERIZATION
For all other compressed internal formats, the compressed image will be de-
coded according to the speci?cation de?ning the internalformat token. Com-
pressed texture images are treated as an array of imageSize ubytes relative to
data. If a pixel unpack buffer object is bound and data +imageSize is greater
than the size of the pixel buffer, an INVALID OPERATION error results. All pixel
storageandpixeltransfermodesareignoredwhendecodingacompressedtexture
image. If the imageSize parameter is not consistent with the format, dimensions,
and contents of the compressed image, an INVALID VALUE error results. If the
compressed image is not encoded according to the de?ned image format, the re-
sultsofthecallareunde?ned.
Speci?c compressed internal formats may impose format-speci?c restrictions
ontheuseofthecompressedimagespeci?cationcallsorparameters. Forexample,
the compressed image format might be supported only for 2D textures, or might
notallownon-zero bordervalues. Anysuchrestrictionswillbedocumentedinthe
extension speci?cation de?ning the compressed internal format; violating these
restrictionswillresultinanINVALID OPERATIONerror.
Any restrictions imposed by speci?c compressed internal formats will be
invariant, meaning that if the GL accepts and stores a texture image in
compressed form, providing the same image to CompressedTexImage1D,
CompressedTexImage2D, or CompressedTexImage3D will not result in an
INVALID OPERATIONerrorifthefollowingrestrictionsaresatis?ed:
• datapointstoacompressedtextureimagereturnedbyGetCompressedTex-
Image(section6.1.4).
• target, level, and internalformat match the target, level and format parame-
tersprovidedtotheGetCompressedTexImagecallreturning data.
• width, height, depth, border, internalformat, and image-
Size match the values of TEXTURE WIDTH, TEXTURE HEIGHT,
TEXTURE DEPTH, TEXTURE BORDER, TEXTURE INTERNAL FORMAT,
and TEXTURE COMPRESSED IMAGE SIZE for image level level in effect at
thetimeoftheGetCompressedTexImagecallreturning data.
This guarantee applies not just to images returned by GetCompressedTexImage,
but also to any other properly encoded compressed texture image of the same size
andformat.
Thecommands
void CompressedTexSubImage1D(enum target,int level,
int xoffset,sizei width,enum format,sizei imageSize,
void *data);
Version2.1-December1,20063.8. TEXTURING 167
void CompressedTexSubImage2D(enum target,int level,
int xoffset,int yoffset,sizei width,sizei height,
enum format,sizei imageSize,void *data);
void CompressedTexSubImage3D(enum target,int level,
int xoffset,int yoffset,int zoffset,sizei width,
sizei height,sizei depth,enum format,
sizei imageSize,void *data);
respecifyonlyarectangularregionofanexistingtexturearray,withincomingdata
storedinaknowncompressedimageformat. Thetarget,level,xoffset,yoffset,zoff-
set, width, height, and depth parameters have the same meaning as in TexSubIm-
age1D, TexSubImage2D, and TexSubImage3D. data points to compressed im-
age data stored in the compressed image format corresponding to format. Since
the core GL provides no speci?c image formats, using any of these six generic
compressedinternalformatsas formatwillresultinanINVALID ENUMerror.
The image pointed to by data and the imageSize parameter are interpreted
as though they were provided to CompressedTexImage1D, CompressedTexIm-
age2D, and CompressedTexImage3D. These commands do not provide for im-
age format conversion, so an INVALID OPERATION error results if format does
not match the internal format of the texture image being modi?ed. If the image-
Size parameter is not consistent with the format, dimensions, and contents of the
compressedimage(toolittleortoomuchdata),anINVALID VALUEerrorresults.
As with CompressedTexImage calls, compressed internal formats may have
additional restrictions on the use of the compressed image speci?cation calls or
parameters. Any such restrictions will be documented in the speci?cation de?n-
ing the compressed internal format; violating these restrictions will result in an
INVALID OPERATIONerror.
Any restrictions imposed by speci?c compressed internal formats will be
invariant, meaning that if the GL accepts and stores a texture image in com-
pressed form, providing the same image to CompressedTexSubImage1D, Com-
pressedTexSubImage2D, CompressedTexSubImage3D will not result in an
INVALID OPERATIONerrorifthefollowingrestrictionsaresatis?ed:
• datapointstoacompressedtextureimagereturnedbyGetCompressedTex-
Image(section6.1.4).
• target, level, and format match the target, level and format parameters pro-
videdtotheGetCompressedTexImagecallreturning data.
• width, height, depth, format, and imageSize match the val-
ues of TEXTURE WIDTH, TEXTURE HEIGHT, TEXTURE DEPTH,
Version2.1-December1,2006168 CHAPTER3. RASTERIZATION
TEXTURE INTERNAL FORMAT, and TEXTURE COMPRESSED IMAGE SIZE
for image level level in effect at the time of the GetCompressedTexImage
callreturning data.
• width, height, depth, format match the values of TEXTURE WIDTH,
TEXTURE HEIGHT, TEXTURE DEPTH, and TEXTURE INTERNAL FORMAT
currentlyineffectforimagelevel level.
• xoffset, yoffset, and zoffset are all ?b, where b is the value of
TEXTURE BORDERcurrentlyineffectforimagelevel level.
ThisguaranteeappliesnotjusttoimagesreturnedbyGetCompressedTexIm-
age,butalsotoanyotherproperlyencodedcompressedtextureimageofthesame
size.
Calling CompressedTexSubImage3D, CompressedTexSubImage2D, or
CompressedTexSubImage1DwillresultinanINVALID OPERATIONerrorifxoff-
set, yoffset, or zoffset is not equal to?b (border width), or if width, height,
s
and depth do not match the values of TEXTURE WIDTH, TEXTURE HEIGHT, or
TEXTURE DEPTH,respectively. Thecontentsofanytexeloutsidetheregionmodi-
?ed by the call are unde?ned. These restrictions may be relaxed for speci?c com-
pressedinternalformatswhoseimagesareeasilymodi?ed.
3.8.4 TextureParameters
Various parameters control how the texture array is treated when speci?ed or
changed,andwhenappliedtoafragment. Eachparameterissetbycalling
void TexParameter{if}(enum target,enum pname,T param);
void TexParameter{if}v(enum target,enum pname,
T params);
target is the target, either TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, or
TEXTURE CUBE MAP. pname is a symbolic constant indicating the parameter to
beset;thepossibleconstantsandcorrespondingparametersaresummarizedinta-
ble 3.18. In the ?rst form of the command, param is a value to which to set a
single-valued parameter; in the second form of the command, params is an array
of parameters whose type depends on the parameter being set. If the values for
TEXTURE BORDER COLOR, or the value for TEXTURE PRIORITY are speci?ed as
integers, the conversion for signed integers from table 2.9 is applied to convert
thesevaluesto?oating-point,followedbyclampingeachvaluetoliein [0,1].
In the remainder of section 3.8, denote by lod , lod , level ,
min max base
and level the values of the texture parameters TEXTURE MIN LOD,
max
Version2.1-December1,20063.8. TEXTURING 169
Name Type LegalValues
TEXTURE WRAP S enum CLAMP,CLAMP TO EDGE,REPEAT,
CLAMP TO BORDER,
MIRRORED REPEAT
TEXTURE WRAP T enum CLAMP,CLAMP TO EDGE,REPEAT,
CLAMP TO BORDER,
MIRRORED REPEAT
TEXTURE WRAP R enum CLAMP,CLAMP TO EDGE,REPEAT,
CLAMP TO BORDER,
MIRRORED REPEAT
TEXTURE MIN FILTER enum NEAREST,
LINEAR,
NEAREST MIPMAP NEAREST,
NEAREST MIPMAP LINEAR,
LINEAR MIPMAP NEAREST,
LINEAR MIPMAP LINEAR,
TEXTURE MAG FILTER enum NEAREST,
LINEAR
TEXTURE BORDER COLOR 4?oats any4valuesin[0,1]
TEXTURE PRIORITY ?oat anyvaluein[0,1]
TEXTURE MIN LOD ?oat anyvalue
TEXTURE MAX LOD ?oat anyvalue
TEXTURE BASE LEVEL integer anynon-negativeinteger
TEXTURE MAX LEVEL integer anynon-negativeinteger
TEXTURE LOD BIAS ?oat anyvalue
DEPTH TEXTURE MODE enum LUMINANCE,INTENSITY,ALPHA
TEXTURE COMPARE MODE enum NONE,COMPARE R TO TEXTURE
TEXTURE COMPARE FUNC enum LEQUAL,GEQUAL
LESS,GREATER,
EQUAL,NOTEQUAL,
ALWAYS,NEVER
GENERATE MIPMAP boolean TRUEorFALSE
Table3.18: Textureparametersandtheirvalues.
Version2.1-December1,2006170 CHAPTER3. RASTERIZATION
MajorAxisDirection Target s t m
c c a
+r TEXTURE CUBE MAP POSITIVE X ?r ?r r
x z y x
?r TEXTURE CUBE MAP NEGATIVE X r ?r r
x z y x
+r TEXTURE CUBE MAP POSITIVE Y r r r
y x z y
?r TEXTURE CUBE MAP NEGATIVE Y r ?r r
y x z y
+r TEXTURE CUBE MAP POSITIVE Z r ?r r
z x y z
?r TEXTURE CUBE MAP NEGATIVE Z ?r ?r r
z x y z
Table3.19: Selectionofcubemapimagesbasedonmajoraxisdirectionoftexture
coordinates.
TEXTURE MAX LOD, TEXTURE BASE LEVEL, and TEXTURE MAX LEVEL respec-
tively.
Texture parameters for a cube map texture apply to the cube map as a whole;
the six distinct two-dimensional texture images use the texture parameters of the
cubemapitself.
If the value of texture parameter GENERATE MIPMAP is TRUE, specifying or
changing texture arrays may have side effects, which are discussed in the Auto-
maticMipmapGenerationdiscussionofsection3.8.8.
3.8.5 DepthComponentTextures
Depth textures can be treated asLUMINANCE,INTENSITY orALPHA textures dur-
ingtexture?lteringandapplication(seesection3.8.14). Theinitialstatefordepth
texturestreatsthemasLUMINANCEtextures.
3.8.6 CubeMapTextureSelection
Whencubemaptexturingisenabled,the(s t r)texturecoordinatesaretreated
as a direction vector (r r r ) emanating from the center of a cube (the q
x y z
coordinate can be ignored, since it merely scales the vector without affecting the
direction.) Attextureapplicationtime,theinterpolatedper-fragmentdirectionvec-
torselectsoneofthecubemapface’stwo-dimensionalimagesbasedonthelargest
magnitude coordinate direction (the major axis direction). If two or more coor-
dinates have the identical magnitude, the implementation may de?ne the rule to
disambiguate this situation. The rule must be deterministic and depend only on
(r r r ). Thetargetcolumnintable3.19explainshowthemajoraxisdirec-
x y z
tionmapstothetwo-dimensionalimageofaparticularcubemaptarget.
Version2.1-December1,20063.8. TEXTURING 171
Usingthes ,t ,andm determinedbythemajoraxisdirectionasspeci?edin
c c a
table3.19,anupdated(s t)iscalculatedasfollows:
 
1 s
c
s = +1
2 |m|
a
 
1 t
c
t = +1
2 |m|
a
This new (s t) is used to ?nd a texture value in the determined face’s two-
dimensionaltextureimageusingtherulesgiveninsections3.8.7through3.8.9.
3.8.7 TextureWrapModes
Wrap modes de?ned by the values of TEXTURE WRAP S, TEXTURE WRAP T, or
TEXTURE WRAP R respectively affect the interpretation of s, t, and r texture co-
ordinates. Theeffectofeachmodeisdescribedbelow.
WrapModeREPEAT
WrapmodeREPEATignorestheintegerpartoftexturecoordinates,usingonlythe
fractional part. (For a number f, the fractional part is f?bfc, regardless of the
signoff;recallthatthebcfunctiontruncatestowards??.)
REPEATisthedefaultbehaviorforalltexturecoordinates.
WrapModeCLAMP
WrapmodeCLAMPclampstexturecoordinatestorange[0,1].
WrapModeCLAMP TO EDGE
WrapmodeCLAMP TO EDGEclampstexturecoordinatesatallmipmaplevelssuch
thatthetexture?lterneversamplesabordertexel. Thecolorreturnedwhenclamp-
ingisderivedonlyfromtexelsattheedgeofthetextureimage.
Texturecoordinatesareclampedtotherange[min,max]. Theminimumvalue
isde?nedas
1
min =
2N
where N is the size of the one-, two-, or three-dimensional texture image in the
directionofclamping. Themaximumvalueisde?nedas
Version2.1-December1,2006172 CHAPTER3. RASTERIZATION
max = 1?min
so that clamping is always symmetric about the [0,1] mapped range of a texture
coordinate.
WrapModeCLAMP TO BORDER
Wrap mode CLAMP TO BORDER clamps texture coordinates at all mipmaps such
thatthetexture?lteralwayssamplesbordertexelsforfragmentswhosecorrespond-
ingtexturecoordinateissuf?cientlyfaroutsidetherange[0,1]. Thecolorreturned
whenclampingisderivedonlyfromthebordertexelsofthetextureimage,orfrom
theconstantbordercolorifthetextureimagedoesnothaveaborder.
Texturecoordinatesareclampedtotherange[min,max]. Theminimumvalue
isde?nedas
?1
min =
2N
whereN isthesize(notincludingborders)oftheone-,two-,orthree-dimensional
textureimageinthedirectionofclamping. Themaximumvalueisde?nedas
max = 1?min
so that clamping is always symmetric about the [0,1] mapped range of a texture
coordinate.
WrapModeMIRRORED REPEAT
WrapmodeMIRRORED REPEAT?rstmirrorsthetexturecoordinate,wheremirror-
ingavaluef computes
(
f?bfc, bfciseven
mirror(f) =
1?(f?bfc), bfcisodd
The mirrored coordinate is then clamped as described above for wrap mode
CLAMP TO EDGE.
3.8.8 TextureMinification
Applying a texture to a primitive implies a mapping from texture image space to
framebuffer image space. In general, this mapping involves a reconstruction of
the sampled texture image, followed by a homogeneous warping implied by the
Version2.1-December1,20063.8. TEXTURING 173
mapping to framebuffer space, then a ?ltering, followed ?nally by a resampling
of the ?ltered, warped, reconstructed image before applying it to a fragment. In
theGLthismappingisapproximatedbyoneoftwosimple?lteringschemes. One
of these schemes is selected based on whether the mapping from texture space to
framebufferspaceisdeemedto magnifyor minifythetextureimage.
ScaleFactorandLevelofDetail
The choice is governed by a scale factor ?(x,y) and the level-of-detail parameter
?(x,y),de?nedas
? (x,y) = log [?(x,y)] (3.18)
base
2
0
?(x,y) =? (x,y)+clamp(bias +bias +bias ) (3.19)
base texobj texunit shader
?
0
? lod , ? >lod
max max
?
?
?
0 0
?, lod ?? ?lod
min max
? = (3.20)
0
? lod , ? <lod
min min
?
?
?
undefined, lod >lod
min max
bias is the value ofTEXTURE LOD BIAS for the bound texture object (as de-
texobj
scribed in section 3.8.4). bias is the value of TEXTURE LOD BIAS for the
texunit
current texture unit (as described in section 3.8.13). bias is the value of
shader
the optional bias parameter in the texture lookup functions available to fragment
shaders. Ifthetextureaccessisperformedinafragmentshaderwithoutaprovided
bias,oroutsideafragmentshader,thenbias iszero. Thesumofthesevalues
shader
is clamped to the range [?bias ,bias ] where bias is the value of the
max max max
implementationde?nedconstantMAX TEXTURE LOD BIAS.
If ?(x,y) is less than or equal to the constant c (described below in sec-
tion3.8.9)thetextureissaidtobemagni?ed;ifitisgreater,thetextureismini?ed.
The initial values of lod and lod are chosen so as to never clamp the
min max
normal range of?. They may be respeci?ed for a speci?c texture by calling Tex-
Parameter[if] with pname set to TEXTURE MIN LOD or TEXTURE MAX LOD re-
spectively.
Let s(x,y) be the function that associates an s texture coordinate with each
set of window coordinates (x,y) that lie within a primitive; de?ne t(x,y) and
r(x,y) analogously. Let u(x,y) = w ? s(x,y), v(x,y) = h ? t(x,y), and
t t
w(x,y) =d?r(x,y),wherew ,h ,andd areasde?nedbyequations3.15,3.16,
t t t t
and 3.17 with w , h , and d equal to the width, height, and depth of the image
s s s
Version2.1-December1,2006174 CHAPTER3. RASTERIZATION
array whose level is level . For a one-dimensional texture, de?ne v(x,y)?
base
0 and w(x,y) ? 0; for a two-dimensional texture, de?ne w(x,y) ? 0. For a
polygon,?isgivenatafragmentwithwindowcoordinates(x,y)by
? ?
s
s
           
? 2 2 2 2 2 2?
?u ?v ?w ?u ?v ?w
? = max + + , + +
? ?
?x ?x ?x ?y ?y ?y
(3.21)
where?u/?xindicatesthederivativeofuwithrespecttowindowx,andsimilarly
fortheotherderivatives.
Foraline,theformulais
s
      
2 2 2
?u ?u ?v ?v ?w ?w
? = ?x+ ?y + ?x+ ?y + ?x+ ?y l,
?x ?y ?x ?y ?x ?y
(3.22)
where ?x = x ? x and ?y = y ? y with (x ,y ) and (x ,y ) being the
2 1 2 1 1 1 2 2
p
2 2
segment’swindowcoordinateendpointsandl = ?x +?y . Forapoint,pixel
rectangle,orbitmap,?? 1.
While it is generally agreed that equations 3.21 and 3.22 give the best results
when texturing, they are often impractical to implement. Therefore, an imple-
mentation may approximate the ideal ? with a function f(x,y) subject to these
conditions:
1. f(x,y) is continuous and monotonically increasing in each of|?u/?x|,
|?u/?y|,|?v/?x|,|?v/?y|,|?w/?x|,and|?w/?y|
2. Let
   
   
?u ?u
   
m = max ,
u
   
?x ?y
   
   
?v ?v
   
m = max ,
v
   
?x ?y
   
 
   
?w ?w
   
m = max , .
w
   
?x ?y
Thenmax{m ,m ,m }?f(x,y)?m +m +m .
u v w u v w
When ? indicates mini?cation, the value assigned to TEXTURE MIN FILTER
is used to determine how the texture value for a fragment is selected. When
Version2.1-December1,20063.8. TEXTURING 175
TEXTURE MIN FILTERisNEAREST,thetexelintheimagearrayoflevellevel
base
thatisnearest(inManhattandistance)tothatspeci?edby(s,t,r)isobtained. This
meansthetexelatlocation(i,j,k)becomesthetexturevalue,withigivenby
(
buc, s< 1
i = (3.23)
w ?1, s = 1
t
(RecallthatifTEXTURE WRAP SisREPEAT,then0?s< 1.) Similarly,j isfound
as
(
bvc, t< 1
j = (3.24)
h ?1, t = 1
t
andk isfoundas
(
bwc, r < 1
k = (3.25)
d ?1, r = 1
t
For a one-dimensional texture, j and k are irrelevant; the texel at location i be-
comesthetexturevalue. Foratwo-dimensionaltexture, k isirrelevant;thetexelat
location(i,j)becomesthetexturevalue.
When TEXTURE MIN FILTER is LINEAR, a 2? 2? 2 cube of texels in the
image array of levellevel is selected. This cube is obtained by ?rst wrapping
base
texturecoordinatesasdescribedinsection3.8.7,thencomputing
(
bu?1/2c modw , TEXTURE WRAP SisREPEAT
t
i =
0
bu?1/2c, otherwise
(
bv?1/2c modh , TEXTURE WRAP TisREPEAT
t
j =
0
bv?1/2c, otherwise
and
(
bw?1/2c modd , TEXTURE WRAP RisREPEAT
t
k =
0
bw?1/2c, otherwise
Then
(
(i +1) modw , TEXTURE WRAP SisREPEAT
0 t
i =
1
i +1, otherwise
0
(
(j +1) modh , TEXTURE WRAP TisREPEAT
0 t
j =
1
j +1, otherwise
0
Version2.1-December1,2006176 CHAPTER3. RASTERIZATION
and
(
(k +1) modd , TEXTURE WRAP RisREPEAT
0 t
k =
1
k +1, otherwise
0
Let
? = frac(u?1/2)
? = frac(v?1/2)
? = frac(w?1/2)
wherefrac(x)denotesthefractionalpartofx.
Forathree-dimensionaltexture,thetexturevalue ? isfoundas
? = (1??)(1??)(1??)? +?(1??)(1??)?
i j k i j k
0 0 0 1 0 0
+(1??)?(1??)? +??(1??)?
i j k i j k
0 1 0 1 1 0
+(1??)(1??)?? +?(1??)??
i j k i j k
0 0 1 1 0 1
+(1??)??? +????
i j k i j k
0 1 1 1 1 1
where? isthetexelatlocation(i,j,k)inthethree-dimensionaltextureimage.
ijk
Foratwo-dimensionaltexture,
? = (1??)(1??)? +?(1??)? +(1??)?? +??? (3.26)
i j i j i j i j
0 0 1 0 0 1 1 1
where? isthetexelatlocation(i,j)inthetwo-dimensionaltextureimage.
ij
Andforaone-dimensionaltexture,
? = (1??)? +??
i i
0 1
where? isthetexelatlocationiintheone-dimensionaltexture.
i
If any of the selected ? , ? , or ? in the above equations refer to a border
ij i
ijk
texelwithi<?b ,j <?b ,k <?b ,i?w ?b ,j?h ?b ,orj?d ?b ,
s s s s s s s s s
thenthebordervaluesde?nedbyTEXTURE BORDER COLORareusedinsteadofthe
unspeci?edvalueorvalues. Ifthetexturecontainscolorcomponents,thevaluesof
TEXTURE BORDER COLORareinterpretedasanRGBAcolortomatchthetexture’s
internalformatinamannerconsistentwithtable3.15. Ifthetexturecontainsdepth
components, the ?rst component of TEXTURE BORDER COLOR is interpreted as a
depthvalue.
Version2.1-December1,20063.8. TEXTURING 177
Mipmapping
TEXTURE MIN FILTER values NEAREST MIPMAP NEAREST,
NEAREST MIPMAP LINEAR, LINEAR MIPMAP NEAREST,
and LINEAR MIPMAP LINEAR each require the use of a mipmap. A mipmap is
an ordered set of arrays representing the same image; each array has a resolution
lower than the previous one. If the image array of level level , excluding its
base
border, has dimensionsw ?h ?d , then there areblog (max(w ,h ,d ))c+1
b b b b b b
2
image arrays in the mipmap. Numbering the levels such that levellevel is the
base
0thlevel,theitharrayhasdimensions
w h d
b b b
max(1,b c)?max(1,b c)?max(1,b c)
i i i
2 2 2
untilthelastarrayisreachedwithdimension1?1?1.
Each array in a mipmap is de?ned using TexImage3D, TexImage2D, Copy-
TexImage2D,TexImage1D,orCopyTexImage1D;thearraybeingsetisindicated
with the level-of-detail argument level. Level-of-detail numbers proceed from
level for the original texture array through p = blog (max(w ,h ,d ))c +
base b b b
2
level with each unit increase indicating an array of half the dimensions of the
base
previousone(roundeddowntothenextintegeriffractional)asalreadydescribed.
All arrays fromlevel throughq = min{p,level } must be de?ned, as dis-
base max
cussedinsection3.8.10.
The values of level and level may be respeci?ed for a speci?c tex-
base max
ture by calling TexParameter[if] with pname set to TEXTURE BASE LEVEL or
TEXTURE MAX LEVELrespectively.
TheerrorINVALID VALUEisgeneratedifeithervalueisnegative.
The mipmap is used in conjunction with the level of detail to approximate the
application of an appropriately ?ltered texture to a fragment. Let c be the value
of ? at which the transition from mini?cation to magni?cation occurs (since this
discussion pertains to mini?cation, we are concerned only with values of? where
?>c).
For mipmap ?lters NEAREST MIPMAP NEAREST and
LINEAR MIPMAP NEAREST,thedthmipmaparrayisselected,where
?
1
?
level , ??
? base
2
1 1 1
d = dlevel +?+ e?1, ?> ,level +??q + (3.27)
base base
2 2 2
?
? 1 1
q, ?> ,level +?>q +
base
2 2
The rules for NEAREST or LINEAR ?ltering are then applied to the selected
array.
Version2.1-December1,2006178 CHAPTER3. RASTERIZATION
Formipmap?ltersNEAREST MIPMAP LINEARandLINEAR MIPMAP LINEAR,
theleveld andd mipmaparraysareselected,where
1 2
(
q, level +??q
base
d = (3.28)
1
blevel +?c, otherwise
base
(
q, level +??q
base
d = (3.29)
2
d +1, otherwise
1
The rules for NEAREST or LINEAR ?ltering are then applied to each of the
selected arrays, yielding two corresponding texture values ? and ? . The ?nal
1 2
texturevalueisthenfoundas
? = [1?frac(?)]? +frac(?)? .
1 2
AutomaticMipmapGeneration
If the value of texture parameterGENERATE MIPMAP isTRUE, making any change
totheinteriororbordertexelsofthelevel arrayofamipmapwillalsocompute
base
a complete set of mipmap arrays (as de?ned in section 3.8.10) derived from the
modi?ed level array. Array levels level + 1 through p are replaced with
base base
the derived arrays, regardless of their previous contents. All other mipmap arrays,
includingthelevel array,areleftunchangedbythiscomputation.
base
Theinternalformatsandborderwidthsofthederivedmipmaparraysallmatch
those of the level array, and the dimensions of the derived arrays follow the
base
requirementsdescribedinsection3.8.10.
Thecontentsofthederivedarraysarecomputedbyrepeated,?lteredreduction
ofthelevel array. Noparticular?lteralgorithmisrequired,thoughabox?lter
base
is recommended as the default ?lter. In some implementations, ?lter quality may
beaffectedbyhints(section5.6).
Automatic mipmap generation is available only for non-proxy texture image
targets.
3.8.9 TextureMagnification
When ? indicates magni?cation, the value assigned to TEXTURE MAG FILTER
determines how the texture value is obtained. There are two possible values
for TEXTURE MAG FILTER: NEAREST and LINEAR. NEAREST behaves exactly as
NEAREST for TEXTURE MIN FILTER (equations 3.23, 3.24, and 3.25 are used);
LINEAR behaves exactly as LINEAR for TEXTURE MIN FILTER (equation 3.26 is
used). Thelevel-of-detail level texturearrayisalwaysusedformagni?cation.
base
Version2.1-December1,20063.8. TEXTURING 179
Finally, there is the choice of c, the mini?cation vs. magni?cation switch-
over point. If the magni?cation ?lter is given by LINEAR and the mini?cation
?lterisgivenbyNEAREST MIPMAP NEARESTorNEAREST MIPMAP LINEAR,then
c = 0.5. This is done to ensure that a mini?ed texture does not appear “sharper”
thanamagni?edtexture. Otherwisec = 0.
3.8.10 TextureCompleteness
A texture is said to be complete if all the image arrays and texture parameters
requiredtoutilizethetexturefortextureapplicationare consistentlyde?ned. The
de?nitionofcompletenessvariesdependingonthetexturedimensionality.
For one-, two-, or three-dimensional textures, a texture is complete if the fol-
lowingconditionsallholdtrue:
• The set of mipmap arrays level through q (where q is de?ned in the
base
Mipmappingdiscussionofsection3.8.8)wereeachspeci?edwiththesame
internalformat.
• Theborderwidthsofeacharrayarethesame.
• ThedimensionsofthearraysfollowthesequencedescribedintheMipmap-
pingdiscussionofsection3.8.8.
• level ?level
base max
• Eachdimensionofthelevel arrayispositive.
base
Array levels k where k < level or k > q are insigni?cant to the de?nition of
base
completeness.
For cube map textures, a texture is cube complete if the following conditions
allholdtrue:
• The level arrays of each of the six texture images making up the cube
base
maphaveidentical,positive,andsquaredimensions.
• Thelevel arrayswereeachspeci?edwiththesameinternalformat.
base
• Thelevel arrayseachhavethesameborderwidth.
base
Finally, a cube map texture is mipmap cube complete if, in addition to being
cubecomplete,eachofthesixtextureimagesconsideredindividuallyiscomplete.
Version2.1-December1,2006180 CHAPTER3. RASTERIZATION
EffectsofCompletenessonTextureApplication
If one-, two-, or three-dimensional texturing (but not cube map textur-
ing) is enabled for a texture unit at the time a primitive is rasterized, if
TEXTURE MIN FILTER is one that requires a mipmap, and if the texture image
boundtotheenabledtexturetargetisnotcomplete,thenitisasiftexturemapping
weredisabledforthattextureunit.
If cube map texturing is enabled for a texture unit at the time a primitive
is rasterized, and if the bound cube map texture is not cube complete, then it
is as if texture mapping were disabled for that texture unit. Additionally, if
TEXTURE MIN FILTER is one that requires a mipmap, and if the texture is not
mipmapcube complete, thenit isasif texturemappingwere disabledforthat tex-
tureunit.
EffectsofCompletenessonTextureImageSpecification
Animplementationmayallowatextureimagearrayoflevel1orgreatertobecre-
ated only if a mipmap complete set of image arrays consistent with the requested
array can be supported. A mipmap complete set of arrays is equivalent to a com-
pletesetofarrayswherelevel = 0andlevel = 1000,andwhere,excluding
base max
borders,thedimensionsoftheimagearraybeingcreatedareunderstoodtobehalf
thecorrespondingdimensionsofthenextlowernumberedarray(roundeddownto
thenextintegeriffractional).
3.8.11 TextureStateandProxyState
The state necessary for texture can be divided into two categories. First, there are
theninesetsofmipmaparrays(oneeachfortheone-,two-,andthree-dimensional
texturetargetsandsixforthecubemaptexturetargets)andtheirnumber. Eachar-
ray has associated with it a width, height (two- and three-dimensional and cube
map only), and depth (three-dimensional only), a border width, an integer de-
scribing the internal format of the image, six integer values describing the res-
olutions of each of the red, green, blue, alpha, luminance, and intensity com-
ponents of the image, a boolean describing whether the image is compressed or
not, and an integer size of a compressed image. Each initial texture array is
null (zero width, height, and depth, zero border width, internal format 1, with
the compressed ?ag set to FALSE, a zero compressed size, and zero-sized com-
ponents). Next, there are the two sets of texture properties; each consists of
the selected mini?cation and magni?cation ?lters, the wrap modes for s, t (two-
and three-dimensional and cube map only), and r (three-dimensional only), the
TEXTURE BORDER COLOR, two integers describing the minimum and maximum
Version2.1-December1,20063.8. TEXTURING 181
level of detail, two integers describing the base and maximum mipmap array,
a boolean ?ag indicating whether the texture is resident, a boolean indicating
whether automatic mipmap generation should be performed, three integers de-
scribing the depth texture mode, compare mode, and compare function, and the
priority associated with each set of properties. The value of the resident ?ag is
determinedbytheGLandmaychangeasaresultofotherGLoperations. The?ag
may only be queried, not set, by applications (see section 3.8.12). In the initial
state,thevalueassignedtoTEXTURE MIN FILTERisNEAREST MIPMAP LINEAR,
and the value for TEXTURE MAG FILTER is LINEAR. s, t, and r wrap modes
are all set to REPEAT. The values of TEXTURE MIN LOD and TEXTURE MAX LOD
are -1000 and 1000 respectively. The values of TEXTURE BASE LEVEL and
TEXTURE MAX LEVEL are 0 and 1000 respectively. TEXTURE PRIORITY is 1.0,
and TEXTURE BORDER COLOR is (0,0,0,0). The value of GENERATE MIPMAP
is false. The values of DEPTH TEXTURE MODE, TEXTURE COMPARE MODE, and
TEXTURE COMPARE FUNC are LUMINANCE, NONE, and LEQUAL respectively. The
initialvalueofTEXTURE RESIDENTisdeterminedbytheGL.
In addition to the one-, two-, and three-dimensional and the six cube map sets
of image arrays, the partially instantiated one-, two-, and three-dimensional and
onecubemapsetofproxyimagearraysaremaintained. Eachproxyarrayincludes
width, height (two- and three-dimensional arrays only), depth (three-dimensional
arrays only), border width, and internal format state values, as well as state for
thered,green,blue,alpha,luminance,andintensitycomponentresolutions. Proxy
arrays do not include image data, nor do they include texture properties. When
TexImage3D is executed with target speci?ed as PROXY TEXTURE 3D, the three-
dimensional proxy state values of the speci?ed level-of-detail are recomputed and
updated. If the image array would not be supported by TexImage3D called with
targetsettoTEXTURE 3D,noerrorisgenerated,buttheproxywidth,height,depth,
border width, and component resolutions are set to zero. If the image array would
be supported by such a call toTexImage3D, the proxy state values are set exactly
asthoughtheactualimagearraywerebeingspeci?ed. Nopixeldataaretransferred
orprocessedineithercase.
One-andtwo-dimensionalproxyarraysareoperatedoninthesamewaywhen
TexImage1Disexecutedwith targetspeci?edasPROXY TEXTURE 1D,orTexIm-
age2Disexecutedwith targetspeci?edasPROXY TEXTURE 2D.
The cube map proxy arrays are operated on in the same manner whenTexIm-
age2D is executed with the target ?eld speci?ed as PROXY TEXTURE CUBE MAP,
withtheadditionthatdeterminingthatagivencubemaptextureissupportedwith
PROXY TEXTURE CUBE MAP indicates that all six of the cube map 2D images are
supported. Likewise,ifthespeci?edPROXY TEXTURE CUBE MAPisnotsupported,
noneofthesixcubemap2Dimagesaresupported.
Version2.1-December1,2006182 CHAPTER3. RASTERIZATION
There is no image associated with any of the proxy textures. There-
fore PROXY TEXTURE 1D, PROXY TEXTURE 2D, and PROXY TEXTURE 3D, and
PROXY TEXTURE CUBE MAP cannot be used as textures, and their images must
never be queried using GetTexImage. The error INVALID ENUM is generated if
this is attempted. Likewise, there is no non level-related state associated with a
proxytexture,andGetTexParameterivorGetTexParameterfvmaynotbecalled
with a proxy texture target. The error INVALID ENUM is generated if this is at-
tempted.
3.8.12 TextureObjects
In addition to the default textures TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, and
TEXTURE CUBE MAP,namedone-,two-,andthree-dimensionalandcubemaptex-
tureobjectscanbecreatedandoperatedupon. Thenamespacefortextureobjects
istheunsignedintegers,withzeroreservedbytheGL.
A texture object is created by binding an unused name to TEXTURE 1D,
TEXTURE 2D, TEXTURE 3D, or TEXTURE CUBE MAP. The binding is effected by
calling
void BindTexture(enum target,uint texture);
with target set to the desired texture target and texture set to the unused name.
The resulting texture object is a new state vector, comprising all the state values
listed in section 3.8.11, set to the same initial values. If the new texture object is
bound to TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, or TEXTURE CUBE MAP, it is
andremainsaone-,two-,three-dimensional,orcubemaptexturerespectivelyuntil
itisdeleted.
BindTexture may also be used to bind an existing texture object to ei-
therTEXTURE 1D,TEXTURE 2D,TEXTURE 3D, orTEXTURE CUBE MAP. The error
INVALID OPERATION is generated if an attempt is made to bind a texture object
ofadifferenttargetthanthespeci?ed target. Ifthebindissuccessfulnochangeis
madetothestateoftheboundtextureobject,andanypreviousbindingto targetis
broken.
While a texture object is bound, GL operations on the target to which it is
boundaffecttheboundobject,andqueriesofthetargettowhichitisboundreturn
statefromtheboundobject. Iftexturemappingofthedimensionalityofthetarget
to which a texture object is bound is enabled, the state of the bound texture object
directsthetexturingoperation.
In the initial state, TEXTURE 1D, TEXTURE 2D, TEXTURE 3D,
and TEXTURE CUBE MAP have one-, two-, three-dimensional, and cube map tex-
ture state vectors respectively associated with them. In order that access to these
Version2.1-December1,20063.8. TEXTURING 183
initial textures not be lost, they are treated as texture objects all of whose names
are 0. The initial one-, two-, three-dimensional, and cube map texture is therefore
operated upon, queried, and applied asTEXTURE 1D,TEXTURE 2D,TEXTURE 3D,
orTEXTURE CUBE MAPrespectivelywhile0isboundtothecorrespondingtargets.
Textureobjectsaredeletedbycalling
void DeleteTextures(sizei n,uint *textures);
textures contains n names of texture objects to be deleted. After a texture object
is deleted, it has no contents or dimensionality, and its name is again unused. If
a texture that is currently bound to one of the targets TEXTURE 1D, TEXTURE 2D,
TEXTURE 3D, or TEXTURE CUBE MAP is deleted, it is as though BindTexture had
beenexecutedwiththesametargetandtexturezero. Unusednamesintexturesare
silentlyignored,asisthevaluezero.
Thecommand
void GenTextures(sizei n,uint *textures);
returns n previously unused texture object names in textures. These names are
marked as used, for the purposes of GenTextures only, but they acquire texture
state and a dimensionality only when they are ?rst bound, just as if they were
unused.
Animplementationmaychoosetoestablishaworkingsetoftextureobjectson
whichbindingoperationsareperformedwithhigherperformance. Atextureobject
thatiscurrentlypartoftheworkingsetissaidtobe resident. Thecommand
boolean AreTexturesResident(sizei n,uint *textures,
boolean *residences);
returnsTRUE if all of the n texture objects named in textures are resident, or if the
implementation does not distinguish a working set. If at least one of the texture
objectsnamedintexturesisnotresident,thenFALSEisreturned,andtheresidence
of each texture object is returned in residences. Otherwise the contents of resi-
dences are not changed. If any of the names in textures are unused or are zero,
FALSEisreturned,theerrorINVALID VALUEisgenerated,andthecontentsofres-
idences are indeterminate. The residence status of a single bound texture object
can also be queried by calling GetTexParameteriv or GetTexParameterfv with
target set to the target to which the texture object is bound, and pname set to
TEXTURE RESIDENT.
AreTexturesResidentindicatesonlywhetheratextureobjectiscurrentlyresi-
dent,notwhetheritcouldnotbemaderesident. Animplementationmaychooseto
Version2.1-December1,2006184 CHAPTER3. RASTERIZATION
makeatextureobjectresidentonlyon?rstuse,forexample. Theclientmayguide
theGLimplementationindeterminingwhichtextureobjectsshouldberesidentby
specifyingapriorityforeachtextureobject. Thecommand
void PrioritizeTextures(sizei n,uint *textures,
clampf *priorities);
setstheprioritiesofthe ntextureobjectsnamedin texturestothevaluesin priori-
ties. Eachpriorityvalueisclampedtotherange[0,1]beforeitisassigned. Zeroin-
dicatesthelowestpriority,withtheleastlikelihoodofbeingresident. Oneindicates
thehighestpriority,withthegreatestlikelihoodofbeingresident. Thepriorityofa
single bound texture object may also be changed by calling TexParameteri, Tex-
Parameterf,TexParameteriv,orTexParameterfvwithtargetsettothetargetto
whichthetextureobjectisbound,pnamesettoTEXTURE PRIORITY,andparam
orparams specifying the new priority value (which is clamped to the range [0,1]
before being assigned). PrioritizeTextures silently ignores attempts to prioritize
unusedtextureobjectnamesorzero(defaulttextures).
The texture object name space, including the initial one-, two-, and three-
dimensional texture objects, is shared among all texture units. A texture object
maybeboundtomorethanonetextureunitsimultaneously. Afteratextureobject
is bound, any GL operations on that target object affect any other texture units to
whichthesametextureobjectisbound.
TexturebindingisaffectedbythesettingofthestateACTIVE TEXTURE.
If a texture object is deleted, it as if all texture units which are bound to that
textureobjectarereboundtotextureobjectzero.
3.8.13 TextureEnvironmentsandTextureFunctions
Thecommand
void TexEnv{if}(enum target,enum pname,T param);
void TexEnv{if}v(enum target,enum pname,T params);
sets parameters of the texture environment that speci?es how texture values are
interpretedwhentexturingafragment,orsetsper-texture-unit?lteringparameters.
target must be one of POINT SPRITE, TEXTURE ENV or
TEXTURE FILTER CONTROL. pname is a symbolic constant indicating the
parametertobeset. Inthe?rstformofthecommand,paramisavaluetowhichto
set a single-valued parameter; in the second form, params is a pointer to an array
of parameters: either a single symbolic constant or a value or group of values to
whichtheparametershouldbeset.
Version2.1-December1,20063.8. TEXTURING 185
When target is POINT SPRITE, point sprite rasterization behavior is affected
asdescribedinsection3.3.
When target is TEXTURE FILTER CONTROL, pname must be
TEXTURE LOD BIAS. In this case the parameter is a single signed ?oating
point value, bias , that biases the level of detail parameter? as described in
texunit
section3.8.8.
When target is TEXTURE ENV, the possible environment parameters are
TEXTURE ENV MODE, TEXTURE ENV COLOR, COMBINE RGB, COMBINE ALPHA,
RGB SCALE, ALPHA SCALE, SRCn RGB, SRCn ALPHA, OPERANDn RGB, and
OPERANDn ALPHA,wheren=0,1,or2. TEXTURE ENV MODEmaybesettooneof
REPLACE,MODULATE,DECAL,BLEND,ADD,orCOMBINE.TEXTURE ENV COLORis
set to an RGBA color by providing four single-precision ?oating-point values in
therange[0,1](valuesoutsidethisrangeareclampedtoit). Ifintegersareprovided
forTEXTURE ENV COLOR, then they are converted to ?oating-point as speci?ed in
table2.9forsignedintegers.
The value of TEXTURE ENV MODE speci?es a texture function. The result of
this function depends on the fragment and the texture array value. The precise
formofthefunctiondependsonthebaseinternalformatsofthetexturearraysthat
werelastspeci?ed.
3
C and A are the primary color components of the incoming fragment; C
f f s
and A are the components of the texture source color, derived from the ?ltered
s
texture values R , G , B , A , L , and I as shown in table 3.20; C and A are
t t t t t t c c
the components of the texture environment color; C and A are the components
p p
resultingfromtheprevioustextureenvironment(fortextureenvironment0,C and
p
A areidenticaltoC andA ,respectively);andC andA aretheprimarycolor
p f f v v
componentscomputedbythetexturefunction.
Allofthesecolorvaluesareintherange[0,1]. Thetexturefunctionsarespec-
i?edintables3.21,3.22,and3.23.
If the value ofTEXTURE ENV MODE is COMBINE, the form of the texture func-
tion depends on the values of COMBINE RGB and COMBINE ALPHA, according to
table 3.23. The RGB and ALPHA results of the texture function are then multi-
pliedbythevaluesofRGB SCALEandALPHA SCALE,respectively. Theresultsare
clampedto[0,1].
The arguments Arg0, Arg1, and Arg2 are determined by the values of
SRCn RGB, SRCn ALPHA, OPERANDn RGB and OPERANDn ALPHA, where n = 0,
n n
1, or 2, as shown in tables 3.24 and 3.25. C andA denote the texture source
s s
3
Intheremainderofsection3.8.13,thenotationC isusedtodenoteeachofthethreecomponents
x
R ,G , andB of a color speci?ed byx. Operations onC are performed independently for each
x x x x
color component. TheA component of colors is usually operated on in a different fashion, and is
thereforedenotedseparatelybyA .
x
Version2.1-December1,2006186 CHAPTER3. RASTERIZATION
TextureBase Texturesourcecolor
InternalFormat C A
s s
ALPHA (0,0,0) A
t
LUMINANCE (L ,L ,L ) 1
t t t
LUMINANCE ALPHA (L ,L ,L ) A
t t t t
INTENSITY (I ,I ,I ) I
t t t t
RGB (R ,G ,B ) 1
t t t
RGBA (R ,G ,B ) A
t t t t
Table 3.20: Correspondenceof ?ltered texturecomponents to texturesource com-
ponents.
TextureBase REPLACE MODULATE DECAL
InternalFormat Function Function Function
ALPHA C =C C =C unde?ned
v p v p
A =A A =A A
v s v p s
LUMINANCE C =C C =C C unde?ned
v s v p s
(or1) A =A A =A
v p v p
LUMINANCE ALPHA C =C C =C C unde?ned
v s v p s
(or2) A =A A =A A
v s v p s
INTENSITY C =C C =C C unde?ned
v s v p s
A =A A =A A
v s v p s
RGB C =C C =C C C =C
v s v p s v s
(or3) A =A A =A A =A
v p v p v p
RGBA C =C C =C C C =C (1?A )+C A
v s v p s v p s s s
(or4) A =A A =A A A =A
v s v p s v p
Table3.21: TexturefunctionsREPLACE,MODULATE,andDECAL.
Version2.1-December1,20063.8. TEXTURING 187
TextureBase BLEND ADD
InternalFormat Function Function
ALPHA C =C C =C
v p v p
A =A A A =A A
v p s v p s
LUMINANCE C =C (1?C )+C C C =C +C
v p s c s v p s
(or1) A =A A =A
v p v p
LUMINANCE ALPHA C =C (1?C )+C C C =C +C
v p s c s v p s
(or2) A =A A A =A A
v p s v p s
INTENSITY C =C (1?C )+C C C =C +C
v p s c s v p s
A =A (1?A )+A A A =A +A
v p s c s v p s
RGB C =C (1?C )+C C C =C +C
v p s c s v p s
(or3) A =A A =A
v p v p
RGBA C =C (1?C )+C C C =C +C
v p s c s v p s
(or4) A =A A A =A A
v p s v p s
Table3.22: TexturefunctionsBLENDandADD.
colorandalphafromthetextureimageboundtotextureunitn
The state required for the current texture environment, for each texture unit,
consists of a six-valued integer indicating the texture function, an eight-valued in-
teger indicating theRGB combiner function and a six-valued integer indicating the
ALPHA combiner function, six four-valued integers indicating the combiner RGB
and ALPHA source arguments, three four-valued integers indicating the combiner
RGBoperands,threetwo-valuedintegersindicatingthecombiner ALPHAoperands,
and four ?oating-point environment color values. In the initial state, the texture
andcombinerfunctionsareeachMODULATE,thecombinerRGBandALPHAsources
areeachTEXTURE,PREVIOUS,andCONSTANTforsources0,1,and2respectively,
thecombinerRGBoperandsforsources0and1areeachSRC COLOR,thecombiner
RGB operand for source 2, as well as for the combiner ALPHA operands, are each
SRC ALPHA,andtheenvironmentcoloris(0,0,0,0).
The state required for the texture ?ltering parameters, for each texture unit,
consists of a single ?oating-point level of detail bias. The initial value of the bias
is0.0.
3.8.14 TextureComparisonModes
Texture values can also be computed according to a speci?ed comparison func-
tion. Texture parameter TEXTURE COMPARE MODE speci?es the comparison
operands,andparameterTEXTURE COMPARE FUNCspeci?esthecomparisonfunc-
Version2.1-December1,2006188 CHAPTER3. RASTERIZATION
COMBINE RGB TextureFunction
REPLACE Arg0
MODULATE Arg0?Arg1
ADD Arg0+Arg1
ADD SIGNED Arg0+Arg1?0.5
INTERPOLATE Arg0?Arg2+Arg1?(1?Arg2)
SUBTRACT Arg0?Arg1
DOT3 RGB 4?((Arg0 ?0.5)?(Arg1 ?0.5)+
r r
(Arg0 ?0.5)?(Arg1 ?0.5)+
g g
(Arg0 ?0.5)?(Arg1 ?0.5))
b b
DOT3 RGBA 4?((Arg0 ?0.5)?(Arg1 ?0.5)+
r r
(Arg0 ?0.5)?(Arg1 ?0.5)+
g g
(Arg0 ?0.5)?(Arg1 ?0.5))
b b
COMBINE ALPHA TextureFunction
REPLACE Arg0
MODULATE Arg0?Arg1
ADD Arg0+Arg1
ADD SIGNED Arg0+Arg1?0.5
INTERPOLATE Arg0?Arg2+Arg1?(1?Arg2)
SUBTRACT Arg0?Arg1
Table 3.23: COMBINE texture functions. The scalar expression computed for the
DOT3 RGBandDOT3 RGBAfunctionsisplacedintoeachofthe3(RGB)or4(RGBA)
components of the output. The result generated from COMBINE ALPHA is ignored
forDOT3 RGBA.
Version2.1-December1,20063.8. TEXTURING 189
SRCn RGB OPERANDn RGB Argument
TEXTURE SRC COLOR C
s
ONE MINUS SRC COLOR 1?C
s
SRC ALPHA A
s
ONE MINUS SRC ALPHA 1?A
s
n
TEXTUREn SRC COLOR C
s
n
ONE MINUS SRC COLOR 1?C
s
n
SRC ALPHA A
s
n
ONE MINUS SRC ALPHA 1?A
s
CONSTANT SRC COLOR C
c
ONE MINUS SRC COLOR 1?C
c
SRC ALPHA Ac
ONE MINUS SRC ALPHA 1?A
c
PRIMARY COLOR SRC COLOR C
f
ONE MINUS SRC COLOR 1?C
f
SRC ALPHA A
f
ONE MINUS SRC ALPHA 1?A
f
PREVIOUS SRC COLOR C
p
ONE MINUS SRC COLOR 1?C
p
SRC ALPHA A
p
ONE MINUS SRC ALPHA 1?A
p
Table3.24: ArgumentsforCOMBINE RGBfunctions.
SRCn ALPHA OPERANDn ALPHA Argument
TEXTURE SRC ALPHA A
s
ONE MINUS SRC ALPHA 1?A
s
n
TEXTUREn SRC ALPHA A
s
n
ONE MINUS SRC ALPHA 1?A
s
CONSTANT SRC ALPHA A
c
ONE MINUS SRC ALPHA 1?A
c
PRIMARY COLOR SRC ALPHA A
f
ONE MINUS SRC ALPHA 1?A
f
PREVIOUS SRC ALPHA A
p
ONE MINUS SRC ALPHA 1?A
p
Table3.25: ArgumentsforCOMBINE ALPHAfunctions.
Version2.1-December1,2006190 CHAPTER3. RASTERIZATION
tion. The format of the resulting texture sample is determined by the value of
DEPTH TEXTURE MODE.
DepthTextureComparisonMode
If the currently bound texture’s base internal format is DEPTH COMPONENT, then
TEXTURE COMPARE MODE,TEXTURE COMPARE FUNCandDEPTH TEXTURE MODE
control the output of the texture unit as described below. Otherwise, the texture
unitoperatesinthenormalmannerandtexturecomparisonisbypassed.
LetD bethedepthtexturevalue,intherange[0,1],andRbetheinterpolated
t
texturecoordinateclampedtotherange [0,1]. ThentheeffectivetexturevalueL ,
t
I ,orA iscomputedasfollows:
t t
IfthevalueofTEXTURE COMPARE MODEisNONE,then
r =D
t
If the value of TEXTURE COMPARE MODE is COMPARE R TO TEXTURE, then r
dependsonthetexturecomparisonfunctionasshownintable3.26.
TextureComparisonFunction Computedresultr
(
1.0, R?D
t
LEQUAL r =
0.0, R>D
t
(
1.0, R?D
t
GEQUAL r =
0.0, R<D
t
(
1.0, R<D
t
LESS r =
0.0, R?D
t
(
1.0, R>D
t
GREATER r =
0.0, R?D
t
(
1.0, R =D
t
EQUAL r =
0.0, R =6 D
t
(
1.0, R =6 D
t
NOTEQUAL r =
0.0, R =D
t
ALWAYS r = 1.0
NEVER r = 0.0
Table3.26: Depthtexturecomparisonfunctions.
The resulting r is assigned to L , I , or A if the value of
t t t
DEPTH TEXTURE MODEisrespectivelyLUMINANCE,INTENSITY,orALPHA.
Version2.1-December1,20063.8. TEXTURING 191
If the value of TEXTURE MAG FILTER is not NEAREST, or the value of
TEXTURE MIN FILTER is not NEAREST or NEAREST MIPMAP NEAREST, then r
may be computed by comparing more than one depth texture value to the texture
R coordinate. The details of this are implementation-dependent, but r should be a
valueintherange [0,1]whichisproportionaltothenumberofcomparisonpasses
orfailures.
3.8.15 sRGBTextureColorConversion
If the currently bound texture’s internal format is one of SRGB, SRGB8,
SRGB ALPHA, SRGB8 ALPHA8, SLUMINANCE ALPHA, SLUMINANCE8 ALPHA8,
SLUMINANCE, SLUMINANCE8, COMPRESSED SRGB, COMPRESSED SRGB ALPHA,
COMPRESSED SLUMINANCE, or COMPRESSED SLUMINANCE ALPHA, the red,
green, and blue components are converted from an sRGB color space to a lin-
earcolorspaceaspartof?lteringdescribedinsections3.8.8and3.8.9. Anyalpha
component is left unchanged. Ideally, implementations should perform this color
conversion on each sample prior to ?ltering but implementations are allowed to
perform this conversion after ?ltering (though this post-?ltering approach is infe-
riortoconvertingfromsRGBpriorto?ltering).
TheconversionfromansRGBencodedcomponent,c ,toalinearcomponent,
s
c ,isasfollows.
l
?
c
s
?
, c ? 0.04045
s
12.92
 
c = 2.4 (3.30)
l
c +0.055
s
?
, c > 0.04045
s
1.055
Assumec isthesRGBcomponentintherange[0,1].
s
3.8.16 TextureApplication
Texturing is enabled or disabled using the generic Enable and Disable com-
mands, respectively, with the symbolic constants TEXTURE 1D, TEXTURE 2D,
TEXTURE 3D, or TEXTURE CUBE MAP to enable the one-, two, three-dimensional,
or cube map texture, respectively. If both two- and one-dimensional textures are
enabled, the two-dimensional texture is used. If the three-dimensional and either
of the two- or one-dimensional textures is enabled, the three-dimensional texture
is used. If the cube map texture and any of the three-, two-, or one-dimensional
textures is enabled, then cube map texturing is used. If all texturing is disabled, a
rasterizedfragmentispassedonunalteredtothenextstageoftheGL(althoughits
texturecoordinatesmaybediscarded). Otherwise,atexturevalueisfoundaccord-
ingtotheparametervaluesofthecurrentlyboundtextureimageoftheappropriate
Version2.1-December1,2006192 CHAPTER3. RASTERIZATION
dimensionality using the rules given in sections 3.8.6 through 3.8.9. This texture
value is used along with the incoming fragment in computing the texture function
indicated by the currently bound texture environment. The result of this function
replaces the incoming fragment’s primary R, G, B, and A values. These are the
color values passed to subsequent operations. Other data associated with the in-
coming fragment remain unchanged, except that the texture coordinates may be
discarded.
Each texture unit is enabled and bound to texture objects independently from
theothertextureunits. Eachtextureunitfollowstheprecedencerulesforone-,two-
, three-dimensional, and cube map textures. Thus texture units can be performing
texture mapping of different dimensionalities simultaneously. Each unit has its
ownenableandbindingstates.
Each texture unit is paired with an environment function, as shown in ?g-
ure 3.11. The second texture function is computed using the texture value from
the second texture, the fragment resulting from the ?rst texture function computa-
tion and the second texture unit’s environment function. If there is a third texture,
thefragmentresultingfromthesecondtexturefunctioniscombinedwiththethird
texturevalueusingthethirdtextureunit’senvironmentfunctionandsoon. Thetex-
ture unit selected by ActiveTexture determines which texture unit’s environment
ismodi?edbyTexEnvcalls.
IfthevalueofTEXTURE ENV MODEisCOMBINE,thetexturefunctionassociated
with a given texture unit is computed using the values speci?ed by SRCn RGB,
SRCn ALPHA,OPERANDn RGBandOPERANDn ALPHA.IfTEXTUREnisspeci?edas
SRCn RGB or SRCn ALPHA, the texture value from texture unit n will be used in
computingthetexturefunctionforthistextureunit.
Texturingisenabledanddisabledindividuallyforeachtextureunit. Iftexturing
is disabled for one of the units, then the fragment resulting from the previous unit
is passed unaltered to the following unit. Individual texture units beyond those
speci?edbyMAX TEXTURE UNITSarealwaystreatedasdisabled.
If a texture unit is disabled or has an invalid or incomplete texture (as de?ned
insection 3.8.10)bound toit, thenblending isdisabledforthat textureunit. Ifthe
texture environment for a given enabled texture unit references a disabled texture
unit, or an invalid or incomplete texture that is bound to another unit, then the
resultsoftextureblendingareunde?ned.
Therequiredstate,pertextureunit,isfourbitsindicatingwhethereachofone-,
two-,three-dimensional,orcubemaptexturingisenabledordisabled. Intheintial
state,alltexturingisdisabledforalltextureunits.
Version2.1-December1,20063.8. TEXTURING 193
C
f
TE
0
CT
TE
0
1
CT
1 TE
2
CT
C’
TE
2
f
3
CT
3
C  = fragment primary color input to texturing
f 
C’ = fragment color output from texturing
  
f
CT = texture color from texture lookup i
i
TE = texture environment i 
i
Figure 3.11. Multitexture pipeline. Four texture units are shown; however, multi-
texturingmaysupportadifferentnumberofunitsdependingontheimplementation.
The input fragment color is successively combined with each texture according to
thestateofthecorrespondingtextureenvironment,andtheresultingfragmentcolor
passedasinputtothenexttextureunitinthepipeline.
Version2.1-December1,2006194 CHAPTER3. RASTERIZATION
3.9 ColorSum
At the beginning of color sum, a fragment has two RGBA colors: a primary color
c (whichtexturing,ifenabled,mayhavemodi?ed)andasecondarycolorc .
pri sec
If color sum is enabled, the R, G, and B components of these two colors are
summedtoproduceasinglepost-texturingRGBAcolor c. TheAcomponentofc
is taken from the A component ofc ; the A component ofc is unused. The
pri sec
componentsofcarethenclampedtotherange[0,1]. Ifcolorsumisdisabled,then
c isassignedtoc.
pri
Color sum is enabled or disabled using the generic Enable and Disable com-
mands,respectively,withthesymbolicconstantCOLOR SUM.Iflightingisenabled
andifavertexshaderisnotactive,thecolorsumstageisalwaysapplied,ignoring
thevalueofCOLOR SUM.
The state required is a single bit indicating whether color sum is enabled or
disabled. Intheinitialstate,colorsumisdisabled.
Colorsumhasnoeffectincolorindexmode,orifafragmentshaderisactive.
3.10 Fog
Ifenabled,fogblendsafogcolorwitharasterizedfragment’spost-texturingcolor
usingablendingfactorf. FogisenabledanddisabledwiththeEnableandDisable
commandsusingthesymbolicconstantFOG.
Thisfactorf iscomputedaccordingtooneofthreeequations:
f = exp(?d·c), (3.31)
2
f = exp(?(d·c) ),or (3.32)
e?c
f = (3.33)
e?s
If a vertex shader is active, or if the fog source, as de?ned below, is FOG COORD,
thencistheinterpolatedvalueofthefogcoordinateforthisfragment. Otherwise,
if the fog source is FRAGMENT DEPTH, then c is the eye-coordinate distance from
theeye,(0,0,0,1)ineyecoordinates,tothefragmentcenter. Theequationandthe
fogsource,alongwitheitherdoreands,isspeci?edwith
void Fog{if}(enum pname,T param);
void Fog{if}v(enum pname,T params);
Version2.1-December1,20063.10. FOG 195
If pname is FOG MODE, then param must be, or params must point to an inte-
ger that is one of the symbolic constants EXP, EXP2, or LINEAR, in which case
equation 3.31, 3.32, or 3.33, respectively, is selected for the fog calculation (if,
when 3.33 is selected,e = s, resultsare unde?ned). If pname isFOG COORD SRC,
then param must be, or params must point to an integer that is one of the sym-
bolic constants FRAGMENT DEPTH or FOG COORD. If pname is FOG DENSITY,
FOG START, or FOG END, then param is or params points to a value that is d, s,
or e, respectively. If d is speci?ed less than zero, the error INVALID VALUE re-
sults.
An implementation may choose to approximate the eye-coordinate distance
from the eye to each fragment center by|z|. Further, f need not be computed at
e
each fragment, but may be computed at each vertex and interpolated as other data
are.
No matter which equation and approximation is used to computef, the result
isclampedto[0,1]toobtainthe?nalf.
f is used differently depending on whether the GL is in RGBA or color index
mode. In RGBA mode, ifC represents a rasterized fragment’s R, G, or B value,
r
thenthecorrespondingvalueproducedbyfogis
C =fC +(1?f)C .
r f
(The rasterized fragment’s A value is not changed by fog blending.) The R, G, B,
and A values ofC are speci?ed by callingFog with pname equal toFOG COLOR;
f
in this case params points to four values comprisingC . If these are not ?oating-
f
point values, then they are converted to ?oating-point using the conversion given
in table 2.9 for signed integers. Each component of C is clamped to [0,1] when
f
speci?ed.
Incolorindexmode,theformulaforfogblendingis
I =i +(1?f)i
r f
where i is the rasterized fragment’s color index and i is a single-precision
r f
?oating-point value. (1? f)i is rounded to the nearest ?xed-point value with
f
the same number of bits to the right of the binary point asi , and the integer por-
r
n
tionofI ismasked(bitwiseANDed)with2 ?1,wherenisthenumberofbitsin
a color in the color index buffer (buffers are discussed in chapter 4). The value of
i issetbycallingFogwith pnamesettoFOG INDEXand parambeingor params
f
pointing to a single value for the fog index. The integer part ofi is masked with
f
n
2 ?1.
The state required for fog consists of a three valued integer to select the fog
equation, three ?oating-point values d, e, and s, an RGBA fog color and a fog
Version2.1-December1,2006196 CHAPTER3. RASTERIZATION
color index, a two-valued integer to select the fog coordinate source, and a single
bit to indicate whether or not fog is enabled. In the initial state, fog is disabled,
FOG COORD SRC is FRAGMENT DEPTH, FOG MODE is EXP, d = 1.0, e = 1.0, and
s = 0.0;C = (0,0,0,0)andi = 0.
f f
Foghasnoeffectifafragmentshaderisactive.
3.11 FragmentShaders
The sequence of operations that are applied to fragments that result from raster-
izing a point, line segment, polygon, pixel rectangle or bitmap as described in
sections3.8through3.10isa?xedfunctionalitymethodforprocessingsuchfrag-
ments. Applicationscanmoregenerallydescribetheoperationsthatoccuronsuch
fragmentsbyusinga fragment shader.
A fragment shader is an array of strings containing source code for the opera-
tionsthataremeanttooccuroneachfragmentthatresultsfromrasterizingapoint,
line segment, polygon, pixel rectangle or bitmap. The language used for fragment
shadersisdescribedintheOpenGLShadingLanguageSpecification.
A fragment shader only applies when the GL is in RGBA mode. Its operation
incolorindexmodeisunde?ned.
Fragment shaders are created as described in section 2.15.1 using a type pa-
rameter of FRAGMENT SHADER. They are attached to and used in program objects
asdescribedinsection2.15.2.
Whentheprogramobjectcurrentlyinuseincludesafragmentshader,itsfrag-
mentshaderisconsidered active,andisusedtoprocessfragments. Iftheprogram
object has no fragment shader, or no program object is currently in use, the ?xed-
functionfragmentprocessingoperationsdescribedinprevioussectionsareused.
3.11.1 ShaderVariables
Fragmentshaderscanaccessuniformsbelongingtothecurrentshaderobject. The
amount of storage available for fragment shader uniform variables is speci?ed by
the implementation dependent constant MAX FRAGMENT UNIFORM COMPONENTS.
This value represents the number of individual ?oating-point, integer, or boolean
values that can be held in uniform variable storage for a fragment shader. A link
errorwillbegeneratedifanattemptismadetoutilizemorethanthespaceavailable
forfragmentshaderuniformvariables.
Fragment shaders can read varying variables that correspond to the attributes
ofthefragmentsproducedbyrasterization. TheOpenGLShadingLanguageSpec-
i?cation de?nes a set of built-in varying variables that can be be accessed by a
Version2.1-December1,20063.11. FRAGMENTSHADERS 197
fragment shader. These built-in varying variables include the data associated with
a fragment that are used for ?xed-function fragment processing, such as the frag-
ment’s position, color, secondary color, texture coordinates, fog coordinate, and
eyez coordinate.
Additionally,whenavertexshaderisactive,itmayde?neoneormorevarying
variables (see section 2.15.3 and the OpenGL Shading Language Specification).
These values are interpolated across the primitive being rendered. The results of
these interpolations are available when varying variables of the same name are
de?nedinthefragmentshader.
User-de?ned varying variables are not saved in the current raster position.
When processing fragments generated by the rasterization of a pixel rectangle or
bitmap, that values of user-de?ned varying variables are unde?ned. Built-in vary-
ingvariableshavewell-de?nedvalues.
3.11.2 ShaderExecution
Ifafragmentshaderisactive,theexecutableversionofthefragmentshaderisused
toprocessincomingfragmentvaluesthataretheresultofpoint,linesegment,poly-
gon,pixelrectangleorbitmaprasterizationratherthanthe?xed-functionfragment
processingdescribedinsections3.8through3.10. Inparticular,
• The texture environments and texture functions described in section 3.8.13
arenotapplied.
• Textureapplicationasdescribedinsection3.8.16isnotapplied.
• Colorsumasdescribedinsection3.9isnotapplied.
• Fogasdescribedinsection3.10isnotapplied.
TextureAccess
When a texture lookup is performed in a fragment shader, the GL computes the
?ltered texture value ? in the manner described in sections 3.8.8 and 3.8.9, and
converts it to a texture source color C according to table 3.20 (section 3.8.13).
s
The GL returns a four-component vector (R ,G ,B ,A ) to the fragment shader.
s s s s
du du dv dv dw
For the purposes of level-of-detail calculations, the derivates , , , ,
dx dy dx dy dx
dw
and maybeapproximatedbyadifferencingalgorithmasdetailedinsection8.8
dy
oftheOpenGLShadingLanguagespeci?cation.
Version2.1-December1,2006198 CHAPTER3. RASTERIZATION
Texture lookups involving textures with depth component data can either re-
turn the depth data directly or return the results of a comparison with the r tex-
ture coordinate used to perform the lookup. The comparison operation is re-
quested in the shader by using the shadow sampler types (sampler1DShadow
orsampler2DShadow)andinthetextureusingtheTEXTURE COMPARE MODEpa-
rameter. These requests must be consistent; the results of a texture lookup are
unde?nedif:
• The sampler used in a texture lookup function is of type sampler1D or
sampler2D,andthetextureobject’sinternalformatisDEPTH COMPONENT,
andtheTEXTURE COMPARE MODEisnotNONE.
• Thesamplerusedinatexturelookupfunctionisoftypesampler1DShadow
or sampler2DShadow, and the texture object’s internal format is
DEPTH COMPONENT,andtheTEXTURE COMPARE MODEisNONE.
• Thesamplerusedinatexturelookupfunctionisoftypesampler1DShadow
or sampler2DShadow, and the texture object’s internal format is not
DEPTH COMPONENT.
Ifafragmentshaderusesasamplerwhoseassociatedtextureobjectisnotcom-
plete, as de?ned in section 3.8.10, the texture image unit will return (R,G,B,A)
=(0,0,0,1).
The number of separate texture units that can be accessed from within a
fragment shader during the rendering of a single primitive is speci?ed by the
implementation-dependentconstant MAX TEXTURE IMAGE UNITS.
ShaderInputs
The OpenGL Shading Language speci?cation describes the values that are avail-
ableasinputstothefragmentshader.
The built-in variable gl FragCoord holds the window coordinates x, y, z,
1
and for the fragment. The z component of gl FragCoord undergoes an im-
w
plied conversion to ?oating-point. This conversion must leave the values 0 and
1 invariant. Note that this z component already has a polygon offset added in, if
1
enabled (see section 3.5.5. The value is computed from thew coordinate (see
c
w
section 2.11), which is the result of the product of the projection matrix and the
vertex’seyecoordinates.
The built-in variables gl Color and gl SecondaryColor hold the R, G, B,
and A components, respectively, of the fragment color and secondary color. Each
Version2.1-December1,20063.11. FRAGMENTSHADERS 199
?xed-point color component undergoes an implied conversion to ?oating-point.
Thisconversionmustleavethevalues0and1invariant.
Thebuilt-invariable gl FrontFacingissettoTRUEifthefragmentisgener-
atedfromafrontfacingprimitive,andFALSEotherwise. Forfragmentsgenerated
from polygon, triangle, or quadrilateral primitives (including ones resulting from
polygonsrenderedaspointsorlines),thedeterminationismadebyexaminingthe
signoftheareacomputedbyequation2.6ofsection2.14.1(includingthepossible
reversal of this sign controlled by FrontFace). If the sign is positive, fragments
generated by the primitive are front facing; otherwise, they are back facing. All
otherfragmentsareconsideredfrontfacing.
ShaderOutputs
The OpenGL Shading Language speci?cation describes the values that may be
output by a fragment shader. These are gl FragColor, gl FragData[n], and
gl FragDepth. The ?nal fragment color values or the ?nal fragment data values
written by a fragment shader are clamped to the range [0,1] and then converted to
?xed-point as described in section 2.14.9. The ?nal fragment depth written by a
fragment shader is ?rst clamped to [0,1] and then converted to ?xed-point as if it
wereawindowz value(seesection2.11.1). Notethatthedepthrangecomputation
isnotappliedhere,onlytheconversionto?xed-point.
Writing to gl FragColor speci?es the fragment color (color number
zero) that will be used by subsequent stages of the pipeline. Writing to
gl FragData[n] speci?es the value of fragment color number n. Any colors,
or color components, associated with a fragment that are not written by the frag-
ment shader are unde?ned. A fragment shader may not statically assign values to
both gl FragColor and gl FragData. In this case, a compile or link error will
result. A shader statically assigns a value to a variable if, after pre-processing, it
containsastatementthatwouldwritetothevariable,whetherornotrun-time?ow
ofcontrolwillcausethatstatementtobeexecuted.
Writing to gl FragDepth speci?es the depth value for the fragment being
processed. If the active fragment shader does not statically assign a value to
gl FragDepth,thenthedepthvaluegeneratedduringrasterizationisusedbysub-
sequentstagesofthepipeline. Otherwise,thevalueassignedtogl FragDepthis
used, and is unde?ned for any fragments where statements assigning a value to
gl FragDepth are not executed. Thus, if a shader statically assigns a value to
gl FragDepth,thenitisresponsibleforalwayswritingit.
Version2.1-December1,2006200 CHAPTER3. RASTERIZATION
3.12 AntialiasingApplication
If antialiasing is enabled for the primitive from which a rasterized fragment was
produced, then the computed coverage value is applied to the fragment. In RGBA
mode, the value is multiplied by the fragment’s alpha (A) value to yield a ?nal
alpha value. In color index mode, the value is used to set the low order bits of
the color index value as described in section 3.2. The coverage value is applied
separatelytoeachfragmentcolor.
3.13 MultisamplePointFade
Finally,ifmultisamplingisenabledandtherasterizedfragmentresultsfromapoint
primitive, then the computed fade factor from equation 3.2 is applied to the frag-
ment. In RGBA mode, the fade factor is multiplied by the fragment’s alpha value
toyielda?nalalphavalue. Incolorindexmode,thefadefactorhasnoeffect. The
fadefactorisappliedseparatelytoeachfragmentcolor.
Version2.1-December1,2006Chapter 4
Per-FragmentOperationsandthe
Framebuffer
The framebuffer consists of a set of pixels arranged as a two-dimensional array.
The height and width of this array may vary from one GL implementation to an-
other. Forpurposesofthisdiscussion,eachpixelintheframebufferissimplyaset
ofsomenumberofbits. Thenumberofbitsperpixelmayalsovarydependingon
theparticularGLimplementationorcontext.
Corresponding bits from each pixel in the framebuffer are grouped together
intoabitplane;eachbitplanecontainsasinglebitfromeachpixel. Thesebitplanes
are grouped into several logical buffers. These are the color, depth, stencil, and
accumulation buffers. The color buffer actually consists of a number of buffers:
thefrontleftbuffer,thefrontrightbuffer,thebackleftbuffer,thebackrightbuffer,
and some number of auxiliary buffers. Typically the contents of the front buffers
are displayed on a color monitor while the contents of the back buffers are invisi-
ble. (Monoscopic contexts displayonly the front leftbuffer; stereoscopic contexts
display both the front left and the front right buffers.) The contents of the aux-
iliary buffers are never visible. All color buffers must have the same number of
bitplanes, although an implementation or context may choose not to provide right
buffers, back buffers, or auxiliary buffers at all. Further, an implementation or
contextmaynotprovidedepth,stencil,oraccumulationbuffers.
Color buffers consist of either unsigned integer color indices or R, G, B, and,
optionally,Aunsignedintegervalues. Thenumberofbitplanesineachofthecolor
buffers,thedepthbuffer,thestencilbuffer,andtheaccumulationbufferis?xedand
window dependent. If an accumulation buffer is provided, it must have at least as
manybitplanesperR,G,andBcolorcomponentasdothecolorbuffers.
Theinitialstateofallprovidedbitplanesisunde?ned.
201202 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
Fragment
Alpha
Pixel
Scissor
+
Test
Ownership
Test
(RGBA Only)
Associated
Test
Data
Depth buffer
Stencil 
Test
Test
Framebuffer Framebuffer
Blending To
Logicop
Dithering
(RGBA Only)
Framebuffer
Framebuffer Framebuffer
Figure4.1. Per-fragmentoperations.
4.1 Per-FragmentOperations
A fragment produced by rasterization with window coordinates of (x ,y ) mod-
w w
i?es the pixel in the framebuffer at that location based on a number of parame-
ters and conditions. We describe these modi?cations and tests, diagrammed in
?gure 4.1, in the order in which they are performed. Figure 4.1 diagrams these
modi?cationsandtests.
4.1.1 PixelOwnershipTest
The ?rst test is to determine if the pixel at location (x ,y ) in the framebuffer
w w
is currently owned by the GL (more precisely, by this GL context). If it is not,
the window system decides the fate the incoming fragment. Possible results are
that the fragment is discarded or that some subset of the subsequent per-fragment
operations are applied to the fragment. This test allows the window system to
controltheGL’sbehavior,forinstance,whenaGLwindowisobscured.
Version2.1-December1,20064.1. PER-FRAGMENTOPERATIONS 203
4.1.2 ScissorTest
The scissor test determines if (x ,y ) lies within the scissor rectangle de?ned by
w w
fourvalues. Thesevaluesaresetwith
void Scissor(int left,int bottom,sizei width,
sizei height);
If left? x < left+width and bottom? y < bottom+height, then the scissor
w w
test passes. Otherwise, the test fails and the fragment is discarded. The test is
enabled or disabled using Enable or Disable using the constant SCISSOR TEST.
When disabled, it is as if the scissor test always passes. If either width or height
is less than zero, then the error INVALID VALUE is generated. The state required
consists of four integer values and a bit indicating whether the test is enabled or
disabled. Intheinitialstateleft =bottom = 0;widthandheightaredetermined
bythesizeoftheGLwindow. Initially,thescissortestisdisabled.
4.1.3 MultisampleFragmentOperations
This step modi?es fragment alpha and coverage values based on the values
of SAMPLE ALPHA TO COVERAGE, SAMPLE ALPHA TO ONE, SAMPLE COVERAGE,
SAMPLE COVERAGE VALUE, and SAMPLE COVERAGE INVERT. No changes to the
fragment alpha or coverage values are made at this step if MULTISAMPLE is dis-
abled,orifthevalueofSAMPLE BUFFERSisnotone.
SAMPLE ALPHA TO COVERAGE, SAMPLE ALPHA TO ONE, and
SAMPLE COVERAGE are enabled and disabled by calling Enable and Disable
with cap speci?ed as one of the three token values. All three values are
queried by calling IsEnabled with cap set to the desired token value. If
SAMPLE ALPHA TO COVERAGE is enabled, a temporary coverage value is gen-
erated where each bit is determined by the alpha value at the corresponding
sample location. The temporary coverage value is then ANDed with the fragment
coveragevalue. Otherwisethefragmentcoveragevalueisunchangedatthispoint.
If multiple colors are written by a fragment shader, the alpha value of fragment
colorzeroisusedtodeterminethetemporarycoveragevalue.
No speci?c algorithm is required for converting the sample alpha values to a
temporary coverage value. It is intended that the number of 1’s in the temporary
coverage be proportional to the set of alpha values for the fragment, with all 1’s
corresponding to the maximum of all alpha values, and all 0’s corresponding to
all alpha values being 0. It is also intended that the algorithm be pseudo-random
in nature, to avoid image artifacts due to regular coverage sample locations. The
algorithm can and probably should be different at different pixel locations. If it
Version2.1-December1,2006204 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
doesdiffer,itshouldbede?nedrelativetowindow,notscreen,coordinates,sothat
renderingresultsareinvariantwithrespecttowindowposition.
Next,ifSAMPLE ALPHA TO ONEisenabled,eachalphavalueisreplacedbythe
maximumrepresentablealphavalue. Otherwise,thealphavaluesarenotchanged.
Finally, if SAMPLE COVERAGE is enabled, the fragment coverage is ANDed
with another temporary coverage. This temporary coverage is generated
in the same manner as the one described above, but as a function of
the value of SAMPLE COVERAGE VALUE. The function need not be identical,
but it must have the same properties of proportionality and invariance. If
SAMPLE COVERAGE INVERT is TRUE, the temporary coverage is inverted (all bit
valuesareinverted)beforeitisANDedwiththefragmentcoverage.
The values of SAMPLE COVERAGE VALUE and SAMPLE COVERAGE INVERT
arespeci?edbycalling
void SampleCoverage(clampf value,boolean invert);
with value set to the desired coverage value, and invert set to TRUE or FALSE.
value is clamped to [0,1] before being stored as SAMPLE COVERAGE VALUE.
SAMPLE COVERAGE VALUE is queried by calling GetFloatv with pname set to
SAMPLE COVERAGE VALUE. SAMPLE COVERAGE INVERT is queried by calling
GetBooleanvwith pnamesettoSAMPLE COVERAGE INVERT.
4.1.4 AlphaTest
This step applies only in RGBA mode. In color index mode, proceed to the next
operation. The alpha test discards a fragment conditional on the outcome of a
comparison between the incoming fragment’s alpha value and a constant value. If
multiplecolorsarewrittenbyafragmentshader,thealphavalueoffragmentcolor
zero is used to determine the result of the alpha test. The comparison is enabled
or disabled with the generic Enable and Disable commands using the symbolic
constant ALPHA TEST. When disabled, it is as if the comparison always passes.
Thetestiscontrolledwith
void AlphaFunc(enum func,clampf ref);
func is a symbolic constant indicating the alpha test function; ref is a reference
value. ref is clamped to lie in [0,1], and then converted to a ?xed-point value ac-
cording to the rules given for an A component in section 2.14.9. For purposes
of the alpha test, the fragment’s alpha value is also rounded to the nearest inte-
ger. ThepossibleconstantsspecifyingthetestfunctionareNEVER,ALWAYS,LESS,
LEQUAL, EQUAL, GEQUAL, GREATER, or NOTEQUAL, meaning pass the fragment
Version2.1-December1,20064.1. PER-FRAGMENTOPERATIONS 205
never,always,ifthefragment’salphavalueislessthan,lessthanorequalto,equal
to,greaterthanorequalto,greaterthan,ornotequaltothereferencevalue,respec-
tively.
The required state consists of the ?oating-point reference value, an eight-
valued integer indicating the comparison function, and a bit indicating if the com-
parison is enabled or disabled. The initial state is for the reference value to be 0
andthefunctiontobeALWAYS.Initially,thealphatestisdisabled.
4.1.5 StencilTest
The stencil test conditionally discards a fragment based on the outcome of a com-
parisonbetweenthevalueinthestencilbufferatlocation(x ,y )andareference
w w
value. The test is enabled or disabled with the Enable and Disable commands,
using the symbolic constant STENCIL TEST. When disabled, the stencil test and
associatedmodi?cationsarenotmade,andthefragmentisalwayspassed.
Thestenciltestiscontrolledwith
void StencilFunc(enum func,int ref,uint mask);
void StencilFuncSeparate(enum face,enum func,int ref,
uint mask);
void StencilOp(enum sfail,enum dpfail,enum dppass);
void StencilOpSeparate(enum face,enum sfail,enum dpfail,
enum dppass);
Therearetwosetsofstencil-relatedstate,thefrontstencilstatesetandtheback
stencilstateset. Stenciltestsandwritesusethefrontsetofstencilstatewhenpro-
cessing fragments rasterized from non-polygon primitives (points, lines, bitmaps,
imagerectangles)andfront-facingpolygonprimitiveswhilethebacksetofstencil
stateisusedwhenprocessingfragmentsrasterizedfromback-facingpolygonprim-
itives. For the purposes of stencil testing, a primitive is still considered a polygon
even if the polygon is to be rasterized as points or lines due to the current poly-
gon mode. Whether a polygon is front- or back-facing is determined in the same
mannerusedfortwo-sidedlightingandfaceculling(seesections 2.14.1and3.5.1).
StencilFuncSeparateandStencilOpSeparatetakeafaceargumentwhichcan
beFRONT,BACK,orFRONT AND BACKandindicateswhichsetofstateisaffected.
StencilFuncandStencilOpsetfrontandbackstencilstatetoidenticalvalues.
StencilFunc and StencilFuncSeparate take three arguments that control
whether the stencil test passes or fails. ref is an integer reference value that is
s
used in the unsigned stencil comparison. It is clamped to the range [0,2 ? 1],
where s is the number of bits in the stencil buffer. The s least signi?cant bits of
Version2.1-December1,2006206 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
mask are bitwise ANDed with both the reference and the stored stencil value, and
theresultingmaskedvaluesarethosethatparticipateinthecomparisoncontrolled
by func. func is a symbolic constant that determines the stencil comparison func-
tion; the eight symbolic constants are NEVER, ALWAYS, LESS, LEQUAL, EQUAL,
GEQUAL, GREATER, or NOTEQUAL. Accordingly, the stencil test passes never, al-
ways,andifthemaskedreferencevalueislessthan,lessthanorequalto,equalto,
greaterthanorequalto,greaterthan,ornotequaltothemaskedstoredvalueinthe
stencilbuffer.
StencilOp and StencilOpSeparate take three arguments that indicate what
happens to the stored stencil value if this or certain subsequent tests fail or pass.
sfail indicates what action is taken if the stencil test fails. The symbolic constants
are KEEP, ZERO, REPLACE, INCR, DECR, INVERT, INCR WRAP, and DECR WRAP.
These correspond to keeping the current value, setting to zero, replacing with the
reference value, incrementing with saturation, decrementing with saturation, bit-
wiseinvertingit,incrementingwithoutsaturation,anddecrementingwithoutsatu-
ration.
Forpurposesofincrementanddecrement,thestencilbitsareconsideredasan
unsignedinteger. Incrementingordecrementingwithsaturationclampsthestencil
value at 0 and the maximum representable value. Incrementing or decrementing
without saturation will wrap such that incrementing the maximum representable
valueresultsin0,anddecrementing0resultsinthemaximumrepresentablevalue.
The same symbolic values are given to indicate the stencil action if the depth
buffertest(seesection4.1.6)fails(dpfail),orifitpasses(dppass).
If the stencil test fails, the incoming fragment is discarded. The state required
consistsofthemostrecentvaluespassedtoStencilFuncorStencilFuncSeparate
andtoStencilOporStencilOpSeparate,andabitindicatingwhetherstenciltest-
ing is enabled or disabled. In the initial state, stenciling is disabled, the front and
back stencil reference value are both zero, the front and back stencil comparison
functions are both ALWAYS, and the front and back stencil mask are both all ones.
Initially,allthreefrontandbackstenciloperationsareKEEP.
Ifthereisnostencilbuffer,nostencilmodi?cationcanoccur,anditisasifthe
stenciltestsalwayspass,regardlessofanycallstoStencilFunc.
4.1.6 DepthBufferTest
The depth buffer test discards the incoming fragment if a depth comparison fails.
ThecomparisonisenabledordisabledwiththegenericEnableandDisablecom-
mands using the symbolic constant DEPTH TEST. When disabled, the depth com-
parisonandsubsequentpossibleupdatestothedepthbuffervaluearebypassedand
the fragment is passed to the next operation. The stencil value, however, is modi-
Version2.1-December1,20064.1. PER-FRAGMENTOPERATIONS 207
?edasindicatedbelowasifthedepthbuffertestpassed. Ifenabled,thecomparison
takesplaceandthedepthbufferandstencilvaluemaysubsequentlybemodi?ed.
Thecomparisonisspeci?edwith
void DepthFunc(enum func);
This command takes a single symbolic constant: one of NEVER, ALWAYS, LESS,
LEQUAL, EQUAL, GREATER, GEQUAL, NOTEQUAL. Accordingly, the depth buffer
test passes never, always, if the incoming fragment’s z value is less than, less
w
than or equal to, equal to, greater than, greater than or equal to, or not equal to
the depth value stored at the location given by the incoming fragment’s (x ,y )
w w
coordinates.
If the depth buffer test fails, the incoming fragment is discarded. The stencil
value at the fragment’s (x ,y ) coordinates is updated according to the function
w w
currently in effect for depth buffer test failure. Otherwise, the fragment continues
to the next operation and the value of the depth buffer at the fragment’s (x ,y )
w w
location is set to the fragment’sz value. In this case the stencil value is updated
w
accordingtothefunctioncurrentlyineffectfordepthbuffertestsuccess.
The necessary state is an eight-valued integer and a single bit indicating
whether depth buffering is enabled or disabled. In the initial state the function
isLESSandthetestisdisabled.
Ifthereisnodepthbuffer,itisasifthedepthbuffertestalwayspasses.
4.1.7 OcclusionQueries
Occlusion queries can be used to track the number of fragments or samples that
passthedepthtest.
Occlusionqueriesareassociatedwithqueryobjects.
Anocclusionquerycanbestartedand?nishedbycalling
void BeginQuery(enum target,uint id);
void EndQuery(enum target);
wheretargetisSAMPLES PASSED.IfBeginQueryiscalledwithanunusedid,that
nameismarkedasusedandassociatedwithanewqueryobject.
BeginQuery with a target of SAMPLES PASSED resets the current samples-
passed count to zero and sets the query active state to TRUE and the active query
id to id. EndQuery with a target of SAMPLES PASSED initializes a copy of the
currentsamples-passedcountintotheactiveocclusionqueryobject’sresultsvalue,
sets the active occlusion query object’s result available to FALSE, sets the query
activestatetoFALSE,andtheactivequeryidto0.
Version2.1-December1,2006208 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
If BeginQuery is called with an id of zero, while another query is already in
progress with the same target, or where id is the name of a query currently in
progress,anINVALID OPERATIONerrorisgenerated.
If EndQuery is called while no query with the same target is in progress, an
INVALID OPERATIONerrorisgenerated.
When an occlusion query is active, the samples-passed count increases by
a certain quantity for each fragment that passes the depth test. If the value of
SAMPLE BUFFERS is 0, then the samples-passed count increases by 1 for each
fragment. If the value of SAMPLE BUFFERS is 1, then the samples-passed count
increases by the number of samples whose coverage bit is set. However, imple-
mentations, at their discretion, are allowed to instead increase the samples-passed
countbythevalueofSAMPLESifanysampleinthefragmentiscovered.
n
Ifthesamples-passedcountover?ows,i.e.,exceedsthevalue 2 ?1(wheren
isthenumberofbitsinthesamples-passedcount),itsvaluebecomesunde?ned. It
is recommended, but not required, that implementations handle this over?ow case
n
bysaturatingat2 ?1andincrementingnofurther.
Thecommand
void GenQueries(sizei n,uint *ids);
returns n previously unused query object names in ids. These names are marked
as used, but no object is associated with them until the ?rst time they are used by
BeginQuery. Queryobjectscontainonepieceofstate,anintegerresultvalue. This
result value is initialized to zero when the object is created. Any positive integer
exceptforzero(whichisreservedfortheGL)isavalidqueryobjectname.
Queryobjectsaredeletedbycalling
void DeleteQueries(sizei n,const uint *ids);
idscontainsnnamesofqueryobjectstobedeleted. Afteraqueryobjectisdeleted,
itsnameisagainunused. Unusednamesin idsaresilentlyignored.
Calling either GenQueries or DeleteQueries while any query of any target is
activecausesanINVALID OPERATIONerrortobegenerated.
The necessary state is a single bit indicating whether an occlusion query is
active,theidenti?erofthecurrentlyactiveocclusionquery,andacounterkeeping
trackofthenumberofsamplesthathavepassed.
4.1.8 Blending
Blending combines the incoming source fragment’s R, G, B, and A values with
the destination R, G, B, and A values stored in the framebuffer at the fragment’s
(x ,y )location.
w w
Version2.1-December1,20064.1. PER-FRAGMENTOPERATIONS 209
Source and destination values are combined according to the blend equation,
quadruplets of source and destination weighting factors determined by the blend
functions,andaconstant blend colortoobtainanewsetofR,G,B,andAvalues,
as described below. Each of these ?oating-point values is clamped to [0,1] and
converted back to a ?xed-point value in the manner described in section 2.14.9.
Theresultingfourvaluesaresenttothenextoperation.
Blending is dependent on the incoming fragment’s alpha value and that of the
corresponding currently stored pixel. Blending applies only in RGBA mode; in
color index mode it is bypassed. Blending is enabled or disabled using Enable or
DisablewiththesymbolicconstantBLEND.Ifitisdisabled,oriflogicaloperation
oncolorvaluesisenabled(section4.1.10),proceedtothenextoperation.
If multiple fragment colors are being written to multiple buffers (see sec-
tion 4.2.1), blending is computed and applied separately for each fragment color
andthecorrespondingbuffer.
BlendEquation
Blendingiscontrolledbythe blend equations,de?nedbythecommands
void BlendEquation(enum mode);
void BlendEquationSeparate(enum modeRGB,
enum modeAlpha);
BlendEquationSeparate argument modeRGB determines the RGB blend func-
tion while modeAlpha determines the alpha blend equation. BlendEqua-
tion argument mode determines both the RGB and alpha blend equations.
modeRGB and modeAlpha must each be one of FUNC ADD, FUNC SUBTRACT,
FUNC REVERSE SUBTRACT,MIN,orMAX.
Destination (framebuffer) components are taken to be ?xed-point values rep-
resented according to the scheme in section 2.14.9 (Final Color Processing), as
are source (fragment) components. Constant color components are taken to be
?oating-pointvalues.
Priortoblending,each?xed-pointcolorcomponentundergoesanimpliedcon-
version to ?oating-point. This conversion must leave the values 0 and 1 invariant.
Blendingcomponentsaretreatedasifcarriedoutin?oating-point.
Table 4.1 provides the corresponding per-component blend equations for each
mode, whether acting on RGB components for modeRGB or the alpha component
for modeAlpha.
In the table, the s subscript on a color component abbreviation (R, G, B, or
A)referstothesourcecolorcomponentforanincomingfragment,thedsubscript
Version2.1-December1,2006210 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
Mode RGBComponents AlphaComponent
FUNC ADD R =R ?S +R ?D A =A ?S +A ?D
s r d r s a d a
G =G ?S +G ?D
s g d g
B =B ?S +B ?D
s b d b
FUNC SUBTRACT R =R ?S ?R ?D A =A ?S ?A ?D
s r d r s a d a
G =G ?S ?G ?D
s g d g
B =B ?S ?B ?D
s b d b
FUNC REVERSE SUBTRACT R =R ?D ?R ?S A =A ?D ?A ?S
d r s r d a s a
G =G ?D ?G ?S
g s g
d
B =B ?D ?B ?S
d b s b
MIN R = min(R ,R ) A = min(A ,A )
s d s d
G = min(G ,G )
s
d
B = min(B ,B )
s d
MAX R = max(R ,R ) A = max(A ,A )
s d s d
G = max(G ,G )
s
d
B = max(B ,B )
s d
Table4.1: RGBandalphablendequations.
on a color component abbreviation refers to the destination color component at
the corresponding framebuffer location, and thec subscript on a color component
abbreviationreferstotheconstantblendcolorcomponent. Acolorcomponentab-
breviation without a subscript refers to the new color component resulting from
blending. Additionally,S ,S ,S ,andS arethered,green,blue,andalphacom-
r g b a
ponents of the source weighting factors determined by the source blend function,
and D , D , D , and D are the red, green, blue, and alpha components of the
r g b a
destination weighting factors determined by the destination blend function. Blend
functionsaredescribedbelow.
BlendFunctions
The weighting factors used by the blend equation are determined by the blend
functions. Blendfunctionsarespeci?edwiththecommands
void BlendFuncSeparate(enum srcRGB,enum dstRGB,
enum srcAlpha,enum dstAlpha);
void BlendFunc(enum src,enum dst);
Version2.1-December1,20064.1. PER-FRAGMENTOPERATIONS 211
Function RGBBlendFactors AlphaBlendFactor
(S ,S ,S )or(D ,D ,D ) S orD
r g b r g b a a
ZERO (0,0,0) 0
ONE (1,1,1) 1
SRC COLOR (R ,G ,B ) A
s s s s
ONE MINUS SRC COLOR (1,1,1)?(R ,G ,B ) 1?A
s s s s
DST COLOR (R ,G ,B ) A
d d d d
ONE MINUS DST COLOR (1,1,1)?(R ,G ,B ) 1?A
d d d d
SRC ALPHA (A ,A ,A ) A
s s s s
ONE MINUS SRC ALPHA (1,1,1)?(A ,A ,A ) 1?A
s s s s
DST ALPHA (A ,A ,A ) A
d d d d
ONE MINUS DST ALPHA (1,1,1)?(A ,A ,A ) 1?A
d d d d
CONSTANT COLOR (R ,G ,B ) A
c c c c
ONE MINUS CONSTANT COLOR (1,1,1)?(R ,G ,B ) 1?A
c c c c
CONSTANT ALPHA (A ,A ,A ) A
c c c c
ONE MINUS CONSTANT ALPHA (1,1,1)?(A ,A ,A ) 1?A
c c c c
1 2
SRC ALPHA SATURATE (f,f,f) 1
Table 4.2: RGB and ALPHA source and destination blending functions and the
corresponding blend factors. Addition and subtraction of triplets is performed
component-wise.
1
SRC ALPHA SATURATE is valid only for source RGB and alpha blending func-
tions.
2
f = min(A ,1?A ).
s d
BlendFuncSeparateargumentssrcRGBanddstRGBdeterminethesourceand
destinationRGBblendfunctions,respectively,whilesrcAlphaanddstAlphadeter-
mine the source and destination alpha blend functions. BlendFunc argument src
determinesbothRGBandalphasourcefunctions, while dstdeterminesbothRGB
andalphadestinationfunctions.
The possible source and destination blend functions and their corresponding
computedblendfactorsaresummarizedintable4.2.
BlendColor
TheconstantcolorC tobeusedinblendingisspeci?edwiththecommand
c
void BlendColor(clampf red,clampf green,clampf blue,
clampf alpha);
Version2.1-December1,2006212 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
The four parameters are clamped to the range [0,1] before being stored. The
constantcolorcanbeusedinboththesourceanddestinationblendingfunctions
BlendingState
The state required for blending is two integers for the RGB and alpha blend equa-
tions, four integers indicating the source and destination RGB and alpha blending
functions,four?oating-pointvaluestostoretheRGBAconstantblendcolor,anda
bit indicatingwhether blending is enabledor disabled. Theinitial blend equations
for RGB and alpha are bothFUNC ADD. The initial blending functions areONE for
the source RGB and alpha functions and ZERO for the destination RGB and alpha
functions. The initial constant blend color is (R,G,B,A) = (0,0,0,0). Initially,
blendingisdisabled.
Blending occurs once for each color buffer currently enabled for writing (sec-
tion 4.2.1) using each buffer’s color forC . If a color buffer has no A value, then
d
A istakentobe1.
d
4.1.9 Dithering
Dithering selects between two color values or indices. In RGBA mode, consider
the value of any of the color components as a ?xed-point value with m bits to the
leftofthebinarypoint,wheremisthenumberofbitsallocatedtothatcomponent
in the framebuffer; call each such value c. For each c, dithering selects a value
c such that c ?{max{0,dce? 1},dce} (after this selection, treat c as a ?xed
1 1 1
point value in [0,1] with m bits). This selection may depend on the x and y
w w
coordinatesofthepixel. Incolorindexmode,thesameruleapplieswithcbeinga
single color index. c must not be larger than the maximum value representable in
theframebufferforeitherthecomponentortheindex,asappropriate.
Many dithering algorithms are possible, but a dithered value produced by any
algorithmmustdependonlytheincomingvalueandthefragment’sxandywindow
coordinates. If dithering is disabled, then each color component is truncated to a
?xed-pointvaluewithasmanybitsasthereareinthecorrespondingcomponentin
theframebuffer;acolorindexisroundedtothenearestintegerrepresentableinthe
colorindexportionoftheframebuffer.
DitheringisenabledwithEnableanddisabledwithDisableusingthesymbolic
constant DITHER. The state required is thus a single bit. Initially, dithering is
enabled.
Version2.1-December1,20064.1. PER-FRAGMENTOPERATIONS 213
4.1.10 LogicalOperation
Finally, a logical operation is applied between the incoming fragment’s color or
index values and the color or index values stored at the corresponding location in
theframebuffer. Theresultreplacesthevaluesintheframebufferatthefragment’s
(x ,y ) coordinates. The logical operation on color indices is enabled or dis-
w w
abledwithEnableorDisableusingthesymbolicconstantINDEX LOGIC OP.(For
compatibility with GL version 1.0, the symbolic constant LOGIC OP may also be
used.) ThelogicaloperationoncolorvaluesisenabledordisabledwithEnableor
Disable using the symbolic constant COLOR LOGIC OP. If the logical operation is
enabled for color values, it is as if blending were disabled, regardless of the value
of BLEND. If multiple fragment colors are being written to multiple buffers (see
section 4.2.1), the logical operation is computed and applied separately for each
fragmentcolorandthecorrespondingbuffer.
Thelogicaloperationisselectedby
void LogicOp(enum op);
opisasymbolicconstant;thepossibleconstantsandcorrespondingoperationsare
enumeratedintable4.3. Inthistable,sisthevalueoftheincomingfragmentandd
isthevaluestoredintheframebuffer. Thenumericvaluesassignedtothesymbolic
constants are the same as those assigned to the corresponding symbolic values in
theXwindowsystem.
Logical operations are performed independently for each color index buffer
that is selected for writing, or for each red, green, blue, and alpha value of each
color buffer that is selected for writing. The required state is an integer indicating
the logical operation, and two bits indicating whether the logical operation is en-
abled or disabled. The initial state is for the logic operation to be given by COPY,
andtobedisabled.
4.1.11 AdditionalMultisampleFragmentOperations
If the DrawBuffer mode isNONE, no change is made to any multisample or color
buffer. Otherwise,fragmentprocessingisasdescribedbelow.
If MULTISAMPLE is enabled, and the value of SAMPLE BUFFERS is one, the
alphatest,stenciltest,depthtest,blending,andditheringoperationsareperformed
foreachpixelsample,ratherthanjustonceforeachfragment. Failureofthealpha,
stencil, or depth test results in termination of the processing of that sample, rather
than discarding of the fragment. All operations are performed on the color, depth,
and stencil values stored in the multisample buffer (to be described in a following
section). Thecontentsofthecolorbuffersarenotmodi?edatthispoint.
Version2.1-December1,2006214 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
Argumentvalue Operation
CLEAR 0
AND s?d
AND REVERSE s?¬d
COPY s
AND INVERTED ¬s?d
NOOP d
XOR s xord
OR s?d
NOR ¬(s?d)
EQUIV ¬(s xord)
INVERT ¬d
OR REVERSE s?¬d
COPY INVERTED ¬s
OR INVERTED ¬s?d
NAND ¬(s?d)
SET all1’s
Table4.3: ArgumentstoLogicOpandtheircorrespondingoperations.
Stencil, depth, blending, and dithering operations are performed for a pixel
sample only if that sample’s fragment coverage bit is a value of 1. If the corre-
spondingcoveragebitis0,nooperationsareperformedforthatsample.
If MULTISAMPLE is disabled, and the value of SAMPLE BUFFERS is one, the
fragment may be treated exactly as described above, with optimization possible
becausethefragmentcoveragemustbesettofullcoverage. Furtheroptimizationis
allowed,however. Animplementationmaychoosetoidentifyacentermostsample,
and to perform alpha, stencil, and depth tests on only that sample. Regardless of
theoutcomeofthestenciltest,allmultisamplebufferstencilsamplevaluesareset
totheappropriatenewstencilvalue. Ifthedepthtestpasses,allmultisamplebuffer
depth sample values are set to the depth of the fragment’s centermost sample’s
depth value, and all multisample buffer color sample values are set to the color
valueoftheincomingfragment. Otherwise,nochangeismadetoanymultisample
buffercolorordepthvalue.
Afteralloperationshavebeencompletedonthemultisamplebuffer,thesample
values for each color in the multisample buffer are combined to produce a single
color value, and that value is written into the corresponding color buffers selected
byDrawBufferorDrawBuffers. Animplementationmaydeferthewritingofthe
color buffers until a later time, but the state of the framebuffer must behave as if
Version2.1-December1,20064.2. WHOLEFRAMEBUFFEROPERATIONS 215
the color buffers were updated as each fragment was processed. The method of
combinationisnotspeci?ed,thoughasimpleaveragecomputedindependentlyfor
eachcolorcomponentisrecommended.
4.2 WholeFramebufferOperations
Theprecedingsectionsdescribedtheoperationsthatoccurasindividualfragments
aresenttotheframebuffer. Thissectiondescribesoperationsthatcontroloraffect
thewholeframebuffer.
4.2.1 SelectingaBufferforWriting
The?rstsuchoperationiscontrollingthecolorbuffersintowhicheachofthefrag-
ment colors are written. This is accomplished with either DrawBuffer or Draw-
Buffers.
Thecommand
void DrawBuffer(enum buf);
de?nes the set of color buffers to which fragment color zero is written. buf is a
symbolic constant specifying zero, one, two, or four buffers for writing. The con-
stants areNONE,FRONT LEFT,FRONT RIGHT,BACK LEFT,BACK RIGHT,FRONT,
BACK,LEFT,RIGHT,FRONT AND BACK,andAUX0throughAUXm,wherem+1is
thenumberofavailableauxiliarybuffers.
Theconstantsrefertothefourpotentiallyvisiblebuffers front left, front right,
back left, and back right, and to the auxiliary buffers. Arguments other thanAUXi
that omit reference to LEFT or RIGHT refer to both left and right buffers. Argu-
mentsotherthanAUXithatomitreferencetoFRONTorBACKrefertobothfrontand
back buffers. AUXi enables drawing only to auxiliary bufferi. Each AUXi adheres
to AUXi = AUX0+i. The constants and the buffers they indicate are summarized
in table 4.4. If DrawBuffer is is supplied with a constant (other than NONE) that
does not indicate any of the color buffers allocated to the GL context, the error
INVALID OPERATIONresults.
DrawBuffer will set the draw buffer for fragment colors other than zero to
NONE.
Thecommand
void DrawBuffers(sizei n,const enum *bufs);
Version2.1-December1,2006216 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
symbolic front front back back aux
constant left right left right i
NONE
FRONT LEFT •
FRONT RIGHT •
BACK LEFT •
BACK RIGHT •
FRONT • •
BACK • •
LEFT • •
RIGHT • •
FRONT AND BACK • • • •
AUXi •
Table4.4: ArgumentstoDrawBufferandthebuffersthattheyindicate.
de?nes the draw buffers to which all fragment colors are written. n speci?es the
number of buffers in bufs. bufs is a pointer to an array of symbolic constants
specifyingthebuffertowhicheachfragmentcoloriswritten. Theconstantsmaybe
NONE,FRONT LEFT,FRONT RIGHT,BACK LEFT,BACK RIGHT,andAUX0through
AUXm,wherem+1isthenumberofavailableauxiliarybuffers. Thedrawbuffers
being de?ned correspond in order to the respective fragment colors. The draw
bufferforfragmentcolorsbeyond nissettoNONE.
Except for NONE, a buffer may not appear more then once in the array
pointed to by bufs. Specifying a buffer more then once will result in the error
INVALID OPERATION.
If?xed-functionfragmentshadingisbeingperformed, DrawBuffersspeci?es
asetofdrawbuffersintowhichthefragmentcoloriswritten.
If a fragment shader writes to gl FragColor, DrawBuffers speci?es a set
of draw buffers into which the single fragment color de?ned by gl FragColor
is written. If a fragment shader writes to gl FragData, DrawBuffers speci?es
a set of draw buffers into which each of the multiple fragment colors de?ned
by gl FragData are separately written. If a fragment shader writes to neither
gl FragColor nor gl FragData, the values of the fragment colors following
shaderexecutionareunde?ned,andmaydifferforeachfragmentcolor.
Themaximumnumberofdrawbuffersisimplementationdependentandmust
be at least 1. The number of draw buffers supported can be queried by calling
GetIntegervwiththesymbolicconstantMAX DRAW BUFFERS.
The constants FRONT, BACK, LEFT, RIGHT, and FRONT AND BACK are not
Version2.1-December1,20064.2. WHOLEFRAMEBUFFEROPERATIONS 217
valid in the bufs array passed to DrawBuffers, and will result in the error
INVALID OPERATION.Thisrestrictionisbecausetheseconstantsmaythemselves
refertomultiplebuffers,asshownintable4.4.
If DrawBuffers is supplied with a constant (other than NONE) that does
not indicate any of the color buffers allocated to the GL context, the error
INVALID OPERATION will be generated. If n is greater than the value of
MAX DRAW BUFFERS,theerrorINVALID VALUEwillbegenerated.
Indicating a buffer or buffers using DrawBuffer or DrawBuffers causes sub-
sequentpixelcolorvaluewritestoaffecttheindicatedbuffers.
SpecifyingNONEasthedrawbufferforanfragmentcolorwillinhibitthatfrag-
mentcolorfrombeingwrittentoanybuffer.
Monoscopic contexts include only left buffers, while stereoscopic contexts in-
clude both left and right buffers. Likewise, single buffered contexts include only
front buffers, while double buffered contexts include both front and back buffers.
ThetypeofcontextisselectedatGLinitialization.
The state required to handle color buffer selection is an integer for each sup-
ported fragment color. In the initial state, the draw buffer for fragment color zero
isFRONTiftherearenobackbuffers;otherwiseitisBACK.Theinitialstateofdraw
buffersforfragmentcolorsotherthenzeroisNONE.
4.2.2 FineControlofBufferUpdates
Four commands are used to mask the writing of bits to each of the logical frame-
buffersafterallper-fragmentoperationshavebeenperformed. Thecommands
void IndexMask(uint mask);
void ColorMask(boolean r,boolean g,boolean b,
boolean a);
control the color buffer or buffers (depending on which buffers are currently indi-
cated for writing). The least signi?cant n bits of mask, where n is the number of
bits in a color index buffer, specify a mask. Where a 1 appears in this mask, the
corresponding bit in the color index buffer (or buffers) is written; where a 0 ap-
pears,thebitisnotwritten. Thismaskappliesonlyincolorindexmode. InRGBA
mode,ColorMaskisusedtomaskthewritingofR,G,BandAvaluestothecolor
bufferorbuffers. r, g, b,and aindicatewhetherR,G,B,orAvalues,respectively,
arewrittenornot(avalueofTRUEmeansthatthecorrespondingvalueiswritten).
In the initial state, all bits (in color index mode) and all color values (in RGBA
mode)areenabledforwriting.
Thedepthbuffercanbeenabledordisabledforwritingz valuesusing
w
Version2.1-December1,2006218 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
void DepthMask(boolean mask);
Ifmaskisnon-zero,thedepthbufferisenabledforwriting;otherwise,itisdisabled.
Intheinitialstate,thedepthbufferisenabledforwriting.
Thecommands
void StencilMask(uint mask);
void StencilMaskSeparate(enum face,uint mask);
controlthewritingofparticularbitsintothestencilplanes.
The least signi?cants bits of mask comprise an integer mask (s is the number
ofbitsinthestencilbuffer),justasforIndexMask. ThefaceparameterofStencil-
MaskSeparate can be FRONT, BACK, or FRONT AND BACK and indicates whether
the front or back stencil mask state is affected. StencilMask sets both front and
backstencilmaskstatetoidenticalvalues.
Fragments generated by front facing primitives use the front mask and frag-
ments generated by back facing primitives use the back mask (see section 4.1.5).
The clear operation always uses the front stencil write mask when clearing the
stencilbuffer.
The state required for the various masking operations is three integers and a
bit: an integer for color indices, an integer for the front and back stencil values,
andabitfordepthvalues. Asetoffourbitsisalsorequiredindicatingwhichcolor
components of an RGBA value should be written. In the initial state, the integer
masks are all ones, as are the bits controlling depth value and RGBA component
writing.
FineControlofMultisampleBufferUpdates
WhenthevalueofSAMPLE BUFFERSisone,ColorMask,DepthMask,andSten-
cilMask orStencilMaskSeparate control the modi?cation of values in the multi-
sample buffer. The color mask has no effect on modi?cations to the color buffers.
If the color mask is entirely disabled, the color sample values must still be com-
bined (as described above) and the result used to replace the color values of the
buffersenabledbyDrawBuffer.
4.2.3 ClearingtheBuffers
The GL provides a means for setting portions of every pixel in a particular buffer
tothesamevalue. Theargumentto
void Clear(bitfield buf);
Version2.1-December1,20064.2. WHOLEFRAMEBUFFEROPERATIONS 219
is the bitwise OR of a number of values indicating which buffers are
to be cleared. The values are COLOR BUFFER BIT, DEPTH BUFFER BIT,
STENCIL BUFFER BIT,andACCUM BUFFER BIT,indicatingthebufferscurrently
enabledforcolorwriting,thedepthbuffer,thestencilbuffer,andtheaccumulation
buffer(seebelow),respectively. Thevaluetowhicheachbufferiscleareddepends
on the setting of the clear value for that buffer. If the mask is not a bitwise OR of
thespeci?edvalues,thentheerrorINVALID VALUEisgenerated.
void ClearColor(clampf r,clampf g,clampf b,
clampf a);
sets the clear value for the color buffers in RGBA mode. Each of the speci?ed
componentsisclampedto[0,1]andconvertedto?xed-pointaccordingtotherules
ofsection2.14.9.
void ClearIndex(float index);
setstheclearcolorindex. indexisconvertedtoa?xed-pointvaluewithunspeci?ed
precisiontotheleftofthebinarypoint;theintegerpartofthisvalueisthenmasked
m
with 2 ? 1, where m is the number of bits in a color index value stored in the
framebuffer.
void ClearDepth(clampd d);
takes a ?oating-point value that is clamped to the range [0,1] and converted to
?xed-point according to the rules for a window z value given in section 2.11.1.
Similarly,
void ClearStencil(int s);
takesasingleintegerargumentthatisthevaluetowhichtoclearthestencilbuffer.
sismaskedtothenumberofbitplanesinthestencilbuffer.
void ClearAccum(float r,float g,float b,float a);
takesfour?oating-pointargumentsthatarethevalues,inorder,towhichtosetthe
R, G, B, and A values of the accumulation buffer (see the next section). These
valuesareclampedtotherange[?1,1]whentheyarespeci?ed.
When Clear is called, the only per-fragment operations that are applied (if
enabled) are the pixel ownership test, the scissor test, and dithering. The masking
operations described in the last section (4.2.2) are also effective. If a buffer is not
present,thenaCleardirectedatthatbufferhasnoeffect.
Version2.1-December1,2006220 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
The state required for clearing is a clear value for each of the color buffer, the
depth buffer, the stencil buffer, and the accumulation buffer. Initially, the RGBA
color clear value is (0,0,0,0), the clear color index is 0, and the stencil buffer and
accumulation buffer clear values are all 0. The depth buffer clear value is initially
1.0.
ClearingtheMultisampleBuffer
The color samples of the multisample buffer are cleared when one or more color
buffers are cleared, as speci?ed by the Clear mask bit COLOR BUFFER BIT and
theDrawBuffermode. IftheDrawBuffermodeisNONE,thecolorsamplesofthe
multisamplebuffercannotbecleared.
IftheClearmaskbitsDEPTH BUFFER BITorSTENCIL BUFFER BITareset,
thenthecorrespondingdepthorstencilsamples,respectively,arecleared.
4.2.4 TheAccumulationBuffer
Each portion of a pixel in the accumulation buffer consists of four values: one for
eachofR,G,B,andA.Theaccumulationbufferiscontrolledexclusivelythrough
theuseof
void Accum(enum op,float value);
(exceptforclearingit). opisasymbolicconstantindicatinganaccumulationbuffer
operation, and value is a ?oating-point value to be used in that operation. The
possibleoperationsareACCUM,LOAD,RETURN,MULT,andADD.
When the scissor test is enabled (section 4.1.2), then only those pixels within
the current scissor box are updated by anyAccum operation; otherwise, all pixels
in the window are updated. The accumulation buffer operations apply identically
to every affected pixel, so we describe the effect of each operation on an individ-
ual pixel. Accumulation buffer values are taken to be signed values in the range
[?1,1]. UsingACCUMobtainsR,G,B,andAcomponentsfromthebuffercurrently
selected for reading (section 4.3.2). Each component, considered as a ?xed-point
value in [0,1]. (see section 2.14.9), is converted to ?oating-point. Each result is
then multiplied by value. The results of this multiplication are then added to the
corresponding color component currently in the accumulation buffer, and the re-
sultingcolorvaluereplacesthecurrentaccumulationbuffercolorvalue.
The LOAD operation has the same effect as ACCUM, but the computed values
replacethecorrespondingaccumulationbuffercomponentsratherthanbeingadded
tothem.
Version2.1-December1,20064.3. DRAWING,READING,ANDCOPYINGPIXELS 221
The RETURN operation takes each color value from the accumulation buffer,
multiplies each of the R, G, B, and A components by value, and clamps the re-
sults to the range [0,1] The resulting color value is placed in the buffers currently
enabled for color writing as if it were a fragment produced from rasterization, ex-
ceptthattheonlyper-fragmentoperationsthatareapplied(ifenabled)arethepixel
ownershiptest,thescissortest(section4.1.2),anddithering(section4.1.9). Color
masking(section4.2.2)isalsoapplied.
TheMULToperationmultiplieseachR,G,B,andAintheaccumulationbuffer
by value and then returns the scaled color components to their corresponding ac-
cumulationbufferlocations. ADDisthesameasMULTexceptthatvalueisaddedto
eachofthecolorcomponents.
The color components operated on by Accum must be clamped only if the
operation is RETURN. In this case, a value sent to the enabled color buffers is ?rst
clamped to [0,1]. Otherwise, results are unde?ned if the result of an operation on
acolorcomponentisoutoftherange[?1,1].
Ifthereisnoaccumulationbuffer,oriftheGLisincolorindexmode,Accum
generatestheerrorINVALID OPERATION.
No state (beyond the accumulation buffer itself) is required for accumulation
buffering.
4.3 Drawing,Reading,andCopyingPixels
PixelsmaybewrittentoandreadfromtheframebufferusingtheDrawPixelsand
ReadPixels commands. CopyPixels can be used to copy a block of pixels from
oneportionoftheframebuffertoanother.
4.3.1 WritingtotheStencilBuffer
The operation of DrawPixels was described in section 3.6.4, except if the format
argument was STENCIL INDEX. In this case, all operations described for Draw-
Pixels take place, but window (x,y) coordinates, each with the corresponding
stencilindex,areproducedinlieuoffragments. Eachcoordinate-stencilindexpair
is sent directly to the per-fragment operations, bypassing the texture, fog, and an-
tialiasingapplicationstagesofrasterization. Eachpairisthentreatedasafragment
forpurposesofthepixelownershipandscissortests;allotherper-fragmentopera-
tionsarebypassed. Finally,eachstencilindexiswrittentoitsindicatedlocationin
theframebuffer,subjecttothecurrentfrontstencilmask(setwithStencilMaskor
StencilMaskSeparate). Ifadepthcomponentispresent,andthesettingofDepth-
Mask is notFALSE, is also written to the framebuffer; the setting ofDepthTest is
Version2.1-December1,2006222 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
ignored.
TheerrorINVALID OPERATIONresultsifthereisnostencilbuffer.
4.3.2 ReadingPixels
The method for reading pixels from the framebuffer and placing them in pixel
packbufferorclientmemory isdiagrammedin?gure4.2. Wedescribethestages
ofthepixelreadingprocessintheorderinwhichtheyoccur.
Initially, zero is bound for the PIXEL PACK BUFFER, indicating that image
read and query commands such as ReadPixels return pixels results into client
memory pointer parameters. However, if a non-zero buffer object is bound as the
currentpixelpackbuffer,thenthepointerparameteristreatedasanoffsetintothe
designatedbufferobject.
Pixelsarereadusing
void ReadPixels(int x,int y,sizei width,sizei height,
enum format,enum type,void *data);
The arguments after x and y to ReadPixels correspond to those of DrawPixels.
ThepixelstoragemodesthatapplytoReadPixelsandothercommandsthatquery
images(seesection6.1)aresummarizedintable4.5.
ObtainingPixelsfromtheFramebuffer
IftheformatisDEPTH COMPONENT,thenvaluesareobtainedfromthedepthbuffer.
Ifthereisnodepthbuffer,theerrorINVALID OPERATIONoccurs.
If there is a multisample buffer (the value of SAMPLE BUFFERS is one), then
values are obtained from the depth samples in this buffer. It is recommended that
the depth value of the centermost sample be used, though implementations may
chooseanyfunctionofthedepthsamplevaluesateachpixel.
IftheformatisSTENCIL INDEX,thenvaluesaretakenfromthestencilbuffer;
again,ifthereisnostencilbuffer,theerrorINVALID OPERATIONoccurs.
Ifthereisamultisamplebuffer,thenvaluesareobtainedfromthestencilsam-
plesinthisbuffer. Itisrecommendedthatthestencilvalueofthecentermostsam-
plebeused,thoughimplementationsmaychooseanyfunctionofthestencilsample
valuesateachpixel.
For all other formats, the buffer from which values are obtained is one of the
colorbuffers;theselectionofcolorbufferiscontrolledwithReadBuffer.
Thecommand
void ReadBuffer(enum src);
Version2.1-December1,20064.3. DRAWING,READING,ANDCOPYINGPIXELS 223
RGBA pixel color index pixel
data in data in
convert
to float
                                                             
                                                             
                                                             
Pixel Transfer
                                                             
scale shift
                          Operations                                   
and bias and offset
                                                             
                                                             
                                                             
RGBA to RGBA index to RGBA index to index 
                                                             
lookup lookup lookup
                                                             
                                                             
                                                             
                                                             
color table 
                                                             
lookup
                                                             
                                                             
                                                             
post
convolution color table 
                                                             
color matrix
scale and bias lookup
                                                             
                                                             
                                                             
                                                             
post color table histogram
                                                             
convolution lookup
                                                             
                                                             
                                                             
color matrix minmax
                                                             
scale and bias
                                                             
                                                             
                                                             
                                                             
                                                             
convert
Pixel Storage
        RGB to L                                                     
Operations
                                                             
                                                             
                                                             
mask to
clamp
                                                             
n
to [0,1] (2 ? 1)
                                                             
                                                             
                                                             
                                                             
pack
                                                             
                                                             
byte, short, int, or float pixel
data stream (index or component)
Figure 4.2. Operation of ReadPixels. Operations in dashed boxes may be enabled
or disabled, except in the case of ”convert RGB to L”, which is only applied when
reading color data in luminosity formats. RGBA and color index pixel paths are
shown;depthandstencilpixelpathsarenotshown.
Version2.1-December1,2006224 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
ParameterName Type InitialValue ValidRange
PACK SWAP BYTES boolean FALSE TRUE/FALSE
PACK LSB FIRST boolean FALSE TRUE/FALSE
PACK ROW LENGTH integer 0 [0,?)
PACK SKIP ROWS integer 0 [0,?)
PACK SKIP PIXELS integer 0 [0,?)
PACK ALIGNMENT integer 4 1,2,4,8
PACK IMAGE HEIGHT integer 0 [0,?)
PACK SKIP IMAGES integer 0 [0,?)
Table4.5: PixelStoreparameterspertainingtoReadPixels,GetColorTable,Get-
ConvolutionFilter,GetSeparableFilter,GetHistogram,GetMinmax,GetPoly-
gonStipple,andGetTexImage.
takes a symbolic constant as argument. The possible values are FRONT LEFT,
FRONT RIGHT,BACK LEFT,BACK RIGHT,FRONT,BACK,LEFT,RIGHT,andAUX0
through AUXn. FRONT and LEFT refer to the front left buffer, BACK refers to the
backleftbuffer,andRIGHTreferstothefrontrightbuffer. Theotherconstantscor-
respond directly to the buffers that they name. If the requested buffer is missing,
then the error INVALID OPERATION is generated. The initial setting for Read-
BufferisFRONTifthereisnobackbufferandBACKotherwise.
ReadPixelsobtainsvaluesfromtheselectedbufferfromeachpixelwithlower
lefthandcornerat(x+i,y+j)for0?i<widthand0?j <height;thispixel
is said to be the ith pixel in the jth row. If any of these pixels lies outside of the
window allocated to the current GL context, the values obtained for those pixels
are unde?ned. Results are also unde?ned for individual pixels that are not owned
by the current context. Otherwise, ReadPixels obtains values from the selected
buffer,regardlessofhowthosevalueswereplacedthere.
If the GL is in RGBA mode, and format is one ofRED,GREEN,BLUE,ALPHA,
RGB,RGBA,BGR,BGRA,LUMINANCE,orLUMINANCE ALPHA,thenred,green,blue,
and alpha values are obtained from the selected buffer at each pixel location.
If the framebuffer does not support alpha values then the A that is obtained is
1.0. If format is COLOR INDEX and the GL is in RGBA mode then the error
INVALID OPERATION occurs. If the GL is in color index mode, and format is
not DEPTH COMPONENT or STENCIL INDEX, then the color index is obtained at
eachpixellocation.
Version2.1-December1,20064.3. DRAWING,READING,ANDCOPYINGPIXELS 225
ConversionofRGBAvalues
This step applies only if the GL is in RGBA mode, and then only if format is
neitherSTENCIL INDEXnorDEPTH COMPONENT.TheR,G,B,andAvaluesform
a group of elements. Each element is taken to be a ?xed-point value in [0,1] with
mbits,wheremisthenumberofbitsinthecorrespondingcolorcomponentofthe
selectedbuffer(seesection2.14.9).
ConversionofDepthvalues
ThisstepappliesonlyifformatisDEPTH COMPONENT.Anelementistakentobea
?xed-point value in [0,1] with m bits, wherem is the number of bits in the depth
buffer(seesection2.11.1).
PixelTransferOperations
This step is actually the sequence of steps that was described separately in sec-
tion 3.6.5. After the processing described in that section is completed, groups are
processedasdescribedinthefollowingsections.
ConversiontoL
ThisstepappliesonlytoRGBAcomponentgroups,andonlyiftheformatiseither
LUMINANCEorLUMINANCE ALPHA.AvalueLiscomputedas
L =R+G+B
where R, G, and B are the values of the R, G, and B components. The single
computedLcomponentreplacestheR,G,andBcomponentsinthegroup.
FinalConversion
For an index, if the type is not FLOAT, ?nal conversion consists of masking the
indexwiththevaluegivenintable4.6;ifthe typeisFLOAT,thentheintegerindex
isconvertedtoaGL?oatdatavalue.
For an RGBA color, each component is ?rst clamped to [0,1]. Then the
appropriateconversionformulafromtable4.7isappliedtothecomponent.
PlacementinPixelPackBufferorClientMemory
If a pixel pack buffer is bound (as indicated by a non-zero value of
PIXEL PACK BUFFER BINDING), data is an offset into the pixel pack buffer and
Version2.1-December1,2006226 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
typeParameter IndexMask
8
UNSIGNED BYTE 2 ?1
BITMAP 1
7
BYTE 2 ?1
16
UNSIGNED SHORT 2 ?1
15
SHORT 2 ?1
32
UNSIGNED INT 2 ?1
31
INT 2 ?1
Table4.6: IndexmasksusedbyReadPixels. Floatingpointdataarenotmasked.
the pixels are packed into the buffer relative to this offset; otherwise, data is a
pointertoablockclientmemoryandthepixelsarepackedintotheclientmemory
relative to the pointer. If a pixel pack buffer object is bound and packing the pixel
dataaccordingtothepixelpackstoragestatewouldaccessmemorybeyondthesize
of the pixel pack buffer’s memory size, an INVALID OPERATION error results. If
a pixel pack buffer object is bound and data is not evenly divisible by the number
ofbasicmachineunitsneededtostoreinmemorythecorrespondingGLdatatype
fromtable3.5forthe typeparameter,anINVALID OPERATIONerrorresults.
Groups of elements are placed in memory just as they are taken from mem-
ory for DrawPixels. That is, the ith group of the jth row (corresponding to the
ith pixel in the jth row) is placed in memory just where the ith group of the jth
row would be taken from for DrawPixels. See Unpacking under section 3.6.4.
The only difference is that the storage mode parameters whose names begin with
PACK are used instead of those whose names begin with UNPACK . If the format
is RED, GREEN, BLUE, ALPHA, or LUMINANCE, only the corresponding single ele-
ment is written. Likewise if the format is LUMINANCE ALPHA, RGB, or BGR, only
thecorrespondingtwoorthreeelementsarewritten. Otherwisealltheelementsof
eachgrouparewritten.
4.3.3 CopyingPixels
CopyPixelstransfersarectangleofpixelvaluesfromoneregionoftheframebuffer
toanother. Pixelcopyingisdiagrammedin?gure4.3.
void CopyPixels(int x,int y,sizei width,sizei height,
enum type);
typeisasymbolicconstantthatmustbeoneofCOLOR,STENCIL,orDEPTH,indi-
cating that the values to be transferred are colors, stencil values, or depth values,
Version2.1-December1,20064.3. DRAWING,READING,ANDCOPYINGPIXELS 227
typeParameter GLDataType Component
ConversionFormula
8
UNSIGNED BYTE ubyte c = (2 ?1)f
8
BYTE byte c = [(2 ?1)f?1]/2
16
UNSIGNED SHORT ushort c = (2 ?1)f
16
SHORT short c = [(2 ?1)f?1]/2
32
UNSIGNED INT uint c = (2 ?1)f
32
INT int c = [(2 ?1)f?1]/2
FLOAT float c =f
N
UNSIGNED BYTE 3 3 2 ubyte c = (2 ?1)f
N
UNSIGNED BYTE 2 3 3 REV ubyte c = (2 ?1)f
N
UNSIGNED SHORT 5 6 5 ushort c = (2 ?1)f
N
UNSIGNED SHORT 5 6 5 REV ushort c = (2 ?1)f
N
UNSIGNED SHORT 4 4 4 4 ushort c = (2 ?1)f
N
UNSIGNED SHORT 4 4 4 4 REV ushort c = (2 ?1)f
N
UNSIGNED SHORT 5 5 5 1 ushort c = (2 ?1)f
N
UNSIGNED SHORT 1 5 5 5 REV ushort c = (2 ?1)f
N
UNSIGNED INT 8 8 8 8 uint c = (2 ?1)f
N
UNSIGNED INT 8 8 8 8 REV uint c = (2 ?1)f
N
UNSIGNED INT 10 10 10 2 uint c = (2 ?1)f
N
UNSIGNED INT 2 10 10 10 REV uint c = (2 ?1)f
Table4.7: Reversedcomponentconversions,usedwhencomponentdataarebeing
returned to client memory. Color, normal, and depth components are converted
from the internal ?oating-point representation ( f) to a datum of the speci?ed GL
data type (c) using the speci?ed equation. All arithmetic is done in the internal
?oating point format. These conversions apply tocomponent data returned by GL
query commands and to components of pixel data returned to client memory. The
equationsremainthesameeveniftheimplementedrangesoftheGLdatatypesare
greater than the minimum required ranges. (See table 2.2.) Equations with N as
theexponentareperformedforeachbit?eldofthepackeddatatype,withN setto
thenumberofbitsinthebit?eld.
Version2.1-December1,2006228 CHAPTER4. PER-FRAGMENTOPERATIONSANDTHE...
RGBA pixel color index pixel
data from framebuffer data from framebuffer
convert
to float
                                                             
                                                             
                        Pixel Transfer                                     
scale shift
                                                             
Operations
and bias and offset
                                                             
                                                             
                                                             
RGBA to RGBA index to RGBA index to index 
                                                             
lookup lookup lookup
                                                             
                                                             
                                                             
                                                             
color table 
                                                             
lookup
                                                             
                                                             
                                                             
post
convolution color table 
                                                             
color matrix
scale and bias lookup
                                                             
                                                             
                                                             
                                                             
post
color table histogram
                                                             
convolution
lookup
                                                             
                                                             
                                                             
color matrix minmax
                                                             
scale and bias
                                                             
                                                             
mask to
final
clamp
n
conversion
to [0,1] (2 ? 1)
RGBA pixel color index pixel
data out data out
Figure 4.3. Operation of CopyPixels. Operations in dashed boxes may be enabled
ordisabled. Index-to-RGBAlookupiscurrentlyneverperformed. RGBAandcolor
indexpixelpathsareshown;depthandstencilpixelpathsarenotshown.
Version2.1-December1,20064.3. DRAWING,READING,ANDCOPYINGPIXELS 229
respectively. The ?rst four arguments have the same interpretation as the corre-
spondingargumentstoReadPixels.
Valuesareobtainedfromtheframebuffer,converted(ifappropriate),thensub-
jected to the pixel transfer operations described in section 3.6.5, just as if Read-
Pixels were called with the corresponding arguments. If the type is STENCIL
or DEPTH, then it is as if the format for ReadPixels were STENCIL INDEX or
DEPTH COMPONENT,respectively. Ifthe typeisCOLOR,theniftheGLisinRGBA
mode,itisasifthe formatwereRGBA,whileiftheGLisincolorindexmode,itis
asifthe formatwereCOLOR INDEX.
The groups of elements so obtained are then written to the framebuffer just as
ifDrawPixels had been givenwidth andheight, beginning with ?nal conversion
ofelements. Theeffective formatisthesameasthatalreadydescribed.
4.3.4 PixelDraw/ReadState
The state required for pixel operations consists of the parameters that are set with
PixelStore, PixelTransfer, and PixelMap. This state has been summarized in
tables 3.1, 3.2, and 3.3. The current setting of ReadBuffer, an integer, is also
required,alongwiththecurrentrasterposition(section2.13). StatesetwithPixel-
StoreisGLclientstate.
Version2.1-December1,2006Chapter 5
SpecialFunctions
This chapter describes additional GL functionality that does not ?t easily into any
oftheprecedingchapters. Thisfunctionalityconsistsofevaluators(usedtomodel
curves and surfaces), selection (used to locate rendered primitives on the screen),
feedback(whichreturnsGLresultsbeforerasterization),displaylists(usedtodes-
ignate a group of GL commands for later execution by the GL), ?ushing and ?n-
ishing(usedtosynchronizetheGLcommandstream),andhints.
5.1 Evaluators
Evaluators provide a means to use a polynomial or rational polynomial mapping
to producevertex, normal, and texture coordinates, and colors. Thevalues so pro-
duced are sent on to further stages of the GL as if they had been provided directly
bytheclient. Transformations,lighting,primitiveassembly,rasterization,andper-
pixeloperationsarenotaffectedbytheuseofevaluators.
k
ConsidertheR -valuedpolynomial p(u)de?nedby
n
X
n
p(u) = B (u)R (5.1)
i
i
i=0
k
withR ?R and
i
 !
n
n i n?i
B (u) = u (1?u) ,
i
i
  
n
0
the ith Bernstein polynomial of degree n (recall that 0 ? 1 and ? 1). Each
0
R isa control point. Therelevantcommandis
i
void Map1{fd}(enum target,Tu ,Tu ,int stride,
1 2
int order,T points);
2305.1. EVALUATORS 231
target k Values
MAP1 VERTEX 3 3 x,y,z vertexcoordinates
MAP1 VERTEX 4 4 x,y,z,w vertexcoordinates
MAP1 INDEX 1 colorindex
MAP1 COLOR 4 4 R,G,B,A
MAP1 NORMAL 3 x,y,z normalcoordinates
MAP1 TEXTURE COORD 1 1 stexturecoordinate
MAP1 TEXTURE COORD 2 2 s,ttexturecoordinates
MAP1 TEXTURE COORD 3 3 s,t,r texturecoordinates
MAP1 TEXTURE COORD 4 4 s,t,r,q texturecoordinates
Table5.1: Valuesspeci?edbythe targettoMap1. Valuesaregivenintheorderin
whichtheyaretaken.
target is a symbolic constant indicating the range of the de?ned polynomial. Its
possible values, along with the evaluations that each indicates, are given in ta-
ble 5.1. order is equal ton+1; The errorINVALID VALUE is generated iforder
is less than one or greater than MAX EVAL ORDER. points is a pointer to a set of
n+1 blocks of storage. Each block begins withk single-precision ?oating-point
or double-precision ?oating-point values, respectively. The rest of the block may
be?lledwitharbitrarydata. Table5.1indicateshowk dependsontargetandwhat
thek valuesrepresentineachcase.
stride is the number of single- or double-precision values (as appropriate) in
each block of storage. The error INVALID VALUE results if stride is less than
k. The order of the polynomial, order, is also the number of blocks of storage
containingcontrolpoints.
u and u give two ?oating-point values that de?ne the endpoints of the pre-
1 2
0
image of the map. When a value u is presented for evaluation, the formula used
is
0
u?u
1
0 0
p(u) =p( ).
u ?u
2 1
TheerrorINVALID VALUEresultsifu =u .
1 2
Map2 is analogous to Map1, except that it describes bivariate polynomials of
theform
n m
XX
n m
p(u,v) = B (u)B (v)R .
ij
i j
i=0j=0
TheformoftheMap2commandis
Version2.1-December1,2006232 CHAPTER5. SPECIALFUNCTIONS
Integers Reals
Vertices
[u ,u ]
k Normals
1 2 [0,1]
EvalMesh
B R
Ax+b ?
i i
Texture Coordinates
[0,1]
EvalPoint l
[v ,v ]
1 2
Colors
MapGrid Map
EvalCoord
Figure5.1. MapEvaluation.
void Map2{fd}(enum target,Tu ,Tu ,int ustride,
1 2
intuorder,Tv ,Tv ,intvstride,intvorder,Tpoints);
1 2
target is a range type selected from the same group as is used for Map1, ex-
cept that the string MAP1 is replaced with MAP2. points is a pointer to (n +
1)(m + 1) blocks of storage (uorder = n + 1 and vorder = m + 1; the er-
ror INVALID VALUE is generated if either uorder or vorder is less than one or
greaterthanMAX EVAL ORDER).ThevaluescomprisingR arelocated
ij
(ustride)i+(vstride)j
values (either single- or double-precision ?oating-point, as appropriate) past the
?rst value pointed to by points. u , u , v , and v de?ne the pre-image rectangle
1 2 1 2
0 0
ofthemap;adomainpoint(u,v )isevaluatedas
0 0
u?u v ?v
1 1
0 0 0
p(u,v ) =p( , ).
u ?u v ?v
2 1 2 1
The evaluation of a de?ned map is enabled or disabled with Enable and
Disable using the constant corresponding to the map as described above. The
evaluator map generates only coordinates for texture unit TEXTURE0. The error
INVALID VALUEresultsifeitherustrideorvstrideislessthank,orifu isequal
1
tou2, or ifv is equal tov . If the value of ACTIVE TEXTURE is not TEXTURE0,
1 2
callingMap{12}generatestheerrorINVALID OPERATION.
Figure 5.1 describes map evaluation schematically; an evaluation of enabled
mapsiseffectedinoneoftwoways. The?rstwayistouse
void EvalCoord{12}{fd}(T arg);
void EvalCoord{12}{fd}v(T arg);
Version2.1-December1,20065.1. EVALUATORS 233
EvalCoord1 causes evaluation of the enabled one-dimensional maps. The argu-
0
mentisthevalue(orapointertothevalue)thatisthedomaincoordinate,u. Eval-
Coord2 causes evaluation of the enabled two-dimensional maps. The two values
0 0
specifythetwodomaincoordinates,u andv ,inthatorder.
When one of the EvalCoord commands is issued, all currently enabled maps
of the indicated dimension are evaluated. Then, for each enabled map, it is as if a
corresponding GL command were issued with the resulting coordinates, with one
important difference. The difference is that when an evaluation is performed, the
GL uses evaluated values instead of current values for those evaluations that are
enabled (otherwise, the current values are used). The order of the effective com-
mandsisimmaterial,exceptthatVertex(forvertexcoordinateevaluation)mustbe
issuedlast. Useofevaluatorshasnoeffectonthecurrentcolor,normal, ortexture
coordinates. If ColorMaterial is enabled, evaluated color values affect the result
of the lighting equation as if the current color was being modi?ed, but no change
ismadetothetrackinglightingparametersortothecurrentcolor.
No command is effectively issued if the corresponding map (of the indicated
dimension) is not enabled. If more than one evaluation is enabled for a particu-
lardimension(e.g. MAP1 TEXTURE COORD 1andMAP1 TEXTURE COORD 2),then
onlytheresultoftheevaluationofthemapwiththehighestnumberofcoordinates
isused.
Finally, ifeitherMAP2 VERTEX 3orMAP2 VERTEX 4isenabled, thenthenor-
mal to the surface is computed. Analytic computation, which sometimes yields
normals of length zero, is one method which may be used. If automatic normal
generation is enabled, then this computed normal is used as the normal associated
with a generated vertex. Automatic normal generation is controlled with Enable
andDisablewiththesymbolicconstantAUTO NORMAL.Ifautomaticnormalgener-
ation is disabled, then a corresponding normal map, if enabled, is used to produce
a normal. If neither automatic normal generation nor a normal map are enabled,
thennonormalissentwithavertexresultingfromanevaluation(theeffectisthat
thecurrentnormalisused).
ForMAP VERTEX 3,letq =p. ForMAP VERTEX 4,letq = (x/w,y/w,z/w),
where(x,y,z,w) =p. Thenlet
?q ?q
m = ? .
?u ?v
Then the generated analytic normal, n, is given byn = m if a vertex shader is
m
active,orelsebyn = .
kmk
The second way to carry out evaluations is to use a set of commands that pro-
vide for ef?cient speci?cation of a series of evenly spaced values to be mapped.
Thismethodproceedsintwosteps. The?rststepistode?neagridinthedomain.
Version2.1-December1,2006234 CHAPTER5. SPECIALFUNCTIONS
Thisisdoneusing
0 0
void MapGrid1{fd}(intn,Tu ,Tu );
1 2
foraone-dimensionalmapor
0 0 0
void MapGrid2{fd}(intn ,Tu ,Tu ,intn ,Tv ,
u v
1 2 1
0
Tv );
2
0 0
for a two-dimensional map. In the case of MapGrid1 u and u describe an
1 2
interval, while n describes the number of partitions of the interval. The error
0 0
INVALID VALUE results if n? 0. For MapGrid2, (u ,v ) speci?es one two-
1 1
0 0
dimensionalpointand(u ,v )speci?esanother. n givesthenumberofpartitions
u
2 2
0 0 0 0
between u and u , and n gives the number of partitions between v and v . If
v
1 2 1 2
eithern ? 0orn ? 0,thentheerrorINVALID VALUEoccurs.
u v
Once a grid is de?ned, an evaluation on a rectangular subset of that grid may
becarriedoutbycalling
void EvalMesh1(enum mode,intp ,intp );
1 2
modeiseitherPOINTorLINE.Theeffectisthesameasperformingthefollowing
0 0 0
codefragment,with?u = (u ?u )/n:
2 1
Begin(type);
fori =p top step1.0
1 2
0 0
EvalCoord1(i ?u + u );
*
1
End();
where EvalCoord1f or EvalCoord1d is substituted for EvalCoord1 as appro-
priate. If mode is POINT, then type is POINTS; if mode is LINE, then type is
LINE STRIP. The one requirement is that if eitheri = 0 ori = n, then the value
0 0 0 0
computedfromi??u +u ispreciselyu oru ,respectively.
1 1 2
Thecorrespondingcommandsfortwo-dimensionalmapsare
void EvalMesh2(enum mode,intp ,intp ,intq ,
1 2 1
intq );
2
modemustbeFILL,LINE,orPOINT.When modeisFILL,thenthesecommands
0 0 0 0 0 0
areequivalenttothefollowing,with?u = (u ?u )/nand?v = (v ?v )/m:
2 1 2 1
Version2.1-December1,20065.1. EVALUATORS 235
fori =q toq ?1step1.0
1 2
Begin(QUAD STRIP);
forj =p top step1.0
1 2
0 0 0 0
EvalCoord2(j ?u + u , i ?v + v );
* *
1 1
0 0 0 0
EvalCoord2(j ?u + u , (i+1) ?v + v );
* *
1 1
End();
If modeisLINE,thenacalltoEvalMesh2isequivalentto
fori =q toq step1.0
1 2
Begin(LINE STRIP);
forj =p top step1.0
1 2
0 0 0 0
EvalCoord2(j ?u + u , i ?v + v );
* *
1 1
End();;
fori =p top step1.0
1 2
Begin(LINE STRIP);
forj =q toq step1.0
1 2
0 0 0 0
EvalCoord2(i ?u + u , j ?v + v );
* *
1 1
End();
If modeisPOINT,thenacalltoEvalMesh2isequivalentto
Begin(POINTS);
fori =q toq step1.0
1 2
forj =p top step1.0
1 2
0 0 0 0
EvalCoord2(j ?u + u , i ?v + v );
* *
1 1
End();
0 0 0 0
Again,inallthreecases,thereistherequirementthat0??u +u =u ,n??u +
1 1
0 0 0 0 0 0 0 0
u =u ,0??v +v =v ,andm??v +v =v .
1 2 1 1 1 2
Anevaluationofasinglepointonthegridmayalsobecarriedout:
void EvalPoint1(intp);
Callingitisequivalenttothecommand
0 0
EvalCoord1(p*?u +u );
1
0 0
with?u andu de?nedasabove.
1
void EvalPoint2(intp,intq );
isequivalenttothecommand
Version2.1-December1,2006236 CHAPTER5. SPECIALFUNCTIONS
0 0 0 0
EvalCoord2(p ?u + u , q ?v + v );
* *
1 1
Thestaterequiredforevaluatorspotentiallyconsistsof9one-dimensionalmap
speci?cationsand9two-dimensionalmapspeci?cations,aswellascorresponding
?ags for each speci?cation indicating which are enabled. Each map speci?cation
consists of one or two orders, an appropriately sized array of control points, and a
setoftwovalues(foraone-dimensionalmap)orfourvalues(foratwo-dimensional
map) to describe the domain. The maximum possible order, for either u or v, is
implementationdependent(onemaximumappliestobothuandv),butmustbeat
least 8. Each control point consists of between one and four ?oating-point values
(depending on the type of the map). Initially, all maps have order 1 (making them
constant maps). All vertex coordinate maps produce the coordinates (0,0,0,1)
(or the appropriate subset); all normal coordinate maps produce (0,0,1); RGBA
maps produce (1,1,1,1); color index maps produce 1.0; and texture coordinate
maps produce (0,0,0,1). In the initial state, all maps are disabled. A ?ag indi-
cates whether or not automatic normal generation is enabled for two-dimensional
maps. In the initial state, automatic normal generation is disabled. Also required
are two ?oating-point values and an integer number of grid divisions for the one-
dimensional grid speci?cation and four ?oating-point values and two integer grid
divisionsforthetwo-dimensionalgridspeci?cation. Intheinitialstate,thebounds
of the domain interval for 1-D is 0 and 1.0, respectively; for 2-D, they are (0,0)
and (1.0,1.0), respectively. The number of grid divisions is 1 for 1-D and 1 in
both directions for 2-D. If any evaluation command is issued when no vertex map
isenabledforthemapdimensionbeingevaluated,nothinghappens.
5.2 Selection
Selection is used to determine which primitives are drawn into some region of a
window. Theregionisde?nedbythecurrentmodel-viewandperspectivematrices.
Selection works by returning an array of integer-valued names. This array
representsthecurrentcontentsofthe name stack. Thisstackiscontrolledwiththe
commands
void InitNames(void);
void PopName(void);
void PushName(uint name);
void LoadName(uint name);
InitNames empties (clears) the name stack. PopName pops one name off the top
of the name stack. PushName causes name to be pushed onto the name stack.
Version2.1-December1,20065.2. SELECTION 237
LoadName replaces the value on the top of the stack with name. Loading a name
ontoanemptystackgeneratestheerrorINVALID OPERATION.Poppinganameoff
ofanemptystackgeneratesSTACK UNDERFLOW;pushinganameontoafullstack
generates STACK OVERFLOW. The maximum allowable depth of the name stack is
implementationdependentbutmustbeatleast64.
In selection mode, framebuffer updates as described in chapter 4 are not per-
formed. TheGLisplacedinselectionmodewith
int RenderMode(enum mode);
mode is a symbolic constant: one of RENDER, SELECT, or FEEDBACK. RENDER is
the default, corresponding to rendering as described until now. SELECT speci?es
selection mode, and FEEDBACK speci?es feedback mode (described below). Use
of any of the name stack manipulation commands while the GL is not in selection
modehasnoeffect.
Selectioniscontrolledusing
void SelectBuffer(sizei n,uint *buffer);
bufferisapointertoanarrayofunsignedintegers(calledtheselectionarray)tobe
potentially ?lled with names, and n is an integer indicating the maximum number
of values that can be stored in that array. Placing the GL in selection mode before
SelectBuffer has been called results in an error of INVALID OPERATION as does
callingSelectBufferwhileinselectionmode.
In selection mode, if a point, line, polygon, or the valid coordinates produced
byaRasterPoscommandintersectstheclipvolume(section2.12)thenthisprim-
itive (or RasterPos command) causes a selection hit. WindowPos commands al-
ways generate a selection hit, since the resulting raster position is always valid.
In the case of polygons, no hit occurs if the polygon would have been culled, but
selectionisbasedonthepolygonitself,regardlessofthesettingofPolygonMode.
When in selection mode, whenever a name stack manipulation command is exe-
cutedorRenderModeiscalledandtherehasbeenahitsincethelasttimethestack
was manipulated or RenderMode was called, then a hit record is written into the
selectionarray.
A hit record consists of the following items in order: a non-negative integer
givingthenumberofelementsonthenamestackatthetimeofthehit,aminimum
depth value, a maximum depth value, and the name stack with the bottommost el-
ement?rst. Theminimumandmaximumdepthvaluesaretheminimumandmax-
imumtakenoverallthewindowcoordinatez valuesofeach(post-clipping)vertex
of each primitive that intersects the clipping volume since the last hit record was
Version2.1-December1,2006238 CHAPTER5. SPECIALFUNCTIONS
written. The minimum and maximum (each of which lies in the range [0,1]) are
32
eachmultipliedby2 ?1androundedtothenearestunsignedintegertoobtainthe
values that are placed in the hit record. No depth offset arithmetic (section 3.5.5)
isperformedonthesevalues.
Hit records are placed in the selection array by maintaining a pointer into that
array. When selection mode is entered, the pointer is initialized to the beginning
of the array. Each time a hit record is copied, the pointer is updated to point at
the array element after the one into which the topmost element of the name stack
was stored. If copying the hit record into the selection array would cause the total
number of values to exceed n, then as much of the record as ?ts in the array is
writtenandanover?ow?agisset.
SelectionmodeisexitedbycallingRenderModewithanargumentvalueother
than SELECT. When called while in selection mode, RenderMode returns the
number of hit records copied into the selection array and resets the SelectBuffer
pointer to its last speci?ed value. Values are not guaranteed to be written into the
selection array until RenderMode is called. If the selection array over?ow ?ag
was set, then RenderMode returns?1 and clears the over?ow ?ag. The name
stackisclearedandthestackpointerresetwheneverRenderModeiscalled.
The state required for selection consists of the address of the selection array
and its maximum size, the name stack and its associated pointer, a minimum and
maximum depth value, and several ?ags. One ?ag indicates the current Render-
Mode value. In the initial state, the GL is in the RENDER mode. Another ?ag is
used to indicate whether or not a hit has occurred since the last name stack ma-
nipulation. This ?ag is reset upon entering selection mode and whenever a name
stack manipulation takes place. One ?nal ?ag is required to indicate whether the
maximum number of copied names would have been exceeded. This ?ag is reset
upon entering selection mode. This ?ag, the address of the selection array, and its
maximumsizeareGLclientstate.
5.3 Feedback
The GL is placed in feedback mode by calling RenderMode with FEEDBACK.
When in feedback mode, framebuffer updates as described in chapter 4 are not
performed. Instead, information about primitives that would have otherwise been
rasterizedisreturnedtotheapplicationviathe feedback buffer.
Feedbackiscontrolledusing
void FeedbackBuffer(sizei n,enum type,float *buffer);
Version2.1-December1,20065.3. FEEDBACK 239
bufferisapointertoanarrayof?oating-pointvaluesintowhichfeedbackinforma-
tion will be placed, and n is a number indicating the maximum number of values
thatcanbewrittentothatarray. typeisasymbolicconstantdescribingtheinforma-
tiontobefedbackforeachvertex(see?gure5.2). TheerrorINVALID OPERATION
results if the GL is placed in feedback mode before a call to FeedbackBuffer has
beenmade,orifacalltoFeedbackBufferismadewhileinfeedbackmode.
While in feedback mode, each primitive that would be rasterized (or bitmap
or call to DrawPixels or CopyPixels, if the raster position is valid) generates a
block of values that get copied into the feedback array. If doing so would cause
the number of entries to exceed the maximum, the block is partially written so as
to ?ll the array (if there is any room left at all). The ?rst block of values gener-
ated after the GL enters feedback mode is placed at the beginning of the feedback
array, with subsequent blocks following. Each block begins with a code indicat-
ingtheprimitivetype,followedbyvaluesthatdescribetheprimitive’sverticesand
associated data. Entries are also written for bitmaps and pixel rectangles. Feed-
backoccursafterpolygonculling(section3.5.1)andPolygonModeinterpretation
of polygons (section 3.5.4) has taken place. It may also occur after polygons with
more than three edges are broken up into triangles (if the GL implementation ren-
derspolygonsbyperformingthisdecomposition). x,y,andz coordinatesreturned
by feedback are window coordinates; ifw is returned, it is in clip coordinates. No
depth offset arithmetic (section 3.5.5) is performed on the z values. In the case
of bitmaps and pixel rectangles, the coordinates returned are those of the current
rasterposition.
The texture coordinates and colors returned are those resulting from the clip-
ping operations described in section 2.14.8. Only coordinates for texture unit
TEXTURE0 are returned even for implementations which support multiple texture
units. Thecolorsreturnedaretheprimarycolors.
The ordering rules for GL command interpretation also apply in feedback
mode. Each command must be fully interpreted and its effects on both GL state
and the values to be written to the feedback buffer completed before a subsequent
commandmaybeexecuted.
FeedbackmodeisexitedbycallingRenderModewithanargumentvalueother
than FEEDBACK. When called while in feedback mode, RenderMode returns the
numberofvaluesplacedinthefeedbackarrayandresetsthefeedbackarraypointer
tobebuffer. Thereturnvalueneverexceedsthemaximumnumberofvaluespassed
toFeedbackBuffer.
Ifwritingavaluetothefeedbackbufferwouldcausemorevaluestobewritten
thanthespeci?edmaximumnumberofvalues,thenthevalueisnotwrittenandan
over?ow ?ag is set. In this case, RenderMode returns?1 when it is called, after
whichtheover?ow?agisreset. Whileinfeedbackmode,valuesarenotguaranteed
Version2.1-December1,2006240 CHAPTER5. SPECIALFUNCTIONS
Type coordinates color texture totalvalues
2D x,y – – 2
3D x,y,z – – 3
3D COLOR x,y,z k – 3+k
3D COLOR TEXTURE x,y,z k 4 7+k
4D COLOR TEXTURE x,y,z,w k 4 8+k
Table5.2: Correspondenceoffeedbacktypetonumberofvaluespervertex. k is1
incolorindexmodeand4inRGBAmode.
tobewrittenintothefeedbackbufferbeforeRenderModeiscalled.
Figure5.2givesagrammarforthearrayproducedbyfeedback. Eachprimitive
is indicated with a unique identifying value followed by some number of vertices.
A vertex is fed back as some number of ?oating-point values determined by the
feedback type. Table 5.2 gives the correspondence between feedback buffer and
thenumberofvaluesreturnedforeachvertex.
Thecommand
void PassThrough(float token);
may be used as a marker in feedback mode. token is returned as if it were a prim-
itive; it is indicated with its own unique identifying value. The ordering of any
PassThrough commands with respect to primitive speci?cation is maintained by
feedback. PassThrough may not occur between Begin and End. It has no effect
whentheGLisnotinfeedbackmode.
The state required for feedback is the pointer to the feedback array, the maxi-
mum number of values that may be placed there, and the feedback type. An over-
?ow ?ag is required to indicate whether the maximum allowable number of feed-
backvalueshasbeenwritten;initiallythis?agiscleared. Thesestatevariablesare
GLclientstate. Feedbackalsoreliesonthesamemode?agasselectiontoindicate
whethertheGLisinfeedback,selection,ornormalrenderingmode.
5.4 DisplayLists
A display list is simply a group of GL commands and arguments that has been
storedforsubsequentexecution. TheGLmaybeinstructedtoprocessaparticular
display list (possibly repeatedly) by providing a number that uniquely speci?es it.
Doing so causes the commands within the list to be executed just as if they were
given normally. The only exception pertains to commands that rely upon client
Version2.1-December1,20065.4. DISPLAYLISTS 241
feedback-list:
feedback-itemfeedback-list pixel-rectangle:
feedback-item DRAW PIXEL TOKENvertex
COPY PIXEL TOKENvertex
feedback-item: passthrough:
point PASS THROUGH TOKENf
line-segment
polygon vertex:
bitmap 2D:
pixel-rectangle f f
passthrough 3D:
f f f
point: 3D COLOR:
POINT TOKENvertex f f f color
line-segment: 3D COLOR TEXTURE:
LINE TOKENvertexvertex f f f colortex
LINE RESET TOKENvertexvertex 4D COLOR TEXTURE:
polygon: f f f f colortex
POLYGON TOKENnpolygon-spec
polygon-spec: color:
polygon-specvertex f f f f
vertexvertexvertex f
bitmap:
BITMAP TOKENvertex tex:
f f f f
Figure5.2: Feedbacksyntax. f isa?oating-pointnumber. nisa?oating-pointin-
tegergivingthenumberofverticesinapolygon. Thesymbolsendingwith TOKEN
are symbolic ?oating-point constants. The labels under the “vertex” rule show the
different data returned for vertices depending on the feedback type. LINE TOKEN
and LINE RESET TOKEN are identical except that the latter is returned only when
thelinestippleisresetforthatlinesegment.
Version2.1-December1,2006242 CHAPTER5. SPECIALFUNCTIONS
state. When such a command is accumulated into the display list (that is, when
issued,notwhenexecuted),theclientstateineffectatthattimeappliestothecom-
mand. Only server state is affected when the command is executed. As always,
pointers which are passed as arguments to commands are dereferenced when the
command is issued. (Vertex array pointers are dereferenced when the commands
ArrayElement, DrawArrays, DrawElements, or DrawRangeElements are ac-
cumulatedintoadisplaylist.)
Adisplaylistisbegunbycalling
void NewList(uint n,enum mode);
nisapositiveintegertowhichthedisplaylistthatfollowsisassigned,andmodeisa
symbolicconstantthatcontrolsthebehavioroftheGLduringdisplaylistcreation.
If mode is COMPILE, then commands are not executed as they are placed in the
display list. If mode is COMPILE AND EXECUTE then commands are executed as
they are encountered, then placed in the display list. If n = 0, then the error
INVALID VALUEisgenerated.
After calling NewList all subsequent GL commands are placed in the display
list(intheorderthecommandsareissued)untilacallto
void EndList(void);
occurs, after which the GL returns to its normal command execution state. It is
onlywhenEndListoccursthatthespeci?eddisplaylistisactuallyassociatedwith
the index indicated with NewList. The error INVALID OPERATION is generated
ifEndListiscalledwithoutapreviousmatchingNewList,orifNewListiscalled
a second time before calling EndList. The error OUT OF MEMORY is generated if
EndListiscalledandthespeci?eddisplaylistcannotbestoredbecauseinsuf?cient
memory is available. In this case GL implementations of revision 1.1 or greater
insure that no change is made to the previous contents of the display list, if any,
and that no other change is made to the GL state, except for the state changed by
executionofGLcommandswhenthedisplaylistmodeisCOMPILE AND EXECUTE.
Oncede?ned,adisplaylistisexecutedbycalling
void CallList(uint n);
n gives the index of the display list to be called. This causes the commands saved
inthedisplaylisttobeexecuted,inorder,justasiftheywereissuedwithoutusing
adisplaylist. Ifn = 0,thentheerrorINVALID VALUEisgenerated.
Thecommand
Version2.1-December1,20065.4. DISPLAYLISTS 243
void CallLists(sizei n,enum type,void *lists);
provides an ef?cient means for executing a number of display lists. n is an in-
teger indicating the number of display lists to be called, and lists is a pointer
that points to an array of offsets. Each offset is constructed as determined by
lists as follows. First, type may be one of the constants BYTE, UNSIGNED BYTE,
SHORT,UNSIGNED SHORT,INT,UNSIGNED INT,orFLOATindicatingthatthear-
raypointedtoby listsisanarrayofbytes,unsignedbytes,shorts,unsignedshorts,
integers,unsignedintegers,or?oats,respectively. Inthiscaseeachoffsetisfound
by simply converting each array element to an integer (?oating point values are
truncated). Further, type may be one of 2 BYTES, 3 BYTES, or 4 BYTES, indicat-
ing that the array contains sequences of 2, 3, or 4 unsigned bytes, in which case
eachintegeroffsetisconstructedaccordingtothefollowingalgorithm:
offset< 0
fori = 1tob
offset<offsetshiftedleft8bits
offset<offset+byte
advancetonext byteinthearray
bis2,3,or4,asindicatedby type. Ifn = 0,CallListsdoesnothing.
Each of the n constructed offsets is taken in order and added to a display list
base to obtain a display list number. For each number, the indicated display list is
executed. Thebaseissetbycalling
void ListBase(uint base);
tospecifytheoffset.
Indicatingadisplaylistindexthatdoesnotcorrespondtoanydisplaylisthasno
effect. CallListorCallListsmayappearinsideadisplaylist. (Ifthemodesupplied
to NewList is COMPILE AND EXECUTE, then the appropriate lists are executed,
but the CallList or CallLists, rather than those lists’ constituent commands, is
placed in the list under construction.) To avoid the possibility of in?nite recursion
resultingfromdisplaylistscallingoneanother,animplementationdependentlimit
is placed on the nesting level of display lists during display list execution. This
limitmustbeatleast64.
Twocommandsareprovidedtomanagedisplaylistindices.
uint GenLists(sizei s);
returnsanintegernsuchthattheindicesn,...,n+s?1arepreviouslyunused(i.e.
there ares previously unused display list indices starting atn). GenLists also has
Version2.1-December1,2006244 CHAPTER5. SPECIALFUNCTIONS
theeffectofcreatinganemptydisplaylistforeachoftheindicesn,...,n+s?1,
so that these indices all become used. GenLists returns 0 if there is no group ofs
contiguouspreviouslyunuseddisplaylistindices,orifs = 0.
boolean IsList(uint list);
returnsTRUEif lististheindexofsomedisplaylist.
Acontiguousgroupofdisplaylistsmaybedeletedbycalling
void DeleteLists(uint list,sizei range);
wherelististheindexofthe?rstdisplaylisttobedeletedandrangeisthenumber
ofdisplayliststobedeleted. Allinformationaboutthedisplaylistsislost,andthe
indices become unused. Indices to which no display list corresponds are ignored.
Ifrange = 0,nothinghappens.
Certain commands, when called while compiling a display list, are not com-
piled into the display list but are executed immediately. These commands fall in
severalcategoriesincluding
Display lists: GenListsandDeleteLists.
Render modes: FeedbackBuffer,SelectBuffer,andRenderMode.
Vertex arrays: ClientActiveTexture, ColorPointer, EdgeFlagPointer, Fog-
CoordPointer, IndexPointer, InterleavedArrays, NormalPointer, Secondary-
ColorPointer,TexCoordPointer,VertexAttribPointer,andVertexPointer.
Client state: EnableClientState, DisableClientState, EnableVertexAttrib-
Array,DisableVertexAttribArray,PushClientAttrib,andPopClientAttrib.
Pixels and textures: PixelStore, ReadPixels, GenTextures, DeleteTextures,
andAreTexturesResident.
Occlusion queries: GenQueriesandDeleteQueries.
Vertex buffer objects: GenBuffers, DeleteBuffers, BindBuffer, BufferData,
BufferSubData,MapBuffer,andUnmapBuffer.
Program and shader objects: CreateProgram, CreateShader, DeletePro-
gram, DeleteShader, AttachShader, DetachShader, BindAttribLocation,
CompileShader,ShaderSource,LinkProgram,andValidateProgram.
GL command stream management: FinishandFlush.
Other queries: All query commands whose names begin with Get and Is (see
chapter6).
GL commands that source data from buffer objects dereference the buffer ob-
ject data in question at display list compile time, rather than encoding the buffer
ID and buffer offset into the display list. Only GL commands that are executed
immediately, rather than being compiled into a display list, are permitted to use a
bufferobjectasadatasink.
Version2.1-December1,20065.5. FLUSHANDFINISH 245
TexImage3D, TexImage2D, TexImage1D, Histogram, and Col-
orTable are executed immediately when called with the correspond-
ing proxy arguments PROXY TEXTURE 3D; PROXY TEXTURE 2D or
PROXY TEXTURE CUBE MAP; PROXY TEXTURE 1D; PROXY HISTOGRAM;
and PROXY COLOR TABLE, PROXY POST CONVOLUTION COLOR TABLE, or
PROXY POST COLOR MATRIX COLOR TABLE.
When a program object is in use, a display list may be executed whose vertex
attribute calls do not match up exactly with what is expected by the vertex shader
contained in that program object. Handling of this mismatch is described in sec-
tion2.15.3.
DisplaylistsrequireonebitofstatetoindicatewhetheraGLcommandshould
be executed immediately or placed in a display list. In the initial state, commands
are executed immediately. If the bit indicates display list creation, an index is
required to indicate the current display list being de?ned. Another bit indicates,
during display list creation, whether or not commands should be executed as they
arecompiled intothedisplay list. Oneintegeris requiredforthe currentListBase
setting;itsinitialvalueiszero. Finally,statemustbemaintainedtoindicatewhich
integers are currently in use as display list indices. In the initial state, no indices
areinuse.
5.5 FlushandFinish
Thecommand
void Flush(void);
indicatesthatallcommandsthathavepreviouslybeensenttotheGLmustcomplete
in?nitetime.
Thecommand
void Finish(void);
forces all previous GL commands to complete. Finish does not return until all
effects from previously issued commands on GL client and server state and the
framebufferarefullyrealized.
5.6 Hints
CertainaspectsofGLbehavior,whenthereisroomforvariation,maybecontrolled
withhints. Ahintisspeci?edusing
Version2.1-December1,2006246 CHAPTER5. SPECIALFUNCTIONS
Target Hintdescription
PERSPECTIVE CORRECTION HINT Qualityofparameterinterpolation
POINT SMOOTH HINT Pointsamplingquality
LINE SMOOTH HINT Linesamplingquality
POLYGON SMOOTH HINT Polygonsamplingquality
FOG HINT Fogquality
(calculatedper-pixelorper-vertex)
GENERATE MIPMAP HINT Qualityandperformanceof
automaticmipmaplevelgeneration
TEXTURE COMPRESSION HINT Qualityandperformanceof
textureimagecompression
FRAGMENT SHADER DERIVATIVE HINT Derivativeaccuracyforfragment
processingbuilt-infunctions
dFdx,dFdyandfwidth
Table5.3: Hinttargetsanddescriptions.
void Hint(enum target,enum hint);
targetisasymbolicconstantindicatingthebehaviortobecontrolled,and hintisa
symbolicconstantindicatingwhattypeofbehaviorisdesired. Thepossibletargets
aredescribedintable5.3;foreachtarget,hintmustbeoneofFASTEST,indicating
thatthemostef?cientoptionshouldbechosen;NICEST,indicatingthatthehighest
quality option should be chosen; and DONT CARE, indicating no preference in the
matter.
For the texture compression hint, a hint ofFASTEST indicates that texture im-
ages should be compressed as quickly as possible, while NICEST indicates that
the texture images be compressed with as little image degradation as possible.
FASTEST should be used for one-time texture compression, and NICEST should
be used if the compression results are to be retrieved by GetCompressedTexIm-
age(section6.1.4)forreuse.
The interpretation of hints is implementation dependent. An implementation
mayignorethementirely.
TheinitialvalueofallhintsisDONT CARE.
Version2.1-December1,2006Chapter 6
StateandStateRequests
The state required to describe the GL machine is enumerated in section 6.2. Most
state is set through the calls described in previous chapters, and can be queried
usingthecallsdescribedinsection6.1.
6.1 QueryingGLState
6.1.1 SimpleQueries
Much of the GL state is completely identi?ed by symbolic constants. The values
of these state variables can be obtained using a set of Get commands. There are
fourcommandsforobtainingsimplestatevariables:
void GetBooleanv(enum value,boolean *data);
void GetIntegerv(enum value,int *data);
void GetFloatv(enum value,float *data);
void GetDoublev(enum value,double *data);
The commands obtain boolean, integer, ?oating-point, or double-precision state
variables. value is a symbolic constant indicating the state variable to return. data
isapointertoascalarorarrayoftheindicatedtypeinwhichtoplacethereturned
data. Inaddition
boolean IsEnabled(enum value);
canbeusedtodetermineifvalueiscurrentlyenabled(aswithEnable)ordisabled.
247248 CHAPTER6. STATEANDSTATEREQUESTS
6.1.2 DataConversions
If a Get command is issued that returns value types different from the type of the
value being obtained, a type conversion is performed. If GetBooleanv is called,
a ?oating-point or integer value converts to FALSE if and only if it is zero (oth-
erwise it converts to TRUE). If GetIntegerv (or any of the Get commands below)
is called, a boolean value is interpreted as either 1 or 0, and a ?oating-point value
is rounded to the nearest integer, unless the value is an RGBA color component,
a DepthRange value, a depth buffer clear value, or a normal coordinate. In these
cases, the Get command converts the ?oating-point value to an integer according
the INT entry of table 4.7; a value not in [?1,1] converts to an unde?ned value.
If GetFloatv is called, a boolean value is interpreted as either 1.0 or 0.0, an in-
teger is coerced to ?oating-point, and a double-precision ?oating-point value is
convertedtosingle-precision. Analogousconversionsarecarriedoutinthecaseof
GetDoublev. Ifavalueissolargeinmagnitudethatitcannotberepresentedwith
therequestedtype,thenthenearestvaluerepresentableusingtherequestedtypeis
returned.
Unless otherwise indicated, multi-valued state variables return their multiple
values in the same order as they are given as arguments to the commands that set
them. For instance, the two DepthRange parameters are returned in the order n
followed by f. Similarly, points for evaluator maps are returned in the order that
they appeared when passed to Map1. Map2 returnsR in the [(uorder)i+j]th
ij
blockofvalues(seepage231fori,j, uorder,andR ).
ij
Matrices may be queried and returned in transposed form by calling Get-
Booleanv, GetIntegerv, GetFloatv, and GetDoublev with pname set to
one of TRANSPOSE MODELVIEW MATRIX, TRANSPOSE PROJECTION MATRIX,
TRANSPOSE TEXTURE MATRIX,orTRANSPOSE COLOR MATRIX.Theeffectof
GetFloatv(TRANSPOSE MODELVIEW MATRIX,m);
isthesameastheeffectofthecommandsequence
GetFloatv(MODELVIEW MATRIX,m);
T
m=m ;
SimilarconversionsoccurwhenqueryingTRANSPOSE PROJECTION MATRIX,
TRANSPOSE TEXTURE MATRIX,andTRANSPOSE COLOR MATRIX.
Most texture state variables are quali?ed by the value of ACTIVE TEXTURE
to determine which server texture state vector is queried. Client tex-
ture state variables such as texture coordinate array pointers are qual-
i?ed by the value of CLIENT ACTIVE TEXTURE. Tables 6.5, 6.6, 6.10,
Version2.1-December1,20066.1. QUERYINGGLSTATE 249
6.16, 6.19, and 6.34 indicate those state variables which are quali?ed by
ACTIVE TEXTURE or CLIENT ACTIVE TEXTURE during state queries. Queries
of texture state variables corresponding to texture coordinate processing
units (namely, TexGen state and enables, and matrices) will generate an
INVALID OPERATION error if the value of ACTIVE TEXTURE is greater than or
equal to MAX TEXTURE COORDS. All other texture state queries will result in an
INVALID OPERATION error if the value of ACTIVE TEXTURE is greater than or
equaltoMAX COMBINED TEXTURE IMAGE UNITS.
6.1.3 EnumeratedQueries
Other commands exist to obtain state variables that are identi?ed by a category
(clipplane,light,material,etc.) aswellasasymbolicconstant. Theseare
void GetClipPlane(enum plane,double eqn[4]);
void GetLight{if}v(enum light,enum value,T data);
void GetMaterial{if}v(enum face,enum value,T data);
void GetTexEnv{if}v(enum env,enum value,T data);
void GetTexGen{ifd}v(enum coord,enum value,T data);
void GetTexParameter{if}v(enum target,enum value,
T data);
void GetTexLevelParameter{if}v(enum target,int lod,
enum value,T data);
void GetPixelMap{uiusf}v(enum map,T data);
void GetMap{ifd}v(enum map,enum value,T data);
void GetBufferParameteriv(enum target,enum value,
T data);
GetClipPlane always returns four double-precision values in eqn; these are the
coef?cients of the plane equation of plane in eye coordinates (these coordinates
arethosethatwerecomputedwhentheplanewasspeci?ed).
GetLightplacesinformationaboutvalue(asymbolicconstant)forlight(alsoa
symbolicconstant)in data. POSITIONorSPOT DIRECTIONreturnsvaluesineye
coordinates(again,thesearethecoordinatesthatwerecomputedwhentheposition
ordirectionwasspeci?ed).
GetMaterial, GetTexGen, GetTexEnv, GetTexParameter, and GetBuffer-
ParameteraresimilartoGetLight,placinginformationabout valueforthetarget
indicated by their ?rst argument into data. The face argument to GetMaterial
must be either FRONT or BACK, indicating the front or back material, respectively.
The env argument to GetTexEnv must be either POINT SPRITE, TEXTURE ENV,
Version2.1-December1,2006250 CHAPTER6. STATEANDSTATEREQUESTS
or TEXTURE FILTER CONTROL. The coord argument to GetTexGen must be one
ofS,T,R, orQ. For GetTexGen,EYE LINEAR coef?cients are returned in the eye
coordinates that were computed when the plane was speci?ed; OBJECT LINEAR
coef?cientsarereturnedinobjectcoordinates.
GetTexParameter
parameter target may be one of TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, or
TEXTURE CUBE MAP,indicatingthecurrentlyboundone-,two-,three-dimensional,
orcubemaptextureobject. GetTexLevelParameterparameter targetmaybeone
of TEXTURE 1D, TEXTURE 2D, TEXTURE 3D, TEXTURE CUBE MAP POSITIVE X,
TEXTURE CUBE MAP NEGATIVE X, TEXTURE CUBE MAP POSITIVE Y,
TEXTURE CUBE MAP NEGATIVE Y, TEXTURE CUBE MAP POSITIVE Z,
TEXTURE CUBE MAP NEGATIVE Z, PROXY TEXTURE 1D, PROXY TEXTURE 2D,
PROXY TEXTURE 3D,orPROXY TEXTURE CUBE MAP,indicatingtheone-,two-,or
three-dimensional texture object, or one of the six distinct 2D images making up
the cube map texture object or one-, two-, three-dimensional, or cube map proxy
state vector. Note that TEXTURE CUBE MAP is not a valid target parameter for
GetTexLevelParameter, because it does not specify a particular cube map face.
value is a symbolic value indicating which texture parameter is to be obtained.
For GetTexParameter, value must be either TEXTURE RESIDENT, or one of the
symbolic values in table 3.18. The lod argument to GetTexLevelParameter de-
termines which level-of-detail’s state is returned. If the lod argument is less than
zero or if it is larger than the maximum allowable level-of-detail then the error
INVALID VALUEoccurs.
For texture images with uncompressed internal formats, queries of
value of TEXTURE RED SIZE, TEXTURE GREEN SIZE, TEXTURE BLUE SIZE,
TEXTURE ALPHA SIZE, TEXTURE LUMINANCE SIZE, TEXTURE DEPTH SIZE,
and TEXTURE INTENSITY SIZE return the actual resolutions of the stored im-
age array components, not the resolutions speci?ed when the image array was
de?ned. For texture images with a compressed internal format, the resolutions
returnedspecifythecomponentresolutionofanuncompressedinternalformatthat
produces an image of roughly the same quality as the compressed image in ques-
tion. Since the quality of the implementation’s compression algorithm is likely
data-dependent, the returned component sizes should be treated only as rough ap-
proximations.
Querying value TEXTURE COMPRESSED IMAGE SIZE returns the
size (in ubytes) of the compressed texture image that would be
returned by GetCompressedTexImage (section 6.1.4). Querying
TEXTURE COMPRESSED IMAGE SIZE is not allowed on texture images with
an uncompressed internal format or on proxy targets and will result in an
INVALID OPERATIONerrorifattempted.
Version2.1-December1,20066.1. QUERYINGGLSTATE 251
Queries of value TEXTURE WIDTH, TEXTURE HEIGHT, TEXTURE DEPTH, and
TEXTURE BORDER return the width, height, depth, and border as speci?ed when
the image array was created. The internal format of the image array is queried
as TEXTURE INTERNAL FORMAT, or as TEXTURE COMPONENTS for compatibility
withGLversion1.0.
ForGetPixelMap,the mapmustbeamapnamefromtable3.3. ForGetMap,
map must be one of the map types described in section 5.1, and value must
be one of ORDER, COEFF, or DOMAIN. The GetPixelMapfv, GetPixelMapuiv,
and GetPixelMapusv commands write all the values in the named pixel map
to data. If a pixel pack buffer is bound (as indicated by a non-zero value of
PIXEL PACK BUFFER BINDING), data is an offset into the pixel pack buffer; oth-
erwise, data is a pointer to client memory. All pixel storage and pixel trans-
fer modes are ignored when returning a pixel map. n machine units are written
where n is the size of the pixel map times the size of FLOAT, UNSIGNED INT,
or UNSIGNED SHORT respectively in basic machine units. If a pixel pack buffer
object is bound and data + n is greater than the size of the pixel buffer, an
INVALID OPERATION error results. If a pixel pack buffer object is bound and
data is not evenly divisible by the number of basic machine units needed to
store in memory a FLOAT, UNSIGNED INT, or UNSIGNED SHORT respectively, an
INVALID OPERATIONerrorresults.
6.1.4 TextureQueries
Thecommand
void GetTexImage(enum tex,int lod,enum format,
enum type,void *img);
is used to obtain texture images. It is somewhat different from the other get com-
mands; texisasymbolicvalueindicatingwhichtexture(ortexturefaceinthecase
of a cube map texture target name) is to be obtained. TEXTURE 1D,TEXTURE 2D,
and TEXTURE 3D indicate a one-, two-, or three-dimensional texture respectively,
while TEXTURE CUBE MAP POSITIVE X, TEXTURE CUBE MAP NEGATIVE X,
TEXTURE CUBE MAP POSITIVE Y, TEXTURE CUBE MAP NEGATIVE Y,
TEXTURE CUBE MAP POSITIVE Z, and TEXTURE CUBE MAP NEGATIVE Z indi-
cate the respective face of a cube map texture. lod is a level-of-detail number,
formatisapixelformatfromtable3.6, typeisapixeltypefrom table3.5.
GetTexImage obtains component groups from a texture image with the
indicated level-of-detail. Calling GetTexImage with a color format (one
of RED, GREEN, BLUE, ALPHA, RGB, BGR, RGBA, BGRA, LUMINANCE, or
Version2.1-December1,2006252 CHAPTER6. STATEANDSTATEREQUESTS
LUMINANCE ALPHA) when the base internal format of the texture image is not a
colorformat,orwithaformatofDEPTH COMPONENTwhenthebaseinternalformat
is not a depth format, causes the error INVALID OPERATION. If the base internal
format is a color format then the components are assigned among R, G, B, and A
according to table 6.1, starting with the ?rst group in the ?rst row, and continuing
by obtaining groups in order from each row and proceeding from the ?rst row to
the last, and from the ?rst image to the last for three-dimensional textures. If the
baseinternalformatisDEPTH COMPONENT,theneachdepthcomponentisassigned
with the same ordering of rows and images. These groups are then packed and
placed in client or pixel buffer object memory. If a pixel pack buffer is bound (as
indicatedbyanon-zerovalueof PIXEL PACK BUFFER BINDING),imgisanoffset
into the pixel pack buffer; otherwise, img is a pointer to client memory. No pixel
transfer operations are performed on this image, but pixel storage modes that are
applicabletoReadPixelsareapplied.
For three-dimensional textures, pixel storage operations are applied as if the
image were two-dimensional, except that the additional pixel storage state values
PACK IMAGE HEIGHT and PACK SKIP IMAGES are applied. The correspondence
oftexelstomemorylocationsisasde?nedforTexImage3Dinsection3.8.1.
The row length, number of rows, image depth, and number of images are de-
terminedbythesizeofthetextureimage(includinganyborders). CallingGetTex-
Image with lod less than zero or larger than the maximum allowable causes the
error INVALID VALUE. Calling GetTexImage with a format of COLOR INDEX or
STENCIL INDEX causes the error INVALID ENUM. If a pixel pack buffer object
isboundandpackingthetextureimageintothebuffer’smemorywouldexceedthe
size of the buffer, an INVALID OPERATION error results. If a pixel pack buffer
object is bound and img is not evenly divisible by the number of basic machine
units needed to store in memory a FLOAT, UNSIGNED INT, or UNSIGNED SHORT
respectively,anINVALID OPERATIONerrorresults.
Thecommand
void GetCompressedTexImage(enum target,int lod,
void *img);
isusedtoobtaintextureimagesstoredincompressedform. Theparameterstarget,
lod,andimgareinterpretedinthesamemannerasinGetTexImage. Whencalled,
GetCompressedTexImage writes n ubytes of compressed image data to the
pixel pack buffer or client memory pointed to by img, where n is the value of
TEXTURE COMPRESSED IMAGE SIZEforthetexture. Thecompressedimagedata
is formatted according to the de?nition of the texture’s internal format. All pixel
storageandpixeltransfermodesareignoredwhenreturningacompressedtexture
image.
Version2.1-December1,20066.1. QUERYINGGLSTATE 253
BaseInternalFormat R G B A
ALPHA 0 0 0 A
i
LUMINANCE(or1) L 0 0 1
i
LUMINANCE ALPHA(or2) L 0 0 A
i i
INTENSITY I 0 0 1
i
RGB(or3) R G B 1
i i i
RGBA(or4) R G B A
i i i i
Table 6.1: Texture, table, and ?lter return values. R , G , B , A , L , and I are
i i i i i i
componentsoftheinternalformatthatareassignedtopixelvaluesR,G,B,andA.
Ifarequestedpixelvalueisnotpresentintheinternalformat,thespeci?edconstant
valueisused.
Calling GetCompressedTexImage with an lod value less than zero or greater
than the maximum allowable causes anINVALID VALUE error. Calling GetCom-
pressedTexImage with a texture image stored with an uncompressed internal for-
mat causes anINVALID OPERATION error. If a pixel pack buffer object is bound
andimg +n is greater than the size of the buffer, anINVALID OPERATION error
results.
Thecommand
boolean IsTexture(uint texture);
returnsTRUEiftextureisthenameofatextureobject. Iftextureiszero,orisanon-
zero value that is not the name of a texture object, or if an error condition occurs,
IsTexturereturnsFALSE.AnamereturnedbyGenTextures,butnotyetbound,is
notthenameofatextureobject.
6.1.5 StippleQuery
Thecommand
void GetPolygonStipple(void *pattern);
obtains the polygon stipple. The pattern is packed into pixel pack buffer or client
memory according to the procedure given in section 4.3.2 for ReadPixels; it is
as if the height and width passed to that command were both equal to 32, the type
wereBITMAP,andthe formatwereCOLOR INDEX.
Version2.1-December1,2006254 CHAPTER6. STATEANDSTATEREQUESTS
6.1.6 ColorMatrixQuery
The scale and bias variables are queried using GetFloatv with pname set
to the appropriate variable name. The top matrix on the color matrix
stack is returned by GetFloatv called with pname set to COLOR MATRIX or
TRANSPOSE COLOR MATRIX. The depth of the color matrix stack, and the maxi-
mumdepthofthecolormatrixstack,arequeriedwithGetIntegerv,settingpname
toCOLOR MATRIX STACK DEPTHandMAX COLOR MATRIX STACK DEPTHrespec-
tively.
6.1.7 ColorTableQuery
Thecurrentcontentsofacolortablearequeriedusing
void GetColorTable(enum target,enum format,enum type,
void *table);
target must be one of the regular color table names listed in table 3.4. format and
typeacceptthesamevaluesasdothecorrespondingparametersofGetTexImage,
except that a format of DEPTH COMPONENT causes the error INVALID ENUM. The
one-dimensionalcolortableimageisreturnedto pixelpackbufferorclientmem-
ory startingattable. Nopixeltransferoperationsareperformedonthisimage,but
pixel storage modes that are applicable to ReadPixels are performed. Color com-
ponentsthatarerequestedinthespeci?edformat,butwhicharenotincludedinthe
internalformatofthecolorlookuptable,arereturnedaszero. Theassignmentsof
internalcolorcomponentstothecomponentsrequestedby formataredescribedin
table6.1.
Thefunctions
void GetColorTableParameter{if}v(enum target,
enum pname,T params);
areusedforintegerand?oatingpointquery.
target must be one of the regular or proxy color table names listed in
table 3.4. pname is one of COLOR TABLE SCALE, COLOR TABLE BIAS,
COLOR TABLE FORMAT, COLOR TABLE WIDTH, COLOR TABLE RED SIZE,
COLOR TABLE GREEN SIZE, COLOR TABLE BLUE SIZE,
COLOR TABLE ALPHA SIZE, COLOR TABLE LUMINANCE SIZE, or
COLOR TABLE INTENSITY SIZE. The value of the speci?ed parameter is
returnedin params.
Version2.1-December1,20066.1. QUERYINGGLSTATE 255
6.1.8 ConvolutionQuery
Thecurrentcontentsofaconvolution?lterimagearequeriedwiththecommand
void GetConvolutionFilter(enum target,enum format,
enum type,void *image);
target must be CONVOLUTION 1D or CONVOLUTION 2D. format and type accept
the same values as do the corresponding parameters of GetTexImage, except
that a format of DEPTH COMPONENT causes the error INVALID ENUM. The one-
dimensional or two-dimensional images is returned to pixel pack buffer or client
memory startingat image. Pixelprocessingandcomponentmappingareidentical
tothoseofGetTexImage.
Thecurrentcontentsofaseparable?lterimagearequeriedusing
void GetSeparableFilter(enum target,enum format,
enum type,void *row,void *column,void *span);
target must be SEPARABLE 2D. format and type accept the same values as do the
corresponding parameters of GetTexImage. The row and column images are re-
turned to pixel pack buffer or client memory starting at row and column respec-
tively. span is currently unused. Pixel processing and component mapping are
identicaltothoseofGetTexImage.
Thefunctions
void GetConvolutionParameter{if}v(enum target,
enum pname,T params);
are used for integer and ?oating point query. target must be
CONVOLUTION 1D, CONVOLUTION 2D, or SEPARABLE 2D. pname is
one of CONVOLUTION BORDER COLOR, CONVOLUTION BORDER MODE,
CONVOLUTION FILTER SCALE, CONVOLUTION FILTER BIAS,
CONVOLUTION FORMAT, CONVOLUTION WIDTH, CONVOLUTION HEIGHT,
MAX CONVOLUTION WIDTH, or MAX CONVOLUTION HEIGHT. The value of the
speci?edparameterisreturnedin params.
6.1.9 HistogramQuery
Thecurrentcontentsofthehistogramtablearequeriedusing
void GetHistogram(enum target,boolean reset,
enum format,enum type,void values);
*
Version2.1-December1,2006256 CHAPTER6. STATEANDSTATEREQUESTS
targetmustbeHISTOGRAM.typeandformatacceptthesamevaluesasdothecorre-
spondingparametersofGetTexImage,exceptthataformatofDEPTH COMPONENT
causestheerrorINVALID ENUM.Theone-dimensionalhistogramtableimageisre-
turnedto pixelpackbufferorclientmemorystartingattype. Pixelprocessingand
componentmappingareidenticaltothoseofGetTexImage,exceptthatinsteadof
applying the Final Conversion pixel storage mode, component values are simply
clampedtotherangeofthetargetdatatype.
If reset is TRUE, then all counters of all elements of the histogram are reset to
zero. Countersareresetwhetherreturnedornot.
Nocountersaremodi?edif resetisFALSE.
Calling
void ResetHistogram(enum target);
resets all counters of all elements of the histogram table to zero. target must be
HISTOGRAM.
It is not an error to reset or query the contents of a histogram table with zero
entries.
Thefunctions
void GetHistogramParameter{if}v(enum target,
enum pname,T params);
are used for integer and ?oating point query. target must be HISTOGRAM or
PROXY HISTOGRAM. pname is one of HISTOGRAM FORMAT, HISTOGRAM WIDTH,
HISTOGRAM RED SIZE, HISTOGRAM GREEN SIZE, HISTOGRAM BLUE SIZE,
HISTOGRAM ALPHA SIZE, or HISTOGRAM LUMINANCE SIZE. pname may be
HISTOGRAM SINK only for target HISTOGRAM. The value of the speci?ed
parameterisreturnedin params.
6.1.10 MinmaxQuery
Thecurrentcontentsoftheminmaxtablearequeriedusing
void GetMinmax(enum target,boolean reset,enum format,
enum type,void values);
*
target must be MINMAX. type and format accept the same values as do the corre-
spondingparametersofGetTexImage,exceptthataformatofDEPTH COMPONENT
causes the error INVALID ENUM. A one-dimensional image of width 2 is returned
Version2.1-December1,20066.1. QUERYINGGLSTATE 257
to pixel pack buffer or client memory starting at values. Pixel processing and
componentmappingareidenticaltothoseofGetTexImage.
If reset is TRUE, then each minimum value is reset to the maximum repre-
sentable value, and each maximum value is reset to the minimum representable
value. Allvaluesarereset,whetherreturnedornot.
Novaluesaremodi?edif resetisFALSE.
Calling
void ResetMinmax(enum target);
resets all minimum and maximum values of target to to their maximum and mini-
mumrepresentablevalues,respectively, targetmustbeMINMAX.
Thefunctions
void GetMinmaxParameter{if}v(enum target,enum pname,
T params);
are used for integer and ?oating point query. target must be MINMAX. pname is
MINMAX FORMAT or MINMAX SINK. The value of the speci?ed parameter is re-
turnedin params.
6.1.11 PointerandStringQueries
Thecommand
void GetPointerv(enum pname,void **params);
obtains the pointer or pointers named pname in the
array params. The possible values for pname are
SELECTION BUFFER POINTER, FEEDBACK BUFFER POINTER,
VERTEX ARRAY POINTER, NORMAL ARRAY POINTER, COLOR ARRAY POINTER,
SECONDARY COLOR ARRAY POINTER, INDEX ARRAY POINTER,
TEXTURE COORD ARRAY POINTER, FOG COORD ARRAY POINTER, and
EDGE FLAG ARRAY POINTER.Eachreturnsasinglepointervalue.
Finally,
ubyte *GetString(enum name);
returns a pointer to a static string describing some aspect of the current GL
1
connection . The possible values for name are VENDOR, RENDERER, VERSION,
1
Applicationsmakingcopiesofthesestaticstringsshouldneverusea?xed-lengthbuffer,because
the strings may grow unpredictably between releases, resulting in buffer over?ow when copying.
This is particularly true of theEXTENSIONS string, which has become extremely long in some
GLimplementations.
Version2.1-December1,2006258 CHAPTER6. STATEANDSTATEREQUESTS
SHADING LANGUAGE VERSION, and EXTENSIONS. The format of the RENDERER
and VENDOR strings is implementation dependent. The EXTENSIONS string con-
tainsaspaceseparatedlistofextensionnames(theextensionnamesthemselvesdo
notcontainanyspaces). TheVERSIONandSHADING LANGUAGE VERSIONstrings
arelaidoutasfollows:
<versionnumber><space><vendor-speci?cinformation >
The version number is either of the form major number.minor number or ma-
jor number.minor number.release number, where the numbers all have one or
more digits. The release number and vendor speci?c information are optional.
However, if present, then they pertain to the server and their format and contents
areimplementationdependent.
GetString returns the version number (returned in the VERSION string) and
the extension names (returned in the EXTENSIONS string) that can be supported
on the connection. Thus, if the client and server support different versions and/or
extensions,acompatibleversionandlistofextensionsisreturned.
6.1.12 OcclusionQueries
Thecommand
boolean IsQuery(uint id);
returnsTRUEif idisthenameofaqueryobject. If idiszero,orif idisanon-zero
valuethatisnotthenameofaqueryobject,IsQueryreturnsFALSE.
Informationaboutaquerytargetcanbequeriedwiththecommand
void GetQueryiv(enum target,enum pname,int *params);
If pname isCURRENT QUERY, the name of the currently active query for target, or
zeroifnoqueryisactive,willbeplacedin params.
IfpnameisQUERY COUNTER BITS,thenumberofbitsinthecounterfortarget
willbeplacedinparams. Thenumberofquerycounterbitsmaybezero,inwhich
casethecountercontainsnousefulinformation. Otherwise,theminimumnumber
of bits allowed is a function of the implementation’s maximum viewport dimen-
sions (MAX VIEWPORT DIMS). In this case, the counter must be able to represent
at least two overdraws for every pixel in the viewport The formula to compute the
allowableminimumvalue(wherenistheminimumnumberofbits)is:
n = min{32,dlog (maxViewportWidth?maxViewportHeight?2)e}
2
Thestateofaqueryobjectcanbequeriedwiththecommands
Version2.1-December1,20066.1. QUERYINGGLSTATE 259
void GetQueryObjectiv(uint id,enum pname,
int *params);
void GetQueryObjectuiv(uint id,enum pname,
uint *params);
Ifidisnotthenameofaqueryobject,orifthequeryobjectnamedbyidiscurrently
active,thenanINVALID OPERATIONerrorisgenerated.
If pname is QUERY RESULT, then the query object’s result value is placed in
params. Ifthenumberofquerycounterbitsfortargetiszero,thentheresultvalue
isalways0.
There may be an indeterminate delay before the above query returns. If
pnameisQUERY RESULT AVAILABLE,itimmediatelyreturnsFALSEifsuchade-
lay would be required, TRUE otherwise. It must always be true that if any query
object returns result available of TRUE, all queries issued prior to that query must
alsoreturnTRUE.
Querying the state for any given query object forces that occlusion query to
completewithina?niteamountoftime.
If multiple queries are issued on the same target and id prior to calling Get-
QueryObject[u]iv, the result returned will always be from the last query issued.
The results from any queries before the last one will be lost if the results are not
retrievedbeforestartinganewqueryonthesametargetandid.
6.1.13 BufferObjectQueries
Thecommand
boolean IsBuffer(uint buffer);
returnsTRUEifbufferisthenameofanbufferobject. Ifbufferiszero,orifbufferis
anon-zerovaluethatisnotthenameofanbufferobject, IsBufferreturnsFALSE.
Thecommand
void GetBufferSubData(enum target,intptr offset,
sizeiptr size,void *data);
queries the data contents of a buffer object. target is ARRAY BUFFER,
ELEMENT ARRAY BUFFER, PIXEL PACK BUFFER, or PIXEL UNPACK BUFFER.
offsetandsizeindicatetherangeofdatainthebufferobjectthatistobequeried,in
terms of basic machine units. data speci?es a region of client memory, size basic
machineunitsinlength,intowhichthedataistoberetrieved.
Version2.1-December1,2006260 CHAPTER6. STATEANDSTATEREQUESTS
AnerrorisgeneratedifGetBufferSubDataisexecutedforabufferobjectthat
iscurrentlymapped.
While the data store of a buffer object is mapped, the pointer to the data store
canbequeriedbycalling
void GetBufferPointerv(enum target,enum pname,
void **params);
with target set to ARRAY BUFFER, ELEMENT ARRAY BUFFER,
PIXEL PACK BUFFER, or PIXEL UNPACK BUFFER and pname set to
BUFFER MAP POINTER. The single buffer map pointer is returned in *params.
GetBufferPointerv returns the NULL pointer value if the buffer’s data store is not
currently mapped, or if the requesting client did not map the buffer object’s data
store,andtheimplementationisunabletosupportmappingsonmultipleclients.
6.1.14 ShaderandProgramQueries
State stored in shader or program objects can be queried by commands that ac-
cept shader or program object names. These commands will generate the error
INVALID VALUE if the provided name is not the name of either a shader or pro-
gram object, and INVALID OPERATION if the provided name identi?es an object
of the other type. If an error is generated, variables used to hold return values are
notmodi?ed.
Thecommand
boolean IsShader(uint shader);
returns TRUE if shader is the name of a shader object. If shader is zero, or a non-
zero value that is not the name of a shader object, IsShader returns FALSE. No
errorisgeneratedif shaderisnotavalidshaderobjectname.
Thecommand
void GetShaderiv(uintshader,enumpname,int*params);
returns properties of the shader object named shader in params. The parameter
valuetoreturnisspeci?edby pname.
If pname is SHADER TYPE, VERTEX SHADER is returned if shader is a ver-
tex shader object, and FRAGMENT SHADER is returned if shader is a fragment
shader object. If pname is DELETE STATUS, TRUE is returned if the shader
has been ?agged for deletion and FALSE is returned otherwise. If pname is
COMPILE STATUS, TRUE is returned if the shader was last compiled successfully,
Version2.1-December1,20066.1. QUERYINGGLSTATE 261
and FALSE is returned otherwise. If pname is INFO LOG LENGTH, the length of
the info log, including a null terminator, is returned. If there is no info log, zero
isreturned. If pnameisSHADER SOURCE LENGTH,thelengthoftheconcatenation
of the source strings making up the shader source, including a null terminator, is
returned. Ifnosourcehasbeende?ned,zeroisreturned.
Thecommand
boolean IsProgram(uint program);
returns TRUE if program is the name of a program object. If program is zero,
or a non-zero value that is not the name of a program object, IsProgram returns
FALSE.Noerrorisgeneratedif programisnotavalidprogramobjectname.
Thecommand
void GetProgramiv(uint program,enum pname,
int *params);
returnspropertiesoftheprogramobjectnamedprograminparams. Theparameter
valuetoreturnisspeci?edby pname.
IfpnameisDELETE STATUS,TRUEisreturnediftheprogramhasbeen?agged
for deletion and FALSE is returned otherwise. If pname is LINK STATUS, TRUE
is returned if the program was last compiled successfully, and FALSE is returned
otherwise. IfpnameisVALIDATE STATUS,TRUEisreturnedifthelastcalltoVal-
idateProgram with program was successful, andFALSE is returned otherwise. If
pnameisINFO LOG LENGTH,thelengthoftheinfolog,includinganullterminator,
isreturned. Ifthereisnoinfolog,0isreturned. If pnameisATTACHED SHADERS,
thenumberofobjectsattachedisreturned. If pnameisACTIVE ATTRIBUTES,the
number of active attributes in program is returned. If no active attributes exist,
0 is returned. If pname is ACTIVE ATTRIBUTE MAX LENGTH, the length of the
longest active attribute name, including a null terminator, is returned. If no ac-
tive attributes exist, 0 is returned. If pname is ACTIVE UNIFORMS, the number of
active uniforms is returned. If no active uniforms exist, 0 is returned. If pname
isACTIVE UNIFORM MAX LENGTH,thelengthofthelongestactiveuniformname,
includinganullterminator,isreturned. Ifnoactiveuniformsexist,0isreturned.
Thecommand
void GetAttachedShaders(uint program,sizei maxCount,
sizei *count,uint *shaders);
returns the names of shader objects attached to program in shaders. The actual
numberofshadernameswrittenintoshadersisreturnedincount. Ifnoshadersare
Version2.1-December1,2006262 CHAPTER6. STATEANDSTATEREQUESTS
attached, count is set to zero. If count is NULL then it is ignored. The maximum
numberofshadernamesthatmaybewrittenintoshadersisspeci?edbymaxCount.
The number of objects attached to program is given by can be queried by calling
GetProgramivwithATTACHED SHADERS.
A string that contains information about the last compilation attempt on a
shader object or last link or validation attempt on a program object, called the
info log,canbeobtainedwiththecommands
void GetShaderInfoLog(uint shader,sizei bufSize,
sizei *length,char *infoLog);
void GetProgramInfoLog(uint program,sizei bufSize,
sizei *length,char *infoLog);
These commands return the info log string in infoLog. This string will be null
terminated. The actual number of characters written into infoLog, excluding the
nullterminator,isreturnedin length. If lengthisNULL,thennolengthisreturned.
The maximum number of characters that may be written into infoLog, including
the null terminator, is speci?ed by bufSize. The number of characters in the info
logcanbequeriedwithGetShaderivorGetProgramivwithINFO LOG LENGTH.
If shader is a shader object, the returned info log will either be an empty string
or it will contain information about the last compilation attempt for that object. If
programisaprogramobject,thereturnedinfologwilleitherbeanemptystringor
itwillcontaininformationaboutthelastlinkattemptorlastvalidationattemptfor
thatobject.
The info log is typically only useful during application development and an
application should not expect different GL implementations to produce identical
infologs.
Thecommand
void GetShaderSource(uint shader,sizei bufSize,
sizei *length,char *source);
returnsinsourcethestringmakingupthesourcecodefortheshaderobjectshader.
Thestring sourcewillbenullterminated. Theactualnumberofcharacterswritten
into source, excluding the null terminator, is returned in length. If length isNULL,
nolengthisreturned. Themaximumnumberofcharactersthatmaybewritteninto
source, including the null terminator, is speci?ed by bufSize. The string source is
a concatenation of the strings passed to the GL using ShaderSource. The length
of this concatenation is given bySHADER SOURCE LENGTH, which can be queried
withGetShaderiv.
Thecommands
Version2.1-December1,20066.1. QUERYINGGLSTATE 263
void GetVertexAttribdv(uint index,enum pname,
double *params);
void GetVertexAttribfv(uint index,enum pname,
float *params);
void GetVertexAttribiv(uint index,enum pname,
int *params);
obtain the vertex attribute state named by pname for the generic ver-
tex attribute numbered index and places the information in the array
params. pname must be one of VERTEX ATTRIB ARRAY BUFFER BINDING,
VERTEX ATTRIB ARRAY ENABLED, VERTEX ATTRIB ARRAY SIZE,
VERTEX ATTRIB ARRAY STRIDE, VERTEX ATTRIB ARRAY TYPE,
VERTEX ATTRIB ARRAY NORMALIZED, or CURRENT VERTEX ATTRIB. Note that
all the queries except CURRENT VERTEX ATTRIB return client state. The
error INVALID VALUE is generated if index is greater than or equal to
MAX VERTEX ATTRIBS.
AllbutCURRENT VERTEX ATTRIBreturninformationaboutgenericvertexat-
tribute arrays. The enable state of a generic vertex attribute array is set by the
commandEnableVertexAttribArrayandclearedbyDisableVertexAttribArray.
The size, stride, type and normalized ?ag are set by the command VertexAttrib-
Pointer. The query CURRENT VERTEX ATTRIB returns the current value for the
genericattribute index. InthiscasetheerrorINVALID OPERATIONisgeneratedif
indexiszero,asthereisnocurrentvalueforgenericattributezero.
Thecommand
void GetVertexAttribPointerv(uint index,enum pname,
void **pointer);
obtains the pointer named pname for vertex attribute numbered index
and places the information in the array pointer. pname must be
VERTEX ATTRIB ARRAY POINTER.TheINVALID VALUEerrorisgeneratedif in-
dexisgreaterthanorequaltoMAX VERTEX ATTRIBS.
Thecommands
void GetUniformfv(uint program,int location,
float *params);
void GetUniformiv(uint program,int location,
int *params);
return the value or values of the uniform at location location for program object
program in the array params. The type of the uniform at location determines the
Version2.1-December1,2006264 CHAPTER6. STATEANDSTATEREQUESTS
number of values returned. The error INVALID OPERATION is generated if pro-
gram has not been linked successfully, or if location is not a valid location for
program. In order to query the values of an array of uniforms, a GetUniform*
command needs to be issued for each array element. If the uniform queried is a
matrix, the values of the matrix are returned in column major order. If an error
occurred,thereturnparameter paramswillbeunmodi?ed.
6.1.15 SavingandRestoringState
Besides providing a means to obtain the values of state variables, the GL also
provides a means to save and restore groups of state variables. The PushAttrib,
PushClientAttrib, PopAttrib and PopClientAttrib commands are used for this
purpose. Thecommands
void PushAttrib(bitfield mask);
void PushClientAttrib(bitfield mask);
takeabitwiseORofsymbolicconstantsindicatingwhichgroupsofstatevariables
to push onto an attribute stack. PushAttrib uses a server attribute stack while
PushClientAttrib uses a client attribute stack. Each constant refers to a group
of state variables. The classi?cation of each variable into a group is indicated
in the following tables of state variables. The error STACK OVERFLOW is gener-
atedifPushAttriborPushClientAttribisexecutedwhilethecorrespondingstack
depth is MAX ATTRIB STACK DEPTH or MAX CLIENT ATTRIB STACK DEPTH re-
spectively. Bitssetinmaskthatdonotcorrespondtoanattributegroupareignored.
ThespecialmaskvaluesALL ATTRIB BITSandCLIENT ALL ATTRIB BITSmay
beusedtopushallstackableserverandclientstate,respectively.
Thecommands
void PopAttrib(void);
void PopClientAttrib(void);
resetthevaluesofthosestatevariablesthatweresavedwiththelastcorresponding
PushAttrib or PopClientAttrib. Those not saved remain unchanged. The er-
rorSTACK UNDERFLOWisgeneratedifPopAttriborPopClientAttribisexecuted
whiletherespectivestackisempty.
Table 6.2 shows the attribute groups with their corresponding symbolic con-
stantnamesandstacks.
When PushAttrib is called with TEXTURE BIT set, the priorities, border col-
ors,?ltermodes,wrapmodes,andotherstateofthecurrentlyboundtextureobjects
(seetable6.17),aswellasthecurrenttexturebindingsandenables,arepushedonto
Version2.1-December1,20066.1. QUERYINGGLSTATE 265
Stack Attribute Constant
server accum-buffer ACCUM BUFFER BIT
server color-buffer COLOR BUFFER BIT
server current CURRENT BIT
server depth-buffer DEPTH BUFFER BIT
server enable ENABLE BIT
server eval EVAL BIT
server fog FOG BIT
server hint HINT BIT
server lighting LIGHTING BIT
server line LINE BIT
server list LIST BIT
server multisample MULTISAMPLE BIT
server pixel PIXEL MODE BIT
server point POINT BIT
server polygon POLYGON BIT
server polygon-stipple POLYGON STIPPLE BIT
server scissor SCISSOR BIT
server stencil-buffer STENCIL BUFFER BIT
server texture TEXTURE BIT
server transform TRANSFORM BIT
server viewport VIEWPORT BIT
server ALL ATTRIB BITS
client vertex-array CLIENT VERTEX ARRAY BIT
client pixel-store CLIENT PIXEL STORE BIT
client select can’tbepushedorpop’d
client feedback can’tbepushedorpop’d
client CLIENT ALL ATTRIB BITS
Table6.2: Attributegroups
Version2.1-December1,2006266 CHAPTER6. STATEANDSTATEREQUESTS
theattributestack. (Unboundtextureobjectsarenotpushedorrestored.) Whenan
attribute set that includes texture information is popped, the bindings and enables
are?rstrestoredtotheirpushedvalues,thentheboundtextureobject’sparameters
arerestoredtotheirpushedvalues.
Operations on attribute groups push or pop texture state within that group for
all texture units. When state for a group is pushed, all state corresponding to
TEXTURE0 is pushed ?rst, followed by state corresponding to TEXTURE1, and so
on up to and including the state corresponding to TEXTUREk where k + 1 is the
value of MAX TEXTURE UNITS. When state for a group is popped, texture state is
restoredin theopposite orderthat itwas pushed, starting withstate corresponding
to TEXTUREk and ending with TEXTURE0. Identical rules are observed for client
texture state push and pop operations. Matrix stacks are never pushed or popped
withPushAttrib,PushClientAttrib,PopAttrib,orPopClientAttrib.
The depth of each attribute stack is implementation dependent but must be at
least16. Thestaterequiredforeachattributestackispotentially16copiesofeach
state variable, 16 masks indicating which groups of variables are stored in each
stack entry, and an attribute stack pointer. In the initial state, both attribute stacks
areempty.
In the tables that follow, a type is indicated for each variable. Table 6.3 ex-
plains these types. The type actually identi?es all state associated with the indi-
cated description; in certain cases only a portion of this state is returned. This
is the case with all matrices, where only the top entry on the stack is returned;
with clip planes, where only the selected clip plane is returned, with parameters
describing lights, where only the value pertaining to the selected light is returned;
withtextures,whereonlytheselectedtextureortextureparameterisreturned;and
withevaluatormaps,whereonlytheselectedmapisreturned. Finally,a“–”inthe
attribute column indicates that the indicated value is not included in any attribute
group(andthuscannotbepushedorpoppedwithPushAttrib,PushClientAttrib,
PopAttrib,orPopClientAttrib).
The M and m entries for initial minmax table values represent the maximum
andminimumpossiblerepresentablevalues,respectively.
6.2 StateTables
The tables on the following pages indicate which state variables are obtained with
what commands. State variables that can be obtained using any of GetBooleanv,
GetIntegerv, GetFloatv, or GetDoublev are listed with just one of these com-
mands – the one that is most appropriate given the type of the data to be returned.
These state variables cannot be obtained using IsEnabled. However, state vari-
Version2.1-December1,20066.2. STATETABLES 267
Typecode Explanation
B Boolean
BMU Basicmachineunits
C Color(?oating-pointR,G,B,andAvalues)
CI Colorindex(?oating-pointindexvalue)
T Texture coordinates (?oating-point s, t, r, q val-
ues)
N Normalcoordinates(?oating-point x,y,z values)
V Vertex,includingassociateddata
Z Integer
+
Z Non-negativeinteger
Z ,Z k-valuedinteger( k?indicatesk isminimum)
k k?
R Floating-pointnumber
+
R Non-negative?oating-pointnumber
[a,b]
R Floating-pointnumberintherange [a,b]
k
R k-tupleof?oating-pointnumbers
P Position(x,y,z,w ?oating-pointcoordinates)
D Direction(x,y,z ?oating-pointcoordinates)
4
M 4?4?oating-pointmatrix
S NULL-terminatedstring
I Image
A Attributestackentry,includingmask
Y Pointer(datatypeunspeci?ed)
n?type ncopiesoftypetype(n?indicatesnisminimum)
Table6.3: StateVariableTypes
Version2.1-December1,2006268 CHAPTER6. STATEANDSTATEREQUESTS
ables for which IsEnabled is listed as the query command can also be obtained
using GetBooleanv, GetIntegerv, GetFloatv, and GetDoublev. State variables
forwhichanyothercommandislistedasthequerycommandcanbeobtainedonly
byusingthatcommand.
State table entries which are required only by the imaging subset (see sec-
tion3.6.2)aretypeset againstagraybackground .
Version2.1-December1,20066.2. STATETABLES 269
6
Table6.4. GLInternalbegin-endstatevariables(inaccessible)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
– Z – 0 When= 0,indicatesbegin/end 2.6.1 –
11
object
– V – – PreviousvertexinBegin/Endline 2.6.1 –
– B – – Indicatesif line-vertex isthe?rst 2.6.1 –
– V – – FirstvertexofaBegin/Endline 2.6.1 –
loop
+
– Z – – Linestipplecounter 3.4 –
– n?V – – VerticesinsideofBegin/End 2.6.1 –
polygon
+
– Z – – Numberof polygon-vertices 2.6.1 –
– 2?V – – Previoustwoverticesina 2.6.1 –
Begin/Endtrianglestrip
– Z – – Numberofverticessofarin 2.6.1 –
3
trianglestrip: 0,1,ormore
– Z – – TrianglestripA/Bvertexpointer 2.6.1 –
2
– 3?V – – Verticesofthequadunder 2.6.1 –
construction
– Z – – Numberofverticessofarinquad 2.6.1 –
4
strip: 0,1,2,ormore270 CHAPTER6. STATEANDSTATEREQUESTS
- - -
Table6.5. CurrentValuesandAssociatedData
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
GetIntegerv,
CURRENT COLOR C GetFloatv 1,1,1,1 Currentcolor 2.7 current
GetIntegerv,
CURRENT SECONDARY COLOR C GetFloatv 0,0,0,1 Currentsecondarycolor 2.7 current
GetIntegerv,
CURRENT INDEX CI GetFloatv 1 Currentcolorindex 2.7 current
CURRENT TEXTURE COORDS 2??T GetFloatv 0,0,0,1 Currenttexturecoordinates 2.7 current
CURRENT NORMAL N GetFloatv 0,0,1 Currentnormal 2.7 current
GetIntegerv,
CURRENT FOG COORD R GetFloatv 0 Currentfogcoordinate 2.7 current
– C – Colorassociatedwithlastvertex 2.6 –
– CI – Colorindexassociatedwithlast 2.6 –
vertex
– T – Texturecoordinatesassociatedwith 2.6 –
lastvertex
4
CURRENT RASTER POSITION R GetFloatv 0,0,0,1 Currentrasterposition 2.13 current
+
CURRENT RASTER DISTANCE R GetFloatv 0 Currentrasterdistance 2.13 current
GetIntegerv,
CURRENT RASTER COLOR C GetFloatv 1,1,1,1 Colorassociatedwithraster 2.13 current
position
GetIntegerv,
CURRENT RASTER SECONDARY COLOR C GetFloatv 0,0,0,1 Secondarycolorassociatedwith 2.13 current
rasterposition
GetIntegerv,
CURRENT RASTER INDEX CI GetFloatv 1 Colorindexassociatedwithraster 2.13 current
position
CURRENT RASTER TEXTURE COORDS 2??T GetFloatv 0,0,0,1 Texturecoordinatesassociatedwith 2.13 current
rasterposition
CURRENT RASTER POSITION VALID B GetBooleanv True Rasterpositionvalidbit 2.13 current
EDGE FLAG B GetBooleanv True Edge?ag 2.6.2 current6.2. STATETABLES 271
Table6.6. VertexArrayData
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
CLIENT ACTIVE TEXTURE Z GetIntegerv TEXTURE0 Clientactivetextureunitselector 2.7 vertex-array
2?
VERTEX ARRAY B IsEnabled False Vertexarrayenable 2.8 vertex-array
+
VERTEX ARRAY SIZE Z GetIntegerv 4 Coordinatespervertex 2.8 vertex-array
VERTEX ARRAY TYPE Z GetIntegerv FLOAT Typeofvertexcoordinates 2.8 vertex-array
4
+
VERTEX ARRAY STRIDE Z GetIntegerv 0 Stridebetweenvertices 2.8 vertex-array
VERTEX ARRAY POINTER Y GetPointerv 0 Pointertothevertexarray 2.8 vertex-array
NORMAL ARRAY B IsEnabled False Normalarrayenable 2.8 vertex-array
NORMAL ARRAY TYPE Z GetIntegerv FLOAT Typeofnormalcoordinates 2.8 vertex-array
5
+
NORMAL ARRAY STRIDE Z GetIntegerv 0 Stridebetweennormals 2.8 vertex-array
NORMAL ARRAY POINTER Y GetPointerv 0 Pointertothenormalarray 2.8 vertex-array
FOG COORD ARRAY B IsEnabled False Fogcoordarrayenable 2.8 vertex-array
FOG COORD ARRAY TYPE Z GetIntegerv FLOAT Typeoffogcoordcomponents 2.8 vertex-array
2
+
FOG COORD ARRAY STRIDE Z GetIntegerv 0 Stridebetweenfogcoords 2.8 vertex-array
FOG COORD ARRAY POINTER Y GetPointerv 0 Pointertothefogcoordarray 2.8 vertex-array
COLOR ARRAY B IsEnabled False Colorarrayenable 2.8 vertex-array
+
COLOR ARRAY SIZE Z GetIntegerv 4 Colorcomponentspervertex 2.8 vertex-array
COLOR ARRAY TYPE Z GetIntegerv FLOAT Typeofcolorcomponents 2.8 vertex-array
8
+
COLOR ARRAY STRIDE Z GetIntegerv 0 Stridebetweencolors 2.8 vertex-array
COLOR ARRAY POINTER Y GetPointerv 0 Pointertothecolorarray 2.8 vertex-array
SECONDARY COLOR ARRAY B IsEnabled False Secondarycolorarrayenable 2.8 vertex-array
+
SECONDARY COLOR ARRAY SIZE Z GetIntegerv 3 Secondarycolorcomponentsper 2.8 vertex-array
vertex
SECONDARY COLOR ARRAY TYPE Z GetIntegerv FLOAT Typeofsecondarycolor 2.8 vertex-array
8
components
+
SECONDARY COLOR ARRAY STRIDE Z GetIntegerv 0 Stridebetweensecondarycolors 2.8 vertex-array
SECONDARY COLOR ARRAY POINTER Y GetPointerv 0 Pointertothesecondarycolorarray 2.8 vertex-array
INDEX ARRAY B IsEnabled False Indexarrayenable 2.8 vertex-array
INDEX ARRAY TYPE Z GetIntegerv FLOAT Typeofindices 2.8 vertex-array
4
+
INDEX ARRAY STRIDE Z GetIntegerv 0 Stridebetweenindices 2.8 vertex-array
INDEX ARRAY POINTER Y GetPointerv 0 Pointertotheindexarray 2.8 vertex-array272 CHAPTER6. STATEANDSTATEREQUESTS
Table6.7. VertexArrayData(cont.)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
TEXTURE COORD ARRAY 2??B IsEnabled False Texturecoordinatearray 2.8 vertex-array
enable
+
TEXTURE COORD ARRAY SIZE 2??Z GetIntegerv 4 Coordinatesperelement 2.8 vertex-array
TEXTURE COORD ARRAY TYPE 2??Z GetIntegerv FLOAT Typeoftexture 2.8 vertex-array
4
coordinates
+
TEXTURE COORD ARRAY STRIDE 2??Z GetIntegerv 0 Stridebetweentexture 2.8 vertex-array
coordinates
TEXTURE COORD ARRAY POINTER 2??Y GetPointerv 0 Pointertothetexture 2.8 vertex-array
coordinatearray
VERTEX ATTRIB ARRAY ENABLED 16+?B GetVertexAttrib False Vertexattribarrayenable 2.8 vertex-array
VERTEX ATTRIB ARRAY SIZE 16+?Z GetVertexAttrib 4 Vertexattribarraysize 2.8 vertex-array
+
VERTEX ATTRIB ARRAY STRIDE 16+?Z GetVertexAttrib 0 Vertexattribarraystride 2.8 vertex-array
VERTEX ATTRIB ARRAY TYPE 16+?Z GetVertexAttrib FLOAT Vertexattribarraytype 2.8 vertex-array
4
VERTEX ATTRIB ARRAY NORMALIZED 16+?B GetVertexAttrib False Vertexattribarray 2.8 vertex-array
normalized
VERTEX ATTRIB ARRAY POINTER 16+?P GetVertex- NULL Vertexattribarray 2.8 vertex-array
AttribPointer pointer
EDGE FLAG ARRAY B IsEnabled False Edge?agarrayenable 2.8 vertex-array
+
EDGE FLAG ARRAY STRIDE Z GetIntegerv 0 Stridebetweenedge 2.8 vertex-array
?ags
EDGE FLAG ARRAY POINTER Y GetPointerv 0 Pointertotheedge?ag 2.8 vertex-array
array6.2. STATETABLES 273
Table6.8. VertexArrayData(cont.)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
+
ARRAY BUFFER BINDING Z GetIntegerv 0 Currentbufferbinding 2.9 vertex-array
+
VERTEX ARRAY BUFFER BINDING Z GetIntegerv 0 Vertexarraybuffer 2.9 vertex-array
binding
+
NORMAL ARRAY BUFFER BINDING Z GetIntegerv 0 Normalarraybuffer 2.9 vertex-array
binding
+
COLOR ARRAY BUFFER BINDING Z GetIntegerv 0 Colorarraybuffer 2.9 vertex-array
binding
+
INDEX ARRAY BUFFER BINDING Z GetIntegerv 0 Indexarraybuffer 2.9 vertex-array
binding
+
TEXTURE COORD ARRAY BUFFER BINDING 2??Z GetIntegerv 0 Texcoordarraybuffer 2.9 vertex-array
binding
+
EDGE FLAG ARRAY BUFFER BINDING Z GetIntegerv 0 Edge?agarraybuffer 2.9 vertex-array
binding
+
SECONDARY COLOR ARRAY BUFFER BINDING Z GetIntegerv 0 Secondarycolorarray 2.9 vertex-array
bufferbinding
+
FOG COORD ARRAY BUFFER BINDING Z GetIntegerv 0 Fogcoordinatearray 2.9 vertex-array
bufferbinding
+
ELEMENT ARRAY BUFFER BINDING Z GetIntegerv 0 Elementarraybuffer 2.9.2 vertex-array
binding
+
VERTEX ATTRIB ARRAY BUFFER BINDING 16+xZ GetVertexAttribiv 0 Attributearraybuffer 2.9 vertex-array
binding274 CHAPTER6. STATEANDSTATEREQUESTS
- - - - - -
-
Table6.9. BufferObjectState
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
– n?BMU GetBufferSubData bufferdata 2.9
+
BUFFER SIZE n?Z GetBufferParameteriv 0 Bufferdatasize 2.9
9
BUFFER USAGE n?Z GetBufferParameteriv STATIC DRAW Bufferusagepattern 2.9
3
BUFFER ACCESS n?Z GetBufferParameteriv READ WRITE Bufferaccess?ag 2.9
BUFFER MAPPED n?B GetBufferParameteriv FALSE Buffermap?ag 2.9
BUFFER MAP POINTER n?Y GetBufferPointerv NULL Mappedbufferpointer 2.96.2. STATETABLES 275
Table6.10. Transformationstate
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
4
COLOR MATRIX 2??M GetFloatv Identity Colormatrixstack 3.6.3 –
(TRANSPOSE COLOR MATRIX)
4
MODELVIEW MATRIX 32??M GetFloatv Identity Model-viewmatrixstack 2.11.2 –
(TRANSPOSE MODELVIEW MATRIX)
4
PROJECTION MATRIX 2??M GetFloatv Identity Projectionmatrixstack 2.11.2 –
(TRANSPOSE PROJECTION MATRIX)
4
TEXTURE MATRIX 2??2??M GetFloatv Identity Texturematrixstack 2.11.2 –
(TRANSPOSE TEXTURE MATRIX)
VIEWPORT 4?Z GetIntegerv see2.11.1 Viewportorigin&extent 2.11.1 viewport
+
DEPTH RANGE 2?R GetFloatv 0,1 Depthrangenear&far 2.11.1 viewport
+
COLOR MATRIX STACK DEPTH Z GetIntegerv 1 Colormatrixstack 3.6.3 –
pointer
+
MODELVIEW STACK DEPTH Z GetIntegerv 1 Model-viewmatrixstack 2.11.2 –
pointer
+
PROJECTION STACK DEPTH Z GetIntegerv 1 Projectionmatrixstack 2.11.2 –
pointer
+
TEXTURE STACK DEPTH 2??Z GetIntegerv 1 Texturematrixstack 2.11.2 –
pointer
MATRIX MODE Z GetIntegerv MODELVIEW Currentmatrixmode 2.11.2 transform
4
NORMALIZE B IsEnabled False Currentnormal 2.11.3 transform/enable
normalizationon/off
RESCALE NORMAL B IsEnabled False Currentnormalrescaling 2.11.3 transform/enable
on/off
4
CLIP PLANEi 6??R GetClipPlane 0,0,0,0 Userclippingplane 2.12 transform
coef?cients
CLIP PLANEi 6??B IsEnabled False ithuserclippingplane 2.12 transform/enable
enabled276 CHAPTER6. STATEANDSTATEREQUESTS
Table6.11. Coloring
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
FOG COLOR C GetFloatv 0,0,0,0 Fogcolor 3.10 fog
FOG INDEX CI GetFloatv 0 Fogindex 3.10 fog
FOG DENSITY R GetFloatv 1.0 Exponentialfogdensity 3.10 fog
FOG START R GetFloatv 0.0 Linearfogstart 3.10 fog
FOG END R GetFloatv 1.0 Linearfogend 3.10 fog
FOG MODE Z GetIntegerv EXP Fogmode 3.10 fog
3
FOG B IsEnabled False Trueiffogenabled 3.10 fog/enable
FOG COORD SRC Z GetIntegerv FRAGMENT DEPTH Sourceofcoordinateforfog 3.10 fog
2
calculation
COLOR SUM B IsEnabled False Trueifcolorsumenabled 3.9 fog/enable
+
SHADE MODEL Z GetIntegerv SMOOTH ShadeModelsetting 2.14.7 lighting6.2. STATETABLES 277
Table6.12. Lighting(seealsotable2.10fordefaults)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
LIGHTING B IsEnabled False Trueiflightingis 2.14.1 lighting/enable
enabled
COLOR MATERIAL B IsEnabled False Trueifcolor 2.14.3 lighting/enable
trackingis
enabled
COLOR MATERIAL PARAMETER Z GetIntegerv AMBIENT AND DIFFUSE Material 2.14.3 lighting
5
properties
trackingcurrent
color
COLOR MATERIAL FACE Z GetIntegerv FRONT AND BACK Face(s)affected 2.14.3 lighting
3
bycolortracking
AMBIENT 2?C GetMaterialfv (0.2,0.2,0.2,1.0) Ambientmaterial 2.14.1 lighting
color
DIFFUSE 2?C GetMaterialfv (0.8,0.8,0.8,1.0) Diffusematerial 2.14.1 lighting
color
SPECULAR 2?C GetMaterialfv (0.0,0.0,0.0,1.0) Specularmaterial 2.14.1 lighting
color
EMISSION 2?C GetMaterialfv (0.0,0.0,0.0,1.0) Emissivemat. 2.14.1 lighting
color
SHININESS 2?R GetMaterialfv 0.0 Specular 2.14.1 lighting
exponentof
material
LIGHT MODEL AMBIENT C GetFloatv (0.2,0.2,0.2,1.0) Ambientscene 2.14.1 lighting
color
LIGHT MODEL LOCAL VIEWER B GetBooleanv False Viewerislocal 2.14.1 lighting
LIGHT MODEL TWO SIDE B GetBooleanv False Usetwo-sided 2.14.1 lighting
lighting
LIGHT MODEL COLOR CONTROL Z GetIntegerv SINGLE COLOR Colorcontrol 2.14.1 lighting
2278 CHAPTER6. STATEANDSTATEREQUESTS
Table6.13. Lighting(cont.)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
AMBIENT 8??C GetLightfv (0.0,0.0,0.0,1.0) Ambientintensityoflighti 2.14.1 lighting
DIFFUSE 8??C GetLightfv seetable2.10 Diffuseintensityoflighti 2.14.1 lighting
SPECULAR 8??C GetLightfv seetable2.10 Specularintensityoflighti 2.14.1 lighting
POSITION 8??P GetLightfv (0.0,0.0,1.0,0.0) Positionoflighti 2.14.1 lighting
+
CONSTANT ATTENUATION 8??R GetLightfv 1.0 Constantatten. factor 2.14.1 lighting
+
LINEAR ATTENUATION 8??R GetLightfv 0.0 Linearatten. factor 2.14.1 lighting
+
QUADRATIC ATTENUATION 8??R GetLightfv 0.0 Quadraticatten. factor 2.14.1 lighting
SPOT DIRECTION 8??D GetLightfv (0.0,0.0,-1.0) Spotlightdirectionoflighti 2.14.1 lighting
+
SPOT EXPONENT 8??R GetLightfv 0.0 Spotlightexponentoflighti 2.14.1 lighting
+
SPOT CUTOFF 8??R GetLightfv 180.0 Spot. angleoflighti 2.14.1 lighting
LIGHTi 8??B IsEnabled False Trueiflightienabled 2.14.1 lighting/enable
COLOR INDEXES 2?3?R GetMaterialfv 0,1,1 a ,d ,ands forcolorindex 2.14.1 lighting
m m m
lighting6.2. STATETABLES 279
Version2.1-December1,2006
Table6.14. Rasterization
Get Initial
Getvalue Type Command Value Description Sec. Attribute
+
POINT SIZE R GetFloatv 1.0 Pointsize 3.3 point
POINT SMOOTH B IsEnabled False Pointantialiasingon 3.3 point/enable
POINT SPRITE B IsEnabled False Pointspriteenable 3.3 point/enable
+
POINT SIZE MIN R GetFloatv 0.0 Attenuatedminimumpointsize 3.3 point
+ 1 1
POINT SIZE MAX R GetFloatv Attenuatedmaximumpointsize. 3.3 point
Max. oftheimpl. dependentmax.
aliasedandsmoothpointsizes.
+
POINT FADE THRESHOLD SIZE R GetFloatv 1.0 Thresholdforalphaattenuation 3.3 point
+
POINT DISTANCE ATTENUATION 3?R GetFloatv 1,0,0 Attenuationcoef?cients 3.3 point
POINT SPRITE COORD ORIGIN Z GetIntegerv UPPER LEFT Originorientationforpointsprites 3.3 point
2
+
LINE WIDTH R GetFloatv 1.0 Linewidth 3.4 line
LINE SMOOTH B IsEnabled False Lineantialiasingon 3.4 line/enable
+
LINE STIPPLE PATTERN Z GetIntegerv 1’s Linestipple 3.4.2 line
+
LINE STIPPLE REPEAT Z GetIntegerv 1 Linestipplerepeat 3.4.2 line
LINE STIPPLE B IsEnabled False Linestippleenable 3.4.2 line/enable
CULL FACE B IsEnabled False Polygoncullingenabled 3.5.1 polygon/enable
CULL FACE MODE Z GetIntegerv BACK Cullfront/backfacingpolygons 3.5.1 polygon
3
FRONT FACE Z GetIntegerv CCW PolygonfrontfaceCW/CCW 3.5.1 polygon
2
indicator
POLYGON SMOOTH B IsEnabled False Polygonantialiasingon 3.5 polygon/enable
POLYGON MODE 2?Z GetIntegerv FILL Polygonrasterizationmode(front 3.5.4 polygon
3
&back)
POLYGON OFFSET FACTOR R GetFloatv 0 Polygonoffsetfactor 3.5.5 polygon
POLYGON OFFSET UNITS R GetFloatv 0 Polygonoffsetunits 3.5.5 polygon
POLYGON OFFSET POINT B IsEnabled False PolygonoffsetenableforPOINT 3.5.5 polygon/enable
moderasterization
POLYGON OFFSET LINE B IsEnabled False PolygonoffsetenableforLINE 3.5.5 polygon/enable
moderasterization
POLYGON OFFSET FILL B IsEnabled False PolygonoffsetenableforFILL 3.5.5 polygon/enable
moderasterization
– I GetPolygonStipple 1’s Polygonstipple 3.5 polygon-stipple
POLYGON STIPPLE B IsEnabled False Polygonstippleenable 3.5.2 polygon/enable280 CHAPTER6. STATEANDSTATEREQUESTS
Table6.15. Multisampling
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
MULTISAMPLE B IsEnabled True Multisamplerasterization 3.2.1 multisample/enable
SAMPLE ALPHA TO COVERAGE B IsEnabled False Modifycoveragefromalpha 4.1.3 multisample/enable
SAMPLE ALPHA TO ONE B IsEnabled False Setalphatomaximum 4.1.3 multisample/enable
SAMPLE COVERAGE B IsEnabled False Masktomodifycoverage 4.1.3 multisample/enable
+
SAMPLE COVERAGE VALUE R GetFloatv 1 Coveragemaskvalue 4.1.3 multisample
SAMPLE COVERAGE INVERT B GetBooleanv False Invertcoveragemaskvalue 4.1.3 multisample6.2. STATETABLES 281
Table6.16. Textures(statepertextureunitandbindingpoint)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
TEXTURE xD 2??3?B IsEnabled False TrueifxDtexturingis 3.8.16 texture/enable
enabled;xis1,2,or3
TEXTURE CUBE MAP 2??B IsEnabled False Trueifcubemap 3.8.13 texture/enable
texturingisenabled
+
TEXTURE BINDING xD 2??3?Z GetIntegerv 0 Textureobjectboundto 3.8.12 texture
TEXTURE xD
+
TEXTURE BINDING CUBE MAP 2??Z GetIntegerv 0 Textureobjectboundto 3.8.11 texture
TEXTURE CUBE MAP
TEXTURE xD n?I GetTexImage see3.8 xDtextureimageat 3.8 –
l.o.d. i
TEXTURE CUBE MAP POSITIVE X n?I GetTexImage see3.8.1 +xfacecubemap 3.8.1 –
textureimageatl.o.d. i
TEXTURE CUBE MAP NEGATIVE X n?I GetTexImage see3.8.1 ?xfacecubemap 3.8.1 –
textureimageatl.o.d. i
TEXTURE CUBE MAP POSITIVE Y n?I GetTexImage see3.8.1 +y facecubemap 3.8.1 –
textureimageatl.o.d. i
TEXTURE CUBE MAP NEGATIVE Y n?I GetTexImage see3.8.1 ?y facecubemap 3.8.1 –
textureimageatl.o.d. i
TEXTURE CUBE MAP POSITIVE Z n?I GetTexImage see3.8.1 +z facecubemap 3.8.1 –
textureimageatl.o.d. i
TEXTURE CUBE MAP NEGATIVE Z n?I GetTexImage see3.8.1 ?z facecubemap 3.8.1 –
textureimageatl.o.d. i282 CHAPTER6. STATEANDSTATEREQUESTS
Table6.17. Textures(statepertextureobject)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
TEXTURE BORDER COLOR n?C GetTexParameter 0,0,0,0 Texturebordercolor 3.8 texture
TEXTURE MIN FILTER n?Z GetTexParameter see3.8 Texturemini?cation 3.8.8 texture
6
function
TEXTURE MAG FILTER n?Z GetTexParameter see3.8 Texturemagni?cation 3.8.9 texture
2
function
TEXTURE WRAP S n?Z GetTexParameter REPEAT Texcoordswrapmode 3.8.7 texture
5
TEXTURE WRAP T n?Z GetTexParameter REPEAT Texcoordtwrapmode 3.8.7 texture
5
(2D,3D,cubemap
texturesonly)
TEXTURE WRAP R n?Z GetTexParameter REPEAT Texcoordr wrapmode 3.8.7 texture
5
(3Dtexturesonly)
[0,1]
TEXTURE PRIORITY n?R GetTexParameterfv 1 Textureobjectpriority 3.8.12 texture
TEXTURE RESIDENT n?B GetTexParameteriv see3.8.12 Textureresidency 3.8.12 texture
TEXTURE MIN LOD n?R GetTexParameterfv -1000 Minimumlevelofdetail 3.8 texture
TEXTURE MAX LOD n?R GetTexParameterfv 1000 Maximumlevelofdetail 3.8 texture
+
TEXTURE BASE LEVEL n?Z GetTexParameterfv 0 Basetexturearray 3.8 texture
+
TEXTURE MAX LEVEL n?Z GetTexParameterfv 1000 Maximumtexturearray 3.8 texture
level
TEXTURE LOD BIAS n?R GetTexParameterfv 0.0 Texturelevelofdetail 3.8.8 texture
biasbias
texobj
DEPTH TEXTURE MODE n?Z GetTexParameteriv LUMINANCE Depthtexturemode 3.8.5 texture
3
TEXTURE COMPARE MODE n?Z GetTexParameteriv NONE Texturecomparison 3.8.14 texture
2
mode
TEXTURE COMPARE FUNC n?Z GetTexParameteriv LEQUAL Texturecomparison 3.8.14 texture
8
function
GENERATE MIPMAP n?B GetTexParameter FALSE Automaticmipmap 3.8.8 texture
generation6.2. STATETABLES 283
- -
Table6.18. Textures(statepertextureimage)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
+
TEXTURE WIDTH n?Z GetTexLevelParameter 0 textureimage’sspeci?ed 3.8 –
width
+
TEXTURE HEIGHT n?Z GetTexLevelParameter 0 2D/3Dtextureimage’s 3.8 –
speci?edheight
+
TEXTURE DEPTH n?Z GetTexLevelParameter 0 3Dtextureimage’s 3.8 –
speci?eddepth
+
TEXTURE BORDER n?Z GetTexLevelParameter 0 textureimage’sspeci?ed 3.8 –
borderwidth
TEXTURE INTERNAL FORMAT n?Z GetTexLevelParameter 1 textureimage’sinternal 3.8 –
60?
(TEXTURE COMPONENTS) imageformat
+
TEXTURE RED SIZE n?Z GetTexLevelParameter 0 textureimage’sred 3.8 –
resolution
+
TEXTURE GREEN SIZE n?Z GetTexLevelParameter 0 textureimage’sgreen 3.8 –
resolution
+
TEXTURE BLUE SIZE n?Z GetTexLevelParameter 0 textureimage’sblue 3.8 –
resolution
+
TEXTURE ALPHA SIZE n?Z GetTexLevelParameter 0 textureimage’salpha 3.8 –
resolution
+
TEXTURE LUMINANCE SIZE n?Z GetTexLevelParameter 0 textureimage’s 3.8 –
luminanceresolution
+
TEXTURE INTENSITY SIZE n?Z GetTexLevelParameter 0 textureimage’sintensity 3.8 –
resolution
+
TEXTURE DEPTH SIZE n?Z GetTexLevelParameter 0 textureimage’sdepth 3.8 –
resolution
TEXTURE COMPRESSED n?B GetTexLevelParameter False Trueiftextureimagehas 3.8.3
acompressedinternal
format
+
TEXTURE COMPRESSED IMAGE SIZE n?Z GetTexLevelParameter 0 size(inubytes)of 3.8.3
compressedtexture
image284 CHAPTER6. STATEANDSTATEREQUESTS
Table6.19. TextureEnvironmentandGeneration
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
COORD REPLACE 2??B GetTexEnviv False Coordinatereplacementenable 3.3 point
ACTIVE TEXTURE Z GetIntegerv TEXTURE0 Activetextureunitselector 2.7 texture
2?
TEXTURE ENV MODE 2??Z GetTexEnviv MODULATE Textureapplicationfunction 3.8.13 texture
6
TEXTURE ENV COLOR 2??C GetTexEnvfv 0,0,0,0 Textureenvironmentcolor 3.8.13 texture
TEXTURE LOD BIAS 2??R GetTexEnvfv 0.0 Texturelevelofdetailbias 3.8.8 texture
bias
texunit
TEXTURE GEN x 2??4?B IsEnabled False Texgenenabled(xisS,T,R,orQ) 2.11.4 texture/enable
4
EYE PLANE 2??4?R GetTexGenfv see2.11.4 Texgenplaneequationcoef?cients 2.11.4 texture
(forS,T,R,andQ)
4
OBJECT PLANE 2??4?R GetTexGenfv see2.11.4 Texgenobjectlinearcoef?cients 2.11.4 texture
(forS,T,R,andQ)
TEXTURE GEN MODE 2??4?Z GetTexGeniv EYE LINEAR Functionusedfortexgen(forS,T, 2.11.4 texture
5
R,andQ
COMBINE RGB 2??Z GetTexEnviv MODULATE RGBcombinerfunction 3.8.13 texture
8
COMBINE ALPHA 2??Z GetTexEnviv MODULATE Alphacombinerfunction 3.8.13 texture
6
SRC0 RGB 2??Z GetTexEnviv TEXTURE RGBsource0 3.8.13 texture
3
SRC1 RGB 2??Z GetTexEnviv PREVIOUS RGBsource1 3.8.13 texture
3
SRC2 RGB 2??Z GetTexEnviv CONSTANT RGBsource2 3.8.13 texture
3
SRC0 ALPHA 2??Z GetTexEnviv TEXTURE Alphasource0 3.8.13 texture
3
SRC1 ALPHA 2??Z GetTexEnviv PREVIOUS Alphasource1 3.8.13 texture
3
SRC2 ALPHA 2??Z GetTexEnviv CONSTANT Alphasource2 3.8.13 texture
3
OPERAND0 RGB 2??Z GetTexEnviv SRC COLOR RGBoperand0 3.8.13 texture
4
OPERAND1 RGB 2??Z GetTexEnviv SRC COLOR RGBoperand1 3.8.13 texture
4
OPERAND2 RGB 2??Z GetTexEnviv SRC ALPHA RGBoperand2 3.8.13 texture
4
OPERAND0 ALPHA 2??Z GetTexEnviv SRC ALPHA Alphaoperand0 3.8.13 texture
2
OPERAND1 ALPHA 2??Z GetTexEnviv SRC ALPHA Alphaoperand1 3.8.13 texture
2
OPERAND2 ALPHA 2??Z GetTexEnviv SRC ALPHA Alphaoperand2 3.8.13 texture
2
3
RGB SCALE 2??R GetTexEnvfv 1.0 RGBpost-combinerscaling 3.8.13 texture
3
ALPHA SCALE 2??R GetTexEnvfv 1.0 Alphapost-combinerscaling 3.8.13 texture6.2. STATETABLES 285
Table6.20. PixelOperations
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
SCISSOR TEST B IsEnabled False Scissoringenabled 4.1.2 scissor/enable
SCISSOR BOX 4?Z GetIntegerv see4.1.2 Scissorbox 4.1.2 scissor
ALPHA TEST B IsEnabled False Alphatestenabled 4.1.4 color-buffer/enable
ALPHA TEST FUNC Z GetIntegerv ALWAYS Alphatestfunction 4.1.4 color-buffer
8
+
ALPHA TEST REF R GetIntegerv 0 Alphatestreferencevalue 4.1.4 color-buffer
STENCIL TEST B IsEnabled False Stencilingenabled 4.1.5 stencil-buffer/enable
STENCIL FUNC Z GetIntegerv ALWAYS Frontstencilfunction 4.1.5 stencil-buffer
8
+
STENCIL VALUE MASK Z GetIntegerv 1’s Frontstencilmask 4.1.5 stencil-buffer
+
STENCIL REF Z GetIntegerv 0 Frontstencilreferencevalue 4.1.5 stencil-buffer
STENCIL FAIL Z GetIntegerv KEEP Frontstencilfailaction 4.1.5 stencil-buffer
8
STENCIL PASS DEPTH FAIL Z GetIntegerv KEEP Frontstencildepthbufferfailaction 4.1.5 stencil-buffer
8
STENCIL PASS DEPTH PASS Z GetIntegerv KEEP Frontstencildepthbufferpass 4.1.5 stencil-buffer
8
action
STENCIL BACK FUNC Z GetIntegerv ALWAYS Backstencilfunction 4.1.5 stencil-buffer
8
+
STENCIL BACK VALUE MASK Z GetIntegerv 1’s Backstencilmask 4.1.5 stencil-buffer
+
STENCIL BACK REF Z GetIntegerv 0 Backstencilreferencevalue 4.1.5 stencil-buffer
STENCIL BACK FAIL Z GetIntegerv KEEP Backstencilfailaction 4.1.5 stencil-buffer
8
STENCIL BACK PASS DEPTH FAIL Z GetIntegerv KEEP Backstencildepthbufferfailaction 4.1.5 stencil-buffer
8
STENCIL BACK PASS DEPTH PASS Z GetIntegerv KEEP Backstencildepthbufferpass 4.1.5 stencil-buffer
8
action
DEPTH TEST B IsEnabled False Depthbufferenabled 4.1.6 depth-buffer/enable
DEPTH FUNC Z GetIntegerv LESS Depthbuffertestfunction 4.1.6 depth-buffer
8286 CHAPTER6. STATEANDSTATEREQUESTS
Table6.21. PixelOperations(cont.)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
BLEND B IsEnabled False Blendingenabled 4.1.8 color-buffer/enable
BLEND SRC RGB(v1.3:BLEND SRC) Z GetIntegerv ONE BlendingsourceRGB 4.1.8 color-buffer
15
function
BLEND SRC ALPHA Z GetIntegerv ONE BlendingsourceA 4.1.8 color-buffer
15
function
BLEND DST RGB(v1.3:BLEND DST) Z GetIntegerv ZERO Blendingdest. RGB 4.1.8 color-buffer
14
function
BLEND DST ALPHA Z GetIntegerv ZERO Blendingdest. A 4.1.8 color-buffer
14
function
BLEND EQUATION RGB Z GetIntegerv FUNC ADD RGBblendingequation 4.1.8 color-buffer
5
(v1.5:BLEND EQUATION)
BLEND EQUATION ALPHA Z GetIntegerv FUNC ADD Alphablendingequation 4.1.8 color-buffer
5
BLEND COLOR C GetFloatv 0,0,0,0 Constantblendcolor 4.1.8 color-buffer
DITHER B IsEnabled True Ditheringenabled 4.1.9 color-buffer/enable
INDEX LOGIC OP(v1.0:LOGIC OP) B IsEnabled False Indexlogicopenabled 4.1.10 color-buffer/enable
COLOR LOGIC OP B IsEnabled False Colorlogicopenabled 4.1.10 color-buffer/enable
LOGIC OP MODE Z GetIntegerv COPY Logicopfunction 4.1.10 color-buffer
166.2. STATETABLES 287
Table6.22. FramebufferControl
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
+
DRAW BUFFERi 1 ?Z GetIntegerv see4.2.1 Drawbufferselectedforoutput 4.2.1 color-buffer
10?
colori
DRAW BUFFER Z GetIntegerv see4.2.1 Drawbufferselectedforoutput 4.2.1 color-buffer
10?
color0
+
INDEX WRITEMASK Z GetIntegerv 1’s Colorindexwritemask 4.2.2 color-buffer
COLOR WRITEMASK 4?B GetBooleanv True Colorwriteenables;R,G,B,orA 4.2.2 color-buffer
DEPTH WRITEMASK B GetBooleanv True Depthbufferenabledforwriting 4.2.2 depth-buffer
+
STENCIL WRITEMASK Z GetIntegerv 1’s Frontstencilbufferwritemask 4.2.2 stencil-buffer
+
STENCIL BACK WRITEMASK Z GetIntegerv 1’s Backstencilbufferwritemask 4.2.2 stencil-buffer
COLOR CLEAR VALUE C GetFloatv 0,0,0,0 Colorbufferclearvalue(RGBA 4.2.3 color-buffer
mode)
INDEX CLEAR VALUE CI GetFloatv 0 Colorbufferclearvalue(color 4.2.3 color-buffer
indexmode)
+
DEPTH CLEAR VALUE R GetIntegerv 1 Depthbufferclearvalue 4.2.3 depth-buffer
+
STENCIL CLEAR VALUE Z GetIntegerv 0 Stencilclearvalue 4.2.3 stencil-buffer
+
ACCUM CLEAR VALUE 4?R GetFloatv 0 Accumulationbufferclearvalue 4.2.3 accum-buffer288 CHAPTER6. STATEANDSTATEREQUESTS
Table6.23. Pixels
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
UNPACK SWAP BYTES B GetBooleanv False ValueofUNPACK SWAP BYTES 3.6.1 pixel-store
UNPACK LSB FIRST B GetBooleanv False ValueofUNPACK LSB FIRST 3.6.1 pixel-store
+
UNPACK IMAGE HEIGHT Z GetIntegerv 0 Valueof 3.6.1 pixel-store
UNPACK IMAGE HEIGHT
+
UNPACK SKIP IMAGES Z GetIntegerv 0 ValueofUNPACK SKIP IMAGES 3.6.1 pixel-store
+
UNPACK ROW LENGTH Z GetIntegerv 0 ValueofUNPACK ROW LENGTH 3.6.1 pixel-store
+
UNPACK SKIP ROWS Z GetIntegerv 0 ValueofUNPACK SKIP ROWS 3.6.1 pixel-store
+
UNPACK SKIP PIXELS Z GetIntegerv 0 ValueofUNPACK SKIP PIXELS 3.6.1 pixel-store
+
UNPACK ALIGNMENT Z GetIntegerv 4 ValueofUNPACK ALIGNMENT 3.6.1 pixel-store
PACK SWAP BYTES B GetBooleanv False ValueofPACK SWAP BYTES 4.3.2 pixel-store
PACK LSB FIRST B GetBooleanv False ValueofPACK LSB FIRST 4.3.2 pixel-store
+
PACK IMAGE HEIGHT Z GetIntegerv 0 ValueofPACK IMAGE HEIGHT 4.3.2 pixel-store
+
PACK SKIP IMAGES Z GetIntegerv 0 ValueofPACK SKIP IMAGES 4.3.2 pixel-store
+
PACK ROW LENGTH Z GetIntegerv 0 ValueofPACK ROW LENGTH 4.3.2 pixel-store
+
PACK SKIP ROWS Z GetIntegerv 0 ValueofPACK SKIP ROWS 4.3.2 pixel-store
+
PACK SKIP PIXELS Z GetIntegerv 0 ValueofPACK SKIP PIXELS 4.3.2 pixel-store
+
PACK ALIGNMENT Z GetIntegerv 4 ValueofPACK ALIGNMENT 4.3.2 pixel-store
+
PIXEL PACK BUFFER BINDING Z GetIntegerv 0 Pixelpackbufferbinding 4.3.2 pixel-store
+
PIXEL UNPACK BUFFER BINDING Z GetIntegerv 0 Pixelunpackbufferbinding 6.1.13 pixel-store
MAP COLOR B GetBooleanv False Trueifcolorsaremapped 3.6.3 pixel
MAP STENCIL B GetBooleanv False Trueifstencilvaluesaremapped 3.6.3 pixel
INDEX SHIFT Z GetIntegerv 0 ValueofINDEX SHIFT 3.6.3 pixel
INDEX OFFSET Z GetIntegerv 0 ValueofINDEX OFFSET 3.6.3 pixel
x SCALE R GetFloatv 1 Valueofx SCALE;xisRED, 3.6.3 pixel
GREEN,BLUE,ALPHA,orDEPTH
x BIAS R GetFloatv 0 Valueofx BIAS 3.6.3 pixel6.2. STATETABLES 289
Table6.24. Pixels(cont.)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
COLOR TABLE B IsEnabled False Trueifcolortable 3.6.3 pixel/enable
lookupisdone
POST CONVOLUTION COLOR TABLE B IsEnabled False Trueifpostconvolution 3.6.3 pixel/enable
colortablelookupis
done
POST COLOR MATRIX COLOR TABLE B IsEnabled False Trueifpostcolormatrix 3.6.3 pixel/enable
colortablelookupis
done
COLOR TABLE I GetColorTable empty Colortable 3.6.3 –
POST CONVOLUTION COLOR TABLE I GetColorTable empty Postconvolutioncolor 3.6.3 –
table
POST COLOR MATRIX COLOR TABLE I GetColorTable empty Postcolormatrixcolor 3.6.3 –
table
COLOR TABLE FORMAT 2?3?Z GetColorTable- RGBA Colortables’internal 3.6.3 –
42
Parameteriv imageformat
+
COLOR TABLE WIDTH 2?3?Z GetColorTable- 0 Colortables’speci?ed 3.6.3 –
Parameteriv width
+
COLOR TABLE x SIZE 6?2?3?Z GetColorTable- 0 Colortablecomponent 3.6.3 –
Parameteriv resolution;xisRED,
GREEN,BLUE,ALPHA,
LUMINANCE,or
INTENSITY
4
COLOR TABLE SCALE 3?R GetColorTable- 1,1,1,1 Scalefactorsappliedto 3.6.3 pixel
Parameterfv colortableentries
4
COLOR TABLE BIAS 3?R GetColorTable- 0,0,0,0 Biasfactorsappliedto 3.6.3 pixel
Parameterfv colortableentries290 CHAPTER6. STATEANDSTATEREQUESTS
Table6.25. Pixels(cont.)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
CONVOLUTION 1D B IsEnabled False Trueif1Dconvolutionis 3.6.3 pixel/enable
done
CONVOLUTION 2D B IsEnabled False Trueif2Dconvolutionis 3.6.3 pixel/enable
done
SEPARABLE 2D B IsEnabled False Trueifseparable2D 3.6.3 pixel/enable
convolutionisdone
CONVOLUTION xD 2?I GetConvolution- empty Convolution?lters;xis 3.6.3 –
Filter 1or2
SEPARABLE 2D 2?I GetSeparable- Fil- empty Separableconvolution 3.6.3 –
ter ?lter
CONVOLUTION BORDER COLOR 3?C GetConvolution- 0,0,0,0 Convolutionbordercolor 3.6.5 pixel
Parameterfv
CONVOLUTION BORDER MODE 3?Z GetConvolution- REDUCE Convolutionborder 3.6.5 pixel
4
Parameteriv mode
4
CONVOLUTION FILTER SCALE 3?R GetConvolution- 1,1,1,1 Scalefactorsappliedto 3.6.3 pixel
Parameterfv convolution?lterentries
4
CONVOLUTION FILTER BIAS 3?R GetConvolution- 0,0,0,0 Biasfactorsappliedto 3.6.3 pixel
Parameterfv convolution?lterentries
CONVOLUTION FORMAT 3?Z GetConvolution- RGBA Convolution?lter 3.6.5 –
42
Parameteriv internalformat
+
CONVOLUTION WIDTH 3?Z GetConvolution- 0 Convolution?lterwidth 3.6.5 –
Parameteriv
+
CONVOLUTION HEIGHT 2?Z GetConvolution- 0 Convolution?lterheight 3.6.5 –
Parameteriv6.2. STATETABLES 291
Table6.26. Pixels(cont.)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
POST CONVOLUTION x SCALE R GetFloatv 1 Componentscalefactors 3.6.3 pixel
afterconvolution;xis
RED,GREEN,BLUE,or
ALPHA
POST CONVOLUTION x BIAS R GetFloatv 0 Componentbiasfactors 3.6.3 pixel
afterconvolution
POST COLOR MATRIX x SCALE R GetFloatv 1 Componentscalefactors 3.6.3 pixel
aftercolormatrix
POST COLOR MATRIX x BIAS R GetFloatv 0 Componentbiasfactors 3.6.3 pixel
aftercolormatrix
HISTOGRAM B IsEnabled False Trueifhistogrammingis 3.6.3 pixel/enable
enabled
HISTOGRAM I GetHistogram empty Histogramtable 3.6.3 –
+
HISTOGRAM WIDTH 2?Z GetHistogram- 0 Histogramtablewidth 3.6.3 –
Parameteriv
HISTOGRAM FORMAT 2?Z GetHistogram- RGBA Histogramtableinternal 3.6.3 –
42
Parameteriv format
+
HISTOGRAM x SIZE 5?2?Z GetHistogram- 0 Histogramtable 3.6.3 –
Parameteriv componentresolution;x
isRED,GREEN,BLUE,
ALPHA,orLUMINANCE
HISTOGRAM SINK B GetHistogram- False Trueifhistogramming 3.6.3 –
Parameteriv consumespixelgroups292 CHAPTER6. STATEANDSTATEREQUESTS
Table6.27. Pixels(cont.)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
MINMAX B IsEnabled False Trueifminmaxis 3.6.3 pixel/enable
enabled
n
MINMAX R GetMinmax (M,M,M,M),(m,m,m,m) Minmaxtable 3.6.3 –
MINMAX FORMAT Z GetMinmax- RGBA Minmaxtableinternal 3.6.3 –
42
Parameteriv format
MINMAX SINK B GetMinmax- False Trueifminmax 3.6.3 –
Parameteriv consumespixelgroups
ZOOM X R GetFloatv 1.0 xzoomfactor 3.6.4 pixel
ZOOM Y R GetFloatv 1.0 y zoomfactor 3.6.4 pixel
x 8?32??R GetPixelMap 0’s RGBAPixelMap 3.6.3 –
translationtables;xisa
mapnamefromtable3.3
x 2?32??Z GetPixelMap 0’s IndexPixelMap 3.6.3 –
translationtables;xisa
mapnamefromtable3.3
+
x SIZE Z GetIntegerv 1 Sizeoftablex 3.6.3 –
READ BUFFER Z GetIntegerv see4.3.2 Readsourcebuffer 4.3.2 pixel
36.2. STATETABLES 293
Table6.28. Evaluators(GetMaptakesamapname)
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
ORDER 9?Z GetMapiv 1 1dmaporder 5.1 –
8?
ORDER 9?2?Z GetMapiv 1,1 2dmaporders 5.1 –
8?
n
COEFF 9?8??R GetMapfv see5.1 1dcontrolpoints 5.1 –
n
COEFF 9?8??8??R GetMapfv see5.1 2dcontrolpoints 5.1 –
DOMAIN 9?2?R GetMapfv see5.1 1ddomainendpoints 5.1 –
DOMAIN 9?4?R GetMapfv see5.1 2ddomainendpoints 5.1 –
MAP1 x 9?B IsEnabled False 1dmapenables: xismaptype 5.1 eval/enable
MAP2 x 9?B IsEnabled False 2dmapenables: xismaptype 5.1 eval/enable
MAP1 GRID DOMAIN 2?R GetFloatv 0,1 1dgridendpoints 5.1 eval
MAP2 GRID DOMAIN 4?R GetFloatv 0,1;0,1 2dgridendpoints 5.1 eval
+
MAP1 GRID SEGMENTS Z GetFloatv 1 1dgriddivisions 5.1 eval
+
MAP2 GRID SEGMENTS 2?Z GetFloatv 1,1 2dgriddivisions 5.1 eval
AUTO NORMAL B IsEnabled False Trueifautomaticnormalgeneration 5.1 eval/enable
enabled294 CHAPTER6. STATEANDSTATEREQUESTS
-
- -
Table6.29. ShaderObjectState
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
SHADER TYPE Z GetShaderiv Typeofshader(vertexorfragment) 2.15.1 –
2
DELETE STATUS B GetShaderiv False Shader?aggedfordeletion 2.15.1 –
COMPILE STATUS B GetShaderiv False Lastcompilesucceeded 2.15.1 –
0+?char GetShaderInfoLog emptystring Infologforshaderobjects 6.1.14 –
+
INFO LOG LENGTH Z GetShaderiv 0 Lengthofinfolog 6.1.14 –
0+?char GetShaderSource emptystring Sourcecodeforashader 2.15.1 –
+
SHADER SOURCE LENGTH Z GetShaderiv 0 Lengthofsourcecode 6.1.14 –6.2. STATETABLES 295
- - - - - - - - - -
Table6.30. ProgramObjectState
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
+
CURRENT PROGRAM Z GetIntegerv 0 Nameofcurrentprogramobject 2.15.2 –
DELETE STATUS B GetProgramiv False Programobjectdeleted 2.15.2 –
LINK STATUS B GetProgramiv False Lastlinkattemptsucceeded 2.15.2 –
VALIDATE STATUS B GetProgramiv False Lastvalidateattemptsucceeded 2.15.2 –
+
ATTACHED SHADERS Z GetProgramiv 0 Numberofattachedshaderobjects 6.1.14 –
0+?H GetAttachedShaders empty Shaderobjectsattached 6.1.14 –
0+?char GetProgramInfoLog empty Infologforprogramobject 6.1.14 –
+
INFO LOG LENGTH Z GetProgramiv 0 Lengthofinfolog 2.15.3 –
+
ACTIVE UNIFORMS Z GetProgramiv 0 Numberofactiveuniforms 2.15.3 –
0+?Z GetUniformLocation – Locationofactiveuniforms 6.1.14 –
+
0+?Z GetActiveUniform – Sizeofactiveuniform 2.15.3 –
+
0+?Z GetActiveUniform – Typeofactiveuniform 2.15.3 –
0+?char GetActiveUniform empty Nameofactiveuniform 2.15.3 –
+
ACTIVE UNIFORM MAX LENGTH Z GetProgramiv 0 Maximumactiveuniformname 6.1.14 –
length
512+?R GetUniform 0 Uniformvalue 2.15.3 –
+
ACTIVE ATTRIBUTES Z GetProgramiv 0 Numberofactiveattributes 2.15.3 –
0+?Z GetAttribLocation – Locationofactivegenericattribute 2.15.3 –
+
0+?Z GetActiveAttrib – Sizeofactiveattribute 2.15.3 –
+
0+?Z GetActiveAttrib – Typeofactiveattribute 2.15.3 –
0+?char GetActiveAttrib empty Nameofactiveattribute 2.15.3 –
+
ACTIVE ATTRIBUTES MAX LENGTH Z GetProgramiv 0 Maximumactiveattributename 6.1.14 –
length296 CHAPTER6. STATEANDSTATEREQUESTS
Table6.31. VertexShaderState
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
VERTEX PROGRAM TWO SIDE B IsEnabled False Two-sidedcolormode 2.14.1 enable
CURRENT VERTEX ATTRIB 16+?R4 GetVertexAttrib 0,0,0,1 Genericvertexattribute 2.7 current
VERTEX PROGRAM POINT SIZE B IsEnabled False Pointsizemode 3.3 enable6.2. STATETABLES 297
Table6.32. Hints
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
PERSPECTIVE CORRECTION HINT Z GetIntegerv DONT CARE Perspectivecorrectionhint 5.6 hint
3
POINT SMOOTH HINT Z GetIntegerv DONT CARE Pointsmoothhint 5.6 hint
3
LINE SMOOTH HINT Z GetIntegerv DONT CARE Linesmoothhint 5.6 hint
3
POLYGON SMOOTH HINT Z GetIntegerv DONT CARE Polygonsmoothhint 5.6 hint
3
FOG HINT Z GetIntegerv DONT CARE Foghint 5.6 hint
3
GENERATE MIPMAP HINT Z GetIntegerv DONT CARE Mipmapgenerationhint 5.6 hint
3
TEXTURE COMPRESSION HINT Z GetIntegerv DONT CARE Texturecompressionqualityhint 5.6 hint
3
FRAGMENT SHADER DERIVATIVE HINT Z GetIntegerv DONT CARE Fragmentshaderderivative 5.6 hint
3
accuracyhint298 CHAPTER6. STATEANDSTATEREQUESTS
Table6.33. ImplementationDependentValues
Version2.1-December1,2006
Get Minimum
Getvalue Type Command Value Description Sec. Attribute
+
MAX LIGHTS Z GetIntegerv 8 Maximumnumberoflights 2.14.1 –
+
MAX CLIP PLANES Z GetIntegerv 6 Maximumnumberofuserclipping 2.12 –
planes
+
MAX COLOR MATRIX STACK DEPTH Z GetIntegerv 2 Maximumcolormatrixstackdepth 3.6.3 –
+
MAX MODELVIEW STACK DEPTH Z GetIntegerv 32 Maximummodel-viewstackdepth 2.11.2 –
+
MAX PROJECTION STACK DEPTH Z GetIntegerv 2 Maximumprojectionmatrixstack 2.11.2 –
depth
+
MAX TEXTURE STACK DEPTH Z GetIntegerv 2 Maximumnumberdepthoftexture 2.11.2 –
matrixstack
+
SUBPIXEL BITS Z GetIntegerv 4 Numberofbitsofsubpixel 3 –
precisioninscreenx andy
w w
+
MAX 3D TEXTURE SIZE Z GetIntegerv 16 Maximum3Dtextureimage 3.8.1 –
dimension
+
MAX TEXTURE SIZE Z GetIntegerv 64 Maximum2D/1Dtextureimage 3.8.1 –
dimension
+
MAX TEXTURE LOD BIAS R GetFloatv 2.0 Maximumabsolutetexturelevelof 3.8.8 –
detailbias
+
MAX CUBE MAP TEXTURE SIZE Z GetIntegerv 16 Maximumcubemaptextureimage 3.8.1 –
dimension
+
MAX PIXEL MAP TABLE Z GetIntegerv 32 MaximumsizeofaPixelMap 3.6.3 –
translationtable
+
MAX NAME STACK DEPTH Z GetIntegerv 64 Maximumselectionnamestack 5.2 –
depth
+
MAX LIST NESTING Z GetIntegerv 64 Maximumdisplaylistcallnesting 5.4 –
+
MAX EVAL ORDER Z GetIntegerv 8 Maximumevaluatorpolynomial 5.1 –
order
+
MAX VIEWPORT DIMS 2?Z GetIntegerv see2.11.1 Maximumviewportdimensions 2.11.1 –6.2. STATETABLES 299
- -
Table6.34. ImplementationDependentValues(cont.)
Version2.1-December1,2006
Get Minimum
Getvalue Type Command Value Description Sec. Attribute
+
MAX ATTRIB STACK DEPTH Z GetIntegerv 16 Maximumdepthofthe 6 –
serverattributestack
+
MAX CLIENT ATTRIB STACK DEPTH Z GetIntegerv 16 Maximumdepthofthe 6 –
clientattributestack
+
– 3?Z 32 Max. sizeofacolortable 3.6.3 –
+
– Z 32 Max. sizeofthehistogram 3.6.3 –
table
+
AUX BUFFERS Z GetIntegerv 0 Numberofauxiliary 4.2.1 –
buffers
RGBA MODE B GetBooleanv – Trueifcolorbuffersstore 2.7 –
RGBA
INDEX MODE B GetBooleanv – Trueifcolorbuffersstore 2.7 –
indexes
DOUBLEBUFFER B GetBooleanv – Trueiffront&back 4.2.1 –
buffersexist
STEREO B GetBooleanv – Trueifleft&rightbuffers 6 –
exist
+
ALIASED POINT SIZE RANGE 2?R GetFloatv 1,1 Range(lotohi)ofaliased 3.3 –
pointsizes
+
SMOOTH POINT SIZE RANGE 2?R GetFloatv 1,1 Range(lotohi)of 3.3 –
(v1.1:POINT SIZE RANGE) antialiasedpointsizes
+
SMOOTH POINT SIZE GRANULARITY R GetFloatv – Antialiasedpointsize 3.3 –
(v1.1:POINT SIZE GRANULARITY) granularity
+
ALIASED LINE WIDTH RANGE 2?R GetFloatv 1,1 Range(lotohi)ofaliased 3.4 –
linewidths
+
SMOOTH LINE WIDTH RANGE 2?R GetFloatv 1,1 Range(lotohi)of 3.4 –
(v1.1:LINE WIDTH RANGE) antialiasedlinewidths
+
SMOOTH LINE WIDTH GRANULARITY R GetFloatv – Antialiasedlinewidth 3.4 –
(v1.1:LINE WIDTH GRANULARITY) granularity300 CHAPTER6. STATEANDSTATEREQUESTS
-
Table6.35. ImplementationDependentValues(cont.)
Version2.1-December1,2006
Get Minimum
Getvalue Type Command Value Description Sec. Attribute
+
MAX CONVOLUTION WIDTH 3?Z GetConvolution- 3 Maximumwidthof 4.3 –
Parameteriv convolution?lter
+
MAX CONVOLUTION HEIGHT 2?Z GetConvolution- 3 Maximumheightof 4.3 –
Parameteriv convolution?lter
+
MAX ELEMENTS INDICES Z GetIntegerv – Recommendedmax. 2.8 –
numberof
DrawRangeElements
indices
+
MAX ELEMENTS VERTICES Z GetIntegerv – Recommendedmax. 2.8 –
numberof
DrawRangeElements
vertices
+
SAMPLE BUFFERS Z GetIntegerv 0 Numberofmultisample 3.2.1 –
buffers
+
SAMPLES Z GetIntegerv 0 Coveragemasksize 3.2.1 –
COMPRESSED TEXTURE FORMATS 0?Z GetIntegerv Enumeratedcompressed 3.8.3 –
textureformats
NUM COMPRESSED TEXTURE FORMATS Z GetIntegerv 0 Numberofcompressed 3.8.3 –
textureformats
+
QUERY COUNTER BITS Z GetQueryiv see6.1.12 Occlusionquerycounter 6.1.12 –
bits
EXTENSIONS S GetString – Supportedextensions 6.1.11 –
RENDERER S GetString – Rendererstring 6.1.11 –
SHADING LANGUAGE VERSION S GetString – ShadingLanguage 6.1.11 –
versionsupported
VENDOR S GetString – Vendorstring 6.1.11 –
VERSION S GetString – OpenGLversion 6.1.11 –
supported6.2. STATETABLES 301
Table6.36. ImplementationDependentValues(cont.)
Version2.1-December1,2006
Get Minimum
Getvalue Type Command Value Description Sec. Attribute
+
MAX TEXTURE UNITS Z GetIntegerv 2 Numberof 2.6 –
?xed-functiontexture
units
+
MAX VERTEX ATTRIBS Z GetIntegerv 16 Numberofactivevertex 2.7 –
attributes
+
MAX VERTEX UNIFORM COMPONENTS Z GetIntegerv 512 Numberofwordsfor 2.15.3 –
vertexshaderuniform
variables
+
MAX VARYING FLOATS Z GetIntegerv 32 Numberof?oatsfor 2.15.3 –
varyingvariables
+
MAX COMBINED TEXTURE IMAGE UNITS Z GetIntegerv 2 Totalnumberoftexture 2.15.4 –
unitsaccessiblebythe
GL
+
MAX VERTEX TEXTURE IMAGE UNITS Z GetIntegerv 0 Numberoftextureimage 2.15.4 –
unitsaccessiblebya
vertexshader
+
MAX TEXTURE IMAGE UNITS Z GetIntegerv 2 Numberoftextureimage 2.15.4 –
unitsaccessibleby
fragmentprocessing
+
MAX TEXTURE COORDS Z GetIntegerv 2 Numberoftexture 2.7 –
coordinatesets
+
MAX FRAGMENT UNIFORM COMPONENTS Z GetIntegerv 64 Numberofwordsfor 3.11.1 –
frag. shaderuniform
variables
+
MAX DRAW BUFFERS Z GetIntegerv 1+ Maximumnumberof 4.2.1 –
activedrawbuffers302 CHAPTER6. STATEANDSTATEREQUESTS
- - - -
Table6.37. ImplementationDependentPixelDepths
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
+
x BITS Z GetIntegerv Numberofbitsinxcolorbuffer 4 –
component;xisoneofRED,
GREEN,BLUE,ALPHA,orINDEX
+
DEPTH BITS Z GetIntegerv Numberofdepthbufferplanes 4 –
+
STENCIL BITS Z GetIntegerv Numberofstencilplanes 4 –
+
ACCUM x BITS Z GetIntegerv Numberofbitsinxaccumulation 4 –
buffercomponent(xisRED,
GREEN,BLUE,orALPHA6.2. STATETABLES 303
Table6.38. Miscellaneous
Version2.1-December1,2006
Get Initial
Getvalue Type Command Value Description Sec. Attribute
+
LIST BASE Z GetIntegerv 0 SettingofListBase 5.4 list
+
LIST INDEX Z GetIntegerv 0 Numberofdisplaylistunder 5.4 –
construction;0ifnone
+
LIST MODE Z GetIntegerv 0 Modeofdisplaylistunder 5.4 –
construction;unde?nedifnone
– 16??A – empty Serverattributestack 6 –
+
ATTRIB STACK DEPTH Z GetIntegerv 0 Serverattributestackpointer 6 –
– 16??A – empty Clientattributestack 6 –
+
CLIENT ATTRIB STACK DEPTH Z GetIntegerv 0 Clientattributestackpointer 6 –
+
NAME STACK DEPTH Z GetIntegerv 0 Namestackdepth 5.2 –
RENDER MODE Z GetIntegerv RENDER RenderModesetting 5.2 –
3
SELECTION BUFFER POINTER Y GetPointerv 0 Selectionbufferpointer 5.2 select
+
SELECTION BUFFER SIZE Z GetIntegerv 0 Selectionbuffersize 5.2 select
FEEDBACK BUFFER POINTER Y GetPointerv 0 Feedbackbufferpointer 5.3 feedback
+
FEEDBACK BUFFER SIZE Z GetIntegerv 0 Feedbackbuffersize 5.3 feedback
FEEDBACK BUFFER TYPE Z GetIntegerv 2D Feedbacktype 5.3 feedback
5
– n?Z GetError 0 Currenterrorcode(s) 2.5 –
8
– n?B – False Trueifthereisacorresponding 2.5 –
error
B – False Occlusionqueryactive 4.1.7 –
+
CURRENT QUERY Z GetQueryiv 0 ActiveocclusionqueryID 4.1.7 –
+
Z – 0 Occlusionsamples-passedcount 4.1.7 –AppendixA
Invariance
TheOpenGLspeci?cationisnotpixelexact. Itthereforedoesnotguaranteeanex-
act match between images produced by different GL implementations. However,
the speci?cation does specify exact matches, in some cases, for images produced
by the same implementation. The purpose of this appendix is to identify and pro-
videjusti?cationforthosecasesthatrequireexactmatches.
A.1 Repeatability
TheobviousandmostfundamentalcaseisrepeatedissuanceofaseriesofGLcom-
mands. ForanygivenGLandframebufferstate vector,andforanyGLcommand,
theresultingGLandframebufferstatemustbeidenticalwheneverthecommandis
executedonthatinitialGLandframebufferstate.
One purpose of repeatability is avoidance of visual artifacts when a double-
buffered scene is redrawn. If rendering is not repeatable, swapping between two
buffers rendered with the same command sequence may result in visible changes
in the image. Such false motion is distracting to the viewer. Another reason for
repeatabilityistestability.
Repeatability, while important, is a weak requirement. Given only repeata-
bility as a requirement, two scenes rendered with one (small) polygon changed
in position might differ at every pixel. Such a difference, while within the law
of repeatability, is certainly not within its spirit. Additional invariance rules are
desirabletoensureusefuloperation.
304A.2. MULTI-PASSALGORITHMS 305
A.2 Multi-passAlgorithms
Invariance is necessary for a whole set of useful multi-pass algorithms. Such al-
gorithms render multiple times, each time with a different GL mode vector, to
eventually produce a result in the framebuffer. Examples of these algorithms in-
clude:
• “Erasing” a primitive from the framebuffer by redrawing it, either in a dif-
ferentcolororusingtheXORlogicaloperation.
• Usingstenciloperationstocomputecappingplanes.
Ontheotherhand,invariancerulescangreatlyincreasethecomplexityofhigh-
performanceimplementationsoftheGL.Eventheweakrepeatabilityrequirement
signi?cantly constrains a parallel implementation of the GL. Because GL imple-
mentations are required to implement ALL GL capabilities, not just a convenient
subset, those that utilize hardware acceleration are expected to alternate between
hardware and software modules based on the current GL mode vector. A strong
invariance requirement forces the behavior of the hardware and software modules
tobeidentical,somethingthatmaybeverydif?culttoachieve(forexample,ifthe
hardwaredoes?oating-pointoperationswithdifferentprecisionthanthesoftware).
What is desired is a compromise that results in many compliant, high-
performance implementations, and in many software vendors choosing to port to
OpenGL.
A.3 InvarianceRules
ForagiveninstantiationofanOpenGLrenderingcontext:
Rule1 ForanygivenGLandframebufferstatevector,andforanygivenGLcom-
mand, theresultingGLandframebufferstatemustbeidenticaleachtimethecom-
mand is executed on that initial GL and framebuffer state.
Rule2 Changes to the following state values have no side effects (the use of any
other state value is not affected by the change):
Required:
• Framebuffer contents (all bitplanes)
• The color buffers enabled for writing
• The values of matrices other than the top-of-stack matrices
Version2.1-December1,2006306 APPENDIXA. INVARIANCE
• Scissor parameters (other than enable)
• Writemasks (color, index, depth, stencil)
• Clear values (color, index, depth, stencil, accumulation)
? Current values (color, index, normal, texture coords, edge?ag)
? Current raster color, index and texture coordinates.
? Material properties (ambient, diffuse, specular, emission, shininess)
Stronglysuggested:
• Matrix mode
• Matrix stack depths
• Alpha test parameters (other than enable)
• Stencil parameters (other than enable)
• Depth test parameters (other than enable)
• Blend parameters (other than enable)
• Logical operation parameters (other than enable)
• Pixel storage and transfer state
• Evaluator state (except as it affects the vertex data generated by the
evaluators)
• Polygonoffsetparameters(otherthanenables,andexceptastheyaffect
the depth values of fragments)
Corollary1 Fragment generation is invariant with respect to the state values
marked with• in Rule 2.
Corollary2 Thewindowcoordinates(x,y,andz)ofgeneratedfragmentsarealso
invariant with respect to
Required:
• Current values (color, color index, normal, texture coords, edge?ag)
• Current raster color, color index, and texture coordinates
• Material properties (ambient, diffuse, specular, emission, shininess)
Rule3 The arithmetic of each per-fragment operation is invariant except with re-
spect to parameters that directly control it (the parameters that control the alpha
test, for instance, are the alpha test enable, the alpha test function, and the alpha
test reference value).
Version2.1-December1,2006A.4. WHATALLTHISMEANS 307
Corollary3 Images rendered into different color buffers sharing the same frame-
buffer, either simultaneously or separately using the same command sequence, are
pixel identical.
Rule4 The same vertex or fragment shader will produce the same result when
run multiple times with the same input. The wording ’the same shader’ means a
programobjectthatispopulatedwiththesamesourcestrings,whicharecompiled
andthenlinked,possiblymultipletimes,andwhichprogramobjectisthenexecuted
using the same GL state vector.
Rule5 All fragment shaders that either conditionally or unconditionally assign
gl FragCoord.z to gl FragDepth are depth-invariant with respect to each
other, for those fragments where the assignment to gl FragDepth actually is
done.
A.4 WhatAllThisMeans
HardwareacceleratedGLimplementationsareexpectedtodefaulttosoftwareop-
eration when some GL state vectors are encountered. Even the weak repeatability
requirementmeans,forexample,thatOpenGLimplementationscannotapplyhys-
teresis to this swap, but must instead guarantee that a given mode vector implies
that a subsequent command always is executed in either the hardware or the soft-
waremachine.
Thestrongerinvariancerulesconstrainwhentheswitchfromhardwaretosoft-
ware rendering can occur, given that the software and hardware renderers are not
pixel identical. For example, the switch can be made when blending is enabled or
disabled,butitshouldnotbemadewhenachangeismadetotheblendingparam-
eters.
Because?oatingpointvaluesmayberepresentedusingdifferentformatsindif-
ferent renderers (hardware and software), many OpenGL state values may change
subtlywhenrenderersareswapped. ThisisthetypeofstatevaluechangethatRule
1seekstoavoid.
Version2.1-December1,2006AppendixB
Corollaries
Thefollowingobservationsarederivedfromthebodyandtheotherappendixesof
the speci?cation. Absence of an observation from this list in no way impugns its
veracity.
1. The CURRENT RASTER TEXTURE COORDS must be maintained correctly at
alltimes,includingperiodswhiletexturemappingisnotenabled,andwhen
theGLisincolorindexmode.
2. When requested, texture coordinates returned in feedback mode are always
valid,includingperiodswhiletexturemappingisnotenabled,andwhenthe
GLisincolorindexmode.
3. The error semantics of upward compatible OpenGL revisions may change.
Otherwise,onlyadditionscanbemadetoupwardcompatiblerevisions.
4. GL query commands are not required to satisfy the semantics of the Flush
ortheFinishcommands. Allthatisrequiredisthatthequeriedstatebecon-
sistentwithcompleteexecutionofallpreviouslyexecutedGLcommands.
5. Applicationspeci?edpointsizeandlinewidthmustbereturnedasspeci?ed
when queried. Implementation dependent clamping affects the values only
whiletheyareinuse.
6. Bitmapsandpixeltransfersdonotcauseselectionhits.
7. Themaskspeci?edasthethirdargumenttoStencilFuncaffectstheoperands
of the stencil comparison function, but has no direct effect on the update of
the stencil buffer. The mask speci?ed by StencilMask has no effect on the
stencil comparison function; it limits the effect of the update of the stencil
buffer.
308309
8. Polygonshadingiscompletedbeforethepolygonmodeisinterpreted. Ifthe
shademodelisFLAT,allofthepointsorlinesgeneratedbyasinglepolygon
willhavethesamecolor.
9. Adisplaylistisjustagroupofcommandsandarguments,soerrorsgenerated
by commands in a display list must be generated when the list is executed.
IfthelistiscreatedinCOMPILEmode,errorsshouldnotbegeneratedwhile
thelistisbeingcreated.
10. RasterPos does not change the current raster index from its default value
in an RGBA mode GL context. Likewise, RasterPos does not change the
current raster color from its default value in a color index GL context. Both
thecurrentrasterindexandthecurrentrastercolorcanbequeried,however,
regardlessofthecolormodeoftheGLcontext.
11. A material property that is attached to the current color via ColorMaterial
alwaystakesthevalueofthecurrentcolor. Attemptstochangethatmaterial
propertyviaMaterialcallshavenoeffect.
12. Material and ColorMaterial can be used to modify the RGBA material
properties,eveninacolorindexcontext. Likewise,Materialcanbeusedto
modifythecolorindexmaterialproperties,eveninanRGBAcontext.
13. There is no atomicity requirement for OpenGL rendering commands, even
atthefragmentlevel.
14. Because rasterization of non-antialiased polygons is point sampled, poly-
gons that have no area generate no fragments when they are rasterized in
FILL mode, and the fragments generated by the rasterization of “narrow”
polygonsmaynotformacontinuousarray.
15. OpenGL does not force left- or right-handedness on any of its coordinates
systems. Consider,however,thefollowingconditions: (1)theobjectcoordi-
nate system is right-handed; (2) the only commands used to manipulate the
model-viewmatrixare Scale(withpositivescalingvaluesonly),Rotate,and
Translate;(3)exactlyoneofeitherFrustumorOrthoisusedtosetthepro-
jection matrix; (4) the near value is less than the far value forDepthRange.
If these conditions are all satis?ed, then the eye coordinate system is right-
handedandtheclip,normalizeddevice,andwindowcoordinatesystemsare
left-handed.
16. ColorMaterialhasnoeffectoncolorindexlighting.
Version2.1-December1,2006310 APPENDIXB. COROLLARIES
17. (No pixel dropouts or duplicates.) Let two polygons share an identical edge
(thatis,thereexistverticesAandBofanedgeofonepolygon,andvertices
C and D of an edge of the other polygon, and the coordinates of vertex A
(resp. B)areidenticaltothoseofvertexC(resp. D),andthestateofthethe
coordinate transfomations is identical when A, B, C, and D are speci?ed).
Then, when the fragments produced by rasterization of both polygons are
taken together, each fragment intersecting the interior of the shared edge is
producedexactlyonce.
18. OpenGL state continues to be modi?ed in FEEDBACK mode and in SELECT
mode. Thecontentsoftheframebufferarenotmodi?ed.
19. The current raster position, the user de?ned clip planes, the spot directions
and the light positions for LIGHTi, and the eye planes for texgen are trans-
formed when they are speci?ed. They are not transformed during a PopAt-
trib,orwhencopyingacontext.
20. Dithering algorithms may be different for different components. In particu-
lar,alphamaybedithereddifferentlyfromred,green,orblue,andanimple-
mentationmaychoosetonotditheralphaatall.
21. For any GL and framebuffer state, and for any group of GL commands and
arguments, the resulting GL and framebuffer state is identical whether the
GLcommandsandargumentsareexecutednormallyorfromadisplaylist.
Version2.1-December1,2006AppendixC
Version1.1
OpenGLversion1.1isthe?rstrevisionsincetheoriginalversion1.0wasreleased
on 1 July 1992. Version 1.1 is upward compatible with version 1.0, meaning that
anyprogramthatrunswitha1.0GLimplementationwillalsorununchangedwith
a 1.1 GL implementation. Several additions were made to the GL, especially to
thetexturemappingcapabilities,butalsotothegeometryandfragmentoperations.
Followingarebriefdescriptionsofeachaddition.
C.1 VertexArray
Arrays of vertex data may be transferred to the GL with many fewer commands
than were previously necessary. Six arrays are de?ned, one each storing vertex
positions, normal coordinates, colors, color indices, texture coordinates, and edge
?ags. The arrays may be speci?ed and enabled independently, or one of the pre-
de?nedcon?gurationsmaybeselectedwithasinglecommand.
The primary goal was to decrease the number of subroutine calls required
to transfer non-display listed geometry data to the GL. A secondary goal was to
improve the ef?ciency of the transfer; especially to allow direct memory access
(DMA) hardware to be used to effect the transfer. The additions match those of
the GL EXT vertex array extension, except that static array data are not sup-
ported (because they complicated the interface, and were not being used), and the
pre-de?nedcon?gurationsareadded(bothtoreducesubroutinecountevenfurther,
andtoallowforef?cienttransferofarraydata).
311312 APPENDIXC. VERSION1.1
C.2 PolygonOffset
Depth values of fragments generated by the rasterization of a polygon may be
shifted toward or away from the origin, as an af?ne function of the window coor-
dinate depth slope of the polygon. Shifted depth values allow coplanar geometry,
especially facet outlines, to be rendered without depth buffer artifacts. They may
alsobeusedbyfutureshadowgenerationalgorithms.
The additions match those of the GL EXT polygon offset extension, with
two exceptions. First, the offset is enabled separately forPOINT,LINE, andFILL
rasterization modes, all sharing a single af?ne function de?nition. (Shifting the
depthvaluesoftheoutlinefragments,insteadofthe?llfragments,allowsthecon-
tents of the depth buffer to be maintained correctly.) Second, the offset bias is
speci?edinunitsofdepthbufferresolution,ratherthaninthe[0,1]depthrange.
C.3 LogicalOperation
Fragments generated by RGBA rendering may be merged into the framebuffer
using a logical operation, just as color index fragments are in GL version 1.0.
Blending is disabled during such operation because it is rarely desired, be-
cause many systems could not support it, and to match the semantics of the
GL EXT blend logic opextension,onwhichthisadditionislooselybased.
C.4 TextureImageFormats
Stored texture arrays have a format, known as the internal format, rather than a
simple count of components. The internal format is represented as a single enu-
merated value, indicating both the organization of the image data (LUMINANCE,
RGB, etc.) and the number of bits of storage for each image component. Clients
can use the internal format speci?cation to suggest the desired storage precision
of texture images. New base internal formats, ALPHA and INTENSITY, provide
new texture environment operations. These additions match those of a subset of
theGL EXT textureextension.
C.5 TextureReplaceEnvironment
A common use of texture mapping is to replace the color values of generated
fragments with texture color data. This could be speci?ed only indirectly in GL
version 1.0, which required that client speci?ed “white” geometry be modulated
Version2.1-December1,2006C.6. TEXTUREPROXIES 313
by a texture. GL version 1.1 allows such replacement to be speci?ed explicitly,
possibly improving performance. These additions match those of a subset of the
GL EXT textureextension.
C.6 TextureProxies
Texture proxies allow a GL implementation to advertise different maximum tex-
ture image sizes as a function of some other texture parameters, especially of the
internal image format. Clients may use the proxy query mechanism to tailor their
useoftextureresourcesatruntime. Theproxyinterfaceisdesignedtoallowsuch
queries without adding new routines to the GL interface. These additions match
those of a subset of the GL EXT texture extension, except that implementations
returnallocationinformationconsistentwithsupportforcompletemipmaparrays.
C.7 CopyTextureandSubtexture
Texture array data can be speci?ed from framebuffer memory, as well as from
clientmemory,andrectangularsubregionsoftexturearrayscanberede?nedeither
from client or framebuffer memory. These additions match those de?ned by the
GL EXT copy textureandGL EXT subtextureextensions.
C.8 TextureObjects
A set of texture arrays and their related texture state can be treated as a single
object. Such treatment allows for greater implementation ef?ciency when multi-
ple arrays are used. In conjunction with the subtexture capability, it also allows
clients to make gradual changes to existing texture arrays, rather than completely
rede?ning them. These additions match those of the GL EXT texture object
extension,withslightadditionstothetextureresidencysemantics.
C.9 OtherChanges
1. Colorindicesmaynowbespeci?edasunsignedbytes.
2. Texture coordinates s, t, and r are divided by q during the rasterization of
points, pixel rectangles, and bitmaps. This division was documented only
forlinesandpolygonsinthe1.0version.
Version2.1-December1,2006314 APPENDIXC. VERSION1.1
3. The line rasterization algorithm was changed so that vertical lines on pixel
bordersrasterizecorrectly.
4. Separatepixeltransferdiscussionsinchapter3andchapter4werecombined
intoasinglediscussioninchapter3.
5. Texture alpha values are returned as 1.0 if there is no alpha channel in the
texture array. This behavior was unspeci?ed in the 1.0 version, and was
incorrectlydocumentedinthereferencemanual.
6. Fogstartandendvaluesmaynowbenegative.
7. Evaluated color values direct the evaluation of the lighting equation if Col-
orMaterialisenabled.
C.10 Acknowledgements
OpenGL1.1istheresultofthecontributionsofmanypeople,representingacross
section of the computer industry. Following is a partial list of the contributors,
includingthecompanythattheyrepresentedatthetimeoftheircontribution:
KurtAkeley,SiliconGraphics
BillArmstrong,Evans&Sutherland
AndyBigos,3Dlabs
PatBrown,IBM
JimCobb,Evans&Sutherland
DickCoulter,DigitalEquipment
BruceD’Amora,GEMedicalSystems
JohnDennis,DigitalEquipment
FredFisher,AccelGraphics
ChrisFrazier,SiliconGraphics
ToddFrazier,Evans&Sutherland
TimFreese,NCD
KenGarnett,NCD
MikeHeck,TemplateGraphicsSoftware
DaveHiggins,IBM
PhilHuxley,3Dlabs
DaleKirkland,Intergraph
HockSanLee,Microsoft
KevinLeFebvre,HewlettPackard
JimMiller,IBM
TimMisner,SunSoft
Version2.1-December1,2006C.10. ACKNOWLEDGEMENTS 315
JeremyMorris,3Dlabs
IsraelPinkas,Intel
BimalPoddar,IBM
LyleRamshaw,DigitalEquipment
RandiRost,HewlettPackard
JohnSchimpf,SiliconGraphics
MarkSegal,SiliconGraphics
IgorSinyak,Intel
JeffStevenson,HewlettPackard
BillSweeney,SunSoft
KelvinThompson,PortableGraphics
NeilTrevett,3Dlabs
LinasVepstas,IBM
AndyVesper,DigitalEquipment
HenriWarren,Megatek
PaulaWomack,SiliconGraphics
MasonWoo,SiliconGraphics
SteveWright,Microsoft
Version2.1-December1,2006AppendixD
Version1.2
OpenGL version 1.2, released on March 16, 1998, is the second revision since the
original version 1.0. Version 1.2 is upward compatible with version 1.1, meaning
that any program that runs with a 1.1 GL implementation will also run unchanged
witha1.2GLimplementation.
Several additions were made to the GL, especially to texture mapping capa-
bilities and the pixel processing pipeline. Following are brief descriptions of each
addition.
D.1 Three-DimensionalTexturing
Three-dimensionaltexturescanbede?nedandused. In-memoryformatsforthree-
dimensional images, and pixel storage modes to support them, are also de?ned.
TheadditionsmatchthoseoftheGL EXT texture3Dextension.
One important application of three-dimensional textures is rendering volumes
ofimagedata.
D.2 BGRAPixelFormats
BGRA extends the list of client memory color formats. Speci?cally, it provides
a component order matching ?le and framebuffer formats common on Windows
platforms. TheadditionsmatchthoseoftheGL EXT bgraextension.
316D.3. PACKEDPIXELFORMATS 317
D.3 PackedPixelFormats
Packed pixels in client memory are represented entirely by one unsigned byte,
one unsigned short, or one unsigned integer. The ?elds with the packed pixel are
notpropermachinetypes,butthepixelasawholeis. Thusthepixelstoragemodes
andtheirunpackingcounterpartsallworkcorrectlywithpackedpixels.
TheadditionsmatchthoseoftheGL EXT packed pixelsextension,withthe
furtheradditionofreversedcomponentorderpackedformats.
D.4 NormalRescaling
Normalsmayberescaledbyaconstantfactorderivedfromthemodel-viewmatrix.
Rescalingcanoperatefasterthanrenormalizationinmanycases,whileresultingin
thesameunitnormals.
TheadditionsarebasedontheGL EXT rescale normalextension.
D.5 SeparateSpecularColor
Lighting calculations are modi?ed to produce a primary color consisting of emis-
sive,ambientanddiffusetermsoftheusualGLlightingequation,andasecondary
color consisting of the specular term. Only the primary color is modi?ed by the
textureenvironment;thesecondarycolorisaddedtotheresultoftexturingtopro-
duce a single post-texturing color. This allows highlights whose color is based on
thelightsourcecreatingthem,ratherthansurfaceproperties.
TheadditionsmatchthoseoftheGL EXT separate specular colorexten-
sion.
D.6 TextureCoordinateEdgeClamping
GL normally clamps such that the texture coordinates are limited to exactly the
range[0,1]. Whenatexturecoordinateisclampedusingthisalgorithm,thetexture
sampling?lterstraddlestheedgeofthetextureimage,takinghalfitssamplevalues
from within the texture image, and the other half from the texture border. It is
sometimes desirable to clamp a texture without requiring a border, and without
usingtheconstantbordercolor.
A new texture clamping algorithm, CLAMP TO EDGE, clamps texture coordi-
nates at all mipmap levels such that the texture ?lter never samples a border texel.
The color returned when clamping is derived only from texels at the edge of the
textureimage.
Version2.1-December1,2006318 APPENDIXD. VERSION1.2
TheadditionsmatchthoseoftheGL SGIS texture edge clampextension.
D.7 TextureLevelofDetailControl
Two constraints related to the texture level of detail parameter ? are added. One
constraint clamps ? to a speci?ed ?oating point range. The other limits the se-
lection of mipmap image arrays to a subset of the arrays that would otherwise be
considered.
Together these constraints allow a large texture to be loaded and used initially
at low resolution, and to have its resolution raised gradually as more resolution is
desired or available. Image array speci?cation is necessarily integral, rather than
continuous. By providing separate, continuous clamping of the ? parameter, it is
possibletoavoid”popping”artifactswhenhigherresolutionimagesareprovided.
TheadditionsmatchthoseoftheGL SGIS texture lodextension.
D.8 VertexArrayDrawElementRange
A new form of DrawElements that provides explicit information on the range of
verticesreferredtobytheindexsetisadded. Implementationscantakeadvantage
of this additional information to process vertex data without having to scan the
indexdatatodeterminewhichverticesarereferenced.
TheadditionsmatchthoseoftheGL EXT draw range elementsextension.
D.9 ImagingSubset
Theremainingnewfeaturesareprimarilyintendedforadvancedimageprocessing
applications, and may not be present in all GL implementations. The are collec-
tivelyreferredtoasthe imaging subset.
D.9.1 ColorTables
AnewRGBA-formatcolorlookupmechanismisde?nedinthepixeltransferpro-
cess,providingadditionallookupcapabilitiesbeyondtheexistinglookup. Thekey
differenceisthatthenewlookuptablesaretreatedasone-dimensionalimageswith
internal formats, like texture images and convolution ?lter images. Thus the new
tables can operate on a subset of the components of passing pixel groups. For ex-
ample,atablewithinternalformatALPHAmodi?esonlytheAcomponentofeach
pixelgroup,leavingtheR,G,andBcomponentsunmodi?ed.
Version2.1-December1,2006D.9. IMAGINGSUBSET 319
Threeindependentlookupsmaybeperformed: priortoconvolution;aftercon-
volutionandpriortocolormatrixtransformation;aftercolormatrixtransformation
andpriortogatheringpipelinestatistics.
Methods to initialize the color lookup tables from the framebuffer, in addition
tothestandardmemorysourcemechanisms,areprovided.
Portions of a color lookup table may be rede?ned without reinitializing the
entiretable. Theaffectedportionsmaybespeci?edeitherfromclientmemory or
fromtheframebuffer.
The additions match those of the GL EXT color table and
GL EXT color subtableextensions.
D.9.2 Convolution
One- or two-dimensional convolution operations are executed following the ?rst
colortablelookupinthepixeltransferprocess. Theconvolutionkernelsarethem-
selves treated as one- and two-dimensional images, which can be loaded from ap-
plicationmemoryorfromtheframebuffer.
The convolution framework is designed to accommodate three-dimensional
convolution,butthatAPIisleftforafutureextension.
The additions match those of the GL EXT convolution and
GL HP convolution border modesextensions.
D.9.3 ColorMatrix
A 4x4 matrix transformation and associated matrix stack are added to the pixel
transferpath. ThematrixoperatesonRGBApixelgroups,usingtheequation
0
C =MC,
where
? ?
R
? ?
G
? ?
C =
? ?
B
A
and M is the 4? 4 matrix on the top of the color matrix stack. After the
matrix multiplication, each resulting color component is scaled and biased by a
programmedamount. Colormatrixmultiplicationfollowsconvolution.
The color matrix can be used to reassign and duplicate color components. It
canalsobeusedtoimplementsimplecolorspaceconversions.
TheadditionsmatchthoseoftheGL SGI color matrixextension.
Version2.1-December1,2006320 APPENDIXD. VERSION1.2
D.9.4 PixelPipelineStatistics
Pixel operations that count occurences of speci?c color component values (his-
togram) and that track the minimum and maximum color component values (min-
max) are performed at the end of the pixel transfer pipeline. An optional mode
allowspixeldatatobediscardedafterthehistogramand/orminmaxoperationsare
completed. Otherwisethepixeldatacontinuesontothenextoperationunaffected.
TheadditionsmatchthoseoftheGL EXT histogramextension.
D.9.5 ConstantBlendColor
Aconstantcolorthatcanbeusedtode?neblendweightingfactorsmaybede?ned.
A typical usage is blending two RGB images. Without the constant blend factor,
one image must have an alpha channel with each pixel set to the desired blend
factor.
TheadditionsmatchthoseoftheGL EXT blend colorextension.
D.9.6 NewBlendingEquations
Blending equations other than the normal weighted sum of source and destination
componentsmaybeused.
Two of the new equations produce the minimum (or maximum) color com-
ponents of the source and destination colors. Taking the maximum is useful for
applicationssuchasmaximumprojectioninmedicalimaging.
The other two equations are similar to the default blending equation, but pro-
duce the difference of its left and right hand sides, rather than the sum. Image
differencesareusefulinmanyimageprocessingapplications.
The additions match those of the GL EXT blend minmax and
GL EXT blend subtractextensions.
D.10 Acknowledgements
OpenGL1.2istheresultofthecontributionsofmanypeople,representingacross
section of the computer industry. Following is a partial list of the contributors,
includingthecompanythattheyrepresentedatthetimeoftheircontribution:
KurtAkeley,SiliconGraphics
BillArmstrong,Evans&Sutherland
OttoBerkes,Microsoft
Pierre-LucBisaillon,MatroxGraphics
DrewBliss,Microsoft
Version2.1-December1,2006D.10. ACKNOWLEDGEMENTS 321
DavidBlythe,SiliconGraphics
JonBrewster,HewlettPackard
DanBrokenshire,IBM
PatBrown,IBM
NewtonCheung,S3
BillClifford,Digital
JimCobb,ParametricTechnology
BruceD’Amora,IBM
KevinDallas,Microsoft
MaheshDandapani,Rendition
DanielDaum,AccelGraphics
SuzyDeffeyes,IBM
PeterDoyle,Intel
JayDuluk,Raycer
CraigDunwoody,SiliconGraphics
DaveErb,IBM
FredFisher,AccelGraphics/DynamicPictures
CelesteFowler,SiliconGraphics
AllenGallotta,ATI
KenGarnett,NCD
MichaelGold,Nvidia/SiliconGraphics
CraigGroeschel,MetroLink
JanHardenbergh,MitsubishiElectric
MikeHeck,TemplateGraphicsSoftware
DickHessel,RaycerGraphics
PaulHo,SiliconGraphics
ShawnHopwood,SiliconGraphics
JimHurley,Intel
PhilHuxley,3Dlabs
DickJay,TemplateGraphicsSoftware
PaulJensen,3Dfx
BrettJohnson,HewlettPackard
MichaelJones,SiliconGraphics
TimKelley,Real3D
JonKhazam,Intel
LouisKhouw,Sun
DaleKirkland,Intergraph
ChrisKitrick,Raycer
DonKuo,S3
HerbKuta,Quantum3D
Version2.1-December1,2006322 APPENDIXD. VERSION1.2
PhilLacroute,SiliconGraphics
PrakashLadia,S3
JonLeech,SiliconGraphics
KevinLefebvre,HewlettPackard
DavidLigon,RaycerGraphics
KentLin,S3
DanMcCabe,S3
JackMiddleton,Sun
TimMisner,Intel
BillMitchell,NationalInstituteofStandards
JeremyMorris,3Dlabs
GeneMunce,Intel
WilliamNewhall,Real3D
MatthewPapakipos,Nvidia/Raycer
GarryPaxinos,MetroLink
HanspeterP?ster,MitsubishiElectric
RichardPimentel,ParametricTechnology
BimalPoddar,IBM/Intel
RobPutney,IBM
MikeQuinlan,Real3D
NateRobins,UniversityofUtah
DetlefRoettger,Elsa
RandiRost,HewlettPackard
KevinRushforth,Sun
RichardS.Wright,Real3D
HockSanLee,Microsoft
JohnSchimpf,SiliconGraphics
StefanSeeboth,ELSA
MarkSegal,SiliconGraphics
BobSeitsinger,S3
Min-ZhiShao,S3
ColinSharp,Rendition
IgorSinyak,Intel
BillSweeney,Sun
WilliamSweeney,Sun
NathanTuck,Raycer
DougTwillenger,Sun
JohnTynefeld,3dfx
KartikVenkataraman,Intel
AndyVesper,DigitalEquipment
Version2.1-December1,2006D.10. ACKNOWLEDGEMENTS 323
HenriWarren,DigitalEquipment/Megatek
PaulaWomack,SiliconGraphics
SteveWright,Microsoft
DavidYu,SiliconGraphics
RandyZhao,S3
Version2.1-December1,2006AppendixE
Version1.2.1
OpenGL version 1.2.1, released on October 14, 1998, introduced ARB extensions
(see Appendix K). The only ARB extension de?ned in this version is multitex-
ture,allowingapplicationofmultipletexturestoafragmentinonerenderingpass.
Multitexture is based on the GL SGIS multitexture extension, simpli?ed by
removingtheabilitytoroutetexturecoordinatesetstoarbitrarytextureunits.
A new corollary discussing display list and immediate mode invariance was
addedtoAppendixBonApril1,1999.
324AppendixF
Version1.3
OpenGL version 1.3, released on August 14, 2001, is the third revision since the
originalversion1.0. Version1.3isupwardcompatiblewithearlierversions,mean-
ing that any program that runs with a 1.2, 1.1, or 1.0 GL implementation will also
rununchangedwitha1.3GLimplementation.
SeveraladditionsweremadetotheGL,especiallytexturemappingcapabilities
previously de?ned by ARB extensions. Following are brief descriptions of each
addition.
F.1 CompressedTextures
Compressing texture images can reduce texture memory utilization and improve
performance when rendering textured primitives. The GL provides a framework
upon which extensions providing speci?c compressed image formats can be built,
andasetofgenericcompressedinternalformatsthatallowapplicationstospecify
that texture images should be stored in compressed form without needing to code
for speci?c compression formats (speci?c compressed formats, such as S3TC or
FXT1,aresupportedbyextensions).
Texture compression was promoted from the
GL ARB texture compressionextension.
F.2 CubeMapTextures
Cubemaptexturesprovideanewtexturegenerationschemeforlookinguptextures
from a set of six two-dimensional images representing the faces of a cube. The
(str)texturecoordinatesaretreatedasadirectionvectoremanatingfromthecenter
of a cube. At texture generation time, the interpolated per-fragment (str) selects
325326 APPENDIXF. VERSION1.3
one cube face two-dimensional image based on the largest magnitude coordinate
(the major axis). A new (st) is calculated by dividing the two other coordinates
(theminoraxesvalues)bythemajoraxisvalue,andthenew(st)isusedtolookup
intotheselectedtwo-dimensionaltextureimagefaceofthecubemap.
Two new texture coordinate generation modes are provided for use in con-
junction with cube map texturing. The REFLECTION MAP mode generates tex-
turecoordinates(str)matchingthevertex’seye-spacere?ectionvector,usefulfor
environment mapping without the singularity inherent in SPHERE MAP mapping.
TheNORMAL MAPmodegeneratestexturecoordinatesmatchingthevertex’strans-
formedeye-spacenormal,usefulfortexture-baseddiffuselightingmodels.
CubemappingwaspromotedfromtheGL ARB texture cube mapextension.
F.3 Multisample
Multisampling provides a antialiasing mechanism which samples all primitives
multipletimesateachpixel. Thecolorsamplevaluesareresolvedtoasingle,dis-
playablecoloreachtimeapixelisupdated,soantialiasingappearstobeautomatic
at the application level. Because each sample includes depth and stencil infor-
mation, the depth and stencil functions perform equivalently to the single-sample
mode.
Whenmultisamplingissupported,anadditionalbuffer,calledthemultisample
buffer,isaddedtotheframebuffer. Pixelsamplevalues,includingcolor,depth,and
stencilvalues,arestoredinthisbuffer.
Multisamplingisusuallyanexpensiveoperation,soitisusuallynotsupported
onallcontexts. Applicationsmustobtainamultisample-capablecontextusingthe
newinterfacesprovidedbyGLX1.4orbytheWGL ARB multisampleextension.
MultisamplingwaspromotedfromtheGL ARB multisampleextension; The
de?nitionoftheextensionwaschangedslightlytosupportbothmultisamplingand
supersamplingimplementations.
F.4 Multitexture
Multitexture adds support for multiple texture units. The capabilities of the mul-
tiple texture units are identical, except that evaluation and feedback are supported
only for texture unit 0. Each texture unit has its own state vector which includes
texture vertex array speci?cation, texture image and ?ltering parameters, and tex-
tureenvironmentapplication.
Thetextureenvironmentsofthetextureunitsareappliedinapipelinedfashion
wherebytheoutputofonetextureenvironmentisusedastheinputfragmentcolor
Version2.1-December1,2006F.5. TEXTUREADDENVIRONMENTMODE 327
forthenexttextureenvironment. Changestotextureclientstateandtextureserver
stateareeachroutedthroughoneoftwoselectorswhichcontrolwhichinstanceof
texturestateisaffected.
MultitexturewaspromotedfromtheGL ARB multitextureextension.
F.5 TextureAddEnvironmentMode
The TEXTURE ENV MODE texture environment function ADD provides a texture
functiontoaddincomingfragmentandtexturesourcecolors.
Texture add mode was promoted from the GL ARB texture env add exten-
sion.
F.6 TextureCombineEnvironmentMode
The TEXTURE ENV MODE texture environment function COMBINE provides a wide
range of programmable combiner functions using the incoming fragment color,
texture source color, texture constant color, and the result of the previous texture
environmentstageaspossibleparameters.
Combiner operations include passthrough, multiplication, addition and biased
addition, subtraction, and linear interpolation of speci?ed parameters. Different
combiner operations may be selected for RGB and A components, and the ?nal
resultmaybescaledby1,2,or4.
TexturecombinewaspromotedfromtheGL ARB texture env combineex-
tension.
F.7 TextureDot3EnvironmentMode
The TEXTURE ENV MODE COMBINE operations also provide three-component dot
productsofspeci?edparameters,withtheresultingscalarvaluereplicatedintothe
RGB or RGBA components of the output color. The dot product is performed
usingpseudo-signedarithmetictoenableper-pixellightingcomputations.
TextureDOT3modewaspromotedfromtheGL ARB texture env dot3ex-
tension.
F.8 TextureBorderClamp
The texture wrap parameter CLAMP TO BORDER mode clamps texture coordinates
atallmipmaplevelssuchthatwhenthetexture?lterstraddlesanedgeofthetexture
Version2.1-December1,2006328 APPENDIXF. VERSION1.3
image,thecolorreturnedisderivedonlyfrombordertexels. Thisbehaviormirrors
thebehaviorofthetextureedgeclampmodeintroducedbyOpenGL1.2.
Texture border clamp was promoted from the
GL ARB texture border clampextension.
F.9 TransposeMatrix
New functions and tokens are added allowing application matrices stored in row
major order rather than column major order to be transferred to the implementa-
tion. This allows an application to use standard C-language 2-dimensional arrays
and have the array indices match the expected matrix row and column indexes.
These arrays are referred to as transpose matrices since they are the transpose of
thestandardmatricespassedtoOpenGL.
TransposematrixaddsaninterfacefortransferingdatatoandfromtheOpenGL
pipeline. ItdoesnotchangeanyOpenGLprocessingorimplyanychangesinstate
representation.
TransposematrixwaspromotedfromtheGL ARB transpose matrixexten-
sion.
F.10 Acknowledgements
OpenGL1.3istheresultofthecontributionsofmanypeople. Followingisapartial
list of the contributors, including the company that they represented at the time of
theircontribution:
AdrianMuntianu,ATI
AlReyes,3dfx
AlainBouchard,Matrox
AlanCommike,SGI
AlanHeirich,Compaq
AlexHerrera,SP3D
AllenAkin,VALinux
AllenGallotta,ATI
AlligatorDescartes,Arcane
AndyVesper,MERL
AndyWolf,DiamondMultimedia
AxelSchildan,S3
BartholdLichtenbelt,3Dlabs
BenjLipchak,Compaq
BillArmstrong,Evans&Sutherland
Version2.1-December1,2006F.10. ACKNOWLEDGEMENTS 329
BillClifford,Intel
BillMannel,SGI
BimalPoddar,Intel
BobBeretta,Apple
BrentInsko,NVIDIA
BrianGoldiez,UCF
BrianGreenstone,Apple
BrianPaul,VALinux
BrianSharp,GLSetup
BruceD’Amora,IBM
BruceStockwell,Compaq
ChrisBrady,Alt.software
ChrisFrazier,Raycer
ChrisHall,3dlabs
ChrisHecker,GLSetup
ChrisLane,Intel
ChrisThornborrow,PixelFusion
ChristopherFraser,IMG
ChuckSmith,Intelligraphics
CraigDunwoody,SGI
DairsieLatimer,PixelFusion
DaleKirkland,3Dlabs/Intergraph
DanBrokenshire,IBM
DanGinsburg,ATI
DanMcCabe,S3
DaveAronson,Microsoft
DaveGosselin,ATI
DaveShreiner,SGI
DaveZenz,Dell
DavidAronson,Microsoft
DavidBlythe,SGI
DavidKirk,NVIDIA
DavidStory,SGI
DavidYu,SGI
DeannaHohn,3dfx
DickCoulter,SiliconMagic
DonMullis,3dfx
EamonODea,PixelFusion
Edward(Chip)Hill,Pixelfusion
EijiObata,NEC
Version2.1-December1,2006330 APPENDIXF. VERSION1.3
ElioDelGiudice,Matrox
EricYoung,S3
EvanHart,ATI
FredFisher,3dLabs
GarryPaxinos,MetroLink
GaryTarolli,3dfx
GeorgeKyriazis,NVIDIA
GrahamConnor,IMG
HerbKuta,Quantum3D
HowardMiller,Apple
IgorSinyak,Intel
JackMiddleton,Sun
JamesBowman,3dfx
JanC.Hardenbergh,MERL
JasonMitchell,ATI
JeffWeyman,ATI
JeffreyNewquist,3dfx
JensOwen,PrecisionInsight
JeremyMorris,3Dlabs
JimBushnell,PyramidPeak
JohnDennis,SharpEye
JohnMetcalfe,IMG
JohnStauffer,Apple
JohnTynan,PixelFusion
JohnW.Polick,NEC
JonKhazam,Intel
JonLeech,SGI
JonPaulSchelter,Matrox
KarlHilleslad,NVIDIA
KelvinThompson
KenCameron,Pixelfusion
KenDyke,Apple
KenNicholson,SGI
KentLin,Intel
KevinLefebvre,HP
KevinMartin,VALinux
KurtAkeley,SGI
LesSilvern,NEC
MaheshDandipani,Rendition
MarkKilgard,NVIDIA
Version2.1-December1,2006F.10. ACKNOWLEDGEMENTS 331
MartinAmon,3dfx
MartinaSourada,ATI
MattLavoie,Pixelfusion
MattRusso,Matrox
MatthewPapakipos,NVIDIA
MichaelGold,NVIDIA
MiriamGeller,SGI
MorganVonEssen,MetroLink
NarukiAruga,PFU
NathanTuck,RaycerGraphics
NeilTrevett,3Dlabs
NewtonCheung,S3
NickTriantos,NVIDIA
PatrickBrown,Intel
PaulJensen,3dfx
PaulKeller,NVIDIA
PaulMartz,HP
PaulaWomack,3dfx
PeterDoenges,Evans&Sutherland
PeterGraffagnino,Apple
PhilHuxley,3Dlabs
RalfBiermann,ElsaAG
RandiRost,3Dlabs
ReneeRashid,Micron
RichJohnson,HP
RichardPimentel,PTC
RichardSchlein,Apple
RickHammerstone,ATI
RikFaith,VALinux
RobGlidden,Sun
RobWheeler,3dfx
ShariPetersen,Rendition
ShawnHopwood,SGI
SteveGlickman,SiliconMagic
SteveMcGuigan,SGI
SteveWright,Microsoft
StuartAnderson,MetroLink
T.C.Zhao,MERL
TeriMorrison,HP
ThomasFox,IBM
Version2.1-December1,2006332 APPENDIXF. VERSION1.3
TimKelley,Real3D
TomFrisinger,ATI
VictorVedovato,Micron
VikramSimha,MERL
YanjunZhang,Sun
ZahidHussain,TI
Version2.1-December1,2006AppendixG
Version1.4
OpenGL version 1.4, released on July 24, 2002, is the fourth revision since the
originalversion1.0. Version1.4isupwardcompatiblewithearlierversions,mean-
ing that any program that runs with a 1.3, 1.2, 1.1, or 1.0 GL implementation will
alsorununchangedwitha1.4GLimplementation.
In addition to numerous additions to the classical ?xed-function GL pipeline
in OpenGL 1.4, the OpenGL ARB also approved the GL ARB vertex program
extension, which supports programmable vertex processing. Following are brief
descriptions of each addition to OpenGL 1.4; see Chapter K for a description of
GL ARB vertex program.
G.1 AutomaticMipmapGeneration
Setting the texture parameterGENERATE MIPMAP toTRUE introduces a side effect
toanymodi?cationofthelevel ofamipmaparray,whereinallhigherlevelsof
base
the mipmap pyramid are recomputed automatically by successive ?ltering of the
baselevelarray.
Automatic
mipmap generation was promoted from the GL SGIS generate mipmap exten-
sion.
G.2 BlendSquaring
Blendsquaringextendsthesetofsupportedsourceanddestinationblendfunctions
to permit squaring RGB and alpha values during blending. FunctionsSRC COLOR
and ONE MINUS SRC COLOR are added to the allowed source blending functions,
333334 APPENDIXG. VERSION1.4
andDST COLOR andONE MINUS DST COLOR are added to the allowed destination
blendingfunctions.
BlendsquaringwaspromotedfromtheGL NV blend squareextension.
G.3 ChangestotheImagingSubset
The subset of blending features described by BlendEquation, BlendColor,
and the BlendFunc modes CONSTANT COLOR, ONE MINUS CONSTANT COLOR,
CONSTANT ALPHA, andONE MINUS CONSTANT ALPHA are now supported. These
feature were available only in the optional imaging subset in versions 1.2 and 1.3
oftheGL.
G.4 DepthTexturesandShadows
Depthtexturesde?neanewtextureinternalformat,DEPTH,normallyusedtorepre-
sentdepthvalues. Applicationsincludeimage-basedshadowcasting,displacement
mapping,andimage-basedrendering.
Image-based shadowing is enabled with a new texture application mode de-
?ned by the parameter TEXTURE COMPARE MODE. This mode enables comparing
texturer coordinatestodepthtexturevaluestogenerateabooleanresult.
DepthtexturesandshadowswerepromotedfromtheGL ARB depth texture
andGL ARB shadowextensions.
G.5 FogCoordinate
A new associated vertex and fragment datum, the fog coordinate may be used
in computing fog for a fragment, instead of using eye distance to the frag-
ment, by specifying the coordinate with the FogCoord commands and setting the
FOG COORDINATE SOURCEfogparameter. Fogcoordinatesareparticularlyuseful
incomputingmorecomplexfogmodels.
FogcoordinatewaspromotedfromtheGL EXT fog coordextension.
G.6 MultipleDrawArrays
MultipleprimitivesmaybedrawninasinglecallusingtheMultiDrawArraysand
MultiDrawElementscomments.
Multiple draw arrays was promoted from the GL EXT multi draw arrays
extension.
Version2.1-December1,2006G.7. POINTPARAMETERS 335
G.7 PointParameters
Point parameters de?ned by the PointParameter commands support additional
geometric characteristics of points, allowing the size of a point to be affected by
linearorquadraticdistanceattenuation,andincreasingcontrolofthemappingfrom
point size to raster point area and point transparency. This effect may be used for
distanceattenuationinrenderingparticlesorlightpoints.
Point parameters was promoted from theGL ARB point parameters exten-
sion.
G.8 SecondaryColor
Thesecondarycolormaybevariedevenwhenlightingisdisabledbyspecifyingit
asavertexparameterwiththeSecondaryColorcommands.
Secondary color was promoted from the GL EXT secondary color exten-
sion.
G.9 SeparateBlendFunctions
Blending capability is extended with BlendFuncSeparate to allow independent
setting of the RGB and alpha blend functions for blend operations that require
sourceanddestinationblendfactors.
Separate blend functions was promoted from the
GL EXT blend func separateextension.
G.10 StencilWrap
NewstenciloperationsINCR WRAPandDECR WRAPallowthestencilvaluetowrap
around the range of stencil values instead of saturating to the minimum or maxi-
mumvaluesondecrementorincrement. Stencilwrappingisneededforalgorithms
thatusethestencilbufferforper-fragmentinside-outsideprimitivecomputations.
StencilwrapwaspromotedfromtheGL EXT stencil wrapextension.
G.11 TextureCrossbarEnvironmentMode
Texture crossbar extends the texture combine environment mode COMBINE by al-
lowinguseofthetexturecolorfromdifferenttextureunitsassourcestothetexture
combinefunction.
Version2.1-December1,2006336 APPENDIXG. VERSION1.4
Texture
environment crossbar was promoted from the GL ARB texture env crossbar
extension.
G.12 TextureLODBias
The texture ?lter control parameter TEXTURE LOD BIAS may be set to bias the
computed? parameter used in texturing for mipmap level of detail selection, pro-
vidingameanstoblurorsharpentextures. LODbiasmaybeusedfordepthof?eld
andotherspecialvisualeffects,aswellasforsometypesofimageprocessing.
Texture LOD bias was based on the GL EXT texture lod bias extension,
withtheadditionofasecondper-textureobjectbiasterm.
G.13 TextureMirroredRepeat
Texture mirrored repeat extends the set of texture wrap modes with the mode
MIRRORED REPEAT. This effectively de?nes a texture map twice as large as the
original texture image in which the additional half, for each mirrored texture co-
ordinate, is a mirror image of the original texture. Mirrored repeat can be used
seamlesstilingofasurface.
Texture mirrored repeat was promoted from the
GL ARB texture mirrored repeatextension.
G.14 WindowRasterPosition
The raster position may be set directly to speci?ed window coordinates with the
WindowPoscommands,bypassingthetransformationappliedtoRasterPos. Win-
dowrasterpositionisparticularlyusefulforimagingandother2Doperations.
Window raster position was promoted from the GL ARB window pos exten-
sion.
G.15 Acknowledgements
OpenGL1.4istheresultofthecontributionsofmanypeople. Followingisapartial
list of the contributors, including the company that they represented at the time of
their contribution. The editor especially thanks Bob Beretta and Pat Brown for
their sustained efforts in leading the GL ARB vertex program working group,
Version2.1-December1,2006G.15. ACKNOWLEDGEMENTS 337
without which this critical extension could not have been de?ned and approved in
conjunctionwithOpenGL1.4.
KurtAkeley,NVIDIA
AllenAkin
BillArmstrong,Evans&Sutherland
BenAshbaugh,Intel
ChrisBentley,ATI
BobBeretta,Apple
DanielBrokenshire,IBM
PatBrown,NVIDIA
BillClifford,Intel
GrahamConnor,Videologic
MattCraighead,NVIDIA
SuzyDeffeyes,IBM
Jean-LucDery,Discreet
KennethDyke,Apple
CassEveritt,NVIDIA
AllenGallotta,ATI
LeeGross,IBM
EvanHart,ATI
ChrisHecker,De?nition6
AlanHeirich,Compaq/HP
GarethHughes,VALinux
MichaelIGold,NVIDIA
RichJohnson,HP
MarkKilgard,NVIDIA
DaleKirkland,3Dlabs
DavidKirk,NVIDIA
ChristianLaforte,Alias—Wavefront
LucLeblanc,Discreet
JonLeech,SGI
BillLicea-Kane,ATI
BartholdLichtenbelt,3Dlabs
JackMiddleton,Sun
HowardMiller,Apple
JeremyMorris,3Dlabs
JonPaulSchelter,Matrox
BrianPaul,VALinux/TungstenGraphics
BimalPoddar,Intel
ThomasRoell,XiGraphics
Version2.1-December1,2006338 APPENDIXG. VERSION1.4
RandiRost,3Dlabs
JeremySandmel,ATI
JohnStauffer,Apple
NickTriantos,NVIDIA
DanielVogel,EpicGames
MasonWoo,WorldWideWoo
DaveZenz,Dell
Version2.1-December1,2006AppendixH
Version1.5
OpenGLversion1.5,releasedonJuly29,2003,isthe?fthrevisionsincetheorig-
inal version 1.0. Version 1.5 is upward compatible with earlier versions, meaning
thatanyprogramthatrunswitha1.4,1.3,1.2,1.1,or1.0GLimplementationwill
alsorununchangedwitha1.5GLimplementation.
In addition to additions to the classical ?xed-function GL pipeline in OpenGL
1.5, the OpenGL ARB also approved a related set of ARB extensions including
the OpenGL Shading Language speci?cation and the GL ARB shader objects,
GL ARB vertex shader, and GL ARB fragment shader extensions through
which high-level shading language programs can be loaded and used in place of
the?xed-functionpipeline.
Following are brief descriptions of each addition to OpenGL 1.5. The low-
levelandhigh-levelshadinglanguagesareimportantadjunctstotheOpenGLcore.
They are described in more detail in appendix K, and their corresponding ARB
extensionspeci?cationsareavailableonlineasdescribedinthatappendix.
H.1 BufferObjects
Buffer objects allow various types of data (especially vertex array data) to be
cached in high-performance graphics memory on the server, thereby increasing
therateofdatatransferstotheGL.
BufferobjectswerepromotedfromtheGL ARB vertex buffer objectex-
tension.
339340 APPENDIXH. VERSION1.5
H.2 OcclusionQueries
Anocclusionqueryisamechanismwherebyanapplicationcanquerythenumber
ofpixels(or,moreprecisely,samples)drawnbyaprimitiveorgroupofprimitives.
Theprimarypurposeofocclusionqueriesistodeterminethevisibilityofanobject.
Occlusion query was promoted from the GL ARB occlusion query exten-
sion.
H.3 ShadowFunctions
Texturecomparisonfunctionsaregeneralizedtosupportalleightbinaryfunctions
ratherthanjustLEQUALandGEQUAL.
Texture comparison functions were promoted from the
GL EXT shadow funcsextension.
H.4 ChangedTokens
ToachieveconsistencywiththesyntaxguidelinesforOpenGLfunctionandtoken
names, new token names are introduced to be used in place of old, inconsistent
names. However, the old token names continue to be supported, for backwards
compatibilitywithcodewrittenforpreviousversionsofOpenGL.Thenewnames,
andtheoldnamestheyreplace,areshownintableH.1.
H.5 Acknowledgements
OpenGL1.5istheresultofthecontributionsofmanypeople. Theeditorespecially
thanksthefollowingindividualsfortheirsustainedeffortsinleadingARBworking
groupsessentialtothesuccessofOpenGL1.5andofARBextensionsapprovedin
conjunctionwithOpenGL1.5:
Matt Craighead led the working group
which created the GL ARB vertex buffer object extension and OpenGL 1.5
corefeature. KurtAkeleywrotetheinitialspeci?cationforthegroup.
Daniel Ginsburgand Matt Craigheadled the workinggroup which createdthe
GL ARB occlusion queryextensionandOpenGL1.5corefeature.
BenjaminLipchakledthefragmentprogramworkinggroupwhichcreatedthe
GL ARB fragment program extension, completing the low-level programmable
shadinginterface.
Bill Licea-Kane led the GL2 working group which created the high-
level programmable shading interface, including theGL ARB fragment shader,
Version2.1-December1,2006H.5. ACKNOWLEDGEMENTS 341
NewTokenName OldTokenName
FOG COORD SRC FOG COORDINATE SOURCE
FOG COORD FOG COORDINATE
CURRENT FOG COORD CURRENT FOG COORDINATE
FOG COORD ARRAY TYPE FOG COORDINATE ARRAY TYPE
FOG COORD ARRAY STRIDE FOG COORDINATE ARRAY STRIDE
FOG COORD ARRAY POINTER FOG COORDINATE ARRAY POINTER
FOG COORD ARRAY FOG COORDINATE ARRAY
FOG COORD ARRAY BUFFER BINDING FOG COORDINATE ARRAY BUFFER BINDING
SRC0 RGB SOURCE0 RGB
SRC1 RGB SOURCE1 RGB
SRC2 RGB SOURCE2 RGB
SRC0 ALPHA SOURCE0 ALPHA
SRC1 ALPHA SOURCE1 ALPHA
SRC2 ALPHA SOURCE2 ALPHA
TableH.1: Newtokennamesandtheoldnamestheyreplace.
GL ARB shader objects, and GL ARB vertex shader extensions and the
OpenGLShadingLanguage.
John Kessenich was the principal editor of the OpenGL Shading Language
speci?cationfortheGL2workinggroup, startingfromtheinitialglslangproposal
writtenbyJohn,DaveBaldwin,andRandiRost.
Apartiallistofothercontributors,includingthecompanythattheyrepresented
atthetimeoftheircontribution,follows:
KurtAkeley,NVIDIA
AllenAkin
ChadAnson,DellComputer
BillArmstrong,Evans&Sutherland
BenAshbaugh,Intel
DaveBaldwin,3Dlabs
ChrisBentley,ATI
BobBeretta,Apple
DavidBlythe
AlainBouchard,Matrox
DanielBrokenshire,IBM
PatBrown,NVIDIA
JohnCarmack,IdSoftware
Version2.1-December1,2006342 APPENDIXH. VERSION1.5
PaulCarmichael,NVIDIA
BobCarwell,IBM
PaulClarke,IBM
BillClifford,Intel
RogerCloud,SGI
GrahamConnor,PowerVR
MattCraighead,NVIDIA
DougCrisman,SGI
MattCruikshank,VitalImages
DeronDannJohnson,Sun
SuzyDeffeyes,IBM
SteveDemlow,VitalImages
JoeDeng,SiS
Jean-LucDery,Discreet
KennethDyke,Apple
BrianEmberling,Sun
CassEveritt,NVIDIA
BrandonFli?et,Intel
AllenGallotta,ATI
DanielGinsburg,ATI
SteveGlanville,NVIDIA
PeterGraffagnino,Apple
LeeGross,IBM
RickHammerstone,ATI
EvanHart,ATI
ChrisHecker,De?nition6
AlanHeirich,HP
GarethHughes,NVIDIA
MichaelIGold,NVIDIA
JohnJarvis,Alt.software
RichJohnson,HP
JohnKessenich,3Dlabs
MarkKilgard,NVIDIA
DaleKirkland,3Dlabs
RaymondKlassen,Intel
JasonKnipe,Bioware
JayantKolhe,NVIDIA
SteveKoren,3Dlabs
BobKuehne,SGI
ChristianLaforte,Alias
Version2.1-December1,2006H.5. ACKNOWLEDGEMENTS 343
LucLeblanc,Discreet
JonLeech,SGI
KevinLefebvre,HP
BillLicea-Kane,ATI
BartholdLichtenbelt,3Dlabs
KentLin,Intel
BenjaminLipchak,ATI
RobMace,ATI
BillMark,NVIDIA
MichaelMcCool,U.Waterloo
JackMiddleton,Sun
HowardMiller,Apple
TeriMorrison,HP/3Dlabs
MarcOlano,SGI/U.Maryland
Jean-FrancoisPanisset,Discreet
JonPaulSchelter,Matrox
BrianPaul,TungstenGraphics
ScottPeterson,HP
BimalPoddar,Intel
ThomasRoell,XiGraphics
PhilRogers,ATI
IanRomanick,IBM
JohnRosasco,Apple
RandiRost,3Dlabs
MattRusso,Matrox
JeremySandmel,ATI
PaulSargent,3Dlabs
FolkerSchamel,SpinorGMBH
MichaelSchulman,Sun
JohnScott,RavenSoftware
AvinashSeetharamaiah,Intel
JohnSpitzer,NVIDIA
VladStamate,PowerVR
MichelleStamnes,Intel
JohnStauffer,Apple
EskilSteenberg,Obsession
BruceStockwell,HP
ChristopherTan,IBM
RayTice,Avid
PierreP.Tremblay,Discreet
Version2.1-December1,2006344 APPENDIXH. VERSION1.5
NeilTrevett,3Dlabs
NickTriantos,NVIDIA
DouglasTwilleager,Sun
ShawnUnderwood,SGI
SteveUrquhart,Intelligraphics
VictorVedovato,ATI
DanielVogel,EpicGames
MikWells,Softimage
HeleneWorkman,Apple
DaveZenz,Dell
KarelZuiderveld,VitalImages
Version2.1-December1,2006AppendixI
Version2.0
OpenGLversion2.0,releasedonSeptember7,2004,isthesixthrevisionsincethe
original version 1.0. Despite incrementing the major version number (to indicate
support for high-level programmable shaders), version 2.0 is upward compatible
with earlier versions, meaning that any program that runs with a 1.5, 1.4, 1.3, 1.2,
1.1, or 1.0 GL implementation will also run unchanged with a 2.0 GL implemen-
tation.
FollowingarebriefdescriptionsofeachadditiontoOpenGL2.0.
I.1 ProgrammableShading
The OpenGL Shading Language, and the related APIs to create, manage, and use
programmable shaders written in the Shading Language, were promoted to core
features in OpenGL 2.0. The complete list of features related to programmable
shadingincludes:
I.1.1 ShaderObjects
Shaderobjectsprovidesmechanismsnecessarytomanageshaderandprogramob-
jects. Shader objects were promoted from the GL ARB shader objects exten-
sion.
I.1.2 ShaderPrograms
Vertex and fragment shader programs may be written in the high-level OpenGL
Shading Language, replacing ?xed-functionality vertex and fragment process-
ing respectively. Vertex and fragment shader programs were promoted from the
GL ARB vertex shaderandGL ARB fragment shaderextensions.
345346 APPENDIXI. VERSION2.0
I.1.3 OpenGLShadingLanguage
The OpenGL Shading Language is a high-level, C-like language used to program
the vertex and fragment pipelines. The Shading Language Specification de?nes
thelanguageproper,whileOpenGLAPIfeaturescontrolhowvertexandfragment
programs interact with the ?xed-function OpenGL pipeline and how applications
managethoseprograms.
OpenGL 2.0 implementations must support at least revision 1.10
of the OpenGL Shading Language. Implementations may query the
SHADING LANGUAGE VERSION string to determine the exact version of the
language supported. The OpenGL Shading Language was promoted from the
GL ARB shading language 100 extension (the shading language itself is
speci?edinacompaniondocument;duetothewayit’swritten,thatdocumentdid
not need to be changed as a consequence of promoting programmable shading to
theOpenGLcore).
I.1.4 ChangesToShaderAPIs
Small changes to the APIs for managing shader and program objects were made
in the process of promoting the shader extensions to the OpenGL 2.0 core. These
changes do not affect the functionality of the shader APIs, but include use of the
existinguint core GL type rather than the newhandleARB type introduced by
theextensions,andchangesinsomefunctionnames,forexamplemappingtheex-
tensionfunctionCreateShaderObjectARBintothecorefunctionCreateShader.
I.2 MultipleRenderTargets
Programmable shaders may write different colors to multiple output color
buffers in a single pass. Multiple render targets was promoted from the
GL ARB draw buffersextension.
I.3 Non-Power-Of-TwoTextures
The restriction of textures to power-of-two dimensions has been relaxed for
all texture targets, so that non-power-of-two textures may be speci?ed with-
out generating errors. Non-power-of-two textures was promoted from the
GL ARB texture non power of twoextension.
Version2.1-December1,2006I.4. POINTSPRITES 347
I.4 PointSprites
Pointspritesreplacepointtexturecoordinateswithtexturecoordinatesinterpolated
across the point. This allows drawing points as customized textures, useful for
particlesystems.
PointspriteswerepromotedfromtheGL ARB point spriteextension,with
the further addition of the POINT SPRITE COORD ORIGIN parameter controlling
thedirectioninwhichthettexturecoordinateincreases.
I.5 SeparateBlendEquation
Blending capability is extended with BlendEquationSeparate to allow indepen-
dentsettingoftheRGBandalphablendequationsforblendoperations.
Separate blend functions was pro-
moted fromtheGL EXT blend equation separate extension. Note thatblend
equation LOGIC OP is not supported unless the GL EXT blend logic op exten-
sionissupported;LOGIC OPwasinadvertentlyincludedintheinitialreleaseofthe
OpenGL2.0Specification.
I.6 SeparateStencil
Separatestencilfunctionalitymaybede?nedforthefrontandbackfacesofprimi-
tives,improvingperformanceofshadowvolumeandConstructiveSolidGeometry
renderingalgorithms.
Separate stencil was based on the the
API of the GL ATI separate stencil extension, with additional state de?ned
bythesimilarGL EXT stencil two sideextension.
I.7 OtherChanges
Several minor revisions and corrections to the OpenGL 1.5 speci?cation were
made:
• In section 2.7, SecondaryColor3 was changed to set A to 1.0 (previously
0.0),sotheinitialGLstatecanberestored.
• In section 2.13, transformation was added to the list of steps not performed
byWindowPos.
Version2.1-December1,2006348 APPENDIXI. VERSION2.0
• Section 3.8.1 was clari?ed to mandate that selection of texture internal for-
mat must allocate a non-zero number of bits for all components named by
theinternalformat,andzerobitsforallothercomponents.
• Tables 3.21 and 3.22 were generalized to multiple textures by replacingC
f
withC .
p
• In section 6.1.9, GetHistogram was clari?ed to note that the Final Conver-
sionpixelstoragemodeisnotappliedwhenstoringhistogramcounts.
• TheFOG COORD ARRAY BUFFER BINDINGenumerantaliaswasaddedtota-
bleH.1.
After the initial version of the OpenGL 2.0 was released, several more minor
correctionsweremadeinthespeci?cationrevisionapprovedonOctober22,2004:
• Corrected name of the fog source from FOG COORD SRC to FOG COORD in
section2.13.
• Corrected last parameter type in the declaration of the UniformMatrix*
commandstoconst float *value,insection2.15.3.
• Changed the end of the second paragraph of the Conversion to Fragments
subsection of section 3.6.4, to more clearly describe the set of generated
fragments.
• ChangedfromtheolderFOG COORDINATEtothenewerFOG COORDnotation
insection3.10.
• AddedPOINT SPRITE COORD ORIGINstatetotable6.14.
• Changed the description of MAX TEXTURE UNITS in table 6.35 to re?ect its
legacy status (referring to the number of ?xed-function texture units), and
moveditintotable6.36.
• Removed duplicated table entries for MAX TEXTURE IMAGE UNITS and
MAX TEXTURE COORDSfromtable6.36.
• AddedVictorVedovatototheOpenGL2.0Acknowledgementssection.
• Miscellaneoustypographicalcorrections.
Additionalminorcorrectionsweremadeinthespeci?cationrevisionapproved
onFebruary9,2005:
Version2.1-December1,2006I.8. ACKNOWLEDGEMENTS 349
• Restoredmissinglanguagefromthedepthtextureextensioninsection6.1.4,
allowingDEPTH COMPONENTasaformatfortexturereadbacks.
• Added separate blend equation to the feature list in appendix I. The feature
has been in the actual OpenGL 2.0 speci?cation all along, but was omitted
fromthefeaturelistintheinitialspeci?cationrelease.
• Removed LOGIC OP from the allowed blend equations in section 4.1.8 and
table 4.1, and adjusted the type of the blend equation state in table 6.21
accordingly.
• RestoredmissingVERTEX ATTRIB ARRAY BUFFER BINDINGstatefromta-
ble6.8.
• Miscellaneoustypographicalcorrections.
I.8 Acknowledgements
OpenGL 2.0 is the result of the contributions of many people. The editors espe-
cially thank the ongoing work of the ARB GL2 working group, led by Bill Licea-
Kane and with speci?cations edited by John Kessenich and Barthold Lichtenbelt,
inperformingworknecessarytopromotetheOpenGLShadingLanguagetoacore
OpenGLfeature.
Apartiallistofothercontributors,includingthecompanythattheyrepresented
atthetimeoftheircontribution,follows:
KurtAkeley,NVIDIA
AllenAkin
DaveBaldwin,3Dlabs
BobBeretta,Apple
PatBrown,NVIDIA
MattCraighead,NVIDIA
SuzyDeffeyes,IBM
KenDyke,Apple
CassEveritt,NVIDIA
SteveGlanville,NVIDIA
MichaelI.Gold,NVIDIA
EvanHart,ATI
PhilHuxley,3Dlabs
DeronDannJohnson,Sun
JohnKessenich,3Dlabs
MarkKilgard,NVIDIA
Version2.1-December1,2006350 APPENDIXI. VERSION2.0
DaleKirkland,3Dlabs
SteveKoren,3Dlabs
JonLeech,SGI
BillLicea-Kane,ATI
BartholdLichtenbelt,3Dlabs
KentLin,Intel
BenjaminLipchak,ATI
RobMace,ATI
MichaelMcCool,U.Waterloo
JackMiddleton,Sun
JeremyMorris,3Dlabs
TeriMorrison,3Dlabs
MarcOlano,SGI/U.Maryland
GlennOrtner,ATI
BrianPaul,TungstenGraphics
BimalPoddar,Intel
PhilRogers,ATI
IanRomanick,IBM
RandiRost,3Dlabs
JeremySandmel,ATI
FolkerSchamel,SpinorGMBH
GeoffStahl,Apple
EskilSteenberg,Obsession
NeilTrevett,3Dlabs
VictorVedovato,ATI
MikWells,Softimage
EsenYilmaz,Intel
DaveZenz,Dell
Version2.1-December1,2006AppendixJ
Version2.1
OpenGLversion 2.1, releasedonAugust 2, 2006, is the seventhrevisionsince the
original version 1.0. Despite incrementing the major version number (to indicate
support for high-level programmable shaders), version 2.1 is upward compatible
with earlier versions, meaning that any program that runs with a 2.0, 1.5, 1.4,
1.3, 1.2, 1.1, or 1.0 GL implementation will also run unchanged with a 2.0 GL
implementation.
FollowingarebriefdescriptionsofeachadditiontoOpenGL2.1.
J.1 OpenGLShadingLanguage
OpenGL 2.1 implementations must support at least revision 1.20 of
the OpenGL Shading Language. Implementations may query the
SHADING LANGUAGE VERSION string to determine the exact version of the
language supported. Refer to the OpenGL Shading Language Specification for
detailsofthechangesbetweenrevision1.10and1.20.
J.2 Non-SquareMatrices
Added the UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv commands in sec-
tion2.15.3,allowingspeci?cationofnon-squareuniformmatrices.
J.3 PixelBufferObjects
Pixel buffer objects expand on the interface provided by the vertex buffer objects,
allowingbufferobjectstobeusedwithbothvertexarrayandpixeldata. Thisallows
351352 APPENDIXJ. VERSION2.1
moreaccelerationopportunitiesforOpenGLpixelcommands.
When a buffer object is bound to the PIXEL PACK BUFFER target, commands
such as ReadPixels write their data into a buffer object. When a buffer object is
bound to the PIXEL UNPACK BUFFER target, commands such as DrawPixels and
TexImage2Dreadtheirdatafromabufferobject.
Pixel buffer objects was promoted from the GL ARB pixel buffer object
extension. The speci?cation was tightened to consistently require error be gener-
ated when read or write operations to a pixel buffer object would run past the end
of the buffer, or would be misaligned with respect to the data type being read or
written.
J.4 sRGBTextures
New uncompressed and compressed color texture formats with sRGB color com-
ponentsarede?ned. ThesRGBcolorspaceisbasedontypical(non-linear)monitor
characteristicsexpectedinadimlylitof?ce. IthasbeenstandardizedbytheInter-
national Electrotechnical Commission (IEC) as IEC 61966-2-1. The sRGB color
spaceroughlycorrespondsto2.2gammacorrection.
sRGB textures was promoted from the GL EXT texture sRGB extension.
Speci?c compressed sRGB internal formats de?ned by the extension were not in-
cluded in OpenGL 2.1, while the generic uncompressed and compressed formats
wereretained
J.5 OtherChanges
Several minor revisions and corrections to the OpenGL 2.0 speci?cation were
made:
• Note that the information log for program objects can include both link and
validationinformation,insection2.15.2.
• Notedinsection3.6.4thatthereisacurrentrastersecondarycolor,andadded
theCURRENT RASTER SECONDARY COLORquery.
• Required perspective-correct interpolation for
all fragment attributes except depth in sections 3.4.1 and 3.5.1, effectively
makingGL PERSPECTIVE CORRECT HINTano-op.
• Merged speci?c and generic compressed internal texture format tables into
thesingletable3.17.
Version2.1-December1,2006J.5. OTHERCHANGES 353
• Changedthetypeoftexturewrapmodeandmin/mag?lterparametersfrom
integertoenumintable3.18.
• Removed mention of compressed texture depth components from sec-
tion3.8.1,sincenocompresseddepthformatsarecurrentlyde?ned.
• Addedforwardreferencefromsection3.8.5tosection3.8.14,whichde?nes
howdepthtexturesareactuallyused.
• Remove notation in table 4.1, and ?xed blend equations for
c
FUNC REVERSE SUBTRACT.
• Noted in section 6.1.15 that all texture object parameters are pushed and
popped by PushAttrib and PopAttrib when TEXTURE BIT is set in the at-
tributemask.
• Miscellaneoustypographicalcorrections.
Additionalminorcorrectionsweremadeinaspeci?cationrevisionapprovedon
August10,2006,withafewadditional?xesandomissionscorrectedonDecember
1,2006:
• Noted in section 2.5 that INVALID VALUE is generated for negative
sizeiptrvalues.
• Noted in section 2.7 that VertexAttrib* can be used to load attributes for
anysupportedmatrixtype,notjustsquarematrices.
• Removed the description of generating multiple connected components
when clipping vertices with w values of different signs, at the end of sec-
c
tion2.12. Implementationsshouldnotrenderinthew < 0region.
c
• Added FLOAT MAT2x3, FLOAT MAT2x4, FLOAT MAT3x2, FLOAT MAT3x4,
FLOAT MAT4x2, and FLOAT MAT4x3 tokens for non-square matrix types to
GetActiveAttrib and GetActiveUniform in section 2.15.3, and expanded
the description of how attribute components are mapped to matrix elements
tomatch.
• Clari?edinsection3.8.12thatthetextureobjectpassedtoBindTexturemust
matchthespeci?ed target,notjustthedimensionalityof target.
• Added missing TexEnv targets RGB SCALE, ALPHA SCALE, SRCn RGB,
SRCn ALPHA,OPERANDn RGB,andOPERANDn ALPHAinsection3.8.13.
Version2.1-December1,2006354 APPENDIXJ. VERSION2.1
• NotedthatPOINT SPRITEisapossibleenvparametertoGetTexEnvinsec-
tion6.1.3.
• Miscellaneoustypographicalcorrections.
J.6 Acknowledgements
OpenGL2.1istheresultofthecontributionsofmanypeople. Theeditorespecially
thankstheongoingworkoftheARBGLSLworkinggroup,ledbyBillLicea-Kane
and with speci?cations edited by John Kessenich and Barthold Lichtenbelt, in up-
datingtheOpenGLShadingLanguagetorevision1.20. RalfBiermann,DerekCor-
nish, Matt Craighead, and Mark Kilgard edited the EXT pixel buffer object
proposal later adopted and developed by the ARB Pixel Buffer Object working
group,andMarkKilgardeditedtheEXT texture sRGBextension.
Apartiallistofothercontributors,includingthecompanythattheyrepresented
atthetimeoftheircontribution,follows:
AaftabMunshi,ATI
AviShapira,GraphicRemedy
BartholdLichtenbelt,3Dlabs/NVIDIA
BenjaminLipchak,ATI
BenjiBowman,ImaginationTechnologies
BillArmstrong,EvansandSutherland
BillLicea-Kane,ATI
BimalPoddar,Intel
BobBeretta,Apple
BrianPaul,TungstenGraphics
CassEveritt,NVIDIA
ChrisDodd,NVIDIA
ChrisStarkey,3Dlabs
DaleKirkland,3Dlabs
DanielVogel,EpicGames
DaveShreiner,SGI
DerekCornish,NVIDIA
EskilSteenberg,Obsession
EvanHart,ATI
FolkerSchamel,SpinorGMBH
GeoffStahl,Apple
HowardMiller,Apple
IanRomanick,IBM
Version2.1-December1,2006J.6. ACKNOWLEDGEMENTS 355
JamesA.McCombe,Apple
JeffJuliano,NVIDIA
JeffWeyman,ATI
JeremySandmel,Apple/ATI
JohnKessenich,3Dlabs/Intel
JohnRosasco,Apple
JohnScott
JonLeech,SGI
JonTrulson,XiGraphics
KenSeverson,NVIDIA
KennethDyke,Apple
KennethRussell,Sun
KentLin,Intel
MarcOlano,U.Maryland
MarkKilgard,NVIDIA
MichaelGold,NVIDIA
NeerajSrivastava,Dell
NeilTrevett,3Dlabs/NVIDIA
NickBurns,Apple
PatBrown,NVIDIA
PaulMartz,SimAuthor
PaulRamsey,Sun
PierreBoudier,ATI
RalfBiermann,NVIDIA
RandiRost,3Dlabs
RobMace,ATI
RobertSimpson,Bitboys/ATI
SaifuddinFakhruddin,Intel
ShawnUnderwood,SGI
SteveDemlow,VitalImages
SteveKoren,3Dlabs
StevenZhu,Intel
ThomasRoell,NVIDIA
TomLanzoni,Dell
TravisBryson,Sun
YakiTebeka,GraphicRemedy
Version2.1-December1,2006AppendixK
ARBExtensions
OpenGLextensionsthathavebeenapprovedbytheOpenGLArchitecturalReview
Board(ARB)aredescribedinthischapter. Theseextensionsarenotrequiredtobe
supportedbyaconformantOpenGLimplementation,butareexpectedtobewidely
available; they de?ne functionality that is likely to move into the required feature
setinafuturerevisionofthespeci?cation.
In order not to compromise the readability of the core speci?cation, ARB ex-
tensionsarenotintegratedintothecorelanguage;instead,theyaremadeavailable
onlineinthe OpenGL Extension Registry(asareamuchlargernumberofvendor-
speci?c extensions, as well as extensions to GLX and WGL). Extensions are doc-
umented as changes to the Specification. The Registry is available on the World
WideWebatURL
http://www.opengl.org/registry/
BriefdescriptionsofARBextensionsareprovidedbelow.
K.1 NamingConventions
To distinguish ARB extensions from core OpenGL features and from vendor-
speci?cextensions,thefollowingnamingconventionsareused:
• A unique name string of the form "GL ARB name" is associated with each
extension. If the extension is supported by an implementation, this string
willbepresentintheEXTENSIONSstringdescribedinsection6.1.11.
• All functions de?ned by the extension will have names of the form Func-
tionARB
356K.2. PROMOTINGEXTENSIONSTOCOREFEATURES 357
• All enumerants de?ned by the extension will have names of the form
NAME ARB.
• In additional to OpenGL extensions, there are also ARB extensions to the
relatedGLXandWGLAPIs. Suchextensionshavenamestringspre?xedby
"GLX " and "WGL " respectively. Not all GLX and WGL ARB extensions
aredescribedhere,butallsuchextensionsareincludedintheregistry.
K.2 PromotingExtensionstoCoreFeatures
ARB extensions can be promoted to required core features in later revisions of
OpenGL. When this occurs, the extension speci?cations are merged into the core
speci?cation. Functionsandenumerantsthatarepartofsuchpromotedextensions
willhavetheARBaf?xremoved.
GLimplementationsofsuchlaterrevisionsshouldcontinuetoexportthename
stringsofpromotedextensionsintheEXTENSIONSstring,andcontinuetosupport
theARB-af?xedversionsoffunctionsandenumerantsasatransitionaid.
For descriptions of extensions promoted to core features in OpenGL 1.3 and
beyond,seeappendicesF,G,H,andIrespectively.
K.3 Multitexture
ThenamestringformultitextureisGL ARB multitexture. Itwaspromotedtoa
corefeatureinOpenGL1.3.
K.4 TransposeMatrix
ThenamestringfortransposematrixisGL ARB transpose matrix. Itwaspro-
motedtoacorefeatureinOpenGL1.3.
K.5 Multisample
The name string for multisample is GL ARB multisample. It was promoted to a
corefeatureinOpenGL1.3.
Version2.1-December1,2006358 APPENDIXK. ARBEXTENSIONS
K.6 TextureAddEnvironmentMode
The name string for texture add mode is GL ARB texture env add. It was pro-
motedtoacorefeatureinOpenGL1.3.
K.7 CubeMapTextures
The name string for cube mapping is GL ARB texture cube map. It was pro-
motedtoacorefeatureinOpenGL1.3.
K.8 CompressedTextures
The name string for compressed textures is GL ARB texture compression. It
waspromotedtoacorefeatureinOpenGL1.3.
K.9 TextureBorderClamp
The name string for texture border clamp isGL ARB texture border clamp. It
waspromotedtoacorefeatureinOpenGL1.3.
K.10 PointParameters
ThenamestringforpointparametersisGL ARB point parameters. Itwaspro-
motedtoacorefeaturesinOpenGL1.4.
K.11 VertexBlend
Vertex blending replaces the single model-view transformation with multiple ver-
texunits. Eachunithasitsowntransformmatrixandanassociatedcurrentweight.
Verticesaretransformedbyalltheenabledunits,scaledbytheirrespectiveweights,
andsummed tocreatethe eye-spacevertex. Normals aresimilarlytransformed by
theinversetransposeofthemodel-viewmatrices.
ThenamestringforvertexblendisGL ARB vertex blend.
Version2.1-December1,2006K.12. MATRIXPALETTE 359
K.12 MatrixPalette
Matrixpaletteextendsvertexblendingtoincludeapaletteofmodel-viewmatrices.
Each vertex may be transformed by a different set of matrices chosen from the
palette.
ThenamestringformatrixpaletteisGL ARB matrix palette.
K.13 TextureCombineEnvironmentMode
ThenamestringfortexturecombinemodeisGL ARB texture env combine. It
waspromotedtoacorefeatureinOpenGL1.3.
K.14 TextureCrossbarEnvironmentMode
The name string for texture crossbar is GL ARB texture env crossbar. It was
promotedtoacorefeaturesinOpenGL1.4.
K.15 TextureDot3EnvironmentMode
The name string for DOT3 is GL ARB texture env dot3. It was promoted to a
corefeatureinOpenGL1.3.
K.16 TextureMirroredRepeat
The name string for texture mirrored repeat is
GL ARB texture mirrored repeat. It was promoted to a core feature in
OpenGL1.4.
K.17 DepthTexture
ThenamestringfordepthtextureisGL ARB depth texture. Itwaspromotedto
acorefeatureinOpenGL1.4.
K.18 Shadow
ThenamestringforshadowisGL ARB shadow. Itwaspromotedtoacorefeature
inOpenGL1.4.
Version2.1-December1,2006360 APPENDIXK. ARBEXTENSIONS
K.19 ShadowAmbient
Shadow ambient extends the basic image-based shadow functionality by allowing
a texture value speci?ed by theTEXTURE COMPARE FAIL VALUE ARB texture pa-
rameter to be returned when the texture comparison fails. This may be used for
ambientlightingofshadowedfragmentsandotheradvancedlightingeffects.
ThenamestringforshadowambientisGL ARB shadow ambient.
K.20 WindowRasterPosition
The name string for window raster position is GL ARB window pos. It was pro-
motedtoacorefeatureinOpenGL1.4.
K.21 Low-LevelVertexProgramming
Application-de?ned vertexprogramsmaybespeci?edinanewlow-levelprogram-
ming language, replacing the standard ?xed-function vertex transformation, light-
ing,andtexturecoordinategenerationpipeline. Vertexprogramsenablemanynew
effectsandareanimportant?rststeptowardsfuturegraphicspipelinesthatwillbe
fullyprogrammableinanunrestricted,high-levelshadinglanguage.
The name string for low-level vertex programming is
GL ARB vertex program.
K.22 Low-LevelFragmentProgramming
Application-de?ned fragmentprogramsmaybespeci?edinthesamelow-levellan-
guage as GL ARB vertex program, replacing the standard ?xed-function vertex
texturing,fog,andcolorsumoperations.
The name string for low-level fragment programming is
GL ARB fragment program.
K.23 BufferObjects
The name string for buffer objects is GL ARB vertex buffer object. It was
promotedtoacorefeatureinOpenGL1.5.
Version2.1-December1,2006K.24. OCCLUSIONQUERIES 361
K.24 OcclusionQueries
The name string for occlusion queries is GL ARB occlusion query. It was pro-
motedtoacorefeatureinOpenGL1.5.
K.25 ShaderObjects
ThenamestringforshaderobjectsisGL ARB shader objects. Itwaspromoted
toacorefeatureinOpenGL2.0.
K.26 High-LevelVertexProgramming
The name string for high-level vertex programming is GL ARB vertex shader.
ItwaspromotedtoacorefeatureinOpenGL2.0.
K.27 High-LevelFragmentProgramming
The name string for high-level fragment
programming is GL ARB fragment shader. It was promoted to a core feature
inOpenGL2.0.
K.28 OpenGLShadingLanguage
The name string for the OpenGL Shading Language is
GL ARB shading language 100. The presence of this extension string in-
dicates that programs written in version 1 of the Shading Language are accepted
byOpenGL.
ItwaspromotedtoacorefeatureinOpenGL2.0.
K.29 Non-Power-Of-TwoTextures
The name string for non-power-of-two textures is
GL ARB texture non power of two. It was promoted to a core feature in
OpenGL2.0.
Version2.1-December1,2006362 APPENDIXK. ARBEXTENSIONS
K.30 PointSprites
ThenamestringforpointspritesisGL ARB point sprite. Itwaspromotedtoa
corefeatureinOpenGL2.0.
K.31 FragmentProgramShadow
Fragment program shadow extends low-level fragment programs de?ned with
GL ARB fragment program to add shadow 1D, 2D, and 3D texture targets, and
removetheinteractionwithGL ARB shadow.
The name string for fragment program shadow is
GL ARB fragment program shadow.
K.32 MultipleRenderTargets
The name string for multiple render targets is GL ARB draw buffers. It was
promotedtoacorefeatureinOpenGL2.0.
K.33 RectangularTextures
Rectangular textures de?ne a new texture target TEXTURE RECTANGLE ARB that
supports 2D textures without requiring power-of-two dimensions. Rectangular
textures are useful for storing video images that do not have power-of-two sizes
(POTS). Resampling artifacts are avoided and less texture memory may be re-
quired. They are are also useful for shadow maps and window-space texturing.
Thesetexturesareaccessedbydimension-dependent(akanon-normalized)texture
coordinates.
Rectangulartexturesarearestrictedversionofnon-power-of-twotextures. The
differences are that rectangular textures are supported only for 2D; they require a
newtexturetarget;andthenewtargetusesnon-normalizestexturecoordinates
ThenamestringfortexturerectanglesisGL ARB texture rectangle.
K.34 Floating-PointColorBuffers
Floating-point color buffers can represent values outside the normal [0,1] range
of colors in the ?xed-function OpenGL pipeline. This group of related exten-
sionsenablescontrollingclampingofvertexcolors,fragmentcolorsthroughoutthe
pipeline, and pixel data read back to client memory, and also includes WGL and
Version2.1-December1,2006K.35. HALF-PRECISIONFLOATINGPOINT 363
GLX extensions for creating frame buffers with ?oating-point color components
(referredtoinGLXas framebuffer con?gurations,andinWGLas pixel formats).
The name strings for ?oating-point color buffers are
GL ARB color buffer float, GLX ARB fbconfig float, and
WGL ARB pixel format float.
K.35 Half-PrecisionFloatingPoint
Thisextensionde?nestherepresentationofa16-bit?oatingpointdataformat,and
a correspondingtype argument which may be used to specify and read back pixel
andtextureimagesstoredinthisformatinclientmemory. Half-precision?oatsare
smallerthanfullprecision?oats,butprovidealargerdynamicrangethansimilarly
sized(short)datatypes.
The name string for half-precision ?oating point is
GL ARB half float pixel.
K.36 Floating-PointTextures
Floating-pointtexturesstoredinboth32-and16-bitformatsmaybede?nedusing
new internalformat arguments to commands which specify and read back texture
images.
Thenamestringfor?oating-pointtexturesis GL ARB texture float.
K.37 PixelBufferObjects
The buffer object interface is expanded by adding two new binding targets for
bufferobjects,thepixelpackandunpackbuffers. Thispermitsbufferobjectstobe
used to store pixel data as well as vertex array data. Pixel-drawing and -reading
commands using data in pixel buffer objects may operate at greatly improved per-
formancecomparedtodatainclientmemory.
ThenamestringforpixelbufferobjectsisGL ARB pixel buffer object. It
waspromotedtoacorefeatureinOpenGL2.1.
Version2.1-December1,2006Index
x BIAS,117,288 ALPHA16,154
x SCALE,117,288 ALPHA4,154
2D,240,241,303 ALPHA8,154
2 BYTES,243 ALPHA BIAS,139
3D,240,241 ALPHA SCALE,139,185,353
3D COLOR,240,241 ALPHA TEST,204
3D COLOR TEXTURE,240,241 AlphaFunc,204
3 BYTES,243 ALWAYS,169,190,204–207,285
AMBIENT,65,66,68
4D COLOR TEXTURE,240,241
4 BYTES,243 AMBIENT AND DIFFUSE,65,66,68
AND,214
1,152,161,180,253,281 AND INVERTED,214
2,152,161,253,281 AND REVERSE,214
3,152,161,253,281 Antialiasing,107
4,152,161,253 AreTexturesResident,183,244
ARRAY BUFFER,33,35–39,259,260
ACCUM,220,221 ARRAY BUFFER BINDING,38
Accum,220,221 ArrayElement,19,27–29,38,242
ACCUM BUFFER BIT,219,265 ATTACHED SHADERS,261,262
ACTIVE ATTRIBUTE MAX LENGTH, AttachShader,74,244
77,261 AUTO NORMAL,85,233
ACTIVE ATTRIBUTES,77,261 AUXi,215,216
ACTIVE TEXTURE, 21, 47, 55, 184, AUXm,215,216
232,248,249 AUXn,224
ACTIVE UNIFORM MAX LENGTH,
AUX0,215,216,224
81,261
ACTIVE UNIFORMS,80,261 BACK, 64, 66, 67, 108, 109, 111, 205,
ActiveTexture,47,83,192 215–218,224,249,279
ADD,185,187,188,220,221,327 BACK LEFT,215,216,224
BACK RIGHT,215,216,224
ADD SIGNED,188
ALL ATTRIB BITS,264,265 Begin, 12, 15–20, 28, 29, 40, 64, 68, 70,
ALPHA, 117, 130, 141, 142, 152, 154, 87, 101, 105, 108, 111, 234,
235,240
155, 169, 170, 185–187, 190,
211, 224, 226, 251, 253, 288, BeginQuery,207,208
289,291,302,312,318 BGR,130,224,226,251
ALPHA12,154 BGRA,130,132,136,224,251,316
364INDEX 365
BindAttribLocation,78,244 ClearColor,219
BindBuffer,33,39,244
ClearDepth,219
BindTexture,47,83,182,183,353
ClearIndex,219
BITMAP, 110, 118, 121, 127, 129, 136,
ClearStencil,219
149,226,253
CLIENT ACTIVE TEXTURE, 26, 248,
Bitmap,149
249
BITMAP TOKEN,241
CLIENT ALL ATTRIB BITS,264,265
BLEND,185,187,209,213
CLIENT PIXEL STORE BIT,265
BlendColor,212,334
CLIENT VERTEX ARRAY BIT,265
BlendEquation,209,334
ClientActiveTexture,20,26,244
BlendEquationSeparate,209,347
CLIP PLANEi,52,53
BlendFunc,211,334
CLIP PLANE0,53
BlendFuncSeparate,211,335
ClipPlane,52
BLUE, 117, 130, 224, 226, 251, 288,
COEFF,251
289,291,302
COLOR, 43, 47, 48, 120, 124, 125, 161,
BLUE BIAS,139
229
BLUE SCALE,139
Color,19,21,22,57,68,71,76
BOOL,81
Color3,21
BOOL VEC2,81
Color4,21
BOOL VEC3,81
Color[size][type]v,27
BOOL VEC4,81
COLOR ARRAY,26,31
BUFFER ACCESS,34,36,37
COLOR ARRAY POINTER,257
BUFFER MAP POINTER, 34, 36–38,
COLOR BUFFER BIT,219,220,265
260
COLOR INDEX, 110, 118, 121, 127,
BUFFER MAPPED,34,36–38
130, 140, 149, 224, 229, 252,
BUFFER SIZE,34,36
253
BUFFER USAGE,34,36,37
COLOR INDEXES,65,69
BufferData,35,36,244
COLOR LOGIC OP,213
BufferSubData,36,37,244
COLOR MATERIAL,66,68
bvec2,82
COLOR MATRIX,254
BYTE,24,129,226,227,243
COLOR MATRIX STACK DEPTH,
254
C3F V3F,31,32
COLOR SUM,194
C4F N3F V3F,31,32
COLOR TABLE,119,121,140
C4UB V2F,31,32
COLOR TABLE ALPHA SIZE,254
C4UB V3F,31,32
COLOR TABLE BIAS,118,119,254
CallList,19,242,243
COLOR TABLE BLUE SIZE,254
CallLists,19,242,243
COLOR TABLE FORMAT,254
CCW,63,64,279
CLAMP,169,171 COLOR TABLE GREEN SIZE,254
COLOR TABLE INTENSITY SIZE,
CLAMP TO BORDER,169,172,327
254
CLAMP TO EDGE,169,171,172,317
COLOR TABLE LUMINANCE SIZE,
CLEAR,214
254
Clear,219,220
ClearAccum,219 COLOR TABLE RED SIZE,254
Version2.1-December1,2006366 INDEX
COLOR TABLE SCALE, 118–120, CONSTANT,187,189,284
254 CONSTANT ALPHA,211,334
COLOR TABLE WIDTH,254 CONSTANT ATTENUATION,65
ColorMask,217,218 CONSTANT BORDER,143,144
ColorMaterial,66–68,233,309,314 CONSTANT COLOR,211,334
ColorPointer,19,24,25,31,244 CONVOLUTION 1D, 122–124, 141,
ColorSubTable,115,120 158,255
ColorTable,115,118–121,145,146,244 CONVOLUTION 2D, 121–123, 141,
ColorTableParameter,119 158,255
ColorTableParameterfv,118 CONVOLUTION BORDER COLOR,
Colorub,71 143,255
Colorui,71 CONVOLUTION BORDER MODE,
Colorus,71 143,255
COMBINE,185,188,192,327,335 CONVOLUTION FILTER BIAS, 122,
COMBINE ALPHA,185,188,189 123,255
COMBINE RGB,185,188,189 CONVOLUTION FILTER SCALE,
COMPARE R TO TEXTURE, 169, 122–124,255
190 CONVOLUTION FORMAT,255
COMPILE,242,309 CONVOLUTION HEIGHT,255
COMPILE AND EXECUTE,242,243 CONVOLUTION WIDTH,255
ConvolutionFilter1D,115,122–124
COMPILE STATUS,73,260
ConvolutionFilter2D,115,121–124
CompileShader,73,244
ConvolutionParameter,122,143
COMPRESSED ALPHA,155
ConvolutionParameterfv,122,123,143
COMPRESSED INTENSITY,155
ConvolutionParameteriv,123,143
COMPRESSED LUMINANCE,155
COORD REPLACE,96,100
COMPRESSED LUMINANCE ALPHA,
COPY,213,214,286
155
COMPRESSED RGB,155 COPY INVERTED,214
COMPRESSED RGBA,155 COPY PIXEL TOKEN,241
COMPRESSED SLUMINANCE, 155, CopyColorSubTable,120
191 CopyColorTable,120
COMPRESSED SLUMINANCE ALPHA, CopyConvolutionFilter1D,124
155,191 CopyConvolutionFilter2D,123
COMPRESSED SRGB,155,191 CopyPixels, 114, 116, 120, 124, 141,
COMPRESSED SRGB ALPHA, 155, 161,221,226,228,239
191 CopyTexImage1D,141,161,163,177
COMPRESSED TEXTURE FORMATS, CopyTexImage2D, 141, 159, 161, 163,
153 177
CompressedTexImage,167 CopyTexImage3D,163
CompressedTexImage1D,165–167 CopyTexSubImage1D,141,162–165
CompressedTexImage2D,165–167 CopyTexSubImage2D, 141, 162, 164,
CompressedTexImage3D,165–167 165
CompressedTexSubImage1D,166–168 CopyTexSubImage3D, 141, 162, 163,
CompressedTexSubImage2D,166–168 165
CompressedTexSubImage3D,167,168 CreateProgram,74,244
Version2.1-December1,2006INDEX 367
CreateShader,72,244,346 DetachShader,74,244
CreateShaderObjectARB,346 dFdx,246
CULL FACE,108 dFdy,246
CullFace,108,109,113 DIFFUSE,65,66
CURRENT BIT,265 Disable, 47, 48, 51, 53, 59, 63, 66, 94–
CURRENT FOG COORD,341 96, 102, 104, 108, 110, 112,
CURRENT FOG COORDINATE,341 145–147, 191, 194, 203–206,
209,213,232,233
CURRENT QUERY,258
DisableClientState,19,26,31,33,244
CURRENT RASTER SECONDARY COLOR,
DisableVertexAttribArray,26,244,263
352
DITHER,213
CURRENT RASTER TEXTURE COORDS,
55,308 DOMAIN,251
CURRENT TEXTURE COORDS,21 DONT CARE,246,297
CURRENT VERTEX ATTRIB,263 DOT3 RGB,188
CW,64 DOT3 RGBA,188
DOUBLE,24,27
DECAL,185,186
DRAW PIXEL TOKEN,241
DECR,206
DrawArrays,28,29,38,242
DECR WRAP,206,335
DrawBuffer,213,215–218,220
DELETE STATUS,73,260,261
DrawBuffers,215–217
DeleteBuffers,34,244
DrawElements,29,30,38,39,242,318
DeleteLists,244
DrawPixels, 110, 113–116, 118, 121,
DeleteProgram,75,244
127–132, 136, 138, 141, 148,
DeleteQueries,208,244
149, 151, 152, 221, 222, 226,
DeleteShader,73,244
229,239,352
DeleteTextures,183,244
DrawRangeElements, 30, 38, 39, 242,
DEPTH, 118, 122, 125, 126, 161, 229,
300
288,334
DST ALPHA,211
DEPTH BIAS,117,139
DST COLOR,211,334
DEPTH BUFFER BIT,219,220,265
DYNAMIC COPY,34,36
DEPTH COMPONENT, 86, 118, 121,
DYNAMIC DRAW,34,35
127, 130, 152–154, 190, 198,
DYNAMIC READ,34,36
222, 225, 229, 251, 252, 254–
256,349
EDGE FLAG ARRAY,26,31
DEPTH COMPONENT16,154
EDGE FLAG ARRAY POINTER,257
DEPTH COMPONENT24,154
EdgeFlag,19
DEPTH COMPONENT32,154
EdgeFlagPointer,19,24,25,244
DEPTH SCALE,117,139
EdgeFlagv,19,27
DEPTH TEST,206 ELEMENT ARRAY BUFFER, 33, 35,
DEPTH TEXTURE MODE, 169, 181, 37–39,259,260
190 EMISSION,65,66
DepthFunc,207 Enable,47,48,51,53,59,63,66,94–96,
DepthMask,218,222 102, 104, 108, 110, 112, 145–
DepthRange,42,57,248,309 147, 191, 194, 203–206, 209,
DepthTest,222 213,232,233,247
Version2.1-December1,2006368 INDEX
ENABLE BIT,265 FLOAT MAT2x3,77,81,353
EnableClientState,19,26,31,33,244 FLOAT MAT2x4,77,81,353
EnableVertexAttribArray,26,244,263 FLOAT MAT3,77,81
End, 12, 15–20, 28, 29, 40, 64, 68, 70, FLOAT MAT3x2,77,81,353
101,108,111,234,235,240 FLOAT MAT3x4,77,81,353
EndList,242 FLOAT MAT4,77,81
EndQuery,207,208 FLOAT MAT4x2,77,81,353
EQUAL,169,190,205–207 FLOAT MAT4x3,77,81,353
EQUIV,214 FLOAT VEC2,77,81
FLOAT VEC3,77,81
EVAL BIT,265
FLOAT VEC4,77,81
EvalCoord,19,232,233
Flush,244,245,308
EvalCoord1,233–235
EvalCoord1d,234 FOG,194
EvalCoord1f,234 Fog,194,195
EvalCoord2,233,235,236 FOG BIT,265
EvalMesh1,234 FOG COLOR,195
EvalMesh2,234,235 FOG COORD,55,194,195,341,348
EvalPoint,19 FOG COORD ARRAY,26,31,341
EvalPoint1,235 FOG COORD ARRAY BUFFER BINDING,
EvalPoint2,235 341,348
EXP,195,196,276 FOG COORD ARRAY POINTER,
EXP2,195 257,341
EXT pixel buffer object,354 FOG COORD ARRAY STRIDE,341
EXT texture sRGB,354 FOG COORD ARRAY TYPE,341
EXTENSIONS,116,257,258,356,357 FOG COORD SRC, 57, 195, 196, 341,
EYE LINEAR,50–52,250,284 348
EYE PLANE,50,51 FOG COORDINATE,341,348
FOG COORDINATE ARRAY,341
FALSE, 19, 34, 36, 38, 61–63, 73–75, FOG COORDINATE ARRAY BUFFER BINDING,
82, 88, 89, 96, 114, 115, 117, 341
125, 126, 136, 139, 147, 148,
FOG COORDINATE ARRAY POINTER,
169, 180, 183, 198, 204, 208,
341
222, 224, 248, 253, 256–261,
FOG COORDINATE ARRAY STRIDE,
282
341
FASTEST,246
FOG COORDINATE ARRAY TYPE,
FEEDBACK,237–239,310
341
FEEDBACK BUFFER POINTER,257
FOG COORDINATE SOURCE, 334,
FeedbackBuffer,238,239,244
341
FILL,111–113,234,279,309,312 FOG DENSITY,195
Finish,244,245,308 FOG END,195
FLAT,70,309 FOG HINT,246
FLOAT,24,27,31–33,77,81,129,225, FOG INDEX,195
227,243,251,252,271,272 FOG MODE,195,196
?oat,76 FOG START,195
FLOAT MAT2,77,81 FogCoord,19,21,334
Version2.1-December1,2006INDEX 369
FogCoord[type]v,27 GetConvolutionParameter,255
FogCoordPointer,19,24,25,244 GetConvolutionParameteriv,122,123
FRAGMENT DEPTH,194–196,276 GetDoublev,247,248,266,268
FRAGMENT SHADER,196,260 GetError,11
FRAGMENT SHADER DERIVATIVE HINT, GetFloatv,204,247,248,253,254,266,
246 268
FRONT, 64, 66, 68, 108, 109, 111, 205, GetHistogram,126,224,255,348
215–218,224,249 GetHistogramParameter,256
FRONT AND BACK, 64, 66–68, 108, GetIntegerv, 30, 94, 217, 247, 248, 254,
111,205,215–218 266,268
FRONT LEFT,215,216,224 GetLight,249
FRONT RIGHT,215,216,224 GetMap,249,251
FrontFace,63,108,199 GetMaterial,249
Frustum,44,46,309 GetMinmax,224,256
GetMinmaxParameter,257
ftransform,87
GetPixelMap,249,251
FUNC ADD,209,210,212,286
GetPixelMapfv,251
FUNC REVERSE SUBTRACT, 209,
GetPixelMapuiv,251
210,353
GetPixelMapusv,251
FUNC SUBTRACT,209,210
GetPointerv,257
fwidth,246
GetPolygonStipple,224,253
GenBuffers,34,244 GetProgramInfoLog,75,262
GENERATE MIPMAP, 169, 170, 178, GetProgramiv, 74, 77, 80, 81, 88, 261,
181,333 262
GENERATE MIPMAP HINT,246 GetQueryiv,258
GenLists,243,244 GetQueryObject[u]iv,259
GenQueries,208,244 GetQueryObjectiv,259
GenTextures,183,244,253 GetQueryObjectuiv,259
GEQUAL,169,190,205–207,340 GetSeparableFilter,224,255
Get,21,43,54,244,247,248 GetShaderInfoLog,73,262
GetActiveAttrib,76,77,353
GetShaderiv,73,260,262
GetActiveUniform,80–82,353
GetShaderSource,262
GetAttachedShaders,261
GetString,257,258
GetAttribLocation,77,78
GetTexEnv,249,354
GetBooleanv,204,247,248,266,268
GetTexGen,249,250
GetBufferParameter,249
GetTexImage, 182, 224, 251, 252, 254–
GetBufferParameteriv,249
256
GetBufferPointerv,260
GetTexLevelParameter,249,250
GetBufferSubData,259,260 GetTexParameter,249,250
GetClipPlane,249 GetTexParameterfv,182,183
GetColorTable,121,224,254 GetTexParameteriv,182,183
GetColorTableParameter,254 GetUniform*,264
GetCompressedTexImage, 166–168, GetUniformfv,263
246,250,252 GetUniformiv,263
GetConvolutionFilter,224,255 GetUniformLocation,79,81,83
Version2.1-December1,2006370 INDEX
GetVertexAttribdv,263 GL ARB vertex buffer object, 339,
340,360
GetVertexAttribfv,263
GL ARB vertex program,333,336,360
GetVertexAttribiv,263
GL ARB vertex shader, 339, 341, 345,
GetVertexAttribPointerv,263
361
GL ARB color buffer ?oat,363
GL ARB window pos,336,360
GL ARB depth texture,334,359
GL ATI separate stencil,347
GL ARB draw buffers,346,362
gl BackColor,63
GL ARB fragment program, 340, 360,
gl BackSecondaryColor,63
362
gl ClipVertex,53
GL ARB fragment program shadow,
gl Color,198
362
GL EXT bgra,316
GL ARB fragment shader, 339, 340,
GL EXT blend color,320
345,361
GL EXT blend equation separate,347
GL ARB half ?oat pixel,363
GL EXT blend func separate,335
GL ARB matrix palette,359
GL EXT blend logic op,312,347
GL ARB multisample,326,357
GL EXT blend minmax,320
GL ARB multitexture,327,357
GL EXT blend subtract,320
GL ARB occlusion query,340,361
GL EXT color subtable,319
GL ARB pixel buffer object,352,363
GL EXT color table,319
GL ARB point parameters,335,358
GL EXT convolution,319
GL ARB point sprite,347,362
GL EXT copy texture,313
GL ARB shader objects, 339, 341, 345,
GL EXT draw range elements,318
361
GL EXT fog coord,334
GL ARB shading language 100, 346,
GL EXT histogram,320
361
GL EXT multi draw arrays,334
GL ARB shadow,334,359,362
GL EXT packed pixels,317
GL ARB shadow ambient,360
GL EXT polygon offset,312
GL ARB texture border clamp, 328,
GL EXT rescale normal,317
358
GL EXT secondary color,335
GL ARB texture compression,325,358
GL EXT separate specular color,317
GL ARB texture cube map,326,358
GL EXT shadow funcs,340
GL ARB texture env add,327,358
GL EXT stencil two side,347
GL ARB texture env combine, 327,
GL EXT stencil wrap,335
359
GL EXT subtexture,313
GL ARB texture env crossbar,336,359
GL EXT texture,312,313
GL ARB texture env dot3,327,359
GL EXT texture3D,316
GL ARB texture ?oat,363
GL EXT texture lod bias,336
GL ARB texture mirrored repeat, 336,
GL EXT texture object,313
359
GL EXT texture sRGB,352
GL ARB texture non power of two,
GL EXT vertex array,311
346,361
gl FogFragCoord,55
GL ARB texture rectangle,362
gl FragColor,199,216
GL ARB transpose matrix,328,357
gl FragCoord,198
GL ARB vertex blend,358 gl FragCoord.z,307
Version2.1-December1,2006INDEX 371
gl FragData,199,216 INDEX ARRAY POINTER,257
gl FragData[n],199 INDEX LOGIC OP,213
gl FragDepth,199,307 INDEX OFFSET,117,139,288
gl FrontColor,63 INDEX SHIFT,117,139,288
gl FrontFacing,198 IndexMask,217,218
gl FrontSecondaryColor,63 IndexPointer,20,24,25,244
GL HP convolution border modes,319 INFO LOG LENGTH,261,262
GL NV blend square,334 InitNames,236
GL PERSPECTIVE CORRECT HINT, INT,24,81,129,226,227,243
352 INT VEC2,81
gl PointSize,95 INT VEC3,81
gl Position,84 INT VEC4,81
gl SecondaryColor,198 INTENSITY, 125, 126, 141, 142, 152,
GL SGI color matrix,319 154, 155, 169, 170, 186, 187,
GL SGIS generate mipmap,333 190,253,289,312
GL SGIS multitexture,324 INTENSITY12,154
GL SGIS texture edge clamp,318 INTENSITY16,154
GL SGIS texture lod,318 INTENSITY4,154
GLX ARB fbcon?g ?oat,363 INTENSITY8,154
GREATER,169,190,205–207 InterleavedArrays,20,31,32,244
GREEN, 117, 130, 224, 226, 251, 288, INTERPOLATE,188
289,291,302 INVALID ENUM, 12, 27, 47, 51, 64,
GREEN BIAS,139 115, 121, 125–127, 161, 165,
GREEN SCALE,139 167,182,252,254–256
INVALID OPERATION,12,19,34,37–
Hint,245 39, 47, 72, 74, 75, 78, 80, 82–
HINT BIT,265 84,87,88,115,117,127,131,
HISTOGRAM,125,126,147,255,256 153, 157, 161, 165–168, 182,
Histogram,125,126,147,244 208, 215–217, 221, 222, 224,
HISTOGRAM ALPHA SIZE,256 226, 232, 237, 239, 242, 249–
HISTOGRAM BLUE SIZE,256 253,259,260,263,264
HISTOGRAM FORMAT,256 INVALID VALUE, 12, 22, 24, 26, 28–
HISTOGRAM GREEN SIZE,256 30, 36, 43, 46, 64, 72, 77, 78,
HISTOGRAM LUMINANCE SIZE, 80,95,96,102,114,116,117,
256 119, 120, 122, 123, 125, 152,
HISTOGRAM RED SIZE,256 156–158, 161–164, 166, 167,
177, 183, 195, 203, 217, 219,
HISTOGRAM SINK,256
231, 232, 234, 242, 250, 252,
HISTOGRAM WIDTH,256
260,263,353
INCR,206 INVERT,206,214
INCR WRAP,206,335 Is,244
INDEX,302 IsBuffer,259
Index,19,22 IsEnabled,203,247,266,268
Index[type]v,27 IsList,244
INDEX ARRAY,26,31 IsProgram,261
Version2.1-December1,2006372 INDEX
IsQuery,258 LoadIdentity,44
IsShader,260 LoadMatrix,43,44
IsTexture,253 LoadMatrix[fd],44
LoadName,236,237
KEEP,206,285 LoadTransposeMatrix,44
LoadTransposeMatrix[fd],44
LEFT,215–217,224
LOGIC OP,213,347,349
LEQUAL,169,181,190,204,206,207,
LogicOp,213,214
282,340
LOWER LEFT,96,100
LESS,169,190,204,206,207,285
LUMINANCE,130,137,141,142,152,
Light,64–66
154, 155, 169, 170, 181, 186,
LIGHTi,64,66,310 187, 190, 224–226, 251, 253,
LIGHT0,64 282,289,291,312
LIGHT MODEL AMBIENT,65 LUMINANCE12,154
LIGHT MODEL COLOR CONTROL, LUMINANCE12 ALPHA12,154
65
LUMINANCE12 ALPHA4,154
LIGHT MODEL LOCAL VIEWER,
LUMINANCE16,154
65
LUMINANCE16 ALPHA16,154
LIGHT MODEL TWO SIDE,65
LUMINANCE4,154
LIGHTING,59
LUMINANCE4 ALPHA4,154
LIGHTING BIT,265
LUMINANCE6 ALPHA2,154
LightModel,64,65
LUMINANCE8,154
LINE,111–113,234,235,279,312
LUMINANCE8 ALPHA8,154
LINE BIT,265
LUMINANCE ALPHA, 130, 137, 141,
LINE LOOP,16
142, 152, 154, 155, 186, 187,
LINE RESET TOKEN,241
224–226,251,253
LINE SMOOTH,102,107
LINE SMOOTH HINT,246 Map1,230–232,248
LINE STIPPLE,104 MAP1 COLOR 4,231
LINE STRIP,15,234 MAP1 INDEX,231
LINE TOKEN,241 MAP1 NORMAL,231
LINEAR,169,175,177–179,181,195 MAP1 TEXTURE COORD 1,231,233
LINEAR ATTENUATION,65 MAP1 TEXTURE COORD 2,231,233
LINEAR MIPMAP LINEAR,169,177, MAP1 TEXTURE COORD 3,231
178 MAP1 TEXTURE COORD 4,231
LINEAR MIPMAP NEAREST, 169, MAP1 VERTEX 3,231
177 MAP1 VERTEX 4,231
LINES,16,105 Map2,231,232,248
LineStipple,104 MAP2 VERTEX 3,233
LineWidth,102 MAP2 VERTEX 4,233
LINK STATUS,74,261
MAP COLOR,117,139,140
LinkProgram,74,75,77,78,80,83,244 MAP STENCIL,117,140
LIST BIT,265 MAP VERTEX 3,233
ListBase,243,245 MAP VERTEX 4,233
LOAD,220,221 Map{12},232
Version2.1-December1,2006INDEX 373
MapBuffer,36,37,244 MAX VARYING FLOATS,84
MapGrid1,234 MAX VERTEX ATTRIBS, 22–24, 26,
MapGrid2,234 33,76,78,263
mat2,76 MAX VERTEX TEXTURE IMAGE UNITS,
mat2x3,76 85
mat2x4,76 MAX VERTEX UNIFORM COMPONENTS,
mat3,76 79
mat3x2,76 MAX VIEWPORT DIMS,258
mat3x4,76 MIN,209,210
mat4,76 MINMAX,126,147,256,257
mat4x2,76 Minmax,126,148
MINMAX FORMAT,257
mat4x3,76
MINMAX SINK,257
Material,19,64,65,69,309
MIRRORED REPEAT,169,172,336
MATRIX MODE,47
MatrixMode,43 MODELVIEW,43,47,48
MAX,209,210 MODELVIEW MATRIX,248
MAX 3D TEXTURE SIZE,157 MODULATE,185–188,284
MAX ATTRIB STACK DEPTH,264 MULT,220,221
MAX CLIENT ATTRIB STACK DEPTH, MultiDrawArrays,29,38,334
264 MultiDrawElements,30,38,39,334
MAX COLOR MATRIX STACK DEPTH, MULTISAMPLE, 94, 101, 107, 113,
254 148,150,203,213,214
MAX COMBINED TEXTURE IMAGE UNITS,MULTISAMPLE BIT,265
47,86,249 MultiTexCoord,19–21,27
MAX CONVOLUTION HEIGHT, 122, MultiTexCoord[size][type]v,27
255 MultMatrix,43,44
MAX CONVOLUTION WIDTH, 122, MultMatrix[fd],44
123,255 MultTransposeMatrix,44
MAX CUBE MAP TEXTURE SIZE, MultTransposeMatrix[fd],44
157
N3F V3F,31,32
MAX DRAW BUFFERS,217
NAND,214
MAX ELEMENTS INDICES,30
NEAREST,169,174,177,178,191
MAX ELEMENTS VERTICES,30
NEAREST MIPMAP LINEAR, 169,
MAX EVAL ORDER,231,232
177–179,181
MAX FRAGMENT UNIFORM COMPONENTS,
NEAREST MIPMAP NEAREST, 169,
196
177,179,191
MAX PIXEL MAP TABLE,117,139
NEVER,169,190,204,206,207
MAX TEXTURE COORDS, 21, 23,
33,47,249,348 NewList,242,243
MAX TEXTURE IMAGE UNITS, 85, NICEST,246
198,348 NO ERROR,11
MAX TEXTURE LOD BIAS,173 NONE, 86, 169, 181, 190, 198, 213,
MAX TEXTURE SIZE,157 215–217,220,282
MAX TEXTURE UNITS, 13, 47, 192, NOOP,214
266,348 NOR,214
Version2.1-December1,2006374 INDEX
Normal,19,21,76 PACK ROW LENGTH,224,288
Normal3,8,21 PACK SKIP IMAGES,224,252,288
Normal3[type]v,27 PACK SKIP PIXELS,224,288
Normal3d,8 PACK SKIP ROWS,224,288
Normal3dv,8 PACK SWAP BYTES,224,288
Normal3f,8 PASS THROUGH TOKEN,241
PassThrough,240
Normal3fv,8
PERSPECTIVE CORRECTION HINT,
NORMAL ARRAY,26,31,33
246
NORMAL ARRAY BUFFER BINDING,
PIXEL MAP A TO A,118,139
38
PIXEL MAP B TO B,118,139
NORMAL ARRAY POINTER,257
PIXEL MAP G TO G,118,139
NORMAL MAP,50,51,326
PIXEL MAP I TO A,118,140
NORMALIZE,49
PIXEL MAP I TO B,118,140
NormalPointer,20,24,25,31,38,244
PIXEL MAP I TO G,118,140
NOTEQUAL,169,190,205–207
PIXEL MAP I TO I,118,140
NULL, 33, 34, 36–38, 40, 73, 77, 80,
260,262,267 PIXEL MAP I TO R,118,140
NUM COMPRESSED TEXTURE FORMATS, PIXEL MAP R TO R,118,139
153 PIXEL MAP S TO S,118,140
PIXEL MODE BIT,265
OBJECT LINEAR,50,52,250
PIXEL PACK BUFFER, 33, 35, 37, 38,
OBJECT PLANE,50,51
114,222,259,260,352
ONE,211,212,286
PIXEL PACK BUFFER BINDING,
ONE MINUS CONSTANT ALPHA, 226,251,252
211,334 PIXEL UNPACK BUFFER, 33, 35, 37,
ONE MINUS CONSTANT COLOR, 38,114,259,260,352
211,334 PIXEL UNPACK BUFFER BINDING,
117,127,165
ONE MINUS DST ALPHA,211
ONE MINUS DST COLOR,211,334 PixelMap,114,116–118,229
ONE MINUS SRC ALPHA,189,211 PixelStore,20,114–116,224,229,244
ONE MINUS SRC COLOR, 189, 211, PixelTransfer,114,116,117,145,229
333 PixelZoom,138,148
OPERANDn ALPHA, 185, 189, 192, POINT,111–113,234,235,279,312
353 POINT BIT,265
OPERANDn RGB,185,189,192,353 POINT DISTANCE ATTENUATION,
OR,214 96
OR INVERTED,214 POINT FADE THRESHOLD SIZE,96
OR REVERSE,214 POINT SIZE MAX,96
ORDER,251 POINT SIZE MIN,96
Ortho,44,46,309 POINT SMOOTH,96,101
OUT OF MEMORY,11,12,36,37,242 POINT SMOOTH HINT,246
POINT SPRITE,96,101,184,185,249,
PACK ALIGNMENT,224,288 354
PACK IMAGE HEIGHT,224,252,288 POINT SPRITE COORD ORIGIN, 96,
PACK LSB FIRST,224,288 100,347,348
Version2.1-December1,2006INDEX 375
POINT TOKEN,241 POST CONVOLUTION x SCALE,
PointParameter,96,335 117
PointParameter*,96
POST CONVOLUTION ALPHA BIAS,
POINTS,15,234
145
PointSize,95
POST CONVOLUTION ALPHA SCALE,
POLYGON,16,19
145
POLYGON BIT,265
POST CONVOLUTION BLUE BIAS,
POLYGON OFFSET FILL,112
145
POLYGON OFFSET LINE,112
POST CONVOLUTION BLUE SCALE,
POLYGON OFFSET POINT,112
145
POLYGON SMOOTH,108,113
POST CONVOLUTION COLOR TABLE,
POLYGON SMOOTH HINT,246
119,145,146
POLYGON STIPPLE,110
POST CONVOLUTION GREEN BIAS,
POLYGON STIPPLE BIT,265
145
POLYGON TOKEN,241
POST CONVOLUTION GREEN SCALE,
PolygonMode,107,111,113,237,239
145
PolygonOffset,112
POST CONVOLUTION RED BIAS,
PolygonStipple,110,115
145
PopAttrib,264,266,310,353
POST CONVOLUTION RED SCALE,
PopClientAttrib,19,244,264,266
145
PopMatrix,48
PREVIOUS,187,189,284
PopName,236
PRIMARY COLOR,189
POSITION,65,249
PrioritizeTextures,184
POST COLOR MATRIX x BIAS,117
PROJECTION,43,47,48
POST COLOR MATRIX x SCALE,
PROXY COLOR TABLE, 119, 121,
117
245
POST COLOR MATRIX ALPHA BIAS,
PROXY HISTOGRAM, 125, 126, 245,
146
256
POST COLOR MATRIX ALPHA SCALE,
PROXY POST COLOR MATRIX COLOR TABLE,
146
119,245
POST COLOR MATRIX BLUE BIAS,
PROXY POST CONVOLUTION COLOR TABLE,
146
119,245
POST COLOR MATRIX BLUE SCALE,
PROXY TEXTURE 1D, 152, 158, 181,
146
182,245,250
POST COLOR MATRIX COLOR TABLE,
PROXY TEXTURE 2D, 152, 158, 181,
119,146
182,244,250
POST COLOR MATRIX GREEN BIAS,
PROXY TEXTURE 3D, 151, 181, 182,
146
244,250
POST COLOR MATRIX GREEN SCALE,
PROXY TEXTURE CUBE MAP, 158,
146
181,182,245,250
POST COLOR MATRIX RED BIAS,
PushAttrib,264,266,353
146
PushClientAttrib,19,244,264,266
POST COLOR MATRIX RED SCALE,
PushMatrix,48
146
POST CONVOLUTION x BIAS,117 PushName,236
Version2.1-December1,2006376 INDEX
Q,50,51,250 RGB5,154
QUAD STRIP,18 RGB5 A1,154
QUADRATIC ATTENUATION,65 RGB8,154
QUADS,18,19 RGB SCALE,185,353
QUERY COUNTER BITS,258 RGBA, 120, 121, 124, 126, 130, 132,
QUERY RESULT,259 136, 141, 142, 152, 154, 155,
QUERY RESULT AVAILABLE,259 186, 187, 224, 229, 251, 253,
289–292
R,50,51,250 RGBA12,154
R3 G3 B2,154 RGBA16,154
RasterPos,54,87,237,309,336 RGBA2,154
RasterPos2,54 RGBA4,154
RasterPos3,54 RGBA8,154
RasterPos4,54
RIGHT,215–217,224
READ ONLY,34,37
Rotate,44,45,309
READ WRITE,34,36,37
ReadBuffer,222,224,229 S,50,51,250
ReadPixels, 114, 116, 129, 130, 132, SAMPLE ALPHA TO COVERAGE,
141, 221–224, 226, 229, 244, 203
252–254,352 SAMPLE ALPHA TO ONE,203,204
Rect,40,108 SAMPLE BUFFERS,94,101,107,113,
RED,117,130,224,226,251,288,289, 148, 150, 203, 208, 213, 214,
291,302 218,222
RED BIAS,139 SAMPLE COVERAGE,203,204
RED SCALE,139 SAMPLE COVERAGE INVERT, 203,
REDUCE,143,145,290 204
REFLECTION MAP,50,51,326 SAMPLE COVERAGE VALUE, 203,
RENDER,237,238,303 204
RENDERER,257,258 SampleCoverage,204
RenderMode,237–239,244 sampler1D,86,198
REPEAT,169,171,175,176,181,282 sampler1DShadow,86,197,198
REPLACE,185,186,188,206 sampler2D,83,86,198
REPLICATE BORDER,143,144 sampler2DShadow,86,198
RESCALE NORMAL,49 SAMPLER 1D,81
ResetHistogram,256 SAMPLER 1D SHADOW,81
SAMPLER 2D,81
ResetMinmax,257
SAMPLER 2D SHADOW,81
RETURN,220,221
SAMPLER 3D,81
RGB,130,132,136,141,142,152,154,
SAMPLER CUBE,81
155, 185–187, 211, 224, 226,
251,253,312 SAMPLES,94,208
RGB10,154 SAMPLES PASSED,207
RGB10 A2,154 Scale,44,45,309
RGB12,154 Scissor,203
RGB16,154 SCISSOR BIT,265
RGB4,154 SCISSOR TEST,203
Version2.1-December1,2006INDEX 377
SECONDARY COLOR ARRAY, 26, SRC1 RGB,341
31 SRC2 ALPHA,341
SECONDARY COLOR ARRAY POINTER, SRC2 RGB,341
257 SRC ALPHA,187,189,211,284
SecondaryColor,19,22,335 SRC ALPHA SATURATE,211
SecondaryColor3,21,347 SRC COLOR,187,189,211,284,333
SecondaryColor3[type]v,27 SRCn ALPHA,185,189,192,353
SecondaryColorPointer,20,24,25,244 SRCn RGB,185,189,192,353
SELECT,237,238,310
SRGB,191
SelectBuffer,237,238,244
SRGB8,155,191
SELECTION BUFFER POINTER,257
SRGB8 ALPHA8,155,191
SEPARABLE 2D,123,141,158,255
SRGB ALPHA,191
SeparableFilter2D,115,123
STACK OVERFLOW,12,48,237,264
SEPARATE SPECULAR COLOR,62
STACK UNDERFLOW, 12, 48, 237,
SET,214
264
ShadeModel,70
STATIC COPY,34,35
SHADER SOURCE LENGTH, 261,
STATIC DRAW,34,35
262
STATIC READ,34,35
SHADER TYPE,88,260
STENCIL,229
ShaderSource,72,73,244,262
STENCIL BUFFER BIT,219,220,265
SHADING LANGUAGE VERSION,
STENCIL INDEX, 118, 121, 127, 130,
258,346,351
138, 151, 221, 222, 225, 229,
SHININESS,65
252
SHORT,24,129,226,227,243
STENCIL TEST,205
SINGLE COLOR,61,62,277
StencilFunc,205,206,308
SLUMINANCE,155,191
StencilFuncSeparate,205,206
SLUMINANCE8,191
StencilMask,218,222,308
SLUMINANCE8 ALPHA8,191
StencilMaskSeparate,218,222
SLUMINANCE ALPHA,191
StencilOp,205,206
SLUMINANCE ALPHA8,155
StencilOpSeparate,205,206
SMOOTH,70,276
STREAM COPY,34,35
SOURCE0 ALPHA,341
STREAM DRAW,34,35
SOURCE0 RGB,341
STREAM READ,34,35
SOURCE1 ALPHA,341
SUBTRACT,188
SOURCE1 RGB,341
T,50,250
SOURCE2 ALPHA,341
T2F C3F V3F,31,32
SOURCE2 RGB,341
T2F C4F N3F V3F,31,32
SPECULAR,65,66
T2F C4UB V3F,31,32
SPHERE MAP,50–52,326
T2F N3F V3F,31,32
SPOT CUTOFF,65
SPOT DIRECTION,65,249 T2F V3F,31,32
SPOT EXPONENT,65 T4F C4F N3F V4F,31,32
SRC0 ALPHA,341 T4F V4F,31,32
SRC0 RGB,341 TABLE TOO LARGE,12,119,125
SRC1 ALPHA,341 TexCoord,19–21
Version2.1-December1,2006378 INDEX
TexCoord1,20 TEXTURE BASE LEVEL, 157, 168,
TexCoord2,20 169,177,181
TexCoord3,20 TEXTURE BIT,264,265,353
TexCoord4,20 TEXTURE BLUE SIZE,250
TexCoordPointer,20,24–26,31,244 TEXTURE BORDER,166,168,250
TexEnv,47,184,192,353 TEXTURE BORDER COLOR, 168,
TexEnv*,96 169,176,180,181
TexGen,47,50,51,249 TEXTURE COMPARE FAIL VALUE ARB,
360
TexImage,47,163
TEXTURE COMPARE FUNC, 169,
TexImage1D, 115, 141, 143, 155, 158,
181,187,190
159, 161, 162, 165, 177, 181,
244 TEXTURE COMPARE MODE, 86,
169,181,187,190,198,334
TexImage2D, 115, 141, 143, 155, 157–
159, 161, 162, 165, 177, 181, TEXTURE COMPONENTS,251
244,352 TEXTURE COMPRESSED IMAGE SIZE,
TexImage3D, 115, 151, 155, 156, 158, 166,167,250,252
159, 162, 165, 177, 181, 244, TEXTURE COMPRESSION HINT,
252 246
TexParameter,47,168 TEXTURE COORD ARRAY,26,31
TexParameter[if],173,177 TEXTURE COORD ARRAY POINTER,
TexParameterf,184 257
TexParameterfv,184 TEXTURE CUBE MAP,158,168,182,
183,191,250,281
TexParameteri,184
TEXTURE CUBE MAP *,158
TexParameteriv,184
TEXTURE CUBE MAP NEGATIVE X,
TexSubImage,163
157,161,162,170,250,251
TexSubImage1D, 115, 141, 162, 164,
TEXTURE CUBE MAP NEGATIVE Y,
165,167
157,161,162,170,250,251
TexSubImage2D, 115, 141, 162, 164,
TEXTURE CUBE MAP NEGATIVE Z,
165,167
157,161,162,170,250,251
TexSubImage3D, 115, 162, 163, 165,
TEXTURE CUBE MAP POSITIVE X,
167
157, 158, 161, 162, 170, 250,
TEXTURE,43,46–48,187,189,284
251
TEXTUREi,21,47
TEXTURE CUBE MAP POSITIVE Y,
TEXTURE0, 21, 27, 33, 47, 48, 232,
157,161,162,170,250,251
239,266,271,284
TEXTURE CUBE MAP POSITIVE Z,
TEXTURE1,266
157,161,162,170,250,251
TEXTURE xD,281
TEXTURE DEPTH,166–168,250
TEXTURE 1D,152,158,161,162,168,
TEXTURE DEPTH SIZE,250
182,183,191,250,251
TEXTURE 2D, 47, 83, 152, 157, 161, TEXTURE ENV,184,185,249
162, 168, 182, 183, 191, 250, TEXTURE ENV COLOR,185
251 TEXTURE ENV MODE,185,192,327
TEXTURE 3D,151,162,168,181–183, TEXTURE FILTER CONTROL, 184,
191,250,251 185,249
TEXTURE ALPHA SIZE,250 TEXTURE GEN MODE,50–52
Version2.1-December1,2006INDEX 379
TEXTURE GEN Q,52 TRIANGLE STRIP,16,17
TEXTURE GEN R,52
TRIANGLES,17,19
TEXTURE GEN S,51
TRUE,19,26,34,37,38,54,61–63,73,
TEXTURE GEN T,51
74, 82, 88, 96, 100, 114, 115,
TEXTURE GREEN SIZE,250
117, 125, 126, 169, 170, 178,
TEXTURE HEIGHT,166–168,250
183, 198, 204, 207, 217, 224,
TEXTURE INTENSITY SIZE,250
244,248,253,256–261,333
TEXTURE INTERNAL FORMAT,
166–168,251
Uniform,81
TEXTURE LOD BIAS, 169, 173, 185,
Uniform*,79,82,83
336
Uniform*f{v},81,82
TEXTURE LUMINANCE SIZE,250
Uniform*i{v},82
TEXTURE MAG FILTER, 169, 178,
Uniform1i{v},82,83
181,191
Uniform1iv,82
TEXTURE MAX LEVEL, 168, 169,
Uniform2f{v},82
177,181
Uniform2i{v},82
TEXTURE MAX LOD, 168, 169, 173,
Uniform4f{v},82
181
Uniform4i{v},82
TEXTURE MIN FILTER, 169,
UniformMatrix*,348
174, 175, 177, 178, 180, 181,
UniformMatrix2x4fv,82
191
UniformMatrix3fv,82
TEXTURE MIN LOD, 168, 169, 173,
UniformMatrix{234}fv,81,82
181
UniformMatrix{2x3,3x2,2x4,4x2,3x4,4x3}fv,
TEXTURE PRIORITY, 168, 169, 181,
81,82,351
184
UnmapBuffer,38,244
TEXTURE RECTANGLE ARB,362
UNPACK ALIGNMENT, 115, 131,
TEXTURE RED SIZE,250
151,288
TEXTURE RESIDENT,181,183,250
UNPACK IMAGE HEIGHT, 115, 151,
TEXTURE WIDTH,166–168,250
288
TEXTURE WRAP R, 169, 171, 175,
UNPACK LSB FIRST,115,136,288
176
UNPACK ROW LENGTH, 115, 131,
TEXTURE WRAP S,169,171,175
151,288
TEXTURE WRAP T,169,171,175
UNPACK SKIP IMAGES, 115, 152,
TEXTUREn,189,192
158,288
TRANSFORM BIT,265
UNPACK SKIP PIXELS, 115, 131,
Translate,44,45,309
136,288
TRANSPOSE COLOR MATRIX, 248,
UNPACK SKIP ROWS, 115, 131, 136,
254
288
TRANSPOSE MODELVIEW MATRIX,
UNPACK SWAP BYTES, 115, 130,
248
288
TRANSPOSE PROJECTION MATRIX,
UNSIGNED BYTE, 24, 29, 32, 129,
248
133,226,227,243
TRANSPOSE TEXTURE MATRIX,
248 UNSIGNED BYTE 2 3 3 REV, 129,
TRIANGLE FAN,17 131–133,227
Version2.1-December1,2006380 INDEX
UNSIGNED BYTE 3 3 2, 129, 131– VERTEX ARRAY,26,33
133,227 VERTEX ARRAY POINTER,257
UNSIGNED INT,24,29,129,135,226, VERTEX ATTRIB ARRAY BUFFER BINDING,
227,243,251,252 263,349
UNSIGNED INT 10 10 10 2,129,131, VERTEX ATTRIB ARRAY ENABLED,
132,135,227 263
UNSIGNED INT 2 10 10 10 REV, VERTEX ATTRIB ARRAY NORMALIZED,
129,131,132,135,227 263
UNSIGNED INT 8 8 8 8, 129, 131, VERTEX ATTRIB ARRAY POINTER,
132,135,227 263
UNSIGNED INT 8 8 8 8 REV, 129, VERTEX ATTRIB ARRAY SIZE,263
131,132,135,227 VERTEX ATTRIB ARRAY STRIDE,
UNSIGNED SHORT, 24, 29, 129, 134, 263
226,227,243,251,252 VERTEX ATTRIB ARRAY TYPE,
UNSIGNED SHORT 1 5 5 5 REV, 263
129,131,132,134,227 VERTEX PROGRAM POINT SIZE,
UNSIGNED SHORT 4 4 4 4, 129, 95
VERTEX PROGRAM TWO SIDE,63
131,132,134,227
VERTEX SHADER,72,260
UNSIGNED SHORT 4 4 4 4 REV,
VertexAttrib,19,22
129,131,132,134,227
VertexAttrib*,22,23,76,353
UNSIGNED SHORT 5 5 5 1, 129,
VertexAttrib1*,22
131,132,134,227
VertexAttrib2*,22
UNSIGNED SHORT 5 6 5, 129, 131,
VertexAttrib3*,22
132,134,227
VertexAttrib4,22
UNSIGNED SHORT 5 6 5 REV, 129,
VertexAttrib4*,22
131,132,134,227
VertexAttrib4N,22
UPPER LEFT,96,100
VertexAttrib4Nub,22
UseProgram,75,84
VertexAttrib[size][type]v,27
VertexAttrib[size]N[type]v,27
V2F,31,32
VertexAttribPointer,20,24,25,244,263
V3F,31,32
VertexPointer,20,24,25,33,244
VALIDATE STATUS,88,261
Viewport,42
ValidateProgram,87,88,244,261
VIEWPORT BIT,265
vec2,76
vec3,76
WGL ARB multisample,326
vec4,76,82
WGL ARB pixel format ?oat,363
VENDOR,257,258
WindowPos,55,57,237,336,347
VERSION,257,258
WindowPos2,55
Vertex,7,19,20,55,76,233
WindowPos3,55
Vertex2,20,23,40
WRITE ONLY,34,37
Vertex2sv,7
Vertex3,20,23
XOR,214
Vertex3f,7
Vertex4,20,23
ZERO,206,211,212,286
Vertex[size][type]v,28
Version2.1-December1,2006