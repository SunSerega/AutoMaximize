
//*****************************************************************************************************\\
// Copyright (©) Cergey Latchenko ( github.com/SunSerega | forum.mmcs.sfedu.ru/u/sun_serega )
// This code is distributed under the Unlicense
// For details see LICENSE file or this:
// https://github.com/SunSerega/POCGL/blob/master/LICENSE
//*****************************************************************************************************\\
// Copyright (©) Сергей Латченко ( github.com/SunSerega | forum.mmcs.sfedu.ru/u/sun_serega )
// Этот код распространяется с лицензией Unlicense
// Подробнее в файле LICENSE или тут:
// https://github.com/SunSerega/POCGL/blob/master/LICENSE
//*****************************************************************************************************\\

///
///Код переведён отсюда:
/// https://github.com/KhronosGroup/OpenGL-Registry
/// (Основная часть не_расширений - \api\GL\ )
///
///Спецификации всех версий OpenGL:
/// https://www.khronos.org/registry/OpenGL/specs/gl/
///
///Если не хватает функции, перечисления, или найдена ошибка - писать сюда:
/// https://github.com/SunSerega/POCGL/issues
///
unit OpenGL;

interface

uses System;
uses System.Runtime.InteropServices;
uses System.Runtime.CompilerServices;

{$region Основные типы} type
  
  GLsync                        = IntPtr;
  GLeglImageOES                 = IntPtr;
  
  QueryName                     = UInt32;
  BufferName                    = UInt32;
  ShaderName                    = UInt32;
  ProgramName                   = UInt32;
  ProgramPipelineName           = UInt32;
  TextureName                   = UInt32;
  SamplerName                   = UInt32;
  FramebufferName               = UInt32;
  RenderbufferName              = UInt32;
  VertexArrayName               = UInt32;
  TransformFeedbackName         = UInt32;
  
  GLContext                     = UInt32;
  GDI_DC                        = IntPtr;
  
  // типы для совместимости с OpenCL
  ///--
  cl_context                    = IntPtr;
  ///--
  cl_event                      = IntPtr;
  
  
  
  //ToDo убрать после чистки
  DummyEnum                     = UInt32;
  DummyFlags                    = UInt32;
  
  
  // INTEL_performance_query
  PerfQueryIdINTEL              = UInt32;
  PerfQueryHandleINTEL          = UInt32;
  
  
  //ToDo переименовать и проверить типы всего дальше:
  
  EGLsync                       = IntPtr;
  EGLDisplay                    = IntPtr;
  
  ShaderBinaryFormat            = UInt32;
  ProgramResourceIndex          = UInt32;
  ProgramBinaryFormat           = UInt32;
  
  GLhandleARB                   = UInt32;
  PBufferName                   = UInt32;
  GLeglClientBufferEXT          = IntPtr;
  VideoOutputDeviceHandleNV     = IntPtr;
  VideoInputDeviceHandleNV      = IntPtr;
  VideoDeviceHandleNV           = IntPtr;
  GLvdpauSurfaceNV              = IntPtr;
  GPUAffinityHandle             = IntPtr;
  GLXFBConfig                   = IntPtr;
  GLXContextID                  = UInt64;
  GLXPbuffer                    = UInt64;
  GLXWindow                     = UInt64;
  GLXPixmap                     = UInt64;
  GLXColormap                   = UInt64;
  GLXDrawable                   = UInt64;
  GLXContext                    = UInt64;
  GLXVideoCaptureDeviceNV       = UInt64;
  GLXVideoSourceSGIX            = UInt64;
  GLXVideoDeviceNV              = UInt32;
  GLXFuncPtr                    = IntPtr;
  
  PDisplay                      = IntPtr;
  PXVisualInfo                  = IntPtr;
  
  
  
  //ToDo эти типы вообще угадывал, перепроверить
  
  GLXDMparams                   = IntPtr;
  GLXDMbuffer                   = IntPtr;
  GLXVLServer                   = IntPtr;
  GLXVLPath                     = IntPtr;
  GLXVLNode                     = IntPtr;
  GLXStatus                     = IntPtr;
  GLUnurbs                      = IntPtr;
  GDI_HENHMetafile              = IntPtr;
  GDI_LayerPlaneDescriptor      = IntPtr;
  
  
  
  OpenGLException = class(Exception)
    
    constructor(text: string) :=
    inherited Create($'Ошибка OpenGL: "{text}"');
    
  end;
  
{$endregion Основные типы}

{$region Перечисления} type
  
  {$region case Result of}
  
  //R
  ErrorCode = record
    public val: UInt32;
    
    public const NO_ERROR =                                 0;
    public const FRAMEBUFFER_COMPLETE =                     $8CD5;
    
    public const INVALID_ENUM =                             $0500;
    public const INVALID_VALUE =                            $0501;
    public const INVALID_OPERATION =                        $0502;
    public const STACK_OVERFLOW =                           $0503;
    public const STACK_UNDERFLOW =                          $0504;
    public const OUT_OF_MEMORY =                            $0505;
    public const INVALID_FRAMEBUFFER_OPERATION =            $0506;
    public const CONTEXT_LOST =                             $0507;
    
    public const GUILTY_CONTEXT_RESET =                     $8253;
    public const INNOCENT_CONTEXT_RESET =                   $8254;
    public const UNKNOWN_CONTEXT_RESET =                    $8255;
    
    ///Устарело, в 3.1 уже не существует
    public const TABLE_TOO_LARGE =                          $8031;
    
    
    
    public function ToString: string; override;
    begin
      var res := typeof(ErrorCode).GetFields.Where(fi->fi.IsLiteral).FirstOrDefault(prop->integer(prop.GetValue(nil)) = self.val);
      Result := res=nil?
        $'ErrorCode[${self.val:X}]':
        res.Name.ToWords('_').Select(w->w[1].ToUpper+w.Substring(1).ToLower).JoinIntoString;
    end;
    
    public procedure RaiseIfError :=
    case val of
      NO_ERROR, FRAMEBUFFER_COMPLETE: ;
      else raise new OpenGLException(self.ToString);
    end;
    
  end;
  
  {$endregion case Result of}
  
  {$region 1 значение}
  
  {$region ...InfoType}
  
  //S
  RenderbufferInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WIDTH:           RenderbufferInfoType read new RenderbufferInfoType($8D42);
    public static property HEIGHT:          RenderbufferInfoType read new RenderbufferInfoType($8D43);
    public static property INTERNAL_FORMAT: RenderbufferInfoType read new RenderbufferInfoType($8D44);
    public static property SAMPLES:         RenderbufferInfoType read new RenderbufferInfoType($8CAB);
    public static property RED_SIZE:        RenderbufferInfoType read new RenderbufferInfoType($8D50);
    public static property GREEN_SIZE:      RenderbufferInfoType read new RenderbufferInfoType($8D51);
    public static property BLUE_SIZE:       RenderbufferInfoType read new RenderbufferInfoType($8D52);
    public static property ALPHA_SIZE:      RenderbufferInfoType read new RenderbufferInfoType($8D53);
    public static property DEPTH_SIZE:      RenderbufferInfoType read new RenderbufferInfoType($8D54);
    public static property STENCIL_SIZE:    RenderbufferInfoType read new RenderbufferInfoType($8D55);
    
  end;
  
  //S
  ActiveSubroutineInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORMS:              ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8DE6);
    public static property UNIFORM_LOCATIONS:     ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8E47);
    public static property GL_ACTIVE_SUBROUTINES: ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8DE5);
    public static property UNIFORM_MAX_LENGTH:    ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8E49);
    public static property MAX_LENGTH:            ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8E48);
    
  end;
  
  //S
  ProgramPipelineInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_PROGRAM:          ProgramPipelineInfoType read new ProgramPipelineInfoType($8259);
    public static property VERTEX_SHADER:           ProgramPipelineInfoType read new ProgramPipelineInfoType($8B31);
    public static property TESS_CONTROL_SHADER:     ProgramPipelineInfoType read new ProgramPipelineInfoType($8E88);
    public static property TESS_EVALUATION_SHADER:  ProgramPipelineInfoType read new ProgramPipelineInfoType($8E87);
    public static property GEOMETRY_SHADER:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8DD9);
    public static property FRAGMENT_SHADER:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8B30);
    public static property COMPUTE_SHADER:          ProgramPipelineInfoType read new ProgramPipelineInfoType($91B9);
    public static property VALIDATE_STATUS:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8B83);
    public static property INFO_LOG_LENGTH:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8B84);
    
  end;
  
  //S
  ProgramInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DELETE_STATUS:                         ProgramInfoType read new ProgramInfoType($8B80);
    public static property LINK_STATUS:                           ProgramInfoType read new ProgramInfoType($8B82);
    public static property VALIDATE_STATUS:                       ProgramInfoType read new ProgramInfoType($8B83);
    public static property INFO_LOG_LENGTH:                       ProgramInfoType read new ProgramInfoType($8B84);
    public static property ATTACHED_SHADERS:                      ProgramInfoType read new ProgramInfoType($8B85);
    public static property ACTIVE_ATTRIBUTES:                     ProgramInfoType read new ProgramInfoType($8B89);
    public static property ACTIVE_ATTRIBUTE_MAX_LENGTH:           ProgramInfoType read new ProgramInfoType($8B8A);
    public static property ACTIVE_UNIFORMS:                       ProgramInfoType read new ProgramInfoType($8B86);
    public static property ACTIVE_UNIFORM_MAX_LENGTH:             ProgramInfoType read new ProgramInfoType($8B87);
    public static property TRANSFORM_FEEDBACK_BUFFER_MODE:        ProgramInfoType read new ProgramInfoType($8C7F);
    public static property TRANSFORM_FEEDBACK_VARYINGS:           ProgramInfoType read new ProgramInfoType($8C83);
    public static property TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: ProgramInfoType read new ProgramInfoType($8C76);
    public static property ACTIVE_UNIFORM_BLOCKS:                 ProgramInfoType read new ProgramInfoType($8A36);
    public static property ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH:  ProgramInfoType read new ProgramInfoType($8A35);
    public static property GEOMETRY_VERTICES_OUT:                 ProgramInfoType read new ProgramInfoType($8916);
    public static property GEOMETRY_INPUT_TYPE:                   ProgramInfoType read new ProgramInfoType($8917);
    public static property GEOMETRY_OUTPUT_TYPE:                  ProgramInfoType read new ProgramInfoType($8918);
    public static property GEOMETRY_SHADER_INVOCATIONS:           ProgramInfoType read new ProgramInfoType($887F);
    public static property TESS_CONTROL_OUTPUT_VERTICES:          ProgramInfoType read new ProgramInfoType($8E75);
    public static property TESS_GEN_MODE:                         ProgramInfoType read new ProgramInfoType($8E76);
    public static property TESS_GEN_SPACING:                      ProgramInfoType read new ProgramInfoType($8E77);
    public static property TESS_GEN_VERTEX_ORDER:                 ProgramInfoType read new ProgramInfoType($8E78);
    public static property TESS_GEN_POINT_MODE:                   ProgramInfoType read new ProgramInfoType($8E79);
    public static property COMPUTE_WORK_GROUP_SIZE:               ProgramInfoType read new ProgramInfoType($8267);
    public static property PROGRAM_SEPARABLE:                     ProgramInfoType read new ProgramInfoType($8258);
    public static property PROGRAM_BINARY_RETRIEVABLE_HINT:       ProgramInfoType read new ProgramInfoType($8257);
    public static property ACTIVE_ATOMIC_COUNTER_BUFFERS:         ProgramInfoType read new ProgramInfoType($92D9);
    
  end;
  
  //S
  ShaderInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHADER_TYPE:           ShaderInfoType read new ShaderInfoType($8B4F);
    public static property DELETE_STATUS:         ShaderInfoType read new ShaderInfoType($8B80);
    public static property COMPILE_STATUS:        ShaderInfoType read new ShaderInfoType($8B81);
    public static property INFO_LOG_LENGTH:       ShaderInfoType read new ShaderInfoType($8B84);
    public static property SHADER_SOURCE_LENGTH:  ShaderInfoType read new ShaderInfoType($8B88);
    public static property SPIR_V_BINARY:         ShaderInfoType read new ShaderInfoType($9552);
    
  end;
  
  //S
  SyncObjInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OBJECT_TYPE:     SyncObjInfoType read new SyncObjInfoType($9112);
    public static property SYNC_CONDITION:  SyncObjInfoType read new SyncObjInfoType($9113);
    public static property SYNC_STATUS:     SyncObjInfoType read new SyncObjInfoType($9114);
    public static property SYNC_FLAGS:      SyncObjInfoType read new SyncObjInfoType($9115);
    
  end;
  
  //S
  QueryTargetType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SAMPLES_PASSED:                        QueryTargetType read new QueryTargetType($8914);
    public static property ANY_SAMPLES_PASSED:                    QueryTargetType read new QueryTargetType($8C2F);
    public static property ANY_SAMPLES_PASSED_CONSERVATIVE:       QueryTargetType read new QueryTargetType($8D6A);
    public static property PRIMITIVES_GENERATED:                  QueryTargetType read new QueryTargetType($8C87);
    public static property TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: QueryTargetType read new QueryTargetType($8C88);
    public static property TIME_ELAPSED:                          QueryTargetType read new QueryTargetType($88BF);
    public static property TIMESTAMP:                             QueryTargetType read new QueryTargetType($8E28);
    
  end;
  
  //S
  GetQueryInfoName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_COUNTER_BITS:  GetQueryInfoName read new GetQueryInfoName($8864);
    public static property CURRENT_QUERY:       GetQueryInfoName read new GetQueryInfoName($8865);
    
  end;
  
  //S
  GetQueryObjectInfoName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RESULT:            GetQueryObjectInfoName read new GetQueryObjectInfoName($8866);
    public static property RESULT_AVAILABLE:  GetQueryObjectInfoName read new GetQueryObjectInfoName($8867);
    
  end;
  
  //S
  BufferInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SIZE:              BufferInfoType read new BufferInfoType($8764);
    public static property USAGE:             BufferInfoType read new BufferInfoType($8765);
    public static property ACCESS:            BufferInfoType read new BufferInfoType($88BB);
    public static property ACCESS_FLAGS:      BufferInfoType read new BufferInfoType($911F);
    public static property IMMUTABLE_STORAGE: BufferInfoType read new BufferInfoType($821F);
    public static property MAPPED:            BufferInfoType read new BufferInfoType($88BC);
    public static property MAP_LENGTH:        BufferInfoType read new BufferInfoType($9120);
    public static property MAP_OFFSET:        BufferInfoType read new BufferInfoType($9121);
    public static property STORAGE_FLAGS:     BufferInfoType read new BufferInfoType($8220);
    public static property MAP_POINTER:       BufferInfoType read new BufferInfoType($88BD);
    
  end;
  
  {$endregion ...InfoType}
  
  //S
  CompatibilityViewClassType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property C_128_BITS:        CompatibilityViewClassType read new CompatibilityViewClassType($82C4);
    public static property C_96_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C5);
    public static property C_64_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C6);
    public static property C_48_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C7);
    public static property C_32_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C8);
    public static property C_24_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C9);
    public static property C_16_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82CA);
    public static property C_8_BITS:          CompatibilityViewClassType read new CompatibilityViewClassType($82CB);
    public static property C_S3TC_DXT1_RGB:   CompatibilityViewClassType read new CompatibilityViewClassType($82CC);
    public static property C_S3TC_DXT1_RGBA:  CompatibilityViewClassType read new CompatibilityViewClassType($82CD);
    public static property C_S3TC_DXT3_RGBA:  CompatibilityViewClassType read new CompatibilityViewClassType($82CE);
    public static property C_S3TC_DXT5_RGBA:  CompatibilityViewClassType read new CompatibilityViewClassType($82CF);
    public static property C_RGTC1_RED:       CompatibilityViewClassType read new CompatibilityViewClassType($82D0);
    public static property C_RGTC2_RG:        CompatibilityViewClassType read new CompatibilityViewClassType($82D1);
    public static property C_BPTC_UNORM:      CompatibilityViewClassType read new CompatibilityViewClassType($82D2);
    public static property C_BPTC_FLOAT:      CompatibilityViewClassType read new CompatibilityViewClassType($82D3);
    
  end;
  
  //S
  CompatibilityImageClassType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property C_4_X_32:      CompatibilityImageClassType read new CompatibilityImageClassType($82B9);
    public static property C_2_X_32:      CompatibilityImageClassType read new CompatibilityImageClassType($82BA);
    public static property C_1_X_32:      CompatibilityImageClassType read new CompatibilityImageClassType($82BB);
    public static property C_4_X_16:      CompatibilityImageClassType read new CompatibilityImageClassType($82BC);
    public static property C_2_X_16:      CompatibilityImageClassType read new CompatibilityImageClassType($82BD);
    public static property C_1_X_16:      CompatibilityImageClassType read new CompatibilityImageClassType($82BE);
    public static property C_4_X_8:       CompatibilityImageClassType read new CompatibilityImageClassType($82BF);
    public static property C_2_X_8:       CompatibilityImageClassType read new CompatibilityImageClassType($82C0);
    public static property C_1_X_8:       CompatibilityImageClassType read new CompatibilityImageClassType($82C1);
    public static property C_11_11_10:    CompatibilityImageClassType read new CompatibilityImageClassType($82C2);
    public static property C_10_10_10_2:  CompatibilityImageClassType read new CompatibilityImageClassType($82C3);
    
  end;
  
  //S
  ImageFormatCompatibilityMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMPATIBILITY1_BY_SIZE:  ImageFormatCompatibilityMode read new ImageFormatCompatibilityMode($90C8);
    public static property COMPATIBILITY2_BY_CLASS: ImageFormatCompatibilityMode read new ImageFormatCompatibilityMode($90C9);
    public static property NONE:                    ImageFormatCompatibilityMode read new ImageFormatCompatibilityMode($90C9);
    
  end;
  
  //S
  SupportLevel = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:            SupportLevel read new SupportLevel(0);
    public static property FULL_SUPPORT:    SupportLevel read new SupportLevel($82B7);
    public static property CAVEAT_SUPPORT:  SupportLevel read new SupportLevel($82B8);
    
  end;
  
  //S
  GDI_LayerType = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property MAIN_PLANE:      GDI_LayerType read new GDI_LayerType(0);
    public static property OVERLAY_PLANE:   GDI_LayerType read new GDI_LayerType(1);
    public static property UNDERLAY_PLANE:  GDI_LayerType read new GDI_LayerType(-1);
    
  end;
  
  //S
  GDI_PixelDataType = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property RGBA:        GDI_PixelDataType read new GDI_PixelDataType(0);
    public static property COLORINDEX:  GDI_PixelDataType read new GDI_PixelDataType(1);
    
  end;
  
  //S
  CopyableImageBuffer = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR:   CopyableImageBuffer read new CopyableImageBuffer($1800);
    public static property DEPTH:   CopyableImageBuffer read new CopyableImageBuffer($1801);
    public static property STENCIL: CopyableImageBuffer read new CopyableImageBuffer($1802);
    
  end;
  
  //S
  VertexProvokingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FIRST_VERTEX_CONVENTION: VertexProvokingMode read new VertexProvokingMode($8E4D);
    public static property LAST_VERTEX_CONVENTION:  VertexProvokingMode read new VertexProvokingMode($8E4E);
    
  end;
  
  //S
  SwizzleMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RED:   SwizzleMode read new SwizzleMode($1903);
    public static property GREEN: SwizzleMode read new SwizzleMode($1904);
    public static property BLUE:  SwizzleMode read new SwizzleMode($1905);
    public static property ALPHA: SwizzleMode read new SwizzleMode($1906);
    public static property ZERO:  SwizzleMode read new SwizzleMode(0);
    public static property ONE:   SwizzleMode read new SwizzleMode(1);
    
  end;
  
  //S
  DepthStencilMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEPTH_COMPONENT: DepthStencilMode read new DepthStencilMode($1902);
    public static property STENCIL_INDEX:   DepthStencilMode read new DepthStencilMode($1901);
    
  end;
  
  //S
  PixelWrapMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLAMP_TO_EDGE:         PixelWrapMode read new PixelWrapMode($812F);
    public static property &REPEAT:               PixelWrapMode read new PixelWrapMode($2901);
    public static property CLAMP_TO_BORDER:       PixelWrapMode read new PixelWrapMode($812D);
    public static property MIRRORED_REPEAT:       PixelWrapMode read new PixelWrapMode($8370);
    public static property MIRROR_CLAMP_TO_EDGE:  PixelWrapMode read new PixelWrapMode($8743);
    
  end;
  
  //S
  TextureCompareMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                    TextureCompareMode read new TextureCompareMode(0);
    public static property COMPARE_REF_TO_TEXTURE:  TextureCompareMode read new TextureCompareMode($884E);
    
  end;
  
  //S
  ReservedTimeoutMode = record
    public val: uint64;
    public constructor(val: uint64) := self.val := val;
    
    public static property GL_TIMEOUT_IGNORED:  ReservedTimeoutMode read new ReservedTimeoutMode(uint64.MaxValue);
    
  end;
  
  //S
  InternalFormatInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INTERNALFORMAT_SUPPORTED:                InternalFormatInfoType read new InternalFormatInfoType($826F);
    public static property INTERNALFORMAT_PREFERRED:                InternalFormatInfoType read new InternalFormatInfoType($8270);
    public static property INTERNALFORMAT_RED_SIZE:                 InternalFormatInfoType read new InternalFormatInfoType($8271);
    public static property INTERNALFORMAT_RED_TYPE:                 InternalFormatInfoType read new InternalFormatInfoType($8278);
    public static property MAX_WIDTH:                               InternalFormatInfoType read new InternalFormatInfoType($827E);
    public static property MAX_HEIGHT:                              InternalFormatInfoType read new InternalFormatInfoType($827F);
    public static property MAX_DEPTH:                               InternalFormatInfoType read new InternalFormatInfoType($8280);
    public static property MAX_LAYERS:                              InternalFormatInfoType read new InternalFormatInfoType($8281);
    public static property COLOR_COMPONENTS:                        InternalFormatInfoType read new InternalFormatInfoType($8283);
    public static property COLOR_RENDERABLE:                        InternalFormatInfoType read new InternalFormatInfoType($8286);
    public static property DEPTH_RENDERABLE:                        InternalFormatInfoType read new InternalFormatInfoType($8287);
    public static property STENCIL_RENDERABLE:                      InternalFormatInfoType read new InternalFormatInfoType($8288);
    public static property FRAMEBUFFER_RENDERABLE:                  InternalFormatInfoType read new InternalFormatInfoType($8289);
    public static property FRAMEBUFFER_RENDERABLE_LAYERED:          InternalFormatInfoType read new InternalFormatInfoType($828A);
    public static property FRAMEBUFFER_BLEND:                       InternalFormatInfoType read new InternalFormatInfoType($828B);
    public static property READ_PIXELS:                             InternalFormatInfoType read new InternalFormatInfoType($828C);
    public static property READ_PIXELS_FORMAT:                      InternalFormatInfoType read new InternalFormatInfoType($828D);
    public static property READ_PIXELS_TYPE:                        InternalFormatInfoType read new InternalFormatInfoType($828E);
    public static property GET_TEXTURE_IMAGE_FORMAT:                InternalFormatInfoType read new InternalFormatInfoType($8291);
    public static property GET_TEXTURE_IMAGE_TYPE:                  InternalFormatInfoType read new InternalFormatInfoType($8292);
    public static property TEXTURE_IMAGE_FORMAT:                    InternalFormatInfoType read new InternalFormatInfoType($828F);
    public static property TEXTURE_IMAGE_TYPE:                      InternalFormatInfoType read new InternalFormatInfoType($8290);
    public static property MIPMAP:                                  InternalFormatInfoType read new InternalFormatInfoType($8293);
    public static property GENERATE_MIPMAP:                         InternalFormatInfoType read new InternalFormatInfoType($8191);
    public static property AUTO_GENERATE_MIPMAP:                    InternalFormatInfoType read new InternalFormatInfoType($8295);
    public static property COLOR_ENCODING:                          InternalFormatInfoType read new InternalFormatInfoType($8296);
    public static property SRGB_READ:                               InternalFormatInfoType read new InternalFormatInfoType($8297);
    public static property SRGB_WRITE:                              InternalFormatInfoType read new InternalFormatInfoType($8298);
    public static property FILTER:                                  InternalFormatInfoType read new InternalFormatInfoType($829A);
    public static property VERTEX_TEXTURE:                          InternalFormatInfoType read new InternalFormatInfoType($829B);
    public static property TESS_CONTROL_TEXTURE:                    InternalFormatInfoType read new InternalFormatInfoType($829C);
    public static property TESS_EVALUATION_TEXTURE:                 InternalFormatInfoType read new InternalFormatInfoType($829D);
    public static property GEOMETRY_TEXTURE:                        InternalFormatInfoType read new InternalFormatInfoType($829E);
    public static property FRAGMENT_TEXTURE:                        InternalFormatInfoType read new InternalFormatInfoType($829F);
    public static property COMPUTE_TEXTURE:                         InternalFormatInfoType read new InternalFormatInfoType($82A0);
    public static property TEXTURE_SHADOW:                          InternalFormatInfoType read new InternalFormatInfoType($82A1);
    public static property TEXTURE_GATHER:                          InternalFormatInfoType read new InternalFormatInfoType($82A2);
    public static property TEXTURE_GATHER_SHADOW:                   InternalFormatInfoType read new InternalFormatInfoType($82A3);
    public static property SHADER_IMAGE_LOAD:                       InternalFormatInfoType read new InternalFormatInfoType($82A4);
    public static property SHADER_IMAGE_STORE:                      InternalFormatInfoType read new InternalFormatInfoType($82A5);
    public static property SHADER_IMAGE_ATOMIC:                     InternalFormatInfoType read new InternalFormatInfoType($82A6);
    public static property IMAGE_TEXEL_SIZE:                        InternalFormatInfoType read new InternalFormatInfoType($82A7);
    public static property IMAGE_COMPATIBILITY_CLASS:               InternalFormatInfoType read new InternalFormatInfoType($82A8);
    public static property IMAGE_PIXEL_FORMAT:                      InternalFormatInfoType read new InternalFormatInfoType($82A9);
    public static property IMAGE_PIXEL_TYPE:                        InternalFormatInfoType read new InternalFormatInfoType($82AA);
    public static property IMAGE_FORMAT_COMPATIBILITY_TYPE:         InternalFormatInfoType read new InternalFormatInfoType($90C7);
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST:     InternalFormatInfoType read new InternalFormatInfoType($82AC);
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST:   InternalFormatInfoType read new InternalFormatInfoType($82AD);
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE:    InternalFormatInfoType read new InternalFormatInfoType($82AE);
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE:  InternalFormatInfoType read new InternalFormatInfoType($82AF);
    public static property TEXTURE_COMPRESSED:                      InternalFormatInfoType read new InternalFormatInfoType($86A1);
    public static property TEXTURE_COMPRESSED_BLOCK_WIDTH:          InternalFormatInfoType read new InternalFormatInfoType($82B1);
    public static property TEXTURE_COMPRESSED_BLOCK_HEIGHT:         InternalFormatInfoType read new InternalFormatInfoType($82B2);
    public static property TEXTURE_COMPRESSED_BLOCK_SIZE:           InternalFormatInfoType read new InternalFormatInfoType($82B3);
    public static property CLEAR_BUFFER:                            InternalFormatInfoType read new InternalFormatInfoType($82B4);
    public static property TEXTURE_VIEW:                            InternalFormatInfoType read new InternalFormatInfoType($82B5);
    public static property VIEW_COMPATIBILITY_CLASS:                InternalFormatInfoType read new InternalFormatInfoType($82B6);
    public static property CLEAR_TEXTURE:                           InternalFormatInfoType read new InternalFormatInfoType($9365);
    
  end;
  
  //S
  TransformFeedbackInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER_BINDING:  TransformFeedbackInfoType read new TransformFeedbackInfoType($8C8F);
    public static property BUFFER_START:    TransformFeedbackInfoType read new TransformFeedbackInfoType($8C84);
    public static property BUFFER_SIZE:     TransformFeedbackInfoType read new TransformFeedbackInfoType($8C85);
    public static property PAUSED:          TransformFeedbackInfoType read new TransformFeedbackInfoType($8E23);
    public static property ACTIVE:          TransformFeedbackInfoType read new TransformFeedbackInfoType($8E24);
    
  end;
  
  //S
  HintValue = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FASTEST:   HintValue read new HintValue($1101);
    public static property NICEST:    HintValue read new HintValue($1102);
    public static property DONT_CARE: HintValue read new HintValue($1100);
    
  end;
  
  //S
  HintType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LINE_SMOOTH_HINT:                HintType read new HintType($0C52);
    public static property POLYGON_SMOOTH_HINT:             HintType read new HintType($0C53);
    public static property TEXTURE_COMPRESSION_HINT:        HintType read new HintType($84EF);
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT: HintType read new HintType($8B8B);
    
  end;
  
  //S
  ObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER:              ObjectType read new ObjectType($82E0);
    public static property FRAMEBUFFER:         ObjectType read new ObjectType($8D40);
    public static property PROGRAM_PIPELINE:    ObjectType read new ObjectType($82E4);
    public static property &PROGRAM:            ObjectType read new ObjectType($82E2);
    public static property QUERY:               ObjectType read new ObjectType($82E3);
    public static property RENDERBUFFER:        ObjectType read new ObjectType($8D41);
    public static property SAMPLER:             ObjectType read new ObjectType($82E6);
    public static property SHADER:              ObjectType read new ObjectType($82E1);
    public static property TEXTURE:             ObjectType read new ObjectType($1702);
    public static property TRANSFORM_FEEDBACK:  ObjectType read new ObjectType($8E22);
    public static property VERTEX_ARRAY:        ObjectType read new ObjectType($8074);
    
  end;
  
  //S
  PixelFilterMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST:                 PixelFilterMode read new PixelFilterMode($2600);
    public static property LINEAR:                  PixelFilterMode read new PixelFilterMode($2601);
    public static property NEAREST_MIPMAP_NEAREST:  PixelFilterMode read new PixelFilterMode($2700);
    public static property NEAREST_MIPMAP_LINEAR:   PixelFilterMode read new PixelFilterMode($2702);
    public static property LINEAR_MIPMAP_NEAREST:   PixelFilterMode read new PixelFilterMode($2701);
    public static property LINEAR_MIPMAP_LINEAR:    PixelFilterMode read new PixelFilterMode($2703);
    
  end;
  
  //S
  ColorClampTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_CLAMP_READ_COLOR: ColorClampTarget read new ColorClampTarget($891C);
    
  end;
  
  //S
  FrameBufferPart = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:            FrameBufferPart read new FrameBufferPart(0);
    public static property FRONT_LEFT:      FrameBufferPart read new FrameBufferPart($0400);
    public static property FRONT_RIGHT:     FrameBufferPart read new FrameBufferPart($0401);
    public static property BACK_LEFT:       FrameBufferPart read new FrameBufferPart($0402);
    public static property BACK_RIGHT:      FrameBufferPart read new FrameBufferPart($0403);
    public static property FRONT:           FrameBufferPart read new FrameBufferPart($0404);
    public static property BACK:            FrameBufferPart read new FrameBufferPart($0405);
    public static property LEFT:            FrameBufferPart read new FrameBufferPart($0406);
    public static property RIGHT:           FrameBufferPart read new FrameBufferPart($0407);
    public static property FRONT_AND_BACK:  FrameBufferPart read new FrameBufferPart($0408);
    
  end;
  
  //S
  LogicOpCode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLEAR:         LogicOpCode read new LogicOpCode($1500);
    public static property &AND:          LogicOpCode read new LogicOpCode($1501);
    public static property AND_REVERSE:   LogicOpCode read new LogicOpCode($1502);
    public static property COPY:          LogicOpCode read new LogicOpCode($1503);
    public static property AND_INVERTED:  LogicOpCode read new LogicOpCode($1504);
    public static property NOOP:          LogicOpCode read new LogicOpCode($1505);
    public static property &XOR:          LogicOpCode read new LogicOpCode($1506);
    public static property &OR:           LogicOpCode read new LogicOpCode($1507);
    public static property NOR:           LogicOpCode read new LogicOpCode($1508);
    public static property EQUIV:         LogicOpCode read new LogicOpCode($1509);
    public static property INVERT:        LogicOpCode read new LogicOpCode($150A);
    public static property OR_REVERSE:    LogicOpCode read new LogicOpCode($150B);
    public static property COPY_INVERTED: LogicOpCode read new LogicOpCode($150C);
    public static property OR_INVERTED:   LogicOpCode read new LogicOpCode($150D);
    public static property NAND:          LogicOpCode read new LogicOpCode($150E);
    public static property &SET:          LogicOpCode read new LogicOpCode($150F);
    
  end;
  
  //S
  BlendFuncMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:                      BlendFuncMode read new BlendFuncMode(0);
    public static property ONE:                       BlendFuncMode read new BlendFuncMode(1);
    public static property SRC_COLOR:                 BlendFuncMode read new BlendFuncMode($0300);
    public static property ONE_MINUS_SRC_COLOR:       BlendFuncMode read new BlendFuncMode($0301);
    public static property DST_COLOR:                 BlendFuncMode read new BlendFuncMode($0306);
    public static property ONE_MINUS_DST_COLOR:       BlendFuncMode read new BlendFuncMode($0307);
    public static property SRC_ALPHA:                 BlendFuncMode read new BlendFuncMode($0302);
    public static property ONE_MINUS_SRC_ALPHA:       BlendFuncMode read new BlendFuncMode($0303);
    public static property DST_ALPHA:                 BlendFuncMode read new BlendFuncMode($0304);
    public static property ONE_MINUS_DST_ALPHA:       BlendFuncMode read new BlendFuncMode($0305);
    public static property CONSTANT_COLOR:            BlendFuncMode read new BlendFuncMode($8001);
    public static property ONE_MINUS_CONSTANT_COLOR:  BlendFuncMode read new BlendFuncMode($8002);
    public static property CONSTANT_ALPHA:            BlendFuncMode read new BlendFuncMode($8003);
    public static property ONE_MINUS_CONSTANT_ALPHA:  BlendFuncMode read new BlendFuncMode($8004);
    public static property SRC_ALPHA_SATURATE:        BlendFuncMode read new BlendFuncMode($0308);
    public static property SRC1_COLOR:                BlendFuncMode read new BlendFuncMode($88F9);
    public static property ONE_MINUS_SRC1_COLOR:      BlendFuncMode read new BlendFuncMode($88FA);
    public static property SRC1_ALPHA:                BlendFuncMode read new BlendFuncMode($8589);
    public static property ONE_MINUS_SRC1_ALPHA:      BlendFuncMode read new BlendFuncMode($88FB);
    
  end;
  
  //S
  BlendEquationMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FUNC_ADD:              BlendEquationMode read new BlendEquationMode($8006);
    public static property FUNC_SUBTRACT:         BlendEquationMode read new BlendEquationMode($800A);
    public static property FUNC_REVERSE_SUBTRACT: BlendEquationMode read new BlendEquationMode($800B);
    public static property MIN:                   BlendEquationMode read new BlendEquationMode($8007);
    public static property MAX:                   BlendEquationMode read new BlendEquationMode($8008);
    
  end;
  
  //S
  StencilOpFailMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KEEP:      StencilOpFailMode read new StencilOpFailMode($1E00);
    public static property ZERO:      StencilOpFailMode read new StencilOpFailMode(0);
    public static property REPLACE:   StencilOpFailMode read new StencilOpFailMode($1E01);
    public static property INCR:      StencilOpFailMode read new StencilOpFailMode($1E02);
    public static property INCR_WRAP: StencilOpFailMode read new StencilOpFailMode($8507);
    public static property DECR:      StencilOpFailMode read new StencilOpFailMode($1E03);
    public static property DECR_WRAP: StencilOpFailMode read new StencilOpFailMode($8508);
    public static property INVERT:    StencilOpFailMode read new StencilOpFailMode($150A);
    
  end;
  
  //S
  ActivationFunc = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:     ActivationFunc read new ActivationFunc($0200);
    public static property LESS:      ActivationFunc read new ActivationFunc($0201);
    public static property LEQUAL:    ActivationFunc read new ActivationFunc($0203);
    public static property GREATER:   ActivationFunc read new ActivationFunc($0204);
    public static property GEQUAL:    ActivationFunc read new ActivationFunc($0206);
    public static property EQUAL:     ActivationFunc read new ActivationFunc($0202);
    public static property NOTEQUAL:  ActivationFunc read new ActivationFunc($0205);
    public static property ALWAYS:    ActivationFunc read new ActivationFunc($0207);
    
  end;
  
  //S
  PolygonRasterizationMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT: PolygonRasterizationMode read new PolygonRasterizationMode($1B00);
    public static property LINE:  PolygonRasterizationMode read new PolygonRasterizationMode($1B01);
    public static property FILL:  PolygonRasterizationMode read new PolygonRasterizationMode($1B02);
    
  end;
  
  //S
  PolygonFace = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRONT:           PolygonFace read new PolygonFace($0404);
    public static property BACK:            PolygonFace read new PolygonFace($0405);
    public static property FRONT_AND_BACK:  PolygonFace read new PolygonFace($0408);
    
  end;
  
  //S
  FrontFaceDirection = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property СW:  FrontFaceDirection read new FrontFaceDirection($0900);
    public static property СCW: FrontFaceDirection read new FrontFaceDirection($0901);
    
  end;
  
  //S
  PointInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FADE_THRESHOLD_SIZE: PointInfoType read new PointInfoType($8128);
    public static property SPRITE_COORD_ORIGIN: PointInfoType read new PointInfoType($8CA0);
    
  end;
  
  //S
  MultisampleInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_SAMPLE_POSITION:  MultisampleInfoType read new MultisampleInfoType($8E50);
    
  end;
  
  //S
  ClipDepthMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEGATIVE_ONE_TO_ONE: ClipDepthMode read new ClipDepthMode($935E);
    public static property ZERO_TO_ONE:         ClipDepthMode read new ClipDepthMode($935F);
    
  end;
  
  //S
  ClipOriginMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOWER_LEFT:  ClipOriginMode read new ClipOriginMode($8CA1);
    public static property UPPER_LEFT:  ClipOriginMode read new ClipOriginMode($8CA2);
    
  end;
  
  //S
  TransformFeedbackBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_TRANSFORM_FEEDBACK: TransformFeedbackBindTarget read new TransformFeedbackBindTarget($8E22);
    
  end;
  
  //S
  TransformFeedbackBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INTERLEAVED_ATTRIBS: TransformFeedbackBufferMode read new TransformFeedbackBufferMode($8C8C);
    public static property SEPARATE_ATTRIBS:    TransformFeedbackBufferMode read new TransformFeedbackBufferMode($8C8D);
    
  end;
  
  //S
  ConditionalRenderingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WAIT:                        ConditionalRenderingMode read new ConditionalRenderingMode($8E13);
    public static property NO_WAIT:                     ConditionalRenderingMode read new ConditionalRenderingMode($8E14);
    public static property BY_REGION_WAIT:              ConditionalRenderingMode read new ConditionalRenderingMode($8E15);
    public static property BY_REGION_NO_WAIT:           ConditionalRenderingMode read new ConditionalRenderingMode($8E16);
    public static property WAIT_INVERTED:               ConditionalRenderingMode read new ConditionalRenderingMode($8E17);
    public static property NO_WAIT_INVERTED:            ConditionalRenderingMode read new ConditionalRenderingMode($8E18);
    public static property BY_REGION_WAIT_INVERTED:     ConditionalRenderingMode read new ConditionalRenderingMode($8E19);
    public static property BY_REGION_NO_WAIT_INVERTED:  ConditionalRenderingMode read new ConditionalRenderingMode($8E1A);
    
  end;
  
  //S
  VertexAttribInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ELEMENT_ARRAY_BUFFER_BINDING:        VertexAttribInfoType read new VertexAttribInfoType($8895);
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:         VertexAttribInfoType read new VertexAttribInfoType($8622);
    public static property VERTEX_ATTRIB_ARRAY_SIZE:            VertexAttribInfoType read new VertexAttribInfoType($8623);
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:          VertexAttribInfoType read new VertexAttribInfoType($8624);
    public static property VERTEX_ATTRIB_ARRAY_TYPE:            VertexAttribInfoType read new VertexAttribInfoType($8625);
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED:      VertexAttribInfoType read new VertexAttribInfoType($886A);
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:         VertexAttribInfoType read new VertexAttribInfoType($88FD);
    public static property VERTEX_ATTRIB_ARRAY_LONG:            VertexAttribInfoType read new VertexAttribInfoType($874E);
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:         VertexAttribInfoType read new VertexAttribInfoType($88FE);
    public static property VERTEX_ATTRIB_RELATIVE_OFFSET:       VertexAttribInfoType read new VertexAttribInfoType($82D5);
    public static property VERTEX_BINDING_OFFSET:               VertexAttribInfoType read new VertexAttribInfoType($82D7);
    public static property VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:  VertexAttribInfoType read new VertexAttribInfoType($889F);
    public static property VERTEX_ATTRIB_BINDING:               VertexAttribInfoType read new VertexAttribInfoType($82D4);
    public static property CURRENT_VERTEX_ATTRIB:               VertexAttribInfoType read new VertexAttribInfoType($8626);
    
  end;
  
  //S
  PatchMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTICES:            PatchMode read new PatchMode($8E72);
    public static property DEFAULT_INNER_LEVEL: PatchMode read new PatchMode($8E73);
    public static property DEFAULT_OUTER_LEVEL: PatchMode read new PatchMode($8E74);
    
  end;
  
  //S
  PrimitiveType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINTS:                    PrimitiveType read new PrimitiveType($0000);
    
    public static property LINES:                     PrimitiveType read new PrimitiveType($0001);
    public static property LINE_LOOP:                 PrimitiveType read new PrimitiveType($0002);
    public static property LINE_STRIP:                PrimitiveType read new PrimitiveType($0003);
    public static property LINES_ADJACENCY:           PrimitiveType read new PrimitiveType($000A);
    public static property LINE_STRIP_ADJACENCY:      PrimitiveType read new PrimitiveType($000B);
    
    public static property TRIANGLES:                 PrimitiveType read new PrimitiveType($0004);
    public static property TRIANGLE_STRIP:            PrimitiveType read new PrimitiveType($0005);
    public static property TRIANGLE_FAN:              PrimitiveType read new PrimitiveType($0006);
    public static property TRIANGLES_ADJACENCY:       PrimitiveType read new PrimitiveType($000C);
    public static property TRIANGLE_STRIP_ADJACENCY:  PrimitiveType read new PrimitiveType($000D);
    
    public static property PATCHES:                   PrimitiveType read new PrimitiveType($000E);
    
  end;
  
  //S
  FramebufferAttachmentInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OBJECT_TYPE:           FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD0); // FramebufferAttachmentObjectType
    
    // non- NONE
    public static property OBJECT_NAME:           FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD1); // UInt32
    public static property RED_SIZE:              FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8212); // Int32
    public static property GREEN_SIZE:            FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8213); // Int32
    public static property BLUE_SIZE:             FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8214); // Int32
    public static property ALPHA_SIZE:            FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8215); // Int32
    public static property DEPTH_SIZE:            FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8216); // Int32
    public static property STENCIL_SIZE:          FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8217); // Int32
    public static property COMPONENT_TYPE:        FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8211); // Int32
    public static property COLOR_ENCODING:        FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8210); // Int32
    
    // TEXTURE
    public static property TEXTURE_LEVEL:         FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD2); // Int32
    public static property TEXTURE_CUBE_MAP_FACE: FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD3); // Int32
    public static property LAYERED:               FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8DA7); // 32-битное boolean (Int32, 0=False, остальное=True)
    public static property TEXTURE_LAYER:         FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD4); // Int32
    
  end;
  
  //S
  FramebufferInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WIDTH:                   FramebufferInfoType read new FramebufferInfoType($9310);
    public static property HEIGHT:                  FramebufferInfoType read new FramebufferInfoType($9311);
    public static property LAYERS:                  FramebufferInfoType read new FramebufferInfoType($9312);
    public static property SAMPLES:                 FramebufferInfoType read new FramebufferInfoType($9313);
    public static property FIXED_SAMPLE_LOCATIONS:  FramebufferInfoType read new FramebufferInfoType($9314);
    
  end;
  
  //S
  FramebufferBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_FRAMEBUFFER:  FramebufferBindTarget read new FramebufferBindTarget($8CA8);
    public static property DRAW_FRAMEBUFFER:  FramebufferBindTarget read new FramebufferBindTarget($8CA9);
    public static property FRAMEBUFFER:       FramebufferBindTarget read new FramebufferBindTarget($8D40);
    
  end;
  
  //S
  TextureCubeSide = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POSITIVE_X:  TextureCubeSide read new TextureCubeSide($8515);
    public static property NEGATIVE_X:  TextureCubeSide read new TextureCubeSide($8516);
    public static property POSITIVE_Y:  TextureCubeSide read new TextureCubeSide($8517);
    public static property NEGATIVE_Y:  TextureCubeSide read new TextureCubeSide($8518);
    public static property POSITIVE_Z:  TextureCubeSide read new TextureCubeSide($8519);
    public static property NEGATIVE_Z:  TextureCubeSide read new TextureCubeSide($851A);
    
  end;
  
  //S
  RenderbufferBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RENDERBUFFER: RenderbufferBindTarget read new RenderbufferBindTarget($8D41);
    
  end;
  
  //S
  AccessType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_ONLY:   AccessType read new AccessType($88B8);
    public static property WRITE_ONLY:  AccessType read new AccessType($88B9);
    public static property READ_WRITE:  AccessType read new AccessType($88BA);
    
  end;
  
  //S
  TextureInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEPTH_STENCIL_TEXTURE_MODE:  TextureInfoType read new TextureInfoType($90EA);
    public static property BASE_LEVEL:                  TextureInfoType read new TextureInfoType($813C);
    public static property BORDER_COLOR:                TextureInfoType read new TextureInfoType($1004);
    public static property COMPARE_MODE:                TextureInfoType read new TextureInfoType($884C);
    public static property COMPARE_FUNC:                TextureInfoType read new TextureInfoType($884D);
    public static property LOD_BIAS:                    TextureInfoType read new TextureInfoType($8501);
    public static property MAG_FILTER:                  TextureInfoType read new TextureInfoType($2800);
    public static property MAX_ANISOTROPY:              TextureInfoType read new TextureInfoType($84FE);
    public static property MAX_LEVEL:                   TextureInfoType read new TextureInfoType($813D);
    public static property MAX_LOD:                     TextureInfoType read new TextureInfoType($813B);
    public static property MIN_FILTER:                  TextureInfoType read new TextureInfoType($2801);
    public static property MIN_LOD:                     TextureInfoType read new TextureInfoType($813A);
    public static property SWIZZLE_R:                   TextureInfoType read new TextureInfoType($8E42);
    public static property SWIZZLE_G:                   TextureInfoType read new TextureInfoType($8E43);
    public static property SWIZZLE_B:                   TextureInfoType read new TextureInfoType($8E44);
    public static property SWIZZLE_A:                   TextureInfoType read new TextureInfoType($8E45);
    public static property SWIZZLE_RGBA:                TextureInfoType read new TextureInfoType($8E46);
    public static property WRAP_S:                      TextureInfoType read new TextureInfoType($2802);
    public static property WRAP_T:                      TextureInfoType read new TextureInfoType($2803);
    public static property WRAP_R:                      TextureInfoType read new TextureInfoType($8072);
    
  end;
  
  //S
  PixelInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNPACK_SWAP_BYTES:               PixelInfoType read new PixelInfoType($0CF0);
    public static property UNPACK_LSB_FIRST:                PixelInfoType read new PixelInfoType($0CF1);
    public static property UNPACK_ROW_LENGTH:               PixelInfoType read new PixelInfoType($0CF2);
    public static property UNPACK_SKIP_ROWS:                PixelInfoType read new PixelInfoType($0CF3);
    public static property UNPACK_SKIP_PIXELS:              PixelInfoType read new PixelInfoType($0CF4);
    public static property UNPACK_ALIGNMENT:                PixelInfoType read new PixelInfoType($0CF5);
    public static property UNPACK_IMAGE_HEIGHT:             PixelInfoType read new PixelInfoType($806E);
    public static property UNPACK_SKIP_IMAGES:              PixelInfoType read new PixelInfoType($806D);
    public static property UNPACK_COMPRESSED_BLOCK_WIDTH:   PixelInfoType read new PixelInfoType($9127);
    public static property UNPACK_COMPRESSED_BLOCK_HEIGHT:  PixelInfoType read new PixelInfoType($9128);
    public static property UNPACK_COMPRESSED_BLOCK_DEPTH:   PixelInfoType read new PixelInfoType($9129);
    public static property UNPACK_COMPRESSED_BLOCK_SIZE:    PixelInfoType read new PixelInfoType($912A);
    public static property PACK_SWAP_BYTES:                 PixelInfoType read new PixelInfoType($0D00);
    public static property PACK_LSB_FIRST:                  PixelInfoType read new PixelInfoType($0D01);
    public static property PACK_ROW_LENGTH:                 PixelInfoType read new PixelInfoType($0D02);
    public static property PACK_SKIP_ROWS:                  PixelInfoType read new PixelInfoType($0D03);
    public static property PACK_SKIP_PIXELS:                PixelInfoType read new PixelInfoType($0D04);
    public static property PACK_ALIGNMENT:                  PixelInfoType read new PixelInfoType($0D05);
    public static property PACK_IMAGE_HEIGHT:               PixelInfoType read new PixelInfoType($806C);
    public static property PACK_SKIP_IMAGES:                PixelInfoType read new PixelInfoType($806B);
    public static property PACK_COMPRESSED_BLOCK_WIDTH:     PixelInfoType read new PixelInfoType($912B);
    public static property PACK_COMPRESSED_BLOCK_HEIGHT:    PixelInfoType read new PixelInfoType($912C);
    public static property PACK_COMPRESSED_BLOCK_DEPTH:     PixelInfoType read new PixelInfoType($912D);
    public static property PACK_COMPRESSED_BLOCK_SIZE:      PixelInfoType read new PixelInfoType($912E);
    
  end;
  
  //S
  TextureUnitId = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property Texture[i: integer]: TextureUnitId read new TextureUnitId($84C0+i);
    
  end;
  
  //S
  FramebufferAttachmentPoint = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    // custom framebuffer
    public static property COLOR_ATTACHMENT[i: integer]:  FramebufferAttachmentPoint read new FramebufferAttachmentPoint($8CE0+i);
    public static property DEPTH_ATTACHMENT:              FramebufferAttachmentPoint read new FramebufferAttachmentPoint($8D00);
    public static property STENCIL_ATTACHMENT:            FramebufferAttachmentPoint read new FramebufferAttachmentPoint($8D20);
    public static property DEPTH_STENCIL_ATTACHMENT:      FramebufferAttachmentPoint read new FramebufferAttachmentPoint($821A);
    
    // default framebuffer
    public static property FRONT:                         FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0404);
    public static property FRONT_LEFT:                    FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0400);
    public static property FRONT_RIGHT:                   FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0401);
    public static property BACK:                          FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0405);
    public static property BACK_LEFT:                     FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0402);
    public static property BACK_RIGHT:                    FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0403);
    public static property DEPTH:                         FramebufferAttachmentPoint read new FramebufferAttachmentPoint($1801);
    public static property STENCIL:                       FramebufferAttachmentPoint read new FramebufferAttachmentPoint($1802);
    
  end;
  
  //S
  TextureBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property T_1D:                          TextureBindTarget read new TextureBindTarget($0DE0);
    public static property T_2D:                          TextureBindTarget read new TextureBindTarget($0DE1);
    public static property T_3D:                          TextureBindTarget read new TextureBindTarget($806F);
    public static property T_1D_ARRAY:                    TextureBindTarget read new TextureBindTarget($8C18);
    public static property T_2D_ARRAY:                    TextureBindTarget read new TextureBindTarget($8C1A);
    public static property T_RECTANGLE:                   TextureBindTarget read new TextureBindTarget($84F5);
    public static property T_BUFFER:                      TextureBindTarget read new TextureBindTarget($8C2A);
    public static property T_CUBE_MAP:                    TextureBindTarget read new TextureBindTarget($8513);
    public static property T_CUBE_MAP_ARRAY:              TextureBindTarget read new TextureBindTarget($9009);
    public static property T_2D_MULTISAMPLE:              TextureBindTarget read new TextureBindTarget($9100);
    public static property PROXY_T_2D_MULTISAMPLE:        TextureBindTarget read new TextureBindTarget($9101);
    public static property T_2D_MULTISAMPLE_ARRAY:        TextureBindTarget read new TextureBindTarget($9102);
    public static property PROXY_T_2D_MULTISAMPLE_ARRAY:  TextureBindTarget read new TextureBindTarget($9103);
    
  end;
  
  //S
  ShaderPrecisionFormatType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOW_FLOAT:     ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF0);
    public static property MEDIUM_FLOAT:  ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF1);
    public static property HIGH_FLOAT:    ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF2);
    public static property LOW_INT:       ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF3);
    public static property MEDIUM_INT:    ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF4);
    public static property HIGH_INT:      ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF5);
    
  end;
  
  //S
  ProgramInterfaceProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_VARIABLES:                      ProgramInterfaceProperty read new ProgramInterfaceProperty($9305);
    public static property BUFFER_BINDING:                        ProgramInterfaceProperty read new ProgramInterfaceProperty($9302);
    public static property NUM_ACTIVE_VARIABLES:                  ProgramInterfaceProperty read new ProgramInterfaceProperty($9304);
    public static property ARRAY_SIZE:                            ProgramInterfaceProperty read new ProgramInterfaceProperty($92FB);
    public static property ARRAY_STRIDE:                          ProgramInterfaceProperty read new ProgramInterfaceProperty($92FE);
    public static property BLOCK_INDEX:                           ProgramInterfaceProperty read new ProgramInterfaceProperty($92FD);
    public static property IS_ROW_MAJOR:                          ProgramInterfaceProperty read new ProgramInterfaceProperty($9300);
    public static property MATRIX_STRIDE:                         ProgramInterfaceProperty read new ProgramInterfaceProperty($92FF);
    public static property ATOMIC_COUNTER_BUFFER_INDEX:           ProgramInterfaceProperty read new ProgramInterfaceProperty($9301);
    public static property BUFFER_DATA_SIZE:                      ProgramInterfaceProperty read new ProgramInterfaceProperty($9303);
    public static property NUM_COMPATIBLE_SUBROUTINES:            ProgramInterfaceProperty read new ProgramInterfaceProperty($8E4A);
    public static property COMPATIBLE_SUBROUTINES:                ProgramInterfaceProperty read new ProgramInterfaceProperty($8E4B);
    public static property IS_PER_PATCH:                          ProgramInterfaceProperty read new ProgramInterfaceProperty($92E7);
    public static property LOCATION:                              ProgramInterfaceProperty read new ProgramInterfaceProperty($930E);
    public static property LOCATION_COMPONENT:                    ProgramInterfaceProperty read new ProgramInterfaceProperty($934A);
    public static property LOCATION_INDEX:                        ProgramInterfaceProperty read new ProgramInterfaceProperty($930F);
    public static property NAME_LENGTH:                           ProgramInterfaceProperty read new ProgramInterfaceProperty($92F9);
    public static property OFFSET:                                ProgramInterfaceProperty read new ProgramInterfaceProperty($92FC);
    public static property REFERENCED_BY_VERTEX_SHADER:           ProgramInterfaceProperty read new ProgramInterfaceProperty($9306);
    public static property REFERENCED_BY_TESS_CONTROL_SHADER:     ProgramInterfaceProperty read new ProgramInterfaceProperty($9307);
    public static property REFERENCED_BY_TESS_EVALUATION_SHADER:  ProgramInterfaceProperty read new ProgramInterfaceProperty($9308);
    public static property REFERENCED_BY_GEOMETRY_SHADER:         ProgramInterfaceProperty read new ProgramInterfaceProperty($9309);
    public static property REFERENCED_BY_FRAGMENT_SHADER:         ProgramInterfaceProperty read new ProgramInterfaceProperty($930A);
    public static property REFERENCED_BY_COMPUTE_SHADER:          ProgramInterfaceProperty read new ProgramInterfaceProperty($930B);
    public static property TRANSFORM_FEEDBACK_BUFFER_INDEX:       ProgramInterfaceProperty read new ProgramInterfaceProperty($934B);
    public static property TRANSFORM_FEEDBACK_BUFFER_STRIDE:      ProgramInterfaceProperty read new ProgramInterfaceProperty($934C);
    public static property TOP_LEVEL_ARRAY_SIZE:                  ProgramInterfaceProperty read new ProgramInterfaceProperty($930C);
    public static property TOP_LEVEL_ARRAY_STRIDE:                ProgramInterfaceProperty read new ProgramInterfaceProperty($930D);
    public static property &TYPE:                                 ProgramInterfaceProperty read new ProgramInterfaceProperty($92FA);
    
//    public static property TEXTURE_BUFFER:                         read new ProgramInterfaceProperty($8C2A); // типа существует, но это не точно
    
  end;
  
  //S
  ProgramInterfaceInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_RESOURCES:                ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F5);
    public static property MAX_NAME_LENGTH:                 ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F6);
    public static property MAX_NUM_ACTIVE_VARIABLES:        ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F7);
    public static property MAX_NUM_COMPATIBLE_SUBROUTINES:  ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F8);
    
  end;
  
  //S
  ProgramInterfaceType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORM:                             ProgramInterfaceType read new ProgramInterfaceType($92E1);
    public static property UNIFORM_BLOCK:                       ProgramInterfaceType read new ProgramInterfaceType($92E2);
    public static property ATOMIC_COUNTER_BUFFER:               ProgramInterfaceType read new ProgramInterfaceType($92C0);
    public static property PROGRAM_INPUT:                       ProgramInterfaceType read new ProgramInterfaceType($92E3);
    public static property PROGRAM_OUTPUT:                      ProgramInterfaceType read new ProgramInterfaceType($92E4);
    public static property VERTEX_SUBROUTINE:                   ProgramInterfaceType read new ProgramInterfaceType($92E8);
    public static property TESS_CONTROL_SUBROUTINE:             ProgramInterfaceType read new ProgramInterfaceType($92E9);
    public static property TESS_EVALUATION_SUBROUTINE:          ProgramInterfaceType read new ProgramInterfaceType($92EA);
    public static property GEOMETRY_SUBROUTINE:                 ProgramInterfaceType read new ProgramInterfaceType($92EB);
    public static property FRAGMENT_SUBROUTINE:                 ProgramInterfaceType read new ProgramInterfaceType($92EC);
    public static property COMPUTE_SUBROUTINE:                  ProgramInterfaceType read new ProgramInterfaceType($92ED);
    public static property VERTEX_SUBROUTINE_UNIFORM:           ProgramInterfaceType read new ProgramInterfaceType($92EE);
    public static property TESS_CONTROL_SUBROUTINE_UNIFORM:     ProgramInterfaceType read new ProgramInterfaceType($92EF);
    public static property TESS_EVALUATION_SUBROUTINE_UNIFORM:  ProgramInterfaceType read new ProgramInterfaceType($92F0);
    public static property GEOMETRY_SUBROUTINE_UNIFORM:         ProgramInterfaceType read new ProgramInterfaceType($92F1);
    public static property FRAGMENT_SUBROUTINE_UNIFORM:         ProgramInterfaceType read new ProgramInterfaceType($92F2);
    public static property COMPUTE_SUBROUTINE_UNIFORM:          ProgramInterfaceType read new ProgramInterfaceType($92F3);
    public static property TRANSFORM_FEEDBACK_VARYING:          ProgramInterfaceType read new ProgramInterfaceType($92F4);
    public static property BUFFER_VARIABLE:                     ProgramInterfaceType read new ProgramInterfaceType($92E5);
    public static property SHADER_STORAGE_BLOCK:                ProgramInterfaceType read new ProgramInterfaceType($92E6);
    public static property TRANSFORM_FEEDBACK_BUFFER:           ProgramInterfaceType read new ProgramInterfaceType($8C8E);
    
  end;
  
  //S
  ProgramParameterType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEPARABLE:               ProgramParameterType read new ProgramParameterType($8258);
    public static property BINARY_RETRIEVABLE_HINT: ProgramParameterType read new ProgramParameterType($8257);
    
  end;
  
  //S
  ShaderType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_SHADER:           ShaderType read new ShaderType($8B31);
    public static property TESS_CONTROL_SHADER:     ShaderType read new ShaderType($8E88);
    public static property TESS_EVALUATION_SHADER:  ShaderType read new ShaderType($8E87);
    public static property GEOMETRY_SHADER:         ShaderType read new ShaderType($8DD9);
    public static property FRAGMENT_SHADER:         ShaderType read new ShaderType($8B30);
    public static property COMPUTE_SHADER:          ShaderType read new ShaderType($91B9);
    
  end;
  
  //S
  SyncObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_SYNC_FENCE: SyncObjectType read new SyncObjectType($9116);
    
  end;
  
  //S
  FenceStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNALED:  FenceStatus read new FenceStatus($9118);
    public static property SIGNALED:    FenceStatus read new FenceStatus($9119);
    
  end;
  
  //S
  FenceCondition = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_SYNC_GPU_COMMANDS_COMPLETE: FenceCondition read new FenceCondition($9117);
    
  end;
  
  //S
  BufferBindType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ARRAY_BUFFER:              BufferBindType read new BufferBindType($8892);
    public static property ATOMIC_COUNTER_BUFFER:     BufferBindType read new BufferBindType($92C0);
    public static property COPY_READ_BUFFER:          BufferBindType read new BufferBindType($8F36);
    public static property COPY_WRITE_BUFFER:         BufferBindType read new BufferBindType($8F37);
    public static property DISPATCH_INDIRECT_BUFFER:  BufferBindType read new BufferBindType($90EE);
    public static property DRAW_INDIRECT_BUFFER:      BufferBindType read new BufferBindType($8F3F);
    public static property ELEMENT_ARRAY_BUFFER:      BufferBindType read new BufferBindType($8893);
    public static property PIXEL_PACK_BUFFER:         BufferBindType read new BufferBindType($88EB);
    public static property PIXEL_UNPACK_BUFFER:       BufferBindType read new BufferBindType($88EC);
    public static property QUERY_BUFFER:              BufferBindType read new BufferBindType($9192);
    public static property SHADER_STORAGE_BUFFER:     BufferBindType read new BufferBindType($90D2);
    public static property TEXTURE_BUFFER:            BufferBindType read new BufferBindType($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: BufferBindType read new BufferBindType($8C8E);
    public static property UNIFORM_BUFFER:            BufferBindType read new BufferBindType($8A11);
    
  end;
  
  //S
  CopyableImageType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ARRAY_BUFFER:              CopyableImageType read new CopyableImageType($8892);
    public static property ATOMIC_COUNTER_BUFFER:     CopyableImageType read new CopyableImageType($92C0);
    public static property COPY_READ_BUFFER:          CopyableImageType read new CopyableImageType($8F36);
    public static property COPY_WRITE_BUFFER:         CopyableImageType read new CopyableImageType($8F37);
    public static property DISPATCH_INDIRECT_BUFFER:  CopyableImageType read new CopyableImageType($90EE);
    public static property DRAW_INDIRECT_BUFFER:      CopyableImageType read new CopyableImageType($8F3F);
    public static property ELEMENT_ARRAY_BUFFER:      CopyableImageType read new CopyableImageType($8893);
    public static property PIXEL_PACK_BUFFER:         CopyableImageType read new CopyableImageType($88EB);
    public static property PIXEL_UNPACK_BUFFER:       CopyableImageType read new CopyableImageType($88EC);
    public static property QUERY_BUFFER:              CopyableImageType read new CopyableImageType($9192);
    public static property SHADER_STORAGE_BUFFER:     CopyableImageType read new CopyableImageType($90D2);
    public static property TEXTURE_BUFFER:            CopyableImageType read new CopyableImageType($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: CopyableImageType read new CopyableImageType($8C8E);
    public static property UNIFORM_BUFFER:            CopyableImageType read new CopyableImageType($8A11);
    
    public static property GL_RENDERBUFFER:           CopyableImageType read new CopyableImageType($8D41);
    
  end;
  
  //S
  BufferDataUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STREAM_DRAW:   BufferDataUsage read new BufferDataUsage($88E0);
    public static property STREAM_READ:   BufferDataUsage read new BufferDataUsage($88E1);
    public static property STREAM_COPY:   BufferDataUsage read new BufferDataUsage($88E2);
    public static property STATIC_DRAW:   BufferDataUsage read new BufferDataUsage($88E4);
    public static property STATIC_READ:   BufferDataUsage read new BufferDataUsage($88E5);
    public static property STATIC_COPY:   BufferDataUsage read new BufferDataUsage($88E6);
    public static property DYNAMIC_DRAW:  BufferDataUsage read new BufferDataUsage($88E8);
    public static property DYNAMIC_READ:  BufferDataUsage read new BufferDataUsage($88E9);
    public static property DYNAMIC_COPY:  BufferDataUsage read new BufferDataUsage($88EA);
    
  end;
  
  //S
  InternalDataFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property R8:        InternalDataFormat read new InternalDataFormat($8229);
    public static property R8I:       InternalDataFormat read new InternalDataFormat($8231);
    public static property R8UI:      InternalDataFormat read new InternalDataFormat($8232);
    public static property R16:       InternalDataFormat read new InternalDataFormat($822A);
    public static property R16I:      InternalDataFormat read new InternalDataFormat($8233);
    public static property R16UI:     InternalDataFormat read new InternalDataFormat($8234);
    public static property R16F:      InternalDataFormat read new InternalDataFormat($822D);
    public static property R32I:      InternalDataFormat read new InternalDataFormat($8235);
    public static property R32UI:     InternalDataFormat read new InternalDataFormat($8236);
    public static property R32F:      InternalDataFormat read new InternalDataFormat($822E);
    
    public static property RG8:       InternalDataFormat read new InternalDataFormat($822B);
    public static property RG8I:      InternalDataFormat read new InternalDataFormat($8237);
    public static property RG8UI:     InternalDataFormat read new InternalDataFormat($8238);
    public static property RG16:      InternalDataFormat read new InternalDataFormat($822C);
    public static property RG16I:     InternalDataFormat read new InternalDataFormat($8239);
    public static property RG16UI:    InternalDataFormat read new InternalDataFormat($823A);
    public static property RG16F:     InternalDataFormat read new InternalDataFormat($822F);
    public static property RG32I:     InternalDataFormat read new InternalDataFormat($823B);
    public static property RG32UI:    InternalDataFormat read new InternalDataFormat($823C);
    public static property RG32F:     InternalDataFormat read new InternalDataFormat($8230);
    
    public static property RGB8:      InternalDataFormat read new InternalDataFormat($8051);
    public static property RGB8I:     InternalDataFormat read new InternalDataFormat($8D8F);
    public static property RGB8UI:    InternalDataFormat read new InternalDataFormat($8D7D);
    public static property RGB16:     InternalDataFormat read new InternalDataFormat($8054);
    public static property RGB16I:    InternalDataFormat read new InternalDataFormat($8D89);
    public static property RGB16UI:   InternalDataFormat read new InternalDataFormat($8D77);
    public static property RGB16F:    InternalDataFormat read new InternalDataFormat($881B);
    public static property RGB32I:    InternalDataFormat read new InternalDataFormat($8D83);
    public static property RGB32UI:   InternalDataFormat read new InternalDataFormat($8D71);
    public static property RGB32F:    InternalDataFormat read new InternalDataFormat($8815);
    
    public static property RGBA8:     InternalDataFormat read new InternalDataFormat($8058);
    public static property RGBA16:    InternalDataFormat read new InternalDataFormat($805B);
    public static property RGBA16F:   InternalDataFormat read new InternalDataFormat($881A);
    public static property RGBA32F:   InternalDataFormat read new InternalDataFormat($8814);
    public static property RGBA8I:    InternalDataFormat read new InternalDataFormat($8D8E);
    public static property RGBA16I:   InternalDataFormat read new InternalDataFormat($8D88);
    public static property RGBA32I:   InternalDataFormat read new InternalDataFormat($8D82);
    public static property RGBA8UI:   InternalDataFormat read new InternalDataFormat($8D7C);
    public static property RGBA16UI:  InternalDataFormat read new InternalDataFormat($8D76);
    public static property RGBA32UI:  InternalDataFormat read new InternalDataFormat($8D70);
    
    public static property RGB4:      InternalDataFormat read new InternalDataFormat($804F);
    public static property RGB5:      InternalDataFormat read new InternalDataFormat($8050);
    public static property RGB10:     InternalDataFormat read new InternalDataFormat($8052);
    public static property RGB12:     InternalDataFormat read new InternalDataFormat($8053);
    public static property RGB5_A1:   InternalDataFormat read new InternalDataFormat($8057);
    public static property RGB10_A2:  InternalDataFormat read new InternalDataFormat($8059);
    
    public static property RGBA2:     InternalDataFormat read new InternalDataFormat($8055);
    public static property RGBA4:     InternalDataFormat read new InternalDataFormat($8056);
    public static property RGBA12:    InternalDataFormat read new InternalDataFormat($805A);
    
  end;
  
  //S
  DataFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RED:             DataFormat read new DataFormat($1903);
    public static property GREEN:           DataFormat read new DataFormat($1904);
    public static property BLUE:            DataFormat read new DataFormat($1905);
    public static property RG:              DataFormat read new DataFormat($8227);
    public static property RGB:             DataFormat read new DataFormat($1907);
    public static property BGR:             DataFormat read new DataFormat($80E0);
    public static property RGBA:            DataFormat read new DataFormat($1908);
    public static property BGRA:            DataFormat read new DataFormat($80E1);
    public static property RED_INTEGER:     DataFormat read new DataFormat($8D94);
    public static property GREEN_INTEGER:   DataFormat read new DataFormat($8D95);
    public static property BLUE_INTEGER:    DataFormat read new DataFormat($8D96);
    public static property RGB_INTEGER:     DataFormat read new DataFormat($8D98);
    public static property RGBA_INTEGER:    DataFormat read new DataFormat($8D99);
    public static property BGR_INTEGER:     DataFormat read new DataFormat($8D9A);
    public static property BGRA_INTEGER:    DataFormat read new DataFormat($8D9B);
    public static property RG_INTEGER:      DataFormat read new DataFormat($8228);
    public static property STENCIL_INDEX:   DataFormat read new DataFormat($1901);
    public static property DEPTH_COMPONENT: DataFormat read new DataFormat($1902);
    public static property DEPTH_STENCIL:   DataFormat read new DataFormat($84F9);
    
  end;
  
  //S
  GLGetQueries = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_TEXTURE:                            GLGetQueries read new GLGetQueries($84E0);
    public static property ALIASED_LINE_WIDTH_RANGE:                  GLGetQueries read new GLGetQueries($846E);
    public static property ARRAY_BUFFER_BINDING:                      GLGetQueries read new GLGetQueries($8894);
    public static property BLEND_COLOR:                               GLGetQueries read new GLGetQueries($8005);
    public static property BLEND_DST_ALPHA:                           GLGetQueries read new GLGetQueries($80CA);
    public static property BLEND_DST_RGB:                             GLGetQueries read new GLGetQueries($80C8);
    public static property BLEND_EQUATION_RGB:                        GLGetQueries read new GLGetQueries($8009);
    public static property BLEND_EQUATION_ALPHA:                      GLGetQueries read new GLGetQueries($883D);
    public static property BLEND_SRC_ALPHA:                           GLGetQueries read new GLGetQueries($80CB);
    public static property BLEND_SRC_RGB:                             GLGetQueries read new GLGetQueries($80C9);
    public static property COLOR_CLEAR_VALUE:                         GLGetQueries read new GLGetQueries($0C22);
    public static property COLOR_WRITEMASK:                           GLGetQueries read new GLGetQueries($0C23);
    public static property COMPRESSED_TEXTURE_FORMATS:                GLGetQueries read new GLGetQueries($86A3);
    public static property MAX_COMPUTE_SHADER_STORAGE_BLOCKS:         GLGetQueries read new GLGetQueries($90DB);
    public static property MAX_COMBINED_SHADER_STORAGE_BLOCKS:        GLGetQueries read new GLGetQueries($90DC);
    public static property MAX_COMPUTE_UNIFORM_BLOCKS:                GLGetQueries read new GLGetQueries($91BB);
    public static property MAX_COMPUTE_TEXTURE_IMAGE_UNITS:           GLGetQueries read new GLGetQueries($91BC);
    public static property MAX_COMPUTE_UNIFORM_COMPONENTS:            GLGetQueries read new GLGetQueries($8263);
    public static property MAX_COMPUTE_ATOMIC_COUNTERS:               GLGetQueries read new GLGetQueries($8265);
    public static property MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS:        GLGetQueries read new GLGetQueries($8264);
    public static property MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS:   GLGetQueries read new GLGetQueries($8266);
    public static property MAX_COMPUTE_WORK_GROUP_INVOCATIONS:        GLGetQueries read new GLGetQueries($90EB);
    public static property MAX_COMPUTE_WORK_GROUP_COUNT:              GLGetQueries read new GLGetQueries($91BE);
    public static property MAX_COMPUTE_WORK_GROUP_SIZE:               GLGetQueries read new GLGetQueries($91BF);
    public static property DISPATCH_INDIRECT_BUFFER_BINDING:          GLGetQueries read new GLGetQueries($90EF);
    public static property MAX_DEBUG_GROUP_STACK_DEPTH:               GLGetQueries read new GLGetQueries($826C);
    public static property DEBUG_GROUP_STACK_DEPTH:                   GLGetQueries read new GLGetQueries($826D);
    public static property CONTEXT_FLAGS:                             GLGetQueries read new GLGetQueries($821E);
    public static property CULL_FACE_MODE:                            GLGetQueries read new GLGetQueries($0B45);
    public static property CURRENT_PROGRAM:                           GLGetQueries read new GLGetQueries($8B8D);
    public static property DEPTH_CLEAR_VALUE:                         GLGetQueries read new GLGetQueries($0B73);
    public static property DEPTH_FUNC:                                GLGetQueries read new GLGetQueries($0B74);
    public static property DEPTH_RANGE:                               GLGetQueries read new GLGetQueries($0B70);
    public static property DEPTH_WRITEMASK:                           GLGetQueries read new GLGetQueries($0B72);
    public static property DOUBLEBUFFER:                              GLGetQueries read new GLGetQueries($0C32);
    public static property DRAW_BUFFER:                               GLGetQueries read new GLGetQueries($0C01);
    public static property DRAW_FRAMEBUFFER_BINDING:                  GLGetQueries read new GLGetQueries($8CA6);
    public static property READ_FRAMEBUFFER_BINDING:                  GLGetQueries read new GLGetQueries($8CAA);
    public static property ELEMENT_ARRAY_BUFFER_BINDING:              GLGetQueries read new GLGetQueries($8895);
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT:           GLGetQueries read new GLGetQueries($8B8B);
    public static property IMPLEMENTATION_COLOR_READ_FORMAT:          GLGetQueries read new GLGetQueries($8B9B);
    public static property IMPLEMENTATION_COLOR_READ_TYPE:            GLGetQueries read new GLGetQueries($8B9A);
    public static property LINE_SMOOTH_HINT:                          GLGetQueries read new GLGetQueries($0C52);
    public static property LINE_WIDTH:                                GLGetQueries read new GLGetQueries($0B21);
    public static property LAYER_PROVOKING_VERTEX:                    GLGetQueries read new GLGetQueries($825E);
    public static property LOGIC_OP_MODE:                             GLGetQueries read new GLGetQueries($0BF0);
    public static property MAJOR_VERSION:                             GLGetQueries read new GLGetQueries($821B);
    public static property MAX_3D_TEXTURE_SIZE:                       GLGetQueries read new GLGetQueries($8073);
    public static property MAX_ARRAY_TEXTURE_LAYERS:                  GLGetQueries read new GLGetQueries($88FF);
    public static property MAX_CLIP_DISTANCES:                        GLGetQueries read new GLGetQueries($0D32);
    public static property MAX_COLOR_TEXTURE_SAMPLES:                 GLGetQueries read new GLGetQueries($910E);
    public static property MAX_COMBINED_ATOMIC_COUNTERS:              GLGetQueries read new GLGetQueries($92D7);
    public static property MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:  GLGetQueries read new GLGetQueries($8A33);
    public static property MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS:  GLGetQueries read new GLGetQueries($8A32);
    public static property MAX_COMBINED_TEXTURE_IMAGE_UNITS:          GLGetQueries read new GLGetQueries($8B4D);
    public static property MAX_COMBINED_UNIFORM_BLOCKS:               GLGetQueries read new GLGetQueries($8A2E);
    public static property MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:    GLGetQueries read new GLGetQueries($8A31);
    public static property MAX_CUBE_MAP_TEXTURE_SIZE:                 GLGetQueries read new GLGetQueries($851C);
    public static property MAX_DEPTH_TEXTURE_SAMPLES:                 GLGetQueries read new GLGetQueries($910F);
    public static property MAX_DRAW_BUFFERS:                          GLGetQueries read new GLGetQueries($8824);
    public static property MAX_DUAL_SOURCE_DRAW_BUFFERS:              GLGetQueries read new GLGetQueries($88FC);
    public static property MAX_ELEMENTS_INDICES:                      GLGetQueries read new GLGetQueries($80E9);
    public static property MAX_ELEMENTS_VERTICES:                     GLGetQueries read new GLGetQueries($80E8);
    public static property MAX_FRAGMENT_ATOMIC_COUNTERS:              GLGetQueries read new GLGetQueries($92D6);
    public static property MAX_FRAGMENT_SHADER_STORAGE_BLOCKS:        GLGetQueries read new GLGetQueries($90DA);
    public static property MAX_FRAGMENT_INPUT_COMPONENTS:             GLGetQueries read new GLGetQueries($9125);
    public static property MAX_FRAGMENT_UNIFORM_COMPONENTS:           GLGetQueries read new GLGetQueries($8B49);
    public static property MAX_FRAGMENT_UNIFORM_VECTORS:              GLGetQueries read new GLGetQueries($8DFD);
    public static property MAX_FRAGMENT_UNIFORM_BLOCKS:               GLGetQueries read new GLGetQueries($8A2D);
    public static property MAX_FRAMEBUFFER_WIDTH:                     GLGetQueries read new GLGetQueries($9315);
    public static property MAX_FRAMEBUFFER_HEIGHT:                    GLGetQueries read new GLGetQueries($9316);
    public static property MAX_FRAMEBUFFER_LAYERS:                    GLGetQueries read new GLGetQueries($9317);
    public static property MAX_FRAMEBUFFER_SAMPLES:                   GLGetQueries read new GLGetQueries($9318);
    public static property MAX_GEOMETRY_ATOMIC_COUNTERS:              GLGetQueries read new GLGetQueries($92D5);
    public static property MAX_GEOMETRY_SHADER_STORAGE_BLOCKS:        GLGetQueries read new GLGetQueries($90D7);
    public static property MAX_GEOMETRY_INPUT_COMPONENTS:             GLGetQueries read new GLGetQueries($9123);
    public static property MAX_GEOMETRY_OUTPUT_COMPONENTS:            GLGetQueries read new GLGetQueries($9124);
    public static property MAX_GEOMETRY_TEXTURE_IMAGE_UNITS:          GLGetQueries read new GLGetQueries($8C29);
    public static property MAX_GEOMETRY_UNIFORM_BLOCKS:               GLGetQueries read new GLGetQueries($8A2C);
    public static property MAX_GEOMETRY_UNIFORM_COMPONENTS:           GLGetQueries read new GLGetQueries($8DDF);
    public static property MAX_INTEGER_SAMPLES:                       GLGetQueries read new GLGetQueries($9110);
    public static property MIN_MAP_BUFFER_ALIGNMENT:                  GLGetQueries read new GLGetQueries($90BC);
    public static property MAX_LABEL_LENGTH:                          GLGetQueries read new GLGetQueries($82E8);
    public static property MAX_PROGRAM_TEXEL_OFFSET:                  GLGetQueries read new GLGetQueries($8905);
    public static property MIN_PROGRAM_TEXEL_OFFSET:                  GLGetQueries read new GLGetQueries($8904);
    public static property MAX_RECTANGLE_TEXTURE_SIZE:                GLGetQueries read new GLGetQueries($84F8);
    public static property MAX_RENDERBUFFER_SIZE:                     GLGetQueries read new GLGetQueries($84E8);
    public static property MAX_SAMPLE_MASK_WORDS:                     GLGetQueries read new GLGetQueries($8E59);
    public static property MAX_SERVER_WAIT_TIMEOUT:                   GLGetQueries read new GLGetQueries($9111);
    public static property MAX_SHADER_STORAGE_BUFFER_BINDINGS:        GLGetQueries read new GLGetQueries($90DD);
    public static property MAX_TESS_CONTROL_ATOMIC_COUNTERS:          GLGetQueries read new GLGetQueries($92D3);
    public static property MAX_TESS_EVALUATION_ATOMIC_COUNTERS:       GLGetQueries read new GLGetQueries($92D4);
    public static property MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS:    GLGetQueries read new GLGetQueries($90D8);
    public static property MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS: GLGetQueries read new GLGetQueries($90D9);
    public static property MAX_TEXTURE_BUFFER_SIZE:                   GLGetQueries read new GLGetQueries($8C2B);
    public static property MAX_TEXTURE_IMAGE_UNITS:                   GLGetQueries read new GLGetQueries($8872);
    public static property MAX_TEXTURE_LOD_BIAS:                      GLGetQueries read new GLGetQueries($84FD);
    public static property MAX_TEXTURE_SIZE:                          GLGetQueries read new GLGetQueries($0D33);
    public static property MAX_UNIFORM_BUFFER_BINDINGS:               GLGetQueries read new GLGetQueries($8A2F);
    public static property MAX_UNIFORM_BLOCK_SIZE:                    GLGetQueries read new GLGetQueries($8A30);
    public static property MAX_UNIFORM_LOCATIONS:                     GLGetQueries read new GLGetQueries($826E);
    public static property MAX_VARYING_COMPONENTS:                    GLGetQueries read new GLGetQueries($8B4B);
    public static property MAX_VARYING_VECTORS:                       GLGetQueries read new GLGetQueries($8DFC);
    public static property MAX_VARYING_FLOATS:                        GLGetQueries read new GLGetQueries($8B4B);
    public static property MAX_VERTEX_ATOMIC_COUNTERS:                GLGetQueries read new GLGetQueries($92D2);
    public static property MAX_VERTEX_ATTRIBS:                        GLGetQueries read new GLGetQueries($8869);
    public static property MAX_VERTEX_SHADER_STORAGE_BLOCKS:          GLGetQueries read new GLGetQueries($90D6);
    public static property MAX_VERTEX_TEXTURE_IMAGE_UNITS:            GLGetQueries read new GLGetQueries($8B4C);
    public static property MAX_VERTEX_UNIFORM_COMPONENTS:             GLGetQueries read new GLGetQueries($8B4A);
    public static property MAX_VERTEX_UNIFORM_VECTORS:                GLGetQueries read new GLGetQueries($8DFB);
    public static property MAX_VERTEX_OUTPUT_COMPONENTS:              GLGetQueries read new GLGetQueries($9122);
    public static property MAX_VERTEX_UNIFORM_BLOCKS:                 GLGetQueries read new GLGetQueries($8A2B);
    public static property MAX_VIEWPORT_DIMS:                         GLGetQueries read new GLGetQueries($0D3A);
    public static property MAX_VIEWPORTS:                             GLGetQueries read new GLGetQueries($825B);
    public static property MINOR_VERSION:                             GLGetQueries read new GLGetQueries($821C);
    public static property NUM_COMPRESSED_TEXTURE_FORMATS:            GLGetQueries read new GLGetQueries($86A2);
    public static property NUM_EXTENSIONS:                            GLGetQueries read new GLGetQueries($821D);
    public static property NUM_PROGRAM_BINARY_FORMATS:                GLGetQueries read new GLGetQueries($87FE);
    public static property NUM_SHADER_BINARY_FORMATS:                 GLGetQueries read new GLGetQueries($8DF9);
    public static property PACK_ALIGNMENT:                            GLGetQueries read new GLGetQueries($0D05);
    public static property PACK_IMAGE_HEIGHT:                         GLGetQueries read new GLGetQueries($806C);
    public static property PACK_LSB_FIRST:                            GLGetQueries read new GLGetQueries($0D01);
    public static property PACK_ROW_LENGTH:                           GLGetQueries read new GLGetQueries($0D02);
    public static property PACK_SKIP_IMAGES:                          GLGetQueries read new GLGetQueries($806B);
    public static property PACK_SKIP_PIXELS:                          GLGetQueries read new GLGetQueries($0D04);
    public static property PACK_SKIP_ROWS:                            GLGetQueries read new GLGetQueries($0D03);
    public static property PACK_SWAP_BYTES:                           GLGetQueries read new GLGetQueries($0D00);
    public static property PIXEL_PACK_BUFFER_BINDING:                 GLGetQueries read new GLGetQueries($88ED);
    public static property PIXEL_UNPACK_BUFFER_BINDING:               GLGetQueries read new GLGetQueries($88EF);
    public static property POINT_FADE_THRESHOLD_SIZE:                 GLGetQueries read new GLGetQueries($8128);
    public static property PRIMITIVE_RESTART_INDEX:                   GLGetQueries read new GLGetQueries($8F9E);
    public static property PROGRAM_BINARY_FORMATS:                    GLGetQueries read new GLGetQueries($87FF);
    public static property PROGRAM_PIPELINE_BINDING:                  GLGetQueries read new GLGetQueries($825A);
    public static property PROGRAM_POINT_SIZE:                        GLGetQueries read new GLGetQueries($8642);
    public static property PROVOKING_VERTEX:                          GLGetQueries read new GLGetQueries($8E4F);
    public static property POINT_SIZE:                                GLGetQueries read new GLGetQueries($0B11);
    public static property POINT_SIZE_GRANULARITY:                    GLGetQueries read new GLGetQueries($0B13);
    public static property POINT_SIZE_RANGE:                          GLGetQueries read new GLGetQueries($0B12);
    public static property POLYGON_OFFSET_FACTOR:                     GLGetQueries read new GLGetQueries($8038);
    public static property POLYGON_OFFSET_UNITS:                      GLGetQueries read new GLGetQueries($2A00);
    public static property POLYGON_SMOOTH_HINT:                       GLGetQueries read new GLGetQueries($0C53);
    public static property READ_BUFFER:                               GLGetQueries read new GLGetQueries($0C02);
    public static property RENDERBUFFER_BINDING:                      GLGetQueries read new GLGetQueries($8CA7);
    public static property SAMPLE_BUFFERS:                            GLGetQueries read new GLGetQueries($80A8);
    public static property SAMPLE_COVERAGE_VALUE:                     GLGetQueries read new GLGetQueries($80AA);
    public static property SAMPLE_COVERAGE_INVERT:                    GLGetQueries read new GLGetQueries($80AB);
    public static property SAMPLER_BINDING:                           GLGetQueries read new GLGetQueries($8919);
    public static property SAMPLES:                                   GLGetQueries read new GLGetQueries($80A9);
    public static property SCISSOR_BOX:                               GLGetQueries read new GLGetQueries($0C10);
    public static property SHADER_COMPILER:                           GLGetQueries read new GLGetQueries($8DFA);
    public static property SHADER_STORAGE_BUFFER_BINDING:             GLGetQueries read new GLGetQueries($90D3);
    public static property SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT:    GLGetQueries read new GLGetQueries($90DF);
    public static property SHADER_STORAGE_BUFFER_START:               GLGetQueries read new GLGetQueries($90D4);
    public static property SHADER_STORAGE_BUFFER_SIZE:                GLGetQueries read new GLGetQueries($90D5);
    public static property SMOOTH_LINE_WIDTH_RANGE:                   GLGetQueries read new GLGetQueries($0B22);
    public static property SMOOTH_LINE_WIDTH_GRANULARITY:             GLGetQueries read new GLGetQueries($0B23);
    public static property STENCIL_BACK_FAIL:                         GLGetQueries read new GLGetQueries($8801);
    public static property STENCIL_BACK_FUNC:                         GLGetQueries read new GLGetQueries($8800);
    public static property STENCIL_BACK_PASS_DEPTH_FAIL:              GLGetQueries read new GLGetQueries($8802);
    public static property STENCIL_BACK_PASS_DEPTH_PASS:              GLGetQueries read new GLGetQueries($8803);
    public static property STENCIL_BACK_REF:                          GLGetQueries read new GLGetQueries($8CA3);
    public static property STENCIL_BACK_VALUE_MASK:                   GLGetQueries read new GLGetQueries($8CA4);
    public static property STENCIL_BACK_WRITEMASK:                    GLGetQueries read new GLGetQueries($8CA5);
    public static property STENCIL_CLEAR_VALUE:                       GLGetQueries read new GLGetQueries($0B91);
    public static property STENCIL_FAIL:                              GLGetQueries read new GLGetQueries($0B94);
    public static property STENCIL_FUNC:                              GLGetQueries read new GLGetQueries($0B92);
    public static property STENCIL_PASS_DEPTH_FAIL:                   GLGetQueries read new GLGetQueries($0B95);
    public static property STENCIL_PASS_DEPTH_PASS:                   GLGetQueries read new GLGetQueries($0B96);
    public static property STENCIL_REF:                               GLGetQueries read new GLGetQueries($0B97);
    public static property STENCIL_VALUE_MASK:                        GLGetQueries read new GLGetQueries($0B93);
    public static property STENCIL_WRITEMASK:                         GLGetQueries read new GLGetQueries($0B98);
    public static property STEREO:                                    GLGetQueries read new GLGetQueries($0C33);
    public static property SUBPIXEL_BITS:                             GLGetQueries read new GLGetQueries($0D50);
    public static property TEXTURE_BINDING_1D:                        GLGetQueries read new GLGetQueries($8068);
    public static property TEXTURE_BINDING_1D_ARRAY:                  GLGetQueries read new GLGetQueries($8C1C);
    public static property TEXTURE_BINDING_2D:                        GLGetQueries read new GLGetQueries($8069);
    public static property TEXTURE_BINDING_2D_ARRAY:                  GLGetQueries read new GLGetQueries($8C1D);
    public static property TEXTURE_BINDING_2D_MULTISAMPLE:            GLGetQueries read new GLGetQueries($9104);
    public static property TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY:      GLGetQueries read new GLGetQueries($9105);
    public static property TEXTURE_BINDING_3D:                        GLGetQueries read new GLGetQueries($806A);
    public static property TEXTURE_BINDING_BUFFER:                    GLGetQueries read new GLGetQueries($8C2C);
    public static property TEXTURE_BINDING_CUBE_MAP:                  GLGetQueries read new GLGetQueries($8514);
    public static property TEXTURE_BINDING_RECTANGLE:                 GLGetQueries read new GLGetQueries($84F6);
    public static property TEXTURE_COMPRESSION_HINT:                  GLGetQueries read new GLGetQueries($84EF);
    public static property TEXTURE_BUFFER_OFFSET_ALIGNMENT:           GLGetQueries read new GLGetQueries($919F);
    public static property TIMESTAMP:                                 GLGetQueries read new GLGetQueries($8E28);
    public static property TRANSFORM_FEEDBACK_BUFFER_BINDING:         GLGetQueries read new GLGetQueries($8C8F);
    public static property TRANSFORM_FEEDBACK_BUFFER_START:           GLGetQueries read new GLGetQueries($8C84);
    public static property TRANSFORM_FEEDBACK_BUFFER_SIZE:            GLGetQueries read new GLGetQueries($8C85);
    public static property UNIFORM_BUFFER_BINDING:                    GLGetQueries read new GLGetQueries($8A28);
    public static property UNIFORM_BUFFER_OFFSET_ALIGNMENT:           GLGetQueries read new GLGetQueries($8A34);
    public static property UNIFORM_BUFFER_SIZE:                       GLGetQueries read new GLGetQueries($8A2A);
    public static property UNIFORM_BUFFER_START:                      GLGetQueries read new GLGetQueries($8A29);
    public static property UNPACK_ALIGNMENT:                          GLGetQueries read new GLGetQueries($0CF5);
    public static property UNPACK_IMAGE_HEIGHT:                       GLGetQueries read new GLGetQueries($806E);
    public static property UNPACK_LSB_FIRST:                          GLGetQueries read new GLGetQueries($0CF1);
    public static property UNPACK_ROW_LENGTH:                         GLGetQueries read new GLGetQueries($0CF2);
    public static property UNPACK_SKIP_IMAGES:                        GLGetQueries read new GLGetQueries($806D);
    public static property UNPACK_SKIP_PIXELS:                        GLGetQueries read new GLGetQueries($0CF4);
    public static property UNPACK_SKIP_ROWS:                          GLGetQueries read new GLGetQueries($0CF3);
    public static property UNPACK_SWAP_BYTES:                         GLGetQueries read new GLGetQueries($0CF0);
    public static property VERTEX_ARRAY_BINDING:                      GLGetQueries read new GLGetQueries($85B5);
    public static property VERTEX_BINDING_DIVISOR:                    GLGetQueries read new GLGetQueries($82D6);
    public static property VERTEX_BINDING_OFFSET:                     GLGetQueries read new GLGetQueries($82D7);
    public static property VERTEX_BINDING_STRIDE:                     GLGetQueries read new GLGetQueries($82D8);
    public static property MAX_VERTEX_ATTRIB_RELATIVE_OFFSET:         GLGetQueries read new GLGetQueries($82D9);
    public static property MAX_VERTEX_ATTRIB_BINDINGS:                GLGetQueries read new GLGetQueries($82DA);
    public static property VIEWPORT:                                  GLGetQueries read new GLGetQueries($0BA2);
    public static property VIEWPORT_BOUNDS_RANGE:                     GLGetQueries read new GLGetQueries($825D);
    public static property VIEWPORT_INDEX_PROVOKING_VERTEX:           GLGetQueries read new GLGetQueries($825F);
    public static property VIEWPORT_SUBPIXEL_BITS:                    GLGetQueries read new GLGetQueries($825C);
    public static property MAX_ELEMENT_INDEX:                         GLGetQueries read new GLGetQueries($8D6B);
    
  end;
  
  //S
  EnablableName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BLEND:                         EnablableName read new EnablableName($0BE2);
    public static property CLIP_DISTANCE0:                EnablableName read new EnablableName($3000);
    public static property CLIP_DISTANCE1:                EnablableName read new EnablableName($3001);
    public static property CLIP_DISTANCE2:                EnablableName read new EnablableName($3002);
    public static property CLIP_DISTANCE3:                EnablableName read new EnablableName($3003);
    public static property CLIP_DISTANCE4:                EnablableName read new EnablableName($3004);
    public static property CLIP_DISTANCE5:                EnablableName read new EnablableName($3005);
    public static property CLIP_DISTANCE6:                EnablableName read new EnablableName($3006);
    public static property CLIP_DISTANCE7:                EnablableName read new EnablableName($3007);
    public static property COLOR_LOGIC_OP:                EnablableName read new EnablableName($0BF2);
    public static property CULL_FACE:                     EnablableName read new EnablableName($0B44);
    public static property DEBUG_OUTPUT:                  EnablableName read new EnablableName($92E0);
    public static property DEBUG_OUTPUT_SYNCHRONOUS:      EnablableName read new EnablableName($8242);
    public static property DEPTH_CLAMP:                   EnablableName read new EnablableName($864F);
    public static property DEPTH_TEST:                    EnablableName read new EnablableName($0B71);
    public static property DITHER:                        EnablableName read new EnablableName($0BD0);
    public static property FRAMEBUFFER_SRGB:              EnablableName read new EnablableName($8DB9);
    public static property LINE_SMOOTH:                   EnablableName read new EnablableName($0B20);
    public static property MULTISAMPLE:                   EnablableName read new EnablableName($809D);
    public static property POLYGON_OFFSET_FILL:           EnablableName read new EnablableName($8037);
    public static property POLYGON_OFFSET_LINE:           EnablableName read new EnablableName($2A02);
    public static property POLYGON_OFFSET_POINT:          EnablableName read new EnablableName($2A01);
    public static property POLYGON_SMOOTH:                EnablableName read new EnablableName($0B41);
    public static property PRIMITIVE_RESTART:             EnablableName read new EnablableName($8F9D);
    public static property PRIMITIVE_RESTART_FIXED_INDEX: EnablableName read new EnablableName($8D69);
    public static property RASTERIZER_DISCARD:            EnablableName read new EnablableName($8C89);
    public static property SAMPLE_ALPHA_TO_COVERAGE:      EnablableName read new EnablableName($809E);
    public static property SAMPLE_ALPHA_TO_ONE:           EnablableName read new EnablableName($809F);
    public static property SAMPLE_COVERAGE:               EnablableName read new EnablableName($80A0);
    public static property SAMPLE_SHADING:                EnablableName read new EnablableName($8C36);
    public static property SAMPLE_MASK:                   EnablableName read new EnablableName($8E51);
    public static property SCISSOR_TEST:                  EnablableName read new EnablableName($0C11);
    public static property STENCIL_TEST:                  EnablableName read new EnablableName($0B90);
    public static property TEXTURE_CUBE_MAP_SEAMLESS:     EnablableName read new EnablableName($884F);
    public static property PROGRAM_POINT_SIZE:            EnablableName read new EnablableName($8642);
    
    public static function operator implicit(v: EnablableName): GLGetQueries := new GLGetQueries(v.val);
    
  end;
  
  //S
  GLGetStringQueries = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VENDOR:                    GLGetStringQueries read new GLGetStringQueries($1F00);
    public static property RENDERER:                  GLGetStringQueries read new GLGetStringQueries($1F01);
    public static property VERSION:                   GLGetStringQueries read new GLGetStringQueries($1F02);
    public static property EXTENSIONS:                GLGetStringQueries read new GLGetStringQueries($1F03);
    public static property SHADING_LANGUAGE_VERSION:  GLGetStringQueries read new GLGetStringQueries($8B8C);
    
  end;
  
  //SR
  ColorEncodingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LINEAR:  ColorEncodingMode read new ColorEncodingMode($2601);
    public static property SRGB:    ColorEncodingMode read new ColorEncodingMode($8C40);
    
    public property IS_LINEAR:  boolean read self = ColorEncodingMode.LINEAR;
    public property IS_SRGB:    boolean read self = ColorEncodingMode.SRGB;
    
    public function ToString: string; override;
    begin
      var res := typeof(ColorEncodingMode).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'ColorEncodingMode[{self.val}]':
        res[0].Substring(3);
    end;
    
  end;
  
  //SR
  DataType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:                        DataType read new DataType($1400);
    public static property UNSIGNED_BYTE:               DataType read new DataType($1401);
    public static property SHORT:                       DataType read new DataType($1402);
    public static property UNSIGNED_SHORT:              DataType read new DataType($1403);
    public static property INT:                         DataType read new DataType($1404);
    public static property UNSIGNED_INT:                DataType read new DataType($1405);
    public static property FLOAT:                       DataType read new DataType($1406);
    public static property HALF_FLOAT:                  DataType read new DataType($140B);
    public static property UNSIGNED_BYTE_3_3_2:         DataType read new DataType($8032);
    public static property UNSIGNED_SHORT_5_6_5:        DataType read new DataType($8363);
    public static property UNSIGNED_SHORT_4_4_4_4:      DataType read new DataType($8033);
    public static property UNSIGNED_SHORT_5_5_5_1:      DataType read new DataType($8034);
    public static property UNSIGNED_INT_8_8_8_8:        DataType read new DataType($8035);
    public static property UNSIGNED_INT_10_10_10_2:     DataType read new DataType($8036);
    public static property UNSIGNED_BYTE_2_3_3_REV:     DataType read new DataType($8362);
    public static property UNSIGNED_SHORT_5_6_5_REV:    DataType read new DataType($8364);
    public static property UNSIGNED_SHORT_4_4_4_4_REV:  DataType read new DataType($8365);
    public static property UNSIGNED_SHORT_1_5_5_5_REV:  DataType read new DataType($8366);
    public static property UNSIGNED_INT_8_8_8_8_REV:    DataType read new DataType($8367);
    public static property UNSIGNED_INT_2_10_10_10_REV: DataType read new DataType($8368);
    public static property SIGNED_NORMALIZED:           DataType read new DataType($8F9C);
    public static property UNSIGNED_NORMALIZED:         DataType read new DataType($8C17);
    
    public property IS_NONE:                        boolean read self.val = 0;
    public property IS_BYTE:                        boolean read self.val = BYTE.val;
    public property IS_UNSIGNED_BYTE:               boolean read self.val = UNSIGNED_BYTE.val;
    public property IS_SHORT:                       boolean read self.val = SHORT.val;
    public property IS_UNSIGNED_SHORT:              boolean read self.val = UNSIGNED_SHORT.val;
    public property IS_INT:                         boolean read self.val = INT.val;
    public property IS_UNSIGNED_INT:                boolean read self.val = UNSIGNED_INT.val;
    public property IS_FLOAT:                       boolean read self.val = FLOAT.val;
    public property IS_HALF_FLOAT:                  boolean read self.val = HALF_FLOAT.val;
    public property IS_UNSIGNED_BYTE_3_3_2:         boolean read self.val = UNSIGNED_BYTE_3_3_2.val;
    public property IS_UNSIGNED_SHORT_5_6_5:        boolean read self.val = UNSIGNED_SHORT_5_6_5.val;
    public property IS_UNSIGNED_SHORT_4_4_4_4:      boolean read self.val = UNSIGNED_SHORT_4_4_4_4.val;
    public property IS_UNSIGNED_SHORT_5_5_5_1:      boolean read self.val = UNSIGNED_SHORT_5_5_5_1.val;
    public property IS_UNSIGNED_INT_8_8_8_8:        boolean read self.val = UNSIGNED_INT_8_8_8_8.val;
    public property IS_UNSIGNED_INT_10_10_10_2:     boolean read self.val = UNSIGNED_INT_10_10_10_2.val;
    public property IS_UNSIGNED_BYTE_2_3_3_REV:     boolean read self.val = UNSIGNED_BYTE_2_3_3_REV.val;
    public property IS_UNSIGNED_SHORT_5_6_5_REV:    boolean read self.val = UNSIGNED_SHORT_5_6_5_REV.val;
    public property IS_UNSIGNED_SHORT_4_4_4_4_REV:  boolean read self.val = UNSIGNED_SHORT_4_4_4_4_REV.val;
    public property IS_UNSIGNED_SHORT_1_5_5_5_REV:  boolean read self.val = UNSIGNED_SHORT_1_5_5_5_REV.val;
    public property IS_UNSIGNED_INT_8_8_8_8_REV:    boolean read self.val = UNSIGNED_INT_8_8_8_8_REV.val;
    public property IS_UNSIGNED_INT_2_10_10_10_REV: boolean read self.val = UNSIGNED_INT_2_10_10_10_REV.val;
    public property IS_SIGNED_NORMALIZED:           boolean read self.val = SIGNED_NORMALIZED.val;
    public property IS_UNSIGNED_NORMALIZED:         boolean read self.val = UNSIGNED_NORMALIZED.val;
    
    public function ToString: string; override;
    begin
      var res := typeof(DataType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DataType[{self.val}]':
        res[0].Substring(3);
    end;
    
  end;
  
  //R
  ProgramVarType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property FLOAT:             boolean read self.val = $1406;
    public property FLOAT_VEC2:        boolean read self.val = $8B50;
    public property FLOAT_VEC3:        boolean read self.val = $8B51;
    public property FLOAT_VEC4:        boolean read self.val = $8B52;
    public property FLOAT_MAT2:        boolean read self.val = $8B5A;
    public property FLOAT_MAT3:        boolean read self.val = $8B5B;
    public property FLOAT_MAT4:        boolean read self.val = $8B5C;
    public property FLOAT_MAT2x3:      boolean read self.val = $8B65;
    public property FLOAT_MAT3x2:      boolean read self.val = $8B67;
    public property FLOAT_MAT2x4:      boolean read self.val = $8B66;
    public property FLOAT_MAT4x2:      boolean read self.val = $8B69;
    public property FLOAT_MAT3x4:      boolean read self.val = $8B68;
    public property FLOAT_MAT4x3:      boolean read self.val = $8B6A;
    public property INT:               boolean read self.val = $1404;
    public property INT_VEC2:          boolean read self.val = $8B53;
    public property INT_VEC3:          boolean read self.val = $8B54;
    public property INT_VEC4:          boolean read self.val = $8B55;
    public property UNSIGNED_INT:      boolean read self.val = $1405;
    public property UNSIGNED_INT_VEC2: boolean read self.val = $8DC6;
    public property UNSIGNED_INT_VEC3: boolean read self.val = $8DC7;
    public property UNSIGNED_INT_VEC4: boolean read self.val = $8DC8;
    public property DOUBLE:            boolean read self.val = $140A;
    public property DOUBLE_VEC2:       boolean read self.val = $8FFC;
    public property DOUBLE_VEC3:       boolean read self.val = $8FFD;
    public property DOUBLE_VEC4:       boolean read self.val = $8FFE;
    public property DOUBLE_MAT2:       boolean read self.val = $8F46;
    public property DOUBLE_MAT3:       boolean read self.val = $8F47;
    public property DOUBLE_MAT4:       boolean read self.val = $8F48;
    public property DOUBLE_MAT2x3:     boolean read self.val = $8F49;
    public property DOUBLE_MAT3x2:     boolean read self.val = $8F4B;
    public property DOUBLE_MAT2x4:     boolean read self.val = $8F4A;
    public property DOUBLE_MAT4x2:     boolean read self.val = $8F4D;
    public property DOUBLE_MAT3x4:     boolean read self.val = $8F4C;
    public property DOUBLE_MAT4x3:     boolean read self.val = $8F4E;
    
    public function ToString: string; override;
    begin
      var res := typeof(ProgramVarType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'ProgramVarType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  FramebufferAttachmentObjectType = record
    public val: UInt32;
    
    public property NONE:                boolean read self.val = 0;
    public property FRAMEBUFFER_DEFAULT: boolean read self.val = $8218;
    public property TEXTURE:             boolean read self.val = $1702;
    public property RENDERBUFFER:        boolean read self.val = $8D41;
    
    public function ToString: string; override;
    begin
      var res := typeof(FramebufferAttachmentObjectType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'FramebufferAttachmentObjectType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  ClientWaitSyncResult = record
    public val: UInt32;
    
    public property ALREADY_SIGNALED:    boolean read self.val = $911A;
    public property TIMEOUT_EXPIRED:     boolean read self.val = $911B;
    public property CONDITION_SATISFIED: boolean read self.val = $911C;
    public property WAIT_FAILED:         boolean read self.val = $911D;
    
    public function ToString: string; override;
    begin
      var res := typeof(ClientWaitSyncResult).GetProperties.Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'ClientWaitSyncResult[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  ShadingLanguageTypeToken = record
    public val: UInt32;
    
    public property FLOAT:                                     boolean read self.val = $1406;
    public property FLOAT_VEC2:                                boolean read self.val = $8B50;
    public property FLOAT_VEC3:                                boolean read self.val = $8B51;
    public property FLOAT_VEC4:                                boolean read self.val = $8B52;
    public property DOUBLE:                                    boolean read self.val = $140A;
    public property DOUBLE_VEC2:                               boolean read self.val = $8FFC;
    public property DOUBLE_VEC3:                               boolean read self.val = $8FFD;
    public property DOUBLE_VEC4:                               boolean read self.val = $8FFE;
    public property INT:                                       boolean read self.val = $1404;
    public property INT_VEC2:                                  boolean read self.val = $8B53;
    public property INT_VEC3:                                  boolean read self.val = $8B54;
    public property INT_VEC4:                                  boolean read self.val = $8B55;
    public property UNSIGNED_INT:                              boolean read self.val = $1405;
    public property UNSIGNED_INT_VEC2:                         boolean read self.val = $8DC6;
    public property UNSIGNED_INT_VEC3:                         boolean read self.val = $8DC7;
    public property UNSIGNED_INT_VEC4:                         boolean read self.val = $8DC8;
    public property BOOL:                                      boolean read self.val = $8B56;
    public property BOOL_VEC2:                                 boolean read self.val = $8B57;
    public property BOOL_VEC3:                                 boolean read self.val = $8B58;
    public property BOOL_VEC4:                                 boolean read self.val = $8B59;
    public property FLOAT_MAT2:                                boolean read self.val = $8B5A;
    public property FLOAT_MAT3:                                boolean read self.val = $8B5B;
    public property FLOAT_MAT4:                                boolean read self.val = $8B5C;
    public property FLOAT_MAT2x3:                              boolean read self.val = $8B65;
    public property FLOAT_MAT2x4:                              boolean read self.val = $8B66;
    public property FLOAT_MAT3x2:                              boolean read self.val = $8B67;
    public property FLOAT_MAT3x4:                              boolean read self.val = $8B68;
    public property FLOAT_MAT4x2:                              boolean read self.val = $8B69;
    public property FLOAT_MAT4x3:                              boolean read self.val = $8B6A;
    public property DOUBLE_MAT2:                               boolean read self.val = $8F46;
    public property DOUBLE_MAT3:                               boolean read self.val = $8F47;
    public property DOUBLE_MAT4:                               boolean read self.val = $8F48;
    public property DOUBLE_MAT2x3:                             boolean read self.val = $8F49;
    public property DOUBLE_MAT2x4:                             boolean read self.val = $8F4A;
    public property DOUBLE_MAT3x2:                             boolean read self.val = $8F4B;
    public property DOUBLE_MAT3x4:                             boolean read self.val = $8F4C;
    public property DOUBLE_MAT4x2:                             boolean read self.val = $8F4D;
    public property DOUBLE_MAT4x3:                             boolean read self.val = $8F4E;
    public property SAMPLER_1D:                                boolean read self.val = $8B5D;
    public property SAMPLER_2D:                                boolean read self.val = $8B5E;
    public property SAMPLER_3D:                                boolean read self.val = $8B5F;
    public property SAMPLER_CUBE:                              boolean read self.val = $8B60;
    public property SAMPLER_1D_SHADOW:                         boolean read self.val = $8B61;
    public property SAMPLER_2D_SHADOW:                         boolean read self.val = $8B62;
    public property SAMPLER_1D_ARRAY:                          boolean read self.val = $8DC0;
    public property SAMPLER_2D_ARRAY:                          boolean read self.val = $8DC1;
    public property SAMPLER_CUBE_MAP_ARRAY:                    boolean read self.val = $900C;
    public property SAMPLER_1D_ARRAY_SHADOW:                   boolean read self.val = $8DC3;
    public property SAMPLER_2D_ARRAY_SHADOW:                   boolean read self.val = $8DC4;
    public property SAMPLER_2D_MULTISAMPLE:                    boolean read self.val = $9108;
    public property SAMPLER_2D_MULTISAMPLE_ARRAY:              boolean read self.val = $910B;
    public property SAMPLER_CUBE_SHADOW:                       boolean read self.val = $8DC5;
    public property SAMPLER_CUBE_MAP_ARRAY_SHADOW:             boolean read self.val = $900D;
    public property SAMPLER_BUFFER:                            boolean read self.val = $8DC2;
    public property SAMPLER_2D_RECT:                           boolean read self.val = $8B63;
    public property SAMPLER_2D_RECT_SHADOW:                    boolean read self.val = $8B64;
    public property INT_SAMPLER_1D:                            boolean read self.val = $8DC9;
    public property INT_SAMPLER_2D:                            boolean read self.val = $8DCA;
    public property INT_SAMPLER_3D:                            boolean read self.val = $8DCB;
    public property INT_SAMPLER_CUBE:                          boolean read self.val = $8DCC;
    public property INT_SAMPLER_1D_ARRAY:                      boolean read self.val = $8DCE;
    public property INT_SAMPLER_2D_ARRAY:                      boolean read self.val = $8DCF;
    public property INT_SAMPLER_CUBE_MAP_ARRAY:                boolean read self.val = $900E;
    public property INT_SAMPLER_2D_MULTISAMPLE:                boolean read self.val = $9109;
    public property INT_SAMPLER_2D_MULTISAMPLE_ARRAY:          boolean read self.val = $910C;
    public property INT_SAMPLER_BUFFER:                        boolean read self.val = $8DD0;
    public property INT_SAMPLER_2D_RECT:                       boolean read self.val = $8DCD;
    public property UNSIGNED_INT_SAMPLER_1D:                   boolean read self.val = $8DD1;
    public property UNSIGNED_INT_SAMPLER_2D:                   boolean read self.val = $8DD2;
    public property UNSIGNED_INT_SAMPLER_3D:                   boolean read self.val = $8DD3;
    public property UNSIGNED_INT_SAMPLER_CUBE:                 boolean read self.val = $8DD4;
    public property UNSIGNED_INT_SAMPLER_1D_ARRAY:             boolean read self.val = $8DD6;
    public property UNSIGNED_INT_SAMPLER_2D_ARRAY:             boolean read self.val = $8DD7;
    public property UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY:       boolean read self.val = $900F;
    public property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:       boolean read self.val = $910A;
    public property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: boolean read self.val = $910D;
    public property UNSIGNED_INT_SAMPLER_BUFFER:               boolean read self.val = $8DD8;
    public property UNSIGNED_INT_SAMPLER_2D_RECT:              boolean read self.val = $8DD5;
    public property IMAGE_1D:                                  boolean read self.val = $904C;
    public property IMAGE_2D:                                  boolean read self.val = $904D;
    public property IMAGE_3D:                                  boolean read self.val = $904E;
    public property IMAGE_2D_RECT:                             boolean read self.val = $904F;
    public property IMAGE_CUBE:                                boolean read self.val = $9050;
    public property IMAGE_BUFFER:                              boolean read self.val = $9051;
    public property IMAGE_1D_ARRAY:                            boolean read self.val = $9052;
    public property IMAGE_2D_ARRAY:                            boolean read self.val = $9053;
    public property IMAGE_CUBE_MAP_ARRAY:                      boolean read self.val = $9054;
    public property IMAGE_2D_MULTISAMPLE:                      boolean read self.val = $9055;
    public property IMAGE_2D_MULTISAMPLE_ARRAY:                boolean read self.val = $9056;
    public property INT_IMAGE_1D:                              boolean read self.val = $9057;
    public property INT_IMAGE_2D:                              boolean read self.val = $9058;
    public property INT_IMAGE_3D:                              boolean read self.val = $9059;
    public property INT_IMAGE_2D_RECT:                         boolean read self.val = $905A;
    public property INT_IMAGE_CUBE:                            boolean read self.val = $905B;
    public property INT_IMAGE_BUFFER:                          boolean read self.val = $905C;
    public property INT_IMAGE_1D_ARRAY:                        boolean read self.val = $905D;
    public property INT_IMAGE_2D_ARRAY:                        boolean read self.val = $905E;
    public property INT_IMAGE_CUBE_MAP_ARRAY:                  boolean read self.val = $905F;
    public property INT_IMAGE_2D_MULTISAMPLE:                  boolean read self.val = $9060;
    public property INT_IMAGE_2D_MULTISAMPLE_ARRAY:            boolean read self.val = $9061;
    public property UNSIGNED_INT_IMAGE_1D:                     boolean read self.val = $9062;
    public property UNSIGNED_INT_IMAGE_2D:                     boolean read self.val = $9063;
    public property UNSIGNED_INT_IMAGE_3D:                     boolean read self.val = $9064;
    public property UNSIGNED_INT_IMAGE_2D_RECT:                boolean read self.val = $9065;
    public property UNSIGNED_INT_IMAGE_CUBE:                   boolean read self.val = $9066;
    public property UNSIGNED_INT_IMAGE_BUFFER:                 boolean read self.val = $9067;
    public property UNSIGNED_INT_IMAGE_1D_ARRAY:               boolean read self.val = $9068;
    public property UNSIGNED_INT_IMAGE_2D_ARRAY:               boolean read self.val = $9069;
    public property UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY:         boolean read self.val = $906A;
    public property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE:         boolean read self.val = $906B;
    public property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY:   boolean read self.val = $906C;
    public property UNSIGNED_INT_ATOMIC_COUNTER:               boolean read self.val = $92DB;
    
  end;
  
  //R
  DebugSourceType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property API:                 boolean read self.val = $8246;
    public property WINDOW_SYSTEM:       boolean read self.val = $8247;
    public property SHADER_COMPILER:     boolean read self.val = $8248;
    public property THIRD_PARTY:         boolean read self.val = $8249;
    public property APPLICATION:         boolean read self.val = $824A;
    public property OTHER:               boolean read self.val = $824B;
    public property API_ARB:             boolean read self.val = $8246;
    public property WINDOW_SYSTEM_ARB:   boolean read self.val = $8247;
    public property SHADER_COMPILER_ARB: boolean read self.val = $8248;
    public property THIRD_PARTY_ARB:     boolean read self.val = $8249;
    public property APPLICATION_ARB:     boolean read self.val = $824A;
    public property OTHER_ARB:           boolean read self.val = $824B;
    
    public function ToString: string; override;
    begin
      var res := typeof(DebugSourceType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DebugSourceType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  DebugMessageType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property ERROR:               boolean read self.val = $824C;
    public property DEPRECATED_BEHAVIOR: boolean read self.val = $824D;
    public property UNDEFINED_BEHAVIOR:  boolean read self.val = $824E;
    public property PORTABILITY:         boolean read self.val = $824F;
    public property PERFORMANCE:         boolean read self.val = $8250;
    public property OTHER:               boolean read self.val = $8251;
    public property MARKER:              boolean read self.val = $8268;
    public property PUSH_GROUP:          boolean read self.val = $8269;
    public property POP_GROUP:           boolean read self.val = $826A;
    
    public function ToString: string; override;
    begin
      var res := typeof(DebugMessageType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DebugMessageType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  DebugSeverityLevel = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property HIGH:          boolean read self.val = $9146;
    public property MEDIUM:        boolean read self.val = $9147;
    public property LOW:           boolean read self.val = $9148;
    public property NOTIFICATION:  boolean read self.val = $826B;
    
    public function ToString: string; override;
    begin
      var res := typeof(DebugSeverityLevel).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DebugSeverityLevel[{self.val}]':
        res[0];
    end;
    
  end;
  
  {$endregion 1 значение}
  
  {$region Флаги}
  
  //S
  GDI_PixelFormatFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DOUBLEBUFFER:          GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000001);
    public static property STEREO:                GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000002);
    public static property DRAW_TO_WINDOW:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000004);
    public static property DRAW_TO_BITMAP:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000008);
    public static property SUPPORT_GDI:           GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000010);
    public static property SUPPORT_OPENGL:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000020);
    public static property GENERIC_FORMAT:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000040);
    public static property NEED_PALETTE:          GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000080);
    public static property NEED_SYSTEM_PALETTE:   GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000100);
    public static property SWAP_EXCHANGE:         GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000200);
    public static property SWAP_COPY:             GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000400);
    public static property SWAP_LAYER_BUFFERS:    GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000800);
    public static property GENERIC_ACCELERATED:   GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00001000);
    public static property SUPPORT_DIRECTDRAW:    GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00002000);
    public static property DEPTH_DONTCARE:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($20000000);
    public static property DOUBLEBUFFER_DONTCARE: GDI_PixelFormatFlags read new GDI_PixelFormatFlags($40000000);
    public static property STEREO_DONTCARE:       GDI_PixelFormatFlags read new GDI_PixelFormatFlags($80000000);
    
    public static function operator or(v1,v2: GDI_PixelFormatFlags): GDI_PixelFormatFlags := new GDI_PixelFormatFlags(v1.val or v2.val);
    
  end;
  
  //S
  BufferTypeFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR_BUFFER_BIT:    BufferTypeFlags read new BufferTypeFlags($00004000);
    public static property DEPTH_BUFFER_BIT:    BufferTypeFlags read new BufferTypeFlags($00000100);
    public static property STENCIL_BUFFER_BIT:  BufferTypeFlags read new BufferTypeFlags($00000400);
    
    public static function operator or(f1,f2: BufferTypeFlags): BufferTypeFlags := new BufferTypeFlags(f1.val or f2.val);
    
  end;
  
  //S
  MemoryBarrierTypeFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_ARRAY_BARRIER_BIT: MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000001);
    public static property ELEMENT_ARRAY_BARRIER_BIT:       MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000002);
    public static property UNIFORM_BARRIER_BIT:             MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000004);
    public static property TEXTURE_FETCH_BARRIER_BIT:       MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000008);
    public static property SHADER_IMAGE_ACCESS_BARRIER_BIT: MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000020);
    public static property COMMAND_BARRIER_BIT:             MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000040);
    public static property PIXEL_BUFFER_BARRIER_BIT:        MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000080);
    public static property TEXTURE_UPDATE_BARRIER_BIT:      MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000100);
    public static property BUFFER_UPDATE_BARRIER_BIT:       MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000200);
    public static property FRAMEBUFFER_BARRIER_BIT:         MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000400);
    public static property TRANSFORM_FEEDBACK_BARRIER_BIT:  MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000800);
    public static property ATOMIC_COUNTER_BARRIER_BIT:      MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00001000);
    public static property SHADER_STORAGE_BARRIER_BIT:      MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00002000);
    public static property QUERY_BUFFER_BARRIER_BIT:        MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00008000);
    public static property ALL_BARRIER_BITS:                MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($FFFFFFFF);
    
    public static function operator or(f1,f2: MemoryBarrierTypeFlags): MemoryBarrierTypeFlags := new MemoryBarrierTypeFlags(f1.val or f2.val);
    
  end;
  
  //S
  ProgramStagesFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_SHADER_BIT:           ProgramStagesFlags read new ProgramStagesFlags($00000001);
    public static property FRAGMENT_SHADER_BIT:         ProgramStagesFlags read new ProgramStagesFlags($00000002);
    public static property GEOMETRY_SHADER_BIT:         ProgramStagesFlags read new ProgramStagesFlags($00000004);
    public static property TESS_CONTROL_SHADER_BIT:     ProgramStagesFlags read new ProgramStagesFlags($00000008);
    public static property TESS_EVALUATION_SHADER_BIT:  ProgramStagesFlags read new ProgramStagesFlags($00000010);
    public static property COMPUTE_SHADER_BIT:          ProgramStagesFlags read new ProgramStagesFlags($00000020);
    public static property ALL_SHADER_BITS:             ProgramStagesFlags read new ProgramStagesFlags($FFFFFFFF);
    
    public static function operator or(f1,f2: ProgramStagesFlags): ProgramStagesFlags := new ProgramStagesFlags(f1.val or f2.val);
    
  end;
  
  //S
  ReservedFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE: ReservedFlags read new ReservedFlags($0);
    
    public static function operator or(f1,f2: ReservedFlags): ReservedFlags := new ReservedFlags(f1.val or f2.val);
    
  end;
  
  //S
  CommandFlushingBehaviorFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SYNC_FLUSH_COMMANDS:  CommandFlushingBehaviorFlags read new CommandFlushingBehaviorFlags($00000001);
    
    public static function operator or(f1,f2: CommandFlushingBehaviorFlags): CommandFlushingBehaviorFlags := new CommandFlushingBehaviorFlags(f1.val or f2.val);
    
  end;
  
  //S
  BufferMapFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_BIT:              BufferMapFlags read new BufferMapFlags($0001);
    public static property WRITE_BIT:             BufferMapFlags read new BufferMapFlags($0002);
    public static property INVALIDATE_RANGE_BIT:  BufferMapFlags read new BufferMapFlags($0004);
    public static property INVALIDATE_BUFFER_BIT: BufferMapFlags read new BufferMapFlags($0008);
    public static property FLUSH_EXPLICIT_BIT:    BufferMapFlags read new BufferMapFlags($0010);
    public static property UNSYNCHRONIZED_BIT:    BufferMapFlags read new BufferMapFlags($0020);
    public static property PERSISTENT_BIT:        BufferMapFlags read new BufferMapFlags($0040);
    public static property COHERENT_BIT:          BufferMapFlags read new BufferMapFlags($0080);
    
    public static function operator or(f1,f2: BufferMapFlags): BufferMapFlags := new BufferMapFlags(f1.val or f2.val);
    
  end;
  
  //S
  BufferStorageFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
//    public static property NONE:                BufferStorageFlags read new BufferStorageFlags(0); //ToDo узнать надо ли
    public static property MAP_READ_BIT:        BufferStorageFlags read new BufferStorageFlags($0001);
    public static property MAP_WRITE_BIT:       BufferStorageFlags read new BufferStorageFlags($0002);
    public static property MAP_PERSISTENT_BIT:  BufferStorageFlags read new BufferStorageFlags($0040);
    public static property MAP_COHERENT_BIT:    BufferStorageFlags read new BufferStorageFlags($0080);
    public static property DYNAMIC_STORAGE_BIT: BufferStorageFlags read new BufferStorageFlags($0100);
    public static property CLIENT_STORAGE_BIT:  BufferStorageFlags read new BufferStorageFlags($0200);
    
    public static function operator or(f1,f2: BufferStorageFlags): BufferStorageFlags := new BufferStorageFlags(f1.val or f2.val);
    
  end;
  
  {$endregion Флаги}
  
  {$region Ext}
  
  {$region INTEL_performance_query}
  
  //S
  PerfQueryDataFlagsINTEL = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property DONOT_FLUSH:  boolean read self.val = $83F9;
    public property FLUSH:        boolean read self.val = $83FA;
    public property WAIT:         boolean read self.val = $83FB;
    
    public static function operator or(a,b: PerfQueryDataFlagsINTEL) :=
    new PerfQueryDataFlagsINTEL(a.val or b.val);
    
  end;
  
  //R
  PerfQueryCounterTypeINTEL = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property &EVENT:         boolean read self.val = $94F0;
    public property DURATION_NORM:  boolean read self.val = $94F1;
    public property DURATION_RAW:   boolean read self.val = $94F2;
    public property THROUGHPUT:     boolean read self.val = $94F3;
    public property RAW:            boolean read self.val = $94F4;
    public property TIMESTAMP:      boolean read self.val = $94F5;
    
    public function ToString: string; override;
    begin
      var res := typeof(PerfQueryCounterTypeINTEL).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault;
      Result := res=nil?
        $'PerfQueryCounterTypeINTEL[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  PerfQueryCounterDataTypeINTEL = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property UINT32: boolean read self.val = $94F8;
    public property UINT64: boolean read self.val = $94F9;
    public property FLOAT:  boolean read self.val = $94FA;
    public property DOUBLE: boolean read self.val = $94FB;
    public property BOOL32: boolean read self.val = $94FC;
    
    public function ToString: string; override;
    begin
      var res := typeof(PerfQueryCounterDataTypeINTEL).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault;
      Result := res=nil?
        $'PerfQueryCounterDataTypeINTEL[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  PerfQueryCapFlagsINTEL = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property SINGLE_CONTEXT: boolean read self.val = 0;
    public property GLOBAL_CONTEXT: boolean read self.val and $1 <> 0;
    
    public function ToString: string; override;
    begin
      var res := typeof(PerfQueryCapFlagsINTEL).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).Where(t->t[1]).ToList;
      Result := res.Count=0?
        $'PerfQueryCapFlagsINTEL[{self.val}]':
        res.Select(t->t[0]).JoinIntoString('+');
    end;
    
  end;
  
  {$endregion INTEL_performance_query}
  
  {$region AMD_debug_output}
  
  //R
  DebugMessageCategoryAMD = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property API_ERROR:          boolean read self.val = $9149;
    public property WINDOW_SYSTEM:      boolean read self.val = $914A;
    public property DEPRECATION:        boolean read self.val = $914B;
    public property UNDEFINED_BEHAVIOR: boolean read self.val = $914C;
    public property PERFORMANCE:        boolean read self.val = $914D;
    public property SHADER_COMPILER:    boolean read self.val = $914E;
    public property APPLICATION:        boolean read self.val = $914F;
    public property OTHER:              boolean read self.val = $9150;
    
    public function ToString: string; override;
    begin
      var res := typeof(DebugMessageType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DebugMessageType[{self.val}]':
        res[0];
    end;
    
  end;
  
  {$endregion AMD_debug_output}
  
  {$endregion Ext}
  
{$endregion Перечисления}

{$region Делегаты} type
  
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  GLDEBUGPROC = procedure(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; message_text: IntPtr; userParam: pointer);
  
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  GLVULKANPROCNV = procedure;
  
{$endregion Делегаты}

{$region Записи} type
  
  {$region Vec}
  
  {$region Vec1}
  
  Vec1b = record
    public val0: SByte;
    
    public constructor(val0: SByte);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1b): Vec1b := new Vec1b(-v.val0);
    public static function operator*(v: Vec1b; k: SByte): Vec1b := new Vec1b(v.val0*k);
    public static function operator+(v1, v2: Vec1b): Vec1b := new Vec1b(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1b): Vec1b := new Vec1b(v1.val0-v2.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1ub = record
    public val0: Byte;
    
    public constructor(val0: Byte);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1ub; k: Byte): Vec1ub := new Vec1ub(v.val0*k);
    public static function operator+(v1, v2: Vec1ub): Vec1ub := new Vec1ub(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1ub): Vec1ub := new Vec1ub(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1ub := new Vec1ub(v.val0);
    public static function operator implicit(v: Vec1ub): Vec1b := new Vec1b(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1s = record
    public val0: Int16;
    
    public constructor(val0: Int16);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1s): Vec1s := new Vec1s(-v.val0);
    public static function operator*(v: Vec1s; k: Int16): Vec1s := new Vec1s(v.val0*k);
    public static function operator+(v1, v2: Vec1s): Vec1s := new Vec1s(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1s): Vec1s := new Vec1s(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1s := new Vec1s(v.val0);
    public static function operator implicit(v: Vec1s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1s := new Vec1s(v.val0);
    public static function operator implicit(v: Vec1s): Vec1ub := new Vec1ub(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1us = record
    public val0: UInt16;
    
    public constructor(val0: UInt16);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1us; k: UInt16): Vec1us := new Vec1us(v.val0*k);
    public static function operator+(v1, v2: Vec1us): Vec1us := new Vec1us(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1us): Vec1us := new Vec1us(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1us := new Vec1us(v.val0);
    public static function operator implicit(v: Vec1us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1us := new Vec1us(v.val0);
    public static function operator implicit(v: Vec1us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1us := new Vec1us(v.val0);
    public static function operator implicit(v: Vec1us): Vec1s := new Vec1s(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1i = record
    public val0: Int32;
    
    public constructor(val0: Int32);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1i): Vec1i := new Vec1i(-v.val0);
    public static function operator*(v: Vec1i; k: Int32): Vec1i := new Vec1i(v.val0*k);
    public static function operator+(v1, v2: Vec1i): Vec1i := new Vec1i(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1i): Vec1i := new Vec1i(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1us := new Vec1us(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1ui = record
    public val0: UInt32;
    
    public constructor(val0: UInt32);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1ui; k: UInt32): Vec1ui := new Vec1ui(v.val0*k);
    public static function operator+(v1, v2: Vec1ui): Vec1ui := new Vec1ui(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1ui): Vec1ui := new Vec1ui(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1i := new Vec1i(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1i64 = record
    public val0: Int64;
    
    public constructor(val0: Int64);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1i64): Vec1i64 := new Vec1i64(-v.val0);
    public static function operator*(v: Vec1i64; k: Int64): Vec1i64 := new Vec1i64(v.val0*k);
    public static function operator+(v1, v2: Vec1i64): Vec1i64 := new Vec1i64(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1i64): Vec1i64 := new Vec1i64(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1ui := new Vec1ui(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1ui64 = record
    public val0: UInt64;
    
    public constructor(val0: UInt64);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1ui64; k: UInt64): Vec1ui64 := new Vec1ui64(v.val0*k);
    public static function operator+(v1, v2: Vec1ui64): Vec1ui64 := new Vec1ui64(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1ui64): Vec1ui64 := new Vec1ui64(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1f = record
    public val0: single;
    
    public constructor(val0: single);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1f): Vec1f := new Vec1f(-v.val0);
    public static function operator*(v: Vec1f; k: single): Vec1f := new Vec1f(v.val0*k);
    public static function operator/(v: Vec1f; k: single): Vec1f := new Vec1f(v.val0/k);
    public static function operator+(v1, v2: Vec1f): Vec1f := new Vec1f(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1f): Vec1f := new Vec1f(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1d = record
    public val0: double;
    
    public constructor(val0: double);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1d): Vec1d := new Vec1d(-v.val0);
    public static function operator*(v: Vec1d; k: double): Vec1d := new Vec1d(v.val0*k);
    public static function operator/(v: Vec1d; k: double): Vec1d := new Vec1d(v.val0/k);
    public static function operator+(v1, v2: Vec1d): Vec1d := new Vec1d(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1d): Vec1d := new Vec1d(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1f := new Vec1f(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  {$endregion Vec1}
  
  {$region Vec2}
  
  Vec2b = record
    public val0: SByte;
    public val1: SByte;
    
    public constructor(val0, val1: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2b): Vec2b := new Vec2b(-v.val0, -v.val1);
    public static function operator*(v: Vec2b; k: SByte): Vec2b := new Vec2b(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2b): Vec2b := new Vec2b(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2b): Vec2b := new Vec2b(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), 0);
    public static function operator implicit(v: Vec2b): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), 0);
    public static function operator implicit(v: Vec2b): Vec1d := new Vec1d(v.val0);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2ub = record
    public val0: Byte;
    public val1: Byte;
    
    public constructor(val0, val1: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2ub; k: Byte): Vec2ub := new Vec2ub(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2ub): Vec2ub := new Vec2ub(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2ub): Vec2ub := new Vec2ub(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), 0);
    public static function operator implicit(v: Vec2ub): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), 0);
    public static function operator implicit(v: Vec2ub): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2ub := new Vec2ub(v.val0, v.val1);
    public static function operator implicit(v: Vec2ub): Vec2b := new Vec2b(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2s = record
    public val0: Int16;
    public val1: Int16;
    
    public constructor(val0, val1: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2s): Vec2s := new Vec2s(-v.val0, -v.val1);
    public static function operator*(v: Vec2s; k: Int16): Vec2s := new Vec2s(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2s): Vec2s := new Vec2s(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2s): Vec2s := new Vec2s(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), 0);
    public static function operator implicit(v: Vec2s): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), 0);
    public static function operator implicit(v: Vec2s): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2s := new Vec2s(v.val0, v.val1);
    public static function operator implicit(v: Vec2s): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2s := new Vec2s(v.val0, v.val1);
    public static function operator implicit(v: Vec2s): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2us = record
    public val0: UInt16;
    public val1: UInt16;
    
    public constructor(val0, val1: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2us; k: UInt16): Vec2us := new Vec2us(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2us): Vec2us := new Vec2us(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2us): Vec2us := new Vec2us(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), 0);
    public static function operator implicit(v: Vec2us): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), 0);
    public static function operator implicit(v: Vec2us): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2us := new Vec2us(v.val0, v.val1);
    public static function operator implicit(v: Vec2us): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2us := new Vec2us(v.val0, v.val1);
    public static function operator implicit(v: Vec2us): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2us := new Vec2us(v.val0, v.val1);
    public static function operator implicit(v: Vec2us): Vec2s := new Vec2s(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2i = record
    public val0: Int32;
    public val1: Int32;
    
    public constructor(val0, val1: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2i): Vec2i := new Vec2i(-v.val0, -v.val1);
    public static function operator*(v: Vec2i; k: Int32): Vec2i := new Vec2i(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2i): Vec2i := new Vec2i(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2i): Vec2i := new Vec2i(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), 0);
    public static function operator implicit(v: Vec2i): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), 0);
    public static function operator implicit(v: Vec2i): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2us := new Vec2us(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2ui = record
    public val0: UInt32;
    public val1: UInt32;
    
    public constructor(val0, val1: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2ui; k: UInt32): Vec2ui := new Vec2ui(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2ui): Vec2ui := new Vec2ui(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2ui): Vec2ui := new Vec2ui(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), 0);
    public static function operator implicit(v: Vec2ui): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), 0);
    public static function operator implicit(v: Vec2ui): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2i := new Vec2i(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2i64 = record
    public val0: Int64;
    public val1: Int64;
    
    public constructor(val0, val1: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2i64): Vec2i64 := new Vec2i64(-v.val0, -v.val1);
    public static function operator*(v: Vec2i64; k: Int64): Vec2i64 := new Vec2i64(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2i64): Vec2i64 := new Vec2i64(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2i64): Vec2i64 := new Vec2i64(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), 0);
    public static function operator implicit(v: Vec2i64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), 0);
    public static function operator implicit(v: Vec2i64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    
    public constructor(val0, val1: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2ui64; k: UInt64): Vec2ui64 := new Vec2ui64(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2ui64): Vec2ui64 := new Vec2ui64(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2ui64): Vec2ui64 := new Vec2ui64(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), 0);
    public static function operator implicit(v: Vec2ui64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), 0);
    public static function operator implicit(v: Vec2ui64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2f = record
    public val0: single;
    public val1: single;
    
    public constructor(val0, val1: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2f): Vec2f := new Vec2f(-v.val0, -v.val1);
    public static function operator*(v: Vec2f; k: single): Vec2f := new Vec2f(v.val0*k, v.val1*k);
    public static function operator/(v: Vec2f; k: single): Vec2f := new Vec2f(v.val0/k, v.val1/k);
    public static function operator+(v1, v2: Vec2f): Vec2f := new Vec2f(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2f): Vec2f := new Vec2f(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2d = record
    public val0: double;
    public val1: double;
    
    public constructor(val0, val1: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2d): Vec2d := new Vec2d(-v.val0, -v.val1);
    public static function operator*(v: Vec2d; k: double): Vec2d := new Vec2d(v.val0*k, v.val1*k);
    public static function operator/(v: Vec2d; k: double): Vec2d := new Vec2d(v.val0/k, v.val1/k);
    public static function operator+(v1, v2: Vec2d): Vec2d := new Vec2d(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2d): Vec2d := new Vec2d(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2f := new Vec2f(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  {$endregion Vec2}
  
  {$region Vec3}
  
  Vec3b = record
    public val0: SByte;
    public val1: SByte;
    public val2: SByte;
    
    public constructor(val0, val1, val2: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3b): Vec3b := new Vec3b(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3b; k: SByte): Vec3b := new Vec3b(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3b): Vec3b := new Vec3b(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3b): Vec3b := new Vec3b(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3b): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3b): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0);
    public static function operator implicit(v: Vec3b): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0);
    public static function operator implicit(v: Vec3b): Vec2d := new Vec2d(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3ub = record
    public val0: Byte;
    public val1: Byte;
    public val2: Byte;
    
    public constructor(val0, val1, val2: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3ub; k: Byte): Vec3ub := new Vec3ub(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3ub): Vec3ub := new Vec3ub(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3ub): Vec3ub := new Vec3ub(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0);
    public static function operator implicit(v: Vec3ub): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0);
    public static function operator implicit(v: Vec3ub): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ub): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3s = record
    public val0: Int16;
    public val1: Int16;
    public val2: Int16;
    
    public constructor(val0, val1, val2: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3s): Vec3s := new Vec3s(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3s; k: Int16): Vec3s := new Vec3s(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3s): Vec3s := new Vec3s(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3s): Vec3s := new Vec3s(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3s): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3s): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0);
    public static function operator implicit(v: Vec3s): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0);
    public static function operator implicit(v: Vec3s): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3s): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3s): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3us = record
    public val0: UInt16;
    public val1: UInt16;
    public val2: UInt16;
    
    public constructor(val0, val1, val2: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3us; k: UInt16): Vec3us := new Vec3us(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3us): Vec3us := new Vec3us(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3us): Vec3us := new Vec3us(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3us): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3us): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0);
    public static function operator implicit(v: Vec3us): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0);
    public static function operator implicit(v: Vec3us): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3us): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3us): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3us): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3i = record
    public val0: Int32;
    public val1: Int32;
    public val2: Int32;
    
    public constructor(val0, val1, val2: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3i): Vec3i := new Vec3i(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3i; k: Int32): Vec3i := new Vec3i(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3i): Vec3i := new Vec3i(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3i): Vec3i := new Vec3i(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0);
    public static function operator implicit(v: Vec3i): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0);
    public static function operator implicit(v: Vec3i): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3ui = record
    public val0: UInt32;
    public val1: UInt32;
    public val2: UInt32;
    
    public constructor(val0, val1, val2: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3ui; k: UInt32): Vec3ui := new Vec3ui(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3ui): Vec3ui := new Vec3ui(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3ui): Vec3ui := new Vec3ui(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0);
    public static function operator implicit(v: Vec3ui): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0);
    public static function operator implicit(v: Vec3ui): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3i64 = record
    public val0: Int64;
    public val1: Int64;
    public val2: Int64;
    
    public constructor(val0, val1, val2: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3i64): Vec3i64 := new Vec3i64(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3i64; k: Int64): Vec3i64 := new Vec3i64(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3i64): Vec3i64 := new Vec3i64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3i64): Vec3i64 := new Vec3i64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0);
    public static function operator implicit(v: Vec3i64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0);
    public static function operator implicit(v: Vec3i64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    public val2: UInt64;
    
    public constructor(val0, val1, val2: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3ui64; k: UInt64): Vec3ui64 := new Vec3ui64(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3ui64): Vec3ui64 := new Vec3ui64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3ui64): Vec3ui64 := new Vec3ui64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0);
    public static function operator implicit(v: Vec3ui64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0);
    public static function operator implicit(v: Vec3ui64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3f = record
    public val0: single;
    public val1: single;
    public val2: single;
    
    public constructor(val0, val1, val2: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3f): Vec3f := new Vec3f(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3f; k: single): Vec3f := new Vec3f(v.val0*k, v.val1*k, v.val2*k);
    public static function operator/(v: Vec3f; k: single): Vec3f := new Vec3f(v.val0/k, v.val1/k, v.val2/k);
    public static function operator+(v1, v2: Vec3f): Vec3f := new Vec3f(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3f): Vec3f := new Vec3f(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3d = record
    public val0: double;
    public val1: double;
    public val2: double;
    
    public constructor(val0, val1, val2: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3d): Vec3d := new Vec3d(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3d; k: double): Vec3d := new Vec3d(v.val0*k, v.val1*k, v.val2*k);
    public static function operator/(v: Vec3d; k: double): Vec3d := new Vec3d(v.val0/k, v.val1/k, v.val2/k);
    public static function operator+(v1, v2: Vec3d): Vec3d := new Vec3d(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3d): Vec3d := new Vec3d(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public static function operator implicit(v: Vec3f): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  {$endregion Vec3}
  
  {$region Vec4}
  
  Vec4b = record
    public val0: SByte;
    public val1: SByte;
    public val2: SByte;
    public val3: SByte;
    
    public constructor(val0, val1, val2, val3: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4b): Vec4b := new Vec4b(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4b; k: SByte): Vec4b := new Vec4b(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4b): Vec4b := new Vec4b(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4b): Vec4b := new Vec4b(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4b): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4b): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), 0);
    public static function operator implicit(v: Vec4b): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), 0);
    public static function operator implicit(v: Vec4b): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4ub = record
    public val0: Byte;
    public val1: Byte;
    public val2: Byte;
    public val3: Byte;
    
    public constructor(val0, val1, val2, val3: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4ub; k: Byte): Vec4ub := new Vec4ub(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4ub): Vec4ub := new Vec4ub(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4ub): Vec4ub := new Vec4ub(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), 0);
    public static function operator implicit(v: Vec4ub): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), 0);
    public static function operator implicit(v: Vec4ub): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ub): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4s = record
    public val0: Int16;
    public val1: Int16;
    public val2: Int16;
    public val3: Int16;
    
    public constructor(val0, val1, val2, val3: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4s): Vec4s := new Vec4s(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4s; k: Int16): Vec4s := new Vec4s(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4s): Vec4s := new Vec4s(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4s): Vec4s := new Vec4s(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4s): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4s): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), 0);
    public static function operator implicit(v: Vec4s): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), 0);
    public static function operator implicit(v: Vec4s): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4s): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4s): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4us = record
    public val0: UInt16;
    public val1: UInt16;
    public val2: UInt16;
    public val3: UInt16;
    
    public constructor(val0, val1, val2, val3: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4us; k: UInt16): Vec4us := new Vec4us(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4us): Vec4us := new Vec4us(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4us): Vec4us := new Vec4us(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4us): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4us): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), 0);
    public static function operator implicit(v: Vec4us): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), 0);
    public static function operator implicit(v: Vec4us): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4us): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4us): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4us): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4i = record
    public val0: Int32;
    public val1: Int32;
    public val2: Int32;
    public val3: Int32;
    
    public constructor(val0, val1, val2, val3: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4i): Vec4i := new Vec4i(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4i; k: Int32): Vec4i := new Vec4i(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4i): Vec4i := new Vec4i(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4i): Vec4i := new Vec4i(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), 0);
    public static function operator implicit(v: Vec4i): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), 0);
    public static function operator implicit(v: Vec4i): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4ui = record
    public val0: UInt32;
    public val1: UInt32;
    public val2: UInt32;
    public val3: UInt32;
    
    public constructor(val0, val1, val2, val3: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4ui; k: UInt32): Vec4ui := new Vec4ui(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4ui): Vec4ui := new Vec4ui(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4ui): Vec4ui := new Vec4ui(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), 0);
    public static function operator implicit(v: Vec4ui): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), 0);
    public static function operator implicit(v: Vec4ui): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4i64 = record
    public val0: Int64;
    public val1: Int64;
    public val2: Int64;
    public val3: Int64;
    
    public constructor(val0, val1, val2, val3: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4i64): Vec4i64 := new Vec4i64(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4i64; k: Int64): Vec4i64 := new Vec4i64(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4i64): Vec4i64 := new Vec4i64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4i64): Vec4i64 := new Vec4i64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), 0);
    public static function operator implicit(v: Vec4i64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), 0);
    public static function operator implicit(v: Vec4i64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ui): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    public val2: UInt64;
    public val3: UInt64;
    
    public constructor(val0, val1, val2, val3: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4ui64; k: UInt64): Vec4ui64 := new Vec4ui64(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4ui64): Vec4ui64 := new Vec4ui64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4ui64): Vec4ui64 := new Vec4ui64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), 0);
    public static function operator implicit(v: Vec4ui64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), 0);
    public static function operator implicit(v: Vec4ui64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ui): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4f = record
    public val0: single;
    public val1: single;
    public val2: single;
    public val3: single;
    
    public constructor(val0, val1, val2, val3: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4f): Vec4f := new Vec4f(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4f; k: single): Vec4f := new Vec4f(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator/(v: Vec4f; k: single): Vec4f := new Vec4f(v.val0/k, v.val1/k, v.val2/k, v.val3/k);
    public static function operator+(v1, v2: Vec4f): Vec4f := new Vec4f(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4f): Vec4f := new Vec4f(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public static function operator implicit(v: Vec3f): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), Convert.ToSByte(v.val3));
    
    public static function operator implicit(v: Vec4ub): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), Convert.ToByte(v.val3));
    
    public static function operator implicit(v: Vec4s): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), Convert.ToInt16(v.val3));
    
    public static function operator implicit(v: Vec4us): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), Convert.ToUInt16(v.val3));
    
    public static function operator implicit(v: Vec4i): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), Convert.ToInt32(v.val3));
    
    public static function operator implicit(v: Vec4ui): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), Convert.ToUInt32(v.val3));
    
    public static function operator implicit(v: Vec4i64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), Convert.ToInt64(v.val3));
    
    public static function operator implicit(v: Vec4ui64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), Convert.ToUInt64(v.val3));
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4d = record
    public val0: double;
    public val1: double;
    public val2: double;
    public val3: double;
    
    public constructor(val0, val1, val2, val3: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4d): Vec4d := new Vec4d(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4d; k: double): Vec4d := new Vec4d(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator/(v: Vec4d; k: double): Vec4d := new Vec4d(v.val0/k, v.val1/k, v.val2/k, v.val3/k);
    public static function operator+(v1, v2: Vec4d): Vec4d := new Vec4d(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4d): Vec4d := new Vec4d(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public static function operator implicit(v: Vec3f): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), Convert.ToSByte(v.val3));
    
    public static function operator implicit(v: Vec4ub): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), Convert.ToByte(v.val3));
    
    public static function operator implicit(v: Vec4s): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), Convert.ToInt16(v.val3));
    
    public static function operator implicit(v: Vec4us): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), Convert.ToUInt16(v.val3));
    
    public static function operator implicit(v: Vec4i): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), Convert.ToInt32(v.val3));
    
    public static function operator implicit(v: Vec4ui): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), Convert.ToUInt32(v.val3));
    
    public static function operator implicit(v: Vec4i64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), Convert.ToInt64(v.val3));
    
    public static function operator implicit(v: Vec4ui64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), Convert.ToUInt64(v.val3));
    
    public static function operator implicit(v: Vec4f): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  {$endregion Vec4}
  
  {$endregion Vec}
  
  {$region Mtr}
  
  Mtr2x2f = record
    public val00, val10: single;
    public val01, val11: single;
    
    public constructor(val00, val01, val10, val11: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x2f read new Mtr2x2f(1.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec2f read new Vec2f(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2f read new Vec2f(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row[y: integer]: Vec2f read y=0?Row0:y=1?Row1:Arr&<Vec2f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2f read new Vec2f(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2f read new Vec2f(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col[x: integer]: Vec2f read x=0?Col0:x=1?Col1:Arr&<Vec2f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2f read pointer(IntPtr(pointer(@self)) + 8);
    public property ColPtr[x: integer]: ^Vec2f read pointer(IntPtr(pointer(@self)) + x*8);
    
    public static function Scale(k: double): Mtr2x2f := new Mtr2x2f(k, 0.0, 0.0, k);
    
    public static function Traslate(X: single): Mtr2x2f := new Mtr2x2f(1.0, X, 0.0, 1.0);
    public static function TraslateTransposed(X: single): Mtr2x2f := new Mtr2x2f(1.0, 0.0, X, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr2x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x2f(
         cr, +sr,
        -sr,  cr
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x2f(
         cr, -sr,
        +sr,  cr
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,2];
      for var y := 0 to 2-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x2f; v: Vec2f): Vec2f := new Vec2f(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1);
    public static function operator*(v: Vec2f; m: Mtr2x2f): Vec2f := new Vec2f(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1);
    
  end;
  Mtr2f = Mtr2x2f;
  
  Mtr3x3f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    public val02, val12, val22: single;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x3f read new Mtr3x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec3f read new Vec3f(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3f read new Vec3f(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3f read new Vec3f(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row[y: integer]: Vec3f read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec3f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3f read new Vec3f(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3f read new Vec3f(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3f read new Vec3f(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col[x: integer]: Vec3f read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec3f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3f read pointer(IntPtr(pointer(@self)) + 12);
    public property ColPtr2: ^Vec3f read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr[x: integer]: ^Vec3f read pointer(IntPtr(pointer(@self)) + x*12);
    
    public static function Scale(k: double): Mtr3x3f := new Mtr3x3f(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y: single): Mtr3x3f := new Mtr3x3f(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y: single): Mtr3x3f := new Mtr3x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr3x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr3x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,3];
      for var y := 0 to 3-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x3f; v: Vec3f): Vec3f := new Vec3f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2);
    public static function operator*(v: Vec3f; m: Mtr3x3f): Vec3f := new Vec3f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
  end;
  Mtr3f = Mtr3x3f;
  
  Mtr4x4f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    public val02, val12, val22, val32: single;
    public val03, val13, val23, val33: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23, val30, val31, val32, val33: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
      self.val33 := val33;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x4f read new Mtr4x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec4f read new Vec4f(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4f read new Vec4f(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4f read new Vec4f(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row3: Vec4f read new Vec4f(self.val30, self.val31, self.val32, self.val33) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; self.val33 := value.val3; end;
    public property Row[y: integer]: Vec4f read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec4f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4f read new Vec4f(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4f read new Vec4f(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4f read new Vec4f(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col3: Vec4f read new Vec4f(self.val03, self.val13, self.val23, self.val33) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; self.val33 := value.val3; end;
    public property Col[x: integer]: Vec4f read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec4f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4f read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr2: ^Vec4f read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr3: ^Vec4f read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec4f read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr4x4f := new Mtr4x4f(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y, Z: single): Mtr4x4f := new Mtr4x4f(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z, 0.0, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y, Z: single): Mtr4x4f := new Mtr4x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, Z, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr4x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr4x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,4];
      for var y := 0 to 4-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x4f; v: Vec4f): Vec4f := new Vec4f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2+m.val33*v.val3);
    public static function operator*(v: Vec4f; m: Mtr4x4f): Vec4f := new Vec4f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2+m.val33*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
  end;
  Mtr4f = Mtr4x4f;
  
  Mtr2x3f = record
    public val00, val10: single;
    public val01, val11: single;
    public val02, val12: single;
    
    public constructor(val00, val01, val02, val10, val11, val12: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x3f read new Mtr2x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec3f read new Vec3f(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3f read new Vec3f(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row[y: integer]: Vec3f read y=0?Row0:y=1?Row1:Arr&<Vec3f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2f read new Vec2f(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2f read new Vec2f(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2f read new Vec2f(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col[x: integer]: Vec2f read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec2f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3f read pointer(IntPtr(pointer(@self)) + 8);
    public property ColPtr[x: integer]: ^Vec3f read pointer(IntPtr(pointer(@self)) + x*8);
    
    public static function Scale(k: double): Mtr2x3f := new Mtr2x3f(k, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y: single): Mtr2x3f := new Mtr2x3f(1.0, 0.0, X, 0.0, 1.0, Y);
    public static function TraslateTransposed(X: single): Mtr2x3f := new Mtr2x3f(1.0, 0.0, 0.0, X, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x3f(
         cr, +sr, 0.0,
        -sr,  cr, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x3f(
         cr, -sr, 0.0,
        +sr,  cr, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,3];
      for var y := 0 to 2-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x3f; v: Vec3f): Vec2f := new Vec2f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2);
    public static function operator*(v: Vec2f; m: Mtr2x3f): Vec3f := new Vec3f(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
  end;
  
  Mtr3x2f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    
    public constructor(val00, val01, val10, val11, val20, val21: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x2f read new Mtr3x2f(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec2f read new Vec2f(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2f read new Vec2f(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2f read new Vec2f(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row[y: integer]: Vec2f read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec2f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3f read new Vec3f(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3f read new Vec3f(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col[x: integer]: Vec3f read x=0?Col0:x=1?Col1:Arr&<Vec3f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2f read pointer(IntPtr(pointer(@self)) + 12);
    public property ColPtr2: ^Vec2f read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr[x: integer]: ^Vec2f read pointer(IntPtr(pointer(@self)) + x*12);
    
    public static function Scale(k: double): Mtr3x2f := new Mtr3x2f(k, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X: single): Mtr3x2f := new Mtr3x2f(1.0, X, 0.0, 1.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: single): Mtr3x2f := new Mtr3x2f(1.0, 0.0, 0.0, 1.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr3x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x2f(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x2f(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,2];
      for var y := 0 to 3-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x2f; v: Vec2f): Vec3f := new Vec3f(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1);
    public static function operator*(v: Vec3f; m: Mtr3x2f): Vec2f := new Vec2f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
  end;
  
  Mtr2x4f = record
    public val00, val10: single;
    public val01, val11: single;
    public val02, val12: single;
    public val03, val13: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x4f read new Mtr2x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec4f read new Vec4f(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4f read new Vec4f(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row[y: integer]: Vec4f read y=0?Row0:y=1?Row1:Arr&<Vec4f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2f read new Vec2f(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2f read new Vec2f(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2f read new Vec2f(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col3: Vec2f read new Vec2f(self.val03, self.val13) write begin self.val03 := value.val0; self.val13 := value.val1; end;
    public property Col[x: integer]: Vec2f read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec2f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4f read pointer(IntPtr(pointer(@self)) + 8);
    public property ColPtr[x: integer]: ^Vec4f read pointer(IntPtr(pointer(@self)) + x*8);
    
    public static function Scale(k: double): Mtr2x4f := new Mtr2x4f(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X, Y: single): Mtr2x4f := new Mtr2x4f(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y);
    public static function TraslateTransposed(X: single): Mtr2x4f := new Mtr2x4f(1.0, 0.0, 0.0, 0.0, X, 1.0, 0.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x4f(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x4f(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,4];
      for var y := 0 to 2-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x4f; v: Vec4f): Vec2f := new Vec2f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3);
    public static function operator*(v: Vec2f; m: Mtr2x4f): Vec4f := new Vec4f(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1, m.val03*v.val0+m.val13*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr4x2f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    
    public constructor(val00, val01, val10, val11, val20, val21, val30, val31: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
      self.val30 := val30;
      self.val31 := val31;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x2f read new Mtr4x2f(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec2f read new Vec2f(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2f read new Vec2f(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2f read new Vec2f(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row3: Vec2f read new Vec2f(self.val30, self.val31) write begin self.val30 := value.val0; self.val31 := value.val1; end;
    public property Row[y: integer]: Vec2f read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec2f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4f read new Vec4f(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4f read new Vec4f(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col[x: integer]: Vec4f read x=0?Col0:x=1?Col1:Arr&<Vec4f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2f read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr2: ^Vec2f read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr3: ^Vec2f read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec2f read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr4x2f := new Mtr4x2f(k, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0);
    
    public static function Traslate(X: single): Mtr4x2f := new Mtr4x2f(1.0, X, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: single): Mtr4x2f := new Mtr4x2f(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr4x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x2f(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x2f(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,2];
      for var y := 0 to 4-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x2f; v: Vec2f): Vec4f := new Vec4f(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1, m.val30*v.val0+m.val31*v.val1);
    public static function operator*(v: Vec4f; m: Mtr4x2f): Vec2f := new Vec2f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr3x4f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    public val02, val12, val22: single;
    public val03, val13, val23: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x4f read new Mtr3x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec4f read new Vec4f(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4f read new Vec4f(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4f read new Vec4f(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row[y: integer]: Vec4f read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec4f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3f read new Vec3f(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3f read new Vec3f(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3f read new Vec3f(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col3: Vec3f read new Vec3f(self.val03, self.val13, self.val23) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; end;
    public property Col[x: integer]: Vec3f read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec3f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4f read pointer(IntPtr(pointer(@self)) + 12);
    public property ColPtr2: ^Vec4f read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr[x: integer]: ^Vec4f read pointer(IntPtr(pointer(@self)) + x*12);
    
    public static function Scale(k: double): Mtr3x4f := new Mtr3x4f(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y, Z: single): Mtr3x4f := new Mtr3x4f(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z);
    public static function TraslateTransposed(X, Y: single): Mtr3x4f := new Mtr3x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr3x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr3x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,4];
      for var y := 0 to 3-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x4f; v: Vec4f): Vec3f := new Vec3f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3);
    public static function operator*(v: Vec3f; m: Mtr3x4f): Vec4f := new Vec4f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
  end;
  
  Mtr4x3f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    public val02, val12, val22, val32: single;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22, val30, val31, val32: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x3f read new Mtr4x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec3f read new Vec3f(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3f read new Vec3f(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3f read new Vec3f(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row3: Vec3f read new Vec3f(self.val30, self.val31, self.val32) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; end;
    public property Row[y: integer]: Vec3f read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec3f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4f read new Vec4f(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4f read new Vec4f(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4f read new Vec4f(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col[x: integer]: Vec4f read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec4f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3f read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr2: ^Vec3f read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr3: ^Vec3f read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec3f read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr4x3f := new Mtr4x3f(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0);
    
    public static function Traslate(X, Y: single): Mtr4x3f := new Mtr4x3f(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y, Z: single): Mtr4x3f := new Mtr4x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, X, Y, Z);
    
    public static function RotateXYcw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr4x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr4x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,3];
      for var y := 0 to 4-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x3f; v: Vec3f): Vec4f := new Vec4f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2);
    public static function operator*(v: Vec4f; m: Mtr4x3f): Vec3f := new Vec3f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
  end;
  
  Mtr2x2d = record
    public val00, val10: double;
    public val01, val11: double;
    
    public constructor(val00, val01, val10, val11: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x2d read new Mtr2x2d(1.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec2d read new Vec2d(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2d read new Vec2d(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row[y: integer]: Vec2d read y=0?Row0:y=1?Row1:Arr&<Vec2d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2d read new Vec2d(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2d read new Vec2d(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col[x: integer]: Vec2d read x=0?Col0:x=1?Col1:Arr&<Vec2d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2d read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr[x: integer]: ^Vec2d read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr2x2d := new Mtr2x2d(k, 0.0, 0.0, k);
    
    public static function Traslate(X: double): Mtr2x2d := new Mtr2x2d(1.0, X, 0.0, 1.0);
    public static function TraslateTransposed(X: double): Mtr2x2d := new Mtr2x2d(1.0, 0.0, X, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr2x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x2d(
         cr, +sr,
        -sr,  cr
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x2d(
         cr, -sr,
        +sr,  cr
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,2];
      for var y := 0 to 2-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x2d; v: Vec2d): Vec2d := new Vec2d(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1);
    public static function operator*(v: Vec2d; m: Mtr2x2d): Vec2d := new Vec2d(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x4f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
  end;
  Mtr2d = Mtr2x2d;
  
  Mtr3x3d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    public val02, val12, val22: double;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x3d read new Mtr3x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec3d read new Vec3d(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3d read new Vec3d(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3d read new Vec3d(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row[y: integer]: Vec3d read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec3d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3d read new Vec3d(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3d read new Vec3d(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3d read new Vec3d(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col[x: integer]: Vec3d read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec3d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3d read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr2: ^Vec3d read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec3d read pointer(IntPtr(pointer(@self)) + x*24);
    
    public static function Scale(k: double): Mtr3x3d := new Mtr3x3d(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y: double): Mtr3x3d := new Mtr3x3d(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y: double): Mtr3x3d := new Mtr3x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr3x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr3x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,3];
      for var y := 0 to 3-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x3d; v: Vec3d): Vec3d := new Vec3d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2);
    public static function operator*(v: Vec3d; m: Mtr3x3d): Vec3d := new Vec3d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
  end;
  Mtr3d = Mtr3x3d;
  
  Mtr4x4d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    public val02, val12, val22, val32: double;
    public val03, val13, val23, val33: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23, val30, val31, val32, val33: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
      self.val33 := val33;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x4d read new Mtr4x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec4d read new Vec4d(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4d read new Vec4d(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4d read new Vec4d(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row3: Vec4d read new Vec4d(self.val30, self.val31, self.val32, self.val33) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; self.val33 := value.val3; end;
    public property Row[y: integer]: Vec4d read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec4d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4d read new Vec4d(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4d read new Vec4d(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4d read new Vec4d(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col3: Vec4d read new Vec4d(self.val03, self.val13, self.val23, self.val33) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; self.val33 := value.val3; end;
    public property Col[x: integer]: Vec4d read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec4d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4d read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr2: ^Vec4d read pointer(IntPtr(pointer(@self)) + 64);
    public property ColPtr3: ^Vec4d read pointer(IntPtr(pointer(@self)) + 96);
    public property ColPtr[x: integer]: ^Vec4d read pointer(IntPtr(pointer(@self)) + x*32);
    
    public static function Scale(k: double): Mtr4x4d := new Mtr4x4d(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y, Z: double): Mtr4x4d := new Mtr4x4d(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z, 0.0, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y, Z: double): Mtr4x4d := new Mtr4x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, Z, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr4x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr4x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,4];
      for var y := 0 to 4-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x4d; v: Vec4d): Vec4d := new Vec4d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2+m.val33*v.val3);
    public static function operator*(v: Vec4d; m: Mtr4x4d): Vec4d := new Vec4d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2+m.val33*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, m.val30, m.val31, m.val32, m.val33);
    public static function operator implicit(m: Mtr4x4d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, m.val30, m.val31, m.val32, m.val33);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    
    public static function operator implicit(m: Mtr4x3f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    
    public static function operator implicit(m: Mtr2x2d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
  end;
  Mtr4d = Mtr4x4d;
  
  Mtr2x3d = record
    public val00, val10: double;
    public val01, val11: double;
    public val02, val12: double;
    
    public constructor(val00, val01, val02, val10, val11, val12: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x3d read new Mtr2x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec3d read new Vec3d(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3d read new Vec3d(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row[y: integer]: Vec3d read y=0?Row0:y=1?Row1:Arr&<Vec3d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2d read new Vec2d(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2d read new Vec2d(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2d read new Vec2d(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col[x: integer]: Vec2d read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec2d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3d read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr[x: integer]: ^Vec3d read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr2x3d := new Mtr2x3d(k, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y: double): Mtr2x3d := new Mtr2x3d(1.0, 0.0, X, 0.0, 1.0, Y);
    public static function TraslateTransposed(X: double): Mtr2x3d := new Mtr2x3d(1.0, 0.0, 0.0, X, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x3d(
         cr, +sr, 0.0,
        -sr,  cr, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x3d(
         cr, -sr, 0.0,
        +sr,  cr, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,3];
      for var y := 0 to 2-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x3d; v: Vec3d): Vec2d := new Vec2d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2);
    public static function operator*(v: Vec2d; m: Mtr2x3d): Vec3d := new Vec3d(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x4f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
  end;
  
  Mtr3x2d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    
    public constructor(val00, val01, val10, val11, val20, val21: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x2d read new Mtr3x2d(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec2d read new Vec2d(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2d read new Vec2d(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2d read new Vec2d(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row[y: integer]: Vec2d read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec2d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3d read new Vec3d(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3d read new Vec3d(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col[x: integer]: Vec3d read x=0?Col0:x=1?Col1:Arr&<Vec3d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2d read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr2: ^Vec2d read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec2d read pointer(IntPtr(pointer(@self)) + x*24);
    
    public static function Scale(k: double): Mtr3x2d := new Mtr3x2d(k, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X: double): Mtr3x2d := new Mtr3x2d(1.0, X, 0.0, 1.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: double): Mtr3x2d := new Mtr3x2d(1.0, 0.0, 0.0, 1.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr3x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x2d(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x2d(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,2];
      for var y := 0 to 3-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x2d; v: Vec2d): Vec3d := new Vec3d(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1);
    public static function operator*(v: Vec3d; m: Mtr3x2d): Vec2d := new Vec2d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
  end;
  
  Mtr2x4d = record
    public val00, val10: double;
    public val01, val11: double;
    public val02, val12: double;
    public val03, val13: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x4d read new Mtr2x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec4d read new Vec4d(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4d read new Vec4d(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row[y: integer]: Vec4d read y=0?Row0:y=1?Row1:Arr&<Vec4d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2d read new Vec2d(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2d read new Vec2d(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2d read new Vec2d(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col3: Vec2d read new Vec2d(self.val03, self.val13) write begin self.val03 := value.val0; self.val13 := value.val1; end;
    public property Col[x: integer]: Vec2d read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec2d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4d read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr[x: integer]: ^Vec4d read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr2x4d := new Mtr2x4d(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X, Y: double): Mtr2x4d := new Mtr2x4d(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y);
    public static function TraslateTransposed(X: double): Mtr2x4d := new Mtr2x4d(1.0, 0.0, 0.0, 0.0, X, 1.0, 0.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x4d(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x4d(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,4];
      for var y := 0 to 2-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x4d; v: Vec4d): Vec2d := new Vec2d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3);
    public static function operator*(v: Vec2d; m: Mtr2x4d): Vec4d := new Vec4d(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1, m.val03*v.val0+m.val13*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x4f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr4x2d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    
    public constructor(val00, val01, val10, val11, val20, val21, val30, val31: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
      self.val30 := val30;
      self.val31 := val31;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x2d read new Mtr4x2d(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec2d read new Vec2d(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2d read new Vec2d(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2d read new Vec2d(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row3: Vec2d read new Vec2d(self.val30, self.val31) write begin self.val30 := value.val0; self.val31 := value.val1; end;
    public property Row[y: integer]: Vec2d read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec2d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4d read new Vec4d(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4d read new Vec4d(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col[x: integer]: Vec4d read x=0?Col0:x=1?Col1:Arr&<Vec4d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2d read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr2: ^Vec2d read pointer(IntPtr(pointer(@self)) + 64);
    public property ColPtr3: ^Vec2d read pointer(IntPtr(pointer(@self)) + 96);
    public property ColPtr[x: integer]: ^Vec2d read pointer(IntPtr(pointer(@self)) + x*32);
    
    public static function Scale(k: double): Mtr4x2d := new Mtr4x2d(k, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0);
    
    public static function Traslate(X: double): Mtr4x2d := new Mtr4x2d(1.0, X, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: double): Mtr4x2d := new Mtr4x2d(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr4x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x2d(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x2d(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,2];
      for var y := 0 to 4-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x2d; v: Vec2d): Vec4d := new Vec4d(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1, m.val30*v.val0+m.val31*v.val1);
    public static function operator*(v: Vec4d; m: Mtr4x2d): Vec2d := new Vec2d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr3x4d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    public val02, val12, val22: double;
    public val03, val13, val23: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x4d read new Mtr3x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec4d read new Vec4d(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4d read new Vec4d(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4d read new Vec4d(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row[y: integer]: Vec4d read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec4d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3d read new Vec3d(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3d read new Vec3d(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3d read new Vec3d(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col3: Vec3d read new Vec3d(self.val03, self.val13, self.val23) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; end;
    public property Col[x: integer]: Vec3d read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec3d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4d read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr2: ^Vec4d read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec4d read pointer(IntPtr(pointer(@self)) + x*24);
    
    public static function Scale(k: double): Mtr3x4d := new Mtr3x4d(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y, Z: double): Mtr3x4d := new Mtr3x4d(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z);
    public static function TraslateTransposed(X, Y: double): Mtr3x4d := new Mtr3x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr3x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr3x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,4];
      for var y := 0 to 3-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x4d; v: Vec4d): Vec3d := new Vec3d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3);
    public static function operator*(v: Vec3d; m: Mtr3x4d): Vec4d := new Vec4d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    
    public static function operator implicit(m: Mtr4x3f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
  end;
  
  Mtr4x3d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    public val02, val12, val22, val32: double;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22, val30, val31, val32: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x3d read new Mtr4x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec3d read new Vec3d(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3d read new Vec3d(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3d read new Vec3d(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row3: Vec3d read new Vec3d(self.val30, self.val31, self.val32) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; end;
    public property Row[y: integer]: Vec3d read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec3d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4d read new Vec4d(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4d read new Vec4d(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4d read new Vec4d(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col[x: integer]: Vec4d read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec4d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3d read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr2: ^Vec3d read pointer(IntPtr(pointer(@self)) + 64);
    public property ColPtr3: ^Vec3d read pointer(IntPtr(pointer(@self)) + 96);
    public property ColPtr[x: integer]: ^Vec3d read pointer(IntPtr(pointer(@self)) + x*32);
    
    public static function Scale(k: double): Mtr4x3d := new Mtr4x3d(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0);
    
    public static function Traslate(X, Y: double): Mtr4x3d := new Mtr4x3d(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y, Z: double): Mtr4x3d := new Mtr4x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, X, Y, Z);
    
    public static function RotateXYcw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr4x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr4x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,3];
      for var y := 0 to 4-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x3d; v: Vec3d): Vec4d := new Vec4d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2);
    public static function operator*(v: Vec4d; m: Mtr4x3d): Vec3d := new Vec3d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    
    public static function operator implicit(m: Mtr2x2d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
  end;
  
  {$endregion Mtr}
  
  {$region Misc}
  
  [StructLayout(LayoutKind.&Explicit)]
  IntFloatUnion = record
    public [FieldOffset(0)] i: integer;
    public [FieldOffset(0)] f: single;
    
    public constructor(i: integer) := self.i := i;
    public constructor(f: single) := self.f := f;
    
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GDI_COLORREF = record
    public [FieldOffset(1)] b: byte;
    public [FieldOffset(2)] g: byte;
    public [FieldOffset(3)] r: byte;
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GPU_Device_Affinity_Info = record
    
    public [FieldOffset(0)] cb: UInt32;
    
    public [FieldOffset(4)] DeviceName: byte;
    // ANSI строка на 32 символа (но конец сроки обозначается сиволом #0, поэтому помещается 31)
    
    public [FieldOffset(36)] DeviceString: byte;
    // ANSI строка на 128 символов (но конец сроки обозначается сиволом #0, поэтому помещается 127)
    
    public [FieldOffset(164)] Flags: UInt32;
    
    public [FieldOffset(168)] rcVirtualScreen_x1: Int32;
    public [FieldOffset(172)] rcVirtualScreen_y1: Int32;
    public [FieldOffset(176)] rcVirtualScreen_x2: Int32;
    public [FieldOffset(180)] rcVirtualScreen_y2: Int32;
    
    public property SDeviceName: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.DeviceName)))
    write
    begin
      if value.Length > 31 then raise new ArgumentException('Строка не может иметь больше 31 символа');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.DeviceName, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
    public property SDeviceString: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.DeviceString)))
    write
    begin
      if value.Length > 127 then raise new ArgumentException('Строка не может иметь больше 127 символов');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.DeviceString, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GLXHyperpipeNetworkSGIX = record
    
    public [FieldOffset(0)] pipeName: byte;
    // ANSI строка на 80 символа (но конец сроки обозначается сиволом #0, поэтому помещается 79)
    
    public [FieldOffset(80)] networkId: Int32;
    
    public property SPipeName: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.pipeName)))
    write
    begin
      if value.Length > 79 then raise new ArgumentException('Строка не может иметь больше 79 символов');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.pipeName, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GLXHyperpipeConfigDataSGIX = record
    
    public [FieldOffset(0)] pipeName: byte;
    // ANSI строка на 80 символа (но конец сроки обозначается сиволом #0, поэтому помещается 79)
    
    public [FieldOffset(80)] channel: Int32;
    public [FieldOffset(84)] participationType: UInt32;
    public [FieldOffset(88)] timeSlice: Int32;
    
    public property SPipeName: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.pipeName)))
    write
    begin
      if value.Length > 79 then raise new ArgumentException('Строка не может иметь больше 79 символов');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.pipeName, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GLXPipeRect = record
    
    public [FieldOffset(0)] pipeName: byte;
    // ANSI строка на 80 символа (но конец сроки обозначается сиволом #0, поэтому помещается 79)
    
    public [FieldOffset(80)] srcXOrigin: Int32;
    public [FieldOffset(84)] srcYOrigin: Int32;
    public [FieldOffset(88)] srcWidth: Int32;
    public [FieldOffset(92)] srcHeight: Int32;
    
    public [FieldOffset(96)] destXOrigin: Int32;
    public [FieldOffset(100)] destYOrigin: Int32;
    public [FieldOffset(104)] destWidth: Int32;
    public [FieldOffset(108)] destHeight: Int32;
    
    public property SPipeName: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.pipeName)))
    write
    begin
      if value.Length > 79 then raise new ArgumentException('Строка не может иметь больше 79 символов');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.pipeName, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GLXPipeRectLimits = record
    
    public [FieldOffset(0)] pipeName: byte;
    // ANSI строка на 80 символа (но конец сроки обозначается сиволом #0, поэтому помещается 79)
    
    public [FieldOffset(80)] XOrigin: Int32;
    public [FieldOffset(84)] YOrigin: Int32;
    public [FieldOffset(88)] maxHeight: Int32;
    public [FieldOffset(92)] maxWidth: Int32;
    
    public property SPipeName: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.pipeName)))
    write
    begin
      if value.Length > 79 then raise new ArgumentException('Строка не может иметь больше 79 символов');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.pipeName, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
  end;
  
  DrawArraysIndirectCommand = record
    public count:         UInt32;
    public instanceCount: UInt32;
    public first:         UInt32;
    public baseInstance:  UInt32;
    
    public constructor(count, instanceCount, first, baseInstance: UInt32);
    begin
      self.count := count;
      self.instanceCount := instanceCount;
      self.first := first;
      self.baseInstance := baseInstance;
    end;
    
  end;
  
  GDI_GlyphmetricsFloat = record
    public gmfBlackBoxX: single;
    public gmfBlackBoxY: single;
    public gmfptGlyphOriginX: single;
    public gmfptGlyphOriginY: single;
    public gmfCellIncX: single;
    public gmfCellIncY: single;
    
    public constructor(gmfBlackBoxX, gmfBlackBoxY, gmfptGlyphOriginX, gmfptGlyphOriginY, gmfCellIncX, gmfCellIncY: single);
    begin
      self.gmfBlackBoxX := gmfBlackBoxX;
      self.gmfBlackBoxY := gmfBlackBoxY;
      self.gmfptGlyphOriginX := gmfptGlyphOriginX;
      self.gmfptGlyphOriginY := gmfptGlyphOriginY;
      self.gmfCellIncX := gmfCellIncX;
      self.gmfCellIncY := gmfCellIncY;
    end;
    
  end;
  
  //ToDo функции принемающие single - бывает, принимают и fixed
  fixed = record
    {private} val: UInt32;
    
    //ToDo реализовать простейшие операции, с инкапсуляцией но разрешить обращатся к val через свойство
    
  end;
  
  half = record
    {private} val: UInt16;
    
    //ToDo реализовать простейшие операции, с инкапсуляцией но разрешить обращатся к val через свойство
    
  end;
  
  GDI_PixelFormatDescriptor = record
    nSize:            UInt16 := sizeof(GDI_PixelFormatDescriptor);
    nVersion:         UInt16 := 1;
    
    dwFlags:          GDI_PixelFormatFlags;
    iPixelType:       GDI_PixelDataType;
    
    cColorBits:       Byte; // кол-во битов для R+G+B
    
    cRedBits:         Byte; // похоже, если оставить нулями - их автоматом заполнит
    cRedShift:        Byte;
    cGreenBits:       Byte;
    cGreenShift:      Byte;
    cBlueBits:        Byte;
    cBlueShift:       Byte;
    cAlphaBits:       Byte; // последние 2 не работают на Windows
    cAlphaShift:      Byte;
    
    cAccumBits:       Byte;
    cAccumRedBits:    Byte;
    cAccumGreenBits:  Byte;
    cAccumBlueBits:   Byte;
    cAccumAlphaBits:  Byte;
    
    cDepthBits:       Byte;
    cStencilBits:     Byte;
    cAuxBuffers:      Byte; // устарело
    
    iLayerType:       GDI_LayerType; // устарело
    bLayersSize:      Byte; // разделено на 2 числа по 4 бита, и бесполезно без iLayerType, то есть оно тоже устарело
    
    // не смог найти нормального описания последних 3, но все присваивают им нолики
    dwLayerMask:      UInt32;
    dwVisibleMask:    UInt32;
    dwDamageMask:     UInt32;
    
  end;
  
  {$endregion Misc}
  
{$endregion Записи}

type
  
  gl = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region 2 - OpenGL Fundamentals}
    
    {$region 2.3 - Command Execution}
    
    {$region 2.3.1 - Errors}
    
    private static function _GetError: ErrorCode; external 'opengl32.dll' name 'glGetError';
    public static z_GetError: function: ErrorCode := _GetError;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetError: ErrorCode := z_GetError;
    
    {$endregion 2.3.1 - Errors}
    
    {$region 2.3.2 - Graphics Reset Recovery}
    
    public z_GetGraphicsResetStatus := GetGLFuncOrNil&<function: ErrorCode>('glGetGraphicsResetStatus');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGraphicsResetStatus: ErrorCode := z_GetGraphicsResetStatus;
    
    {$endregion 2.3.2 - Graphics Reset Recovery}
    
    {$region 2.3.3 - Flush and Finish}
    
    private static procedure _Flush; external 'opengl32.dll' name 'glFlush';
    public static z_Flush := _Flush;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Flush := z_Flush;
    
    private static procedure _Finish; external 'opengl32.dll' name 'glFinish';
    public static z_Finish := _Finish;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Finish := z_Finish;
    
    {$endregion 2.3.3 - Flush and Finish}
    
    {$endregion 2.3 - Command Execution}
    
    {$endregion 2 - OpenGL Fundamentals}
    
    {$region 4 - Event Model}
    
    {$region 4.1 - Sync Objects and Fences}
    
    public z_FenceSync := GetGLFuncOrNil&<function(condition: FenceCondition; flags: ReservedFlags): GLsync>('glFenceSync');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FenceSync(condition: FenceCondition; flags: ReservedFlags): GLsync := z_FenceSync(condition, flags);
    
    public z_DeleteSync := GetGLFuncOrNil&<procedure(sync: GLsync)>('glDeleteSync');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSync(sync: GLsync) := z_DeleteSync(sync);
    
    {$region 4.1.1 - Waiting for Sync Objects}
    
    public z_WaitSync := GetGLFuncOrNil&<procedure(sync: GLsync; flags: ReservedFlags; timeout: ReservedTimeoutMode)>('glWaitSync');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSync(sync: GLsync; flags: ReservedFlags; timeout: ReservedTimeoutMode) := z_WaitSync(sync, flags, timeout);
    
    public z_ClientWaitSync := GetGLFuncOrNil&<function(sync: GLsync; flags: CommandFlushingBehaviorFlags; timeout: TimeSpan): ClientWaitSyncResult>('glClientWaitSync');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ClientWaitSync(sync: GLsync; flags: CommandFlushingBehaviorFlags; timeout: UInt64): ClientWaitSyncResult := ClientWaitSync(sync, flags, timeout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ClientWaitSync(sync: GLsync; flags: CommandFlushingBehaviorFlags; timeout: TimeSpan): ClientWaitSyncResult := z_ClientWaitSync(sync, flags, timeout);
    
    {$endregion 4.1.1 - Waiting for Sync Objects}
    
    {$region 4.1.3 - Sync Object Queries}
    
    public z_IsSync := GetGLFuncOrNil&<function(sync: GLsync): boolean>('glIsSync');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSync(sync: GLsync): boolean := z_IsSync(sync);
    
    public z_GetSynciv := GetGLFuncOrNil&<procedure(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; length: pointer; values: pointer)>('glGetSynciv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: SyncObjectType) := GetSynciv(sync, pname, bufSize, @length, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: FenceStatus) := GetSynciv(sync, pname, bufSize, @length, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: FenceCondition) := GetSynciv(sync, pname, bufSize, @length, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: Int32) := GetSynciv(sync, pname, bufSize, @length, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; length: pointer; values: pointer) := z_GetSynciv(sync, pname, bufSize, length, values);
    
    {$endregion 4.1.3 - Sync Object Queries}
    
    {$endregion 4.1 - Sync Objects and Fences}
    
    {$region 4.2 - Query Objects and Asynchronous Queries}
    
    {$region 4.2.2 - Query Object Creation and Activation}
    
    public z_GenQueries := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glGenQueries');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueries(n: Int32; ids: array of QueryName) := GenQueries(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueries(n: Int32; var ids: QueryName) := GenQueries(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueries(n: Int32; ids: pointer) := z_GenQueries(n, ids);
    
    public z_EndQueryIndexed := GetGLFuncOrNil&<procedure(target: QueryTargetType; index: UInt32)>('glEndQueryIndexed');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQueryIndexed(target: QueryTargetType; index: UInt32) := z_EndQueryIndexed(target, index);
    
    public z_EndQuery := GetGLFuncOrNil&<procedure(target: QueryTargetType)>('glEndQuery');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQuery(target: QueryTargetType) := z_EndQuery(target);
    
    public z_DeleteQueries := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glDeleteQueries');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueries(n: Int32; ids: array of QueryName) := DeleteQueries(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueries(n: Int32; var ids: QueryName) := DeleteQueries(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueries(n: Int32; ids: pointer) := z_DeleteQueries(n, ids);
    
    public z_CreateQueries := GetGLFuncOrNil&<procedure(target: QueryTargetType; n: Int32; ids: pointer)>('glCreateQueries');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: QueryTargetType; n: Int32; ids: array of QueryName) := CreateQueries(target, n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: QueryTargetType; n: Int32; var ids: QueryName) := CreateQueries(target, n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateQueries(target: QueryTargetType; n: Int32; ids: pointer) := z_CreateQueries(target, n, ids);
    
    public z_BeginQueryIndexed := GetGLFuncOrNil&<procedure(target: QueryTargetType; index: UInt32; id: QueryName)>('glBeginQueryIndexed');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQueryIndexed(target: QueryTargetType; index: UInt32; id: QueryName) := z_BeginQueryIndexed(target, index, id);
    
    public z_BeginQuery := GetGLFuncOrNil&<procedure(target: QueryTargetType; id: QueryName)>('glBeginQuery');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQuery(target: QueryTargetType; id: QueryName) := z_BeginQuery(target, id);
    
    {$endregion 4.2.2 - Query Object Creation and Activation}
    
    {$region 4.2.3 - Query Object Queries}
    
    public z_IsQuery := GetGLFuncOrNil&<function(id: QueryName): boolean>('glIsQuery');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsQuery(id: QueryName): boolean := z_IsQuery(id);
    
    public z_GetQueryObjectuiv := GetGLFuncOrNil&<procedure(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer)>('glGetQueryObjectuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuiv(id: QueryName; pname: GetQueryObjectInfoName; var &params: UInt32) := GetQueryObjectuiv(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuiv(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer) := z_GetQueryObjectuiv(id, pname, &params);
    
    public z_GetQueryObjectui64v := GetGLFuncOrNil&<procedure(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer)>('glGetQueryObjectui64v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: UInt64) := GetQueryObjectui64v(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: TimeSpan) := GetQueryObjectui64v(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: DateTime) := GetQueryObjectui64v(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer) := z_GetQueryObjectui64v(id, pname, &params);
    
    public z_GetQueryObjectiv := GetGLFuncOrNil&<procedure(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer)>('glGetQueryObjectiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectiv(id: QueryName; pname: GetQueryObjectInfoName; var &params: Int32) := GetQueryObjectiv(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectiv(id: QueryName; pname: GetQueryObjectInfoName; var &params: boolean) := GetQueryObjectiv(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectiv(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer) := z_GetQueryObjectiv(id, pname, &params);
    
    public z_GetQueryObjecti64v := GetGLFuncOrNil&<procedure(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer)>('glGetQueryObjecti64v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: Int64) := GetQueryObjecti64v(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64v(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer) := z_GetQueryObjecti64v(id, pname, &params);
    
    public z_GetQueryiv := GetGLFuncOrNil&<procedure(target: QueryTargetType; pname: GetQueryInfoName; &params: pointer)>('glGetQueryiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: Int32) := GetQueryiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: QueryName) := GetQueryiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: boolean) := GetQueryiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: TimeSpan) := GetQueryiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: DateTime) := GetQueryiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; &params: pointer) := z_GetQueryiv(target, pname, &params);
    
    public z_GetQueryIndexediv := GetGLFuncOrNil&<procedure(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; &params: pointer)>('glGetQueryIndexediv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: Int32) := GetQueryIndexediv(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: QueryName) := GetQueryIndexediv(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: boolean) := GetQueryIndexediv(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: TimeSpan) := GetQueryIndexediv(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: DateTime) := GetQueryIndexediv(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; &params: pointer) := z_GetQueryIndexediv(target, index, pname, &params);
    
    public z_GetQueryBufferObjectuiv := GetGLFuncOrNil&<procedure(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr)>('glGetQueryBufferObjectuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectuiv(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr) := z_GetQueryBufferObjectuiv(id, buffer, pname, offset);
    
    public z_GetQueryBufferObjectui64v := GetGLFuncOrNil&<procedure(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr)>('glGetQueryBufferObjectui64v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectui64v(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr) := z_GetQueryBufferObjectui64v(id, buffer, pname, offset);
    
    public z_GetQueryBufferObjectiv := GetGLFuncOrNil&<procedure(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr)>('glGetQueryBufferObjectiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjectiv(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr) := z_GetQueryBufferObjectiv(id, buffer, pname, offset);
    
    public z_GetQueryBufferObjecti64v := GetGLFuncOrNil&<procedure(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr)>('glGetQueryBufferObjecti64v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryBufferObjecti64v(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr) := z_GetQueryBufferObjecti64v(id, buffer, pname, offset);
    
    {$endregion 4.2.3 - Query Object Queries}
    
    {$endregion 4.2 - Query Objects and Asynchronous Queries}
    
    {$region 4.3 - Time Queries}
    
    public z_QueryCounter := GetGLFuncOrNil&<procedure(id: QueryName; target: QueryTargetType)>('glQueryCounter');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryCounter(id: QueryName; target: QueryTargetType) := z_QueryCounter(id, target);
    
    {$endregion 4.3 - Time Queries}
    
    {$endregion 4 - Event Model}
    
    {$region 6 - Buffer Objects}
    
    public z_IsBuffer := GetGLFuncOrNil&<function(buffer: BufferName): boolean>('glIsBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsBuffer(buffer: BufferName): boolean := z_IsBuffer(buffer);
    
    public z_GenBuffers := GetGLFuncOrNil&<procedure(n: Int32; buffers: pointer)>('glGenBuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffers(n: Int32; buffers: array of BufferName) := GenBuffers(n, buffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffers(n: Int32; var buffers: BufferName) := GenBuffers(n, @buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffers(n: Int32; buffers: pointer) := z_GenBuffers(n, buffers);
    
    public z_DeleteBuffers := GetGLFuncOrNil&<procedure(n: Int32; buffers: pointer)>('glDeleteBuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffers(n: Int32; buffers: array of BufferName) := DeleteBuffers(n, buffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffers(n: Int32; var buffers: BufferName) := DeleteBuffers(n, @buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffers(n: Int32; buffers: pointer) := z_DeleteBuffers(n, buffers);
    
    public z_CreateBuffers := GetGLFuncOrNil&<procedure(n: Int32; buffers: pointer)>('glCreateBuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; buffers: array of BufferName) := CreateBuffers(n, buffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; var buffers: BufferName) := CreateBuffers(n, @buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateBuffers(n: Int32; buffers: pointer) := z_CreateBuffers(n, buffers);
    
    {$region 6.1 - Creating and Binding Buffer Objects}
    
    public z_BindBuffer := GetGLFuncOrNil&<procedure(target: BufferBindType; buffer: BufferName)>('glBindBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffer(target: BufferBindType; buffer: BufferName) := z_BindBuffer(target, buffer);
    
    {$region 6.1.1 - Binding Buffer Objects to Indexed Targets}
    
    public z_BindBuffersRange := GetGLFuncOrNil&<procedure(target: BufferBindType; first: UInt32; count: Int32; buffers: pointer; offsets: pointer; sizes: pointer)>('glBindBuffersRange');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferBindType; first: UInt32; count: Int32; buffers: array of BufferName; offsets: array of IntPtr; sizes: array of UIntPtr) := BindBuffersRange(target, first, count, buffers[0], offsets[0], sizes[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferBindType; first: UInt32; count: Int32; var buffers: BufferName; var offsets: IntPtr; var sizes: UIntPtr) := BindBuffersRange(target, first, count, @buffers, @offsets, @sizes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersRange(target: BufferBindType; first: UInt32; count: Int32; buffers: pointer; offsets: pointer; sizes: pointer) := z_BindBuffersRange(target, first, count, buffers, offsets, sizes);
    
    public z_BindBuffersBase := GetGLFuncOrNil&<procedure(target: BufferBindType; first: UInt32; count: Int32; buffers: pointer)>('glBindBuffersBase');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: BufferBindType; first: UInt32; count: Int32; buffers: array of BufferName) := BindBuffersBase(target, first, count, buffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: BufferBindType; first: UInt32; count: Int32; var buffers: BufferName) := BindBuffersBase(target, first, count, @buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBuffersBase(target: BufferBindType; first: UInt32; count: Int32; buffers: pointer) := z_BindBuffersBase(target, first, count, buffers);
    
    public z_BindBufferRange := GetGLFuncOrNil&<procedure(target: BufferBindType; index: UInt32; buffer: BufferName; offset: IntPtr; size: UIntPtr)>('glBindBufferRange');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRange(target: BufferBindType; index: UInt32; buffer: BufferName; offset: IntPtr; size: UIntPtr) := z_BindBufferRange(target, index, buffer, offset, size);
    
    public z_BindBufferBase := GetGLFuncOrNil&<procedure(target: BufferBindType; index: UInt32; buffer: BufferName)>('glBindBufferBase');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBase(target: BufferBindType; index: UInt32; buffer: BufferName) := z_BindBufferBase(target, index, buffer);
    
    {$endregion 6.1.1 - Binding Buffer Objects to Indexed Targets}
    
    {$endregion 6.1 - Creating and Binding Buffer Objects}
    
    {$region 6.2 - Creating and Modifying Buffer Object Data Stores}
    
    public z_NamedBufferSubData := GetGLFuncOrNil&<procedure(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: pointer)>('glNamedBufferSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData<T>(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: array of T); where T: record; begin NamedBufferSubData(buffer, offset, size, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData<T>(buffer: BufferName; offset: IntPtr; size: UIntPtr; var data: T); where T: record; begin NamedBufferSubData(buffer, offset, size, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: IntPtr) := NamedBufferSubData(buffer, offset, size, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: pointer) := z_NamedBufferSubData(buffer, offset, size, data);
    
    public z_NamedBufferStorage := GetGLFuncOrNil&<procedure(buffer: BufferName; size: UIntPtr; data: pointer; flags: BufferStorageFlags)>('glNamedBufferStorage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage<T>(buffer: BufferName; size: UIntPtr; data: array of T; flags: BufferStorageFlags); where T: record; begin NamedBufferStorage(buffer, size, data[0], flags); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage<T>(buffer: BufferName; size: UIntPtr; var data: T; flags: BufferStorageFlags); where T: record; begin NamedBufferStorage(buffer, size, @data, flags); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage(buffer: BufferName; size: UIntPtr; data: IntPtr; flags: BufferStorageFlags) := NamedBufferStorage(buffer, size, pointer(data), flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorage(buffer: BufferName; size: UIntPtr; data: pointer; flags: BufferStorageFlags) := z_NamedBufferStorage(buffer, size, data, flags);
    
    public z_NamedBufferData := GetGLFuncOrNil&<procedure(buffer: BufferName; size: UIntPtr; data: pointer; usage: BufferDataUsage)>('glNamedBufferData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData<T>(buffer: BufferName; size: UIntPtr; data: array of T; usage: BufferDataUsage); where T: record; begin NamedBufferData(buffer, size, data[0], usage); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData<T>(buffer: BufferName; size: UIntPtr; var data: T; usage: BufferDataUsage); where T: record; begin NamedBufferData(buffer, size, @data, usage); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData(buffer: BufferName; size: UIntPtr; data: IntPtr; usage: BufferDataUsage) := NamedBufferData(buffer, size, pointer(data), usage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferData(buffer: BufferName; size: UIntPtr; data: pointer; usage: BufferDataUsage) := z_NamedBufferData(buffer, size, data, usage);
    
    public z_BufferSubData := GetGLFuncOrNil&<procedure(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: pointer)>('glBufferSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubData<T>(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: array of T); where T: record; begin BufferSubData(target, offset, size, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubData<T>(target: BufferBindType; offset: IntPtr; size: UIntPtr; var data: T); where T: record; begin BufferSubData(target, offset, size, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: IntPtr) := BufferSubData(target, offset, size, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: pointer) := z_BufferSubData(target, offset, size, data);
    
    public z_BufferStorage := GetGLFuncOrNil&<procedure(target: BufferBindType; size: UIntPtr; data: pointer; flags: BufferDataUsage)>('glBufferStorage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage<T>(target: BufferBindType; size: UIntPtr; data: array of T; flags: BufferDataUsage); where T: record; begin BufferStorage(target, size, data[0], flags); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage<T>(target: BufferBindType; size: UIntPtr; var data: T; flags: BufferDataUsage); where T: record; begin BufferStorage(target, size, @data, flags); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage(target: BufferBindType; size: UIntPtr; data: IntPtr; flags: BufferDataUsage) := BufferStorage(target, size, pointer(data), flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorage(target: BufferBindType; size: UIntPtr; data: pointer; flags: BufferDataUsage) := z_BufferStorage(target, size, data, flags);
    
    public z_BufferData := GetGLFuncOrNil&<procedure(target: BufferBindType; size: UIntPtr; data: pointer; usage: BufferDataUsage)>('glBufferData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferData<T>(target: BufferBindType; size: UIntPtr; data: array of T; usage: BufferDataUsage); where T: record; begin BufferData(target, size, data[0], usage); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferData<T>(target: BufferBindType; size: UIntPtr; var data: T; usage: BufferDataUsage); where T: record; begin BufferData(target, size, @data, usage); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferData(target: BufferBindType; size: UIntPtr; data: IntPtr; usage: BufferDataUsage) := BufferData(target, size, pointer(data), usage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferData(target: BufferBindType; size: UIntPtr; data: pointer; usage: BufferDataUsage) := z_BufferData(target, size, data, usage);
    
    {$region 6.2.1 - Clearing Buffer Object Data Stores}
    
    public z_ClearNamedBufferSubData := GetGLFuncOrNil&<procedure(buffer: BufferName; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: pointer)>('glClearNamedBufferSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData<T>(buffer: BufferName; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: array of T); where T: record; begin ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData<T>(buffer: BufferName; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; var data: T); where T: record; begin ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData(buffer: BufferName; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: IntPtr) := ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubData(buffer: BufferName; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: pointer) := z_ClearNamedBufferSubData(buffer, internalformat, offset, size, format, &type, data);
    
    public z_ClearNamedBufferData := GetGLFuncOrNil&<procedure(buffer: BufferName; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: pointer)>('glClearNamedBufferData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData<T>(buffer: BufferName; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: array of T); where T: record; begin ClearNamedBufferData(buffer, internalformat, format, &type, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData<T>(buffer: BufferName; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; var data: T); where T: record; begin ClearNamedBufferData(buffer, internalformat, format, &type, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData(buffer: BufferName; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: IntPtr) := ClearNamedBufferData(buffer, internalformat, format, &type, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferData(buffer: BufferName; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: pointer) := z_ClearNamedBufferData(buffer, internalformat, format, &type, data);
    
    public z_ClearBufferSubData := GetGLFuncOrNil&<procedure(target: BufferBindType; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: pointer)>('glClearBufferSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData<T>(target: BufferBindType; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: array of T); where T: record; begin ClearBufferSubData(target, internalformat, offset, size, format, &type, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData<T>(target: BufferBindType; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; var data: T); where T: record; begin ClearBufferSubData(target, internalformat, offset, size, format, &type, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData(target: BufferBindType; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: IntPtr) := ClearBufferSubData(target, internalformat, offset, size, format, &type, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferSubData(target: BufferBindType; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: pointer) := z_ClearBufferSubData(target, internalformat, offset, size, format, &type, data);
    
    public z_ClearBufferData := GetGLFuncOrNil&<procedure(target: BufferBindType; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: pointer)>('glClearBufferData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData<T>(target: BufferBindType; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: array of T); where T: record; begin ClearBufferData(target, internalformat, format, &type, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData<T>(target: BufferBindType; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; var data: T); where T: record; begin ClearBufferData(target, internalformat, format, &type, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData(target: BufferBindType; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: IntPtr) := ClearBufferData(target, internalformat, format, &type, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferData(target: BufferBindType; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: pointer) := z_ClearBufferData(target, internalformat, format, &type, data);
    
    {$endregion 6.2.1 - Clearing Buffer Object Data Stores}
    
    {$endregion 6.2 - Creating and Modifying Buffer Object Data Stores}
    
    {$region 6.3 - Mapping and Unmapping Buffer Data}
    
    public z_MapNamedBufferRange := GetGLFuncOrNil&<function(buffer: BufferName; offset: IntPtr; length: UIntPtr; access: BufferMapFlags): IntPtr>('glMapNamedBufferRange');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferRange(buffer: BufferName; offset: IntPtr; length: UIntPtr; access: BufferMapFlags): IntPtr := z_MapNamedBufferRange(buffer, offset, length, access);
    
    public z_MapNamedBuffer := GetGLFuncOrNil&<function(buffer: BufferName; access: BufferMapFlags): IntPtr>('glMapNamedBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBuffer(buffer: BufferName; access: BufferMapFlags): IntPtr := z_MapNamedBuffer(buffer, access);
    
    public z_MapBufferRange := GetGLFuncOrNil&<function(target: BufferBindType; offset: IntPtr; length: UIntPtr; access: BufferMapFlags): IntPtr>('glMapBufferRange');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBufferRange(target: BufferBindType; offset: IntPtr; length: UIntPtr; access: BufferMapFlags): IntPtr := z_MapBufferRange(target, offset, length, access);
    
    public z_MapBuffer := GetGLFuncOrNil&<function(target: BufferBindType; access: BufferMapFlags): IntPtr>('glMapBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBuffer(target: BufferBindType; access: BufferMapFlags): IntPtr := z_MapBuffer(target, access);
    
    public z_FlushMappedNamedBufferRange := GetGLFuncOrNil&<procedure(buffer: BufferName; offset: IntPtr; length: UIntPtr)>('glFlushMappedNamedBufferRange');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedNamedBufferRange(buffer: BufferName; offset: IntPtr; length: UIntPtr) := z_FlushMappedNamedBufferRange(buffer, offset, length);
    
    public z_FlushMappedBufferRange := GetGLFuncOrNil&<procedure(target: BufferBindType; offset: IntPtr; length: UIntPtr)>('glFlushMappedBufferRange');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedBufferRange(target: BufferBindType; offset: IntPtr; length: UIntPtr) := z_FlushMappedBufferRange(target, offset, length);
    
    {$region 6.3.1 - Unmapping Buffers}
    
    public z_UnmapNamedBuffer := GetGLFuncOrNil&<function(buffer: BufferName): boolean>('glUnmapNamedBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapNamedBuffer(buffer: BufferName): boolean := z_UnmapNamedBuffer(buffer);
    
    public z_UnmapBuffer := GetGLFuncOrNil&<function(target: BufferBindType): boolean>('glUnmapBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapBuffer(target: BufferBindType): boolean := z_UnmapBuffer(target);
    
    {$endregion 6.3.1 - Unmapping Buffers}
    
    {$endregion 6.3 - Mapping and Unmapping Buffer Data}
    
    {$region 6.5 - Invalidating Buffer Data}
    
    public z_InvalidateBufferSubData := GetGLFuncOrNil&<procedure(buffer: BufferName; offset: IntPtr; length: UIntPtr)>('glInvalidateBufferSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateBufferSubData(buffer: BufferName; offset: IntPtr; length: UIntPtr) := z_InvalidateBufferSubData(buffer, offset, length);
    
    public z_InvalidateBufferData := GetGLFuncOrNil&<procedure(buffer: BufferName)>('glInvalidateBufferData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateBufferData(buffer: BufferName) := z_InvalidateBufferData(buffer);
    
    {$endregion 6.5 - Invalidating Buffer Data}
    
    {$region 6.6 - Copying Between Buffers}
    
    public z_CopyNamedBufferSubData := GetGLFuncOrNil&<procedure(readBuffer: BufferName; writeBuffer: BufferName; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>('glCopyNamedBufferSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyNamedBufferSubData(readBuffer: BufferName; writeBuffer: BufferName; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_CopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    public z_CopyBufferSubData := GetGLFuncOrNil&<procedure(readTarget: BufferBindType; writeTarget: BufferBindType; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>('glCopyBufferSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyBufferSubData(readTarget: BufferBindType; writeTarget: BufferBindType; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_CopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
    
    {$endregion 6.6 - Copying Between Buffers}
    
    {$region 6.7 - Buffer Object Queries}
    
    public z_GetNamedBufferSubData := GetGLFuncOrNil&<procedure(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: pointer)>('glGetNamedBufferSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData<T>(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: array of T); where T: record; begin GetNamedBufferSubData(buffer, offset, size, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData<T>(buffer: BufferName; offset: IntPtr; size: UIntPtr; var data: T); where T: record; begin GetNamedBufferSubData(buffer, offset, size, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: IntPtr) := GetNamedBufferSubData(buffer, offset, size, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: pointer) := z_GetNamedBufferSubData(buffer, offset, size, data);
    
    public z_GetNamedBufferPointerv := GetGLFuncOrNil&<procedure(buffer: BufferName; pname: BufferInfoType; &params: pointer)>('glGetNamedBufferPointerv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: BufferName; pname: BufferInfoType; var &params: IntPtr) := GetNamedBufferPointerv(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: BufferName; pname: BufferInfoType; var &params: ^IntPtr) := GetNamedBufferPointerv(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointerv(buffer: BufferName; pname: BufferInfoType; &params: pointer) := z_GetNamedBufferPointerv(buffer, pname, &params);
    
    public z_GetNamedBufferParameteriv := GetGLFuncOrNil&<procedure(buffer: BufferName; pname: BufferInfoType; &params: pointer)>('glGetNamedBufferParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: BufferName; pname: BufferInfoType; var &params: Int32) := GetNamedBufferParameteriv(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: BufferName; pname: BufferInfoType; var &params: BufferDataUsage) := GetNamedBufferParameteriv(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: BufferName; pname: BufferInfoType; var &params: AccessType) := GetNamedBufferParameteriv(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: BufferName; pname: BufferInfoType; var &params: boolean) := GetNamedBufferParameteriv(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteriv(buffer: BufferName; pname: BufferInfoType; &params: pointer) := z_GetNamedBufferParameteriv(buffer, pname, &params);
    
    public z_GetNamedBufferParameteri64v := GetGLFuncOrNil&<procedure(buffer: BufferName; pname: BufferInfoType; &params: pointer)>('glGetNamedBufferParameteri64v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteri64v(buffer: BufferName; pname: BufferInfoType; var &params: Int64) := GetNamedBufferParameteri64v(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameteri64v(buffer: BufferName; pname: BufferInfoType; &params: pointer) := z_GetNamedBufferParameteri64v(buffer, pname, &params);
    
    public z_GetBufferSubData := GetGLFuncOrNil&<procedure(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: pointer)>('glGetBufferSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubData<T>(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: array of T); where T: record; begin GetBufferSubData(target, offset, size, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubData<T>(target: BufferBindType; offset: IntPtr; size: UIntPtr; var data: T); where T: record; begin GetBufferSubData(target, offset, size, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: IntPtr) := GetBufferSubData(target, offset, size, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: pointer) := z_GetBufferSubData(target, offset, size, data);
    
    public z_GetBufferPointerv := GetGLFuncOrNil&<procedure(target: BufferBindType; pname: BufferInfoType; &params: pointer)>('glGetBufferPointerv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointerv(target: BufferBindType; pname: BufferInfoType; var &params: IntPtr) := GetBufferPointerv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointerv(target: BufferBindType; pname: BufferInfoType; var &params: ^IntPtr) := GetBufferPointerv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointerv(target: BufferBindType; pname: BufferInfoType; &params: pointer) := z_GetBufferPointerv(target, pname, &params);
    
    public z_GetBufferParameteriv := GetGLFuncOrNil&<procedure(target: BufferBindType; pname: BufferInfoType; &params: pointer)>('glGetBufferParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: Int32) := GetBufferParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: BufferDataUsage) := GetBufferParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: AccessType) := GetBufferParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: boolean) := GetBufferParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; &params: pointer) := z_GetBufferParameteriv(target, pname, &params);
    
    public z_GetBufferParameteri64v := GetGLFuncOrNil&<procedure(target: BufferBindType; pname: BufferInfoType; &params: pointer)>('glGetBufferParameteri64v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteri64v(target: BufferBindType; pname: BufferInfoType; var &params: Int64) := GetBufferParameteri64v(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameteri64v(target: BufferBindType; pname: BufferInfoType; &params: pointer) := z_GetBufferParameteri64v(target, pname, &params);
    
    {$endregion 6.7 - Buffer Object Queries}
    
    {$endregion 6 - Buffer Objects}
    
    {$region 7 - Programs and Shaders}
    
    {$region 7.1 - Shader Objects}
    
    public z_ShaderSource := GetGLFuncOrNil&<procedure(shader: ShaderName; count: Int32; string: pointer; length: pointer)>('glShaderSource');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: ShaderName; count: Int32; var string: IntPtr; var length: Int32) := ShaderSource(shader, count, @string, @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSource(shader: ShaderName; count: Int32; string: pointer; length: pointer) := z_ShaderSource(shader, count, string, length);
    
    public z_ReleaseShaderCompiler := GetGLFuncOrNil&<procedure>('glReleaseShaderCompiler');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseShaderCompiler := z_ReleaseShaderCompiler;
    
    public z_IsShader := GetGLFuncOrNil&<function(shader: ShaderName): boolean>('glIsShader');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsShader(shader: ShaderName): boolean := z_IsShader(shader);
    
    public z_DeleteShader := GetGLFuncOrNil&<procedure(shader: ShaderName)>('glDeleteShader');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteShader(shader: ShaderName) := z_DeleteShader(shader);
    
    public z_CreateShader := GetGLFuncOrNil&<function(&type: ShaderType): ShaderName>('glCreateShader');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShader(&type: ShaderType): ShaderName := z_CreateShader(&type);
    
    public z_CompileShader := GetGLFuncOrNil&<procedure(shader: ShaderName)>('glCompileShader');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShader(shader: ShaderName) := z_CompileShader(shader);
    
    {$endregion 7.1 - Shader Objects}
    
    {$region 7.2 - Shader Binaries}
    
    public z_ShaderBinary := GetGLFuncOrNil&<procedure(count: Int32; shaders: pointer; binaryformat: ShaderBinaryFormat; binary: pointer; length: Int32)>('glShaderBinary');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: array of ShaderName; binaryformat: ShaderBinaryFormat; binary: array of byte; length: Int32) := ShaderBinary(count, shaders[0], binaryformat, binary[0], length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: array of ShaderName; binaryformat: ShaderBinaryFormat; var binary: byte; length: Int32) := ShaderBinary(count, shaders[0], binaryformat, @binary, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: array of ShaderName; binaryformat: ShaderBinaryFormat; binary: pointer; length: Int32) := ShaderBinary(count, shaders[0], binaryformat, binary, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; var shaders: ShaderName; binaryformat: ShaderBinaryFormat; binary: array of byte; length: Int32) := ShaderBinary(count, @shaders, binaryformat, binary[0], length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; var shaders: ShaderName; binaryformat: ShaderBinaryFormat; var binary: byte; length: Int32) := ShaderBinary(count, @shaders, binaryformat, @binary, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; var shaders: ShaderName; binaryformat: ShaderBinaryFormat; binary: pointer; length: Int32) := ShaderBinary(count, @shaders, binaryformat, binary, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: pointer; binaryformat: ShaderBinaryFormat; binary: array of byte; length: Int32) := ShaderBinary(count, shaders, binaryformat, binary[0], length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: pointer; binaryformat: ShaderBinaryFormat; var binary: byte; length: Int32) := ShaderBinary(count, shaders, binaryformat, @binary, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderBinary(count: Int32; shaders: pointer; binaryformat: ShaderBinaryFormat; binary: pointer; length: Int32) := z_ShaderBinary(count, shaders, binaryformat, binary, length);
    
    {$region 7.2.1 - Shader Specialization}
    
    public z_SpecializeShader := GetGLFuncOrNil&<procedure(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: pointer)>('glSpecializeShader');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of IntFloatUnion); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShader(shader, ptr_2, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of Int32); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShader(shader, ptr_2, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of single); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShader(shader, ptr_2, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: IntFloatUnion); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShader(shader, ptr_2, numSpecializationConstants, @pConstantIndex, @pConstantValue); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: Int32); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShader(shader, ptr_2, numSpecializationConstants, @pConstantIndex, @pConstantValue); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: single); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShader(shader, ptr_2, numSpecializationConstants, @pConstantIndex, @pConstantValue); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: pointer); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShader(shader, ptr_2, numSpecializationConstants, pConstantIndex, pConstantValue); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of IntFloatUnion) := SpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of Int32) := SpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of single) := SpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: IntFloatUnion) := SpecializeShader(shader, pEntryPoint, numSpecializationConstants, @pConstantIndex, @pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: Int32) := SpecializeShader(shader, pEntryPoint, numSpecializationConstants, @pConstantIndex, @pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: single) := SpecializeShader(shader, pEntryPoint, numSpecializationConstants, @pConstantIndex, @pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: pointer) := z_SpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    
    {$endregion 7.2.1 - Shader Specialization}
    
    {$endregion 7.2 - Shader Binaries}
    
    {$region 7.3 - Program Objects}
    
    public z_UseProgram := GetGLFuncOrNil&<procedure(&program: ProgramName)>('glUseProgram');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgram(&program: ProgramName) := z_UseProgram(&program);
    
    public z_ProgramParameteri := GetGLFuncOrNil&<procedure(&program: ProgramName; pname: ProgramParameterType; value: Int32)>('glProgramParameteri');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteri(&program: ProgramName; pname: ProgramParameterType; value: Int32) := z_ProgramParameteri(&program, pname, value);
    
    public z_LinkProgram := GetGLFuncOrNil&<procedure(&program: ProgramName)>('glLinkProgram');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LinkProgram(&program: ProgramName) := z_LinkProgram(&program);
    
    public z_IsProgram := GetGLFuncOrNil&<function(&program: ProgramName): boolean>('glIsProgram');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgram(&program: ProgramName): boolean := z_IsProgram(&program);
    
    public z_DetachShader := GetGLFuncOrNil&<procedure(&program: ProgramName; shader: ShaderName)>('glDetachShader');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetachShader(&program: ProgramName; shader: ShaderName) := z_DetachShader(&program, shader);
    
    public z_DeleteProgram := GetGLFuncOrNil&<procedure(&program: ProgramName)>('glDeleteProgram');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgram(&program: ProgramName) := z_DeleteProgram(&program);
    
    public z_CreateShaderProgramv := GetGLFuncOrNil&<function(&type: ShaderType; count: Int32; strings: pointer): ProgramName>('glCreateShaderProgramv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: ShaderType; count: Int32; strings: array of IntPtr): ProgramName := CreateShaderProgramv(&type, count, strings[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: ShaderType; count: Int32; var strings: IntPtr): ProgramName := CreateShaderProgramv(&type, count, @strings);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramv(&type: ShaderType; count: Int32; strings: pointer): ProgramName := z_CreateShaderProgramv(&type, count, strings);
    
    public z_CreateProgram := GetGLFuncOrNil&<function: ProgramName>('glCreateProgram');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgram: ProgramName := z_CreateProgram;
    
    public z_AttachShader := GetGLFuncOrNil&<procedure(&program: ProgramName; shader: ShaderName)>('glAttachShader');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AttachShader(&program: ProgramName; shader: ShaderName) := z_AttachShader(&program, shader);
    
    {$region 7.3.1 - Program Interfaces}
    
    public z_GetProgramResourceName := GetGLFuncOrNil&<procedure(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; length: pointer; name: IntPtr)>('glGetProgramResourceName');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; var length: Int32; name: string); begin var ptr_6 := Marshal.StringToHGlobalAnsi(name); GetProgramResourceName(&program, programInterface, index, bufSize, @length, ptr_6); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; var length: Int32; name: IntPtr) := GetProgramResourceName(&program, programInterface, index, bufSize, @length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; length: pointer; name: string); begin var ptr_6 := Marshal.StringToHGlobalAnsi(name); GetProgramResourceName(&program, programInterface, index, bufSize, length, ptr_6); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; length: pointer; name: IntPtr) := z_GetProgramResourceName(&program, programInterface, index, bufSize, length, name);
    
    public z_GetProgramResourceLocationIndex := GetGLFuncOrNil&<function(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): Int32>('glGetProgramResourceLocationIndex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndex(&program: ProgramName; programInterface: ProgramInterfaceType; name: string): Int32; begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); Result := GetProgramResourceLocationIndex(&program, programInterface, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndex(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): Int32 := z_GetProgramResourceLocationIndex(&program, programInterface, name);
    
    public z_GetProgramResourceLocation := GetGLFuncOrNil&<function(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): Int32>('glGetProgramResourceLocation');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocation(&program: ProgramName; programInterface: ProgramInterfaceType; name: string): Int32; begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); Result := GetProgramResourceLocation(&program, programInterface, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocation(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): Int32 := z_GetProgramResourceLocation(&program, programInterface, name);
    
    public z_GetProgramResourceiv := GetGLFuncOrNil&<procedure(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: pointer)>('glGetProgramResourceiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: array of Int32; &params: array of Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props[0], bufSize, length[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: array of Int32; var &params: Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props[0], bufSize, length[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: array of Int32; &params: pointer) := GetProgramResourceiv(&program, programInterface, index, propCount, props[0], bufSize, length[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; var length: Int32; &params: array of Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props[0], bufSize, @length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; var length: Int32; var &params: Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props[0], bufSize, @length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; var length: Int32; &params: pointer) := GetProgramResourceiv(&program, programInterface, index, propCount, props[0], bufSize, @length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: pointer; &params: array of Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props[0], bufSize, length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: pointer; var &params: Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props[0], bufSize, length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: pointer; &params: pointer) := GetProgramResourceiv(&program, programInterface, index, propCount, props[0], bufSize, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: array of Int32; &params: array of Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, @props, bufSize, length[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: array of Int32; var &params: Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, @props, bufSize, length[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: array of Int32; &params: pointer) := GetProgramResourceiv(&program, programInterface, index, propCount, @props, bufSize, length[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; var length: Int32; &params: array of Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, @props, bufSize, @length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; var length: Int32; var &params: Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, @props, bufSize, @length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; var length: Int32; &params: pointer) := GetProgramResourceiv(&program, programInterface, index, propCount, @props, bufSize, @length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: pointer; &params: array of Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, @props, bufSize, length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: pointer; var &params: Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, @props, bufSize, length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: pointer; &params: pointer) := GetProgramResourceiv(&program, programInterface, index, propCount, @props, bufSize, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: array of Int32; &params: array of Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props, bufSize, length[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: array of Int32; var &params: Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props, bufSize, length[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: array of Int32; &params: pointer) := GetProgramResourceiv(&program, programInterface, index, propCount, props, bufSize, length[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; var length: Int32; &params: array of Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props, bufSize, @length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; var length: Int32; var &params: Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props, bufSize, @length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; var length: Int32; &params: pointer) := GetProgramResourceiv(&program, programInterface, index, propCount, props, bufSize, @length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: array of Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props, bufSize, length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; var &params: Int32) := GetProgramResourceiv(&program, programInterface, index, propCount, props, bufSize, length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourceiv(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: pointer) := z_GetProgramResourceiv(&program, programInterface, index, propCount, props, bufSize, length, &params);
    
    public z_GetProgramResourceIndex := GetGLFuncOrNil&<function(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): ProgramResourceIndex>('glGetProgramResourceIndex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceIndex(&program: ProgramName; programInterface: ProgramInterfaceType; name: string): ProgramResourceIndex; begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); Result := GetProgramResourceIndex(&program, programInterface, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceIndex(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): ProgramResourceIndex := z_GetProgramResourceIndex(&program, programInterface, name);
    
    public z_GetProgramInterfaceiv := GetGLFuncOrNil&<procedure(&program: ProgramName; programInterface: ProgramInterfaceType; pname: ProgramInterfaceInfoType; &params: pointer)>('glGetProgramInterfaceiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: ProgramName; programInterface: ProgramInterfaceType; pname: ProgramInterfaceInfoType; &params: array of Int32) := GetProgramInterfaceiv(&program, programInterface, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: ProgramName; programInterface: ProgramInterfaceType; pname: ProgramInterfaceInfoType; var &params: Int32) := GetProgramInterfaceiv(&program, programInterface, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInterfaceiv(&program: ProgramName; programInterface: ProgramInterfaceType; pname: ProgramInterfaceInfoType; &params: pointer) := z_GetProgramInterfaceiv(&program, programInterface, pname, &params);
    
    {$endregion 7.3.1 - Program Interfaces}
    
    {$endregion 7.3 - Program Objects}
    
    {$region 7.4 - Program Pipeline Objects}
    
    public z_UseProgramStages := GetGLFuncOrNil&<procedure(pipeline: ProgramPipelineName; stages: ProgramStagesFlags; &program: ProgramName)>('glUseProgramStages');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgramStages(pipeline: ProgramPipelineName; stages: ProgramStagesFlags; &program: ProgramName) := z_UseProgramStages(pipeline, stages, &program);
    
    public z_IsProgramPipeline := GetGLFuncOrNil&<function(pipeline: ProgramPipelineName): boolean>('glIsProgramPipeline');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramPipeline(pipeline: ProgramPipelineName): boolean := z_IsProgramPipeline(pipeline);
    
    public z_GenProgramPipelines := GetGLFuncOrNil&<procedure(n: Int32; pipelines: pointer)>('glGenProgramPipelines');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; pipelines: array of ProgramPipelineName) := GenProgramPipelines(n, pipelines[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; var pipelines: ProgramPipelineName) := GenProgramPipelines(n, @pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelines(n: Int32; pipelines: pointer) := z_GenProgramPipelines(n, pipelines);
    
    public z_DeleteProgramPipelines := GetGLFuncOrNil&<procedure(n: Int32; pipelines: pointer)>('glDeleteProgramPipelines');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; pipelines: array of ProgramPipelineName) := DeleteProgramPipelines(n, pipelines[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; var pipelines: ProgramPipelineName) := DeleteProgramPipelines(n, @pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelines(n: Int32; pipelines: pointer) := z_DeleteProgramPipelines(n, pipelines);
    
    public z_CreateProgramPipelines := GetGLFuncOrNil&<procedure(n: Int32; pipelines: pointer)>('glCreateProgramPipelines');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; pipelines: array of ProgramPipelineName) := CreateProgramPipelines(n, pipelines[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; var pipelines: ProgramPipelineName) := CreateProgramPipelines(n, @pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateProgramPipelines(n: Int32; pipelines: pointer) := z_CreateProgramPipelines(n, pipelines);
    
    public z_BindProgramPipeline := GetGLFuncOrNil&<procedure(pipeline: ProgramPipelineName)>('glBindProgramPipeline');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramPipeline(pipeline: ProgramPipelineName) := z_BindProgramPipeline(pipeline);
    
    public z_ActiveShaderProgram := GetGLFuncOrNil&<procedure(pipeline: ProgramPipelineName; &program: ProgramName)>('glActiveShaderProgram');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveShaderProgram(pipeline: ProgramPipelineName; &program: ProgramName) := z_ActiveShaderProgram(pipeline, &program);
    
    {$endregion 7.4 - Program Pipeline Objects}
    
    {$region 7.5 - Program Binaries}
    
    public z_ProgramBinary := GetGLFuncOrNil&<procedure(&program: UInt32; binaryFormat: DummyEnum; binary: pointer; length: Int32)>('glProgramBinary');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBinary(&program: UInt32; binaryFormat: DummyEnum; binary: pointer; length: Int32) := z_ProgramBinary(&program, binaryFormat, binary, length);
    
    public z_GetProgramBinary := GetGLFuncOrNil&<procedure(&program: UInt32; bufSize: Int32; length: pointer; binaryFormat: pointer; binary: pointer)>('glGetProgramBinary');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: UInt32; bufSize: Int32; length: array of Int32; binaryFormat: array of DummyEnum; binary: pointer) := GetProgramBinary(&program, bufSize, length[0], binaryFormat[0], binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: UInt32; bufSize: Int32; length: array of Int32; var binaryFormat: DummyEnum; binary: pointer) := GetProgramBinary(&program, bufSize, length[0], @binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: UInt32; bufSize: Int32; length: array of Int32; binaryFormat: pointer; binary: pointer) := GetProgramBinary(&program, bufSize, length[0], binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: UInt32; bufSize: Int32; var length: Int32; binaryFormat: array of DummyEnum; binary: pointer) := GetProgramBinary(&program, bufSize, @length, binaryFormat[0], binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: UInt32; bufSize: Int32; var length: Int32; var binaryFormat: DummyEnum; binary: pointer) := GetProgramBinary(&program, bufSize, @length, @binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: UInt32; bufSize: Int32; var length: Int32; binaryFormat: pointer; binary: pointer) := GetProgramBinary(&program, bufSize, @length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: UInt32; bufSize: Int32; length: pointer; binaryFormat: array of DummyEnum; binary: pointer) := GetProgramBinary(&program, bufSize, length, binaryFormat[0], binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: UInt32; bufSize: Int32; length: pointer; var binaryFormat: DummyEnum; binary: pointer) := GetProgramBinary(&program, bufSize, length, @binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinary(&program: UInt32; bufSize: Int32; length: pointer; binaryFormat: pointer; binary: pointer) := z_GetProgramBinary(&program, bufSize, length, binaryFormat, binary);
    
    {$endregion 7.5 - Program Binaries}
    
    {$region 7.6 - Uniform Variables}
    
    public z_GetUniformLocation := GetGLFuncOrNil&<function(&program: ProgramName; name: IntPtr): Int32>('glGetUniformLocation');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocation(&program: ProgramName; name: string): Int32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); Result := GetUniformLocation(&program, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocation(&program: ProgramName; name: IntPtr): Int32 := z_GetUniformLocation(&program, name);
    
    public z_GetUniformIndices := GetGLFuncOrNil&<procedure(&program: ProgramName; uniformCount: Int32; uniformNames: pointer; uniformIndices: pointer)>('glGetUniformIndices');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: array of IntPtr; uniformIndices: array of UInt32) := GetUniformIndices(&program, uniformCount, uniformNames[0], uniformIndices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: array of IntPtr; var uniformIndices: ProgramName) := GetUniformIndices(&program, uniformCount, uniformNames[0], @uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: array of IntPtr; uniformIndices: pointer) := GetUniformIndices(&program, uniformCount, uniformNames[0], uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: array of UInt32) := GetUniformIndices(&program, uniformCount, @uniformNames, uniformIndices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: ProgramName) := GetUniformIndices(&program, uniformCount, @uniformNames, @uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: pointer) := GetUniformIndices(&program, uniformCount, @uniformNames, uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: pointer; uniformIndices: array of UInt32) := GetUniformIndices(&program, uniformCount, uniformNames, uniformIndices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: pointer; var uniformIndices: ProgramName) := GetUniformIndices(&program, uniformCount, uniformNames, @uniformIndices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: pointer; uniformIndices: pointer) := z_GetUniformIndices(&program, uniformCount, uniformNames, uniformIndices);
    
    public z_GetUniformBlockIndex := GetGLFuncOrNil&<function(&program: ProgramName; uniformBlockName: IntPtr): UInt32>('glGetUniformBlockIndex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBlockIndex(&program: ProgramName; uniformBlockName: string): UInt32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(uniformBlockName); Result := GetUniformBlockIndex(&program, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBlockIndex(&program: ProgramName; uniformBlockName: IntPtr): UInt32 := z_GetUniformBlockIndex(&program, uniformBlockName);
    
    public z_GetActiveUniformsiv := GetGLFuncOrNil&<procedure(&program: ProgramName; uniformCount: Int32; uniformIndices: pointer; pname: ProgramInterfaceProperty; &params: pointer)>('glGetActiveUniformsiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; uniformIndices: array of UInt32; pname: ProgramInterfaceProperty; &params: array of Int32) := GetActiveUniformsiv(&program, uniformCount, uniformIndices[0], pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; var uniformIndices: UInt32; pname: ProgramInterfaceProperty; var &params: ShadingLanguageTypeToken) := GetActiveUniformsiv(&program, uniformCount, @uniformIndices, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; var uniformIndices: UInt32; pname: ProgramInterfaceProperty; var &params: Int32) := GetActiveUniformsiv(&program, uniformCount, @uniformIndices, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; uniformIndices: pointer; pname: ProgramInterfaceProperty; &params: pointer) := z_GetActiveUniformsiv(&program, uniformCount, uniformIndices, pname, &params);
    
    public z_GetActiveUniformName := GetGLFuncOrNil&<procedure(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; length: pointer; uniformName: IntPtr)>('glGetActiveUniformName');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(uniformName); GetActiveUniformName(&program, uniformIndex, bufSize, @length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr) := GetActiveUniformName(&program, uniformIndex, bufSize, @length, uniformName);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; length: pointer; uniformName: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(uniformName); GetActiveUniformName(&program, uniformIndex, bufSize, length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; length: pointer; uniformName: IntPtr) := z_GetActiveUniformName(&program, uniformIndex, bufSize, length, uniformName);
    
    public z_GetActiveUniformBlockName := GetGLFuncOrNil&<procedure(&program: ProgramName; uniformBlockIndex: UInt32; bufSize: Int32; length: pointer; uniformBlockName: IntPtr)>('glGetActiveUniformBlockName');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockName(&program: ProgramName; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; uniformBlockName: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(uniformBlockName); GetActiveUniformBlockName(&program, uniformBlockIndex, bufSize, @length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockName(&program: ProgramName; uniformBlockIndex: UInt32; bufSize: Int32; length: pointer; uniformBlockName: IntPtr) := z_GetActiveUniformBlockName(&program, uniformBlockIndex, bufSize, length, uniformBlockName);
    
    public z_GetActiveUniformBlockiv := GetGLFuncOrNil&<procedure(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; &params: pointer)>('glGetActiveUniformBlockiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; &params: array of Int32) := GetActiveUniformBlockiv(&program, uniformBlockIndex, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; var &params: Int32) := GetActiveUniformBlockiv(&program, uniformBlockIndex, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; var &params: ShadingLanguageTypeToken) := GetActiveUniformBlockiv(&program, uniformBlockIndex, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; &params: pointer) := z_GetActiveUniformBlockiv(&program, uniformBlockIndex, pname, &params);
    
    public z_GetActiveUniform := GetGLFuncOrNil&<procedure(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr)>('glGetActiveUniform');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ShadingLanguageTypeToken; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniform(&program, index, bufSize, @length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ShadingLanguageTypeToken; name: IntPtr) := GetActiveUniform(&program, index, bufSize, @length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniform(&program, index, bufSize, length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr) := z_GetActiveUniform(&program, index, bufSize, length, size, &type, name);
    
    public z_GetActiveAtomicCounterBufferiv := GetGLFuncOrNil&<procedure(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; &params: pointer)>('glGetActiveAtomicCounterBufferiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; &params: array of Int32) := GetActiveAtomicCounterBufferiv(&program, bufferIndex, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; var &params: Int32) := GetActiveAtomicCounterBufferiv(&program, bufferIndex, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; var &params: ShadingLanguageTypeToken) := GetActiveAtomicCounterBufferiv(&program, bufferIndex, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; &params: pointer) := z_GetActiveAtomicCounterBufferiv(&program, bufferIndex, pname, &params);
    
    {$region 7.6.1 - Loading Uniform Variables In The Default Uniform Block}
    
    public z_UniformMatrix4x3fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix4x3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix4x3fv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix4x3fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3f) := UniformMatrix4x3fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix4x3fv(location, count, transpose, value);
    
    public z_UniformMatrix4x3dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix4x3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; value: array of double) := UniformMatrix4x3dv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; var value: double) := UniformMatrix4x3dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3d) := UniformMatrix4x3dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix4x3dv(location, count, transpose, value);
    
    public z_UniformMatrix4x2fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix4x2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix4x2fv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix4x2fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2f) := UniformMatrix4x2fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix4x2fv(location, count, transpose, value);
    
    public z_UniformMatrix4x2dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix4x2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; value: array of double) := UniformMatrix4x2dv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; var value: double) := UniformMatrix4x2dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2d) := UniformMatrix4x2dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix4x2dv(location, count, transpose, value);
    
    public z_UniformMatrix4fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix4fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix4fv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix4fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4f) := UniformMatrix4fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix4fv(location, count, transpose, value);
    
    public z_UniformMatrix4dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; value: array of double) := UniformMatrix4dv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; var value: double) := UniformMatrix4dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4d) := UniformMatrix4dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix4dv(location, count, transpose, value);
    
    public z_UniformMatrix3x4fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix3x4fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix3x4fv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix3x4fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4f) := UniformMatrix3x4fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix3x4fv(location, count, transpose, value);
    
    public z_UniformMatrix3x4dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix3x4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; value: array of double) := UniformMatrix3x4dv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; var value: double) := UniformMatrix3x4dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4d) := UniformMatrix3x4dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix3x4dv(location, count, transpose, value);
    
    public z_UniformMatrix3x2fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix3x2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix3x2fv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix3x2fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2f) := UniformMatrix3x2fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix3x2fv(location, count, transpose, value);
    
    public z_UniformMatrix3x2dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix3x2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; value: array of double) := UniformMatrix3x2dv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; var value: double) := UniformMatrix3x2dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2d) := UniformMatrix3x2dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix3x2dv(location, count, transpose, value);
    
    public z_UniformMatrix3fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix3fv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix3fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3f) := UniformMatrix3fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix3fv(location, count, transpose, value);
    
    public z_UniformMatrix3dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; value: array of double) := UniformMatrix3dv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; var value: double) := UniformMatrix3dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3d) := UniformMatrix3dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix3dv(location, count, transpose, value);
    
    public z_UniformMatrix2x4fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix2x4fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix2x4fv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix2x4fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4f) := UniformMatrix2x4fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix2x4fv(location, count, transpose, value);
    
    public z_UniformMatrix2x4dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix2x4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; value: array of double) := UniformMatrix2x4dv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; var value: double) := UniformMatrix2x4dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4d) := UniformMatrix2x4dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix2x4dv(location, count, transpose, value);
    
    public z_UniformMatrix2x3fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix2x3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix2x3fv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix2x3fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3f) := UniformMatrix2x3fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix2x3fv(location, count, transpose, value);
    
    public z_UniformMatrix2x3dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix2x3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; value: array of double) := UniformMatrix2x3dv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; var value: double) := UniformMatrix2x3dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3d) := UniformMatrix2x3dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix2x3dv(location, count, transpose, value);
    
    public z_UniformMatrix2fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix2fv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix2fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2f) := UniformMatrix2fv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix2fv(location, count, transpose, value);
    
    public z_UniformMatrix2dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; value: array of double) := UniformMatrix2dv(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; var value: double) := UniformMatrix2dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2d) := UniformMatrix2dv(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix2dv(location, count, transpose, value);
    
    public z_Uniform4uiv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; value: array of UInt32) := Uniform4uiv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; var value: UInt32) := Uniform4uiv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; var value: Vec4ui) := Uniform4uiv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiv(location: Int32; count: Int32; value: pointer) := z_Uniform4uiv(location, count, value);
    
    public z_Uniform4ui := GetGLFuncOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>('glUniform4ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) := z_Uniform4ui(location, v0, v1, v2, v3);
    
    public z_Uniform4iv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; value: array of Int32) := Uniform4iv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; var value: Int32) := Uniform4iv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; var value: Vec4i) := Uniform4iv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iv(location: Int32; count: Int32; value: pointer) := z_Uniform4iv(location, count, value);
    
    public z_Uniform4i := GetGLFuncOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>('glUniform4i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) := z_Uniform4i(location, v0, v1, v2, v3);
    
    public z_Uniform4fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; value: array of single) := Uniform4fv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; var value: single) := Uniform4fv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; var value: Vec4f) := Uniform4fv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fv(location: Int32; count: Int32; value: pointer) := z_Uniform4fv(location, count, value);
    
    public z_Uniform4f := GetGLFuncOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single; v3: single)>('glUniform4f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4f(location: Int32; v0: single; v1: single; v2: single; v3: single) := z_Uniform4f(location, v0, v1, v2, v3);
    
    public z_Uniform4dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; value: array of double) := Uniform4dv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; var value: double) := Uniform4dv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; var value: Vec4d) := Uniform4dv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4dv(location: Int32; count: Int32; value: pointer) := z_Uniform4dv(location, count, value);
    
    public z_Uniform4d := GetGLFuncOrNil&<procedure(location: Int32; x: double; y: double; z: double; w: double)>('glUniform4d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4d(location: Int32; x: double; y: double; z: double; w: double) := z_Uniform4d(location, x, y, z, w);
    
    public z_Uniform3uiv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; value: array of UInt32) := Uniform3uiv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; var value: UInt32) := Uniform3uiv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; var value: Vec3ui) := Uniform3uiv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiv(location: Int32; count: Int32; value: pointer) := z_Uniform3uiv(location, count, value);
    
    public z_Uniform3ui := GetGLFuncOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>('glUniform3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) := z_Uniform3ui(location, v0, v1, v2);
    
    public z_Uniform3iv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; value: array of Int32) := Uniform3iv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; var value: Int32) := Uniform3iv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; var value: Vec3i) := Uniform3iv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iv(location: Int32; count: Int32; value: pointer) := z_Uniform3iv(location, count, value);
    
    public z_Uniform3i := GetGLFuncOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32)>('glUniform3i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i(location: Int32; v0: Int32; v1: Int32; v2: Int32) := z_Uniform3i(location, v0, v1, v2);
    
    public z_Uniform3fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; value: array of single) := Uniform3fv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; var value: single) := Uniform3fv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; var value: Vec3f) := Uniform3fv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fv(location: Int32; count: Int32; value: pointer) := z_Uniform3fv(location, count, value);
    
    public z_Uniform3f := GetGLFuncOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single)>('glUniform3f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3f(location: Int32; v0: single; v1: single; v2: single) := z_Uniform3f(location, v0, v1, v2);
    
    public z_Uniform3dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; value: array of double) := Uniform3dv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; var value: double) := Uniform3dv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; var value: Vec3d) := Uniform3dv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3dv(location: Int32; count: Int32; value: pointer) := z_Uniform3dv(location, count, value);
    
    public z_Uniform3d := GetGLFuncOrNil&<procedure(location: Int32; x: double; y: double; z: double)>('glUniform3d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3d(location: Int32; x: double; y: double; z: double) := z_Uniform3d(location, x, y, z);
    
    public z_Uniform2uiv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; value: array of UInt32) := Uniform2uiv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; var value: UInt32) := Uniform2uiv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; var value: Vec2ui) := Uniform2uiv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiv(location: Int32; count: Int32; value: pointer) := z_Uniform2uiv(location, count, value);
    
    public z_Uniform2ui := GetGLFuncOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32)>('glUniform2ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui(location: Int32; v0: UInt32; v1: UInt32) := z_Uniform2ui(location, v0, v1);
    
    public z_Uniform2iv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; value: array of Int32) := Uniform2iv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; var value: Int32) := Uniform2iv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; var value: Vec2i) := Uniform2iv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iv(location: Int32; count: Int32; value: pointer) := z_Uniform2iv(location, count, value);
    
    public z_Uniform2i := GetGLFuncOrNil&<procedure(location: Int32; v0: Int32; v1: Int32)>('glUniform2i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i(location: Int32; v0: Int32; v1: Int32) := z_Uniform2i(location, v0, v1);
    
    public z_Uniform2fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; value: array of single) := Uniform2fv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; var value: single) := Uniform2fv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; var value: Vec2f) := Uniform2fv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fv(location: Int32; count: Int32; value: pointer) := z_Uniform2fv(location, count, value);
    
    public z_Uniform2f := GetGLFuncOrNil&<procedure(location: Int32; v0: single; v1: single)>('glUniform2f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2f(location: Int32; v0: single; v1: single) := z_Uniform2f(location, v0, v1);
    
    public z_Uniform2dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; value: array of double) := Uniform2dv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; var value: double) := Uniform2dv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; var value: Vec2d) := Uniform2dv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2dv(location: Int32; count: Int32; value: pointer) := z_Uniform2dv(location, count, value);
    
    public z_Uniform2d := GetGLFuncOrNil&<procedure(location: Int32; x: double; y: double)>('glUniform2d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2d(location: Int32; x: double; y: double) := z_Uniform2d(location, x, y);
    
    public z_Uniform1uiv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; value: array of UInt32) := Uniform1uiv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; var value: UInt32) := Uniform1uiv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; var value: Vec1ui) := Uniform1uiv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiv(location: Int32; count: Int32; value: pointer) := z_Uniform1uiv(location, count, value);
    
    public z_Uniform1ui := GetGLFuncOrNil&<procedure(location: Int32; v0: UInt32)>('glUniform1ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui(location: Int32; v0: UInt32) := z_Uniform1ui(location, v0);
    
    public z_Uniform1iv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; value: array of Int32) := Uniform1iv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; var value: Int32) := Uniform1iv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; var value: Vec1i) := Uniform1iv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iv(location: Int32; count: Int32; value: pointer) := z_Uniform1iv(location, count, value);
    
    public z_Uniform1i := GetGLFuncOrNil&<procedure(location: Int32; v0: Int32)>('glUniform1i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i(location: Int32; v0: Int32) := z_Uniform1i(location, v0);
    
    public z_Uniform1fv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; value: array of single) := Uniform1fv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; var value: single) := Uniform1fv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; var value: Vec1f) := Uniform1fv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fv(location: Int32; count: Int32; value: pointer) := z_Uniform1fv(location, count, value);
    
    public z_Uniform1f := GetGLFuncOrNil&<procedure(location: Int32; v0: single)>('glUniform1f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1f(location: Int32; v0: single) := z_Uniform1f(location, v0);
    
    public z_Uniform1dv := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; value: array of double) := Uniform1dv(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; var value: double) := Uniform1dv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; var value: Vec1d) := Uniform1dv(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1dv(location: Int32; count: Int32; value: pointer) := z_Uniform1dv(location, count, value);
    
    public z_Uniform1d := GetGLFuncOrNil&<procedure(location: Int32; x: double)>('glUniform1d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1d(location: Int32; x: double) := z_Uniform1d(location, x);
    
    public z_ProgramUniformMatrix4x3fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4x3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix4x3fv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix4x3fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3f) := ProgramUniformMatrix4x3fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4x3fv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4x3dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4x3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix4x3dv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix4x3dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3d) := ProgramUniformMatrix4x3dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4x3dv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4x2fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4x2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix4x2fv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix4x2fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2f) := ProgramUniformMatrix4x2fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4x2fv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4x2dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4x2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix4x2dv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix4x2dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2d) := ProgramUniformMatrix4x2dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4x2dv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix4fv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix4fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4f) := ProgramUniformMatrix4fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4fv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix4dv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix4dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4d) := ProgramUniformMatrix4dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4dv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3x4fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3x4fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix3x4fv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix3x4fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4f) := ProgramUniformMatrix3x4fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3x4fv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3x4dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3x4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix3x4dv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix3x4dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4d) := ProgramUniformMatrix3x4dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3x4dv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3x2fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3x2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix3x2fv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix3x2fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2f) := ProgramUniformMatrix3x2fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3x2fv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3x2dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3x2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix3x2dv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix3x2dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2d) := ProgramUniformMatrix3x2dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3x2dv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix3fv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix3fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3f) := ProgramUniformMatrix3fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3fv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix3dv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix3dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3d) := ProgramUniformMatrix3dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3dv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix2x4fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2x4fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix2x4fv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix2x4fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4f) := ProgramUniformMatrix2x4fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2x4fv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix2x4dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2x4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix2x4dv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix2x4dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4d) := ProgramUniformMatrix2x4dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2x4dv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix2x3fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2x3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix2x3fv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix2x3fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3f) := ProgramUniformMatrix2x3fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2x3fv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix2x3dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2x3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix2x3dv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix2x3dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3d) := ProgramUniformMatrix2x3dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2x3dv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix2fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix2fv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix2fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2f) := ProgramUniformMatrix2fv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2fv(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix2dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix2dv(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix2dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2d) := ProgramUniformMatrix2dv(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2dv(&program, location, count, transpose, value);
    
    public z_ProgramUniform4uiv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform4uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; value: array of UInt32) := ProgramUniform4uiv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32) := ProgramUniform4uiv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4ui) := ProgramUniform4uiv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4uiv(&program, location, count, value);
    
    public z_ProgramUniform4ui := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>('glProgramUniform4ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) := z_ProgramUniform4ui(&program, location, v0, v1, v2, v3);
    
    public z_ProgramUniform4iv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform4iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; value: array of Int32) := ProgramUniform4iv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32) := ProgramUniform4iv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4i) := ProgramUniform4iv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4iv(&program, location, count, value);
    
    public z_ProgramUniform4i := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>('glProgramUniform4i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i(&program: ProgramName; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) := z_ProgramUniform4i(&program, location, v0, v1, v2, v3);
    
    public z_ProgramUniform4fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform4fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; value: array of single) := ProgramUniform4fv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; var value: single) := ProgramUniform4fv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4f) := ProgramUniform4fv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4fv(&program, location, count, value);
    
    public z_ProgramUniform4f := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: single; v1: single; v2: single; v3: single)>('glProgramUniform4f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4f(&program: ProgramName; location: Int32; v0: single; v1: single; v2: single; v3: single) := z_ProgramUniform4f(&program, location, v0, v1, v2, v3);
    
    public z_ProgramUniform4dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; value: array of double) := ProgramUniform4dv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; var value: double) := ProgramUniform4dv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4d) := ProgramUniform4dv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4dv(&program, location, count, value);
    
    public z_ProgramUniform4d := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: double; v1: double; v2: double; v3: double)>('glProgramUniform4d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4d(&program: ProgramName; location: Int32; v0: double; v1: double; v2: double; v3: double) := z_ProgramUniform4d(&program, location, v0, v1, v2, v3);
    
    public z_ProgramUniform3uiv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; value: array of UInt32) := ProgramUniform3uiv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32) := ProgramUniform3uiv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3ui) := ProgramUniform3uiv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3uiv(&program, location, count, value);
    
    public z_ProgramUniform3ui := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>('glProgramUniform3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) := z_ProgramUniform3ui(&program, location, v0, v1, v2);
    
    public z_ProgramUniform3iv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform3iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; value: array of Int32) := ProgramUniform3iv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32) := ProgramUniform3iv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3i) := ProgramUniform3iv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3iv(&program, location, count, value);
    
    public z_ProgramUniform3i := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: Int32; v1: Int32; v2: Int32)>('glProgramUniform3i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i(&program: ProgramName; location: Int32; v0: Int32; v1: Int32; v2: Int32) := z_ProgramUniform3i(&program, location, v0, v1, v2);
    
    public z_ProgramUniform3fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; value: array of single) := ProgramUniform3fv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; var value: single) := ProgramUniform3fv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3f) := ProgramUniform3fv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3fv(&program, location, count, value);
    
    public z_ProgramUniform3f := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: single; v1: single; v2: single)>('glProgramUniform3f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3f(&program: ProgramName; location: Int32; v0: single; v1: single; v2: single) := z_ProgramUniform3f(&program, location, v0, v1, v2);
    
    public z_ProgramUniform3dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; value: array of double) := ProgramUniform3dv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; var value: double) := ProgramUniform3dv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3d) := ProgramUniform3dv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3dv(&program, location, count, value);
    
    public z_ProgramUniform3d := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: double; v1: double; v2: double)>('glProgramUniform3d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3d(&program: ProgramName; location: Int32; v0: double; v1: double; v2: double) := z_ProgramUniform3d(&program, location, v0, v1, v2);
    
    public z_ProgramUniform2uiv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform2uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; value: array of UInt32) := ProgramUniform2uiv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32) := ProgramUniform2uiv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2ui) := ProgramUniform2uiv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2uiv(&program, location, count, value);
    
    public z_ProgramUniform2ui := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32)>('glProgramUniform2ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32) := z_ProgramUniform2ui(&program, location, v0, v1);
    
    public z_ProgramUniform2iv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform2iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; value: array of Int32) := ProgramUniform2iv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32) := ProgramUniform2iv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2i) := ProgramUniform2iv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2iv(&program, location, count, value);
    
    public z_ProgramUniform2i := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: Int32; v1: Int32)>('glProgramUniform2i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i(&program: ProgramName; location: Int32; v0: Int32; v1: Int32) := z_ProgramUniform2i(&program, location, v0, v1);
    
    public z_ProgramUniform2fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; value: array of single) := ProgramUniform2fv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; var value: single) := ProgramUniform2fv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2f) := ProgramUniform2fv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2fv(&program, location, count, value);
    
    public z_ProgramUniform2f := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: single; v1: single)>('glProgramUniform2f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2f(&program: ProgramName; location: Int32; v0: single; v1: single) := z_ProgramUniform2f(&program, location, v0, v1);
    
    public z_ProgramUniform2dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; value: array of double) := ProgramUniform2dv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; var value: double) := ProgramUniform2dv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2d) := ProgramUniform2dv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2dv(&program, location, count, value);
    
    public z_ProgramUniform2d := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: double; v1: double)>('glProgramUniform2d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2d(&program: ProgramName; location: Int32; v0: double; v1: double) := z_ProgramUniform2d(&program, location, v0, v1);
    
    public z_ProgramUniform1uiv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform1uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; value: array of UInt32) := ProgramUniform1uiv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32) := ProgramUniform1uiv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1ui) := ProgramUniform1uiv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1uiv(&program, location, count, value);
    
    public z_ProgramUniform1ui := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: UInt32)>('glProgramUniform1ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui(&program: ProgramName; location: Int32; v0: UInt32) := z_ProgramUniform1ui(&program, location, v0);
    
    public z_ProgramUniform1iv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform1iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; value: array of Int32) := ProgramUniform1iv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32) := ProgramUniform1iv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1i) := ProgramUniform1iv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1iv(&program, location, count, value);
    
    public z_ProgramUniform1i := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: Int32)>('glProgramUniform1i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i(&program: ProgramName; location: Int32; v0: Int32) := z_ProgramUniform1i(&program, location, v0);
    
    public z_ProgramUniform1fv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform1fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; value: array of single) := ProgramUniform1fv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; var value: single) := ProgramUniform1fv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1f) := ProgramUniform1fv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1fv(&program, location, count, value);
    
    public z_ProgramUniform1f := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: single)>('glProgramUniform1f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1f(&program: ProgramName; location: Int32; v0: single) := z_ProgramUniform1f(&program, location, v0);
    
    public z_ProgramUniform1dv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; count: Int32; value: pointer)>('glProgramUniform1dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; value: array of double) := ProgramUniform1dv(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; var value: double) := ProgramUniform1dv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1d) := ProgramUniform1dv(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1dv(&program, location, count, value);
    
    public z_ProgramUniform1d := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; v0: double)>('glProgramUniform1d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1d(&program: ProgramName; location: Int32; v0: double) := z_ProgramUniform1d(&program, location, v0);
    
    {$endregion 7.6.1 - Loading Uniform Variables In The Default Uniform Block}
    
    {$region 7.6.3 - Uniform Buffer Object Bindings}
    
    public z_UniformBlockBinding := GetGLFuncOrNil&<procedure(&program: ProgramName; uniformBlockIndex: UInt32; _uniformBlockBinding: UInt32)>('glUniformBlockBinding');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformBlockBinding(&program: ProgramName; uniformBlockIndex: UInt32; _uniformBlockBinding: UInt32) := z_UniformBlockBinding(&program, uniformBlockIndex, _uniformBlockBinding);
    
    {$endregion 7.6.3 - Uniform Buffer Object Bindings}
    
    {$endregion 7.6 - Uniform Variables}
    
    {$region 7.8 - Shader Buffer Variables and Shader Storage Blocks}
    
    public z_ShaderStorageBlockBinding := GetGLFuncOrNil&<procedure(&program: ProgramName; storageBlockIndex: UInt32; storageBlockBinding: UInt32)>('glShaderStorageBlockBinding');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderStorageBlockBinding(&program: ProgramName; storageBlockIndex: UInt32; storageBlockBinding: UInt32) := z_ShaderStorageBlockBinding(&program, storageBlockIndex, storageBlockBinding);
    
    {$endregion 7.8 - Shader Buffer Variables and Shader Storage Blocks}
    
    {$region 7.10 - Subroutine Uniform Variables}
    
    public z_UniformSubroutinesuiv := GetGLFuncOrNil&<procedure(shadertype: ShaderType; count: Int32; indices: pointer)>('glUniformSubroutinesuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; indices: array of UInt32) := UniformSubroutinesuiv(_shadertype, count, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; var indices: UInt32) := UniformSubroutinesuiv(_shadertype, count, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; indices: pointer) := z_UniformSubroutinesuiv(_shadertype, count, indices);
    
    public z_GetSubroutineUniformLocation := GetGLFuncOrNil&<function(&program: ProgramName; shadertype: ShaderType; name: IntPtr): Int32>('glGetSubroutineUniformLocation');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineUniformLocation(&program: ProgramName; _shadertype: ShaderType; name: string): Int32; begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); Result := GetSubroutineUniformLocation(&program, _shadertype, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineUniformLocation(&program: ProgramName; _shadertype: ShaderType; name: IntPtr): Int32 := z_GetSubroutineUniformLocation(&program, _shadertype, name);
    
    public z_GetSubroutineIndex := GetGLFuncOrNil&<function(&program: ProgramName; shadertype: ShaderType; name: IntPtr): UInt32>('glGetSubroutineIndex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineIndex(&program: ProgramName; _shadertype: ShaderType; name: string): UInt32; begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); Result := GetSubroutineIndex(&program, _shadertype, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSubroutineIndex(&program: ProgramName; _shadertype: ShaderType; name: IntPtr): UInt32 := z_GetSubroutineIndex(&program, _shadertype, name);
    
    public z_GetActiveSubroutineUniformName := GetGLFuncOrNil&<procedure(&program: ProgramName; shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; name: IntPtr)>('glGetActiveSubroutineUniformName');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; name: string); begin var ptr_6 := Marshal.StringToHGlobalAnsi(name); GetActiveSubroutineUniformName(&program, _shadertype, index, bufsize, @length, ptr_6); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; name: IntPtr) := GetActiveSubroutineUniformName(&program, _shadertype, index, bufsize, @length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; name: string); begin var ptr_6 := Marshal.StringToHGlobalAnsi(name); GetActiveSubroutineUniformName(&program, _shadertype, index, bufsize, length, ptr_6); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; name: IntPtr) := z_GetActiveSubroutineUniformName(&program, _shadertype, index, bufsize, length, name);
    
    public z_GetActiveSubroutineUniformiv := GetGLFuncOrNil&<procedure(&program: ProgramName; shadertype: ShaderType; index: UInt32; pname: ProgramInterfaceProperty; values: pointer)>('glGetActiveSubroutineUniformiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: ProgramName; _shadertype: ShaderType; index: UInt32; pname: ProgramInterfaceProperty; values: array of Int32) := GetActiveSubroutineUniformiv(&program, _shadertype, index, pname, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: ProgramName; _shadertype: ShaderType; index: UInt32; pname: ProgramInterfaceProperty; var values: Int32) := GetActiveSubroutineUniformiv(&program, _shadertype, index, pname, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineUniformiv(&program: ProgramName; _shadertype: ShaderType; index: UInt32; pname: ProgramInterfaceProperty; values: pointer) := z_GetActiveSubroutineUniformiv(&program, _shadertype, index, pname, values);
    
    public z_GetActiveSubroutineName := GetGLFuncOrNil&<procedure(&program: ProgramName; shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; name: IntPtr)>('glGetActiveSubroutineName');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; name: string); begin var ptr_6 := Marshal.StringToHGlobalAnsi(name); GetActiveSubroutineName(&program, _shadertype, index, bufsize, @length, ptr_6); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; name: IntPtr) := GetActiveSubroutineName(&program, _shadertype, index, bufsize, @length, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; name: string); begin var ptr_6 := Marshal.StringToHGlobalAnsi(name); GetActiveSubroutineName(&program, _shadertype, index, bufsize, length, ptr_6); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; name: IntPtr) := z_GetActiveSubroutineName(&program, _shadertype, index, bufsize, length, name);
    
    {$endregion 7.10 - Subroutine Uniform Variables}
    
    {$region 7.13 - Shader Memory Access}
    
    {$region 7.13.2 - Shader Memory Access Synchronization}
    
    public z_MemoryBarrierByRegion := GetGLFuncOrNil&<procedure(barriers: MemoryBarrierTypeFlags)>('glMemoryBarrierByRegion');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrierByRegion(barriers: MemoryBarrierTypeFlags) := z_MemoryBarrierByRegion(barriers);
    
    public z_MemoryBarrier := GetGLFuncOrNil&<procedure(barriers: MemoryBarrierTypeFlags)>('glMemoryBarrier');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrier(barriers: MemoryBarrierTypeFlags) := z_MemoryBarrier(barriers);
    
    {$endregion 7.13.2 - Shader Memory Access Synchronization}
    
    {$endregion 7.13 - Shader Memory Access}
    
    {$region 7.14 - Shader, Program, and Program Pipeline Queries}
    
    public z_GetUniformuiv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; &params: pointer)>('glGetUniformuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuiv(&program: ProgramName; location: Int32; &params: array of UInt32) := GetUniformuiv(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuiv(&program: ProgramName; location: Int32; var &params: ProgramName) := GetUniformuiv(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuiv(&program: ProgramName; location: Int32; &params: pointer) := z_GetUniformuiv(&program, location, &params);
    
    public z_GetUniformSubroutineuiv := GetGLFuncOrNil&<procedure(shadertype: ShaderType; location: Int32; &params: pointer)>('glGetUniformSubroutineuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; &params: array of UInt32) := GetUniformSubroutineuiv(_shadertype, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; var &params: UInt32) := GetUniformSubroutineuiv(_shadertype, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; &params: pointer) := z_GetUniformSubroutineuiv(_shadertype, location, &params);
    
    public z_GetUniformiv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; &params: pointer)>('glGetUniformiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformiv(&program: ProgramName; location: Int32; &params: array of Int32) := GetUniformiv(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformiv(&program: ProgramName; location: Int32; var &params: Int32) := GetUniformiv(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformiv(&program: ProgramName; location: Int32; &params: pointer) := z_GetUniformiv(&program, location, &params);
    
    public z_GetUniformfv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; &params: pointer)>('glGetUniformfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfv(&program: ProgramName; location: Int32; &params: array of single) := GetUniformfv(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfv(&program: ProgramName; location: Int32; var &params: single) := GetUniformfv(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfv(&program: ProgramName; location: Int32; &params: pointer) := z_GetUniformfv(&program, location, &params);
    
    public z_GetUniformdv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; &params: pointer)>('glGetUniformdv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: ProgramName; location: Int32; &params: array of double) := GetUniformdv(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: ProgramName; location: Int32; var &params: double) := GetUniformdv(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformdv(&program: ProgramName; location: Int32; &params: pointer) := z_GetUniformdv(&program, location, &params);
    
    public z_GetShaderSource := GetGLFuncOrNil&<procedure(shader: ShaderName; bufSize: Int32; length: pointer; source: IntPtr)>('glGetShaderSource');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSource(shader: ShaderName; bufSize: Int32; var length: Int32; source: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(source); GetShaderSource(shader, bufSize, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSource(shader: ShaderName; bufSize: Int32; var length: Int32; source: IntPtr) := GetShaderSource(shader, bufSize, @length, source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSource(shader: ShaderName; bufSize: Int32; length: pointer; source: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(source); GetShaderSource(shader, bufSize, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSource(shader: ShaderName; bufSize: Int32; length: pointer; source: IntPtr) := z_GetShaderSource(shader, bufSize, length, source);
    
    public z_GetShaderPrecisionFormat := GetGLFuncOrNil&<procedure(shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; range: pointer; precision: pointer)>('glGetShaderPrecisionFormat');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; var range: Int32; var precision: Int32) := GetShaderPrecisionFormat(_shadertype, precisiontype, @range, @precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; var range: Int32; precision: pointer) := GetShaderPrecisionFormat(_shadertype, precisiontype, @range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; var range: Vec2i; var precision: Int32) := GetShaderPrecisionFormat(_shadertype, precisiontype, @range, @precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; var range: Vec2i; precision: pointer) := GetShaderPrecisionFormat(_shadertype, precisiontype, @range, precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; range: pointer; var precision: Int32) := GetShaderPrecisionFormat(_shadertype, precisiontype, range, @precision);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; range: pointer; precision: pointer) := z_GetShaderPrecisionFormat(_shadertype, precisiontype, range, precision);
    
    public z_GetShaderiv := GetGLFuncOrNil&<procedure(shader: ShaderName; pname: ShaderInfoType; &params: pointer)>('glGetShaderiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderiv(shader: ShaderName; pname: ShaderInfoType; &params: array of Int32) := GetShaderiv(shader, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderiv(shader: ShaderName; pname: ShaderInfoType; var &params: Int32) := GetShaderiv(shader, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderiv(shader: ShaderName; pname: ShaderInfoType; &params: pointer) := z_GetShaderiv(shader, pname, &params);
    
    public z_GetShaderInfoLog := GetGLFuncOrNil&<procedure(shader: ShaderName; bufSize: Int32; length: pointer; infoLog: IntPtr)>('glGetShaderInfoLog');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; var length: Int32; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetShaderInfoLog(shader, bufSize, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; var length: Int32; infoLog: IntPtr) := GetShaderInfoLog(shader, bufSize, @length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; length: pointer; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetShaderInfoLog(shader, bufSize, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; length: pointer; infoLog: IntPtr) := z_GetShaderInfoLog(shader, bufSize, length, infoLog);
    
    public z_GetProgramStageiv := GetGLFuncOrNil&<procedure(&program: ProgramName; shadertype: ShaderType; pname: ActiveSubroutineInfoType; values: pointer)>('glGetProgramStageiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: ProgramName; _shadertype: ShaderType; pname: ActiveSubroutineInfoType; values: array of Int32) := GetProgramStageiv(&program, _shadertype, pname, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: ProgramName; _shadertype: ShaderType; pname: ActiveSubroutineInfoType; var values: Int32) := GetProgramStageiv(&program, _shadertype, pname, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStageiv(&program: ProgramName; _shadertype: ShaderType; pname: ActiveSubroutineInfoType; values: pointer) := z_GetProgramStageiv(&program, _shadertype, pname, values);
    
    public z_GetProgramPipelineiv := GetGLFuncOrNil&<procedure(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; &params: pointer)>('glGetProgramPipelineiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; var &params: Int32) := GetProgramPipelineiv(pipeline, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; var &params: ProgramName) := GetProgramPipelineiv(pipeline, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; var &params: ErrorCode) := GetProgramPipelineiv(pipeline, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; &params: pointer) := z_GetProgramPipelineiv(pipeline, pname, &params);
    
    public z_GetProgramPipelineInfoLog := GetGLFuncOrNil&<procedure(pipeline: ProgramPipelineName; bufSize: Int32; length: pointer; infoLog: IntPtr)>('glGetProgramPipelineInfoLog');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; var length: Int32; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetProgramPipelineInfoLog(pipeline, bufSize, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; var length: Int32; infoLog: IntPtr) := GetProgramPipelineInfoLog(pipeline, bufSize, @length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; length: pointer; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetProgramPipelineInfoLog(pipeline, bufSize, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; length: pointer; infoLog: IntPtr) := z_GetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
    
    public z_GetProgramiv := GetGLFuncOrNil&<procedure(&program: ProgramName; pname: ProgramInfoType; &params: pointer)>('glGetProgramiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramiv(&program: ProgramName; pname: ProgramInfoType; &params: array of Int32) := GetProgramiv(&program, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramiv(&program: ProgramName; pname: ProgramInfoType; var &params: Int32) := GetProgramiv(&program, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramiv(&program: ProgramName; pname: ProgramInfoType; &params: pointer) := z_GetProgramiv(&program, pname, &params);
    
    public z_GetProgramInfoLog := GetGLFuncOrNil&<procedure(&program: ProgramName; bufSize: Int32; length: pointer; infoLog: IntPtr)>('glGetProgramInfoLog');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; var length: Int32; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetProgramInfoLog(&program, bufSize, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; var length: Int32; infoLog: IntPtr) := GetProgramInfoLog(&program, bufSize, @length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; length: pointer; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetProgramInfoLog(&program, bufSize, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; length: pointer; infoLog: IntPtr) := z_GetProgramInfoLog(&program, bufSize, length, infoLog);
    
    public z_GetnUniformuiv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: ProgramName; location: Int32; bufSize: Int32; &params: array of UInt32) := GetnUniformuiv(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: ProgramName) := GetnUniformuiv(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuiv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformuiv(&program, location, bufSize, &params);
    
    public z_GetnUniformiv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: ProgramName; location: Int32; bufSize: Int32; &params: array of Int32) := GetnUniformiv(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: Int32) := GetnUniformiv(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformiv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformiv(&program, location, bufSize, &params);
    
    public z_GetnUniformfv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: ProgramName; location: Int32; bufSize: Int32; &params: array of single) := GetnUniformfv(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: single) := GetnUniformfv(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformfv(&program, location, bufSize, &params);
    
    public z_GetnUniformdv := GetGLFuncOrNil&<procedure(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformdv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdv(&program: ProgramName; location: Int32; bufSize: Int32; &params: array of double) := GetnUniformdv(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: double) := GetnUniformdv(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformdv(&program, location, bufSize, &params);
    
    public z_GetAttachedShaders := GetGLFuncOrNil&<procedure(&program: ProgramName; maxCount: Int32; count: pointer; shaders: pointer)>('glGetAttachedShaders');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; var count: Int32; shaders: array of ShaderName) := GetAttachedShaders(&program, maxCount, @count, shaders[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; var count: Int32; var shaders: ShaderName) := GetAttachedShaders(&program, maxCount, @count, @shaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; var count: Int32; shaders: pointer) := GetAttachedShaders(&program, maxCount, @count, shaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; count: pointer; shaders: array of ShaderName) := GetAttachedShaders(&program, maxCount, count, shaders[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; count: pointer; var shaders: ShaderName) := GetAttachedShaders(&program, maxCount, count, @shaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; count: pointer; shaders: pointer) := z_GetAttachedShaders(&program, maxCount, count, shaders);
    
    {$endregion 7.14 - Shader, Program, and Program Pipeline Queries}
    
    {$endregion 7 - Programs and Shaders}
    
    {$region 8 - Textures and Samplers}
    
    public z_ActiveTexture := GetGLFuncOrNil&<procedure(texture: TextureUnitId)>('glActiveTexture');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveTexture(texture: TextureUnitId) := z_ActiveTexture(texture);
    
    {$region 8.1 - Texture Objects}
    
    private static function _IsTexture(texture: TextureName): boolean; external 'opengl32.dll' name 'glIsTexture';
    public static z_IsTexture := _IsTexture;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTexture(texture: TextureName): boolean := z_IsTexture(texture);
    
    private static procedure _GenTextures(n: Int32; textures: pointer); external 'opengl32.dll' name 'glGenTextures';
    public static z_GenTextures := _GenTextures;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTextures(n: Int32; textures: array of TextureName) := GenTextures(n, textures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTextures(n: Int32; var textures: TextureName) := GenTextures(n, @textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTextures(n: Int32; textures: pointer) := z_GenTextures(n, textures);
    
    private static procedure _DeleteTextures(n: Int32; textures: pointer); external 'opengl32.dll' name 'glDeleteTextures';
    public static z_DeleteTextures := _DeleteTextures;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTextures(n: Int32; textures: array of TextureName) := DeleteTextures(n, textures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTextures(n: Int32; var textures: TextureName) := DeleteTextures(n, @textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTextures(n: Int32; textures: pointer) := z_DeleteTextures(n, textures);
    
    public z_CreateTextures := GetGLFuncOrNil&<procedure(target: TextureBindTarget; n: Int32; textures: pointer)>('glCreateTextures');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: TextureBindTarget; n: Int32; textures: array of TextureName) := CreateTextures(target, n, textures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: TextureBindTarget; n: Int32; var textures: TextureName) := CreateTextures(target, n, @textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTextures(target: TextureBindTarget; n: Int32; textures: pointer) := z_CreateTextures(target, n, textures);
    
    public z_BindTextureUnit := GetGLFuncOrNil&<procedure(&unit: TextureUnitId; texture: TextureName)>('glBindTextureUnit');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextureUnit(&unit: TextureUnitId; texture: TextureName) := z_BindTextureUnit(&unit, texture);
    
    public z_BindTextures := GetGLFuncOrNil&<procedure(first: TextureUnitId; count: Int32; textures: pointer)>('glBindTextures');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: TextureUnitId; count: Int32; textures: array of TextureName) := BindTextures(first, count, textures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: TextureUnitId; count: Int32; var textures: TextureName) := BindTextures(first, count, @textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextures(first: TextureUnitId; count: Int32; textures: pointer) := z_BindTextures(first, count, textures);
    
    private static procedure _BindTexture(target: TextureBindTarget; texture: TextureName); external 'opengl32.dll' name 'glBindTexture';
    public static z_BindTexture := _BindTexture;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexture(target: TextureBindTarget; texture: TextureName) := z_BindTexture(target, texture);
    
    {$endregion 8.1 - Texture Objects}
    
    {$region 8.2 - Sampler Objects}
    
    public z_SamplerParameteriv := GetGLFuncOrNil&<procedure(sampler: SamplerName; pname: TextureInfoType; param: pointer)>('glSamplerParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var param: Int32) := SamplerParameteriv(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; param: pointer) := z_SamplerParameteriv(sampler, pname, param);
    
    public z_SamplerParameterIuiv := GetGLFuncOrNil&<procedure(sampler: SamplerName; pname: TextureInfoType; param: pointer)>('glSamplerParameterIuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: UInt32) := SamplerParameterIuiv(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: TextureCompareMode) := SamplerParameterIuiv(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: ActivationFunc) := SamplerParameterIuiv(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: PixelFilterMode) := SamplerParameterIuiv(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: PixelWrapMode) := SamplerParameterIuiv(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; param: pointer) := z_SamplerParameterIuiv(sampler, pname, param);
    
    public z_SamplerParameterIiv := GetGLFuncOrNil&<procedure(sampler: SamplerName; pname: TextureInfoType; param: pointer)>('glSamplerParameterIiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; var param: Int32) := SamplerParameterIiv(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; param: pointer) := z_SamplerParameterIiv(sampler, pname, param);
    
    public z_SamplerParameteri := GetGLFuncOrNil&<procedure(sampler: SamplerName; pname: TextureInfoType; param: Int32)>('glSamplerParameteri');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: TextureCompareMode) := SamplerParameteri(sampler, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: ActivationFunc) := SamplerParameteri(sampler, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: PixelFilterMode) := SamplerParameteri(sampler, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: PixelWrapMode) := SamplerParameteri(sampler, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: Int32) := z_SamplerParameteri(sampler, pname, param);
    
    public z_SamplerParameterfv := GetGLFuncOrNil&<procedure(sampler: SamplerName; pname: TextureInfoType; param: pointer)>('glSamplerParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; var param: single) := SamplerParameterfv(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; param: pointer) := z_SamplerParameterfv(sampler, pname, param);
    
    public z_SamplerParameterf := GetGLFuncOrNil&<procedure(sampler: SamplerName; pname: TextureInfoType; param: single)>('glSamplerParameterf');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterf(sampler: SamplerName; pname: TextureInfoType; param: single) := z_SamplerParameterf(sampler, pname, param);
    
    public z_IsSampler := GetGLFuncOrNil&<function(sampler: SamplerName): boolean>('glIsSampler');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSampler(sampler: SamplerName): boolean := z_IsSampler(sampler);
    
    public z_GenSamplers := GetGLFuncOrNil&<procedure(count: Int32; samplers: pointer)>('glGenSamplers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; samplers: array of SamplerName) := GenSamplers(count, samplers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; var samplers: SamplerName) := GenSamplers(count, @samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSamplers(count: Int32; samplers: pointer) := z_GenSamplers(count, samplers);
    
    public z_DeleteSamplers := GetGLFuncOrNil&<procedure(count: Int32; samplers: pointer)>('glDeleteSamplers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; samplers: array of SamplerName) := DeleteSamplers(count, samplers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; var samplers: SamplerName) := DeleteSamplers(count, @samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSamplers(count: Int32; samplers: pointer) := z_DeleteSamplers(count, samplers);
    
    public z_CreateSamplers := GetGLFuncOrNil&<procedure(n: Int32; samplers: pointer)>('glCreateSamplers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; samplers: array of SamplerName) := CreateSamplers(n, samplers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; var samplers: SamplerName) := CreateSamplers(n, @samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateSamplers(n: Int32; samplers: pointer) := z_CreateSamplers(n, samplers);
    
    public z_BindSamplers := GetGLFuncOrNil&<procedure(first: Int32; count: Int32; samplers: pointer)>('glBindSamplers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: Int32; count: Int32; samplers: array of SamplerName) := BindSamplers(first, count, samplers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: Int32; count: Int32; var samplers: SamplerName) := BindSamplers(first, count, @samplers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSamplers(first: Int32; count: Int32; samplers: pointer) := z_BindSamplers(first, count, samplers);
    
    public z_BindSampler := GetGLFuncOrNil&<procedure(&unit: Int32; sampler: SamplerName)>('glBindSampler');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSampler(&unit: Int32; sampler: SamplerName) := z_BindSampler(&unit, sampler);
    
    {$endregion 8.2 - Sampler Objects}
    
    {$region 8.3 - Sampler Object Queries}
    
    public z_GetSamplerParameteriv := GetGLFuncOrNil&<procedure(sampler: SamplerName; pname: TextureInfoType; &params: pointer)>('glGetSamplerParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: Int32) := GetSamplerParameteriv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: TextureCompareMode) := GetSamplerParameteriv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: ActivationFunc) := GetSamplerParameteriv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelFilterMode) := GetSamplerParameteriv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelWrapMode) := GetSamplerParameteriv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; &params: pointer) := z_GetSamplerParameteriv(sampler, pname, &params);
    
    public z_GetSamplerParameterIuiv := GetGLFuncOrNil&<procedure(sampler: SamplerName; pname: TextureInfoType; &params: pointer)>('glGetSamplerParameterIuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: UInt32) := GetSamplerParameterIuiv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: TextureCompareMode) := GetSamplerParameterIuiv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: ActivationFunc) := GetSamplerParameterIuiv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelFilterMode) := GetSamplerParameterIuiv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelWrapMode) := GetSamplerParameterIuiv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; &params: pointer) := z_GetSamplerParameterIuiv(sampler, pname, &params);
    
    public z_GetSamplerParameterIiv := GetGLFuncOrNil&<procedure(sampler: SamplerName; pname: TextureInfoType; &params: pointer)>('glGetSamplerParameterIiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; var &params: Int32) := GetSamplerParameterIiv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; &params: pointer) := z_GetSamplerParameterIiv(sampler, pname, &params);
    
    public z_GetSamplerParameterfv := GetGLFuncOrNil&<procedure(sampler: SamplerName; pname: TextureInfoType; &params: pointer)>('glGetSamplerParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; var &params: single) := GetSamplerParameterfv(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; &params: pointer) := z_GetSamplerParameterfv(sampler, pname, &params);
    
    {$endregion 8.3 - Sampler Object Queries}
    
    {$region 8.4 - Pixel Rectangles}
    
    {$region 8.4.1 - Pixel Storage Modes and Pixel Buffer Objects}
    
    private static procedure _PixelStorei(pname: PixelInfoType; param: Int32); external 'opengl32.dll' name 'glPixelStorei';
    public static z_PixelStorei := _PixelStorei;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStorei(pname: PixelInfoType; param: Int32) := z_PixelStorei(pname, param);
    
    private static procedure _PixelStoref(pname: PixelInfoType; param: single); external 'opengl32.dll' name 'glPixelStoref';
    public static z_PixelStoref := _PixelStoref;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStoref(pname: PixelInfoType; param: single) := z_PixelStoref(pname, param);
    
    {$endregion 8.4.1 - Pixel Storage Modes and Pixel Buffer Objects}
    
    {$endregion 8.4 - Pixel Rectangles}
    
    {$region 8.5 - Texture Image Specification}
    
    public z_TexImage3D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer)>('glTexImage3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: array of T); where T: record; begin TexImage3D(target, level, internalformat, width, height, depth, border, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: DataFormat; &type: DataType; var pixels: T); where T: record; begin TexImage3D(target, level, internalformat, width, height, depth, border, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: IntPtr) := TexImage3D(target, level, internalformat, width, height, depth, border, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer) := z_TexImage3D(target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    {$region 8.5.3 - Texture Image Structure}
    
    private static procedure _TexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer); external 'opengl32.dll' name 'glTexImage2D';
    public static z_TexImage2D := _TexImage2D;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: array of T); where T: record; begin TexImage2D(target, level, internalformat, width, height, border, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; format: DataFormat; &type: DataType; var pixels: T); where T: record; begin TexImage2D(target, level, internalformat, width, height, border, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: IntPtr) := TexImage2D(target, level, internalformat, width, height, border, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer) := z_TexImage2D(target, level, internalformat, width, height, border, format, &type, pixels);
    
    private static procedure _TexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer); external 'opengl32.dll' name 'glTexImage1D';
    public static z_TexImage1D := _TexImage1D;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage1D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: array of T); where T: record; begin TexImage1D(target, level, internalformat, width, border, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage1D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; format: DataFormat; &type: DataType; var pixels: T); where T: record; begin TexImage1D(target, level, internalformat, width, border, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: IntPtr) := TexImage1D(target, level, internalformat, width, border, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer) := z_TexImage1D(target, level, internalformat, width, border, format, &type, pixels);
    
    {$endregion 8.5.3 - Texture Image Structure}
    
    {$endregion 8.5 - Texture Image Specification}
    
    {$region 8.6 - Alternate Texture Image Specification Commands}
    
    public z_TextureSubImage3D := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: pointer)>('glTextureSubImage3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3D<T>(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: array of T); where T: record; begin TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3D<T>(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; var pixels: T); where T: record; begin TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: IntPtr) := TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: pointer) := z_TextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    public z_TextureSubImage2D := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer)>('glTextureSubImage2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2D<T>(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: array of T); where T: record; begin TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2D<T>(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; var pixels: T); where T: record; begin TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: IntPtr) := TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer) := z_TextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    public z_TextureSubImage1D := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; xoffset: Int32; width: Int32; format: UInt32; &type: DataType; pixels: pointer)>('glTextureSubImage1D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1D<T>(texture: TextureName; level: Int32; xoffset: Int32; width: Int32; format: UInt32; &type: DataType; pixels: array of T); where T: record; begin TextureSubImage1D(texture, level, xoffset, width, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1D<T>(texture: TextureName; level: Int32; xoffset: Int32; width: Int32; format: UInt32; &type: DataType; var pixels: T); where T: record; begin TextureSubImage1D(texture, level, xoffset, width, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1D(texture: TextureName; level: Int32; xoffset: Int32; width: Int32; format: UInt32; &type: DataType; pixels: IntPtr) := TextureSubImage1D(texture, level, xoffset, width, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1D(texture: TextureName; level: Int32; xoffset: Int32; width: Int32; format: UInt32; &type: DataType; pixels: pointer) := z_TextureSubImage1D(texture, level, xoffset, width, format, &type, pixels);
    
    public z_TexSubImage3D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: pointer)>('glTexSubImage3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage3D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: array of T); where T: record; begin TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage3D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; var pixels: T); where T: record; begin TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: IntPtr) := TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: pointer) := z_TexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    private static procedure _TexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer); external 'opengl32.dll' name 'glTexSubImage2D';
    public static z_TexSubImage2D := _TexSubImage2D;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage2D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: array of T); where T: record; begin TexSubImage2D(target, level, xoffset, yoffset, width, height, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage2D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; var pixels: T); where T: record; begin TexSubImage2D(target, level, xoffset, yoffset, width, height, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: IntPtr) := TexSubImage2D(target, level, xoffset, yoffset, width, height, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer) := z_TexSubImage2D(target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    private static procedure _TexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; &type: DataType; pixels: pointer); external 'opengl32.dll' name 'glTexSubImage1D';
    public static z_TexSubImage1D := _TexSubImage1D;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage1D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; &type: DataType; pixels: array of T); where T: record; begin TexSubImage1D(target, level, xoffset, width, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage1D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; &type: DataType; var pixels: T); where T: record; begin TexSubImage1D(target, level, xoffset, width, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; &type: DataType; pixels: IntPtr) := TexSubImage1D(target, level, xoffset, width, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; &type: DataType; pixels: pointer) := z_TexSubImage1D(target, level, xoffset, width, format, &type, pixels);
    
    public z_CopyTextureSubImage3D := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyTextureSubImage3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage3D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    public z_CopyTextureSubImage2D := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyTextureSubImage2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage2D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);
    
    public z_CopyTextureSubImage1D := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>('glCopyTextureSubImage1D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage1D(texture: TextureName; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) := z_CopyTextureSubImage1D(texture, level, xoffset, x, y, width);
    
    public z_CopyTexSubImage3D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyTexSubImage3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    private static procedure _CopyTexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32); external 'opengl32.dll' name 'glCopyTexSubImage2D';
    public static z_CopyTexSubImage2D := _CopyTexSubImage2D;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
    
    private static procedure _CopyTexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32); external 'opengl32.dll' name 'glCopyTexSubImage1D';
    public static z_CopyTexSubImage1D := _CopyTexSubImage1D;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) := z_CopyTexSubImage1D(target, level, xoffset, x, y, width);
    
    private static procedure _CopyTexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32); external 'opengl32.dll' name 'glCopyTexImage2D';
    public static z_CopyTexImage2D := _CopyTexImage2D;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) := z_CopyTexImage2D(target, level, internalformat, x, y, width, height, border);
    
    private static procedure _CopyTexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; x: Int32; y: Int32; width: Int32; border: Int32); external 'opengl32.dll' name 'glCopyTexImage1D';
    public static z_CopyTexImage1D := _CopyTexImage1D;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; x: Int32; y: Int32; width: Int32; border: Int32) := z_CopyTexImage1D(target, level, internalformat, x, y, width, border);
    
    {$endregion 8.6 - Alternate Texture Image Specification Commands}
    
    {$region 8.7 - Compressed Texture Images}
    
    public z_CompressedTextureSubImage3D := GetGLFuncOrNil&<procedure(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: pointer)>('glCompressedTextureSubImage3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3D<T>(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: array of T); where T: record; begin CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3D<T>(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; var data: T); where T: record; begin CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: IntPtr) := CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: pointer) := z_CompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    public z_CompressedTextureSubImage2D := GetGLFuncOrNil&<procedure(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: pointer)>('glCompressedTextureSubImage2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2D<T>(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: array of T); where T: record; begin CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2D<T>(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; var data: T); where T: record; begin CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: IntPtr) := CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: pointer) := z_CompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    public z_CompressedTextureSubImage1D := GetGLFuncOrNil&<procedure(texture: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: pointer)>('glCompressedTextureSubImage1D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1D<T>(texture: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: array of T); where T: record; begin CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1D<T>(texture: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; var data: T); where T: record; begin CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1D(texture: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: IntPtr) := CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1D(texture: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: pointer) := z_CompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data);
    
    public z_CompressedTexSubImage3D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: pointer)>('glCompressedTexSubImage3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage3D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: array of T); where T: record; begin CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage3D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; var data: T); where T: record; begin CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: IntPtr) := CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: pointer) := z_CompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    public z_CompressedTexSubImage2D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: pointer)>('glCompressedTexSubImage2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage2D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: array of T); where T: record; begin CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage2D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; var data: T); where T: record; begin CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: IntPtr) := CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: pointer) := z_CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    public z_CompressedTexSubImage1D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: pointer)>('glCompressedTexSubImage1D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage1D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: array of T); where T: record; begin CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage1D<T>(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; var data: T); where T: record; begin CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: IntPtr) := CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: pointer) := z_CompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
    
    public z_CompressedTexImage3D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: pointer)>('glCompressedTexImage3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage3D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: array of T); where T: record; begin CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage3D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; var data: T); where T: record; begin CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr) := CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: pointer) := z_CompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
    
    public z_CompressedTexImage2D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: pointer)>('glCompressedTexImage2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage2D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: array of T); where T: record; begin CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage2D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; var data: T); where T: record; begin CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr) := CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: pointer) := z_CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
    
    public z_CompressedTexImage1D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; imageSize: Int32; data: pointer)>('glCompressedTexImage1D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage1D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; imageSize: Int32; data: array of T); where T: record; begin CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage1D<T>(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; imageSize: Int32; var data: T); where T: record; begin CompressedTexImage1D(target, level, internalformat, width, border, imageSize, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr) := CompressedTexImage1D(target, level, internalformat, width, border, imageSize, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; imageSize: Int32; data: pointer) := z_CompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
    
    {$endregion 8.7 - Compressed Texture Images}
    
    {$region 8.8 - Multisample Textures}
    
    public z_TexImage3DMultisample := GetGLFuncOrNil&<procedure(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>('glTexImage3DMultisample');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) := z_TexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    public z_TexImage2DMultisample := GetGLFuncOrNil&<procedure(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean)>('glTexImage2DMultisample');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean) := z_TexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
    
    {$endregion 8.8 - Multisample Textures}
    
    {$region 8.9 - Buffer Textures}
    
    public z_TextureBufferRange := GetGLFuncOrNil&<procedure(texture: TextureName; internalformat: InternalDataFormat; buffer: BufferName; offset: IntPtr; size: UIntPtr)>('glTextureBufferRange');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferRange(texture: TextureName; internalformat: InternalDataFormat; buffer: BufferName; offset: IntPtr; size: UIntPtr) := z_TextureBufferRange(texture, internalformat, buffer, offset, size);
    
    public z_TextureBuffer := GetGLFuncOrNil&<procedure(texture: TextureName; internalformat: InternalDataFormat; buffer: BufferName)>('glTextureBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBuffer(texture: TextureName; internalformat: InternalDataFormat; buffer: BufferName) := z_TextureBuffer(texture, internalformat, buffer);
    
    public z_TexBufferRange := GetGLFuncOrNil&<procedure(target: TextureBindTarget; internalformat: InternalDataFormat; buffer: BufferName; offset: IntPtr; size: UIntPtr)>('glTexBufferRange');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferRange(target: TextureBindTarget; internalformat: InternalDataFormat; buffer: BufferName; offset: IntPtr; size: UIntPtr) := z_TexBufferRange(target, internalformat, buffer, offset, size);
    
    public z_TexBuffer := GetGLFuncOrNil&<procedure(target: TextureBindTarget; internalformat: InternalDataFormat; buffer: BufferName)>('glTexBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBuffer(target: TextureBindTarget; internalformat: InternalDataFormat; buffer: BufferName) := z_TexBuffer(target, internalformat, buffer);
    
    {$endregion 8.9 - Buffer Textures}
    
    {$region 8.10 - Texture Parameters}
    
    public z_TextureParameteriv := GetGLFuncOrNil&<procedure(texture: TextureName; pname: TextureInfoType; param: pointer)>('glTextureParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: Int32) := TextureParameteriv(texture, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: DepthStencilMode) := TextureParameteriv(texture, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: TextureCompareMode) := TextureParameteriv(texture, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: ActivationFunc) := TextureParameteriv(texture, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: PixelFilterMode) := TextureParameteriv(texture, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: SwizzleMode) := TextureParameteriv(texture, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: PixelWrapMode) := TextureParameteriv(texture, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; param: pointer) := z_TextureParameteriv(texture, pname, param);
    
    public z_TextureParameterIuiv := GetGLFuncOrNil&<procedure(texture: TextureName; pname: TextureInfoType; &params: pointer)>('glTextureParameterIuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: UInt32) := TextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: DepthStencilMode) := TextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: TextureCompareMode) := TextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: ActivationFunc) := TextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelFilterMode) := TextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: SwizzleMode) := TextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelWrapMode) := TextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; &params: pointer) := z_TextureParameterIuiv(texture, pname, &params);
    
    public z_TextureParameterIiv := GetGLFuncOrNil&<procedure(texture: TextureName; pname: TextureInfoType; &params: pointer)>('glTextureParameterIiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: TextureName; pname: TextureInfoType; var &params: Int32) := TextureParameterIiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIiv(texture: TextureName; pname: TextureInfoType; &params: pointer) := z_TextureParameterIiv(texture, pname, &params);
    
    public z_TextureParameteri := GetGLFuncOrNil&<procedure(texture: TextureName; pname: TextureInfoType; param: Int32)>('glTextureParameteri');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: DepthStencilMode) := TextureParameteri(texture, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: TextureCompareMode) := TextureParameteri(texture, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: ActivationFunc) := TextureParameteri(texture, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: PixelFilterMode) := TextureParameteri(texture, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: SwizzleMode) := TextureParameteri(texture, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: PixelWrapMode) := TextureParameteri(texture, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: Int32) := z_TextureParameteri(texture, pname, param);
    
    public z_TextureParameterfv := GetGLFuncOrNil&<procedure(texture: TextureName; pname: TextureInfoType; param: pointer)>('glTextureParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: TextureName; pname: TextureInfoType; var param: single) := TextureParameterfv(texture, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfv(texture: TextureName; pname: TextureInfoType; param: pointer) := z_TextureParameterfv(texture, pname, param);
    
    public z_TextureParameterf := GetGLFuncOrNil&<procedure(texture: TextureName; pname: TextureInfoType; param: single)>('glTextureParameterf');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterf(texture: TextureName; pname: TextureInfoType; param: single) := z_TextureParameterf(texture, pname, param);
    
    private static procedure _TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer); external 'opengl32.dll' name 'glTexParameteriv';
    public static z_TexParameteriv := _TexParameteriv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32) := TexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode) := TexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode) := TexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc) := TexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelFilterMode) := TexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode) := TexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode) := TexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer) := z_TexParameteriv(target, pname, &params);
    
    public z_TexParameterIuiv := GetGLFuncOrNil&<procedure(target: TextureBindTarget; pname: TextureInfoType; &params: pointer)>('glTexParameterIuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: UInt32) := TexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode) := TexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode) := TexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc) := TexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelFilterMode) := TexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode) := TexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode) := TexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer) := z_TexParameterIuiv(target, pname, &params);
    
    public z_TexParameterIiv := GetGLFuncOrNil&<procedure(target: TextureBindTarget; pname: TextureInfoType; &params: pointer)>('glTexParameterIiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32) := TexParameterIiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer) := z_TexParameterIiv(target, pname, &params);
    
    private static procedure _TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: Int32); external 'opengl32.dll' name 'glTexParameteri';
    public static z_TexParameteri := _TexParameteri;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: DepthStencilMode) := TexParameteri(target, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: TextureCompareMode) := TexParameteri(target, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: ActivationFunc) := TexParameteri(target, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: PixelFilterMode) := TexParameteri(target, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: SwizzleMode) := TexParameteri(target, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: PixelWrapMode) := TexParameteri(target, pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: Int32) := z_TexParameteri(target, pname, param);
    
    private static procedure _TexParameterfv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer); external 'opengl32.dll' name 'glTexParameterfv';
    public static z_TexParameterfv := _TexParameterfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterfv(target: TextureBindTarget; pname: TextureInfoType; var &params: single) := TexParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterfv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer) := z_TexParameterfv(target, pname, &params);
    
    private static procedure _TexParameterf(target: TextureBindTarget; pname: TextureInfoType; param: single); external 'opengl32.dll' name 'glTexParameterf';
    public static z_TexParameterf := _TexParameterf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterf(target: TextureBindTarget; pname: TextureInfoType; param: single) := z_TexParameterf(target, pname, param);
    
    {$endregion 8.10 - Texture Parameters}
    
    {$region 8.11 - Texture Queries}
    
    {$region 8.11.2 - Texture Parameter Queries}
    
    public z_GetTextureParameteriv := GetGLFuncOrNil&<procedure(texture: TextureName; pname: TextureInfoType; &params: pointer)>('glGetTextureParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: Int32) := GetTextureParameteriv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: DepthStencilMode) := GetTextureParameteriv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: TextureCompareMode) := GetTextureParameteriv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: ActivationFunc) := GetTextureParameteriv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: PixelFilterMode) := GetTextureParameteriv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: SwizzleMode) := GetTextureParameteriv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: PixelWrapMode) := GetTextureParameteriv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; &params: pointer) := z_GetTextureParameteriv(texture, pname, &params);
    
    public z_GetTextureParameterIuiv := GetGLFuncOrNil&<procedure(texture: TextureName; pname: TextureInfoType; &params: pointer)>('glGetTextureParameterIuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: UInt32) := GetTextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: DepthStencilMode) := GetTextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: TextureCompareMode) := GetTextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: ActivationFunc) := GetTextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelFilterMode) := GetTextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: SwizzleMode) := GetTextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelWrapMode) := GetTextureParameterIuiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; &params: pointer) := z_GetTextureParameterIuiv(texture, pname, &params);
    
    public z_GetTextureParameterIiv := GetGLFuncOrNil&<procedure(texture: TextureName; pname: TextureInfoType; &params: pointer)>('glGetTextureParameterIiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIiv(texture: TextureName; pname: TextureInfoType; var &params: Int32) := GetTextureParameterIiv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIiv(texture: TextureName; pname: TextureInfoType; &params: pointer) := z_GetTextureParameterIiv(texture, pname, &params);
    
    public z_GetTextureParameterfv := GetGLFuncOrNil&<procedure(texture: TextureName; pname: TextureInfoType; &params: pointer)>('glGetTextureParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfv(texture: TextureName; pname: TextureInfoType; var &params: single) := GetTextureParameterfv(texture, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfv(texture: TextureName; pname: TextureInfoType; &params: pointer) := z_GetTextureParameterfv(texture, pname, &params);
    
    private static procedure _GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer); external 'opengl32.dll' name 'glGetTexParameteriv';
    public static z_GetTexParameteriv := _GetTexParameteriv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32) := GetTexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode) := GetTexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode) := GetTexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc) := GetTexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelFilterMode) := GetTexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode) := GetTexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode) := GetTexParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer) := z_GetTexParameteriv(target, pname, &params);
    
    public z_GetTexParameterIuiv := GetGLFuncOrNil&<procedure(target: TextureBindTarget; pname: TextureInfoType; &params: pointer)>('glGetTexParameterIuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: UInt32) := GetTexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode) := GetTexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode) := GetTexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc) := GetTexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelFilterMode) := GetTexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode) := GetTexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode) := GetTexParameterIuiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer) := z_GetTexParameterIuiv(target, pname, &params);
    
    public z_GetTexParameterIiv := GetGLFuncOrNil&<procedure(target: TextureBindTarget; pname: TextureInfoType; &params: pointer)>('glGetTexParameterIiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32) := GetTexParameterIiv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer) := z_GetTexParameterIiv(target, pname, &params);
    
    private static procedure _GetTexParameterfv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer); external 'opengl32.dll' name 'glGetTexParameterfv';
    public static z_GetTexParameterfv := _GetTexParameterfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterfv(target: TextureBindTarget; pname: TextureInfoType; var &params: single) := GetTexParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterfv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer) := z_GetTexParameterfv(target, pname, &params);
    
    {$endregion 8.11.2 - Texture Parameter Queries}
    
    {$region 8.11.3 - Texture Level Parameter Queries}
    
    public z_GetTextureLevelParameteriv := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; pname: TextureInfoType; &params: pointer)>('glGetTextureLevelParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: Int32) := GetTextureLevelParameteriv(texture, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: DataType) := GetTextureLevelParameteriv(texture, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: boolean) := GetTextureLevelParameteriv(texture, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: InternalDataFormat) := GetTextureLevelParameteriv(texture, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; &params: pointer) := z_GetTextureLevelParameteriv(texture, level, pname, &params);
    
    public z_GetTextureLevelParameterfv := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; pname: TextureInfoType; &params: pointer)>('glGetTextureLevelParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: single) := GetTextureLevelParameterfv(texture, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfv(texture: TextureName; level: Int32; pname: TextureInfoType; &params: pointer) := z_GetTextureLevelParameterfv(texture, level, pname, &params);
    
    private static procedure _GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; &params: pointer); external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    public static z_GetTexLevelParameteriv := _GetTexLevelParameteriv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: Int32) := GetTexLevelParameteriv(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: DataType) := GetTexLevelParameteriv(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: boolean) := GetTexLevelParameteriv(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: InternalDataFormat) := GetTexLevelParameteriv(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; &params: pointer) := GetTexLevelParameteriv(target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: Int32) := GetTexLevelParameteriv(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: DataType) := GetTexLevelParameteriv(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: boolean) := GetTexLevelParameteriv(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: InternalDataFormat) := GetTexLevelParameteriv(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; &params: pointer) := z_GetTexLevelParameteriv(target, level, pname, &params);
    
    private static procedure _GetTexLevelParameterfv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; &params: pointer); external 'opengl32.dll' name 'glGetTexLevelParameterfv';
    public static z_GetTexLevelParameterfv := _GetTexLevelParameterfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterfv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: single) := GetTexLevelParameterfv(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterfv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; &params: pointer) := GetTexLevelParameterfv(target, level, pname, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterfv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: single) := GetTexLevelParameterfv(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterfv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; &params: pointer) := z_GetTexLevelParameterfv(target, level, pname, &params);
    
    {$endregion 8.11.3 - Texture Level Parameter Queries}
    
    {$region 8.11.4 - Texture Image Queries}
    
    public z_GetTextureSubImage := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer)>('glGetTextureSubImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureSubImage<T>(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: array of T); where T: record; begin GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, bufSize, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureSubImage<T>(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; bufSize: Int32; var pixels: T); where T: record; begin GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, bufSize, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: IntPtr) := GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, bufSize, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer) := z_GetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, bufSize, pixels);
    
    public z_GetTextureImage := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer)>('glGetTextureImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImage<T>(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: array of T); where T: record; begin GetTextureImage(texture, level, format, &type, bufSize, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImage<T>(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; var pixels: T); where T: record; begin GetTextureImage(texture, level, format, &type, bufSize, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: IntPtr) := GetTextureImage(texture, level, format, &type, bufSize, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer) := z_GetTextureImage(texture, level, format, &type, bufSize, pixels);
    
    private static procedure _GetTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; pixels: pointer); external 'opengl32.dll' name 'glGetTexImage';
    public static z_GetTexImage := _GetTexImage;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexImage<T>(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; pixels: array of T); where T: record; begin GetTexImage(target, level, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexImage<T>(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; var pixels: T); where T: record; begin GetTexImage(target, level, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; pixels: IntPtr) := GetTexImage(target, level, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; pixels: pointer) := z_GetTexImage(target, level, format, &type, pixels);
    
    public z_GetnTexImage := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer)>('glGetnTexImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnTexImage<T>(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: array of T); where T: record; begin GetnTexImage(target, level, format, &type, bufSize, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnTexImage<T>(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; var pixels: T); where T: record; begin GetnTexImage(target, level, format, &type, bufSize, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: IntPtr) := GetnTexImage(target, level, format, &type, bufSize, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer) := z_GetnTexImage(target, level, format, &type, bufSize, pixels);
    
    public z_GetnCompressedTexImage := GetGLFuncOrNil&<procedure(target: TextureBindTarget; lod: Int32; bufSize: Int32; pixels: pointer)>('glGetnCompressedTexImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnCompressedTexImage<T>(target: TextureBindTarget; lod: Int32; bufSize: Int32; pixels: array of T); where T: record; begin GetnCompressedTexImage(target, lod, bufSize, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnCompressedTexImage<T>(target: TextureBindTarget; lod: Int32; bufSize: Int32; var pixels: T); where T: record; begin GetnCompressedTexImage(target, lod, bufSize, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnCompressedTexImage(target: TextureBindTarget; lod: Int32; bufSize: Int32; pixels: IntPtr) := GetnCompressedTexImage(target, lod, bufSize, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnCompressedTexImage(target: TextureBindTarget; lod: Int32; bufSize: Int32; pixels: pointer) := z_GetnCompressedTexImage(target, lod, bufSize, pixels);
    
    public z_GetCompressedTextureSubImage := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: pointer)>('glGetCompressedTextureSubImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureSubImage<T>(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: array of T); where T: record; begin GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureSubImage<T>(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; var pixels: T); where T: record; begin GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr) := GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: pointer) := z_GetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
    
    public z_GetCompressedTextureImage := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; bufSize: Int32; pixels: pointer)>('glGetCompressedTextureImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImage<T>(texture: TextureName; level: Int32; bufSize: Int32; pixels: array of T); where T: record; begin GetCompressedTextureImage(texture, level, bufSize, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImage<T>(texture: TextureName; level: Int32; bufSize: Int32; var pixels: T); where T: record; begin GetCompressedTextureImage(texture, level, bufSize, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImage(texture: TextureName; level: Int32; bufSize: Int32; pixels: IntPtr) := GetCompressedTextureImage(texture, level, bufSize, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImage(texture: TextureName; level: Int32; bufSize: Int32; pixels: pointer) := z_GetCompressedTextureImage(texture, level, bufSize, pixels);
    
    public z_GetCompressedTexImage := GetGLFuncOrNil&<procedure(target: TextureBindTarget; level: Int32; img: pointer)>('glGetCompressedTexImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTexImage<T>(target: TextureBindTarget; level: Int32; img: array of T); where T: record; begin GetCompressedTexImage(target, level, img[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTexImage<T>(target: TextureBindTarget; level: Int32; var img: T); where T: record; begin GetCompressedTexImage(target, level, @img); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTexImage(target: TextureBindTarget; level: Int32; img: IntPtr) := GetCompressedTexImage(target, level, pointer(img));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTexImage(target: TextureBindTarget; level: Int32; img: pointer) := z_GetCompressedTexImage(target, level, img);
    
    {$endregion 8.11.4 - Texture Image Queries}
    
    {$endregion 8.11 - Texture Queries}
    
    {$region 8.14 - Texture Minification}
    
    {$region 8.14.4 - Manual Mipmap Generation}
    
    public z_GenerateTextureMipmap := GetGLFuncOrNil&<procedure(texture: TextureName)>('glGenerateTextureMipmap');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateTextureMipmap(texture: TextureName) := z_GenerateTextureMipmap(texture);
    
    public z_GenerateMipmap := GetGLFuncOrNil&<procedure(target: TextureBindTarget)>('glGenerateMipmap');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMipmap(target: TextureBindTarget) := z_GenerateMipmap(target);
    
    {$endregion 8.14.4 - Manual Mipmap Generation}
    
    {$endregion 8.14 - Texture Minification}
    
    {$region 8.18 - Texture Views}
    
    public z_TextureView := GetGLFuncOrNil&<procedure(texture: TextureName; target: TextureBindTarget; origtexture: TextureName; internalformat: InternalDataFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32)>('glTextureView');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureView(texture: TextureName; target: TextureBindTarget; origtexture: TextureName; internalformat: InternalDataFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32) := z_TextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    
    {$endregion 8.18 - Texture Views}
    
    {$region 8.19 - Immutable-Format Texture Images}
    
    public z_TextureStorage3DMultisample := GetGLFuncOrNil&<procedure(texture: TextureName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>('glTextureStorage3DMultisample');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DMultisample(texture: TextureName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) := z_TextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    public z_TextureStorage3D := GetGLFuncOrNil&<procedure(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32)>('glTextureStorage3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3D(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32) := z_TextureStorage3D(texture, levels, internalformat, width, height, depth);
    
    public z_TextureStorage2DMultisample := GetGLFuncOrNil&<procedure(texture: TextureName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean)>('glTextureStorage2DMultisample');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DMultisample(texture: TextureName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean) := z_TextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations);
    
    public z_TextureStorage2D := GetGLFuncOrNil&<procedure(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32)>('glTextureStorage2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2D(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32) := z_TextureStorage2D(texture, levels, internalformat, width, height);
    
    public z_TextureStorage1D := GetGLFuncOrNil&<procedure(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32)>('glTextureStorage1D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage1D(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32) := z_TextureStorage1D(texture, levels, internalformat, width);
    
    public z_TexStorage3DMultisample := GetGLFuncOrNil&<procedure(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>('glTexStorage3DMultisample');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) := z_TexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    public z_TexStorage3D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32)>('glTexStorage3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3D(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32) := z_TexStorage3D(target, levels, internalformat, width, height, depth);
    
    public z_TexStorage2DMultisample := GetGLFuncOrNil&<procedure(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean)>('glTexStorage2DMultisample');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean) := z_TexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
    
    public z_TexStorage2D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32)>('glTexStorage2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2D(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32) := z_TexStorage2D(target, levels, internalformat, width, height);
    
    public z_TexStorage1D := GetGLFuncOrNil&<procedure(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32)>('glTexStorage1D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage1D(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32) := z_TexStorage1D(target, levels, internalformat, width);
    
    {$endregion 8.19 - Immutable-Format Texture Images}
    
    {$region 8.20 - Invalidating Texture Image Data}
    
    public z_InvalidateTexSubImage := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32)>('glInvalidateTexSubImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateTexSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32) := z_InvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
    
    public z_InvalidateTexImage := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32)>('glInvalidateTexImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateTexImage(texture: TextureName; level: Int32) := z_InvalidateTexImage(texture, level);
    
    {$endregion 8.20 - Invalidating Texture Image Data}
    
    {$region 8.21 - Clearing Texture Image Data}
    
    public z_ClearTexSubImage := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; data: pointer)>('glClearTexSubImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexSubImage<T>(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; data: array of T); where T: record; begin ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexSubImage<T>(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; var data: T); where T: record; begin ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; data: IntPtr) := ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; data: pointer) := z_ClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, data);
    
    public z_ClearTexImage := GetGLFuncOrNil&<procedure(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; data: pointer)>('glClearTexImage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexImage<T>(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; data: array of T); where T: record; begin ClearTexImage(texture, level, format, &type, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexImage<T>(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; var data: T); where T: record; begin ClearTexImage(texture, level, format, &type, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; data: IntPtr) := ClearTexImage(texture, level, format, &type, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; data: pointer) := z_ClearTexImage(texture, level, format, &type, data);
    
    {$endregion 8.21 - Clearing Texture Image Data}
    
    {$region 8.26 - Texture Image Loads and Stores}
    
    public z_BindImageTextures := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; textures: pointer)>('glBindImageTextures');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; textures: array of TextureName) := BindImageTextures(first, count, textures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; var textures: TextureName) := BindImageTextures(first, count, @textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextures(first: UInt32; count: Int32; textures: pointer) := z_BindImageTextures(first, count, textures);
    
    public z_BindImageTexture := GetGLFuncOrNil&<procedure(&unit: TextureUnitId; texture: TextureName; level: Int32; layered: boolean; layer: Int32; access: AccessType; format: DataFormat)>('glBindImageTexture');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTexture(&unit: TextureUnitId; texture: TextureName; level: Int32; layered: boolean; layer: Int32; access: AccessType; format: DataFormat) := z_BindImageTexture(&unit, texture, level, layered, layer, access, format);
    
    {$endregion 8.26 - Texture Image Loads and Stores}
    
    {$endregion 8 - Textures and Samplers}
    
    {$region 9 - Framebuffers and Framebuffer Objects}
    
    {$region 9.2 - Binding and Managing Framebuffer Objects}
    
    public z_IsFramebuffer := GetGLFuncOrNil&<function(framebuffer: FramebufferName): boolean>('glIsFramebuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFramebuffer(framebuffer: FramebufferName): boolean := z_IsFramebuffer(framebuffer);
    
    public z_GenFramebuffers := GetGLFuncOrNil&<procedure(n: Int32; framebuffers: pointer)>('glGenFramebuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; framebuffers: array of FramebufferName) := GenFramebuffers(n, framebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; var framebuffers: FramebufferName) := GenFramebuffers(n, @framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffers(n: Int32; framebuffers: pointer) := z_GenFramebuffers(n, framebuffers);
    
    public z_DeleteFramebuffers := GetGLFuncOrNil&<procedure(n: Int32; framebuffers: pointer)>('glDeleteFramebuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; framebuffers: array of FramebufferName) := DeleteFramebuffers(n, framebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; var framebuffers: FramebufferName) := DeleteFramebuffers(n, @framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffers(n: Int32; framebuffers: pointer) := z_DeleteFramebuffers(n, framebuffers);
    
    public z_CreateFramebuffers := GetGLFuncOrNil&<procedure(n: Int32; framebuffers: pointer)>('glCreateFramebuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; framebuffers: array of FramebufferName) := CreateFramebuffers(n, framebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; var framebuffers: FramebufferName) := CreateFramebuffers(n, @framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateFramebuffers(n: Int32; framebuffers: pointer) := z_CreateFramebuffers(n, framebuffers);
    
    public z_BindFramebuffer := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; framebuffer: FramebufferName)>('glBindFramebuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFramebuffer(target: FramebufferBindTarget; framebuffer: FramebufferName) := z_BindFramebuffer(target, framebuffer);
    
    {$region 9.2.1 - Framebuffer Object Parameters}
    
    public z_NamedFramebufferParameteri := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; pname: FramebufferInfoType; param: Int32)>('glNamedFramebufferParameteri');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferParameteri(framebuffer: FramebufferName; pname: FramebufferInfoType; param: Int32) := z_NamedFramebufferParameteri(framebuffer, pname, param);
    
    public z_FramebufferParameteri := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; pname: FramebufferInfoType; param: Int32)>('glFramebufferParameteri');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferParameteri(target: FramebufferBindTarget; pname: FramebufferInfoType; param: Int32) := z_FramebufferParameteri(target, pname, param);
    
    {$endregion 9.2.1 - Framebuffer Object Parameters}
    
    {$region 9.2.3 - Framebuffer Object Queries}
    
    public z_GetNamedFramebufferParameteriv := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; pname: FramebufferInfoType; param: pointer)>('glGetNamedFramebufferParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: FramebufferName; pname: FramebufferInfoType; var param: Int32) := GetNamedFramebufferParameteriv(framebuffer, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: FramebufferName; pname: FramebufferInfoType; var param: boolean) := GetNamedFramebufferParameteriv(framebuffer, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameteriv(framebuffer: FramebufferName; pname: FramebufferInfoType; param: pointer) := z_GetNamedFramebufferParameteriv(framebuffer, pname, param);
    
    public z_GetNamedFramebufferAttachmentParameteriv := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; &params: pointer)>('glGetNamedFramebufferAttachmentParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: Int32) := GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: FramebufferAttachmentObjectType) := GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: UInt32) := GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: DataType) := GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: ColorEncodingMode) := GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; &params: pointer) := z_GetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, &params);
    
    public z_GetFramebufferParameteriv := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; pname: FramebufferInfoType; &params: pointer)>('glGetFramebufferParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: FramebufferBindTarget; pname: FramebufferInfoType; var &params: Int32) := GetFramebufferParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: FramebufferBindTarget; pname: FramebufferInfoType; var &params: boolean) := GetFramebufferParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameteriv(target: FramebufferBindTarget; pname: FramebufferInfoType; &params: pointer) := z_GetFramebufferParameteriv(target, pname, &params);
    
    public z_GetFramebufferAttachmentParameteriv := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; &params: pointer)>('glGetFramebufferAttachmentParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: Int32) := GetFramebufferAttachmentParameteriv(target, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: FramebufferAttachmentObjectType) := GetFramebufferAttachmentParameteriv(target, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: UInt32) := GetFramebufferAttachmentParameteriv(target, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: DataType) := GetFramebufferAttachmentParameteriv(target, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: ColorEncodingMode) := GetFramebufferAttachmentParameteriv(target, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; &params: pointer) := z_GetFramebufferAttachmentParameteriv(target, attachment, pname, &params);
    
    {$endregion 9.2.3 - Framebuffer Object Queries}
    
    {$region 9.2.4 - Renderbuffer Objects}
    
    public z_RenderbufferStorageMultisample := GetGLFuncOrNil&<procedure(target: RenderbufferBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32)>('glRenderbufferStorageMultisample');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisample(target: RenderbufferBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32) := z_RenderbufferStorageMultisample(target, samples, internalformat, width, height);
    
    public z_RenderbufferStorage := GetGLFuncOrNil&<procedure(target: RenderbufferBindTarget; internalformat: InternalDataFormat; width: Int32; height: Int32)>('glRenderbufferStorage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorage(target: RenderbufferBindTarget; internalformat: InternalDataFormat; width: Int32; height: Int32) := z_RenderbufferStorage(target, internalformat, width, height);
    
    public z_NamedRenderbufferStorageMultisample := GetGLFuncOrNil&<procedure(renderbuffer: RenderbufferName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32)>('glNamedRenderbufferStorageMultisample');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisample(renderbuffer: RenderbufferName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32) := z_NamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height);
    
    public z_NamedRenderbufferStorage := GetGLFuncOrNil&<procedure(renderbuffer: RenderbufferName; internalformat: InternalDataFormat; width: Int32; height: Int32)>('glNamedRenderbufferStorage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorage(renderbuffer: RenderbufferName; internalformat: InternalDataFormat; width: Int32; height: Int32) := z_NamedRenderbufferStorage(renderbuffer, internalformat, width, height);
    
    public z_IsRenderbuffer := GetGLFuncOrNil&<function(renderbuffer: RenderbufferName): boolean>('glIsRenderbuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsRenderbuffer(renderbuffer: RenderbufferName): boolean := z_IsRenderbuffer(renderbuffer);
    
    public z_GenRenderbuffers := GetGLFuncOrNil&<procedure(n: Int32; renderbuffers: pointer)>('glGenRenderbuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; renderbuffers: array of RenderbufferName) := GenRenderbuffers(n, renderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; var renderbuffers: RenderbufferName) := GenRenderbuffers(n, @renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffers(n: Int32; renderbuffers: pointer) := z_GenRenderbuffers(n, renderbuffers);
    
    public z_DeleteRenderbuffers := GetGLFuncOrNil&<procedure(n: Int32; renderbuffers: pointer)>('glDeleteRenderbuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; renderbuffers: array of RenderbufferName) := DeleteRenderbuffers(n, renderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; var renderbuffers: RenderbufferName) := DeleteRenderbuffers(n, @renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffers(n: Int32; renderbuffers: pointer) := z_DeleteRenderbuffers(n, renderbuffers);
    
    public z_CreateRenderbuffers := GetGLFuncOrNil&<procedure(n: Int32; renderbuffers: pointer)>('glCreateRenderbuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; renderbuffers: array of RenderbufferName) := CreateRenderbuffers(n, renderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; var renderbuffers: RenderbufferName) := CreateRenderbuffers(n, @renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateRenderbuffers(n: Int32; renderbuffers: pointer) := z_CreateRenderbuffers(n, renderbuffers);
    
    public z_BindRenderbuffer := GetGLFuncOrNil&<procedure(target: RenderbufferBindTarget; renderbuffer: RenderbufferName)>('glBindRenderbuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindRenderbuffer(target: RenderbufferBindTarget; renderbuffer: RenderbufferName) := z_BindRenderbuffer(target, renderbuffer);
    
    {$endregion 9.2.4 - Renderbuffer Objects}
    
    {$region 9.2.6 - Renderbuffer Object Queries}
    
    public z_GetRenderbufferParameteriv := GetGLFuncOrNil&<procedure(target: RenderbufferBindTarget; pname: RenderbufferInfoType; &params: pointer)>('glGetRenderbufferParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: RenderbufferBindTarget; pname: RenderbufferInfoType; var &params: Int32) := GetRenderbufferParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: RenderbufferBindTarget; pname: RenderbufferInfoType; var &params: InternalDataFormat) := GetRenderbufferParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameteriv(target: RenderbufferBindTarget; pname: RenderbufferInfoType; &params: pointer) := z_GetRenderbufferParameteriv(target, pname, &params);
    
    public z_GetNamedRenderbufferParameteriv := GetGLFuncOrNil&<procedure(renderbuffer: RenderbufferName; pname: RenderbufferInfoType; &params: pointer)>('glGetNamedRenderbufferParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: RenderbufferName; pname: RenderbufferInfoType; var &params: Int32) := GetNamedRenderbufferParameteriv(renderbuffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: RenderbufferName; pname: RenderbufferInfoType; var &params: InternalDataFormat) := GetNamedRenderbufferParameteriv(renderbuffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameteriv(renderbuffer: RenderbufferName; pname: RenderbufferInfoType; &params: pointer) := z_GetNamedRenderbufferParameteriv(renderbuffer, pname, &params);
    
    {$endregion 9.2.6 - Renderbuffer Object Queries}
    
    {$region 9.2.7 - Attaching Renderbuffer Images to a Framebuffer}
    
    public z_NamedFramebufferRenderbuffer := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; renderbuffertarget: RenderbufferBindTarget; renderbuffer: RenderbufferName)>('glNamedFramebufferRenderbuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferRenderbuffer(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; renderbuffertarget: RenderbufferBindTarget; renderbuffer: RenderbufferName) := z_NamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
    
    public z_FramebufferRenderbuffer := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; renderbuffertarget: RenderbufferBindTarget; renderbuffer: RenderbufferName)>('glFramebufferRenderbuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferRenderbuffer(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; renderbuffertarget: RenderbufferBindTarget; renderbuffer: RenderbufferName) := z_FramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
    
    {$endregion 9.2.7 - Attaching Renderbuffer Images to a Framebuffer}
    
    {$region 9.2.8 - Attaching Texture Images to a Framebuffer}
    
    public z_NamedFramebufferTextureLayer := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32; layer: Int32)>('glNamedFramebufferTextureLayer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureLayer(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32; layer: Int32) := z_NamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
    
    public z_NamedFramebufferTexture := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32)>('glNamedFramebufferTexture');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32) := z_NamedFramebufferTexture(framebuffer, attachment, texture, level);
    
    public z_FramebufferTextureLayer := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32; layer: Int32)>('glFramebufferTextureLayer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayer(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32; layer: Int32) := z_FramebufferTextureLayer(target, attachment, texture, level, layer);
    
    public z_FramebufferTexture3D := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32; zoffset: Int32)>('glFramebufferTexture3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture3D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureBindTarget; texture: TextureName; level: Int32; zoffset: Int32) := FramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture3D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32; zoffset: Int32) := z_FramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
    
    public z_FramebufferTexture2D := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32)>('glFramebufferTexture2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureBindTarget; texture: TextureName; level: Int32) := FramebufferTexture2D(target, attachment, textarget, texture, level);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32) := z_FramebufferTexture2D(target, attachment, textarget, texture, level);
    
    public z_FramebufferTexture1D := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32)>('glFramebufferTexture1D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture1D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureBindTarget; texture: TextureName; level: Int32) := FramebufferTexture1D(target, attachment, textarget, texture, level);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture1D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32) := z_FramebufferTexture1D(target, attachment, textarget, texture, level);
    
    public z_FramebufferTexture := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32)>('glFramebufferTexture');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32) := z_FramebufferTexture(target, attachment, texture, level);
    
    {$endregion 9.2.8 - Attaching Texture Images to a Framebuffer}
    
    {$endregion 9.2 - Binding and Managing Framebuffer Objects}
    
    {$region 9.3 - Feedback Loops Between Textures and the Framebuffer}
    
    {$region 9.3.1 - Rendering Feedback Loops}
    
    public z_TextureBarrier := GetGLFuncOrNil&<procedure>('glTextureBarrier');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBarrier := z_TextureBarrier;
    
    {$endregion 9.3.1 - Rendering Feedback Loops}
    
    {$endregion 9.3 - Feedback Loops Between Textures and the Framebuffer}
    
    {$region 9.4 - Framebuffer Completeness}
    
    {$region 9.4.2 - Whole Framebuffer Completeness}
    
    public z_CheckNamedFramebufferStatus := GetGLFuncOrNil&<function(framebuffer: FramebufferName; target: FramebufferBindTarget): ErrorCode>('glCheckNamedFramebufferStatus');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckNamedFramebufferStatus(framebuffer: FramebufferName; target: FramebufferBindTarget): ErrorCode := z_CheckNamedFramebufferStatus(framebuffer, target);
    
    public z_CheckFramebufferStatus := GetGLFuncOrNil&<function(target: FramebufferBindTarget): ErrorCode>('glCheckFramebufferStatus');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckFramebufferStatus(target: FramebufferBindTarget): ErrorCode := z_CheckFramebufferStatus(target);
    
    {$endregion 9.4.2 - Whole Framebuffer Completeness}
    
    {$endregion 9.4 - Framebuffer Completeness}
    
    {$endregion 9 - Framebuffers and Framebuffer Objects}
    
    {$region 10 - Vertex Specification and Drawing Commands}
    
    {$region 10.1 - Primitive Types}
    
    {$region 10.1.15 - Separate Patches}
    
    public z_PatchParameteri := GetGLFuncOrNil&<procedure(pname: PatchMode; value: Int32)>('glPatchParameteri');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameteri(pname: PatchMode; value: Int32) := z_PatchParameteri(pname, value);
    
    {$endregion 10.1.15 - Separate Patches}
    
    {$endregion 10.1 - Primitive Types}
    
    {$region 10.2 - Current Vertex Attribute Values}
    
    {$region 10.2.1 - Current Generic Attributes}
    
    public z_VertexAttribP4uiv := GetGLFuncOrNil&<procedure(index: UInt32; &type: DataType; normalized: boolean; value: pointer)>('glVertexAttribP4uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32) := VertexAttribP4uiv(index, &type, normalized, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer) := z_VertexAttribP4uiv(index, &type, normalized, value);
    
    public z_VertexAttribP4ui := GetGLFuncOrNil&<procedure(index: UInt32; &type: DataType; normalized: boolean; value: UInt32)>('glVertexAttribP4ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP4ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32) := z_VertexAttribP4ui(index, &type, normalized, value);
    
    public z_VertexAttribP3uiv := GetGLFuncOrNil&<procedure(index: UInt32; &type: DataType; normalized: boolean; value: pointer)>('glVertexAttribP3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32) := VertexAttribP3uiv(index, &type, normalized, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer) := z_VertexAttribP3uiv(index, &type, normalized, value);
    
    public z_VertexAttribP3ui := GetGLFuncOrNil&<procedure(index: UInt32; &type: DataType; normalized: boolean; value: UInt32)>('glVertexAttribP3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP3ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32) := z_VertexAttribP3ui(index, &type, normalized, value);
    
    public z_VertexAttribP2uiv := GetGLFuncOrNil&<procedure(index: UInt32; &type: DataType; normalized: boolean; value: pointer)>('glVertexAttribP2uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32) := VertexAttribP2uiv(index, &type, normalized, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer) := z_VertexAttribP2uiv(index, &type, normalized, value);
    
    public z_VertexAttribP2ui := GetGLFuncOrNil&<procedure(index: UInt32; &type: DataType; normalized: boolean; value: UInt32)>('glVertexAttribP2ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP2ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32) := z_VertexAttribP2ui(index, &type, normalized, value);
    
    public z_VertexAttribP1uiv := GetGLFuncOrNil&<procedure(index: UInt32; &type: DataType; normalized: boolean; value: pointer)>('glVertexAttribP1uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32) := VertexAttribP1uiv(index, &type, normalized, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer) := z_VertexAttribP1uiv(index, &type, normalized, value);
    
    public z_VertexAttribP1ui := GetGLFuncOrNil&<procedure(index: UInt32; &type: DataType; normalized: boolean; value: UInt32)>('glVertexAttribP1ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribP1ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32) := z_VertexAttribP1ui(index, &type, normalized, value);
    
    public z_VertexAttribL4dv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; v: array of double) := VertexAttribL4dv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; var v: double) := VertexAttribL4dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; var v: Vec4d) := VertexAttribL4dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dv(index: UInt32; v: pointer) := z_VertexAttribL4dv(index, v);
    
    public z_VertexAttribL4d := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>('glVertexAttribL4d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4d(index: UInt32; x: double; y: double; z: double; w: double) := z_VertexAttribL4d(index, x, y, z, w);
    
    public z_VertexAttribL3dv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; v: array of double) := VertexAttribL3dv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; var v: double) := VertexAttribL3dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; var v: Vec3d) := VertexAttribL3dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dv(index: UInt32; v: pointer) := z_VertexAttribL3dv(index, v);
    
    public z_VertexAttribL3d := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>('glVertexAttribL3d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3d(index: UInt32; x: double; y: double; z: double) := z_VertexAttribL3d(index, x, y, z);
    
    public z_VertexAttribL2dv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; v: array of double) := VertexAttribL2dv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; var v: double) := VertexAttribL2dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; var v: Vec2d) := VertexAttribL2dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dv(index: UInt32; v: pointer) := z_VertexAttribL2dv(index, v);
    
    public z_VertexAttribL2d := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double)>('glVertexAttribL2d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2d(index: UInt32; x: double; y: double) := z_VertexAttribL2d(index, x, y);
    
    public z_VertexAttribL1dv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL1dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; v: array of double) := VertexAttribL1dv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; var v: double) := VertexAttribL1dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; var v: Vec1d) := VertexAttribL1dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dv(index: UInt32; v: pointer) := z_VertexAttribL1dv(index, v);
    
    public z_VertexAttribL1d := GetGLFuncOrNil&<procedure(index: UInt32; x: double)>('glVertexAttribL1d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1d(index: UInt32; x: double) := z_VertexAttribL1d(index, x);
    
    public z_VertexAttribI4usv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4usv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; v: array of UInt16) := VertexAttribI4usv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; var v: UInt16) := VertexAttribI4usv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; var v: Vec4us) := VertexAttribI4usv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usv(index: UInt32; v: pointer) := z_VertexAttribI4usv(index, v);
    
    public z_VertexAttribI4uiv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; v: array of UInt32) := VertexAttribI4uiv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; var v: UInt32) := VertexAttribI4uiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; var v: Vec4ui) := VertexAttribI4uiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiv(index: UInt32; v: pointer) := z_VertexAttribI4uiv(index, v);
    
    public z_VertexAttribI4ui := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>('glVertexAttribI4ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ui(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := z_VertexAttribI4ui(index, x, y, z, w);
    
    public z_VertexAttribI4ubv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4ubv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; v: array of Byte) := VertexAttribI4ubv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; var v: Byte) := VertexAttribI4ubv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; var v: Vec4ub) := VertexAttribI4ubv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubv(index: UInt32; v: pointer) := z_VertexAttribI4ubv(index, v);
    
    public z_VertexAttribI4sv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; v: array of Int16) := VertexAttribI4sv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; var v: Int16) := VertexAttribI4sv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; var v: Vec4s) := VertexAttribI4sv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4sv(index: UInt32; v: pointer) := z_VertexAttribI4sv(index, v);
    
    public z_VertexAttribI4iv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; v: array of Int32) := VertexAttribI4iv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; var v: Int32) := VertexAttribI4iv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; var v: Vec4i) := VertexAttribI4iv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iv(index: UInt32; v: pointer) := z_VertexAttribI4iv(index, v);
    
    public z_VertexAttribI4i := GetGLFuncOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>('glVertexAttribI4i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4i(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := z_VertexAttribI4i(index, x, y, z, w);
    
    public z_VertexAttribI4bv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4bv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; v: array of SByte) := VertexAttribI4bv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; var v: SByte) := VertexAttribI4bv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; var v: Vec4b) := VertexAttribI4bv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bv(index: UInt32; v: pointer) := z_VertexAttribI4bv(index, v);
    
    public z_VertexAttribI3uiv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; v: array of UInt32) := VertexAttribI3uiv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; var v: UInt32) := VertexAttribI3uiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; var v: Vec3ui) := VertexAttribI3uiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiv(index: UInt32; v: pointer) := z_VertexAttribI3uiv(index, v);
    
    public z_VertexAttribI3ui := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32)>('glVertexAttribI3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ui(index: UInt32; x: UInt32; y: UInt32; z: UInt32) := z_VertexAttribI3ui(index, x, y, z);
    
    public z_VertexAttribI3iv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI3iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; v: array of Int32) := VertexAttribI3iv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; var v: Int32) := VertexAttribI3iv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; var v: Vec3i) := VertexAttribI3iv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iv(index: UInt32; v: pointer) := z_VertexAttribI3iv(index, v);
    
    public z_VertexAttribI3i := GetGLFuncOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32)>('glVertexAttribI3i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3i(index: UInt32; x: Int32; y: Int32; z: Int32) := z_VertexAttribI3i(index, x, y, z);
    
    public z_VertexAttribI2uiv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI2uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; v: array of UInt32) := VertexAttribI2uiv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; var v: UInt32) := VertexAttribI2uiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; var v: Vec2ui) := VertexAttribI2uiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiv(index: UInt32; v: pointer) := z_VertexAttribI2uiv(index, v);
    
    public z_VertexAttribI2ui := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32)>('glVertexAttribI2ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ui(index: UInt32; x: UInt32; y: UInt32) := z_VertexAttribI2ui(index, x, y);
    
    public z_VertexAttribI2iv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI2iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; v: array of Int32) := VertexAttribI2iv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; var v: Int32) := VertexAttribI2iv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; var v: Vec2i) := VertexAttribI2iv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iv(index: UInt32; v: pointer) := z_VertexAttribI2iv(index, v);
    
    public z_VertexAttribI2i := GetGLFuncOrNil&<procedure(index: UInt32; x: Int32; y: Int32)>('glVertexAttribI2i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2i(index: UInt32; x: Int32; y: Int32) := z_VertexAttribI2i(index, x, y);
    
    public z_VertexAttribI1uiv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI1uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiv(index: UInt32; v: array of UInt32) := VertexAttribI1uiv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiv(index: UInt32; var v: UInt32) := VertexAttribI1uiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiv(index: UInt32; var v: Vec1ui) := VertexAttribI1uiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiv(index: UInt32; v: pointer) := z_VertexAttribI1uiv(index, v);
    
    public z_VertexAttribI1ui := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt32)>('glVertexAttribI1ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ui(index: UInt32; x: UInt32) := z_VertexAttribI1ui(index, x);
    
    public z_VertexAttribI1iv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI1iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iv(index: UInt32; v: array of Int32) := VertexAttribI1iv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iv(index: UInt32; var v: Int32) := VertexAttribI1iv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iv(index: UInt32; var v: Vec1i) := VertexAttribI1iv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iv(index: UInt32; v: pointer) := z_VertexAttribI1iv(index, v);
    
    public z_VertexAttribI1i := GetGLFuncOrNil&<procedure(index: UInt32; x: Int32)>('glVertexAttribI1i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1i(index: UInt32; x: Int32) := z_VertexAttribI1i(index, x);
    
    public z_VertexAttrib4usv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4usv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; v: array of UInt16) := VertexAttrib4usv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; var v: UInt16) := VertexAttrib4usv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; var v: Vec4us) := VertexAttrib4usv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usv(index: UInt32; v: pointer) := z_VertexAttrib4usv(index, v);
    
    public z_VertexAttrib4uiv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; v: array of UInt32) := VertexAttrib4uiv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; var v: UInt32) := VertexAttrib4uiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; var v: Vec4ui) := VertexAttrib4uiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uiv(index: UInt32; v: pointer) := z_VertexAttrib4uiv(index, v);
    
    public z_VertexAttrib4ubv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4ubv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; v: array of Byte) := VertexAttrib4ubv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; var v: Byte) := VertexAttrib4ubv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; var v: Vec4ub) := VertexAttrib4ubv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubv(index: UInt32; v: pointer) := z_VertexAttrib4ubv(index, v);
    
    public z_VertexAttrib4sv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; v: array of Int16) := VertexAttrib4sv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; var v: Int16) := VertexAttrib4sv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; var v: Vec4s) := VertexAttrib4sv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sv(index: UInt32; v: pointer) := z_VertexAttrib4sv(index, v);
    
    public z_VertexAttrib4s := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>('glVertexAttrib4s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4s(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) := z_VertexAttrib4s(index, x, y, z, w);
    
    public z_VertexAttrib4Nusv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4Nusv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; v: array of UInt16) := VertexAttrib4Nusv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; var v: UInt16) := VertexAttrib4Nusv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; var v: Vec4us) := VertexAttrib4Nusv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nusv(index: UInt32; v: pointer) := z_VertexAttrib4Nusv(index, v);
    
    public z_VertexAttrib4Nuiv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4Nuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; v: array of UInt32) := VertexAttrib4Nuiv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; var v: UInt32) := VertexAttrib4Nuiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; var v: Vec4ui) := VertexAttrib4Nuiv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nuiv(index: UInt32; v: pointer) := z_VertexAttrib4Nuiv(index, v);
    
    public z_VertexAttrib4Nubv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4Nubv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; v: array of Byte) := VertexAttrib4Nubv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; var v: Byte) := VertexAttrib4Nubv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; var v: Vec4ub) := VertexAttrib4Nubv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nubv(index: UInt32; v: pointer) := z_VertexAttrib4Nubv(index, v);
    
    public z_VertexAttrib4Nub := GetGLFuncOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>('glVertexAttrib4Nub');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nub(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) := z_VertexAttrib4Nub(index, x, y, z, w);
    
    public z_VertexAttrib4Nsv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4Nsv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; v: array of Int16) := VertexAttrib4Nsv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; var v: Int16) := VertexAttrib4Nsv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; var v: Vec4s) := VertexAttrib4Nsv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nsv(index: UInt32; v: pointer) := z_VertexAttrib4Nsv(index, v);
    
    public z_VertexAttrib4Niv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4Niv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; v: array of Int32) := VertexAttrib4Niv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; var v: Int32) := VertexAttrib4Niv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; var v: Vec4i) := VertexAttrib4Niv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Niv(index: UInt32; v: pointer) := z_VertexAttrib4Niv(index, v);
    
    public z_VertexAttrib4Nbv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4Nbv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; v: array of SByte) := VertexAttrib4Nbv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; var v: SByte) := VertexAttrib4Nbv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; var v: Vec4b) := VertexAttrib4Nbv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4Nbv(index: UInt32; v: pointer) := z_VertexAttrib4Nbv(index, v);
    
    public z_VertexAttrib4iv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; v: array of Int32) := VertexAttrib4iv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; var v: Int32) := VertexAttrib4iv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; var v: Vec4i) := VertexAttrib4iv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4iv(index: UInt32; v: pointer) := z_VertexAttrib4iv(index, v);
    
    public z_VertexAttrib4fv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; v: array of single) := VertexAttrib4fv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; var v: single) := VertexAttrib4fv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; var v: Vec4f) := VertexAttrib4fv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fv(index: UInt32; v: pointer) := z_VertexAttrib4fv(index, v);
    
    public z_VertexAttrib4f := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>('glVertexAttrib4f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4f(index: UInt32; x: single; y: single; z: single; w: single) := z_VertexAttrib4f(index, x, y, z, w);
    
    public z_VertexAttrib4dv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; v: array of double) := VertexAttrib4dv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; var v: double) := VertexAttrib4dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; var v: Vec4d) := VertexAttrib4dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dv(index: UInt32; v: pointer) := z_VertexAttrib4dv(index, v);
    
    public z_VertexAttrib4d := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>('glVertexAttrib4d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4d(index: UInt32; x: double; y: double; z: double; w: double) := z_VertexAttrib4d(index, x, y, z, w);
    
    public z_VertexAttrib4bv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4bv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; v: array of SByte) := VertexAttrib4bv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; var v: SByte) := VertexAttrib4bv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; var v: Vec4b) := VertexAttrib4bv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bv(index: UInt32; v: pointer) := z_VertexAttrib4bv(index, v);
    
    public z_VertexAttrib3sv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib3sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; v: array of Int16) := VertexAttrib3sv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; var v: Int16) := VertexAttrib3sv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; var v: Vec3s) := VertexAttrib3sv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sv(index: UInt32; v: pointer) := z_VertexAttrib3sv(index, v);
    
    public z_VertexAttrib3s := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>('glVertexAttrib3s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3s(index: UInt32; x: Int16; y: Int16; z: Int16) := z_VertexAttrib3s(index, x, y, z);
    
    public z_VertexAttrib3fv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; v: array of single) := VertexAttrib3fv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; var v: single) := VertexAttrib3fv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; var v: Vec3f) := VertexAttrib3fv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fv(index: UInt32; v: pointer) := z_VertexAttrib3fv(index, v);
    
    public z_VertexAttrib3f := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>('glVertexAttrib3f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3f(index: UInt32; x: single; y: single; z: single) := z_VertexAttrib3f(index, x, y, z);
    
    public z_VertexAttrib3dv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; v: array of double) := VertexAttrib3dv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; var v: double) := VertexAttrib3dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; var v: Vec3d) := VertexAttrib3dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dv(index: UInt32; v: pointer) := z_VertexAttrib3dv(index, v);
    
    public z_VertexAttrib3d := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>('glVertexAttrib3d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3d(index: UInt32; x: double; y: double; z: double) := z_VertexAttrib3d(index, x, y, z);
    
    public z_VertexAttrib2sv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib2sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; v: array of Int16) := VertexAttrib2sv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; var v: Int16) := VertexAttrib2sv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; var v: Vec2s) := VertexAttrib2sv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sv(index: UInt32; v: pointer) := z_VertexAttrib2sv(index, v);
    
    public z_VertexAttrib2s := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>('glVertexAttrib2s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2s(index: UInt32; x: Int16; y: Int16) := z_VertexAttrib2s(index, x, y);
    
    public z_VertexAttrib2fv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; v: array of single) := VertexAttrib2fv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; var v: single) := VertexAttrib2fv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; var v: Vec2f) := VertexAttrib2fv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fv(index: UInt32; v: pointer) := z_VertexAttrib2fv(index, v);
    
    public z_VertexAttrib2f := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single)>('glVertexAttrib2f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2f(index: UInt32; x: single; y: single) := z_VertexAttrib2f(index, x, y);
    
    public z_VertexAttrib2dv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; v: array of double) := VertexAttrib2dv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; var v: double) := VertexAttrib2dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; var v: Vec2d) := VertexAttrib2dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dv(index: UInt32; v: pointer) := z_VertexAttrib2dv(index, v);
    
    public z_VertexAttrib2d := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double)>('glVertexAttrib2d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2d(index: UInt32; x: double; y: double) := z_VertexAttrib2d(index, x, y);
    
    public z_VertexAttrib1sv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib1sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sv(index: UInt32; v: array of Int16) := VertexAttrib1sv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sv(index: UInt32; var v: Int16) := VertexAttrib1sv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sv(index: UInt32; var v: Vec1s) := VertexAttrib1sv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sv(index: UInt32; v: pointer) := z_VertexAttrib1sv(index, v);
    
    public z_VertexAttrib1s := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16)>('glVertexAttrib1s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1s(index: UInt32; x: Int16) := z_VertexAttrib1s(index, x);
    
    public z_VertexAttrib1fv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib1fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fv(index: UInt32; v: array of single) := VertexAttrib1fv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fv(index: UInt32; var v: single) := VertexAttrib1fv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fv(index: UInt32; var v: Vec1f) := VertexAttrib1fv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fv(index: UInt32; v: pointer) := z_VertexAttrib1fv(index, v);
    
    public z_VertexAttrib1f := GetGLFuncOrNil&<procedure(index: UInt32; x: single)>('glVertexAttrib1f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1f(index: UInt32; x: single) := z_VertexAttrib1f(index, x);
    
    public z_VertexAttrib1dv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib1dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dv(index: UInt32; v: array of double) := VertexAttrib1dv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dv(index: UInt32; var v: double) := VertexAttrib1dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dv(index: UInt32; var v: Vec1d) := VertexAttrib1dv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dv(index: UInt32; v: pointer) := z_VertexAttrib1dv(index, v);
    
    public z_VertexAttrib1d := GetGLFuncOrNil&<procedure(index: UInt32; x: double)>('glVertexAttrib1d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1d(index: UInt32; x: double) := z_VertexAttrib1d(index, x);
    
    {$endregion 10.2.1 - Current Generic Attributes}
    
    {$endregion 10.2 - Current Vertex Attribute Values}
    
    {$region 10.3 - Vertex Arrays}
    
    {$region 10.3.1 - Vertex Array Objects}
    
    public z_VertexArrayElementBuffer := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; buffer: BufferName)>('glVertexArrayElementBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayElementBuffer(vaobj: VertexArrayName; buffer: BufferName) := z_VertexArrayElementBuffer(vaobj, buffer);
    
    public z_IsVertexArray := GetGLFuncOrNil&<function(&array: VertexArrayName): boolean>('glIsVertexArray');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexArray(&array: VertexArrayName): boolean := z_IsVertexArray(&array);
    
    public z_GenVertexArrays := GetGLFuncOrNil&<procedure(n: Int32; arrays: pointer)>('glGenVertexArrays');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; arrays: array of VertexArrayName) := GenVertexArrays(n, arrays[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; var arrays: VertexArrayName) := GenVertexArrays(n, @arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArrays(n: Int32; arrays: pointer) := z_GenVertexArrays(n, arrays);
    
    public z_DeleteVertexArrays := GetGLFuncOrNil&<procedure(n: Int32; arrays: pointer)>('glDeleteVertexArrays');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; arrays: array of VertexArrayName) := DeleteVertexArrays(n, arrays[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; var arrays: VertexArrayName) := DeleteVertexArrays(n, @arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArrays(n: Int32; arrays: pointer) := z_DeleteVertexArrays(n, arrays);
    
    public z_CreateVertexArrays := GetGLFuncOrNil&<procedure(n: Int32; arrays: pointer)>('glCreateVertexArrays');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; arrays: array of VertexArrayName) := CreateVertexArrays(n, arrays[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; var arrays: VertexArrayName) := CreateVertexArrays(n, @arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateVertexArrays(n: Int32; arrays: pointer) := z_CreateVertexArrays(n, arrays);
    
    public z_BindVertexArray := GetGLFuncOrNil&<procedure(&array: VertexArrayName)>('glBindVertexArray');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexArray(&array: VertexArrayName) := z_BindVertexArray(&array);
    
    {$endregion 10.3.1 - Vertex Array Objects}
    
    {$region 10.3.2 - Specifying Arrays for Generic Vertex Attributes}
    
    public z_VertexAttribPointer := GetGLFuncOrNil&<procedure(index: UInt32; size: Int32; &type: DataType; normalized: boolean; stride: Int32; _pointer: pointer)>('glVertexAttribPointer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointer<T>(index: UInt32; size: Int32; &type: DataType; normalized: boolean; stride: Int32; _pointer: array of T); where T: record; begin VertexAttribPointer(index, size, &type, normalized, stride, _pointer[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointer<T>(index: UInt32; size: Int32; &type: DataType; normalized: boolean; stride: Int32; var _pointer: T); where T: record; begin VertexAttribPointer(index, size, &type, normalized, stride, @_pointer); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointer(index: UInt32; size: Int32; &type: DataType; normalized: boolean; stride: Int32; _pointer: IntPtr) := VertexAttribPointer(index, size, &type, normalized, stride, pointer(_pointer));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointer(index: UInt32; size: Int32; &type: DataType; normalized: boolean; stride: Int32; _pointer: pointer) := z_VertexAttribPointer(index, size, &type, normalized, stride, _pointer);
    
    public z_VertexAttribLPointer := GetGLFuncOrNil&<procedure(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: pointer)>('glVertexAttribLPointer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointer<T>(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: array of T); where T: record; begin VertexAttribLPointer(index, size, &type, stride, _pointer[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointer<T>(index: UInt32; size: Int32; &type: DataType; stride: Int32; var _pointer: T); where T: record; begin VertexAttribLPointer(index, size, &type, stride, @_pointer); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: IntPtr) := VertexAttribLPointer(index, size, &type, stride, pointer(_pointer));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: pointer) := z_VertexAttribLPointer(index, size, &type, stride, _pointer);
    
    public z_VertexAttribLFormat := GetGLFuncOrNil&<procedure(attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32)>('glVertexAttribLFormat');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLFormat(attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32) := z_VertexAttribLFormat(attribindex, size, &type, relativeoffset);
    
    public z_VertexAttribIPointer := GetGLFuncOrNil&<procedure(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: pointer)>('glVertexAttribIPointer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointer<T>(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: array of T); where T: record; begin VertexAttribIPointer(index, size, &type, stride, _pointer[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointer<T>(index: UInt32; size: Int32; &type: DataType; stride: Int32; var _pointer: T); where T: record; begin VertexAttribIPointer(index, size, &type, stride, @_pointer); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: IntPtr) := VertexAttribIPointer(index, size, &type, stride, pointer(_pointer));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: pointer) := z_VertexAttribIPointer(index, size, &type, stride, _pointer);
    
    public z_VertexAttribIFormat := GetGLFuncOrNil&<procedure(attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32)>('glVertexAttribIFormat');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIFormat(attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32) := z_VertexAttribIFormat(attribindex, size, &type, relativeoffset);
    
    public z_VertexAttribFormat := GetGLFuncOrNil&<procedure(attribindex: UInt32; size: Int32; &type: DataType; normalized: boolean; relativeoffset: UInt32)>('glVertexAttribFormat');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribFormat(attribindex: UInt32; size: Int32; &type: DataType; normalized: boolean; relativeoffset: UInt32) := z_VertexAttribFormat(attribindex, size, &type, normalized, relativeoffset);
    
    public z_VertexAttribBinding := GetGLFuncOrNil&<procedure(attribindex: UInt32; bindingindex: UInt32)>('glVertexAttribBinding');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribBinding(attribindex: UInt32; bindingindex: UInt32) := z_VertexAttribBinding(attribindex, bindingindex);
    
    public z_VertexArrayVertexBuffers := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; first: UInt32; count: Int32; buffers: pointer; offsets: pointer; strides: pointer)>('glVertexArrayVertexBuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: VertexArrayName; first: UInt32; count: Int32; buffers: array of BufferName; offsets: array of IntPtr; strides: array of Int32) := VertexArrayVertexBuffers(vaobj, first, count, buffers[0], offsets[0], strides[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: VertexArrayName; first: UInt32; count: Int32; var buffers: BufferName; var offsets: IntPtr; var strides: Int32) := VertexArrayVertexBuffers(vaobj, first, count, @buffers, @offsets, @strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffers(vaobj: VertexArrayName; first: UInt32; count: Int32; buffers: pointer; offsets: pointer; strides: pointer) := z_VertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);
    
    public z_VertexArrayVertexBuffer := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; bindingindex: UInt32; buffer: BufferName; offset: IntPtr; stride: Int32)>('glVertexArrayVertexBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBuffer(vaobj: VertexArrayName; bindingindex: UInt32; buffer: BufferName; offset: IntPtr; stride: Int32) := z_VertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
    
    public z_VertexArrayAttribLFormat := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32)>('glVertexArrayAttribLFormat');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribLFormat(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32) := z_VertexArrayAttribLFormat(vaobj, attribindex, size, &type, relativeoffset);
    
    public z_VertexArrayAttribIFormat := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32)>('glVertexArrayAttribIFormat');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribIFormat(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32) := z_VertexArrayAttribIFormat(vaobj, attribindex, size, &type, relativeoffset);
    
    public z_VertexArrayAttribFormat := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; normalized: boolean; relativeoffset: UInt32)>('glVertexArrayAttribFormat');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribFormat(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; normalized: boolean; relativeoffset: UInt32) := z_VertexArrayAttribFormat(vaobj, attribindex, size, &type, normalized, relativeoffset);
    
    public z_VertexArrayAttribBinding := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; attribindex: UInt32; bindingindex: UInt32)>('glVertexArrayAttribBinding');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayAttribBinding(vaobj: VertexArrayName; attribindex: UInt32; bindingindex: UInt32) := z_VertexArrayAttribBinding(vaobj, attribindex, bindingindex);
    
    public z_EnableVertexAttribArray := GetGLFuncOrNil&<procedure(index: UInt32)>('glEnableVertexAttribArray');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribArray(index: UInt32) := z_EnableVertexAttribArray(index);
    
    public z_EnableVertexArrayAttrib := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; index: UInt32)>('glEnableVertexArrayAttrib');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayAttrib(vaobj: VertexArrayName; index: UInt32) := z_EnableVertexArrayAttrib(vaobj, index);
    
    public z_DisableVertexAttribArray := GetGLFuncOrNil&<procedure(index: UInt32)>('glDisableVertexAttribArray');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribArray(index: UInt32) := z_DisableVertexAttribArray(index);
    
    public z_DisableVertexArrayAttrib := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; index: UInt32)>('glDisableVertexArrayAttrib');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayAttrib(vaobj: VertexArrayName; index: UInt32) := z_DisableVertexArrayAttrib(vaobj, index);
    
    public z_BindVertexBuffers := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; buffers: pointer; offsets: pointer; strides: pointer)>('glBindVertexBuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: array of BufferName; offsets: array of IntPtr; strides: array of Int32) := BindVertexBuffers(first, count, buffers[0], offsets[0], strides[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: BufferName; var offsets: IntPtr; var strides: Int32) := BindVertexBuffers(first, count, @buffers, @offsets, @strides);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: pointer; offsets: pointer; strides: pointer) := z_BindVertexBuffers(first, count, buffers, offsets, strides);
    
    public z_BindVertexBuffer := GetGLFuncOrNil&<procedure(bindingindex: UInt32; buffer: BufferName; offset: IntPtr; stride: Int32)>('glBindVertexBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexBuffer(bindingindex: UInt32; buffer: BufferName; offset: IntPtr; stride: Int32) := z_BindVertexBuffer(bindingindex, buffer, offset, stride);
    
    {$endregion 10.3.2 - Specifying Arrays for Generic Vertex Attributes}
    
    {$region 10.3.4 - Vertex Attribute Divisors}
    
    public z_VertexBindingDivisor := GetGLFuncOrNil&<procedure(bindingindex: UInt32; divisor: UInt32)>('glVertexBindingDivisor');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBindingDivisor(bindingindex: UInt32; divisor: UInt32) := z_VertexBindingDivisor(bindingindex, divisor);
    
    public z_VertexAttribDivisor := GetGLFuncOrNil&<procedure(index: UInt32; divisor: UInt32)>('glVertexAttribDivisor');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribDivisor(index: UInt32; divisor: UInt32) := z_VertexAttribDivisor(index, divisor);
    
    public z_VertexArrayBindingDivisor := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; bindingindex: UInt32; divisor: UInt32)>('glVertexArrayBindingDivisor');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayBindingDivisor(vaobj: VertexArrayName; bindingindex: UInt32; divisor: UInt32) := z_VertexArrayBindingDivisor(vaobj, bindingindex, divisor);
    
    {$endregion 10.3.4 - Vertex Attribute Divisors}
    
    {$region 10.3.6 - Primitive Restart}
    
    public z_PrimitiveRestartIndex := GetGLFuncOrNil&<procedure(index: UInt32)>('glPrimitiveRestartIndex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveRestartIndex(index: UInt32) := z_PrimitiveRestartIndex(index);
    
    private static procedure _Enable(cap: EnablableName); external 'opengl32.dll' name 'glEnable';
    public static z_Enable := _Enable;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Enable(cap: EnablableName) := z_Enable(cap);
    
    private static procedure _Disable(cap: EnablableName); external 'opengl32.dll' name 'glDisable';
    public static z_Disable := _Disable;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Disable(cap: EnablableName) := z_Disable(cap);
    
    {$endregion 10.3.6 - Primitive Restart}
    
    {$endregion 10.3 - Vertex Arrays}
    
    {$region 10.4 - Drawing Commands Using Vertex Arrays}
    
    public z_MultiDrawElementsIndirectCount := GetGLFuncOrNil&<procedure(mode: PrimitiveType; &type: DataType; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>('glMultiDrawElementsIndirectCount');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectCount(mode: PrimitiveType; &type: DataType; var indirect: DrawArraysIndirectCommand; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) := MultiDrawElementsIndirectCount(mode, &type, @indirect, drawcount, maxdrawcount, stride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectCount(mode: PrimitiveType; &type: DataType; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) := z_MultiDrawElementsIndirectCount(mode, &type, indirect, drawcount, maxdrawcount, stride);
    
    public z_MultiDrawElementsIndirect := GetGLFuncOrNil&<procedure(mode: PrimitiveType; &type: DataType; indirect: pointer; drawcount: Int32; stride: Int32)>('glMultiDrawElementsIndirect');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirect(mode: PrimitiveType; &type: DataType; var indirect: DrawArraysIndirectCommand; drawcount: Int32; stride: Int32) := MultiDrawElementsIndirect(mode, &type, @indirect, drawcount, stride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirect(mode: PrimitiveType; &type: DataType; indirect: pointer; drawcount: Int32; stride: Int32) := z_MultiDrawElementsIndirect(mode, &type, indirect, drawcount, stride);
    
    public z_MultiDrawElementsBaseVertex := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; drawcount: Int32; basevertex: pointer)>('glMultiDrawElementsBaseVertex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertex(mode, count[0], &type, indices[0], drawcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertex(mode, count[0], &type, indices[0], drawcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertex(mode, count[0], &type, indices[0], drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; drawcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertex(mode, count[0], &type, @indices, drawcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertex(mode, count[0], &type, @indices, drawcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; drawcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertex(mode, count[0], &type, @indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; drawcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertex(mode, count[0], &type, indices, drawcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; drawcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertex(mode, count[0], &type, indices, drawcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; drawcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertex(mode, count[0], &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertex(mode, @count, &type, indices[0], drawcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertex(mode, @count, &type, indices[0], drawcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertex(mode, @count, &type, indices[0], drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; drawcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertex(mode, @count, &type, @indices, drawcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertex(mode, @count, &type, @indices, drawcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; drawcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertex(mode, @count, &type, @indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; drawcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertex(mode, @count, &type, indices, drawcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; drawcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertex(mode, @count, &type, indices, drawcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; drawcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertex(mode, @count, &type, indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertex(mode, count, &type, indices[0], drawcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertex(mode, count, &type, indices[0], drawcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertex(mode, count, &type, indices[0], drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; drawcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertex(mode, count, &type, @indices, drawcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; drawcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertex(mode, count, &type, @indices, drawcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; drawcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertex(mode, count, &type, @indices, drawcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; drawcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertex(mode, count, &type, indices, drawcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; drawcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertex(mode, count, &type, indices, drawcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertex(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; drawcount: Int32; basevertex: pointer) := z_MultiDrawElementsBaseVertex(mode, count, &type, indices, drawcount, basevertex);
    
    public z_MultiDrawElements := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; drawcount: Int32)>('glMultiDrawElements');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32) := MultiDrawElements(mode, count[0], &type, indices[0], drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; drawcount: Int32) := MultiDrawElements(mode, count[0], &type, @indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; drawcount: Int32) := MultiDrawElements(mode, count[0], &type, indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32) := MultiDrawElements(mode, @count, &type, indices[0], drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; drawcount: Int32) := MultiDrawElements(mode, @count, &type, @indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; drawcount: Int32) := MultiDrawElements(mode, @count, &type, indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; drawcount: Int32) := MultiDrawElements(mode, count, &type, indices[0], drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; drawcount: Int32) := MultiDrawElements(mode, count, &type, @indices, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElements(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; drawcount: Int32) := z_MultiDrawElements(mode, count, &type, indices, drawcount);
    
    public z_MultiDrawArraysIndirectCount := GetGLFuncOrNil&<procedure(mode: PrimitiveType; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>('glMultiDrawArraysIndirectCount');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectCount(mode: PrimitiveType; indirect: array of DrawArraysIndirectCommand; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) := MultiDrawArraysIndirectCount(mode, indirect[0], drawcount, maxdrawcount, stride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectCount(mode: PrimitiveType; var indirect: DrawArraysIndirectCommand; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) := MultiDrawArraysIndirectCount(mode, @indirect, drawcount, maxdrawcount, stride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectCount(mode: PrimitiveType; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) := z_MultiDrawArraysIndirectCount(mode, indirect, drawcount, maxdrawcount, stride);
    
    public z_MultiDrawArraysIndirect := GetGLFuncOrNil&<procedure(mode: PrimitiveType; indirect: pointer; drawcount: Int32; stride: Int32)>('glMultiDrawArraysIndirect');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirect(mode: PrimitiveType; indirect: array of DrawArraysIndirectCommand; drawcount: Int32; stride: Int32) := MultiDrawArraysIndirect(mode, indirect[0], drawcount, stride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirect(mode: PrimitiveType; var indirect: DrawArraysIndirectCommand; drawcount: Int32; stride: Int32) := MultiDrawArraysIndirect(mode, @indirect, drawcount, stride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirect(mode: PrimitiveType; indirect: pointer; drawcount: Int32; stride: Int32) := z_MultiDrawArraysIndirect(mode, indirect, drawcount, stride);
    
    public z_MultiDrawArrays := GetGLFuncOrNil&<procedure(mode: PrimitiveType; first: pointer; count: pointer; drawcount: Int32)>('glMultiDrawArrays');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: PrimitiveType; first: array of Int32; count: array of Int32; drawcount: Int32) := MultiDrawArrays(mode, first[0], count[0], drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: PrimitiveType; var first: Int32; var count: Int32; drawcount: Int32) := MultiDrawArrays(mode, @first, @count, drawcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArrays(mode: PrimitiveType; first: pointer; count: pointer; drawcount: Int32) := z_MultiDrawArrays(mode, first, count, drawcount);
    
    public z_DrawRangeElementsBaseVertex := GetGLFuncOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: pointer; basevertex: Int32)>('glDrawRangeElementsBaseVertex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: array of UInt32; basevertex: Int32) := DrawRangeElementsBaseVertex(mode, start, &end, count, &type, indices[0], basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt32; basevertex: Int32) := DrawRangeElementsBaseVertex(mode, start, &end, count, &type, @indices, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: array of UInt16; basevertex: Int32) := DrawRangeElementsBaseVertex(mode, start, &end, count, &type, indices[0], basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt16; basevertex: Int32) := DrawRangeElementsBaseVertex(mode, start, &end, count, &type, @indices, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: array of Byte; basevertex: Int32) := DrawRangeElementsBaseVertex(mode, start, &end, count, &type, indices[0], basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: Byte; basevertex: Int32) := DrawRangeElementsBaseVertex(mode, start, &end, count, &type, @indices, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: pointer; basevertex: Int32) := z_DrawRangeElementsBaseVertex(mode, start, &end, count, &type, indices, basevertex);
    
    public z_DrawRangeElements := GetGLFuncOrNil&<procedure(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: pointer)>('glDrawRangeElements');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: array of UInt32) := DrawRangeElements(mode, start, &end, count, &type, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt32) := DrawRangeElements(mode, start, &end, count, &type, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: array of UInt16) := DrawRangeElements(mode, start, &end, count, &type, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt16) := DrawRangeElements(mode, start, &end, count, &type, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: array of Byte) := DrawRangeElements(mode, start, &end, count, &type, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: Byte) := DrawRangeElements(mode, start, &end, count, &type, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: pointer) := z_DrawRangeElements(mode, start, &end, count, &type, indices);
    
    public z_DrawElementsInstancedBaseVertexBaseInstance := GetGLFuncOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; basevertex: Int32; baseinstance: UInt32)>('glDrawElementsInstancedBaseVertexBaseInstance');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt32; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseVertexBaseInstance(mode, count, &type, indices[0], instancecount, basevertex, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseVertexBaseInstance(mode, count, &type, @indices, instancecount, basevertex, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt16; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseVertexBaseInstance(mode, count, &type, indices[0], instancecount, basevertex, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseVertexBaseInstance(mode, count, &type, @indices, instancecount, basevertex, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of Byte; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseVertexBaseInstance(mode, count, &type, indices[0], instancecount, basevertex, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseVertexBaseInstance(mode, count, &type, @indices, instancecount, basevertex, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) := z_DrawElementsInstancedBaseVertexBaseInstance(mode, count, &type, indices, instancecount, basevertex, baseinstance);
    
    public z_DrawElementsInstancedBaseVertex := GetGLFuncOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; basevertex: Int32)>('glDrawElementsInstancedBaseVertex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt32; instancecount: Int32; basevertex: Int32) := DrawElementsInstancedBaseVertex(mode, count, &type, indices[0], instancecount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32; basevertex: Int32) := DrawElementsInstancedBaseVertex(mode, count, &type, @indices, instancecount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt16; instancecount: Int32; basevertex: Int32) := DrawElementsInstancedBaseVertex(mode, count, &type, indices[0], instancecount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32; basevertex: Int32) := DrawElementsInstancedBaseVertex(mode, count, &type, @indices, instancecount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of Byte; instancecount: Int32; basevertex: Int32) := DrawElementsInstancedBaseVertex(mode, count, &type, indices[0], instancecount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32; basevertex: Int32) := DrawElementsInstancedBaseVertex(mode, count, &type, @indices, instancecount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; basevertex: Int32) := z_DrawElementsInstancedBaseVertex(mode, count, &type, indices, instancecount, basevertex);
    
    public z_DrawElementsInstancedBaseInstance := GetGLFuncOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; baseinstance: UInt32)>('glDrawElementsInstancedBaseInstance');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt32; instancecount: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseInstance(mode, count, &type, indices[0], instancecount, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseInstance(mode, count, &type, @indices, instancecount, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt16; instancecount: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseInstance(mode, count, &type, indices[0], instancecount, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseInstance(mode, count, &type, @indices, instancecount, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of Byte; instancecount: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseInstance(mode, count, &type, indices[0], instancecount, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32; baseinstance: UInt32) := DrawElementsInstancedBaseInstance(mode, count, &type, @indices, instancecount, baseinstance);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; baseinstance: UInt32) := z_DrawElementsInstancedBaseInstance(mode, count, &type, indices, instancecount, baseinstance);
    
    public z_DrawElementsInstanced := GetGLFuncOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32)>('glDrawElementsInstanced');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt32; instancecount: Int32) := DrawElementsInstanced(mode, count, &type, indices[0], instancecount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32) := DrawElementsInstanced(mode, count, &type, @indices, instancecount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt16; instancecount: Int32) := DrawElementsInstanced(mode, count, &type, indices[0], instancecount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32) := DrawElementsInstanced(mode, count, &type, @indices, instancecount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of Byte; instancecount: Int32) := DrawElementsInstanced(mode, count, &type, indices[0], instancecount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32) := DrawElementsInstanced(mode, count, &type, @indices, instancecount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32) := z_DrawElementsInstanced(mode, count, &type, indices, instancecount);
    
    public z_DrawElementsIndirect := GetGLFuncOrNil&<procedure(mode: PrimitiveType; &type: DataType; indirect: pointer)>('glDrawElementsIndirect');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsIndirect(mode: PrimitiveType; &type: DataType; var indirect: DrawArraysIndirectCommand) := DrawElementsIndirect(mode, &type, @indirect);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsIndirect(mode: PrimitiveType; &type: DataType; indirect: pointer) := z_DrawElementsIndirect(mode, &type, indirect);
    
    public z_DrawElementsBaseVertex := GetGLFuncOrNil&<procedure(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; basevertex: Int32)>('glDrawElementsBaseVertex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt32; basevertex: Int32) := DrawElementsBaseVertex(mode, count, &type, indices[0], basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; basevertex: Int32) := DrawElementsBaseVertex(mode, count, &type, @indices, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt16; basevertex: Int32) := DrawElementsBaseVertex(mode, count, &type, indices[0], basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; basevertex: Int32) := DrawElementsBaseVertex(mode, count, &type, @indices, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of Byte; basevertex: Int32) := DrawElementsBaseVertex(mode, count, &type, indices[0], basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; basevertex: Int32) := DrawElementsBaseVertex(mode, count, &type, @indices, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; basevertex: Int32) := z_DrawElementsBaseVertex(mode, count, &type, indices, basevertex);
    
    private static procedure _DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer); external 'opengl32.dll' name 'glDrawElements';
    public static z_DrawElements := _DrawElements;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt32) := DrawElements(mode, count, &type, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32) := DrawElements(mode, count, &type, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of UInt16) := DrawElements(mode, count, &type, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16) := DrawElements(mode, count, &type, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; indices: array of Byte) := DrawElements(mode, count, &type, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte) := DrawElements(mode, count, &type, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer) := z_DrawElements(mode, count, &type, indices);
    
    public z_DrawArraysInstancedBaseInstance := GetGLFuncOrNil&<procedure(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32)>('glDrawArraysInstancedBaseInstance');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedBaseInstance(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32) := z_DrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance);
    
    public z_DrawArraysInstanced := GetGLFuncOrNil&<procedure(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32)>('glDrawArraysInstanced');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstanced(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32) := z_DrawArraysInstanced(mode, first, count, instancecount);
    
    public z_DrawArraysIndirect := GetGLFuncOrNil&<procedure(mode: PrimitiveType; indirect: pointer)>('glDrawArraysIndirect');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysIndirect(mode: PrimitiveType; var indirect: DrawArraysIndirectCommand) := DrawArraysIndirect(mode, @indirect);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysIndirect(mode: PrimitiveType; indirect: pointer) := z_DrawArraysIndirect(mode, indirect);
    
    private static procedure _DrawArrays(mode: PrimitiveType; first: Int32; count: Int32); external 'opengl32.dll' name 'glDrawArrays';
    public static z_DrawArrays := _DrawArrays;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArrays(mode: PrimitiveType; first: Int32; count: Int32) := z_DrawArrays(mode, first, count);
    
    {$endregion 10.4 - Drawing Commands Using Vertex Arrays}
    
    {$region 10.5 - Vertex Array and Vertex Array Object Queries}
    
    public z_GetVertexAttribPointerv := GetGLFuncOrNil&<procedure(index: UInt32; pname: UInt32; _pointer: pointer)>('glGetVertexAttribPointerv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; _pointer: array of IntPtr) := GetVertexAttribPointerv(index, pname, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; var _pointer: IntPtr) := GetVertexAttribPointerv(index, pname, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; var _pointer: ^IntPtr) := GetVertexAttribPointerv(index, pname, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; _pointer: pointer) := z_GetVertexAttribPointerv(index, pname, _pointer);
    
    public z_GetVertexAttribLdv := GetGLFuncOrNil&<procedure(index: UInt32; pname: VertexAttribInfoType; &params: pointer)>('glGetVertexAttribLdv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; &params: array of double) := GetVertexAttribLdv(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; var &params: double) := GetVertexAttribLdv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4d) := GetVertexAttribLdv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; &params: pointer) := z_GetVertexAttribLdv(index, pname, &params);
    
    public z_GetVertexAttribiv := GetGLFuncOrNil&<procedure(index: UInt32; pname: VertexAttribInfoType; &params: pointer)>('glGetVertexAttribiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; &params: array of Int32) := GetVertexAttribiv(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: Int32) := GetVertexAttribiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: BufferName) := GetVertexAttribiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: DataType) := GetVertexAttribiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4i) := GetVertexAttribiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; &params: pointer) := z_GetVertexAttribiv(index, pname, &params);
    
    public z_GetVertexAttribIuiv := GetGLFuncOrNil&<procedure(index: UInt32; pname: VertexAttribInfoType; &params: pointer)>('glGetVertexAttribIuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; &params: array of UInt32) := GetVertexAttribIuiv(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; var &params: UInt32) := GetVertexAttribIuiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; var &params: DataType) := GetVertexAttribIuiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4ui) := GetVertexAttribIuiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; &params: pointer) := z_GetVertexAttribIuiv(index, pname, &params);
    
    public z_GetVertexAttribIiv := GetGLFuncOrNil&<procedure(index: UInt32; pname: VertexAttribInfoType; &params: pointer)>('glGetVertexAttribIiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; &params: array of Int32) := GetVertexAttribIiv(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: Int32) := GetVertexAttribIiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: BufferName) := GetVertexAttribIiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: DataType) := GetVertexAttribIiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4i) := GetVertexAttribIiv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; &params: pointer) := z_GetVertexAttribIiv(index, pname, &params);
    
    public z_GetVertexAttribfv := GetGLFuncOrNil&<procedure(index: UInt32; pname: VertexAttribInfoType; &params: pointer)>('glGetVertexAttribfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; &params: array of single) := GetVertexAttribfv(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; var &params: single) := GetVertexAttribfv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4f) := GetVertexAttribfv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; &params: pointer) := z_GetVertexAttribfv(index, pname, &params);
    
    public z_GetVertexAttribdv := GetGLFuncOrNil&<procedure(index: UInt32; pname: VertexAttribInfoType; &params: pointer)>('glGetVertexAttribdv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; &params: array of double) := GetVertexAttribdv(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; var &params: double) := GetVertexAttribdv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4d) := GetVertexAttribdv(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; &params: pointer) := z_GetVertexAttribdv(index, pname, &params);
    
    public z_GetVertexArrayiv := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; pname: VertexAttribInfoType; param: pointer)>('glGetVertexArrayiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: VertexArrayName; pname: VertexAttribInfoType; var param: Int32) := GetVertexArrayiv(vaobj, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: VertexArrayName; pname: VertexAttribInfoType; var param: BufferName) := GetVertexArrayiv(vaobj, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayiv(vaobj: VertexArrayName; pname: VertexAttribInfoType; param: pointer) := z_GetVertexArrayiv(vaobj, pname, param);
    
    public z_GetVertexArrayIndexediv := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; param: pointer)>('glGetVertexArrayIndexediv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; var param: Int32) := GetVertexArrayIndexediv(vaobj, index, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; var param: DataType) := GetVertexArrayIndexediv(vaobj, index, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexediv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; param: pointer) := z_GetVertexArrayIndexediv(vaobj, index, pname, param);
    
    public z_GetVertexArrayIndexed64iv := GetGLFuncOrNil&<procedure(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; param: pointer)>('glGetVertexArrayIndexed64iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexed64iv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; var param: Int64) := GetVertexArrayIndexed64iv(vaobj, index, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIndexed64iv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; param: pointer) := z_GetVertexArrayIndexed64iv(vaobj, index, pname, param);
    
    {$endregion 10.5 - Vertex Array and Vertex Array Object Queries}
    
    {$region 10.9 - Conditional Rendering}
    
    public z_EndConditionalRender := GetGLFuncOrNil&<procedure>('glEndConditionalRender');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndConditionalRender := z_EndConditionalRender;
    
    public z_BeginConditionalRender := GetGLFuncOrNil&<procedure(id: UInt32; mode: ConditionalRenderingMode)>('glBeginConditionalRender');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginConditionalRender(id: UInt32; mode: ConditionalRenderingMode) := z_BeginConditionalRender(id, mode);
    
    {$endregion 10.9 - Conditional Rendering}
    
    {$endregion 10 - Vertex Specification and Drawing Commands}
    
    {$region 11 - Programmable Vertex Processing}
    
    {$region 11.1 - Vertex Shaders}
    
    {$region 11.1.1 - Vertex Attributes}
    
    public z_GetAttribLocation := GetGLFuncOrNil&<function(&program: ProgramName; name: IntPtr): Int32>('glGetAttribLocation');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocation(&program: ProgramName; name: string): Int32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); Result := GetAttribLocation(&program, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocation(&program: ProgramName; name: IntPtr): Int32 := z_GetAttribLocation(&program, name);
    
    public z_GetActiveAttrib := GetGLFuncOrNil&<procedure(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr)>('glGetActiveAttrib');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttrib(&program, index, bufSize, @length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; name: IntPtr) := GetActiveAttrib(&program, index, bufSize, @length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttrib(&program, index, bufSize, @length, @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr) := GetActiveAttrib(&program, index, bufSize, @length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttrib(&program, index, bufSize, length, size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; name: IntPtr) := GetActiveAttrib(&program, index, bufSize, length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttrib(&program, index, bufSize, length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr) := z_GetActiveAttrib(&program, index, bufSize, length, size, &type, name);
    
    public z_BindAttribLocation := GetGLFuncOrNil&<procedure(&program: ProgramName; index: UInt32; name: IntPtr)>('glBindAttribLocation');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocation(&program: ProgramName; index: UInt32; name: string); begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); BindAttribLocation(&program, index, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocation(&program: ProgramName; index: UInt32; name: IntPtr) := z_BindAttribLocation(&program, index, name);
    
    {$endregion 11.1.1 - Vertex Attributes}
    
    {$region 11.1.2 - Vertex Shader Variables}
    
    public z_TransformFeedbackVaryings := GetGLFuncOrNil&<procedure(&program: ProgramName; count: Int32; varyings: pointer; bufferMode: TransformFeedbackBufferMode)>('glTransformFeedbackVaryings');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryings(&program: ProgramName; count: Int32; var varyings: IntPtr; bufferMode: TransformFeedbackBufferMode) := TransformFeedbackVaryings(&program, count, @varyings, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryings(&program: ProgramName; count: Int32; varyings: pointer; bufferMode: TransformFeedbackBufferMode) := z_TransformFeedbackVaryings(&program, count, varyings, bufferMode);
    
    public z_GetTransformFeedbackVarying := GetGLFuncOrNil&<procedure(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr)>('glGetTransformFeedbackVarying');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVarying(&program, index, bufSize, @length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; name: IntPtr) := GetTransformFeedbackVarying(&program, index, bufSize, @length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVarying(&program, index, bufSize, @length, @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr) := GetTransformFeedbackVarying(&program, index, bufSize, @length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVarying(&program, index, bufSize, length, size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; name: IntPtr) := GetTransformFeedbackVarying(&program, index, bufSize, length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVarying(&program, index, bufSize, length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr) := z_GetTransformFeedbackVarying(&program, index, bufSize, length, size, &type, name);
    
    {$endregion 11.1.2 - Vertex Shader Variables}
    
    {$region 11.1.3 - Shader Execution}
    
    public z_ValidateProgramPipeline := GetGLFuncOrNil&<procedure(pipeline: ProgramPipelineName)>('glValidateProgramPipeline');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgramPipeline(pipeline: ProgramPipelineName) := z_ValidateProgramPipeline(pipeline);
    
    public z_ValidateProgram := GetGLFuncOrNil&<procedure(&program: ProgramName)>('glValidateProgram');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgram(&program: ProgramName) := z_ValidateProgram(&program);
    
    {$endregion 11.1.3 - Shader Execution}
    
    {$endregion 11.1 - Vertex Shaders}
    
    {$region 11.2 - Tessellation}
    
    {$region 11.2.2 - Tessellation Primitive Generation}
    
    public z_PatchParameterfv := GetGLFuncOrNil&<procedure(pname: PatchMode; values: pointer)>('glPatchParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchMode; values: array of single) := PatchParameterfv(pname, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchMode; var values: single) := PatchParameterfv(pname, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchMode; var values: Vec2f) := PatchParameterfv(pname, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchMode; var values: Vec4f) := PatchParameterfv(pname, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameterfv(pname: PatchMode; values: pointer) := z_PatchParameterfv(pname, values);
    
    {$endregion 11.2.2 - Tessellation Primitive Generation}
    
    {$endregion 11.2 - Tessellation}
    
    {$endregion 11 - Programmable Vertex Processing}
    
    {$region 13 - Fixed-Function Vertex Post-Processing}
    
    {$region 13.3 - Transform Feedback}
    
    {$region 13.3.1 - Transform Feedback Objects}
    
    public z_IsTransformFeedback := GetGLFuncOrNil&<function(id: TransformFeedbackName): boolean>('glIsTransformFeedback');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTransformFeedback(id: TransformFeedbackName): boolean := z_IsTransformFeedback(id);
    
    public z_GenTransformFeedbacks := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glGenTransformFeedbacks');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; ids: array of TransformFeedbackName) := GenTransformFeedbacks(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; var ids: TransformFeedbackName) := GenTransformFeedbacks(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacks(n: Int32; ids: pointer) := z_GenTransformFeedbacks(n, ids);
    
    public z_DeleteTransformFeedbacks := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glDeleteTransformFeedbacks');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; ids: array of TransformFeedbackName) := DeleteTransformFeedbacks(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; var ids: TransformFeedbackName) := DeleteTransformFeedbacks(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacks(n: Int32; ids: pointer) := z_DeleteTransformFeedbacks(n, ids);
    
    public z_CreateTransformFeedbacks := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glCreateTransformFeedbacks');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; ids: array of TransformFeedbackName) := CreateTransformFeedbacks(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; var ids: TransformFeedbackName) := CreateTransformFeedbacks(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateTransformFeedbacks(n: Int32; ids: pointer) := z_CreateTransformFeedbacks(n, ids);
    
    public z_BindTransformFeedback := GetGLFuncOrNil&<procedure(target: TransformFeedbackBindTarget; id: TransformFeedbackName)>('glBindTransformFeedback');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTransformFeedback(target: TransformFeedbackBindTarget; id: TransformFeedbackName) := z_BindTransformFeedback(target, id);
    
    {$endregion 13.3.1 - Transform Feedback Objects}
    
    {$region 13.3.2 - Transform Feedback Primitive Capture}
    
    public z_TransformFeedbackBufferRange := GetGLFuncOrNil&<procedure(xfb: TransformFeedbackName; index: UInt32; buffer: BufferName; offset: IntPtr; size: UIntPtr)>('glTransformFeedbackBufferRange');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackBufferRange(xfb: TransformFeedbackName; index: UInt32; buffer: BufferName; offset: IntPtr; size: UIntPtr) := z_TransformFeedbackBufferRange(xfb, index, buffer, offset, size);
    
    public z_TransformFeedbackBufferBase := GetGLFuncOrNil&<procedure(xfb: TransformFeedbackName; index: UInt32; buffer: BufferName)>('glTransformFeedbackBufferBase');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackBufferBase(xfb: TransformFeedbackName; index: UInt32; buffer: BufferName) := z_TransformFeedbackBufferBase(xfb, index, buffer);
    
    public z_ResumeTransformFeedback := GetGLFuncOrNil&<procedure>('glResumeTransformFeedback');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResumeTransformFeedback := z_ResumeTransformFeedback;
    
    public z_PauseTransformFeedback := GetGLFuncOrNil&<procedure>('glPauseTransformFeedback');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PauseTransformFeedback := z_PauseTransformFeedback;
    
    public z_EndTransformFeedback := GetGLFuncOrNil&<procedure>('glEndTransformFeedback');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTransformFeedback := z_EndTransformFeedback;
    
    public z_BeginTransformFeedback := GetGLFuncOrNil&<procedure(primitiveMode: PrimitiveType)>('glBeginTransformFeedback');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginTransformFeedback(primitiveMode: PrimitiveType) := z_BeginTransformFeedback(primitiveMode);
    
    {$endregion 13.3.2 - Transform Feedback Primitive Capture}
    
    {$region 13.3.3 - Transform Feedback Draw Operations}
    
    public z_DrawTransformFeedbackStreamInstanced := GetGLFuncOrNil&<procedure(mode: PrimitiveType; id: TransformFeedbackName; stream: UInt32; instancecount: Int32)>('glDrawTransformFeedbackStreamInstanced');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackStreamInstanced(mode: PrimitiveType; id: TransformFeedbackName; stream: UInt32; instancecount: Int32) := z_DrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount);
    
    public z_DrawTransformFeedbackStream := GetGLFuncOrNil&<procedure(mode: PrimitiveType; id: TransformFeedbackName; stream: UInt32)>('glDrawTransformFeedbackStream');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackStream(mode: PrimitiveType; id: TransformFeedbackName; stream: UInt32) := z_DrawTransformFeedbackStream(mode, id, stream);
    
    public z_DrawTransformFeedbackInstanced := GetGLFuncOrNil&<procedure(mode: PrimitiveType; id: TransformFeedbackName; instancecount: Int32)>('glDrawTransformFeedbackInstanced');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackInstanced(mode: PrimitiveType; id: TransformFeedbackName; instancecount: Int32) := z_DrawTransformFeedbackInstanced(mode, id, instancecount);
    
    public z_DrawTransformFeedback := GetGLFuncOrNil&<procedure(mode: PrimitiveType; id: TransformFeedbackName)>('glDrawTransformFeedback');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedback(mode: PrimitiveType; id: TransformFeedbackName) := z_DrawTransformFeedback(mode, id);
    
    {$endregion 13.3.3 - Transform Feedback Draw Operations}
    
    {$endregion 13.3 - Transform Feedback}
    
    {$region 13.6 - Flatshading}
    
    public z_ProvokingVertex := GetGLFuncOrNil&<procedure(mode: VertexProvokingMode)>('glProvokingVertex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProvokingVertex(mode: VertexProvokingMode) := z_ProvokingVertex(mode);
    
    {$endregion 13.6 - Flatshading}
    
    {$region 13.7 - Primitive Clipping}
    
    public z_ClipControl := GetGLFuncOrNil&<procedure(origin: ClipOriginMode; depth: ClipDepthMode)>('glClipControl');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipControl(origin: ClipOriginMode; depth: ClipDepthMode) := z_ClipControl(origin, depth);
    
    {$endregion 13.7 - Primitive Clipping}
    
    {$region 13.8 - Coordinate Transformations}
    
    {$region 13.8.1 - Controlling the Viewport}
    
    public z_ViewportIndexedfv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glViewportIndexedfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; v: array of single) := ViewportIndexedfv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; var v: single) := ViewportIndexedfv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; var v: Vec4f) := ViewportIndexedfv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfv(index: UInt32; v: pointer) := z_ViewportIndexedfv(index, v);
    
    public z_ViewportIndexedf := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single; w: single; h: single)>('glViewportIndexedf');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedf(index: UInt32; x: single; y: single; w: single; h: single) := z_ViewportIndexedf(index, x, y, w, h);
    
    public z_ViewportArrayv := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>('glViewportArrayv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: array of single) := ViewportArrayv(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; var v: single) := ViewportArrayv(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: array of Vec4f) := ViewportArrayv(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; var v: Vec4f) := ViewportArrayv(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayv(first: UInt32; count: Int32; v: pointer) := z_ViewportArrayv(first, count, v);
    
    private static procedure _Viewport(x: Int32; y: Int32; width: Int32; height: Int32); external 'opengl32.dll' name 'glViewport';
    public static z_Viewport := _Viewport;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Viewport(x: Int32; y: Int32; width: Int32; height: Int32) := z_Viewport(x, y, width, height);
    
    public z_DepthRangeIndexed := GetGLFuncOrNil&<procedure(index: UInt32; n: double; f: double)>('glDepthRangeIndexed');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeIndexed(index: UInt32; n: double; f: double) := z_DepthRangeIndexed(index, n, f);
    
    public z_DepthRangef := GetGLFuncOrNil&<procedure(n: single; f: single)>('glDepthRangef');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangef(n: single; f: single) := z_DepthRangef(n, f);
    
    public z_DepthRangeArrayv := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>('glDepthRangeArrayv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: array of double) := DepthRangeArrayv(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; var v: double) := DepthRangeArrayv(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: array of Vec2d) := DepthRangeArrayv(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; var v: Vec2d) := DepthRangeArrayv(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayv(first: UInt32; count: Int32; v: pointer) := z_DepthRangeArrayv(first, count, v);
    
    private static procedure _DepthRange(n: double; f: double); external 'opengl32.dll' name 'glDepthRange';
    public static z_DepthRange := _DepthRange;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRange(n: double; f: double) := z_DepthRange(n, f);
    
    {$endregion 13.8.1 - Controlling the Viewport}
    
    {$endregion 13.8 - Coordinate Transformations}
    
    {$endregion 13 - Fixed-Function Vertex Post-Processing}
    
    {$region 14 - Fixed-Function Primitive Assembly and Rasterization}
    
    {$region 14.3 - Antialiasing}
    
    {$region 14.3.1 - Multisampling}
    
    public z_MinSampleShading := GetGLFuncOrNil&<procedure(value: single)>('glMinSampleShading');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MinSampleShading(value: single) := z_MinSampleShading(value);
    
    public z_GetMultisamplefv := GetGLFuncOrNil&<procedure(pname: MultisampleInfoType; index: UInt32; val: pointer)>('glGetMultisamplefv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; val: array of single) := GetMultisamplefv(pname, index, val[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; var val: single) := GetMultisamplefv(pname, index, @val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; var val: Vec2f) := GetMultisamplefv(pname, index, @val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; val: pointer) := z_GetMultisamplefv(pname, index, val);
    
    {$endregion 14.3.1 - Multisampling}
    
    {$endregion 14.3 - Antialiasing}
    
    {$region 14.4 - Points}
    
    private static procedure _PointSize(size: single); external 'opengl32.dll' name 'glPointSize';
    public static z_PointSize := _PointSize;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointSize(size: single) := z_PointSize(size);
    
    public z_PointParameteriv := GetGLFuncOrNil&<procedure(pname: PointInfoType; &params: pointer)>('glPointParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriv(pname: PointInfoType; var &params: Int32) := PointParameteriv(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriv(pname: PointInfoType; &params: pointer) := z_PointParameteriv(pname, &params);
    
    public z_PointParameteri := GetGLFuncOrNil&<procedure(pname: PointInfoType; param: Int32)>('glPointParameteri');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteri(pname: PointInfoType; param: ClipOriginMode) := PointParameteri(pname, param.val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteri(pname: PointInfoType; param: Int32) := z_PointParameteri(pname, param);
    
    public z_PointParameterfv := GetGLFuncOrNil&<procedure(pname: PointInfoType; &params: pointer)>('glPointParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfv(pname: PointInfoType; var &params: single) := PointParameterfv(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfv(pname: PointInfoType; &params: pointer) := z_PointParameterfv(pname, &params);
    
    public z_PointParameterf := GetGLFuncOrNil&<procedure(pname: PointInfoType; param: single)>('glPointParameterf');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterf(pname: PointInfoType; param: single) := z_PointParameterf(pname, param);
    
    {$endregion 14.4 - Points}
    
    {$region 14.5 - Line Segments}
    
    private static procedure _LineWidth(width: single); external 'opengl32.dll' name 'glLineWidth';
    public static z_LineWidth := _LineWidth;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineWidth(width: single) := z_LineWidth(width);
    
    {$endregion 14.5 - Line Segments}
    
    {$region 14.6 - Polygons}
    
    {$region 14.6.1 - Basic Polygon Rasterization}
    
    private static procedure _FrontFace(mode: FrontFaceDirection); external 'opengl32.dll' name 'glFrontFace';
    public static z_FrontFace := _FrontFace;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrontFace(mode: FrontFaceDirection) := z_FrontFace(mode);
    
    private static procedure _CullFace(mode: PolygonFace); external 'opengl32.dll' name 'glCullFace';
    public static z_CullFace := _CullFace;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullFace(mode: PolygonFace) := z_CullFace(mode);
    
    {$endregion 14.6.1 - Basic Polygon Rasterization}
    
    {$region 14.6.4 - Options Controlling Polygon Rasterization}
    
    private static procedure _PolygonMode(face: PolygonFace; mode: PolygonRasterizationMode); external 'opengl32.dll' name 'glPolygonMode';
    public static z_PolygonMode := _PolygonMode;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonMode(face: PolygonFace; mode: PolygonRasterizationMode) := z_PolygonMode(face, mode);
    
    {$endregion 14.6.4 - Options Controlling Polygon Rasterization}
    
    {$region 14.6.5 - Depth Offset}
    
    public z_PolygonOffsetClamp := GetGLFuncOrNil&<procedure(factor: single; units: single; clamp: single)>('glPolygonOffsetClamp');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetClamp(factor: single; units: single; clamp: single) := z_PolygonOffsetClamp(factor, units, clamp);
    
    private static procedure _PolygonOffset(factor: single; units: single); external 'opengl32.dll' name 'glPolygonOffset';
    public static z_PolygonOffset := _PolygonOffset;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffset(factor: single; units: single) := z_PolygonOffset(factor, units);
    
    {$endregion 14.6.5 - Depth Offset}
    
    {$endregion 14.6 - Polygons}
    
    {$region 14.9 - Early Per-Fragment Tests}
    
    {$region 14.9.2 - Scissor Test}
    
    public z_ScissorIndexedv := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glScissorIndexedv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; v: array of Int32) := ScissorIndexedv(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; var v: Int32) := ScissorIndexedv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; var v: Vec4i) := ScissorIndexedv(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedv(index: UInt32; v: pointer) := z_ScissorIndexedv(index, v);
    
    public z_ScissorIndexed := GetGLFuncOrNil&<procedure(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32)>('glScissorIndexed');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexed(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32) := z_ScissorIndexed(index, left, bottom, width, height);
    
    public z_ScissorArrayv := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>('glScissorArrayv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: array of Int32) := ScissorArrayv(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; var v: Int32) := ScissorArrayv(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: array of Vec4i) := ScissorArrayv(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; var v: Vec4i) := ScissorArrayv(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayv(first: UInt32; count: Int32; v: pointer) := z_ScissorArrayv(first, count, v);
    
    private static procedure _Scissor(x: Int32; y: Int32; width: Int32; height: Int32); external 'opengl32.dll' name 'glScissor';
    public static z_Scissor := _Scissor;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Scissor(x: Int32; y: Int32; width: Int32; height: Int32) := z_Scissor(x, y, width, height);
    
    {$endregion 14.9.2 - Scissor Test}
    
    {$region 14.9.3 - Multisample Fragment Operations}
    
    public z_SampleMaski := GetGLFuncOrNil&<procedure(maskNumber: UInt32; mask: UInt32)>('glSampleMaski');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaski(maskNumber: UInt32; mask: UInt32) := z_SampleMaski(maskNumber, mask);
    
    public z_SampleCoverage := GetGLFuncOrNil&<procedure(value: single; invert: boolean)>('glSampleCoverage');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleCoverage(value: single; invert: boolean) := z_SampleCoverage(value, invert);
    
    {$endregion 14.9.3 - Multisample Fragment Operations}
    
    {$endregion 14.9 - Early Per-Fragment Tests}
    
    {$endregion 14 - Fixed-Function Primitive Assembly and Rasterization}
    
    {$region 15 - Programmable Fragment Processing}
    
    {$region 15.2 - Shader Execution}
    
    {$region 15.2.3 - Shader Outputs}
    
    public z_GetFragDataLocation := GetGLFuncOrNil&<function(&program: ProgramName; name: IntPtr): Int32>('glGetFragDataLocation');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocation(&program: ProgramName; name: string): Int32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); Result := GetFragDataLocation(&program, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocation(&program: ProgramName; name: IntPtr): Int32 := z_GetFragDataLocation(&program, name);
    
    public z_GetFragDataIndex := GetGLFuncOrNil&<function(&program: ProgramName; name: IntPtr): Int32>('glGetFragDataIndex');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndex(&program: ProgramName; name: string): Int32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); Result := GetFragDataIndex(&program, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndex(&program: ProgramName; name: IntPtr): Int32 := z_GetFragDataIndex(&program, name);
    
    public z_BindFragDataLocationIndexed := GetGLFuncOrNil&<procedure(&program: ProgramName; colorNumber: UInt32; index: UInt32; name: IntPtr)>('glBindFragDataLocationIndexed');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexed(&program: ProgramName; colorNumber: UInt32; index: UInt32; name: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(name); BindFragDataLocationIndexed(&program, colorNumber, index, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexed(&program: ProgramName; colorNumber: UInt32; index: UInt32; name: IntPtr) := z_BindFragDataLocationIndexed(&program, colorNumber, index, name);
    
    public z_BindFragDataLocation := GetGLFuncOrNil&<procedure(&program: ProgramName; color: UInt32; name: IntPtr)>('glBindFragDataLocation');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocation(&program: ProgramName; color: UInt32; name: string); begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); BindFragDataLocation(&program, color, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocation(&program: ProgramName; color: UInt32; name: IntPtr) := z_BindFragDataLocation(&program, color, name);
    
    {$endregion 15.2.3 - Shader Outputs}
    
    {$endregion 15.2 - Shader Execution}
    
    {$endregion 15 - Programmable Fragment Processing}
    
    {$region 17 - Writing Fragments and Samples to the Framebuffer}
    
    {$region 17.3 - Per-Fragment Operations}
    
    {$region 17.3.3 - Stencil Test}
    
    public z_StencilOpSeparate := GetGLFuncOrNil&<procedure(face: PolygonFace; sfail: StencilOpFailMode; dpfail: StencilOpFailMode; dppass: StencilOpFailMode)>('glStencilOpSeparate');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOpSeparate(face: PolygonFace; sfail: StencilOpFailMode; dpfail: StencilOpFailMode; dppass: StencilOpFailMode) := z_StencilOpSeparate(face, sfail, dpfail, dppass);
    
    private static procedure _StencilOp(fail: StencilOpFailMode; zfail: StencilOpFailMode; zpass: StencilOpFailMode); external 'opengl32.dll' name 'glStencilOp';
    public static z_StencilOp := _StencilOp;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOp(fail: StencilOpFailMode; zfail: StencilOpFailMode; zpass: StencilOpFailMode) := z_StencilOp(fail, zfail, zpass);
    
    public z_StencilFuncSeparate := GetGLFuncOrNil&<procedure(face: PolygonFace; func: ActivationFunc; ref: Int32; mask: UInt32)>('glStencilFuncSeparate');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFuncSeparate(face: PolygonFace; func: ActivationFunc; ref: Int32; mask: UInt32) := z_StencilFuncSeparate(face, func, ref, mask);
    
    private static procedure _StencilFunc(func: ActivationFunc; ref: Int32; mask: UInt32); external 'opengl32.dll' name 'glStencilFunc';
    public static z_StencilFunc := _StencilFunc;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFunc(func: ActivationFunc; ref: Int32; mask: UInt32) := z_StencilFunc(func, ref, mask);
    
    {$endregion 17.3.3 - Stencil Test}
    
    {$region 17.3.4 - Depth Buffer Test}
    
    private static procedure _DepthFunc(func: ActivationFunc); external 'opengl32.dll' name 'glDepthFunc';
    public static z_DepthFunc := _DepthFunc;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthFunc(func: ActivationFunc) := z_DepthFunc(func);
    
    {$endregion 17.3.4 - Depth Buffer Test}
    
    {$region 17.3.6 - Blending}
    
    public z_Enablei := GetGLFuncOrNil&<procedure(target: EnablableName; index: UInt32)>('glEnablei');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Enablei(target: EnablableName; index: UInt32) := z_Enablei(target, index);
    
    public z_Disablei := GetGLFuncOrNil&<procedure(target: EnablableName; index: UInt32)>('glDisablei');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Disablei(target: EnablableName; index: UInt32) := z_Disablei(target, index);
    
    public z_BlendFuncSeparatei := GetGLFuncOrNil&<procedure(buf: UInt32; srcRGB: BlendFuncMode; dstRGB: BlendFuncMode; srcAlpha: BlendFuncMode; dstAlpha: BlendFuncMode)>('glBlendFuncSeparatei');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparatei(buf: UInt32; srcRGB: BlendFuncMode; dstRGB: BlendFuncMode; srcAlpha: BlendFuncMode; dstAlpha: BlendFuncMode) := z_BlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    public z_BlendFuncSeparate := GetGLFuncOrNil&<procedure(sfactorRGB: BlendFuncMode; dfactorRGB: BlendFuncMode; sfactorAlpha: BlendFuncMode; dfactorAlpha: BlendFuncMode)>('glBlendFuncSeparate');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparate(sfactorRGB: BlendFuncMode; dfactorRGB: BlendFuncMode; sfactorAlpha: BlendFuncMode; dfactorAlpha: BlendFuncMode) := z_BlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    
    public z_BlendFunci := GetGLFuncOrNil&<procedure(buf: UInt32; src: BlendFuncMode; dst: BlendFuncMode)>('glBlendFunci');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunci(buf: UInt32; src: BlendFuncMode; dst: BlendFuncMode) := z_BlendFunci(buf, src, dst);
    
    private static procedure _BlendFunc(sfactor: BlendFuncMode; dfactor: BlendFuncMode); external 'opengl32.dll' name 'glBlendFunc';
    public static z_BlendFunc := _BlendFunc;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunc(sfactor: BlendFuncMode; dfactor: BlendFuncMode) := z_BlendFunc(sfactor, dfactor);
    
    public z_BlendEquationSeparatei := GetGLFuncOrNil&<procedure(buf: UInt32; modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode)>('glBlendEquationSeparatei');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparatei(buf: UInt32; modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode) := z_BlendEquationSeparatei(buf, modeRGB, modeAlpha);
    
    public z_BlendEquationSeparate := GetGLFuncOrNil&<procedure(modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode)>('glBlendEquationSeparate');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparate(modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode) := z_BlendEquationSeparate(modeRGB, modeAlpha);
    
    public z_BlendEquationi := GetGLFuncOrNil&<procedure(buf: UInt32; mode: BlendEquationMode)>('glBlendEquationi');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationi(buf: UInt32; mode: BlendEquationMode) := z_BlendEquationi(buf, mode);
    
    public z_BlendEquation := GetGLFuncOrNil&<procedure(mode: BlendEquationMode)>('glBlendEquation');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquation(mode: BlendEquationMode) := z_BlendEquation(mode);
    
    public z_BlendColor := GetGLFuncOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>('glBlendColor');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColor(red: single; green: single; blue: single; alpha: single) := z_BlendColor(red, green, blue, alpha);
    
    {$endregion 17.3.6 - Blending}
    
    {$region 17.3.9 - Logical Operation}
    
    private static procedure _LogicOp(opcode: LogicOpCode); external 'opengl32.dll' name 'glLogicOp';
    public static z_LogicOp := _LogicOp;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LogicOp(opcode: LogicOpCode) := z_LogicOp(opcode);
    
    {$endregion 17.3.9 - Logical Operation}
    
    {$endregion 17.3 - Per-Fragment Operations}
    
    {$region 17.4 - Whole Framebuffer Operations}
    
    {$region 17.4.1 - Selecting Buffers for Writing}
    
    public z_NamedFramebufferDrawBuffers := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; n: Int32; bufs: pointer)>('glNamedFramebufferDrawBuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: FramebufferName; n: Int32; bufs: array of FrameBufferPart) := NamedFramebufferDrawBuffers(framebuffer, n, bufs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: FramebufferName; n: Int32; var bufs: FrameBufferPart) := NamedFramebufferDrawBuffers(framebuffer, n, @bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffers(framebuffer: FramebufferName; n: Int32; bufs: pointer) := z_NamedFramebufferDrawBuffers(framebuffer, n, bufs);
    
    public z_NamedFramebufferDrawBuffer := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; buf: FrameBufferPart)>('glNamedFramebufferDrawBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferDrawBuffer(framebuffer: FramebufferName; buf: FrameBufferPart) := z_NamedFramebufferDrawBuffer(framebuffer, buf);
    
    public z_DrawBuffers := GetGLFuncOrNil&<procedure(n: Int32; bufs: pointer)>('glDrawBuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffers(n: Int32; bufs: array of FrameBufferPart) := DrawBuffers(n, bufs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffers(n: Int32; var bufs: FrameBufferPart) := DrawBuffers(n, @bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffers(n: Int32; bufs: pointer) := z_DrawBuffers(n, bufs);
    
    private static procedure _DrawBuffer(buf: FrameBufferPart); external 'opengl32.dll' name 'glDrawBuffer';
    public static z_DrawBuffer := _DrawBuffer;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffer(buf: FrameBufferPart) := z_DrawBuffer(buf);
    
    {$endregion 17.4.1 - Selecting Buffers for Writing}
    
    {$region 17.4.2 - Fine Control of Buffer Updates}
    
    public z_StencilMaskSeparate := GetGLFuncOrNil&<procedure(face: PolygonFace; mask: UInt32)>('glStencilMaskSeparate');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilMaskSeparate(face: PolygonFace; mask: UInt32) := z_StencilMaskSeparate(face, mask);
    
    private static procedure _StencilMask(mask: UInt32); external 'opengl32.dll' name 'glStencilMask';
    public static z_StencilMask := _StencilMask;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilMask(mask: UInt32) := z_StencilMask(mask);
    
    private static procedure _DepthMask(flag: boolean); external 'opengl32.dll' name 'glDepthMask';
    public static z_DepthMask := _DepthMask;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthMask(flag: boolean) := z_DepthMask(flag);
    
    public z_ColorMaski := GetGLFuncOrNil&<procedure(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean)>('glColorMaski');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaski(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean) := z_ColorMaski(index, r, g, b, a);
    
    private static procedure _ColorMask(red: boolean; green: boolean; blue: boolean; alpha: boolean); external 'opengl32.dll' name 'glColorMask';
    public static z_ColorMask := _ColorMask;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMask(red: boolean; green: boolean; blue: boolean; alpha: boolean) := z_ColorMask(red, green, blue, alpha);
    
    {$endregion 17.4.2 - Fine Control of Buffer Updates}
    
    {$region 17.4.3 - Clearing the Buffers}
    
    private static procedure _ClearStencil(s: Int32); external 'opengl32.dll' name 'glClearStencil';
    public static z_ClearStencil := _ClearStencil;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearStencil(s: Int32) := z_ClearStencil(s);
    
    public z_ClearNamedFramebufferuiv := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer)>('glClearNamedFramebufferuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of UInt32) := ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: UInt32) := ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of Vec4ui) := ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4ui) := ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer) := z_ClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);
    
    public z_ClearNamedFramebufferiv := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer)>('glClearNamedFramebufferiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of Int32) := ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Int32) := ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of Vec4i) := ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4i) := ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer) := z_ClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);
    
    public z_ClearNamedFramebufferfv := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer)>('glClearNamedFramebufferfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of single) := ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: single) := ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of Vec4f) := ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4f) := ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer) := z_ClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);
    
    public z_ClearNamedFramebufferfi := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; depth: single; stencil: Int32)>('glClearNamedFramebufferfi');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedFramebufferfi(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; depth: single; stencil: Int32) := z_ClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);
    
    public z_ClearDepthf := GetGLFuncOrNil&<procedure(d: single)>('glClearDepthf');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthf(d: single) := z_ClearDepthf(d);
    
    private static procedure _ClearDepth(depth: double); external 'opengl32.dll' name 'glClearDepth';
    public static z_ClearDepth := _ClearDepth;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepth(depth: double) := z_ClearDepth(depth);
    
    private static procedure _ClearColor(red: single; green: single; blue: single; alpha: single); external 'opengl32.dll' name 'glClearColor';
    public static z_ClearColor := _ClearColor;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColor(red: single; green: single; blue: single; alpha: single) := z_ClearColor(red, green, blue, alpha);
    
    public z_ClearBufferuiv := GetGLFuncOrNil&<procedure(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer)>('glClearBufferuiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of UInt32) := ClearBufferuiv(buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: UInt32) := ClearBufferuiv(buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of Vec4ui) := ClearBufferuiv(buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4ui) := ClearBufferuiv(buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer) := z_ClearBufferuiv(buffer, drawbuffer, value);
    
    public z_ClearBufferiv := GetGLFuncOrNil&<procedure(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer)>('glClearBufferiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of Int32) := ClearBufferiv(buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Int32) := ClearBufferiv(buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of Vec4i) := ClearBufferiv(buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4i) := ClearBufferiv(buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer) := z_ClearBufferiv(buffer, drawbuffer, value);
    
    public z_ClearBufferfv := GetGLFuncOrNil&<procedure(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer)>('glClearBufferfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of single) := ClearBufferfv(buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: single) := ClearBufferfv(buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: array of Vec4f) := ClearBufferfv(buffer, drawbuffer, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4f) := ClearBufferfv(buffer, drawbuffer, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer) := z_ClearBufferfv(buffer, drawbuffer, value);
    
    public z_ClearBufferfi := GetGLFuncOrNil&<procedure(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; depth: single; stencil: Int32)>('glClearBufferfi');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearBufferfi(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; depth: single; stencil: Int32) := z_ClearBufferfi(buffer, drawbuffer, depth, stencil);
    
    private static procedure _Clear(mask: BufferTypeFlags); external 'opengl32.dll' name 'glClear';
    public static z_Clear := _Clear;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Clear(mask: BufferTypeFlags) := z_Clear(mask);
    
    {$endregion 17.4.3 - Clearing the Buffers}
    
    {$region 17.4.4 - Invalidating Framebuffer Contents}
    
    public z_InvalidateSubFramebuffer := GetGLFuncOrNil&<procedure(target: DummyEnum; numAttachments: Int32; attachments: pointer; x: Int32; y: Int32; width: Int32; height: Int32)>('glInvalidateSubFramebuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: DummyEnum; numAttachments: Int32; attachments: array of DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32) := InvalidateSubFramebuffer(target, numAttachments, attachments[0], x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: DummyEnum; numAttachments: Int32; var attachments: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32) := InvalidateSubFramebuffer(target, numAttachments, @attachments, x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateSubFramebuffer(target: DummyEnum; numAttachments: Int32; attachments: pointer; x: Int32; y: Int32; width: Int32; height: Int32) := z_InvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
    
    public z_InvalidateNamedFramebufferSubData := GetGLFuncOrNil&<procedure(framebuffer: UInt32; numAttachments: Int32; attachments: pointer; x: Int32; y: Int32; width: Int32; height: Int32)>('glInvalidateNamedFramebufferSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: UInt32; numAttachments: Int32; attachments: array of DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32) := InvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments[0], x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: UInt32; numAttachments: Int32; var attachments: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32) := InvalidateNamedFramebufferSubData(framebuffer, numAttachments, @attachments, x, y, width, height);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferSubData(framebuffer: UInt32; numAttachments: Int32; attachments: pointer; x: Int32; y: Int32; width: Int32; height: Int32) := z_InvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);
    
    public z_InvalidateNamedFramebufferData := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; numAttachments: Int32; attachments: pointer)>('glInvalidateNamedFramebufferData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: FramebufferName; numAttachments: Int32; attachments: array of FramebufferAttachmentPoint) := InvalidateNamedFramebufferData(framebuffer, numAttachments, attachments[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: FramebufferName; numAttachments: Int32; var attachments: FramebufferAttachmentPoint) := InvalidateNamedFramebufferData(framebuffer, numAttachments, @attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateNamedFramebufferData(framebuffer: FramebufferName; numAttachments: Int32; attachments: pointer) := z_InvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
    
    public z_InvalidateFramebuffer := GetGLFuncOrNil&<procedure(target: FramebufferBindTarget; numAttachments: Int32; attachments: pointer)>('glInvalidateFramebuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; attachments: array of FramebufferAttachmentPoint) := InvalidateFramebuffer(target, numAttachments, attachments[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; var attachments: FramebufferAttachmentPoint) := InvalidateFramebuffer(target, numAttachments, @attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InvalidateFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; attachments: pointer) := z_InvalidateFramebuffer(target, numAttachments, attachments);
    
    {$endregion 17.4.4 - Invalidating Framebuffer Contents}
    
    {$endregion 17.4 - Whole Framebuffer Operations}
    
    {$endregion 17 - Writing Fragments and Samples to the Framebuffer}
    
    {$region 18 - Reading and Copying Pixels}
    
    {$region 18.2 - Reading Pixels}
    
    {$region 18.2.1 - Selecting Buffers for Reading}
    
    private static procedure _ReadBuffer(src: FramebufferAttachmentPoint); external 'opengl32.dll' name 'glReadBuffer';
    public static z_ReadBuffer := _ReadBuffer;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadBuffer(src: FramebufferAttachmentPoint) := z_ReadBuffer(src);
    
    public z_NamedFramebufferReadBuffer := GetGLFuncOrNil&<procedure(framebuffer: FramebufferName; src: FramebufferAttachmentPoint)>('glNamedFramebufferReadBuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferReadBuffer(framebuffer: FramebufferName; src: FramebufferAttachmentPoint) := z_NamedFramebufferReadBuffer(framebuffer, src);
    
    {$endregion 18.2.1 - Selecting Buffers for Reading}
    
    {$region 18.2.2 - ReadPixels}
    
    private static procedure _ReadPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer); external 'opengl32.dll' name 'glReadPixels';
    public static z_ReadPixels := _ReadPixels;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadPixels<T>(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: array of T); where T: record; begin ReadPixels(x, y, width, height, format, &type, pixels[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadPixels<T>(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; var pixels: T); where T: record; begin ReadPixels(x, y, width, height, format, &type, @pixels); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: IntPtr) := ReadPixels(x, y, width, height, format, &type, pointer(pixels));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer) := z_ReadPixels(x, y, width, height, format, &type, pixels);
    
    public z_ReadnPixels := GetGLFuncOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; bufSize: Int32; data: pointer)>('glReadnPixels');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixels<T>(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; bufSize: Int32; data: array of T); where T: record; begin ReadnPixels(x, y, width, height, format, &type, bufSize, data[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixels<T>(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; bufSize: Int32; var data: T); where T: record; begin ReadnPixels(x, y, width, height, format, &type, bufSize, @data); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; bufSize: Int32; data: IntPtr) := ReadnPixels(x, y, width, height, format, &type, bufSize, pointer(data));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; bufSize: Int32; data: pointer) := z_ReadnPixels(x, y, width, height, format, &type, bufSize, data);
    
    {$endregion 18.2.2 - ReadPixels}
    
    {$region 18.2.8 - Final Conversion}
    
    public z_ClampColor := GetGLFuncOrNil&<procedure(target: ColorClampTarget; clamp: UInt32)>('glClampColor');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClampColor(target: ColorClampTarget; clamp: UInt32) := z_ClampColor(target, clamp);
    
    {$endregion 18.2.8 - Final Conversion}
    
    {$endregion 18.2 - Reading Pixels}
    
    {$region 18.3 - Copying Pixels}
    
    {$region 18.3.1 - Blitting Pixel Rectangles}
    
    public z_BlitNamedFramebuffer := GetGLFuncOrNil&<procedure(readFramebuffer: FramebufferName; drawFramebuffer: FramebufferName; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: BufferTypeFlags; filter: PixelFilterMode)>('glBlitNamedFramebuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitNamedFramebuffer(readFramebuffer: FramebufferName; drawFramebuffer: FramebufferName; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: BufferTypeFlags; filter: PixelFilterMode) := z_BlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    public z_BlitFramebuffer := GetGLFuncOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: BufferTypeFlags; filter: PixelFilterMode)>('glBlitFramebuffer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebuffer(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: BufferTypeFlags; filter: PixelFilterMode) := z_BlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    {$endregion 18.3.1 - Blitting Pixel Rectangles}
    
    {$region 18.3.2 - Copying Between Images}
    
    public z_CopyImageSubData := GetGLFuncOrNil&<procedure(srcName: UInt32; srcTarget: CopyableImageType; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: CopyableImageType; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>('glCopyImageSubData');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubData(srcName: UInt32; srcTarget: CopyableImageType; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: CopyableImageType; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) := z_CopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
    {$endregion 18.3.2 - Copying Between Images}
    
    {$endregion 18.3 - Copying Pixels}
    
    {$endregion 18 - Reading and Copying Pixels}
    
    {$region 19 - Compute Shaders}
    
    public z_DispatchComputeIndirect := GetGLFuncOrNil&<procedure(indirect: IntPtr)>('glDispatchComputeIndirect');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchComputeIndirect(indirect: IntPtr) := z_DispatchComputeIndirect(indirect);
    
    public z_DispatchCompute := GetGLFuncOrNil&<procedure(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32)>('glDispatchCompute');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchCompute(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32) := z_DispatchCompute(num_groups_x, num_groups_y, num_groups_z);
    
    {$endregion 19 - Compute Shaders}
    
    {$region 20 - Debug Output}
    
    {$region 20.2 - Debug Message Callback}
    
    public z_DebugMessageCallback := GetGLFuncOrNil&<procedure(callback: GLDEBUGPROC; userParam: pointer)>('glDebugMessageCallback');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallback<T>(callback: GLDEBUGPROC; userParam: array of T); where T: record; begin DebugMessageCallback(callback, userParam[0]); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallback<T>(callback: GLDEBUGPROC; var userParam: T); where T: record; begin DebugMessageCallback(callback, @userParam); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallback(callback: GLDEBUGPROC; userParam: IntPtr) := DebugMessageCallback(callback, pointer(userParam));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallback(callback: GLDEBUGPROC; userParam: pointer) := z_DebugMessageCallback(callback, userParam);
    
    {$endregion 20.2 - Debug Message Callback}
    
    {$region 20.4 - Controlling Debug Messages}
    
    public z_DebugMessageControl := GetGLFuncOrNil&<procedure(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: pointer; enabled: boolean)>('glDebugMessageControl');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: array of UInt32; enabled: boolean) := DebugMessageControl(source, &type, severity, count, ids[0], enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; var ids: UInt32; enabled: boolean) := DebugMessageControl(source, &type, severity, count, @ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControl(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: pointer; enabled: boolean) := z_DebugMessageControl(source, &type, severity, count, ids, enabled);
    
    {$endregion 20.4 - Controlling Debug Messages}
    
    {$region 20.5 - Externally Generated Messages}
    
    public z_DebugMessageInsert := GetGLFuncOrNil&<procedure(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: IntPtr)>('glDebugMessageInsert');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsert(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: string); begin var ptr_6 := Marshal.StringToHGlobalAnsi(buf); DebugMessageInsert(source, &type, id, severity, length, ptr_6); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsert(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: IntPtr) := z_DebugMessageInsert(source, &type, id, severity, length, buf);
    
    {$endregion 20.5 - Externally Generated Messages}
    
    {$region 20.6 - Debug Groups}
    
    public z_PushDebugGroup := GetGLFuncOrNil&<procedure(source: DebugSourceType; id: UInt32; length: Int32; message: IntPtr)>('glPushDebugGroup');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroup(source: DebugSourceType; id: UInt32; length: Int32; message: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(message); PushDebugGroup(source, id, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroup(source: DebugSourceType; id: UInt32; length: Int32; message: IntPtr) := z_PushDebugGroup(source, id, length, message);
    
    public z_PopDebugGroup := GetGLFuncOrNil&<procedure>('glPopDebugGroup');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopDebugGroup := z_PopDebugGroup;
    
    {$endregion 20.6 - Debug Groups}
    
    {$region 20.7 - Debug Labels}
    
    public z_ObjectPtrLabel := GetGLFuncOrNil&<procedure(ptr: pointer; length: Int32; &label: IntPtr)>('glObjectPtrLabel');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel<T>(ptr: array of T; length: Int32; &label: string); where T: record; begin var ptr_3 := Marshal.StringToHGlobalAnsi(&label); ObjectPtrLabel(ptr[0], length, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel<T>(ptr: array of T; length: Int32; &label: IntPtr); where T: record; begin ObjectPtrLabel(ptr[0], length, &label); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel<T>(var ptr: T; length: Int32; &label: string); where T: record; begin var ptr_3 := Marshal.StringToHGlobalAnsi(&label); ObjectPtrLabel(@ptr, length, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel<T>(var ptr: T; length: Int32; &label: IntPtr); where T: record; begin ObjectPtrLabel(@ptr, length, &label); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: string); begin var ptr_3 := Marshal.StringToHGlobalAnsi(&label); ObjectPtrLabel(pointer(ptr), length, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: IntPtr) := ObjectPtrLabel(pointer(ptr), length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: pointer; length: Int32; &label: string); begin var ptr_3 := Marshal.StringToHGlobalAnsi(&label); ObjectPtrLabel(ptr, length, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabel(ptr: pointer; length: Int32; &label: IntPtr) := z_ObjectPtrLabel(ptr, length, &label);
    
    public z_ObjectLabel := GetGLFuncOrNil&<procedure(identifier: ObjectType; name: UInt32; length: Int32; &label: IntPtr)>('glObjectLabel');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabel(identifier: ObjectType; name: UInt32; length: Int32; &label: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(&label); ObjectLabel(identifier, name, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabel(identifier: ObjectType; name: UInt32; length: Int32; &label: IntPtr) := z_ObjectLabel(identifier, name, length, &label);
    
    {$endregion 20.7 - Debug Labels}
    
    {$region 20.9 - Debug Output Queries}
    
    public z_GetObjectPtrLabel := GetGLFuncOrNil&<procedure(ptr: pointer; bufSize: Int32; length: pointer; &label: IntPtr)>('glGetObjectPtrLabel');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; var length: Int32; &label: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(&label); GetObjectPtrLabel(ptr, bufSize, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; var length: Int32; &label: IntPtr) := GetObjectPtrLabel(ptr, bufSize, @length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; length: pointer; &label: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(&label); GetObjectPtrLabel(ptr, bufSize, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; length: pointer; &label: IntPtr) := z_GetObjectPtrLabel(ptr, bufSize, length, &label);
    
    public z_GetObjectLabel := GetGLFuncOrNil&<procedure(identifier: ObjectType; name: UInt32; bufSize: Int32; length: pointer; &label: IntPtr)>('glGetObjectLabel');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; var length: Int32; &label: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(&label); GetObjectLabel(identifier, name, bufSize, @length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr) := GetObjectLabel(identifier, name, bufSize, @length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; length: pointer; &label: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(&label); GetObjectLabel(identifier, name, bufSize, length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; length: pointer; &label: IntPtr) := z_GetObjectLabel(identifier, name, bufSize, length, &label);
    
    public z_GetDebugMessageLog := GetGLFuncOrNil&<function(count: UInt32; bufSize: Int32; sources: pointer; types: pointer; ids: pointer; severities: pointer; lengths: pointer; messageLog: IntPtr): UInt32>('glGetDebugMessageLog');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: array of DebugSourceType; types: array of DebugMessageType; ids: array of UInt32; severities: array of DebugSeverityLevel; lengths: array of Int32; messageLog: string): UInt32; begin var ptr_8 := Marshal.StringToHGlobalAnsi(messageLog); Result := GetDebugMessageLog(count, bufSize, sources[0], types[0], ids[0], severities[0], lengths[0], ptr_8); Marshal.FreeHGlobal(ptr_8); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: array of DebugSourceType; types: array of DebugMessageType; ids: array of UInt32; severities: array of DebugSeverityLevel; lengths: array of Int32; messageLog: IntPtr): UInt32 := GetDebugMessageLog(count, bufSize, sources[0], types[0], ids[0], severities[0], lengths[0], messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; var sources: DebugSourceType; var types: DebugMessageType; var ids: UInt32; var severities: DebugSeverityLevel; var lengths: Int32; messageLog: string): UInt32; begin var ptr_8 := Marshal.StringToHGlobalAnsi(messageLog); Result := GetDebugMessageLog(count, bufSize, @sources, @types, @ids, @severities, @lengths, ptr_8); Marshal.FreeHGlobal(ptr_8); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; var sources: DebugSourceType; var types: DebugMessageType; var ids: UInt32; var severities: DebugSeverityLevel; var lengths: Int32; messageLog: IntPtr): UInt32 := GetDebugMessageLog(count, bufSize, @sources, @types, @ids, @severities, @lengths, messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: pointer; types: pointer; ids: pointer; severities: pointer; lengths: pointer; messageLog: string): UInt32; begin var ptr_8 := Marshal.StringToHGlobalAnsi(messageLog); Result := GetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, ptr_8); Marshal.FreeHGlobal(ptr_8); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: pointer; types: pointer; ids: pointer; severities: pointer; lengths: pointer; messageLog: IntPtr): UInt32 := z_GetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    
    {$endregion 20.9 - Debug Output Queries}
    
    {$endregion 20 - Debug Output}
    
    {$region 21 - Special Functions}
    
    {$region 21.5 - Hints}
    
    private static procedure _Hint(target: HintType; mode: HintValue); external 'opengl32.dll' name 'glHint';
    public static z_Hint := _Hint;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Hint(target: HintType; mode: HintValue) := z_Hint(target, mode);
    
    {$endregion 21.5 - Hints}
    
    {$endregion 21 - Special Functions}
    
    {$region 22 - Context State Queries}
    
    {$region 22.1 - Simple Queries}
    
    public z_IsEnabledi := GetGLFuncOrNil&<function(target: EnablableName; index: UInt32): boolean>('glIsEnabledi');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledi(target: EnablableName; index: UInt32): boolean := z_IsEnabledi(target, index);
    
    private static function _IsEnabled(cap: EnablableName): boolean; external 'opengl32.dll' name 'glIsEnabled';
    public static z_IsEnabled := _IsEnabled;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabled(cap: EnablableName): boolean := z_IsEnabled(cap);
    
    private static procedure _GetIntegerv(pname: GLGetQueries; data: pointer); external 'opengl32.dll' name 'glGetIntegerv';
    public static z_GetIntegerv := _GetIntegerv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: GLGetQueries; data: array of Int32) := GetIntegerv(pname, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: GLGetQueries; var data: Int32) := GetIntegerv(pname, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerv(pname: GLGetQueries; data: pointer) := z_GetIntegerv(pname, data);
    
    public z_GetIntegeri_v := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetIntegeri_v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: GLGetQueries; index: UInt32; data: array of Int32) := GetIntegeri_v(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: GLGetQueries; index: UInt32; var data: Int32) := GetIntegeri_v(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: BufferBindType; index: UInt32; var data: BufferName) := GetIntegeri_v(new GLGetQueries(target.val), index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_v(target: GLGetQueries; index: UInt32; data: pointer) := z_GetIntegeri_v(target, index, data);
    
    public z_GetInteger64v := GetGLFuncOrNil&<procedure(pname: GLGetQueries; data: pointer)>('glGetInteger64v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: GLGetQueries; data: array of Int64) := GetInteger64v(pname, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: GLGetQueries; var data: Int64) := GetInteger64v(pname, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64v(pname: GLGetQueries; data: pointer) := z_GetInteger64v(pname, data);
    
    public z_GetInteger64i_v := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetInteger64i_v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64i_v(target: GLGetQueries; index: UInt32; data: array of Int64) := GetInteger64i_v(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64i_v(target: GLGetQueries; index: UInt32; var data: Int64) := GetInteger64i_v(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64i_v(target: BufferBindType; index: UInt32; var data: Vec2i64) := GetInteger64i_v(new GLGetQueries(target.val), index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64i_v(target: GLGetQueries; index: UInt32; data: pointer) := z_GetInteger64i_v(target, index, data);
    
    private static procedure _GetFloatv(pname: GLGetQueries; data: pointer); external 'opengl32.dll' name 'glGetFloatv';
    public static z_GetFloatv := _GetFloatv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatv(pname: GLGetQueries; data: array of single) := GetFloatv(pname, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatv(pname: GLGetQueries; var data: single) := GetFloatv(pname, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatv(pname: GLGetQueries; data: pointer) := z_GetFloatv(pname, data);
    
    public z_GetFloati_v := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetFloati_v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: GLGetQueries; index: UInt32; data: array of single) := GetFloati_v(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: GLGetQueries; index: UInt32; var data: single) := GetFloati_v(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_v(target: GLGetQueries; index: UInt32; data: pointer) := z_GetFloati_v(target, index, data);
    
    private static procedure _GetDoublev(pname: GLGetQueries; data: pointer); external 'opengl32.dll' name 'glGetDoublev';
    public static z_GetDoublev := _GetDoublev;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublev(pname: GLGetQueries; data: array of double) := GetDoublev(pname, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublev(pname: GLGetQueries; var data: double) := GetDoublev(pname, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublev(pname: GLGetQueries; data: pointer) := z_GetDoublev(pname, data);
    
    public z_GetDoublei_v := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetDoublei_v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: GLGetQueries; index: UInt32; data: array of double) := GetDoublei_v(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: GLGetQueries; index: UInt32; var data: double) := GetDoublei_v(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_v(target: GLGetQueries; index: UInt32; data: pointer) := z_GetDoublei_v(target, index, data);
    
    private static procedure _GetBooleanv(pname: GLGetQueries; data: pointer); external 'opengl32.dll' name 'glGetBooleanv';
    public static z_GetBooleanv := _GetBooleanv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanv(pname: GLGetQueries; data: array of boolean) := GetBooleanv(pname, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanv(pname: GLGetQueries; var data: boolean) := GetBooleanv(pname, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanv(pname: GLGetQueries; data: pointer) := z_GetBooleanv(pname, data);
    
    public z_GetBooleani_v := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetBooleani_v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleani_v(target: GLGetQueries; index: UInt32; data: array of boolean) := GetBooleani_v(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleani_v(target: GLGetQueries; index: UInt32; var data: boolean) := GetBooleani_v(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleani_v(target: GLGetQueries; index: UInt32; data: pointer) := z_GetBooleani_v(target, index, data);
    
    {$endregion 22.1 - Simple Queries}
    
    {$region 22.2 - Pointer, String, and Related Context Queries}
    
    public z_GetStringi := GetGLFuncOrNil&<function(name: GLGetStringQueries; index: UInt32): IntPtr>('glGetStringi');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetStringi_Str(name: GLGetStringQueries; index: UInt32): string := Marshal.PtrToStringAnsi(GetStringi(name, index));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetStringi(name: GLGetStringQueries; index: UInt32): IntPtr := z_GetStringi(name, index);
    
    private static function _GetString(name: GLGetStringQueries): IntPtr; external 'opengl32.dll' name 'glGetString';
    public static z_GetString := _GetString;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetString_Str(name: GLGetStringQueries): string := Marshal.PtrToStringAnsi(GetString(name));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetString(name: GLGetStringQueries): IntPtr := z_GetString(name);
    
    private static procedure _GetPointerv(pname: GLGetQueries; &params: pointer); external 'opengl32.dll' name 'glGetPointerv';
    public static z_GetPointerv := _GetPointerv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: GLGetQueries; &params: array of IntPtr) := GetPointerv(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: GLGetQueries; var &params: IntPtr) := GetPointerv(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: GLGetQueries; var &params: ^IntPtr) := GetPointerv(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerv(pname: GLGetQueries; &params: pointer) := z_GetPointerv(pname, &params);
    
    {$endregion 22.2 - Pointer, String, and Related Context Queries}
    
    {$region 22.3 - Internal Format Queries}
    
    public z_GetInternalformativ := GetGLFuncOrNil&<procedure(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; &params: pointer)>('glGetInternalformativ');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; &params: array of Int32) := GetInternalformativ(target, internalformat, pname, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: Int32) := GetInternalformativ(target, internalformat, pname, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: SupportLevel) := GetInternalformativ(target, internalformat, pname, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: DataFormat) := GetInternalformativ(target, internalformat, pname, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: DataType) := GetInternalformativ(target, internalformat, pname, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: CompatibilityImageClassType) := GetInternalformativ(target, internalformat, pname, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: ImageFormatCompatibilityMode) := GetInternalformativ(target, internalformat, pname, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; &params: pointer) := z_GetInternalformativ(target, internalformat, pname, bufSize, &params);
    
    public z_GetInternalformati64v := GetGLFuncOrNil&<procedure(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; &params: pointer)>('glGetInternalformati64v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; &params: array of Int64) := GetInternalformati64v(target, internalformat, pname, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: Int64) := GetInternalformati64v(target, internalformat, pname, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformati64v(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; &params: pointer) := z_GetInternalformati64v(target, internalformat, pname, bufSize, &params);
    
    {$endregion 22.3 - Internal Format Queries}
    
    {$region 22.4 - Transform Feedback State Queries}
    
    public z_GetTransformFeedbackiv := GetGLFuncOrNil&<procedure(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; param: pointer)>('glGetTransformFeedbackiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; var param: Int32) := GetTransformFeedbackiv(xfb, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; var param: BufferName) := GetTransformFeedbackiv(xfb, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackiv(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; param: pointer) := z_GetTransformFeedbackiv(xfb, pname, param);
    
    public z_GetTransformFeedbacki64_v := GetGLFuncOrNil&<procedure(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; param: pointer)>('glGetTransformFeedbacki64_v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki64_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; var param: Int64) := GetTransformFeedbacki64_v(xfb, pname, index, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki64_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; param: pointer) := z_GetTransformFeedbacki64_v(xfb, pname, index, param);
    
    public z_GetTransformFeedbacki_v := GetGLFuncOrNil&<procedure(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; param: pointer)>('glGetTransformFeedbacki_v');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; var param: Int32) := GetTransformFeedbacki_v(xfb, pname, index, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; var param: BufferName) := GetTransformFeedbacki_v(xfb, pname, index, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbacki_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; param: pointer) := z_GetTransformFeedbacki_v(xfb, pname, index, param);
    
    {$endregion 22.4 - Transform Feedback State Queries}
    
    {$endregion 22 - Context State Queries}
    
  end;
  
  glD = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    public z_MultiTexCoord4svARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord4svARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4svARB(target: DummyEnum; v: array of Int16) := MultiTexCoord4svARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4svARB(target: DummyEnum; var v: Int16) := MultiTexCoord4svARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4svARB(target: DummyEnum; v: pointer) := z_MultiTexCoord4svARB(target, v);
    
    public z_MultiTexCoord4sARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int16; t: Int16; r: Int16; q: Int16)>('glMultiTexCoord4sARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sARB(target: DummyEnum; s: Int16; t: Int16; r: Int16; q: Int16) := z_MultiTexCoord4sARB(target, s, t, r, q);
    
    public z_MultiTexCoord4ivARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord4ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4ivARB(target: DummyEnum; v: array of Int32) := MultiTexCoord4ivARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4ivARB(target: DummyEnum; var v: Int32) := MultiTexCoord4ivARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4ivARB(target: DummyEnum; v: pointer) := z_MultiTexCoord4ivARB(target, v);
    
    public z_MultiTexCoord4iARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int32; t: Int32; r: Int32; q: Int32)>('glMultiTexCoord4iARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iARB(target: DummyEnum; s: Int32; t: Int32; r: Int32; q: Int32) := z_MultiTexCoord4iARB(target, s, t, r, q);
    
    public z_MultiTexCoord4fvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord4fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fvARB(target: DummyEnum; v: array of single) := MultiTexCoord4fvARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fvARB(target: DummyEnum; var v: single) := MultiTexCoord4fvARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fvARB(target: DummyEnum; v: pointer) := z_MultiTexCoord4fvARB(target, v);
    
    public z_MultiTexCoord4fARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: single; t: single; r: single; q: single)>('glMultiTexCoord4fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fARB(target: DummyEnum; s: single; t: single; r: single; q: single) := z_MultiTexCoord4fARB(target, s, t, r, q);
    
    public z_MultiTexCoord4dvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord4dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dvARB(target: DummyEnum; v: array of double) := MultiTexCoord4dvARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dvARB(target: DummyEnum; var v: double) := MultiTexCoord4dvARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dvARB(target: DummyEnum; v: pointer) := z_MultiTexCoord4dvARB(target, v);
    
    public z_MultiTexCoord4dARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: double; t: double; r: double; q: double)>('glMultiTexCoord4dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dARB(target: DummyEnum; s: double; t: double; r: double; q: double) := z_MultiTexCoord4dARB(target, s, t, r, q);
    
    public z_MultiTexCoord3svARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord3svARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3svARB(target: DummyEnum; v: array of Int16) := MultiTexCoord3svARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3svARB(target: DummyEnum; var v: Int16) := MultiTexCoord3svARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3svARB(target: DummyEnum; v: pointer) := z_MultiTexCoord3svARB(target, v);
    
    public z_MultiTexCoord3sARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int16; t: Int16; r: Int16)>('glMultiTexCoord3sARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sARB(target: DummyEnum; s: Int16; t: Int16; r: Int16) := z_MultiTexCoord3sARB(target, s, t, r);
    
    public z_MultiTexCoord3ivARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord3ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3ivARB(target: DummyEnum; v: array of Int32) := MultiTexCoord3ivARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3ivARB(target: DummyEnum; var v: Int32) := MultiTexCoord3ivARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3ivARB(target: DummyEnum; v: pointer) := z_MultiTexCoord3ivARB(target, v);
    
    public z_MultiTexCoord3iARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int32; t: Int32; r: Int32)>('glMultiTexCoord3iARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iARB(target: DummyEnum; s: Int32; t: Int32; r: Int32) := z_MultiTexCoord3iARB(target, s, t, r);
    
    public z_MultiTexCoord3fvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord3fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fvARB(target: DummyEnum; v: array of single) := MultiTexCoord3fvARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fvARB(target: DummyEnum; var v: single) := MultiTexCoord3fvARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fvARB(target: DummyEnum; v: pointer) := z_MultiTexCoord3fvARB(target, v);
    
    public z_MultiTexCoord3fARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: single; t: single; r: single)>('glMultiTexCoord3fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fARB(target: DummyEnum; s: single; t: single; r: single) := z_MultiTexCoord3fARB(target, s, t, r);
    
    public z_MultiTexCoord3dvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord3dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dvARB(target: DummyEnum; v: array of double) := MultiTexCoord3dvARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dvARB(target: DummyEnum; var v: double) := MultiTexCoord3dvARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dvARB(target: DummyEnum; v: pointer) := z_MultiTexCoord3dvARB(target, v);
    
    public z_MultiTexCoord3dARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: double; t: double; r: double)>('glMultiTexCoord3dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dARB(target: DummyEnum; s: double; t: double; r: double) := z_MultiTexCoord3dARB(target, s, t, r);
    
    public z_MultiTexCoord2svARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord2svARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2svARB(target: DummyEnum; v: array of Int16) := MultiTexCoord2svARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2svARB(target: DummyEnum; var v: Int16) := MultiTexCoord2svARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2svARB(target: DummyEnum; v: pointer) := z_MultiTexCoord2svARB(target, v);
    
    public z_MultiTexCoord2sARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int16; t: Int16)>('glMultiTexCoord2sARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sARB(target: DummyEnum; s: Int16; t: Int16) := z_MultiTexCoord2sARB(target, s, t);
    
    public z_MultiTexCoord2ivARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord2ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2ivARB(target: DummyEnum; v: array of Int32) := MultiTexCoord2ivARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2ivARB(target: DummyEnum; var v: Int32) := MultiTexCoord2ivARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2ivARB(target: DummyEnum; v: pointer) := z_MultiTexCoord2ivARB(target, v);
    
    public z_MultiTexCoord2iARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int32; t: Int32)>('glMultiTexCoord2iARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iARB(target: DummyEnum; s: Int32; t: Int32) := z_MultiTexCoord2iARB(target, s, t);
    
    public z_MultiTexCoord2fvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord2fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fvARB(target: DummyEnum; v: array of single) := MultiTexCoord2fvARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fvARB(target: DummyEnum; var v: single) := MultiTexCoord2fvARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fvARB(target: DummyEnum; v: pointer) := z_MultiTexCoord2fvARB(target, v);
    
    public z_MultiTexCoord2fARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: single; t: single)>('glMultiTexCoord2fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fARB(target: DummyEnum; s: single; t: single) := z_MultiTexCoord2fARB(target, s, t);
    
    public z_MultiTexCoord2dvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord2dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dvARB(target: DummyEnum; v: array of double) := MultiTexCoord2dvARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dvARB(target: DummyEnum; var v: double) := MultiTexCoord2dvARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dvARB(target: DummyEnum; v: pointer) := z_MultiTexCoord2dvARB(target, v);
    
    public z_MultiTexCoord2dARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: double; t: double)>('glMultiTexCoord2dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dARB(target: DummyEnum; s: double; t: double) := z_MultiTexCoord2dARB(target, s, t);
    
    public z_MultiTexCoord1svARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord1svARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1svARB(target: DummyEnum; v: array of Int16) := MultiTexCoord1svARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1svARB(target: DummyEnum; var v: Int16) := MultiTexCoord1svARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1svARB(target: DummyEnum; v: pointer) := z_MultiTexCoord1svARB(target, v);
    
    public z_MultiTexCoord1sARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int16)>('glMultiTexCoord1sARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sARB(target: DummyEnum; s: Int16) := z_MultiTexCoord1sARB(target, s);
    
    public z_MultiTexCoord1ivARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord1ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1ivARB(target: DummyEnum; v: array of Int32) := MultiTexCoord1ivARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1ivARB(target: DummyEnum; var v: Int32) := MultiTexCoord1ivARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1ivARB(target: DummyEnum; v: pointer) := z_MultiTexCoord1ivARB(target, v);
    
    public z_MultiTexCoord1iARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int32)>('glMultiTexCoord1iARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iARB(target: DummyEnum; s: Int32) := z_MultiTexCoord1iARB(target, s);
    
    public z_MultiTexCoord1fvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord1fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fvARB(target: DummyEnum; v: array of single) := MultiTexCoord1fvARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fvARB(target: DummyEnum; var v: single) := MultiTexCoord1fvARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fvARB(target: DummyEnum; v: pointer) := z_MultiTexCoord1fvARB(target, v);
    
    public z_MultiTexCoord1fARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: single)>('glMultiTexCoord1fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fARB(target: DummyEnum; s: single) := z_MultiTexCoord1fARB(target, s);
    
    public z_MultiTexCoord1dvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord1dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dvARB(target: DummyEnum; v: array of double) := MultiTexCoord1dvARB(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dvARB(target: DummyEnum; var v: double) := MultiTexCoord1dvARB(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dvARB(target: DummyEnum; v: pointer) := z_MultiTexCoord1dvARB(target, v);
    
    public z_MultiTexCoord1dARB := GetGLFuncOrNil&<procedure(target: DummyEnum; s: double)>('glMultiTexCoord1dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dARB(target: DummyEnum; s: double) := z_MultiTexCoord1dARB(target, s);
    
    public z_ClientActiveTextureARB := GetGLFuncOrNil&<procedure(texture: DummyEnum)>('glClientActiveTextureARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveTextureARB(texture: DummyEnum) := z_ClientActiveTextureARB(texture);
    
    public z_ActiveTextureARB := GetGLFuncOrNil&<procedure(texture: DummyEnum)>('glActiveTextureARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveTextureARB(texture: DummyEnum) := z_ActiveTextureARB(texture);
    
    {$region 2 - OpenGL Operation}
    
    {$region 2.6 - Begin/End Paradigm}
    
    {$region 2.6.1 - Begin and End}
    
    private static procedure _End; external 'opengl32.dll' name 'glEnd';
    ///OpenGL 3.0
    public static z_End := _End;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure &End := z_End;
    
    private static procedure _Begin(mode: DummyEnum); external 'opengl32.dll' name 'glBegin';
    ///OpenGL 3.0
    public static z_Begin := _Begin;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure &Begin(mode: DummyEnum) := z_Begin(mode);
    
    {$endregion 2.6.1 - Begin and End}
    
    {$region 2.6.2 - Polygon Edges}
    
    private static procedure _EdgeFlagv(flag: pointer); external 'opengl32.dll' name 'glEdgeFlagv';
    ///OpenGL 3.0
    public static z_EdgeFlagv := _EdgeFlagv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagv(flag: array of boolean) := EdgeFlagv(flag[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagv(var flag: boolean) := EdgeFlagv(@flag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagv(flag: pointer) := z_EdgeFlagv(flag);
    
    private static procedure _EdgeFlag(flag: boolean); external 'opengl32.dll' name 'glEdgeFlag';
    ///OpenGL 3.0
    public static z_EdgeFlag := _EdgeFlag;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlag(flag: boolean) := z_EdgeFlag(flag);
    
    {$endregion 2.6.2 - Polygon Edges}
    
    {$endregion 2.6 - Begin/End Paradigm}
    
    {$region 2.7 - Vertex Specification}
    
    private static procedure _Vertex4sv(v: pointer); external 'opengl32.dll' name 'glVertex4sv';
    ///OpenGL 3.0
    public static z_Vertex4sv := _Vertex4sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4sv(v: array of Int16) := Vertex4sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4sv(var v: Int16) := Vertex4sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4sv(v: pointer) := z_Vertex4sv(v);
    
    private static procedure _Vertex4s(v1: Int16; v2: Int16; v3: Int16; v4: Int16); external 'opengl32.dll' name 'glVertex4s';
    ///OpenGL 3.0
    public static z_Vertex4s := _Vertex4s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4s(v1: Int16; v2: Int16; v3: Int16; v4: Int16) := z_Vertex4s(v1, v2, v3, v4);
    
    private static procedure _Vertex4iv(v: pointer); external 'opengl32.dll' name 'glVertex4iv';
    ///OpenGL 3.0
    public static z_Vertex4iv := _Vertex4iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4iv(v: array of Int32) := Vertex4iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4iv(var v: Int32) := Vertex4iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4iv(v: pointer) := z_Vertex4iv(v);
    
    private static procedure _Vertex4i(v1: Int32; v2: Int32; v3: Int32; v4: Int32); external 'opengl32.dll' name 'glVertex4i';
    ///OpenGL 3.0
    public static z_Vertex4i := _Vertex4i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4i(v1: Int32; v2: Int32; v3: Int32; v4: Int32) := z_Vertex4i(v1, v2, v3, v4);
    
    private static procedure _Vertex4fv(v: pointer); external 'opengl32.dll' name 'glVertex4fv';
    ///OpenGL 3.0
    public static z_Vertex4fv := _Vertex4fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4fv(v: array of single) := Vertex4fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4fv(var v: single) := Vertex4fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4fv(v: pointer) := z_Vertex4fv(v);
    
    private static procedure _Vertex4f(v1: single; v2: single; v3: single; v4: single); external 'opengl32.dll' name 'glVertex4f';
    ///OpenGL 3.0
    public static z_Vertex4f := _Vertex4f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4f(v1: single; v2: single; v3: single; v4: single) := z_Vertex4f(v1, v2, v3, v4);
    
    private static procedure _Vertex4dv(v: pointer); external 'opengl32.dll' name 'glVertex4dv';
    ///OpenGL 3.0
    public static z_Vertex4dv := _Vertex4dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4dv(v: array of double) := Vertex4dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4dv(var v: double) := Vertex4dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4dv(v: pointer) := z_Vertex4dv(v);
    
    private static procedure _Vertex4d(v1: double; v2: double; v3: double; v4: double); external 'opengl32.dll' name 'glVertex4d';
    ///OpenGL 3.0
    public static z_Vertex4d := _Vertex4d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4d(v1: double; v2: double; v3: double; v4: double) := z_Vertex4d(v1, v2, v3, v4);
    
    private static procedure _Vertex3sv(v: pointer); external 'opengl32.dll' name 'glVertex3sv';
    ///OpenGL 3.0
    public static z_Vertex3sv := _Vertex3sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3sv(v: array of Int16) := Vertex3sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3sv(var v: Int16) := Vertex3sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3sv(v: pointer) := z_Vertex3sv(v);
    
    private static procedure _Vertex3s(v1: Int16; v2: Int16; v3: Int16); external 'opengl32.dll' name 'glVertex3s';
    ///OpenGL 3.0
    public static z_Vertex3s := _Vertex3s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3s(v1: Int16; v2: Int16; v3: Int16) := z_Vertex3s(v1, v2, v3);
    
    private static procedure _Vertex3iv(v: pointer); external 'opengl32.dll' name 'glVertex3iv';
    ///OpenGL 3.0
    public static z_Vertex3iv := _Vertex3iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3iv(v: array of Int32) := Vertex3iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3iv(var v: Int32) := Vertex3iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3iv(v: pointer) := z_Vertex3iv(v);
    
    private static procedure _Vertex3i(v1: Int32; v2: Int32; v3: Int32); external 'opengl32.dll' name 'glVertex3i';
    ///OpenGL 3.0
    public static z_Vertex3i := _Vertex3i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3i(v1: Int32; v2: Int32; v3: Int32) := z_Vertex3i(v1, v2, v3);
    
    private static procedure _Vertex3fv(v: pointer); external 'opengl32.dll' name 'glVertex3fv';
    ///OpenGL 3.0
    public static z_Vertex3fv := _Vertex3fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(v: array of single) := Vertex3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(var v: single) := Vertex3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(v: pointer) := z_Vertex3fv(v);
    
    private static procedure _Vertex3f(x: single; y: single; z: single); external 'opengl32.dll' name 'glVertex3f';
    ///OpenGL 3.0
    public static z_Vertex3f := _Vertex3f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3f(x: single; y: single; z: single) := z_Vertex3f(x, y, z);
    
    private static procedure _Vertex3dv(v: pointer); external 'opengl32.dll' name 'glVertex3dv';
    ///OpenGL 3.0
    public static z_Vertex3dv := _Vertex3dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3dv(v: array of double) := Vertex3dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3dv(var v: double) := Vertex3dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3dv(v: pointer) := z_Vertex3dv(v);
    
    private static procedure _Vertex3d(v1: double; v2: double; v3: double); external 'opengl32.dll' name 'glVertex3d';
    ///OpenGL 3.0
    public static z_Vertex3d := _Vertex3d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3d(v1: double; v2: double; v3: double) := z_Vertex3d(v1, v2, v3);
    
    private static procedure _Vertex2sv(v: pointer); external 'opengl32.dll' name 'glVertex2sv';
    ///OpenGL 3.0
    public static z_Vertex2sv := _Vertex2sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2sv(v: array of Int16) := Vertex2sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2sv(var v: Int16) := Vertex2sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2sv(v: pointer) := z_Vertex2sv(v);
    
    private static procedure _Vertex2s(v1: Int16; v2: Int16); external 'opengl32.dll' name 'glVertex2s';
    ///OpenGL 3.0
    public static z_Vertex2s := _Vertex2s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2s(v1: Int16; v2: Int16) := z_Vertex2s(v1, v2);
    
    private static procedure _Vertex2iv(v: pointer); external 'opengl32.dll' name 'glVertex2iv';
    ///OpenGL 3.0
    public static z_Vertex2iv := _Vertex2iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2iv(v: array of Int32) := Vertex2iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2iv(var v: Int32) := Vertex2iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2iv(v: pointer) := z_Vertex2iv(v);
    
    private static procedure _Vertex2i(v1: Int32; v2: Int32); external 'opengl32.dll' name 'glVertex2i';
    ///OpenGL 3.0
    public static z_Vertex2i := _Vertex2i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2i(v1: Int32; v2: Int32) := z_Vertex2i(v1, v2);
    
    private static procedure _Vertex2fv(v: pointer); external 'opengl32.dll' name 'glVertex2fv';
    ///OpenGL 3.0
    public static z_Vertex2fv := _Vertex2fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(v: array of single) := Vertex2fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(var v: single) := Vertex2fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(v: pointer) := z_Vertex2fv(v);
    
    private static procedure _Vertex2f(x: single; y: single); external 'opengl32.dll' name 'glVertex2f';
    ///OpenGL 3.0
    public static z_Vertex2f := _Vertex2f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2f(x: single; y: single) := z_Vertex2f(x, y);
    
    private static procedure _Vertex2dv(v: pointer); external 'opengl32.dll' name 'glVertex2dv';
    ///OpenGL 3.0
    public static z_Vertex2dv := _Vertex2dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2dv(v: array of double) := Vertex2dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2dv(var v: double) := Vertex2dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2dv(v: pointer) := z_Vertex2dv(v);
    
    private static procedure _Vertex2d(v1: double; v2: double); external 'opengl32.dll' name 'glVertex2d';
    ///OpenGL 3.0
    public static z_Vertex2d := _Vertex2d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2d(v1: double; v2: double) := z_Vertex2d(v1, v2);
    
    private static procedure _TexCoord4sv(v: pointer); external 'opengl32.dll' name 'glTexCoord4sv';
    ///OpenGL 3.0
    public static z_TexCoord4sv := _TexCoord4sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4sv(v: array of Int16) := TexCoord4sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4sv(var v: Int16) := TexCoord4sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4sv(v: pointer) := z_TexCoord4sv(v);
    
    private static procedure _TexCoord4s(v1: Int16; v2: Int16; v3: Int16; v4: Int16); external 'opengl32.dll' name 'glTexCoord4s';
    ///OpenGL 3.0
    public static z_TexCoord4s := _TexCoord4s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4s(v1: Int16; v2: Int16; v3: Int16; v4: Int16) := z_TexCoord4s(v1, v2, v3, v4);
    
    private static procedure _TexCoord4iv(v: pointer); external 'opengl32.dll' name 'glTexCoord4iv';
    ///OpenGL 3.0
    public static z_TexCoord4iv := _TexCoord4iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4iv(v: array of Int32) := TexCoord4iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4iv(var v: Int32) := TexCoord4iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4iv(v: pointer) := z_TexCoord4iv(v);
    
    private static procedure _TexCoord4i(v1: Int32; v2: Int32; v3: Int32; v4: Int32); external 'opengl32.dll' name 'glTexCoord4i';
    ///OpenGL 3.0
    public static z_TexCoord4i := _TexCoord4i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4i(v1: Int32; v2: Int32; v3: Int32; v4: Int32) := z_TexCoord4i(v1, v2, v3, v4);
    
    private static procedure _TexCoord4fv(v: pointer); external 'opengl32.dll' name 'glTexCoord4fv';
    ///OpenGL 3.0
    public static z_TexCoord4fv := _TexCoord4fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fv(v: array of single) := TexCoord4fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fv(var v: single) := TexCoord4fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fv(v: pointer) := z_TexCoord4fv(v);
    
    private static procedure _TexCoord4f(v1: single; v2: single; v3: single; v4: single); external 'opengl32.dll' name 'glTexCoord4f';
    ///OpenGL 3.0
    public static z_TexCoord4f := _TexCoord4f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4f(v1: single; v2: single; v3: single; v4: single) := z_TexCoord4f(v1, v2, v3, v4);
    
    private static procedure _TexCoord4dv(v: pointer); external 'opengl32.dll' name 'glTexCoord4dv';
    ///OpenGL 3.0
    public static z_TexCoord4dv := _TexCoord4dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4dv(v: array of double) := TexCoord4dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4dv(var v: double) := TexCoord4dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4dv(v: pointer) := z_TexCoord4dv(v);
    
    private static procedure _TexCoord4d(v1: double; v2: double; v3: double; v4: double); external 'opengl32.dll' name 'glTexCoord4d';
    ///OpenGL 3.0
    public static z_TexCoord4d := _TexCoord4d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4d(v1: double; v2: double; v3: double; v4: double) := z_TexCoord4d(v1, v2, v3, v4);
    
    private static procedure _TexCoord3sv(v: pointer); external 'opengl32.dll' name 'glTexCoord3sv';
    ///OpenGL 3.0
    public static z_TexCoord3sv := _TexCoord3sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3sv(v: array of Int16) := TexCoord3sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3sv(var v: Int16) := TexCoord3sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3sv(v: pointer) := z_TexCoord3sv(v);
    
    private static procedure _TexCoord3s(v1: Int16; v2: Int16; v3: Int16); external 'opengl32.dll' name 'glTexCoord3s';
    ///OpenGL 3.0
    public static z_TexCoord3s := _TexCoord3s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3s(v1: Int16; v2: Int16; v3: Int16) := z_TexCoord3s(v1, v2, v3);
    
    private static procedure _TexCoord3iv(v: pointer); external 'opengl32.dll' name 'glTexCoord3iv';
    ///OpenGL 3.0
    public static z_TexCoord3iv := _TexCoord3iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3iv(v: array of Int32) := TexCoord3iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3iv(var v: Int32) := TexCoord3iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3iv(v: pointer) := z_TexCoord3iv(v);
    
    private static procedure _TexCoord3i(v1: Int32; v2: Int32; v3: Int32); external 'opengl32.dll' name 'glTexCoord3i';
    ///OpenGL 3.0
    public static z_TexCoord3i := _TexCoord3i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3i(v1: Int32; v2: Int32; v3: Int32) := z_TexCoord3i(v1, v2, v3);
    
    private static procedure _TexCoord3fv(v: pointer); external 'opengl32.dll' name 'glTexCoord3fv';
    ///OpenGL 3.0
    public static z_TexCoord3fv := _TexCoord3fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3fv(v: array of single) := TexCoord3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3fv(var v: single) := TexCoord3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3fv(v: pointer) := z_TexCoord3fv(v);
    
    private static procedure _TexCoord3f(v1: single; v2: single; v3: single); external 'opengl32.dll' name 'glTexCoord3f';
    ///OpenGL 3.0
    public static z_TexCoord3f := _TexCoord3f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3f(v1: single; v2: single; v3: single) := z_TexCoord3f(v1, v2, v3);
    
    private static procedure _TexCoord3dv(v: pointer); external 'opengl32.dll' name 'glTexCoord3dv';
    ///OpenGL 3.0
    public static z_TexCoord3dv := _TexCoord3dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3dv(v: array of double) := TexCoord3dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3dv(var v: double) := TexCoord3dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3dv(v: pointer) := z_TexCoord3dv(v);
    
    private static procedure _TexCoord3d(v1: double; v2: double; v3: double); external 'opengl32.dll' name 'glTexCoord3d';
    ///OpenGL 3.0
    public static z_TexCoord3d := _TexCoord3d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3d(v1: double; v2: double; v3: double) := z_TexCoord3d(v1, v2, v3);
    
    private static procedure _TexCoord2sv(v: pointer); external 'opengl32.dll' name 'glTexCoord2sv';
    ///OpenGL 3.0
    public static z_TexCoord2sv := _TexCoord2sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2sv(v: array of Int16) := TexCoord2sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2sv(var v: Int16) := TexCoord2sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2sv(v: pointer) := z_TexCoord2sv(v);
    
    private static procedure _TexCoord2s(v1: Int16; v2: Int16); external 'opengl32.dll' name 'glTexCoord2s';
    ///OpenGL 3.0
    public static z_TexCoord2s := _TexCoord2s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2s(v1: Int16; v2: Int16) := z_TexCoord2s(v1, v2);
    
    private static procedure _TexCoord2iv(v: pointer); external 'opengl32.dll' name 'glTexCoord2iv';
    ///OpenGL 3.0
    public static z_TexCoord2iv := _TexCoord2iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2iv(v: array of Int32) := TexCoord2iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2iv(var v: Int32) := TexCoord2iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2iv(v: pointer) := z_TexCoord2iv(v);
    
    private static procedure _TexCoord2i(v1: Int32; v2: Int32); external 'opengl32.dll' name 'glTexCoord2i';
    ///OpenGL 3.0
    public static z_TexCoord2i := _TexCoord2i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2i(v1: Int32; v2: Int32) := z_TexCoord2i(v1, v2);
    
    private static procedure _TexCoord2fv(v: pointer); external 'opengl32.dll' name 'glTexCoord2fv';
    ///OpenGL 3.0
    public static z_TexCoord2fv := _TexCoord2fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fv(v: array of single) := TexCoord2fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fv(var v: single) := TexCoord2fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fv(v: pointer) := z_TexCoord2fv(v);
    
    private static procedure _TexCoord2f(v1: single; v2: single); external 'opengl32.dll' name 'glTexCoord2f';
    ///OpenGL 3.0
    public static z_TexCoord2f := _TexCoord2f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2f(v1: single; v2: single) := z_TexCoord2f(v1, v2);
    
    private static procedure _TexCoord2dv(v: pointer); external 'opengl32.dll' name 'glTexCoord2dv';
    ///OpenGL 3.0
    public static z_TexCoord2dv := _TexCoord2dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2dv(v: array of double) := TexCoord2dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2dv(var v: double) := TexCoord2dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2dv(v: pointer) := z_TexCoord2dv(v);
    
    private static procedure _TexCoord2d(v1: double; v2: double); external 'opengl32.dll' name 'glTexCoord2d';
    ///OpenGL 3.0
    public static z_TexCoord2d := _TexCoord2d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2d(v1: double; v2: double) := z_TexCoord2d(v1, v2);
    
    private static procedure _TexCoord1sv(v: pointer); external 'opengl32.dll' name 'glTexCoord1sv';
    ///OpenGL 3.0
    public static z_TexCoord1sv := _TexCoord1sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1sv(v: array of Int16) := TexCoord1sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1sv(var v: Int16) := TexCoord1sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1sv(v: pointer) := z_TexCoord1sv(v);
    
    private static procedure _TexCoord1s(v1: Int16); external 'opengl32.dll' name 'glTexCoord1s';
    ///OpenGL 3.0
    public static z_TexCoord1s := _TexCoord1s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1s(v1: Int16) := z_TexCoord1s(v1);
    
    private static procedure _TexCoord1iv(v: pointer); external 'opengl32.dll' name 'glTexCoord1iv';
    ///OpenGL 3.0
    public static z_TexCoord1iv := _TexCoord1iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1iv(v: array of Int32) := TexCoord1iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1iv(var v: Int32) := TexCoord1iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1iv(v: pointer) := z_TexCoord1iv(v);
    
    private static procedure _TexCoord1i(v1: Int32); external 'opengl32.dll' name 'glTexCoord1i';
    ///OpenGL 3.0
    public static z_TexCoord1i := _TexCoord1i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1i(v1: Int32) := z_TexCoord1i(v1);
    
    private static procedure _TexCoord1fv(v: pointer); external 'opengl32.dll' name 'glTexCoord1fv';
    ///OpenGL 3.0
    public static z_TexCoord1fv := _TexCoord1fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1fv(v: array of single) := TexCoord1fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1fv(var v: single) := TexCoord1fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1fv(v: pointer) := z_TexCoord1fv(v);
    
    private static procedure _TexCoord1f(v1: single); external 'opengl32.dll' name 'glTexCoord1f';
    ///OpenGL 3.0
    public static z_TexCoord1f := _TexCoord1f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1f(v1: single) := z_TexCoord1f(v1);
    
    private static procedure _TexCoord1dv(v: pointer); external 'opengl32.dll' name 'glTexCoord1dv';
    ///OpenGL 3.0
    public static z_TexCoord1dv := _TexCoord1dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1dv(v: array of double) := TexCoord1dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1dv(var v: double) := TexCoord1dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1dv(v: pointer) := z_TexCoord1dv(v);
    
    private static procedure _TexCoord1d(v1: double); external 'opengl32.dll' name 'glTexCoord1d';
    ///OpenGL 3.0
    public static z_TexCoord1d := _TexCoord1d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1d(v1: double) := z_TexCoord1d(v1);
    
    ///OpenGL 3.0
    public z_SecondaryColor3usv := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3usv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(v: array of UInt16) := SecondaryColor3usv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(var v: UInt16) := SecondaryColor3usv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(v: pointer) := z_SecondaryColor3usv(v);
    
    ///OpenGL 3.0
    public z_SecondaryColor3us := GetGLFuncOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16)>('glSecondaryColor3us');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3us(red: UInt16; green: UInt16; blue: UInt16) := z_SecondaryColor3us(red, green, blue);
    
    ///OpenGL 3.0
    public z_SecondaryColor3uiv := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(v: array of UInt32) := SecondaryColor3uiv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(var v: UInt32) := SecondaryColor3uiv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(v: pointer) := z_SecondaryColor3uiv(v);
    
    ///OpenGL 3.0
    public z_SecondaryColor3ui := GetGLFuncOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32)>('glSecondaryColor3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ui(red: UInt32; green: UInt32; blue: UInt32) := z_SecondaryColor3ui(red, green, blue);
    
    ///OpenGL 3.0
    public z_SecondaryColor3ubv := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3ubv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(v: array of Byte) := SecondaryColor3ubv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(var v: Byte) := SecondaryColor3ubv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(v: pointer) := z_SecondaryColor3ubv(v);
    
    ///OpenGL 3.0
    public z_SecondaryColor3ub := GetGLFuncOrNil&<procedure(red: Byte; green: Byte; blue: Byte)>('glSecondaryColor3ub');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ub(red: Byte; green: Byte; blue: Byte) := z_SecondaryColor3ub(red, green, blue);
    
    ///OpenGL 3.0
    public z_SecondaryColor3sv := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(v: array of Int16) := SecondaryColor3sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(var v: Int16) := SecondaryColor3sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(v: pointer) := z_SecondaryColor3sv(v);
    
    ///OpenGL 3.0
    public z_SecondaryColor3s := GetGLFuncOrNil&<procedure(red: Int16; green: Int16; blue: Int16)>('glSecondaryColor3s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3s(red: Int16; green: Int16; blue: Int16) := z_SecondaryColor3s(red, green, blue);
    
    ///OpenGL 3.0
    public z_SecondaryColor3iv := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(v: array of Int32) := SecondaryColor3iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(var v: Int32) := SecondaryColor3iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(v: pointer) := z_SecondaryColor3iv(v);
    
    ///OpenGL 3.0
    public z_SecondaryColor3i := GetGLFuncOrNil&<procedure(red: Int32; green: Int32; blue: Int32)>('glSecondaryColor3i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3i(red: Int32; green: Int32; blue: Int32) := z_SecondaryColor3i(red, green, blue);
    
    ///OpenGL 3.0
    public z_SecondaryColor3fv := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(v: array of single) := SecondaryColor3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(var v: single) := SecondaryColor3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(v: pointer) := z_SecondaryColor3fv(v);
    
    ///OpenGL 3.0
    public z_SecondaryColor3f := GetGLFuncOrNil&<procedure(red: single; green: single; blue: single)>('glSecondaryColor3f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3f(red: single; green: single; blue: single) := z_SecondaryColor3f(red, green, blue);
    
    ///OpenGL 3.0
    public z_SecondaryColor3dv := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(v: array of double) := SecondaryColor3dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(var v: double) := SecondaryColor3dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(v: pointer) := z_SecondaryColor3dv(v);
    
    ///OpenGL 3.0
    public z_SecondaryColor3d := GetGLFuncOrNil&<procedure(red: double; green: double; blue: double)>('glSecondaryColor3d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3d(red: double; green: double; blue: double) := z_SecondaryColor3d(red, green, blue);
    
    ///OpenGL 3.0
    public z_SecondaryColor3bv := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3bv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(v: array of SByte) := SecondaryColor3bv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(var v: SByte) := SecondaryColor3bv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(v: pointer) := z_SecondaryColor3bv(v);
    
    ///OpenGL 3.0
    public z_SecondaryColor3b := GetGLFuncOrNil&<procedure(red: SByte; green: SByte; blue: SByte)>('glSecondaryColor3b');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3b(red: SByte; green: SByte; blue: SByte) := z_SecondaryColor3b(red, green, blue);
    
    private static procedure _Normal3sv(v: pointer); external 'opengl32.dll' name 'glNormal3sv';
    ///OpenGL 3.0
    public static z_Normal3sv := _Normal3sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3sv(v: array of Int16) := Normal3sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3sv(var v: Int16) := Normal3sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3sv(v: pointer) := z_Normal3sv(v);
    
    private static procedure _Normal3s(v1: Int16; v2: Int16; v3: Int16); external 'opengl32.dll' name 'glNormal3s';
    ///OpenGL 3.0
    public static z_Normal3s := _Normal3s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3s(v1: Int16; v2: Int16; v3: Int16) := z_Normal3s(v1, v2, v3);
    
    private static procedure _Normal3iv(v: pointer); external 'opengl32.dll' name 'glNormal3iv';
    ///OpenGL 3.0
    public static z_Normal3iv := _Normal3iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3iv(v: array of Int32) := Normal3iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3iv(var v: Int32) := Normal3iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3iv(v: pointer) := z_Normal3iv(v);
    
    private static procedure _Normal3i(v1: Int32; v2: Int32; v3: Int32); external 'opengl32.dll' name 'glNormal3i';
    ///OpenGL 3.0
    public static z_Normal3i := _Normal3i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3i(v1: Int32; v2: Int32; v3: Int32) := z_Normal3i(v1, v2, v3);
    
    private static procedure _Normal3fv(v: pointer); external 'opengl32.dll' name 'glNormal3fv';
    ///OpenGL 3.0
    public static z_Normal3fv := _Normal3fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(v: array of single) := Normal3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(var v: single) := Normal3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(v: pointer) := z_Normal3fv(v);
    
    private static procedure _Normal3f(nx: single; ny: single; nz: single); external 'opengl32.dll' name 'glNormal3f';
    ///OpenGL 3.0
    public static z_Normal3f := _Normal3f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3f(nx: single; ny: single; nz: single) := z_Normal3f(nx, ny, nz);
    
    private static procedure _Normal3dv(v: pointer); external 'opengl32.dll' name 'glNormal3dv';
    ///OpenGL 3.0
    public static z_Normal3dv := _Normal3dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3dv(v: array of double) := Normal3dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3dv(var v: double) := Normal3dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3dv(v: pointer) := z_Normal3dv(v);
    
    private static procedure _Normal3d(v1: double; v2: double; v3: double); external 'opengl32.dll' name 'glNormal3d';
    ///OpenGL 3.0
    public static z_Normal3d := _Normal3d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3d(v1: double; v2: double; v3: double) := z_Normal3d(v1, v2, v3);
    
    private static procedure _Normal3bv(v: pointer); external 'opengl32.dll' name 'glNormal3bv';
    ///OpenGL 3.0
    public static z_Normal3bv := _Normal3bv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3bv(v: array of SByte) := Normal3bv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3bv(var v: SByte) := Normal3bv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3bv(v: pointer) := z_Normal3bv(v);
    
    private static procedure _Normal3b(v1: SByte; v2: SByte; v3: SByte); external 'opengl32.dll' name 'glNormal3b';
    ///OpenGL 3.0
    public static z_Normal3b := _Normal3b;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3b(v1: SByte; v2: SByte; v3: SByte) := z_Normal3b(v1, v2, v3);
    
    ///OpenGL 3.0
    public z_MultiTexCoord4sv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord4sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: DummyEnum; v: array of Int16) := MultiTexCoord4sv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: DummyEnum; var v: Int16) := MultiTexCoord4sv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: DummyEnum; v: pointer) := z_MultiTexCoord4sv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord4s := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int16; t: Int16; r: Int16; q: Int16)>('glMultiTexCoord4s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4s(target: DummyEnum; s: Int16; t: Int16; r: Int16; q: Int16) := z_MultiTexCoord4s(target, s, t, r, q);
    
    ///OpenGL 3.0
    public z_MultiTexCoord4iv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord4iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: DummyEnum; v: array of Int32) := MultiTexCoord4iv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: DummyEnum; var v: Int32) := MultiTexCoord4iv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: DummyEnum; v: pointer) := z_MultiTexCoord4iv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord4i := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int32; t: Int32; r: Int32; q: Int32)>('glMultiTexCoord4i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4i(target: DummyEnum; s: Int32; t: Int32; r: Int32; q: Int32) := z_MultiTexCoord4i(target, s, t, r, q);
    
    ///OpenGL 3.0
    public z_MultiTexCoord4fv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord4fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: DummyEnum; v: array of single) := MultiTexCoord4fv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: DummyEnum; var v: single) := MultiTexCoord4fv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: DummyEnum; v: pointer) := z_MultiTexCoord4fv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord4f := GetGLFuncOrNil&<procedure(target: DummyEnum; s: single; t: single; r: single; q: single)>('glMultiTexCoord4f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4f(target: DummyEnum; s: single; t: single; r: single; q: single) := z_MultiTexCoord4f(target, s, t, r, q);
    
    ///OpenGL 3.0
    public z_MultiTexCoord4dv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord4dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: DummyEnum; v: array of double) := MultiTexCoord4dv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: DummyEnum; var v: double) := MultiTexCoord4dv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: DummyEnum; v: pointer) := z_MultiTexCoord4dv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord4d := GetGLFuncOrNil&<procedure(target: DummyEnum; s: double; t: double; r: double; q: double)>('glMultiTexCoord4d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4d(target: DummyEnum; s: double; t: double; r: double; q: double) := z_MultiTexCoord4d(target, s, t, r, q);
    
    ///OpenGL 3.0
    public z_MultiTexCoord3sv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord3sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: DummyEnum; v: array of Int16) := MultiTexCoord3sv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: DummyEnum; var v: Int16) := MultiTexCoord3sv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: DummyEnum; v: pointer) := z_MultiTexCoord3sv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord3s := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int16; t: Int16; r: Int16)>('glMultiTexCoord3s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3s(target: DummyEnum; s: Int16; t: Int16; r: Int16) := z_MultiTexCoord3s(target, s, t, r);
    
    ///OpenGL 3.0
    public z_MultiTexCoord3iv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord3iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: DummyEnum; v: array of Int32) := MultiTexCoord3iv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: DummyEnum; var v: Int32) := MultiTexCoord3iv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: DummyEnum; v: pointer) := z_MultiTexCoord3iv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord3i := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int32; t: Int32; r: Int32)>('glMultiTexCoord3i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3i(target: DummyEnum; s: Int32; t: Int32; r: Int32) := z_MultiTexCoord3i(target, s, t, r);
    
    ///OpenGL 3.0
    public z_MultiTexCoord3fv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: DummyEnum; v: array of single) := MultiTexCoord3fv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: DummyEnum; var v: single) := MultiTexCoord3fv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: DummyEnum; v: pointer) := z_MultiTexCoord3fv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord3f := GetGLFuncOrNil&<procedure(target: DummyEnum; s: single; t: single; r: single)>('glMultiTexCoord3f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3f(target: DummyEnum; s: single; t: single; r: single) := z_MultiTexCoord3f(target, s, t, r);
    
    ///OpenGL 3.0
    public z_MultiTexCoord3dv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: DummyEnum; v: array of double) := MultiTexCoord3dv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: DummyEnum; var v: double) := MultiTexCoord3dv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: DummyEnum; v: pointer) := z_MultiTexCoord3dv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord3d := GetGLFuncOrNil&<procedure(target: DummyEnum; s: double; t: double; r: double)>('glMultiTexCoord3d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3d(target: DummyEnum; s: double; t: double; r: double) := z_MultiTexCoord3d(target, s, t, r);
    
    ///OpenGL 3.0
    public z_MultiTexCoord2sv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord2sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: DummyEnum; v: array of Int16) := MultiTexCoord2sv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: DummyEnum; var v: Int16) := MultiTexCoord2sv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: DummyEnum; v: pointer) := z_MultiTexCoord2sv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord2s := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int16; t: Int16)>('glMultiTexCoord2s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2s(target: DummyEnum; s: Int16; t: Int16) := z_MultiTexCoord2s(target, s, t);
    
    ///OpenGL 3.0
    public z_MultiTexCoord2iv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord2iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: DummyEnum; v: array of Int32) := MultiTexCoord2iv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: DummyEnum; var v: Int32) := MultiTexCoord2iv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: DummyEnum; v: pointer) := z_MultiTexCoord2iv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord2i := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int32; t: Int32)>('glMultiTexCoord2i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2i(target: DummyEnum; s: Int32; t: Int32) := z_MultiTexCoord2i(target, s, t);
    
    ///OpenGL 3.0
    public z_MultiTexCoord2fv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: DummyEnum; v: array of single) := MultiTexCoord2fv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: DummyEnum; var v: single) := MultiTexCoord2fv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: DummyEnum; v: pointer) := z_MultiTexCoord2fv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord2f := GetGLFuncOrNil&<procedure(target: DummyEnum; s: single; t: single)>('glMultiTexCoord2f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2f(target: DummyEnum; s: single; t: single) := z_MultiTexCoord2f(target, s, t);
    
    ///OpenGL 3.0
    public z_MultiTexCoord2dv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: DummyEnum; v: array of double) := MultiTexCoord2dv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: DummyEnum; var v: double) := MultiTexCoord2dv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: DummyEnum; v: pointer) := z_MultiTexCoord2dv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord2d := GetGLFuncOrNil&<procedure(target: DummyEnum; s: double; t: double)>('glMultiTexCoord2d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2d(target: DummyEnum; s: double; t: double) := z_MultiTexCoord2d(target, s, t);
    
    ///OpenGL 3.0
    public z_MultiTexCoord1sv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord1sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: DummyEnum; v: array of Int16) := MultiTexCoord1sv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: DummyEnum; var v: Int16) := MultiTexCoord1sv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: DummyEnum; v: pointer) := z_MultiTexCoord1sv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord1s := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int16)>('glMultiTexCoord1s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1s(target: DummyEnum; s: Int16) := z_MultiTexCoord1s(target, s);
    
    ///OpenGL 3.0
    public z_MultiTexCoord1iv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord1iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: DummyEnum; v: array of Int32) := MultiTexCoord1iv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: DummyEnum; var v: Int32) := MultiTexCoord1iv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: DummyEnum; v: pointer) := z_MultiTexCoord1iv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord1i := GetGLFuncOrNil&<procedure(target: DummyEnum; s: Int32)>('glMultiTexCoord1i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1i(target: DummyEnum; s: Int32) := z_MultiTexCoord1i(target, s);
    
    ///OpenGL 3.0
    public z_MultiTexCoord1fv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord1fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: DummyEnum; v: array of single) := MultiTexCoord1fv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: DummyEnum; var v: single) := MultiTexCoord1fv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: DummyEnum; v: pointer) := z_MultiTexCoord1fv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord1f := GetGLFuncOrNil&<procedure(target: DummyEnum; s: single)>('glMultiTexCoord1f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1f(target: DummyEnum; s: single) := z_MultiTexCoord1f(target, s);
    
    ///OpenGL 3.0
    public z_MultiTexCoord1dv := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord1dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: DummyEnum; v: array of double) := MultiTexCoord1dv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: DummyEnum; var v: double) := MultiTexCoord1dv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: DummyEnum; v: pointer) := z_MultiTexCoord1dv(target, v);
    
    ///OpenGL 3.0
    public z_MultiTexCoord1d := GetGLFuncOrNil&<procedure(target: DummyEnum; s: double)>('glMultiTexCoord1d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1d(target: DummyEnum; s: double) := z_MultiTexCoord1d(target, s);
    
    private static procedure _Indexubv(v: pointer); external 'opengl32.dll' name 'glIndexubv';
    ///OpenGL 3.0
    public static z_Indexubv := _Indexubv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexubv(v: array of Byte) := Indexubv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexubv(var v: Byte) := Indexubv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexubv(v: pointer) := z_Indexubv(v);
    
    private static procedure _Indexub(v1: Byte); external 'opengl32.dll' name 'glIndexub';
    ///OpenGL 3.0
    public static z_Indexub := _Indexub;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexub(v1: Byte) := z_Indexub(v1);
    
    private static procedure _Indexsv(v: pointer); external 'opengl32.dll' name 'glIndexsv';
    ///OpenGL 3.0
    public static z_Indexsv := _Indexsv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexsv(v: array of Int16) := Indexsv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexsv(var v: Int16) := Indexsv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexsv(v: pointer) := z_Indexsv(v);
    
    private static procedure _Indexs(v1: Int16); external 'opengl32.dll' name 'glIndexs';
    ///OpenGL 3.0
    public static z_Indexs := _Indexs;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexs(v1: Int16) := z_Indexs(v1);
    
    private static procedure _Indexiv(v: pointer); external 'opengl32.dll' name 'glIndexiv';
    ///OpenGL 3.0
    public static z_Indexiv := _Indexiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexiv(v: array of Int32) := Indexiv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexiv(var v: Int32) := Indexiv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexiv(v: pointer) := z_Indexiv(v);
    
    private static procedure _Indexi(v1: Int32); external 'opengl32.dll' name 'glIndexi';
    ///OpenGL 3.0
    public static z_Indexi := _Indexi;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexi(v1: Int32) := z_Indexi(v1);
    
    private static procedure _Indexfv(v: pointer); external 'opengl32.dll' name 'glIndexfv';
    ///OpenGL 3.0
    public static z_Indexfv := _Indexfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexfv(v: array of single) := Indexfv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexfv(var v: single) := Indexfv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexfv(v: pointer) := z_Indexfv(v);
    
    private static procedure _Indexf(v1: single); external 'opengl32.dll' name 'glIndexf';
    ///OpenGL 3.0
    public static z_Indexf := _Indexf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexf(v1: single) := z_Indexf(v1);
    
    private static procedure _Indexdv(v: pointer); external 'opengl32.dll' name 'glIndexdv';
    ///OpenGL 3.0
    public static z_Indexdv := _Indexdv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexdv(v: array of double) := Indexdv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexdv(var v: double) := Indexdv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexdv(v: pointer) := z_Indexdv(v);
    
    private static procedure _Indexd(v1: double); external 'opengl32.dll' name 'glIndexd';
    ///OpenGL 3.0
    public static z_Indexd := _Indexd;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Indexd(v1: double) := z_Indexd(v1);
    
    ///OpenGL 3.0
    public z_FogCoordfv := GetGLFuncOrNil&<procedure(coord: pointer)>('glFogCoordfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(coord: array of single) := FogCoordfv(coord[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(var coord: single) := FogCoordfv(@coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(coord: pointer) := z_FogCoordfv(coord);
    
    ///OpenGL 3.0
    public z_FogCoordf := GetGLFuncOrNil&<procedure(coord: single)>('glFogCoordf');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordf(coord: single) := z_FogCoordf(coord);
    
    ///OpenGL 3.0
    public z_FogCoorddv := GetGLFuncOrNil&<procedure(coord: pointer)>('glFogCoorddv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(coord: array of double) := FogCoorddv(coord[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(var coord: double) := FogCoorddv(@coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(coord: pointer) := z_FogCoorddv(coord);
    
    ///OpenGL 3.0
    public z_FogCoordd := GetGLFuncOrNil&<procedure(coord: double)>('glFogCoordd');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordd(coord: double) := z_FogCoordd(coord);
    
    private static procedure _Color4usv(v: pointer); external 'opengl32.dll' name 'glColor4usv';
    ///OpenGL 3.0
    public static z_Color4usv := _Color4usv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4usv(v: array of UInt16) := Color4usv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4usv(var v: UInt16) := Color4usv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4usv(v: pointer) := z_Color4usv(v);
    
    private static procedure _Color4us(v1: UInt16; v2: UInt16; v3: UInt16; v4: UInt16); external 'opengl32.dll' name 'glColor4us';
    ///OpenGL 3.0
    public static z_Color4us := _Color4us;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4us(v1: UInt16; v2: UInt16; v3: UInt16; v4: UInt16) := z_Color4us(v1, v2, v3, v4);
    
    private static procedure _Color4uiv(v: pointer); external 'opengl32.dll' name 'glColor4uiv';
    ///OpenGL 3.0
    public static z_Color4uiv := _Color4uiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4uiv(v: array of UInt32) := Color4uiv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4uiv(var v: UInt32) := Color4uiv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4uiv(v: pointer) := z_Color4uiv(v);
    
    private static procedure _Color4ui(v1: UInt32; v2: UInt32; v3: UInt32; v4: UInt32); external 'opengl32.dll' name 'glColor4ui';
    ///OpenGL 3.0
    public static z_Color4ui := _Color4ui;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ui(v1: UInt32; v2: UInt32; v3: UInt32; v4: UInt32) := z_Color4ui(v1, v2, v3, v4);
    
    private static procedure _Color4ubv(v: pointer); external 'opengl32.dll' name 'glColor4ubv';
    ///OpenGL 3.0
    public static z_Color4ubv := _Color4ubv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubv(v: array of Byte) := Color4ubv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubv(var v: Byte) := Color4ubv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubv(v: pointer) := z_Color4ubv(v);
    
    private static procedure _Color4ub(red: Byte; green: Byte; blue: Byte; alpha: Byte); external 'opengl32.dll' name 'glColor4ub';
    ///OpenGL 3.0
    public static z_Color4ub := _Color4ub;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ub(red: Byte; green: Byte; blue: Byte; alpha: Byte) := z_Color4ub(red, green, blue, alpha);
    
    private static procedure _Color4sv(v: pointer); external 'opengl32.dll' name 'glColor4sv';
    ///OpenGL 3.0
    public static z_Color4sv := _Color4sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4sv(v: array of Int16) := Color4sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4sv(var v: Int16) := Color4sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4sv(v: pointer) := z_Color4sv(v);
    
    private static procedure _Color4s(v1: Int16; v2: Int16; v3: Int16; v4: Int16); external 'opengl32.dll' name 'glColor4s';
    ///OpenGL 3.0
    public static z_Color4s := _Color4s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4s(v1: Int16; v2: Int16; v3: Int16; v4: Int16) := z_Color4s(v1, v2, v3, v4);
    
    private static procedure _Color4iv(v: pointer); external 'opengl32.dll' name 'glColor4iv';
    ///OpenGL 3.0
    public static z_Color4iv := _Color4iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4iv(v: array of Int32) := Color4iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4iv(var v: Int32) := Color4iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4iv(v: pointer) := z_Color4iv(v);
    
    private static procedure _Color4i(v1: Int32; v2: Int32; v3: Int32; v4: Int32); external 'opengl32.dll' name 'glColor4i';
    ///OpenGL 3.0
    public static z_Color4i := _Color4i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4i(v1: Int32; v2: Int32; v3: Int32; v4: Int32) := z_Color4i(v1, v2, v3, v4);
    
    private static procedure _Color4fv(v: pointer); external 'opengl32.dll' name 'glColor4fv';
    ///OpenGL 3.0
    public static z_Color4fv := _Color4fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(v: array of single) := Color4fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(var v: single) := Color4fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(v: pointer) := z_Color4fv(v);
    
    private static procedure _Color4f(red: single; green: single; blue: single; alpha: single); external 'opengl32.dll' name 'glColor4f';
    ///OpenGL 3.0
    public static z_Color4f := _Color4f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4f(red: single; green: single; blue: single; alpha: single) := z_Color4f(red, green, blue, alpha);
    
    private static procedure _Color4dv(v: pointer); external 'opengl32.dll' name 'glColor4dv';
    ///OpenGL 3.0
    public static z_Color4dv := _Color4dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4dv(v: array of double) := Color4dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4dv(var v: double) := Color4dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4dv(v: pointer) := z_Color4dv(v);
    
    private static procedure _Color4d(v1: double; v2: double; v3: double; v4: double); external 'opengl32.dll' name 'glColor4d';
    ///OpenGL 3.0
    public static z_Color4d := _Color4d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4d(v1: double; v2: double; v3: double; v4: double) := z_Color4d(v1, v2, v3, v4);
    
    private static procedure _Color4bv(v: pointer); external 'opengl32.dll' name 'glColor4bv';
    ///OpenGL 3.0
    public static z_Color4bv := _Color4bv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4bv(v: array of SByte) := Color4bv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4bv(var v: SByte) := Color4bv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4bv(v: pointer) := z_Color4bv(v);
    
    private static procedure _Color4b(v1: SByte; v2: SByte; v3: SByte; v4: SByte); external 'opengl32.dll' name 'glColor4b';
    ///OpenGL 3.0
    public static z_Color4b := _Color4b;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4b(v1: SByte; v2: SByte; v3: SByte; v4: SByte) := z_Color4b(v1, v2, v3, v4);
    
    private static procedure _Color3usv(v: pointer); external 'opengl32.dll' name 'glColor3usv';
    ///OpenGL 3.0
    public static z_Color3usv := _Color3usv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3usv(v: array of UInt16) := Color3usv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3usv(var v: UInt16) := Color3usv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3usv(v: pointer) := z_Color3usv(v);
    
    private static procedure _Color3us(v1: UInt16; v2: UInt16; v3: UInt16); external 'opengl32.dll' name 'glColor3us';
    ///OpenGL 3.0
    public static z_Color3us := _Color3us;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3us(v1: UInt16; v2: UInt16; v3: UInt16) := z_Color3us(v1, v2, v3);
    
    private static procedure _Color3uiv(v: pointer); external 'opengl32.dll' name 'glColor3uiv';
    ///OpenGL 3.0
    public static z_Color3uiv := _Color3uiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3uiv(v: array of UInt32) := Color3uiv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3uiv(var v: UInt32) := Color3uiv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3uiv(v: pointer) := z_Color3uiv(v);
    
    private static procedure _Color3ui(v1: UInt32; v2: UInt32; v3: UInt32); external 'opengl32.dll' name 'glColor3ui';
    ///OpenGL 3.0
    public static z_Color3ui := _Color3ui;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ui(v1: UInt32; v2: UInt32; v3: UInt32) := z_Color3ui(v1, v2, v3);
    
    private static procedure _Color3ubv(v: pointer); external 'opengl32.dll' name 'glColor3ubv';
    ///OpenGL 3.0
    public static z_Color3ubv := _Color3ubv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ubv(v: array of Byte) := Color3ubv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ubv(var v: Byte) := Color3ubv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ubv(v: pointer) := z_Color3ubv(v);
    
    private static procedure _Color3ub(v1: Byte; v2: Byte; v3: Byte); external 'opengl32.dll' name 'glColor3ub';
    ///OpenGL 3.0
    public static z_Color3ub := _Color3ub;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3ub(v1: Byte; v2: Byte; v3: Byte) := z_Color3ub(v1, v2, v3);
    
    private static procedure _Color3sv(v: pointer); external 'opengl32.dll' name 'glColor3sv';
    ///OpenGL 3.0
    public static z_Color3sv := _Color3sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3sv(v: array of Int16) := Color3sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3sv(var v: Int16) := Color3sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3sv(v: pointer) := z_Color3sv(v);
    
    private static procedure _Color3s(v1: Int16; v2: Int16; v3: Int16); external 'opengl32.dll' name 'glColor3s';
    ///OpenGL 3.0
    public static z_Color3s := _Color3s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3s(v1: Int16; v2: Int16; v3: Int16) := z_Color3s(v1, v2, v3);
    
    private static procedure _Color3iv(v: pointer); external 'opengl32.dll' name 'glColor3iv';
    ///OpenGL 3.0
    public static z_Color3iv := _Color3iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3iv(v: array of Int32) := Color3iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3iv(var v: Int32) := Color3iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3iv(v: pointer) := z_Color3iv(v);
    
    private static procedure _Color3i(v1: Int32; v2: Int32; v3: Int32); external 'opengl32.dll' name 'glColor3i';
    ///OpenGL 3.0
    public static z_Color3i := _Color3i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3i(v1: Int32; v2: Int32; v3: Int32) := z_Color3i(v1, v2, v3);
    
    private static procedure _Color3fv(v: pointer); external 'opengl32.dll' name 'glColor3fv';
    ///OpenGL 3.0
    public static z_Color3fv := _Color3fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fv(v: array of single) := Color3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fv(var v: single) := Color3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fv(v: pointer) := z_Color3fv(v);
    
    private static procedure _Color3f(v1: single; v2: single; v3: single); external 'opengl32.dll' name 'glColor3f';
    ///OpenGL 3.0
    public static z_Color3f := _Color3f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3f(v1: single; v2: single; v3: single) := z_Color3f(v1, v2, v3);
    
    private static procedure _Color3dv(v: pointer); external 'opengl32.dll' name 'glColor3dv';
    ///OpenGL 3.0
    public static z_Color3dv := _Color3dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3dv(v: array of double) := Color3dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3dv(var v: double) := Color3dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3dv(v: pointer) := z_Color3dv(v);
    
    private static procedure _Color3d(v1: double; v2: double; v3: double); external 'opengl32.dll' name 'glColor3d';
    ///OpenGL 3.0
    public static z_Color3d := _Color3d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3d(v1: double; v2: double; v3: double) := z_Color3d(v1, v2, v3);
    
    private static procedure _Color3bv(v: pointer); external 'opengl32.dll' name 'glColor3bv';
    ///OpenGL 3.0
    public static z_Color3bv := _Color3bv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3bv(v: array of SByte) := Color3bv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3bv(var v: SByte) := Color3bv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3bv(v: pointer) := z_Color3bv(v);
    
    private static procedure _Color3b(v1: SByte; v2: SByte; v3: SByte); external 'opengl32.dll' name 'glColor3b';
    ///OpenGL 3.0
    public static z_Color3b := _Color3b;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3b(v1: SByte; v2: SByte; v3: SByte) := z_Color3b(v1, v2, v3);
    
    {$endregion 2.7 - Vertex Specification}
    
    {$region 2.8 - Vertex Arrays}
    
    private static procedure _VertexPointer(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer); external 'opengl32.dll' name 'glVertexPointer';
    ///OpenGL 3.0
    public static z_VertexPointer := _VertexPointer;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointer(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_VertexPointer(size, &type, stride, _pointer);
    
    private static procedure _TexCoordPointer(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer); external 'opengl32.dll' name 'glTexCoordPointer';
    ///OpenGL 3.0
    public static z_TexCoordPointer := _TexCoordPointer;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointer(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_TexCoordPointer(size, &type, stride, _pointer);
    
    ///OpenGL 3.0
    public z_SecondaryColorPointer := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glSecondaryColorPointer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointer(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_SecondaryColorPointer(size, &type, stride, _pointer);
    
    private static procedure _NormalPointer(&type: DummyEnum; stride: Int32; _pointer: pointer); external 'opengl32.dll' name 'glNormalPointer';
    ///OpenGL 3.0
    public static z_NormalPointer := _NormalPointer;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointer(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_NormalPointer(&type, stride, _pointer);
    
    private static procedure _InterleavedArrays(format: DummyEnum; stride: Int32; _pointer: pointer); external 'opengl32.dll' name 'glInterleavedArrays';
    ///OpenGL 3.0
    public static z_InterleavedArrays := _InterleavedArrays;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InterleavedArrays(format: DummyEnum; stride: Int32; _pointer: pointer) := z_InterleavedArrays(format, stride, _pointer);
    
    private static procedure _IndexPointer(&type: DummyEnum; stride: Int32; _pointer: pointer); external 'opengl32.dll' name 'glIndexPointer';
    ///OpenGL 3.0
    public static z_IndexPointer := _IndexPointer;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointer(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_IndexPointer(&type, stride, _pointer);
    
    ///OpenGL 3.0
    public z_FogCoordPointer := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>('glFogCoordPointer');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointer(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_FogCoordPointer(&type, stride, _pointer);
    
    private static procedure _EnableClientState(&array: DummyEnum); external 'opengl32.dll' name 'glEnableClientState';
    ///OpenGL 3.0
    public static z_EnableClientState := _EnableClientState;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientState(&array: DummyEnum) := z_EnableClientState(&array);
    
    private static procedure _EdgeFlagPointer(stride: Int32; _pointer: pointer); external 'opengl32.dll' name 'glEdgeFlagPointer';
    ///OpenGL 3.0
    public static z_EdgeFlagPointer := _EdgeFlagPointer;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointer(stride: Int32; _pointer: pointer) := z_EdgeFlagPointer(stride, _pointer);
    
    private static procedure _DisableClientState(&array: DummyEnum); external 'opengl32.dll' name 'glDisableClientState';
    ///OpenGL 3.0
    public static z_DisableClientState := _DisableClientState;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientState(&array: DummyEnum) := z_DisableClientState(&array);
    
    private static procedure _ColorPointer(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer); external 'opengl32.dll' name 'glColorPointer';
    ///OpenGL 3.0
    public static z_ColorPointer := _ColorPointer;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointer(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_ColorPointer(size, &type, stride, _pointer);
    
    ///OpenGL 3.0
    public z_ClientActiveTexture := GetGLFuncOrNil&<procedure(texture: DummyEnum)>('glClientActiveTexture');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveTexture(texture: DummyEnum) := z_ClientActiveTexture(texture);
    
    private static procedure _ArrayElement(i: Int32); external 'opengl32.dll' name 'glArrayElement';
    ///OpenGL 3.0
    public static z_ArrayElement := _ArrayElement;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayElement(i: Int32) := z_ArrayElement(i);
    
    {$endregion 2.8 - Vertex Arrays}
    
    {$region 2.11 - Rectangles}
    
    private static procedure _Rectsv(v: pointer); external 'opengl32.dll' name 'glRectsv';
    ///OpenGL 3.0
    public static z_Rectsv := _Rectsv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(v: array of Int16) := Rectsv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(var v: Int16) := Rectsv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectsv(v: pointer) := z_Rectsv(v);
    
    private static procedure _Rects(v1: Int16); external 'opengl32.dll' name 'glRects';
    ///OpenGL 3.0
    public static z_Rects := _Rects;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rects(v1: Int16) := z_Rects(v1);
    
    private static procedure _Rectiv(v: pointer); external 'opengl32.dll' name 'glRectiv';
    ///OpenGL 3.0
    public static z_Rectiv := _Rectiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(v: array of Int32) := Rectiv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(var v: Int32) := Rectiv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectiv(v: pointer) := z_Rectiv(v);
    
    private static procedure _Recti(v1: Int32); external 'opengl32.dll' name 'glRecti';
    ///OpenGL 3.0
    public static z_Recti := _Recti;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Recti(v1: Int32) := z_Recti(v1);
    
    private static procedure _Rectfv(v: pointer); external 'opengl32.dll' name 'glRectfv';
    ///OpenGL 3.0
    public static z_Rectfv := _Rectfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(v: array of single) := Rectfv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(var v: single) := Rectfv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectfv(v: pointer) := z_Rectfv(v);
    
    private static procedure _Rectf(v1: single); external 'opengl32.dll' name 'glRectf';
    ///OpenGL 3.0
    public static z_Rectf := _Rectf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectf(v1: single) := z_Rectf(v1);
    
    private static procedure _Rectdv(v: pointer); external 'opengl32.dll' name 'glRectdv';
    ///OpenGL 3.0
    public static z_Rectdv := _Rectdv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(v: array of double) := Rectdv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(var v: double) := Rectdv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectdv(v: pointer) := z_Rectdv(v);
    
    private static procedure _Rectd(v1: double); external 'opengl32.dll' name 'glRectd';
    ///OpenGL 3.0
    public static z_Rectd := _Rectd;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rectd(v1: double) := z_Rectd(v1);
    
    {$endregion 2.11 - Rectangles}
    
    {$region 2.12 - Coordinate Transformations}
    
    {$region 2.12.2 - Matrices}
    
    private static procedure _Translatef(x: single; y: single; z: single); external 'opengl32.dll' name 'glTranslatef';
    ///OpenGL 3.0
    public static z_Translatef := _Translatef;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Translatef(x: single; y: single; z: single) := z_Translatef(x, y, z);
    
    private static procedure _Translated(x: double; y: double; z: double); external 'opengl32.dll' name 'glTranslated';
    ///OpenGL 3.0
    public static z_Translated := _Translated;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Translated(x: double; y: double; z: double) := z_Translated(x, y, z);
    
    private static procedure _Scalef(x: single; y: single; z: single); external 'opengl32.dll' name 'glScalef';
    ///OpenGL 3.0
    public static z_Scalef := _Scalef;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Scalef(x: single; y: single; z: single) := z_Scalef(x, y, z);
    
    private static procedure _Scaled(x: double; y: double; z: double); external 'opengl32.dll' name 'glScaled';
    ///OpenGL 3.0
    public static z_Scaled := _Scaled;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Scaled(x: double; y: double; z: double) := z_Scaled(x, y, z);
    
    private static procedure _Rotatef(angle: single; x: single; y: single; z: single); external 'opengl32.dll' name 'glRotatef';
    ///OpenGL 3.0
    public static z_Rotatef := _Rotatef;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rotatef(angle: single; x: single; y: single; z: single) := z_Rotatef(angle, x, y, z);
    
    private static procedure _Rotated(angle: double; x: double; y: double; z: double); external 'opengl32.dll' name 'glRotated';
    ///OpenGL 3.0
    public static z_Rotated := _Rotated;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rotated(angle: double; x: double; y: double; z: double) := z_Rotated(angle, x, y, z);
    
    private static procedure _PushMatrix; external 'opengl32.dll' name 'glPushMatrix';
    ///OpenGL 3.0
    public static z_PushMatrix := _PushMatrix;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushMatrix := z_PushMatrix;
    
    private static procedure _PopMatrix; external 'opengl32.dll' name 'glPopMatrix';
    ///OpenGL 3.0
    public static z_PopMatrix := _PopMatrix;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopMatrix := z_PopMatrix;
    
    private static procedure _Ortho(left: double; right: double; bottom: double; top: double; nearVal: double; farVal: double); external 'opengl32.dll' name 'glOrtho';
    ///OpenGL 3.0
    public static z_Ortho := _Ortho;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Ortho(left: double; right: double; bottom: double; top: double; nearVal: double; farVal: double) := z_Ortho(left, right, bottom, top, nearVal, farVal);
    
    ///OpenGL 3.0
    public z_MultTransposeMatrixf := GetGLFuncOrNil&<procedure(m: pointer)>('glMultTransposeMatrixf');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(m: array of single) := MultTransposeMatrixf(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(var m: single) := MultTransposeMatrixf(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(m: pointer) := z_MultTransposeMatrixf(m);
    
    ///OpenGL 3.0
    public z_MultTransposeMatrixd := GetGLFuncOrNil&<procedure(m: pointer)>('glMultTransposeMatrixd');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(m: array of double) := MultTransposeMatrixd(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(var m: double) := MultTransposeMatrixd(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(m: pointer) := z_MultTransposeMatrixd(m);
    
    private static procedure _MultMatrixf(m: pointer); external 'opengl32.dll' name 'glMultMatrixf';
    ///OpenGL 3.0
    public static z_MultMatrixf := _MultMatrixf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(m: array of single) := MultMatrixf(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(var m: single) := MultMatrixf(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(m: pointer) := z_MultMatrixf(m);
    
    private static procedure _MultMatrixd(m: pointer); external 'opengl32.dll' name 'glMultMatrixd';
    ///OpenGL 3.0
    public static z_MultMatrixd := _MultMatrixd;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixd(m: array of double) := MultMatrixd(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixd(var m: double) := MultMatrixd(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixd(m: pointer) := z_MultMatrixd(m);
    
    private static procedure _MatrixMode(mode: DummyEnum); external 'opengl32.dll' name 'glMatrixMode';
    ///OpenGL 3.0
    public static z_MatrixMode := _MatrixMode;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMode(mode: DummyEnum) := z_MatrixMode(mode);
    
    ///OpenGL 3.0
    public z_LoadTransposeMatrixf := GetGLFuncOrNil&<procedure(m: pointer)>('glLoadTransposeMatrixf');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(m: array of single) := LoadTransposeMatrixf(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(var m: single) := LoadTransposeMatrixf(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(m: pointer) := z_LoadTransposeMatrixf(m);
    
    ///OpenGL 3.0
    public z_LoadTransposeMatrixd := GetGLFuncOrNil&<procedure(m: pointer)>('glLoadTransposeMatrixd');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(m: array of double) := LoadTransposeMatrixd(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(var m: double) := LoadTransposeMatrixd(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(m: pointer) := z_LoadTransposeMatrixd(m);
    
    private static procedure _LoadMatrixf(m: pointer); external 'opengl32.dll' name 'glLoadMatrixf';
    ///OpenGL 3.0
    public static z_LoadMatrixf := _LoadMatrixf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(m: array of single) := LoadMatrixf(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(var m: single) := LoadMatrixf(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(m: pointer) := z_LoadMatrixf(m);
    
    private static procedure _LoadMatrixd(m: pointer); external 'opengl32.dll' name 'glLoadMatrixd';
    ///OpenGL 3.0
    public static z_LoadMatrixd := _LoadMatrixd;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixd(m: array of double) := LoadMatrixd(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixd(var m: double) := LoadMatrixd(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixd(m: pointer) := z_LoadMatrixd(m);
    
    private static procedure _LoadIdentity; external 'opengl32.dll' name 'glLoadIdentity';
    ///OpenGL 3.0
    public static z_LoadIdentity := _LoadIdentity;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadIdentity := z_LoadIdentity;
    
    private static procedure _Frustum(left: double; right: double; bottom: double; top: double; nearVal: double; farVal: double); external 'opengl32.dll' name 'glFrustum';
    ///OpenGL 3.0
    public static z_Frustum := _Frustum;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Frustum(left: double; right: double; bottom: double; top: double; nearVal: double; farVal: double) := z_Frustum(left, right, bottom, top, nearVal, farVal);
    
    {$endregion 2.12.2 - Matrices}
    
    {$region 2.12.4 - Generating Texture Coordinates}
    
    private static procedure _TexGeniv(coord: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glTexGeniv';
    ///OpenGL 3.0
    public static z_TexGeniv := _TexGeniv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniv(coord: DummyEnum; pname: DummyEnum; &params: array of Int32) := TexGeniv(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniv(coord: DummyEnum; pname: DummyEnum; var &params: Int32) := TexGeniv(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniv(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexGeniv(coord, pname, &params);
    
    private static procedure _TexGeni(coord: DummyEnum; pname: DummyEnum; param: Int32); external 'opengl32.dll' name 'glTexGeni';
    ///OpenGL 3.0
    public static z_TexGeni := _TexGeni;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeni(coord: DummyEnum; pname: DummyEnum; param: Int32) := z_TexGeni(coord, pname, param);
    
    private static procedure _TexGenfv(coord: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glTexGenfv';
    ///OpenGL 3.0
    public static z_TexGenfv := _TexGenfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfv(coord: DummyEnum; pname: DummyEnum; &params: array of single) := TexGenfv(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfv(coord: DummyEnum; pname: DummyEnum; var &params: single) := TexGenfv(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfv(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexGenfv(coord, pname, &params);
    
    private static procedure _TexGenf(coord: DummyEnum; pname: DummyEnum; param: single); external 'opengl32.dll' name 'glTexGenf';
    ///OpenGL 3.0
    public static z_TexGenf := _TexGenf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenf(coord: DummyEnum; pname: DummyEnum; param: single) := z_TexGenf(coord, pname, param);
    
    private static procedure _TexGendv(coord: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glTexGendv';
    ///OpenGL 3.0
    public static z_TexGendv := _TexGendv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGendv(coord: DummyEnum; pname: DummyEnum; &params: array of double) := TexGendv(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGendv(coord: DummyEnum; pname: DummyEnum; var &params: double) := TexGendv(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGendv(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexGendv(coord, pname, &params);
    
    private static procedure _TexGend(coord: DummyEnum; pname: DummyEnum; param: double); external 'opengl32.dll' name 'glTexGend';
    ///OpenGL 3.0
    public static z_TexGend := _TexGend;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGend(coord: DummyEnum; pname: DummyEnum; param: double) := z_TexGend(coord, pname, param);
    
    {$endregion 2.12.4 - Generating Texture Coordinates}
    
    {$endregion 2.12 - Coordinate Transformations}
    
    {$region 2.17 - Clipping}
    
    private static procedure _ClipPlane(plane: DummyEnum; equation: pointer); external 'opengl32.dll' name 'glClipPlane';
    ///OpenGL 3.0
    public static z_ClipPlane := _ClipPlane;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlane(plane: DummyEnum; equation: array of double) := ClipPlane(plane, equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlane(plane: DummyEnum; var equation: double) := ClipPlane(plane, @equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlane(plane: DummyEnum; equation: pointer) := z_ClipPlane(plane, equation);
    
    {$endregion 2.17 - Clipping}
    
    {$region 2.18 - Current Raster Position}
    
    ///OpenGL 3.0
    public z_WindowPos3sv := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(v: array of Int16) := WindowPos3sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(var v: Int16) := WindowPos3sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(v: pointer) := z_WindowPos3sv(v);
    
    ///OpenGL 3.0
    public z_WindowPos3s := GetGLFuncOrNil&<procedure(x: Int16; y: Int16; z: Int16)>('glWindowPos3s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3s(x: Int16; y: Int16; z: Int16) := z_WindowPos3s(x, y, z);
    
    ///OpenGL 3.0
    public z_WindowPos3iv := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(v: array of Int32) := WindowPos3iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(var v: Int32) := WindowPos3iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(v: pointer) := z_WindowPos3iv(v);
    
    ///OpenGL 3.0
    public z_WindowPos3i := GetGLFuncOrNil&<procedure(x: Int32; y: Int32; z: Int32)>('glWindowPos3i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3i(x: Int32; y: Int32; z: Int32) := z_WindowPos3i(x, y, z);
    
    ///OpenGL 3.0
    public z_WindowPos3fv := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(v: array of single) := WindowPos3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(var v: single) := WindowPos3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(v: pointer) := z_WindowPos3fv(v);
    
    ///OpenGL 3.0
    public z_WindowPos3f := GetGLFuncOrNil&<procedure(x: single; y: single; z: single)>('glWindowPos3f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3f(x: single; y: single; z: single) := z_WindowPos3f(x, y, z);
    
    ///OpenGL 3.0
    public z_WindowPos3dv := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(v: array of double) := WindowPos3dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(var v: double) := WindowPos3dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(v: pointer) := z_WindowPos3dv(v);
    
    ///OpenGL 3.0
    public z_WindowPos3d := GetGLFuncOrNil&<procedure(x: double; y: double; z: double)>('glWindowPos3d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3d(x: double; y: double; z: double) := z_WindowPos3d(x, y, z);
    
    ///OpenGL 3.0
    public z_WindowPos2sv := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2sv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(v: array of Int16) := WindowPos2sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(var v: Int16) := WindowPos2sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(v: pointer) := z_WindowPos2sv(v);
    
    ///OpenGL 3.0
    public z_WindowPos2s := GetGLFuncOrNil&<procedure(x: Int16; y: Int16)>('glWindowPos2s');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2s(x: Int16; y: Int16) := z_WindowPos2s(x, y);
    
    ///OpenGL 3.0
    public z_WindowPos2iv := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2iv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(v: array of Int32) := WindowPos2iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(var v: Int32) := WindowPos2iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(v: pointer) := z_WindowPos2iv(v);
    
    ///OpenGL 3.0
    public z_WindowPos2i := GetGLFuncOrNil&<procedure(x: Int32; y: Int32)>('glWindowPos2i');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2i(x: Int32; y: Int32) := z_WindowPos2i(x, y);
    
    ///OpenGL 3.0
    public z_WindowPos2fv := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2fv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(v: array of single) := WindowPos2fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(var v: single) := WindowPos2fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(v: pointer) := z_WindowPos2fv(v);
    
    ///OpenGL 3.0
    public z_WindowPos2f := GetGLFuncOrNil&<procedure(x: single; y: single)>('glWindowPos2f');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2f(x: single; y: single) := z_WindowPos2f(x, y);
    
    ///OpenGL 3.0
    public z_WindowPos2dv := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2dv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(v: array of double) := WindowPos2dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(var v: double) := WindowPos2dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(v: pointer) := z_WindowPos2dv(v);
    
    ///OpenGL 3.0
    public z_WindowPos2d := GetGLFuncOrNil&<procedure(x: double; y: double)>('glWindowPos2d');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2d(x: double; y: double) := z_WindowPos2d(x, y);
    
    private static procedure _RasterPos4sv(v: pointer); external 'opengl32.dll' name 'glRasterPos4sv';
    ///OpenGL 3.0
    public static z_RasterPos4sv := _RasterPos4sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4sv(v: array of Int16) := RasterPos4sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4sv(var v: Int16) := RasterPos4sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4sv(v: pointer) := z_RasterPos4sv(v);
    
    private static procedure _RasterPos4s(v1: Int16; v2: Int16; v3: Int16; v4: Int16); external 'opengl32.dll' name 'glRasterPos4s';
    ///OpenGL 3.0
    public static z_RasterPos4s := _RasterPos4s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4s(v1: Int16; v2: Int16; v3: Int16; v4: Int16) := z_RasterPos4s(v1, v2, v3, v4);
    
    private static procedure _RasterPos4iv(v: pointer); external 'opengl32.dll' name 'glRasterPos4iv';
    ///OpenGL 3.0
    public static z_RasterPos4iv := _RasterPos4iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4iv(v: array of Int32) := RasterPos4iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4iv(var v: Int32) := RasterPos4iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4iv(v: pointer) := z_RasterPos4iv(v);
    
    private static procedure _RasterPos4i(v1: Int32; v2: Int32; v3: Int32; v4: Int32); external 'opengl32.dll' name 'glRasterPos4i';
    ///OpenGL 3.0
    public static z_RasterPos4i := _RasterPos4i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4i(v1: Int32; v2: Int32; v3: Int32; v4: Int32) := z_RasterPos4i(v1, v2, v3, v4);
    
    private static procedure _RasterPos4fv(v: pointer); external 'opengl32.dll' name 'glRasterPos4fv';
    ///OpenGL 3.0
    public static z_RasterPos4fv := _RasterPos4fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4fv(v: array of single) := RasterPos4fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4fv(var v: single) := RasterPos4fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4fv(v: pointer) := z_RasterPos4fv(v);
    
    private static procedure _RasterPos4f(v1: single; v2: single; v3: single; v4: single); external 'opengl32.dll' name 'glRasterPos4f';
    ///OpenGL 3.0
    public static z_RasterPos4f := _RasterPos4f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4f(v1: single; v2: single; v3: single; v4: single) := z_RasterPos4f(v1, v2, v3, v4);
    
    private static procedure _RasterPos4dv(v: pointer); external 'opengl32.dll' name 'glRasterPos4dv';
    ///OpenGL 3.0
    public static z_RasterPos4dv := _RasterPos4dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4dv(v: array of double) := RasterPos4dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4dv(var v: double) := RasterPos4dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4dv(v: pointer) := z_RasterPos4dv(v);
    
    private static procedure _RasterPos4d(v1: double; v2: double; v3: double; v4: double); external 'opengl32.dll' name 'glRasterPos4d';
    ///OpenGL 3.0
    public static z_RasterPos4d := _RasterPos4d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4d(v1: double; v2: double; v3: double; v4: double) := z_RasterPos4d(v1, v2, v3, v4);
    
    private static procedure _RasterPos3sv(v: pointer); external 'opengl32.dll' name 'glRasterPos3sv';
    ///OpenGL 3.0
    public static z_RasterPos3sv := _RasterPos3sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3sv(v: array of Int16) := RasterPos3sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3sv(var v: Int16) := RasterPos3sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3sv(v: pointer) := z_RasterPos3sv(v);
    
    private static procedure _RasterPos3s(v1: Int16; v2: Int16; v3: Int16); external 'opengl32.dll' name 'glRasterPos3s';
    ///OpenGL 3.0
    public static z_RasterPos3s := _RasterPos3s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3s(v1: Int16; v2: Int16; v3: Int16) := z_RasterPos3s(v1, v2, v3);
    
    private static procedure _RasterPos3iv(v: pointer); external 'opengl32.dll' name 'glRasterPos3iv';
    ///OpenGL 3.0
    public static z_RasterPos3iv := _RasterPos3iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3iv(v: array of Int32) := RasterPos3iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3iv(var v: Int32) := RasterPos3iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3iv(v: pointer) := z_RasterPos3iv(v);
    
    private static procedure _RasterPos3i(v1: Int32; v2: Int32; v3: Int32); external 'opengl32.dll' name 'glRasterPos3i';
    ///OpenGL 3.0
    public static z_RasterPos3i := _RasterPos3i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3i(v1: Int32; v2: Int32; v3: Int32) := z_RasterPos3i(v1, v2, v3);
    
    private static procedure _RasterPos3fv(v: pointer); external 'opengl32.dll' name 'glRasterPos3fv';
    ///OpenGL 3.0
    public static z_RasterPos3fv := _RasterPos3fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3fv(v: array of single) := RasterPos3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3fv(var v: single) := RasterPos3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3fv(v: pointer) := z_RasterPos3fv(v);
    
    private static procedure _RasterPos3f(x: single; y: single; z: single); external 'opengl32.dll' name 'glRasterPos3f';
    ///OpenGL 3.0
    public static z_RasterPos3f := _RasterPos3f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3f(x: single; y: single; z: single) := z_RasterPos3f(x, y, z);
    
    private static procedure _RasterPos3dv(v: pointer); external 'opengl32.dll' name 'glRasterPos3dv';
    ///OpenGL 3.0
    public static z_RasterPos3dv := _RasterPos3dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3dv(v: array of double) := RasterPos3dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3dv(var v: double) := RasterPos3dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3dv(v: pointer) := z_RasterPos3dv(v);
    
    private static procedure _RasterPos3d(v1: double; v2: double; v3: double); external 'opengl32.dll' name 'glRasterPos3d';
    ///OpenGL 3.0
    public static z_RasterPos3d := _RasterPos3d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3d(v1: double; v2: double; v3: double) := z_RasterPos3d(v1, v2, v3);
    
    private static procedure _RasterPos2sv(v: pointer); external 'opengl32.dll' name 'glRasterPos2sv';
    ///OpenGL 3.0
    public static z_RasterPos2sv := _RasterPos2sv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2sv(v: array of Int16) := RasterPos2sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2sv(var v: Int16) := RasterPos2sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2sv(v: pointer) := z_RasterPos2sv(v);
    
    private static procedure _RasterPos2s(v1: Int16; v2: Int16); external 'opengl32.dll' name 'glRasterPos2s';
    ///OpenGL 3.0
    public static z_RasterPos2s := _RasterPos2s;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2s(v1: Int16; v2: Int16) := z_RasterPos2s(v1, v2);
    
    private static procedure _RasterPos2iv(v: pointer); external 'opengl32.dll' name 'glRasterPos2iv';
    ///OpenGL 3.0
    public static z_RasterPos2iv := _RasterPos2iv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2iv(v: array of Int32) := RasterPos2iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2iv(var v: Int32) := RasterPos2iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2iv(v: pointer) := z_RasterPos2iv(v);
    
    private static procedure _RasterPos2i(v1: Int32; v2: Int32); external 'opengl32.dll' name 'glRasterPos2i';
    ///OpenGL 3.0
    public static z_RasterPos2i := _RasterPos2i;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2i(v1: Int32; v2: Int32) := z_RasterPos2i(v1, v2);
    
    private static procedure _RasterPos2fv(v: pointer); external 'opengl32.dll' name 'glRasterPos2fv';
    ///OpenGL 3.0
    public static z_RasterPos2fv := _RasterPos2fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2fv(v: array of single) := RasterPos2fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2fv(var v: single) := RasterPos2fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2fv(v: pointer) := z_RasterPos2fv(v);
    
    private static procedure _RasterPos2f(v1: single; v2: single); external 'opengl32.dll' name 'glRasterPos2f';
    ///OpenGL 3.0
    public static z_RasterPos2f := _RasterPos2f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2f(v1: single; v2: single) := z_RasterPos2f(v1, v2);
    
    private static procedure _RasterPos2dv(v: pointer); external 'opengl32.dll' name 'glRasterPos2dv';
    ///OpenGL 3.0
    public static z_RasterPos2dv := _RasterPos2dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2dv(v: array of double) := RasterPos2dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2dv(var v: double) := RasterPos2dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2dv(v: pointer) := z_RasterPos2dv(v);
    
    private static procedure _RasterPos2d(v1: double; v2: double); external 'opengl32.dll' name 'glRasterPos2d';
    ///OpenGL 3.0
    public static z_RasterPos2d := _RasterPos2d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2d(v1: double; v2: double) := z_RasterPos2d(v1, v2);
    
    {$endregion 2.18 - Current Raster Position}
    
    {$region 2.19 - Colors and Coloring}
    
    {$region 2.19.2 - Lighting Parameter Specification}
    
    private static procedure _Materialiv(face: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glMaterialiv';
    ///OpenGL 3.0
    public static z_Materialiv := _Materialiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialiv(face: DummyEnum; pname: DummyEnum; &params: array of Int32) := Materialiv(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialiv(face: DummyEnum; pname: DummyEnum; var &params: Int32) := Materialiv(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialiv(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_Materialiv(face, pname, &params);
    
    private static procedure _Materiali(face: DummyEnum; pname: DummyEnum; param: Int32); external 'opengl32.dll' name 'glMateriali';
    ///OpenGL 3.0
    public static z_Materiali := _Materiali;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materiali(face: DummyEnum; pname: DummyEnum; param: Int32) := z_Materiali(face, pname, param);
    
    private static procedure _Materialfv(face: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glMaterialfv';
    ///OpenGL 3.0
    public static z_Materialfv := _Materialfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: DummyEnum; pname: DummyEnum; &params: array of single) := Materialfv(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: DummyEnum; pname: DummyEnum; var &params: single) := Materialfv(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_Materialfv(face, pname, &params);
    
    private static procedure _Materialf(face: DummyEnum; pname: DummyEnum; param: single); external 'opengl32.dll' name 'glMaterialf';
    ///OpenGL 3.0
    public static z_Materialf := _Materialf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialf(face: DummyEnum; pname: DummyEnum; param: single) := z_Materialf(face, pname, param);
    
    private static procedure _LightModeliv(pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glLightModeliv';
    ///OpenGL 3.0
    public static z_LightModeliv := _LightModeliv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeliv(pname: DummyEnum; &params: array of Int32) := LightModeliv(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeliv(pname: DummyEnum; var &params: Int32) := LightModeliv(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeliv(pname: DummyEnum; &params: pointer) := z_LightModeliv(pname, &params);
    
    private static procedure _LightModeli(pname: DummyEnum; param: Int32); external 'opengl32.dll' name 'glLightModeli';
    ///OpenGL 3.0
    public static z_LightModeli := _LightModeli;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModeli(pname: DummyEnum; param: Int32) := z_LightModeli(pname, param);
    
    private static procedure _LightModelfv(pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glLightModelfv';
    ///OpenGL 3.0
    public static z_LightModelfv := _LightModelfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: DummyEnum; &params: array of single) := LightModelfv(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: DummyEnum; var &params: single) := LightModelfv(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: DummyEnum; &params: pointer) := z_LightModelfv(pname, &params);
    
    private static procedure _LightModelf(pname: DummyEnum; param: single); external 'opengl32.dll' name 'glLightModelf';
    ///OpenGL 3.0
    public static z_LightModelf := _LightModelf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelf(pname: DummyEnum; param: single) := z_LightModelf(pname, param);
    
    private static procedure _Lightiv(light: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glLightiv';
    ///OpenGL 3.0
    public static z_Lightiv := _Lightiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightiv(light: DummyEnum; pname: DummyEnum; &params: array of Int32) := Lightiv(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightiv(light: DummyEnum; pname: DummyEnum; var &params: Int32) := Lightiv(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightiv(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_Lightiv(light, pname, &params);
    
    private static procedure _Lighti(light: DummyEnum; pname: DummyEnum; param: Int32); external 'opengl32.dll' name 'glLighti';
    ///OpenGL 3.0
    public static z_Lighti := _Lighti;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lighti(light: DummyEnum; pname: DummyEnum; param: Int32) := z_Lighti(light, pname, param);
    
    private static procedure _Lightfv(light: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glLightfv';
    ///OpenGL 3.0
    public static z_Lightfv := _Lightfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: DummyEnum; pname: DummyEnum; &params: array of single) := Lightfv(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: DummyEnum; pname: DummyEnum; var &params: single) := Lightfv(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_Lightfv(light, pname, &params);
    
    private static procedure _Lightf(light: DummyEnum; pname: DummyEnum; param: single); external 'opengl32.dll' name 'glLightf';
    ///OpenGL 3.0
    public static z_Lightf := _Lightf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightf(light: DummyEnum; pname: DummyEnum; param: single) := z_Lightf(light, pname, param);
    
    {$endregion 2.19.2 - Lighting Parameter Specification}
    
    {$region 2.19.3 - ColorMaterial}
    
    private static procedure _ColorMaterial(face: DummyEnum; mode: DummyEnum); external 'opengl32.dll' name 'glColorMaterial';
    ///OpenGL 3.0
    public static z_ColorMaterial := _ColorMaterial;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaterial(face: DummyEnum; mode: DummyEnum) := z_ColorMaterial(face, mode);
    
    {$endregion 2.19.3 - ColorMaterial}
    
    {$region 2.19.7 - Flatshading}
    
    private static procedure _ShadeModel(mode: DummyEnum); external 'opengl32.dll' name 'glShadeModel';
    ///OpenGL 3.0
    public static z_ShadeModel := _ShadeModel;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadeModel(mode: DummyEnum) := z_ShadeModel(mode);
    
    {$endregion 2.19.7 - Flatshading}
    
    {$endregion 2.19 - Colors and Coloring}
    
    {$endregion 2 - OpenGL Operation}
    
    {$region 3 - Rasterization}
    
    {$region 3.5 - Line Segments}
    
    {$region 3.5.2 - Other Line Segment Features}
    
    private static procedure _LineStipple(factor: Int32; pattern: UInt16); external 'opengl32.dll' name 'glLineStipple';
    ///OpenGL 3.0
    public static z_LineStipple := _LineStipple;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineStipple(factor: Int32; pattern: UInt16) := z_LineStipple(factor, pattern);
    
    {$endregion 3.5.2 - Other Line Segment Features}
    
    {$endregion 3.5 - Line Segments}
    
    {$region 3.6 - Polygons}
    
    {$region 3.6.2 - Stippling}
    
    private static procedure _PolygonStipple(mask: pointer); external 'opengl32.dll' name 'glPolygonStipple';
    ///OpenGL 3.0
    public static z_PolygonStipple := _PolygonStipple;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(mask: array of Byte) := PolygonStipple(mask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(var mask: Byte) := PolygonStipple(@mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(mask: pointer) := z_PolygonStipple(mask);
    
    {$endregion 3.6.2 - Stippling}
    
    {$endregion 3.6 - Polygons}
    
    {$region 3.7 - Pixel Rectangles}
    
    {$region 3.7.3 - Pixel Transfer Modes}
    
    ///OpenGL 3.0
    public z_SeparableFilter2D := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer)>('glSeparableFilter2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SeparableFilter2D(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer) := z_SeparableFilter2D(target, internalformat, width, height, format, &type, row, column);
    
    private static procedure _PixelTransferi(pname: DummyEnum; param: Int32); external 'opengl32.dll' name 'glPixelTransferi';
    ///OpenGL 3.0
    public static z_PixelTransferi := _PixelTransferi;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransferi(pname: DummyEnum; param: Int32) := z_PixelTransferi(pname, param);
    
    private static procedure _PixelTransferf(pname: DummyEnum; param: single); external 'opengl32.dll' name 'glPixelTransferf';
    ///OpenGL 3.0
    public static z_PixelTransferf := _PixelTransferf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransferf(pname: DummyEnum; param: single) := z_PixelTransferf(pname, param);
    
    private static procedure _PixelMapusv(map: DummyEnum; mapsize: Int32; values: pointer); external 'opengl32.dll' name 'glPixelMapusv';
    ///OpenGL 3.0
    public static z_PixelMapusv := _PixelMapusv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapusv(map: DummyEnum; mapsize: Int32; values: array of UInt16) := PixelMapusv(map, mapsize, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapusv(map: DummyEnum; mapsize: Int32; var values: UInt16) := PixelMapusv(map, mapsize, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapusv(map: DummyEnum; mapsize: Int32; values: pointer) := z_PixelMapusv(map, mapsize, values);
    
    private static procedure _PixelMapuiv(map: DummyEnum; mapsize: Int32; values: pointer); external 'opengl32.dll' name 'glPixelMapuiv';
    ///OpenGL 3.0
    public static z_PixelMapuiv := _PixelMapuiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapuiv(map: DummyEnum; mapsize: Int32; values: array of UInt32) := PixelMapuiv(map, mapsize, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapuiv(map: DummyEnum; mapsize: Int32; var values: UInt32) := PixelMapuiv(map, mapsize, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapuiv(map: DummyEnum; mapsize: Int32; values: pointer) := z_PixelMapuiv(map, mapsize, values);
    
    private static procedure _PixelMapfv(map: DummyEnum; mapsize: Int32; values: pointer); external 'opengl32.dll' name 'glPixelMapfv';
    ///OpenGL 3.0
    public static z_PixelMapfv := _PixelMapfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapfv(map: DummyEnum; mapsize: Int32; values: array of single) := PixelMapfv(map, mapsize, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapfv(map: DummyEnum; mapsize: Int32; var values: single) := PixelMapfv(map, mapsize, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapfv(map: DummyEnum; mapsize: Int32; values: pointer) := z_PixelMapfv(map, mapsize, values);
    
    ///OpenGL 3.0
    public z_Minmax := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; sink: boolean)>('glMinmax');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Minmax(target: DummyEnum; internalformat: DummyEnum; sink: boolean) := z_Minmax(target, internalformat, sink);
    
    ///OpenGL 3.0
    public z_Histogram := GetGLFuncOrNil&<procedure(target: DummyEnum; width: Int32; internalformat: DummyEnum; sink: boolean)>('glHistogram');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Histogram(target: DummyEnum; width: Int32; internalformat: DummyEnum; sink: boolean) := z_Histogram(target, width, internalformat, sink);
    
    ///OpenGL 3.0
    public z_CopyConvolutionFilter2D := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyConvolutionFilter2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter2D(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyConvolutionFilter2D(target, internalformat, x, y, width, height);
    
    ///OpenGL 3.0
    public z_CopyConvolutionFilter1D := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32)>('glCopyConvolutionFilter1D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter1D(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32) := z_CopyConvolutionFilter1D(target, internalformat, x, y, width);
    
    ///OpenGL 3.0
    public z_CopyColorTable := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32)>('glCopyColorTable');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorTable(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32) := z_CopyColorTable(target, internalformat, x, y, width);
    
    ///OpenGL 3.0
    public z_CopyColorSubTable := GetGLFuncOrNil&<procedure(target: DummyEnum; start: Int32; x: Int32; y: Int32; width: Int32)>('glCopyColorSubTable');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorSubTable(target: DummyEnum; start: Int32; x: Int32; y: Int32; width: Int32) := z_CopyColorSubTable(target, start, x, y, width);
    
    ///OpenGL 3.0
    public z_ConvolutionParameteriv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glConvolutionParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := ConvolutionParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := ConvolutionParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ConvolutionParameteriv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_ConvolutionParameterfv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glConvolutionParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := ConvolutionParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := ConvolutionParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ConvolutionParameterfv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_ConvolutionFilter2D := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; image: pointer)>('glConvolutionFilter2D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter2D(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; image: pointer) := z_ConvolutionFilter2D(target, internalformat, width, height, format, &type, image);
    
    ///OpenGL 3.0
    public z_ConvolutionFilter1D := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; image: pointer)>('glConvolutionFilter1D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter1D(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; image: pointer) := z_ConvolutionFilter1D(target, internalformat, width, format, &type, image);
    
    ///OpenGL 3.0
    public z_ColorTableParameteriv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glColorTableParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := ColorTableParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := ColorTableParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ColorTableParameteriv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_ColorTableParameterfv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glColorTableParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := ColorTableParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := ColorTableParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ColorTableParameterfv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_ColorTable := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; table: pointer)>('glColorTable');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTable(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; table: pointer) := z_ColorTable(target, internalformat, width, format, &type, table);
    
    ///OpenGL 3.0
    public z_ColorSubTable := GetGLFuncOrNil&<procedure(target: DummyEnum; start: Int32; count: Int32; format: DummyEnum; &type: DummyEnum; data: pointer)>('glColorSubTable');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorSubTable(target: DummyEnum; start: Int32; count: Int32; format: DummyEnum; &type: DummyEnum; data: pointer) := z_ColorSubTable(target, start, count, format, &type, data);
    
    {$endregion 3.7.3 - Pixel Transfer Modes}
    
    {$region 3.7.4 - Rasterization of Pixel Rectangles}
    
    private static procedure _PixelZoom(xfactor: single; yfactor: single); external 'opengl32.dll' name 'glPixelZoom';
    ///OpenGL 3.0
    public static z_PixelZoom := _PixelZoom;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelZoom(xfactor: single; yfactor: single) := z_PixelZoom(xfactor, yfactor);
    
    private static procedure _DrawPixels(width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer); external 'opengl32.dll' name 'glDrawPixels';
    ///OpenGL 3.0
    public static z_DrawPixels := _DrawPixels;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawPixels(width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_DrawPixels(width, height, format, &type, pixels);
    
    {$endregion 3.7.4 - Rasterization of Pixel Rectangles}
    
    {$region 3.7.5 - Pixel Transfer Operations}
    
    ///OpenGL 3.0
    public z_ConvolutionParameteri := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: Int32)>('glConvolutionParameteri');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteri(target: DummyEnum; pname: DummyEnum; &params: Int32) := z_ConvolutionParameteri(target, pname, &params);
    
    ///OpenGL 3.0
    public z_ConvolutionParameterf := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: single)>('glConvolutionParameterf');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterf(target: DummyEnum; pname: DummyEnum; &params: single) := z_ConvolutionParameterf(target, pname, &params);
    
    {$endregion 3.7.5 - Pixel Transfer Operations}
    
    {$endregion 3.7 - Pixel Rectangles}
    
    {$region 3.8 - Bitmaps}
    
    private static procedure _Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; _bitmap: pointer); external 'opengl32.dll' name 'glBitmap';
    ///OpenGL 3.0
    public static z_Bitmap := _Bitmap;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; _bitmap: array of Byte) := Bitmap(width, height, xorig, yorig, xmove, ymove, _bitmap[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; var _bitmap: Byte) := Bitmap(width, height, xorig, yorig, xmove, ymove, @_bitmap);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; _bitmap: pointer) := z_Bitmap(width, height, xorig, yorig, xmove, ymove, _bitmap);
    
    {$endregion 3.8 - Bitmaps}
    
    {$region 3.9 - Texturing}
    
    {$region 3.9.12 - Texture Objects}
    
    private static procedure _PrioritizeTextures(n: Int32; textures: pointer; priorities: pointer); external 'opengl32.dll' name 'glPrioritizeTextures';
    ///OpenGL 3.0
    public static z_PrioritizeTextures := _PrioritizeTextures;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: array of UInt32; priorities: array of single) := PrioritizeTextures(n, textures[0], priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: array of UInt32; var priorities: single) := PrioritizeTextures(n, textures[0], @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: array of UInt32; priorities: pointer) := PrioritizeTextures(n, textures[0], priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; var textures: UInt32; priorities: array of single) := PrioritizeTextures(n, @textures, priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; var textures: UInt32; var priorities: single) := PrioritizeTextures(n, @textures, @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; var textures: UInt32; priorities: pointer) := PrioritizeTextures(n, @textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: pointer; priorities: array of single) := PrioritizeTextures(n, textures, priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: pointer; var priorities: single) := PrioritizeTextures(n, textures, @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTextures(n: Int32; textures: pointer; priorities: pointer) := z_PrioritizeTextures(n, textures, priorities);
    
    private static function _AreTexturesResident(n: Int32; textures: pointer; residences: pointer): boolean; external 'opengl32.dll' name 'glAreTexturesResident';
    ///OpenGL 3.0
    public static z_AreTexturesResident := _AreTexturesResident;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: array of UInt32; residences: array of boolean): boolean := AreTexturesResident(n, textures[0], residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: array of UInt32; var residences: boolean): boolean := AreTexturesResident(n, textures[0], @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: array of UInt32; residences: pointer): boolean := AreTexturesResident(n, textures[0], residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; var textures: UInt32; residences: array of boolean): boolean := AreTexturesResident(n, @textures, residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; var textures: UInt32; var residences: boolean): boolean := AreTexturesResident(n, @textures, @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; var textures: UInt32; residences: pointer): boolean := AreTexturesResident(n, @textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: pointer; residences: array of boolean): boolean := AreTexturesResident(n, textures, residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: pointer; var residences: boolean): boolean := AreTexturesResident(n, textures, @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResident(n: Int32; textures: pointer; residences: pointer): boolean := z_AreTexturesResident(n, textures, residences);
    
    {$endregion 3.9.12 - Texture Objects}
    
    {$region 3.9.13 - Texture Environments and Texture Functions}
    
    private static procedure _TexEnviv(target: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glTexEnviv';
    ///OpenGL 3.0
    public static z_TexEnviv := _TexEnviv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := TexEnviv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := TexEnviv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexEnviv(target, pname, &params);
    
    private static procedure _TexEnvi(target: DummyEnum; pname: DummyEnum; param: Int32); external 'opengl32.dll' name 'glTexEnvi';
    ///OpenGL 3.0
    public static z_TexEnvi := _TexEnvi;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvi(target: DummyEnum; pname: DummyEnum; param: Int32) := z_TexEnvi(target, pname, param);
    
    private static procedure _TexEnvfv(target: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glTexEnvfv';
    ///OpenGL 3.0
    public static z_TexEnvfv := _TexEnvfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := TexEnvfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: DummyEnum; pname: DummyEnum; var &params: single) := TexEnvfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexEnvfv(target, pname, &params);
    
    private static procedure _TexEnvf(target: DummyEnum; pname: DummyEnum; param: single); external 'opengl32.dll' name 'glTexEnvf';
    ///OpenGL 3.0
    public static z_TexEnvf := _TexEnvf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvf(target: DummyEnum; pname: DummyEnum; param: single) := z_TexEnvf(target, pname, param);
    
    {$endregion 3.9.13 - Texture Environments and Texture Functions}
    
    {$endregion 3.9 - Texturing}
    
    {$region 3.11 - Fog}
    
    private static procedure _Fogiv(pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glFogiv';
    ///OpenGL 3.0
    public static z_Fogiv := _Fogiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogiv(pname: DummyEnum; &params: array of Int32) := Fogiv(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogiv(pname: DummyEnum; var &params: Int32) := Fogiv(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogiv(pname: DummyEnum; &params: pointer) := z_Fogiv(pname, &params);
    
    private static procedure _Fogi(pname: DummyEnum; param: Int32); external 'opengl32.dll' name 'glFogi';
    ///OpenGL 3.0
    public static z_Fogi := _Fogi;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogi(pname: DummyEnum; param: Int32) := z_Fogi(pname, param);
    
    private static procedure _Fogfv(pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glFogfv';
    ///OpenGL 3.0
    public static z_Fogfv := _Fogfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: DummyEnum; &params: array of single) := Fogfv(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: DummyEnum; var &params: single) := Fogfv(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: DummyEnum; &params: pointer) := z_Fogfv(pname, &params);
    
    private static procedure _Fogf(pname: DummyEnum; param: single); external 'opengl32.dll' name 'glFogf';
    ///OpenGL 3.0
    public static z_Fogf := _Fogf;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogf(pname: DummyEnum; param: single) := z_Fogf(pname, param);
    
    {$endregion 3.11 - Fog}
    
    {$endregion 3 - Rasterization}
    
    {$region 4 - Per-Fragment Operations and the Framebuffer}
    
    {$region 4.1 - Per-Fragment Operations}
    
    {$region 4.1.4 - Alpha Test}
    
    private static procedure _AlphaFunc(func: DummyEnum; ref: single); external 'opengl32.dll' name 'glAlphaFunc';
    ///OpenGL 3.0
    public static z_AlphaFunc := _AlphaFunc;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFunc(func: DummyEnum; ref: single) := z_AlphaFunc(func, ref);
    
    {$endregion 4.1.4 - Alpha Test}
    
    {$endregion 4.1 - Per-Fragment Operations}
    
    {$region 4.2 - Whole Framebuffer Operations}
    
    {$region 4.2.2 - Fine Control of Buffer Updates}
    
    private static procedure _IndexMask(mask: UInt32); external 'opengl32.dll' name 'glIndexMask';
    ///OpenGL 3.0
    public static z_IndexMask := _IndexMask;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexMask(mask: UInt32) := z_IndexMask(mask);
    
    {$endregion 4.2.2 - Fine Control of Buffer Updates}
    
    {$region 4.2.3 - Clearing the Buffers}
    
    private static procedure _ClearIndex(c: single); external 'opengl32.dll' name 'glClearIndex';
    ///OpenGL 3.0
    public static z_ClearIndex := _ClearIndex;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearIndex(c: single) := z_ClearIndex(c);
    
    private static procedure _ClearAccum(red: single; green: single; blue: single; alpha: single); external 'opengl32.dll' name 'glClearAccum';
    ///OpenGL 3.0
    public static z_ClearAccum := _ClearAccum;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearAccum(red: single; green: single; blue: single; alpha: single) := z_ClearAccum(red, green, blue, alpha);
    
    {$endregion 4.2.3 - Clearing the Buffers}
    
    {$region 4.2.4 - The Accumulation Buffer}
    
    private static procedure _Accum(op: DummyEnum; value: single); external 'opengl32.dll' name 'glAccum';
    ///OpenGL 3.0
    public static z_Accum := _Accum;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Accum(op: DummyEnum; value: single) := z_Accum(op, value);
    
    {$endregion 4.2.4 - The Accumulation Buffer}
    
    {$endregion 4.2 - Whole Framebuffer Operations}
    
    {$region 4.3 - Drawing, Reading, and Copying Pixels}
    
    {$region 4.3.3 - Copying Pixels}
    
    private static procedure _CopyPixels(x: Int32; y: Int32; width: Int32; height: Int32; &type: DummyEnum); external 'opengl32.dll' name 'glCopyPixels';
    ///OpenGL 3.0
    public static z_CopyPixels := _CopyPixels;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyPixels(x: Int32; y: Int32; width: Int32; height: Int32; &type: DummyEnum) := z_CopyPixels(x, y, width, height, &type);
    
    {$endregion 4.3.3 - Copying Pixels}
    
    {$endregion 4.3 - Drawing, Reading, and Copying Pixels}
    
    {$endregion 4 - Per-Fragment Operations and the Framebuffer}
    
    {$region 5 - Special Functions}
    
    {$region 5.1 - Evaluators}
    
    private static procedure _MapGrid2f(un: Int32; u1: single; u2: single; vn: Int32; v1: single; v2: single); external 'opengl32.dll' name 'glMapGrid2f';
    ///OpenGL 3.0
    public static z_MapGrid2f := _MapGrid2f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid2f(un: Int32; u1: single; u2: single; vn: Int32; v1: single; v2: single) := z_MapGrid2f(un, u1, u2, vn, v1, v2);
    
    private static procedure _MapGrid2d(un: Int32; u1: double; u2: double; vn: Int32; v1: double; v2: double); external 'opengl32.dll' name 'glMapGrid2d';
    ///OpenGL 3.0
    public static z_MapGrid2d := _MapGrid2d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid2d(un: Int32; u1: double; u2: double; vn: Int32; v1: double; v2: double) := z_MapGrid2d(un, u1, u2, vn, v1, v2);
    
    private static procedure _MapGrid1f(un: Int32; u1: single; u2: single); external 'opengl32.dll' name 'glMapGrid1f';
    ///OpenGL 3.0
    public static z_MapGrid1f := _MapGrid1f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid1f(un: Int32; u1: single; u2: single) := z_MapGrid1f(un, u1, u2);
    
    private static procedure _MapGrid1d(un: Int32; u1: double; u2: double); external 'opengl32.dll' name 'glMapGrid1d';
    ///OpenGL 3.0
    public static z_MapGrid1d := _MapGrid1d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid1d(un: Int32; u1: double; u2: double) := z_MapGrid1d(un, u1, u2);
    
    private static procedure _Map2f(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: pointer); external 'opengl32.dll' name 'glMap2f';
    ///OpenGL 3.0
    public static z_Map2f := _Map2f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2f(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: array of single) := Map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2f(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single) := Map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2f(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: pointer) := z_Map2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    private static procedure _Map2d(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: pointer); external 'opengl32.dll' name 'glMap2d';
    ///OpenGL 3.0
    public static z_Map2d := _Map2d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2d(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: array of double) := Map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2d(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; var points: double) := Map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2d(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: pointer) := z_Map2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    private static procedure _Map1f(target: DummyEnum; u1: single; u2: single; stride: Int32; order: Int32; points: pointer); external 'opengl32.dll' name 'glMap1f';
    ///OpenGL 3.0
    public static z_Map1f := _Map1f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1f(target: DummyEnum; u1: single; u2: single; stride: Int32; order: Int32; points: array of single) := Map1f(target, u1, u2, stride, order, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1f(target: DummyEnum; u1: single; u2: single; stride: Int32; order: Int32; var points: single) := Map1f(target, u1, u2, stride, order, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1f(target: DummyEnum; u1: single; u2: single; stride: Int32; order: Int32; points: pointer) := z_Map1f(target, u1, u2, stride, order, points);
    
    private static procedure _Map1d(target: DummyEnum; u1: double; u2: double; stride: Int32; order: Int32; points: pointer); external 'opengl32.dll' name 'glMap1d';
    ///OpenGL 3.0
    public static z_Map1d := _Map1d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1d(target: DummyEnum; u1: double; u2: double; stride: Int32; order: Int32; points: array of double) := Map1d(target, u1, u2, stride, order, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1d(target: DummyEnum; u1: double; u2: double; stride: Int32; order: Int32; var points: double) := Map1d(target, u1, u2, stride, order, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1d(target: DummyEnum; u1: double; u2: double; stride: Int32; order: Int32; points: pointer) := z_Map1d(target, u1, u2, stride, order, points);
    
    private static procedure _EvalPoint2(i: Int32; j: Int32); external 'opengl32.dll' name 'glEvalPoint2';
    ///OpenGL 3.0
    public static z_EvalPoint2 := _EvalPoint2;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalPoint2(i: Int32; j: Int32) := z_EvalPoint2(i, j);
    
    private static procedure _EvalPoint1(i: Int32); external 'opengl32.dll' name 'glEvalPoint1';
    ///OpenGL 3.0
    public static z_EvalPoint1 := _EvalPoint1;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalPoint1(i: Int32) := z_EvalPoint1(i);
    
    private static procedure _EvalMesh2(mode: DummyEnum; i1: Int32; i2: Int32; j1: Int32; j2: Int32); external 'opengl32.dll' name 'glEvalMesh2';
    ///OpenGL 3.0
    public static z_EvalMesh2 := _EvalMesh2;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalMesh2(mode: DummyEnum; i1: Int32; i2: Int32; j1: Int32; j2: Int32) := z_EvalMesh2(mode, i1, i2, j1, j2);
    
    private static procedure _EvalMesh1(mode: DummyEnum; i1: Int32; i2: Int32); external 'opengl32.dll' name 'glEvalMesh1';
    ///OpenGL 3.0
    public static z_EvalMesh1 := _EvalMesh1;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalMesh1(mode: DummyEnum; i1: Int32; i2: Int32) := z_EvalMesh1(mode, i1, i2);
    
    private static procedure _EvalCoord2fv(v: pointer); external 'opengl32.dll' name 'glEvalCoord2fv';
    ///OpenGL 3.0
    public static z_EvalCoord2fv := _EvalCoord2fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2fv(v: array of single) := EvalCoord2fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2fv(var v: single) := EvalCoord2fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2fv(v: pointer) := z_EvalCoord2fv(v);
    
    private static procedure _EvalCoord2f(v1: single; v2: single); external 'opengl32.dll' name 'glEvalCoord2f';
    ///OpenGL 3.0
    public static z_EvalCoord2f := _EvalCoord2f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2f(v1: single; v2: single) := z_EvalCoord2f(v1, v2);
    
    private static procedure _EvalCoord2dv(v: pointer); external 'opengl32.dll' name 'glEvalCoord2dv';
    ///OpenGL 3.0
    public static z_EvalCoord2dv := _EvalCoord2dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2dv(v: array of double) := EvalCoord2dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2dv(var v: double) := EvalCoord2dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2dv(v: pointer) := z_EvalCoord2dv(v);
    
    private static procedure _EvalCoord2d(v1: double; v2: double); external 'opengl32.dll' name 'glEvalCoord2d';
    ///OpenGL 3.0
    public static z_EvalCoord2d := _EvalCoord2d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2d(v1: double; v2: double) := z_EvalCoord2d(v1, v2);
    
    private static procedure _EvalCoord1fv(v: pointer); external 'opengl32.dll' name 'glEvalCoord1fv';
    ///OpenGL 3.0
    public static z_EvalCoord1fv := _EvalCoord1fv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1fv(v: array of single) := EvalCoord1fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1fv(var v: single) := EvalCoord1fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1fv(v: pointer) := z_EvalCoord1fv(v);
    
    private static procedure _EvalCoord1f(v1: single); external 'opengl32.dll' name 'glEvalCoord1f';
    ///OpenGL 3.0
    public static z_EvalCoord1f := _EvalCoord1f;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1f(v1: single) := z_EvalCoord1f(v1);
    
    private static procedure _EvalCoord1dv(v: pointer); external 'opengl32.dll' name 'glEvalCoord1dv';
    ///OpenGL 3.0
    public static z_EvalCoord1dv := _EvalCoord1dv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1dv(v: array of double) := EvalCoord1dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1dv(var v: double) := EvalCoord1dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1dv(v: pointer) := z_EvalCoord1dv(v);
    
    private static procedure _EvalCoord1d(v1: double); external 'opengl32.dll' name 'glEvalCoord1d';
    ///OpenGL 3.0
    public static z_EvalCoord1d := _EvalCoord1d;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1d(v1: double) := z_EvalCoord1d(v1);
    
    {$endregion 5.1 - Evaluators}
    
    {$region 5.2 - Selection}
    
    private static procedure _SelectBuffer(size: Int32; buffer: pointer); external 'opengl32.dll' name 'glSelectBuffer';
    ///OpenGL 3.0
    public static z_SelectBuffer := _SelectBuffer;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectBuffer(size: Int32; buffer: array of UInt32) := SelectBuffer(size, buffer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectBuffer(size: Int32; var buffer: UInt32) := SelectBuffer(size, @buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectBuffer(size: Int32; buffer: pointer) := z_SelectBuffer(size, buffer);
    
    private static function _RenderMode(mode: DummyEnum): Int32; external 'opengl32.dll' name 'glRenderMode';
    ///OpenGL 3.0
    public static z_RenderMode := _RenderMode;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RenderMode(mode: DummyEnum): Int32 := z_RenderMode(mode);
    
    private static procedure _PushName(name: UInt32); external 'opengl32.dll' name 'glPushName';
    ///OpenGL 3.0
    public static z_PushName := _PushName;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushName(name: UInt32) := z_PushName(name);
    
    private static procedure _PopName; external 'opengl32.dll' name 'glPopName';
    ///OpenGL 3.0
    public static z_PopName := _PopName;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopName := z_PopName;
    
    private static procedure _LoadName(name: UInt32); external 'opengl32.dll' name 'glLoadName';
    ///OpenGL 3.0
    public static z_LoadName := _LoadName;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadName(name: UInt32) := z_LoadName(name);
    
    private static procedure _InitNames; external 'opengl32.dll' name 'glInitNames';
    ///OpenGL 3.0
    public static z_InitNames := _InitNames;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InitNames := z_InitNames;
    
    {$endregion 5.2 - Selection}
    
    {$region 5.3 - Feedback}
    
    private static procedure _PassThrough(token: single); external 'opengl32.dll' name 'glPassThrough';
    ///OpenGL 3.0
    public static z_PassThrough := _PassThrough;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassThrough(token: single) := z_PassThrough(token);
    
    private static procedure _FeedbackBuffer(size: Int32; &type: DummyEnum; buffer: pointer); external 'opengl32.dll' name 'glFeedbackBuffer';
    ///OpenGL 3.0
    public static z_FeedbackBuffer := _FeedbackBuffer;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBuffer(size: Int32; &type: DummyEnum; buffer: array of single) := FeedbackBuffer(size, &type, buffer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBuffer(size: Int32; &type: DummyEnum; var buffer: single) := FeedbackBuffer(size, &type, @buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBuffer(size: Int32; &type: DummyEnum; buffer: pointer) := z_FeedbackBuffer(size, &type, buffer);
    
    {$endregion 5.3 - Feedback}
    
    {$region 5.4 - Display Lists}
    
    private static procedure _NewList(list: UInt32; mode: DummyEnum); external 'opengl32.dll' name 'glNewList';
    ///OpenGL 3.0
    public static z_NewList := _NewList;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NewList(list: UInt32; mode: DummyEnum) := z_NewList(list, mode);
    
    private static procedure _ListBase(base: UInt32); external 'opengl32.dll' name 'glListBase';
    ///OpenGL 3.0
    public static z_ListBase := _ListBase;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListBase(base: UInt32) := z_ListBase(base);
    
    private static function _IsList(list: UInt32): boolean; external 'opengl32.dll' name 'glIsList';
    ///OpenGL 3.0
    public static z_IsList := _IsList;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsList(list: UInt32): boolean := z_IsList(list);
    
    private static function _GenLists(range: Int32): UInt32; external 'opengl32.dll' name 'glGenLists';
    ///OpenGL 3.0
    public static z_GenLists := _GenLists;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenLists(range: Int32): UInt32 := z_GenLists(range);
    
    private static procedure _EndList; external 'opengl32.dll' name 'glEndList';
    ///OpenGL 3.0
    public static z_EndList := _EndList;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndList := z_EndList;
    
    private static procedure _DeleteLists(list: UInt32; range: Int32); external 'opengl32.dll' name 'glDeleteLists';
    ///OpenGL 3.0
    public static z_DeleteLists := _DeleteLists;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteLists(list: UInt32; range: Int32) := z_DeleteLists(list, range);
    
    private static procedure _CallLists(n: Int32; &type: DummyEnum; lists: pointer); external 'opengl32.dll' name 'glCallLists';
    ///OpenGL 3.0
    public static z_CallLists := _CallLists;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallLists(n: Int32; &type: DummyEnum; lists: pointer) := z_CallLists(n, &type, lists);
    
    private static procedure _CallList(list: UInt32); external 'opengl32.dll' name 'glCallList';
    ///OpenGL 3.0
    public static z_CallList := _CallList;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallList(list: UInt32) := z_CallList(list);
    
    {$endregion 5.4 - Display Lists}
    
    {$endregion 5 - Special Functions}
    
    {$region 6 - State and State Requests}
    
    {$region 6.1 - Querying GL State}
    
    {$region 6.1.3 - Enumerated Queries}
    
    private static procedure _GetTexGeniv(coord: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glGetTexGeniv';
    ///OpenGL 3.0
    public static z_GetTexGeniv := _GetTexGeniv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGeniv(coord: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetTexGeniv(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGeniv(coord: DummyEnum; pname: DummyEnum; var &params: Int32) := GetTexGeniv(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGeniv(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexGeniv(coord, pname, &params);
    
    private static procedure _GetTexGenfv(coord: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glGetTexGenfv';
    ///OpenGL 3.0
    public static z_GetTexGenfv := _GetTexGenfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfv(coord: DummyEnum; pname: DummyEnum; &params: array of single) := GetTexGenfv(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfv(coord: DummyEnum; pname: DummyEnum; var &params: single) := GetTexGenfv(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfv(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexGenfv(coord, pname, &params);
    
    ///OpenGL 3.0
    public z_GetTexGendv := GetGLFuncOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexGendv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGendv(coord: DummyEnum; pname: DummyEnum; &params: array of double) := GetTexGendv(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGendv(coord: DummyEnum; pname: DummyEnum; var &params: double) := GetTexGendv(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGendv(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexGendv(coord, pname, &params);
    
    private static procedure _GetTexEnviv(target: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glGetTexEnviv';
    ///OpenGL 3.0
    public static z_GetTexEnviv := _GetTexEnviv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnviv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetTexEnviv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnviv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetTexEnviv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnviv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexEnviv(target, pname, &params);
    
    private static procedure _GetTexEnvfv(target: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glGetTexEnvfv';
    ///OpenGL 3.0
    public static z_GetTexEnvfv := _GetTexEnvfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetTexEnvfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvfv(target: DummyEnum; pname: DummyEnum; var &params: single) := GetTexEnvfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexEnvfv(target, pname, &params);
    
    private static procedure _GetPixelMapusv(map: DummyEnum; data: pointer); external 'opengl32.dll' name 'glGetPixelMapusv';
    ///OpenGL 3.0
    public static z_GetPixelMapusv := _GetPixelMapusv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapusv(map: DummyEnum; data: array of UInt16) := GetPixelMapusv(map, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapusv(map: DummyEnum; var data: UInt16) := GetPixelMapusv(map, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapusv(map: DummyEnum; data: pointer) := z_GetPixelMapusv(map, data);
    
    private static procedure _GetPixelMapuiv(map: DummyEnum; data: pointer); external 'opengl32.dll' name 'glGetPixelMapuiv';
    ///OpenGL 3.0
    public static z_GetPixelMapuiv := _GetPixelMapuiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapuiv(map: DummyEnum; data: array of UInt32) := GetPixelMapuiv(map, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapuiv(map: DummyEnum; var data: UInt32) := GetPixelMapuiv(map, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapuiv(map: DummyEnum; data: pointer) := z_GetPixelMapuiv(map, data);
    
    private static procedure _GetPixelMapfv(map: DummyEnum; data: pointer); external 'opengl32.dll' name 'glGetPixelMapfv';
    ///OpenGL 3.0
    public static z_GetPixelMapfv := _GetPixelMapfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapfv(map: DummyEnum; data: array of single) := GetPixelMapfv(map, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapfv(map: DummyEnum; var data: single) := GetPixelMapfv(map, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapfv(map: DummyEnum; data: pointer) := z_GetPixelMapfv(map, data);
    
    private static procedure _GetMaterialiv(face: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glGetMaterialiv';
    ///OpenGL 3.0
    public static z_GetMaterialiv := _GetMaterialiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialiv(face: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMaterialiv(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialiv(face: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMaterialiv(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialiv(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMaterialiv(face, pname, &params);
    
    private static procedure _GetMaterialfv(face: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glGetMaterialfv';
    ///OpenGL 3.0
    public static z_GetMaterialfv := _GetMaterialfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialfv(face: DummyEnum; pname: DummyEnum; &params: array of single) := GetMaterialfv(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialfv(face: DummyEnum; pname: DummyEnum; var &params: single) := GetMaterialfv(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialfv(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMaterialfv(face, pname, &params);
    
    private static procedure _GetMapiv(target: DummyEnum; query: DummyEnum; v: pointer); external 'opengl32.dll' name 'glGetMapiv';
    ///OpenGL 3.0
    public static z_GetMapiv := _GetMapiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapiv(target: DummyEnum; query: DummyEnum; v: array of Int32) := GetMapiv(target, query, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapiv(target: DummyEnum; query: DummyEnum; var v: Int32) := GetMapiv(target, query, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapiv(target: DummyEnum; query: DummyEnum; v: pointer) := z_GetMapiv(target, query, v);
    
    private static procedure _GetMapfv(target: DummyEnum; query: DummyEnum; v: pointer); external 'opengl32.dll' name 'glGetMapfv';
    ///OpenGL 3.0
    public static z_GetMapfv := _GetMapfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapfv(target: DummyEnum; query: DummyEnum; v: array of single) := GetMapfv(target, query, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapfv(target: DummyEnum; query: DummyEnum; var v: single) := GetMapfv(target, query, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapfv(target: DummyEnum; query: DummyEnum; v: pointer) := z_GetMapfv(target, query, v);
    
    private static procedure _GetMapdv(target: DummyEnum; query: DummyEnum; v: pointer); external 'opengl32.dll' name 'glGetMapdv';
    ///OpenGL 3.0
    public static z_GetMapdv := _GetMapdv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapdv(target: DummyEnum; query: DummyEnum; v: array of double) := GetMapdv(target, query, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapdv(target: DummyEnum; query: DummyEnum; var v: double) := GetMapdv(target, query, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapdv(target: DummyEnum; query: DummyEnum; v: pointer) := z_GetMapdv(target, query, v);
    
    private static procedure _GetLightiv(light: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glGetLightiv';
    ///OpenGL 3.0
    public static z_GetLightiv := _GetLightiv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightiv(light: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetLightiv(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightiv(light: DummyEnum; pname: DummyEnum; var &params: Int32) := GetLightiv(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightiv(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetLightiv(light, pname, &params);
    
    private static procedure _GetLightfv(light: DummyEnum; pname: DummyEnum; &params: pointer); external 'opengl32.dll' name 'glGetLightfv';
    ///OpenGL 3.0
    public static z_GetLightfv := _GetLightfv;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightfv(light: DummyEnum; pname: DummyEnum; &params: array of single) := GetLightfv(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightfv(light: DummyEnum; pname: DummyEnum; var &params: single) := GetLightfv(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightfv(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetLightfv(light, pname, &params);
    
    private static procedure _GetClipPlane(plane: DummyEnum; equation: pointer); external 'opengl32.dll' name 'glGetClipPlane';
    ///OpenGL 3.0
    public static z_GetClipPlane := _GetClipPlane;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlane(plane: DummyEnum; equation: array of double) := GetClipPlane(plane, equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlane(plane: DummyEnum; var equation: double) := GetClipPlane(plane, @equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlane(plane: DummyEnum; equation: pointer) := z_GetClipPlane(plane, equation);
    
    {$endregion 6.1.3 - Enumerated Queries}
    
    {$region 6.1.5 - Stipple Query}
    
    private static procedure _GetPolygonStipple(mask: pointer); external 'opengl32.dll' name 'glGetPolygonStipple';
    ///OpenGL 3.0
    public static z_GetPolygonStipple := _GetPolygonStipple;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPolygonStipple(mask: array of Byte) := GetPolygonStipple(mask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPolygonStipple(var mask: Byte) := GetPolygonStipple(@mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPolygonStipple(mask: pointer) := z_GetPolygonStipple(mask);
    
    {$endregion 6.1.5 - Stipple Query}
    
    {$region 6.1.7 - Color Table Query}
    
    ///OpenGL 3.0
    public z_GetColorTableParameteriv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetColorTableParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetColorTableParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetColorTableParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetColorTableParameteriv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_GetColorTableParameterfv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetColorTableParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetColorTableParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := GetColorTableParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetColorTableParameterfv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_GetColorTable := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; table: pointer)>('glGetColorTable');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTable(target: DummyEnum; format: DummyEnum; &type: DummyEnum; table: pointer) := z_GetColorTable(target, format, &type, table);
    
    {$endregion 6.1.7 - Color Table Query}
    
    {$region 6.1.8 - Convolution Query}
    
    ///OpenGL 3.0
    public z_GetSeparableFilter := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer; span: pointer)>('glGetSeparableFilter');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSeparableFilter(target: DummyEnum; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer; span: pointer) := z_GetSeparableFilter(target, format, &type, row, column, span);
    
    ///OpenGL 3.0
    public z_GetConvolutionParameteriv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetConvolutionParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetConvolutionParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetConvolutionParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetConvolutionParameteriv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_GetConvolutionParameterfv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetConvolutionParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetConvolutionParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := GetConvolutionParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetConvolutionParameterfv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_GetConvolutionFilter := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; image: pointer)>('glGetConvolutionFilter');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionFilter(target: DummyEnum; format: DummyEnum; &type: DummyEnum; image: pointer) := z_GetConvolutionFilter(target, format, &type, image);
    
    {$endregion 6.1.8 - Convolution Query}
    
    {$region 6.1.9 - Histogram Query}
    
    ///OpenGL 3.0
    public z_ResetHistogram := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glResetHistogram');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetHistogram(target: DummyEnum) := z_ResetHistogram(target);
    
    ///OpenGL 3.0
    public z_GetHistogramParameteriv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetHistogramParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetHistogramParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetHistogramParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetHistogramParameteriv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_GetHistogramParameterfv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetHistogramParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetHistogramParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := GetHistogramParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetHistogramParameterfv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_GetHistogram := GetGLFuncOrNil&<procedure(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; values: pointer)>('glGetHistogram');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogram(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; values: pointer) := z_GetHistogram(target, reset, format, &type, values);
    
    {$endregion 6.1.9 - Histogram Query}
    
    {$region 6.1.10 - Minmax Query}
    
    ///OpenGL 3.0
    public z_ResetMinmax := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glResetMinmax');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMinmax(target: DummyEnum) := z_ResetMinmax(target);
    
    ///OpenGL 3.0
    public z_GetMinmaxParameteriv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMinmaxParameteriv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMinmaxParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMinmaxParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMinmaxParameteriv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_GetMinmaxParameterfv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMinmaxParameterfv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetMinmaxParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := GetMinmaxParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMinmaxParameterfv(target, pname, &params);
    
    ///OpenGL 3.0
    public z_GetMinmax := GetGLFuncOrNil&<procedure(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; values: pointer)>('glGetMinmax');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmax(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; values: pointer) := z_GetMinmax(target, reset, format, &type, values);
    
    {$endregion 6.1.10 - Minmax Query}
    
    {$region 6.1.18 - Saving and Restoring State}
    
    private static procedure _PushClientAttrib(mask: DummyFlags); external 'opengl32.dll' name 'glPushClientAttrib';
    ///OpenGL 3.0
    public static z_PushClientAttrib := _PushClientAttrib;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushClientAttrib(mask: DummyFlags) := z_PushClientAttrib(mask);
    
    private static procedure _PushAttrib(mask: DummyFlags); external 'opengl32.dll' name 'glPushAttrib';
    ///OpenGL 3.0
    public static z_PushAttrib := _PushAttrib;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushAttrib(mask: DummyFlags) := z_PushAttrib(mask);
    
    private static procedure _PopClientAttrib; external 'opengl32.dll' name 'glPopClientAttrib';
    ///OpenGL 3.0
    public static z_PopClientAttrib := _PopClientAttrib;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopClientAttrib := z_PopClientAttrib;
    
    private static procedure _PopAttrib; external 'opengl32.dll' name 'glPopAttrib';
    ///OpenGL 3.0
    public static z_PopAttrib := _PopAttrib;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopAttrib := z_PopAttrib;
    
    {$endregion 6.1.18 - Saving and Restoring State}
    
    {$endregion 6.1 - Querying GL State}
    
    {$endregion 6 - State and State Requests}
    
  end;
  
  wgl = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    public z_CopyContext := GetGLFuncOrNil&<function(hglrcSrc: GLContext; hglrcDst: GLContext; mask: UInt32): UInt32>('wglCopyContext');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CopyContext(hglrcSrc: GLContext; hglrcDst: GLContext; mask: UInt32): UInt32 := z_CopyContext(hglrcSrc, hglrcDst, mask);
    
    public z_CopyImageSubDataNV := GetGLFuncOrNil&<function(hSrcRC: GLContext; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; hDstRC: GLContext; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32): UInt32>('wglCopyImageSubDataNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CopyImageSubDataNV(hSrcRC: GLContext; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; hDstRC: GLContext; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32): UInt32 := z_CopyImageSubDataNV(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
    private static function _CreateContext(hDc: GDI_DC): GLContext; external 'opengl32.dll' name 'wglCreateContext';
    public static z_CreateContext := _CreateContext;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContext(hDc: GDI_DC): GLContext := z_CreateContext(hDc);
    
    public z_CreateLayerContext := GetGLFuncOrNil&<function(hDc: GDI_DC; level: Int32): GLContext>('wglCreateLayerContext');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateLayerContext(hDc: GDI_DC; level: Int32): GLContext := z_CreateLayerContext(hDc, level);
    
    public z_DeleteContext := GetGLFuncOrNil&<function(oldContext: GLContext): UInt32>('wglDeleteContext');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteContext(oldContext: GLContext): UInt32 := z_DeleteContext(oldContext);
    
    public z_DescribeLayerPlane := GetGLFuncOrNil&<function(hDc: GDI_DC; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: pointer): UInt32>('wglDescribeLayerPlane');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DescribeLayerPlane(hDc: GDI_DC; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: array of GDI_LayerPlaneDescriptor): UInt32 := DescribeLayerPlane(hDc, pixelFormat, layerPlane, nBytes, plpd[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DescribeLayerPlane(hDc: GDI_DC; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; var plpd: GDI_LayerPlaneDescriptor): UInt32 := DescribeLayerPlane(hDc, pixelFormat, layerPlane, nBytes, @plpd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DescribeLayerPlane(hDc: GDI_DC; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: pointer): UInt32 := z_DescribeLayerPlane(hDc, pixelFormat, layerPlane, nBytes, plpd);
    
    public z_GetCurrentContext := GetGLFuncOrNil&<function: GLContext>('wglGetCurrentContext');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentContext: GLContext := z_GetCurrentContext;
    
    public z_GetCurrentDC := GetGLFuncOrNil&<function: GDI_DC>('wglGetCurrentDC');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentDC: GDI_DC := z_GetCurrentDC;
    
    public z_GetLayerPaletteEntries := GetGLFuncOrNil&<function(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: pointer): Int32>('wglGetLayerPaletteEntries');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: array of GDI_COLORREF): Int32 := GetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, pcr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: GDI_COLORREF): Int32 := GetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, @pcr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: pointer): Int32 := z_GetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, pcr);
    
    public z_GetProcAddress := GetGLFuncOrNil&<function(lpszProc: IntPtr): IntPtr>('wglGetProcAddress');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddress(lpszProc: string): IntPtr; begin var ptr_1 := Marshal.StringToHGlobalAnsi(lpszProc); Result := GetProcAddress(ptr_1); Marshal.FreeHGlobal(ptr_1); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddress(lpszProc: IntPtr): IntPtr := z_GetProcAddress(lpszProc);
    
    private static function _MakeCurrent(hDc: GDI_DC; newContext: GLContext): UInt32; external 'opengl32.dll' name 'wglMakeCurrent';
    public static z_MakeCurrent := _MakeCurrent;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeCurrent(hDc: GDI_DC; newContext: GLContext): UInt32 := z_MakeCurrent(hDc, newContext);
    
    public z_RealizeLayerPalette := GetGLFuncOrNil&<function(hdc: GDI_DC; iLayerPlane: Int32; bRealize: UInt32): UInt32>('wglRealizeLayerPalette');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RealizeLayerPalette(hdc: GDI_DC; iLayerPlane: Int32; bRealize: UInt32): UInt32 := z_RealizeLayerPalette(hdc, iLayerPlane, bRealize);
    
    public z_SetLayerPaletteEntries := GetGLFuncOrNil&<function(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: pointer): Int32>('wglSetLayerPaletteEntries');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: array of GDI_COLORREF): Int32 := SetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, pcr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: GDI_COLORREF): Int32 := SetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, @pcr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: pointer): Int32 := z_SetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, pcr);
    
    public z_ShareLists := GetGLFuncOrNil&<function(hrcSrvShare: GLContext; hrcSrvSource: GLContext): UInt32>('wglShareLists');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ShareLists(hrcSrvShare: GLContext; hrcSrvSource: GLContext): UInt32 := z_ShareLists(hrcSrvShare, hrcSrvSource);
    
    public z_SwapLayerBuffers := GetGLFuncOrNil&<function(hdc: GDI_DC; fuFlags: UInt32): UInt32>('wglSwapLayerBuffers');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapLayerBuffers(hdc: GDI_DC; fuFlags: UInt32): UInt32 := z_SwapLayerBuffers(hdc, fuFlags);
    
    public z_UseFontBitmaps := GetGLFuncOrNil&<function(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32): UInt32>('wglUseFontBitmaps');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontBitmaps(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32): UInt32 := z_UseFontBitmaps(hDC, first, count, listBase);
    
    public z_UseFontBitmapsA := GetGLFuncOrNil&<function(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32): UInt32>('wglUseFontBitmapsA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontBitmapsA(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32): UInt32 := z_UseFontBitmapsA(hDC, first, count, listBase);
    
    public z_UseFontBitmapsW := GetGLFuncOrNil&<function(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32): UInt32>('wglUseFontBitmapsW');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontBitmapsW(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32): UInt32 := z_UseFontBitmapsW(hDC, first, count, listBase);
    
    public z_UseFontOutlines := GetGLFuncOrNil&<function(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: pointer): UInt32>('wglUseFontOutlines');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlines(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: array of GDI_GlyphmetricsFloat): UInt32 := UseFontOutlines(hDC, first, count, listBase, deviation, extrusion, format, lpgmf[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlines(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; var lpgmf: GDI_GlyphmetricsFloat): UInt32 := UseFontOutlines(hDC, first, count, listBase, deviation, extrusion, format, @lpgmf);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlines(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: pointer): UInt32 := z_UseFontOutlines(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    
    public z_UseFontOutlinesA := GetGLFuncOrNil&<function(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: pointer): UInt32>('wglUseFontOutlinesA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlinesA(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: array of GDI_GlyphmetricsFloat): UInt32 := UseFontOutlinesA(hDC, first, count, listBase, deviation, extrusion, format, lpgmf[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlinesA(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; var lpgmf: GDI_GlyphmetricsFloat): UInt32 := UseFontOutlinesA(hDC, first, count, listBase, deviation, extrusion, format, @lpgmf);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlinesA(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: pointer): UInt32 := z_UseFontOutlinesA(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    
    public z_UseFontOutlinesW := GetGLFuncOrNil&<function(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: pointer): UInt32>('wglUseFontOutlinesW');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlinesW(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: array of GDI_GlyphmetricsFloat): UInt32 := UseFontOutlinesW(hDC, first, count, listBase, deviation, extrusion, format, lpgmf[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlinesW(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; var lpgmf: GDI_GlyphmetricsFloat): UInt32 := UseFontOutlinesW(hDC, first, count, listBase, deviation, extrusion, format, @lpgmf);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlinesW(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: pointer): UInt32 := z_UseFontOutlinesW(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    
    {$region NV_vertex_array_range}
    
    public z_VertexArrayRangeNV := GetGLFuncOrNil&<procedure(length: Int32; _pointer: pointer)>('glVertexArrayRangeNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayRangeNV(length: Int32; _pointer: pointer) := z_VertexArrayRangeNV(length, _pointer);
    
    public z_FlushVertexArrayRangeNV := GetGLFuncOrNil&<procedure>('glFlushVertexArrayRangeNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushVertexArrayRangeNV := z_FlushVertexArrayRangeNV;
    
    public z_AllocateMemoryNV := GetGLFuncOrNil&<function(size: Int32; readfreq: single; writefreq: single; priority: single): pointer>('wglAllocateMemoryNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AllocateMemoryNV(size: Int32; readfreq: single; writefreq: single; priority: single): pointer := z_AllocateMemoryNV(size, readfreq, writefreq, priority);
    
    public z_FreeMemoryNV := GetGLFuncOrNil&<procedure(_pointer: pointer)>('wglFreeMemoryNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeMemoryNV(_pointer: pointer) := z_FreeMemoryNV(_pointer);
    
    {$endregion NV_vertex_array_range}
    
    {$region WGL_I3D_image_buffer}
    
    public z_CreateImageBufferI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; dwSize: UInt32; uFlags: UInt32): IntPtr>('wglCreateImageBufferI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateImageBufferI3D(hDC: GDI_DC; dwSize: UInt32; uFlags: UInt32): IntPtr := z_CreateImageBufferI3D(hDC, dwSize, uFlags);
    
    public z_DestroyImageBufferI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; pAddress: IntPtr): UInt32>('wglDestroyImageBufferI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyImageBufferI3D(hDC: GDI_DC; pAddress: IntPtr): UInt32 := z_DestroyImageBufferI3D(hDC, pAddress);
    
    public z_AssociateImageBufferEventsI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; pEvent: pointer; pAddress: pointer; pSize: pointer; count: UInt32): UInt32>('wglAssociateImageBufferEventsI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: array of IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress[0], pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: array of IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress[0], @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: array of IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress[0], pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; var pAddress: IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], @pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], @pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; var pAddress: IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], @pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: pointer; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: pointer; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: pointer; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: array of IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress[0], pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: array of IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress[0], @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: array of IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress[0], pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; var pAddress: IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, @pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, @pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; var pAddress: IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, @pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: pointer; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: pointer; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: pointer; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: array of IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, pAddress[0], pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: array of IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, pAddress[0], @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: array of IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, pAddress[0], pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; var pAddress: IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, @pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, @pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; var pAddress: IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, @pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: pointer; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: pointer; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: pointer; pSize: pointer; count: UInt32): UInt32 := z_AssociateImageBufferEventsI3D(hDC, pEvent, pAddress, pSize, count);
    
    public z_ReleaseImageBufferEventsI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; pAddress: pointer; count: UInt32): UInt32>('wglReleaseImageBufferEventsI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: GDI_DC; pAddress: array of IntPtr; count: UInt32): UInt32 := ReleaseImageBufferEventsI3D(hDC, pAddress[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: GDI_DC; var pAddress: IntPtr; count: UInt32): UInt32 := ReleaseImageBufferEventsI3D(hDC, @pAddress, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: GDI_DC; pAddress: pointer; count: UInt32): UInt32 := z_ReleaseImageBufferEventsI3D(hDC, pAddress, count);
    
    {$endregion WGL_I3D_image_buffer}
    
    {$region WGL_I3D_swap_frame_usage}
    
    public z_GetFrameUsageI3D := GetGLFuncOrNil&<function(pUsage: pointer): UInt32>('wglGetFrameUsageI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFrameUsageI3D(pUsage: array of single): UInt32 := GetFrameUsageI3D(pUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFrameUsageI3D(var pUsage: single): UInt32 := GetFrameUsageI3D(@pUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFrameUsageI3D(pUsage: pointer): UInt32 := z_GetFrameUsageI3D(pUsage);
    
    public z_BeginFrameTrackingI3D := GetGLFuncOrNil&<function: UInt32>('wglBeginFrameTrackingI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BeginFrameTrackingI3D: UInt32 := z_BeginFrameTrackingI3D;
    
    public z_EndFrameTrackingI3D := GetGLFuncOrNil&<function: UInt32>('wglEndFrameTrackingI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EndFrameTrackingI3D: UInt32 := z_EndFrameTrackingI3D;
    
    public z_QueryFrameTrackingI3D := GetGLFuncOrNil&<function(pFrameCount: pointer; pMissedFrames: pointer; pLastMissedUsage: pointer): UInt32>('wglQueryFrameTrackingI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: array of UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames[0], pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: array of UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames[0], @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: array of UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames[0], pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; var pMissedFrames: UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], @pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; var pMissedFrames: UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], @pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; var pMissedFrames: UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], @pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: pointer; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: pointer; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: pointer; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: array of UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames[0], pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: array of UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames[0], @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: array of UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames[0], pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; var pMissedFrames: UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, @pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; var pMissedFrames: UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, @pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; var pMissedFrames: UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(@pFrameCount, @pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: pointer; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: pointer; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: pointer; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: array of UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount, pMissedFrames[0], pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: array of UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount, pMissedFrames[0], @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: array of UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(pFrameCount, pMissedFrames[0], pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; var pMissedFrames: UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount, @pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; var pMissedFrames: UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount, @pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; var pMissedFrames: UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(pFrameCount, @pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: pointer; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount, pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: pointer; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount, pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: pointer; pLastMissedUsage: pointer): UInt32 := z_QueryFrameTrackingI3D(pFrameCount, pMissedFrames, pLastMissedUsage);
    
    {$endregion WGL_I3D_swap_frame_usage}
    
    {$region NV_video_capture}
    
    public z_BeginVideoCaptureNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32)>('glBeginVideoCaptureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginVideoCaptureNV(video_capture_slot: UInt32) := z_BeginVideoCaptureNV(video_capture_slot);
    
    public z_BindVideoCaptureStreamBufferNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr)>('glBindVideoCaptureStreamBufferNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVideoCaptureStreamBufferNV(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr) := z_BindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
    
    public z_BindVideoCaptureStreamTextureNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: UInt32)>('glBindVideoCaptureStreamTextureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVideoCaptureStreamTextureNV(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: UInt32) := z_BindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
    
    public z_EndVideoCaptureNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32)>('glEndVideoCaptureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndVideoCaptureNV(video_capture_slot: UInt32) := z_EndVideoCaptureNV(video_capture_slot);
    
    public z_GetVideoCaptureivNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoCaptureivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; &params: array of Int32) := GetVideoCaptureivNV(video_capture_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; var &params: Int32) := GetVideoCaptureivNV(video_capture_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoCaptureivNV(video_capture_slot, pname, &params);
    
    public z_GetVideoCaptureStreamivNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoCaptureStreamivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of Int32) := GetVideoCaptureStreamivNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32) := GetVideoCaptureStreamivNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoCaptureStreamivNV(video_capture_slot, stream, pname, &params);
    
    public z_GetVideoCaptureStreamfvNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoCaptureStreamfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of single) := GetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single) := GetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, &params);
    
    public z_GetVideoCaptureStreamdvNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoCaptureStreamdvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of double) := GetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: double) := GetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, &params);
    
    public z_VideoCaptureNV := GetGLFuncOrNil&<function(video_capture_slot: UInt32; sequence_num: pointer; capture_time: pointer): DummyEnum>('glVideoCaptureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; capture_time: array of UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, sequence_num[0], capture_time[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; var capture_time: UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, sequence_num[0], @capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; capture_time: pointer): DummyEnum := VideoCaptureNV(video_capture_slot, sequence_num[0], capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; capture_time: array of UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, @sequence_num, capture_time[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; var capture_time: UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, @sequence_num, @capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; capture_time: pointer): DummyEnum := VideoCaptureNV(video_capture_slot, @sequence_num, capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: pointer; capture_time: array of UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, sequence_num, capture_time[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: pointer; var capture_time: UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, sequence_num, @capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: pointer; capture_time: pointer): DummyEnum := z_VideoCaptureNV(video_capture_slot, sequence_num, capture_time);
    
    public z_VideoCaptureStreamParameterivNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glVideoCaptureStreamParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of Int32) := VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32) := VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, &params);
    
    public z_VideoCaptureStreamParameterfvNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glVideoCaptureStreamParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of single) := VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single) := VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, &params);
    
    public z_VideoCaptureStreamParameterdvNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glVideoCaptureStreamParameterdvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of double) := VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: double) := VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, &params);
    
    public z_BindVideoCaptureDeviceNV := GetGLFuncOrNil&<function(uVideoSlot: UInt32; hDevice: VideoInputDeviceHandleNV): UInt32>('wglBindVideoCaptureDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoCaptureDeviceNV(uVideoSlot: UInt32; hDevice: VideoInputDeviceHandleNV): UInt32 := z_BindVideoCaptureDeviceNV(uVideoSlot, hDevice);
    
    public z_EnumerateVideoCaptureDevicesNV := GetGLFuncOrNil&<function(hDc: GDI_DC; phDeviceList: pointer): UInt32>('wglEnumerateVideoCaptureDevicesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(hDc: GDI_DC; phDeviceList: array of VideoInputDeviceHandleNV): UInt32 := EnumerateVideoCaptureDevicesNV(hDc, phDeviceList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(hDc: GDI_DC; var phDeviceList: VideoInputDeviceHandleNV): UInt32 := EnumerateVideoCaptureDevicesNV(hDc, @phDeviceList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(hDc: GDI_DC; phDeviceList: pointer): UInt32 := z_EnumerateVideoCaptureDevicesNV(hDc, phDeviceList);
    
    public z_LockVideoCaptureDeviceNV := GetGLFuncOrNil&<function(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV): UInt32>('wglLockVideoCaptureDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LockVideoCaptureDeviceNV(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV): UInt32 := z_LockVideoCaptureDeviceNV(hDc, hDevice);
    
    public z_QueryVideoCaptureDeviceNV := GetGLFuncOrNil&<function(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV; iAttribute: Int32; piValue: pointer): UInt32>('wglQueryVideoCaptureDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV; iAttribute: Int32; piValue: array of Int32): UInt32 := QueryVideoCaptureDeviceNV(hDc, hDevice, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV; iAttribute: Int32; var piValue: Int32): UInt32 := QueryVideoCaptureDeviceNV(hDc, hDevice, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV; iAttribute: Int32; piValue: pointer): UInt32 := z_QueryVideoCaptureDeviceNV(hDc, hDevice, iAttribute, piValue);
    
    public z_ReleaseVideoCaptureDeviceNV := GetGLFuncOrNil&<function(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV): UInt32>('wglReleaseVideoCaptureDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoCaptureDeviceNV(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV): UInt32 := z_ReleaseVideoCaptureDeviceNV(hDc, hDevice);
    
    {$endregion NV_video_capture}
    
    {$region NV_swap_group}
    
    public z_JoinSwapGroupNV := GetGLFuncOrNil&<function(hDC: GDI_DC; group: UInt32): UInt32>('wglJoinSwapGroupNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function JoinSwapGroupNV(hDC: GDI_DC; group: UInt32): UInt32 := z_JoinSwapGroupNV(hDC, group);
    
    public z_BindSwapBarrierNV := GetGLFuncOrNil&<function(group: UInt32; barrier: UInt32): UInt32>('wglBindSwapBarrierNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindSwapBarrierNV(group: UInt32; barrier: UInt32): UInt32 := z_BindSwapBarrierNV(group, barrier);
    
    public z_QuerySwapGroupNV := GetGLFuncOrNil&<function(hDC: GDI_DC; group: pointer; barrier: pointer): UInt32>('wglQuerySwapGroupNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: GDI_DC; group: array of UInt32; barrier: array of UInt32): UInt32 := QuerySwapGroupNV(hDC, group[0], barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: GDI_DC; group: array of UInt32; var barrier: UInt32): UInt32 := QuerySwapGroupNV(hDC, group[0], @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: GDI_DC; group: array of UInt32; barrier: pointer): UInt32 := QuerySwapGroupNV(hDC, group[0], barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: GDI_DC; var group: UInt32; barrier: array of UInt32): UInt32 := QuerySwapGroupNV(hDC, @group, barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: GDI_DC; var group: UInt32; var barrier: UInt32): UInt32 := QuerySwapGroupNV(hDC, @group, @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: GDI_DC; var group: UInt32; barrier: pointer): UInt32 := QuerySwapGroupNV(hDC, @group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: GDI_DC; group: pointer; barrier: array of UInt32): UInt32 := QuerySwapGroupNV(hDC, group, barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: GDI_DC; group: pointer; var barrier: UInt32): UInt32 := QuerySwapGroupNV(hDC, group, @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(hDC: GDI_DC; group: pointer; barrier: pointer): UInt32 := z_QuerySwapGroupNV(hDC, group, barrier);
    
    public z_QueryMaxSwapGroupsNV := GetGLFuncOrNil&<function(hDC: GDI_DC; maxGroups: pointer; maxBarriers: pointer): UInt32>('wglQueryMaxSwapGroupsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: array of UInt32; maxBarriers: array of UInt32): UInt32 := QueryMaxSwapGroupsNV(hDC, maxGroups[0], maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: array of UInt32; var maxBarriers: UInt32): UInt32 := QueryMaxSwapGroupsNV(hDC, maxGroups[0], @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: array of UInt32; maxBarriers: pointer): UInt32 := QueryMaxSwapGroupsNV(hDC, maxGroups[0], maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: GDI_DC; var maxGroups: UInt32; maxBarriers: array of UInt32): UInt32 := QueryMaxSwapGroupsNV(hDC, @maxGroups, maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: GDI_DC; var maxGroups: UInt32; var maxBarriers: UInt32): UInt32 := QueryMaxSwapGroupsNV(hDC, @maxGroups, @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: GDI_DC; var maxGroups: UInt32; maxBarriers: pointer): UInt32 := QueryMaxSwapGroupsNV(hDC, @maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: pointer; maxBarriers: array of UInt32): UInt32 := QueryMaxSwapGroupsNV(hDC, maxGroups, maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: pointer; var maxBarriers: UInt32): UInt32 := QueryMaxSwapGroupsNV(hDC, maxGroups, @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: pointer; maxBarriers: pointer): UInt32 := z_QueryMaxSwapGroupsNV(hDC, maxGroups, maxBarriers);
    
    public z_QueryFrameCountNV := GetGLFuncOrNil&<function(hDC: GDI_DC; count: pointer): UInt32>('wglQueryFrameCountNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(hDC: GDI_DC; count: array of UInt32): UInt32 := QueryFrameCountNV(hDC, count[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(hDC: GDI_DC; var count: UInt32): UInt32 := QueryFrameCountNV(hDC, @count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(hDC: GDI_DC; count: pointer): UInt32 := z_QueryFrameCountNV(hDC, count);
    
    public z_ResetFrameCountNV := GetGLFuncOrNil&<function(hDC: GDI_DC): UInt32>('wglResetFrameCountNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ResetFrameCountNV(hDC: GDI_DC): UInt32 := z_ResetFrameCountNV(hDC);
    
    {$endregion NV_swap_group}
    
    {$region ARB_render_texture}
    
    public z_BindTexImageARB := GetGLFuncOrNil&<function(hPbuffer: PBufferName; iBuffer: Int32): UInt32>('wglBindTexImageARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTexImageARB(hPbuffer: PBufferName; iBuffer: Int32): UInt32 := z_BindTexImageARB(hPbuffer, iBuffer);
    
    public z_ReleaseTexImageARB := GetGLFuncOrNil&<function(hPbuffer: PBufferName; iBuffer: Int32): UInt32>('wglReleaseTexImageARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseTexImageARB(hPbuffer: PBufferName; iBuffer: Int32): UInt32 := z_ReleaseTexImageARB(hPbuffer, iBuffer);
    
    public z_SetPbufferAttribARB := GetGLFuncOrNil&<function(hPbuffer: PBufferName; piAttribList: pointer): UInt32>('wglSetPbufferAttribARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: PBufferName; piAttribList: array of Int32): UInt32 := SetPbufferAttribARB(hPbuffer, piAttribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: PBufferName; var piAttribList: Int32): UInt32 := SetPbufferAttribARB(hPbuffer, @piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: PBufferName; piAttribList: pointer): UInt32 := z_SetPbufferAttribARB(hPbuffer, piAttribList);
    
    {$endregion ARB_render_texture}
    
    {$region NV_present_video}
    
    public z_PresentFrameKeyedNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32)>('glPresentFrameKeyedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PresentFrameKeyedNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32) := z_PresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, &type, target0, fill0, key0, target1, fill1, key1);
    
    public z_PresentFrameDualFillNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32)>('glPresentFrameDualFillNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PresentFrameDualFillNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32) := z_PresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, &type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    
    public z_GetVideoivNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoivNV(video_slot: UInt32; pname: DummyEnum; &params: array of Int32) := GetVideoivNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoivNV(video_slot: UInt32; pname: DummyEnum; var &params: Int32) := GetVideoivNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoivNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoivNV(video_slot, pname, &params);
    
    public z_GetVideouivNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideouivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideouivNV(video_slot: UInt32; pname: DummyEnum; &params: array of UInt32) := GetVideouivNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideouivNV(video_slot: UInt32; pname: DummyEnum; var &params: UInt32) := GetVideouivNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideouivNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideouivNV(video_slot, pname, &params);
    
    public z_GetVideoi64vNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoi64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; &params: array of Int64) := GetVideoi64vNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; var &params: Int64) := GetVideoi64vNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoi64vNV(video_slot, pname, &params);
    
    public z_GetVideoui64vNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; &params: array of UInt64) := GetVideoui64vNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; var &params: UInt64) := GetVideoui64vNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoui64vNV(video_slot, pname, &params);
    
    public z_EnumerateVideoDevicesNV := GetGLFuncOrNil&<function(hDc: GDI_DC; phDeviceList: pointer): Int32>('wglEnumerateVideoDevicesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(hDc: GDI_DC; phDeviceList: array of VideoOutputDeviceHandleNV): Int32 := EnumerateVideoDevicesNV(hDc, phDeviceList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(hDc: GDI_DC; var phDeviceList: VideoOutputDeviceHandleNV): Int32 := EnumerateVideoDevicesNV(hDc, @phDeviceList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(hDc: GDI_DC; phDeviceList: pointer): Int32 := z_EnumerateVideoDevicesNV(hDc, phDeviceList);
    
    public z_BindVideoDeviceNV := GetGLFuncOrNil&<function(hDc: GDI_DC; uVideoSlot: UInt32; hVideoDevice: VideoOutputDeviceHandleNV; piAttribList: pointer): UInt32>('wglBindVideoDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(hDc: GDI_DC; uVideoSlot: UInt32; hVideoDevice: VideoOutputDeviceHandleNV; piAttribList: array of Int32): UInt32 := BindVideoDeviceNV(hDc, uVideoSlot, hVideoDevice, piAttribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(hDc: GDI_DC; uVideoSlot: UInt32; hVideoDevice: VideoOutputDeviceHandleNV; var piAttribList: Int32): UInt32 := BindVideoDeviceNV(hDc, uVideoSlot, hVideoDevice, @piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(hDc: GDI_DC; uVideoSlot: UInt32; hVideoDevice: VideoOutputDeviceHandleNV; piAttribList: pointer): UInt32 := z_BindVideoDeviceNV(hDc, uVideoSlot, hVideoDevice, piAttribList);
    
    public z_QueryCurrentContextNV := GetGLFuncOrNil&<function(iAttribute: Int32; piValue: pointer): UInt32>('wglQueryCurrentContextNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentContextNV(iAttribute: Int32; piValue: array of Int32): UInt32 := QueryCurrentContextNV(iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentContextNV(iAttribute: Int32; var piValue: Int32): UInt32 := QueryCurrentContextNV(iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentContextNV(iAttribute: Int32; piValue: pointer): UInt32 := z_QueryCurrentContextNV(iAttribute, piValue);
    
    {$endregion NV_present_video}
    
    {$region NV_video_output}
    
    public z_GetVideoDeviceNV := GetGLFuncOrNil&<function(hDC: GDI_DC; numDevices: Int32; hVideoDevice: pointer): UInt32>('wglGetVideoDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(hDC: GDI_DC; numDevices: Int32; hVideoDevice: array of VideoDeviceHandleNV): UInt32 := GetVideoDeviceNV(hDC, numDevices, hVideoDevice[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(hDC: GDI_DC; numDevices: Int32; var hVideoDevice: VideoDeviceHandleNV): UInt32 := GetVideoDeviceNV(hDC, numDevices, @hVideoDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(hDC: GDI_DC; numDevices: Int32; hVideoDevice: pointer): UInt32 := z_GetVideoDeviceNV(hDC, numDevices, hVideoDevice);
    
    public z_ReleaseVideoDeviceNV := GetGLFuncOrNil&<function(hVideoDevice: VideoDeviceHandleNV): UInt32>('wglReleaseVideoDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoDeviceNV(hVideoDevice: VideoDeviceHandleNV): UInt32 := z_ReleaseVideoDeviceNV(hVideoDevice);
    
    public z_BindVideoImageNV := GetGLFuncOrNil&<function(hVideoDevice: VideoDeviceHandleNV; hPbuffer: PBufferName; iVideoBuffer: Int32): UInt32>('wglBindVideoImageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoImageNV(hVideoDevice: VideoDeviceHandleNV; hPbuffer: PBufferName; iVideoBuffer: Int32): UInt32 := z_BindVideoImageNV(hVideoDevice, hPbuffer, iVideoBuffer);
    
    public z_ReleaseVideoImageNV := GetGLFuncOrNil&<function(hPbuffer: PBufferName; iVideoBuffer: Int32): UInt32>('wglReleaseVideoImageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoImageNV(hPbuffer: PBufferName; iVideoBuffer: Int32): UInt32 := z_ReleaseVideoImageNV(hPbuffer, iVideoBuffer);
    
    public z_SendPbufferToVideoNV := GetGLFuncOrNil&<function(hPbuffer: PBufferName; iBufferType: Int32; pulCounterPbuffer: pointer; bBlock: UInt32): UInt32>('wglSendPbufferToVideoNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(hPbuffer: PBufferName; iBufferType: Int32; pulCounterPbuffer: array of UInt64; bBlock: UInt32): UInt32 := SendPbufferToVideoNV(hPbuffer, iBufferType, pulCounterPbuffer[0], bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(hPbuffer: PBufferName; iBufferType: Int32; var pulCounterPbuffer: UInt64; bBlock: UInt32): UInt32 := SendPbufferToVideoNV(hPbuffer, iBufferType, @pulCounterPbuffer, bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(hPbuffer: PBufferName; iBufferType: Int32; pulCounterPbuffer: pointer; bBlock: UInt32): UInt32 := z_SendPbufferToVideoNV(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
    
    public z_GetVideoInfoNV := GetGLFuncOrNil&<function(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: pointer): UInt32>('wglGetVideoInfoNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: array of UInt64; pulCounterOutputVideo: array of UInt64): UInt32 := GetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer[0], pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: array of UInt64; var pulCounterOutputVideo: UInt64): UInt32 := GetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer[0], @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: array of UInt64; pulCounterOutputVideo: pointer): UInt32 := GetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer[0], pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: array of UInt64): UInt32 := GetVideoInfoNV(hpVideoDevice, @pulCounterOutputPbuffer, pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; var pulCounterOutputPbuffer: UInt64; var pulCounterOutputVideo: UInt64): UInt32 := GetVideoInfoNV(hpVideoDevice, @pulCounterOutputPbuffer, @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: pointer): UInt32 := GetVideoInfoNV(hpVideoDevice, @pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: array of UInt64): UInt32 := GetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: pointer; var pulCounterOutputVideo: UInt64): UInt32 := GetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer, @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: pointer): UInt32 := z_GetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    
    {$endregion NV_video_output}
    
    {$region AMD_gpu_association}
    
    public z_GetGPUIDsAMD := GetGLFuncOrNil&<function(maxCount: UInt32; ids: pointer): UInt32>('wglGetGPUIDsAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; ids: array of UInt32): UInt32 := GetGPUIDsAMD(maxCount, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; var ids: UInt32): UInt32 := GetGPUIDsAMD(maxCount, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; ids: pointer): UInt32 := z_GetGPUIDsAMD(maxCount, ids);
    
    public z_GetGPUInfoAMD := GetGLFuncOrNil&<function(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: pointer): Int32>('wglGetGPUInfoAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUInfoAMD(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: pointer): Int32 := z_GetGPUInfoAMD(id, &property, dataType, size, data);
    
    public z_GetContextGPUIDAMD := GetGLFuncOrNil&<function(hglrc: GLContext): UInt32>('wglGetContextGPUIDAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetContextGPUIDAMD(hglrc: GLContext): UInt32 := z_GetContextGPUIDAMD(hglrc);
    
    public z_CreateAssociatedContextAMD := GetGLFuncOrNil&<function(id: UInt32): GLContext>('wglCreateAssociatedContextAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAMD(id: UInt32): GLContext := z_CreateAssociatedContextAMD(id);
    
    public z_CreateAssociatedContextAttribsAMD := GetGLFuncOrNil&<function(id: UInt32; hShareContext: GLContext; attribList: pointer): GLContext>('wglCreateAssociatedContextAttribsAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: GLContext; attribList: array of Int32): GLContext := CreateAssociatedContextAttribsAMD(id, hShareContext, attribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: GLContext; var attribList: Int32): GLContext := CreateAssociatedContextAttribsAMD(id, hShareContext, @attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: GLContext; attribList: pointer): GLContext := z_CreateAssociatedContextAttribsAMD(id, hShareContext, attribList);
    
    public z_DeleteAssociatedContextAMD := GetGLFuncOrNil&<function(hglrc: GLContext): UInt32>('wglDeleteAssociatedContextAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteAssociatedContextAMD(hglrc: GLContext): UInt32 := z_DeleteAssociatedContextAMD(hglrc);
    
    public z_MakeAssociatedContextCurrentAMD := GetGLFuncOrNil&<function(hglrc: GLContext): UInt32>('wglMakeAssociatedContextCurrentAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeAssociatedContextCurrentAMD(hglrc: GLContext): UInt32 := z_MakeAssociatedContextCurrentAMD(hglrc);
    
    public z_GetCurrentAssociatedContextAMD := GetGLFuncOrNil&<function: GLContext>('wglGetCurrentAssociatedContextAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentAssociatedContextAMD: GLContext := z_GetCurrentAssociatedContextAMD;
    
    public z_BlitContextFramebufferAMD := GetGLFuncOrNil&<procedure(dstCtx: GLContext; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>('wglBlitContextFramebufferAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitContextFramebufferAMD(dstCtx: GLContext; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := z_BlitContextFramebufferAMD(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    {$endregion AMD_gpu_association}
    
    {$region WGL_ARB_pixel_format}
    
    public z_GetPixelFormatAttribivARB := GetGLFuncOrNil&<function(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; piValues: pointer): UInt32>('wglGetPixelFormatAttribivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; piValues: array of Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], piValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; var piValues: Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], @piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; piValues: pointer): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; piValues: array of Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, piValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var piValues: Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, @piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; piValues: pointer): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; piValues: array of Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; var piValues: Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, @piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; piValues: pointer): UInt32 := z_GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    
    public z_GetPixelFormatAttribfvARB := GetGLFuncOrNil&<function(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; pfValues: pointer): UInt32>('wglGetPixelFormatAttribfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; pfValues: array of single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], pfValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; var pfValues: single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], @pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; pfValues: pointer): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; pfValues: array of single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, pfValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var pfValues: single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, @pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; pfValues: pointer): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; pfValues: array of single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; var pfValues: single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, @pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; pfValues: pointer): UInt32 := z_GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    
    public z_ChoosePixelFormatARB := GetGLFuncOrNil&<function(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32>('wglChoosePixelFormatARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := z_ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    
    {$endregion WGL_ARB_pixel_format}
    
    {$region EXT_pixel_format}
    
    public z_GetPixelFormatAttribivEXT := GetGLFuncOrNil&<function(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; piValues: pointer): UInt32>('wglGetPixelFormatAttribivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; piValues: array of Int32): UInt32 := GetPixelFormatAttribivEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], piValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; var piValues: Int32): UInt32 := GetPixelFormatAttribivEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], @piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; piValues: pointer): UInt32 := GetPixelFormatAttribivEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; piValues: array of Int32): UInt32 := GetPixelFormatAttribivEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, piValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var piValues: Int32): UInt32 := GetPixelFormatAttribivEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, @piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; piValues: pointer): UInt32 := GetPixelFormatAttribivEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; piValues: array of Int32): UInt32 := GetPixelFormatAttribivEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; var piValues: Int32): UInt32 := GetPixelFormatAttribivEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, @piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; piValues: pointer): UInt32 := z_GetPixelFormatAttribivEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    
    public z_GetPixelFormatAttribfvEXT := GetGLFuncOrNil&<function(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; pfValues: pointer): UInt32>('wglGetPixelFormatAttribfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; pfValues: array of single): UInt32 := GetPixelFormatAttribfvEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], pfValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; var pfValues: single): UInt32 := GetPixelFormatAttribfvEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], @pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; pfValues: pointer): UInt32 := GetPixelFormatAttribfvEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; pfValues: array of single): UInt32 := GetPixelFormatAttribfvEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, pfValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var pfValues: single): UInt32 := GetPixelFormatAttribfvEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, @pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; pfValues: pointer): UInt32 := GetPixelFormatAttribfvEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; pfValues: array of single): UInt32 := GetPixelFormatAttribfvEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; var pfValues: single): UInt32 := GetPixelFormatAttribfvEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, @pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvEXT(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; pfValues: pointer): UInt32 := z_GetPixelFormatAttribfvEXT(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    
    public z_ChoosePixelFormatEXT := GetGLFuncOrNil&<function(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32>('wglChoosePixelFormatEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatEXT(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := z_ChoosePixelFormatEXT(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    
    {$endregion EXT_pixel_format}
    
    {$region WGL_NV_gpu_affinity}
    
    public z_EnumGpusNV := GetGLFuncOrNil&<function(iGpuIndex: UInt32; phGpu: pointer): UInt32>('wglEnumGpusNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; phGpu: array of GPUAffinityHandle): UInt32 := EnumGpusNV(iGpuIndex, phGpu[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; var phGpu: GPUAffinityHandle): UInt32 := EnumGpusNV(iGpuIndex, @phGpu);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; phGpu: pointer): UInt32 := z_EnumGpusNV(iGpuIndex, phGpu);
    
    public z_EnumGpuDevicesNV := GetGLFuncOrNil&<function(hGpu: GPUAffinityHandle; iDeviceIndex: UInt32; lpGpuDevice: pointer): UInt32>('wglEnumGpuDevicesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: GPUAffinityHandle; iDeviceIndex: UInt32; lpGpuDevice: array of GPU_Device_Affinity_Info): UInt32 := EnumGpuDevicesNV(hGpu, iDeviceIndex, lpGpuDevice[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: GPUAffinityHandle; iDeviceIndex: UInt32; var lpGpuDevice: GPU_Device_Affinity_Info): UInt32 := EnumGpuDevicesNV(hGpu, iDeviceIndex, @lpGpuDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: GPUAffinityHandle; iDeviceIndex: UInt32; lpGpuDevice: pointer): UInt32 := z_EnumGpuDevicesNV(hGpu, iDeviceIndex, lpGpuDevice);
    
    public z_CreateAffinityDCNV := GetGLFuncOrNil&<function(phGpuList: pointer): GDI_DC>('wglCreateAffinityDCNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(phGpuList: array of GPUAffinityHandle): GDI_DC := CreateAffinityDCNV(phGpuList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(var phGpuList: GPUAffinityHandle): GDI_DC := CreateAffinityDCNV(@phGpuList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(phGpuList: pointer): GDI_DC := z_CreateAffinityDCNV(phGpuList);
    
    public z_EnumGpusFromAffinityDCNV := GetGLFuncOrNil&<function(hAffinityDC: GDI_DC; iGpuIndex: UInt32; hGpu: pointer): UInt32>('wglEnumGpusFromAffinityDCNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: GDI_DC; iGpuIndex: UInt32; hGpu: array of GPUAffinityHandle): UInt32 := EnumGpusFromAffinityDCNV(hAffinityDC, iGpuIndex, hGpu[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: GDI_DC; iGpuIndex: UInt32; var hGpu: GPUAffinityHandle): UInt32 := EnumGpusFromAffinityDCNV(hAffinityDC, iGpuIndex, @hGpu);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: GDI_DC; iGpuIndex: UInt32; hGpu: pointer): UInt32 := z_EnumGpusFromAffinityDCNV(hAffinityDC, iGpuIndex, hGpu);
    
    public z_DeleteDCNV := GetGLFuncOrNil&<function(hdc: GDI_DC): UInt32>('wglDeleteDCNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteDCNV(hdc: GDI_DC): UInt32 := z_DeleteDCNV(hdc);
    
    {$endregion WGL_NV_gpu_affinity}
    
    {$region WGL_ARB_buffer_region}
    
    public z_CreateBufferRegionARB := GetGLFuncOrNil&<function(hDC: GDI_DC; iLayerPlane: Int32; uType: UInt32): IntPtr>('wglCreateBufferRegionARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateBufferRegionARB(hDC: GDI_DC; iLayerPlane: Int32; uType: UInt32): IntPtr := z_CreateBufferRegionARB(hDC, iLayerPlane, uType);
    
    public z_DeleteBufferRegionARB := GetGLFuncOrNil&<procedure(hRegion: IntPtr)>('wglDeleteBufferRegionARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBufferRegionARB(hRegion: IntPtr) := z_DeleteBufferRegionARB(hRegion);
    
    public z_SaveBufferRegionARB := GetGLFuncOrNil&<function(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32): UInt32>('wglSaveBufferRegionARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SaveBufferRegionARB(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32): UInt32 := z_SaveBufferRegionARB(hRegion, x, y, width, height);
    
    public z_RestoreBufferRegionARB := GetGLFuncOrNil&<function(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32; xSrc: Int32; ySrc: Int32): UInt32>('wglRestoreBufferRegionARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RestoreBufferRegionARB(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32; xSrc: Int32; ySrc: Int32): UInt32 := z_RestoreBufferRegionARB(hRegion, x, y, width, height, xSrc, ySrc);
    
    {$endregion WGL_ARB_buffer_region}
    
    {$region WGL_ARB_create_context WGL_ARB_create_context_profile}
    
    public z_CreateContextAttribsARB := GetGLFuncOrNil&<function(hDC: GDI_DC; hShareContext: GLContext; attribList: pointer): GLContext>('wglCreateContextAttribsARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: GDI_DC; hShareContext: GLContext; attribList: array of Int32): GLContext := CreateContextAttribsARB(hDC, hShareContext, attribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: GDI_DC; hShareContext: GLContext; var attribList: Int32): GLContext := CreateContextAttribsARB(hDC, hShareContext, @attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: GDI_DC; hShareContext: GLContext; attribList: pointer): GLContext := z_CreateContextAttribsARB(hDC, hShareContext, attribList);
    
    {$endregion WGL_ARB_create_context WGL_ARB_create_context_profile}
    
    {$region WGL_ARB_pbuffer}
    
    public z_CreatePbufferARB := GetGLFuncOrNil&<function(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: pointer): PBufferName>('wglCreatePbufferARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: array of Int32): PBufferName := CreatePbufferARB(hDC, iPixelFormat, iWidth, iHeight, piAttribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): PBufferName := CreatePbufferARB(hDC, iPixelFormat, iWidth, iHeight, @piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: pointer): PBufferName := z_CreatePbufferARB(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    
    public z_GetPbufferDCARB := GetGLFuncOrNil&<function(hPbuffer: PBufferName): GDI_DC>('wglGetPbufferDCARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPbufferDCARB(hPbuffer: PBufferName): GDI_DC := z_GetPbufferDCARB(hPbuffer);
    
    public z_ReleasePbufferDCARB := GetGLFuncOrNil&<function(hPbuffer: PBufferName; hDC: GDI_DC): Int32>('wglReleasePbufferDCARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleasePbufferDCARB(hPbuffer: PBufferName; hDC: GDI_DC): Int32 := z_ReleasePbufferDCARB(hPbuffer, hDC);
    
    public z_DestroyPbufferARB := GetGLFuncOrNil&<function(hPbuffer: PBufferName): UInt32>('wglDestroyPbufferARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyPbufferARB(hPbuffer: PBufferName): UInt32 := z_DestroyPbufferARB(hPbuffer);
    
    public z_QueryPbufferARB := GetGLFuncOrNil&<function(hPbuffer: PBufferName; iAttribute: Int32; piValue: pointer): UInt32>('wglQueryPbufferARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: PBufferName; iAttribute: Int32; piValue: array of Int32): UInt32 := QueryPbufferARB(hPbuffer, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: PBufferName; iAttribute: Int32; var piValue: Int32): UInt32 := QueryPbufferARB(hPbuffer, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: PBufferName; iAttribute: Int32; piValue: pointer): UInt32 := z_QueryPbufferARB(hPbuffer, iAttribute, piValue);
    
    {$endregion WGL_ARB_pbuffer}
    
    {$region EXT_pbuffer}
    
    public z_CreatePbufferEXT := GetGLFuncOrNil&<function(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: pointer): PBufferName>('wglCreatePbufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferEXT(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: array of Int32): PBufferName := CreatePbufferEXT(hDC, iPixelFormat, iWidth, iHeight, piAttribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferEXT(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): PBufferName := CreatePbufferEXT(hDC, iPixelFormat, iWidth, iHeight, @piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferEXT(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: pointer): PBufferName := z_CreatePbufferEXT(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    
    public z_GetPbufferDCEXT := GetGLFuncOrNil&<function(hPbuffer: PBufferName): GDI_DC>('wglGetPbufferDCEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPbufferDCEXT(hPbuffer: PBufferName): GDI_DC := z_GetPbufferDCEXT(hPbuffer);
    
    public z_ReleasePbufferDCEXT := GetGLFuncOrNil&<function(hPbuffer: PBufferName; hDC: GDI_DC): Int32>('wglReleasePbufferDCEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleasePbufferDCEXT(hPbuffer: PBufferName; hDC: GDI_DC): Int32 := z_ReleasePbufferDCEXT(hPbuffer, hDC);
    
    public z_DestroyPbufferEXT := GetGLFuncOrNil&<function(hPbuffer: PBufferName): UInt32>('wglDestroyPbufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyPbufferEXT(hPbuffer: PBufferName): UInt32 := z_DestroyPbufferEXT(hPbuffer);
    
    public z_QueryPbufferEXT := GetGLFuncOrNil&<function(hPbuffer: PBufferName; iAttribute: Int32; piValue: pointer): UInt32>('wglQueryPbufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferEXT(hPbuffer: PBufferName; iAttribute: Int32; piValue: array of Int32): UInt32 := QueryPbufferEXT(hPbuffer, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferEXT(hPbuffer: PBufferName; iAttribute: Int32; var piValue: Int32): UInt32 := QueryPbufferEXT(hPbuffer, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferEXT(hPbuffer: PBufferName; iAttribute: Int32; piValue: pointer): UInt32 := z_QueryPbufferEXT(hPbuffer, iAttribute, piValue);
    
    {$endregion EXT_pbuffer}
    
    {$region NV_delay_before_swap}
    
    public z_DelayBeforeSwapNV := GetGLFuncOrNil&<function(hDC: GDI_DC; seconds: single): UInt32>('wglDelayBeforeSwapNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DelayBeforeSwapNV(hDC: GDI_DC; seconds: single): UInt32 := z_DelayBeforeSwapNV(hDC, seconds);
    
    {$endregion NV_delay_before_swap}
    
    {$region WGL_I3D_swap_frame_lock}
    
    public z_EnableFrameLockI3D := GetGLFuncOrNil&<function: UInt32>('wglEnableFrameLockI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnableFrameLockI3D: UInt32 := z_EnableFrameLockI3D;
    
    public z_DisableFrameLockI3D := GetGLFuncOrNil&<function: UInt32>('wglDisableFrameLockI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DisableFrameLockI3D: UInt32 := z_DisableFrameLockI3D;
    
    public z_IsEnabledFrameLockI3D := GetGLFuncOrNil&<function(pFlag: pointer): UInt32>('wglIsEnabledFrameLockI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(pFlag: array of UInt32): UInt32 := IsEnabledFrameLockI3D(pFlag[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(var pFlag: UInt32): UInt32 := IsEnabledFrameLockI3D(@pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(pFlag: pointer): UInt32 := z_IsEnabledFrameLockI3D(pFlag);
    
    public z_QueryFrameLockMasterI3D := GetGLFuncOrNil&<function(pFlag: pointer): UInt32>('wglQueryFrameLockMasterI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(pFlag: array of UInt32): UInt32 := QueryFrameLockMasterI3D(pFlag[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(var pFlag: UInt32): UInt32 := QueryFrameLockMasterI3D(@pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(pFlag: pointer): UInt32 := z_QueryFrameLockMasterI3D(pFlag);
    
    {$endregion WGL_I3D_swap_frame_lock}
    
    {$region WGL_I3D_genlock}
    
    public z_EnableGenlockI3D := GetGLFuncOrNil&<function(hDC: GDI_DC): UInt32>('wglEnableGenlockI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnableGenlockI3D(hDC: GDI_DC): UInt32 := z_EnableGenlockI3D(hDC);
    
    public z_DisableGenlockI3D := GetGLFuncOrNil&<function(hDC: GDI_DC): UInt32>('wglDisableGenlockI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DisableGenlockI3D(hDC: GDI_DC): UInt32 := z_DisableGenlockI3D(hDC);
    
    public z_IsEnabledGenlockI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; pFlag: pointer): UInt32>('wglIsEnabledGenlockI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: GDI_DC; pFlag: array of UInt32): UInt32 := IsEnabledGenlockI3D(hDC, pFlag[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: GDI_DC; var pFlag: UInt32): UInt32 := IsEnabledGenlockI3D(hDC, @pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: GDI_DC; pFlag: pointer): UInt32 := z_IsEnabledGenlockI3D(hDC, pFlag);
    
    public z_GenlockSourceI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; uSource: UInt32): UInt32>('wglGenlockSourceI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceI3D(hDC: GDI_DC; uSource: UInt32): UInt32 := z_GenlockSourceI3D(hDC, uSource);
    
    public z_GetGenlockSourceI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; uSource: pointer): UInt32>('wglGetGenlockSourceI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceI3D(hDC: GDI_DC; uSource: array of UInt32): UInt32 := GetGenlockSourceI3D(hDC, uSource[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceI3D(hDC: GDI_DC; var uSource: UInt32): UInt32 := GetGenlockSourceI3D(hDC, @uSource);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceI3D(hDC: GDI_DC; uSource: pointer): UInt32 := z_GetGenlockSourceI3D(hDC, uSource);
    
    public z_GenlockSourceEdgeI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; uEdge: UInt32): UInt32>('wglGenlockSourceEdgeI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceEdgeI3D(hDC: GDI_DC; uEdge: UInt32): UInt32 := z_GenlockSourceEdgeI3D(hDC, uEdge);
    
    public z_GetGenlockSourceEdgeI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; uEdge: pointer): UInt32>('wglGetGenlockSourceEdgeI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceEdgeI3D(hDC: GDI_DC; uEdge: array of UInt32): UInt32 := GetGenlockSourceEdgeI3D(hDC, uEdge[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceEdgeI3D(hDC: GDI_DC; var uEdge: UInt32): UInt32 := GetGenlockSourceEdgeI3D(hDC, @uEdge);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceEdgeI3D(hDC: GDI_DC; uEdge: pointer): UInt32 := z_GetGenlockSourceEdgeI3D(hDC, uEdge);
    
    public z_GenlockSampleRateI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; uRate: UInt32): UInt32>('wglGenlockSampleRateI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSampleRateI3D(hDC: GDI_DC; uRate: UInt32): UInt32 := z_GenlockSampleRateI3D(hDC, uRate);
    
    public z_GetGenlockSampleRateI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; uRate: pointer): UInt32>('wglGetGenlockSampleRateI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSampleRateI3D(hDC: GDI_DC; uRate: array of UInt32): UInt32 := GetGenlockSampleRateI3D(hDC, uRate[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSampleRateI3D(hDC: GDI_DC; var uRate: UInt32): UInt32 := GetGenlockSampleRateI3D(hDC, @uRate);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSampleRateI3D(hDC: GDI_DC; uRate: pointer): UInt32 := z_GetGenlockSampleRateI3D(hDC, uRate);
    
    public z_GenlockSourceDelayI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; uDelay: UInt32): UInt32>('wglGenlockSourceDelayI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceDelayI3D(hDC: GDI_DC; uDelay: UInt32): UInt32 := z_GenlockSourceDelayI3D(hDC, uDelay);
    
    public z_GetGenlockSourceDelayI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; uDelay: pointer): UInt32>('wglGetGenlockSourceDelayI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceDelayI3D(hDC: GDI_DC; uDelay: array of UInt32): UInt32 := GetGenlockSourceDelayI3D(hDC, uDelay[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceDelayI3D(hDC: GDI_DC; var uDelay: UInt32): UInt32 := GetGenlockSourceDelayI3D(hDC, @uDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceDelayI3D(hDC: GDI_DC; uDelay: pointer): UInt32 := z_GetGenlockSourceDelayI3D(hDC, uDelay);
    
    public z_QueryGenlockMaxSourceDelayI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; uMaxLineDelay: pointer; uMaxPixelDelay: pointer): UInt32>('wglQueryGenlockMaxSourceDelayI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: array of UInt32; uMaxPixelDelay: array of UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay[0], uMaxPixelDelay[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: array of UInt32; var uMaxPixelDelay: UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay[0], @uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: array of UInt32; uMaxPixelDelay: pointer): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay[0], uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; var uMaxLineDelay: UInt32; uMaxPixelDelay: array of UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, @uMaxLineDelay, uMaxPixelDelay[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; var uMaxLineDelay: UInt32; var uMaxPixelDelay: UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, @uMaxLineDelay, @uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; var uMaxLineDelay: UInt32; uMaxPixelDelay: pointer): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, @uMaxLineDelay, uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: pointer; uMaxPixelDelay: array of UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay, uMaxPixelDelay[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: pointer; var uMaxPixelDelay: UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay, @uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: pointer; uMaxPixelDelay: pointer): UInt32 := z_QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay, uMaxPixelDelay);
    
    {$endregion WGL_I3D_genlock}
    
    {$region NV_DX_interop}
    
    public z_DXSetResourceShareHandleNV := GetGLFuncOrNil&<function(dxObject: pointer; shareHandle: IntPtr): UInt32>('wglDXSetResourceShareHandleNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXSetResourceShareHandleNV(dxObject: pointer; shareHandle: IntPtr): UInt32 := z_DXSetResourceShareHandleNV(dxObject, shareHandle);
    
    public z_DXOpenDeviceNV := GetGLFuncOrNil&<function(dxDevice: pointer): IntPtr>('wglDXOpenDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXOpenDeviceNV(dxDevice: pointer): IntPtr := z_DXOpenDeviceNV(dxDevice);
    
    public z_DXCloseDeviceNV := GetGLFuncOrNil&<function(hDevice: IntPtr): UInt32>('wglDXCloseDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXCloseDeviceNV(hDevice: IntPtr): UInt32 := z_DXCloseDeviceNV(hDevice);
    
    public z_DXRegisterObjectNV := GetGLFuncOrNil&<function(hDevice: IntPtr; dxObject: pointer; name: UInt32; &type: DummyEnum; access: DummyEnum): IntPtr>('wglDXRegisterObjectNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXRegisterObjectNV(hDevice: IntPtr; dxObject: pointer; name: UInt32; &type: DummyEnum; access: DummyEnum): IntPtr := z_DXRegisterObjectNV(hDevice, dxObject, name, &type, access);
    
    public z_DXUnregisterObjectNV := GetGLFuncOrNil&<function(hDevice: IntPtr; hObject: IntPtr): UInt32>('wglDXUnregisterObjectNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnregisterObjectNV(hDevice: IntPtr; hObject: IntPtr): UInt32 := z_DXUnregisterObjectNV(hDevice, hObject);
    
    public z_DXObjectAccessNV := GetGLFuncOrNil&<function(hObject: IntPtr; access: DummyEnum): UInt32>('wglDXObjectAccessNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXObjectAccessNV(hObject: IntPtr; access: DummyEnum): UInt32 := z_DXObjectAccessNV(hObject, access);
    
    public z_DXLockObjectsNV := GetGLFuncOrNil&<function(hDevice: IntPtr; count: Int32; hObjects: pointer): UInt32>('wglDXLockObjectsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: array of IntPtr): UInt32 := DXLockObjectsNV(hDevice, count, hObjects[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): UInt32 := DXLockObjectsNV(hDevice, count, @hObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: pointer): UInt32 := z_DXLockObjectsNV(hDevice, count, hObjects);
    
    public z_DXUnlockObjectsNV := GetGLFuncOrNil&<function(hDevice: IntPtr; count: Int32; hObjects: pointer): UInt32>('wglDXUnlockObjectsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: array of IntPtr): UInt32 := DXUnlockObjectsNV(hDevice, count, hObjects[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): UInt32 := DXUnlockObjectsNV(hDevice, count, @hObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: pointer): UInt32 := z_DXUnlockObjectsNV(hDevice, count, hObjects);
    
    {$endregion NV_DX_interop}
    
    {$region WGL_ARB_make_current_read}
    
    public z_MakeContextCurrentARB := GetGLFuncOrNil&<function(hDrawDC: GDI_DC; hReadDC: GDI_DC; hglrc: GLContext): UInt32>('wglMakeContextCurrentARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeContextCurrentARB(hDrawDC: GDI_DC; hReadDC: GDI_DC; hglrc: GLContext): UInt32 := z_MakeContextCurrentARB(hDrawDC, hReadDC, hglrc);
    
    public z_GetCurrentReadDCARB := GetGLFuncOrNil&<function: GDI_DC>('wglGetCurrentReadDCARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDCARB: GDI_DC := z_GetCurrentReadDCARB;
    
    {$endregion WGL_ARB_make_current_read}
    
    {$region EXT_make_current_read}
    
    public z_MakeContextCurrentEXT := GetGLFuncOrNil&<function(hDrawDC: GDI_DC; hReadDC: GDI_DC; hglrc: GLContext): UInt32>('wglMakeContextCurrentEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeContextCurrentEXT(hDrawDC: GDI_DC; hReadDC: GDI_DC; hglrc: GLContext): UInt32 := z_MakeContextCurrentEXT(hDrawDC, hReadDC, hglrc);
    
    public z_GetCurrentReadDCEXT := GetGLFuncOrNil&<function: GDI_DC>('wglGetCurrentReadDCEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDCEXT: GDI_DC := z_GetCurrentReadDCEXT;
    
    {$endregion EXT_make_current_read}
    
    {$region WGL_I3D_digital_video_control}
    
    public z_GetDigitalVideoParametersI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32>('wglGetDigitalVideoParametersI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: array of Int32): UInt32 := GetDigitalVideoParametersI3D(hDC, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; var piValue: Int32): UInt32 := GetDigitalVideoParametersI3D(hDC, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := z_GetDigitalVideoParametersI3D(hDC, iAttribute, piValue);
    
    public z_SetDigitalVideoParametersI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32>('wglSetDigitalVideoParametersI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: array of Int32): UInt32 := SetDigitalVideoParametersI3D(hDC, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; var piValue: Int32): UInt32 := SetDigitalVideoParametersI3D(hDC, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := z_SetDigitalVideoParametersI3D(hDC, iAttribute, piValue);
    
    {$endregion WGL_I3D_digital_video_control}
    
    {$region WGL_ARB_extensions_string}
    
    public z_GetExtensionsStringARB := GetGLFuncOrNil&<function(hdc: GDI_DC): IntPtr>('wglGetExtensionsStringARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetExtensionsStringARB_Str(hdc: GDI_DC): string := Marshal.PtrToStringAnsi(GetExtensionsStringARB(hdc));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetExtensionsStringARB(hdc: GDI_DC): IntPtr := z_GetExtensionsStringARB(hdc);
    
    {$endregion WGL_ARB_extensions_string}
    
    {$region EXT_extensions_string}
    
    public z_GetExtensionsStringEXT := GetGLFuncOrNil&<function: IntPtr>('wglGetExtensionsStringEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetExtensionsStringEXT_Str: string := Marshal.PtrToStringAnsi(GetExtensionsStringEXT);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetExtensionsStringEXT: IntPtr := z_GetExtensionsStringEXT;
    
    {$endregion EXT_extensions_string}
    
    {$region WGL_I3D_gamma}
    
    public z_GetGammaTableParametersI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32>('wglGetGammaTableParametersI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: array of Int32): UInt32 := GetGammaTableParametersI3D(hDC, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; var piValue: Int32): UInt32 := GetGammaTableParametersI3D(hDC, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := z_GetGammaTableParametersI3D(hDC, iAttribute, piValue);
    
    public z_SetGammaTableParametersI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32>('wglSetGammaTableParametersI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: array of Int32): UInt32 := SetGammaTableParametersI3D(hDC, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; var piValue: Int32): UInt32 := SetGammaTableParametersI3D(hDC, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := z_SetGammaTableParametersI3D(hDC, iAttribute, piValue);
    
    public z_GetGammaTableI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: pointer): UInt32>('wglGetGammaTableI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: pointer): UInt32 := z_GetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue);
    
    public z_SetGammaTableI3D := GetGLFuncOrNil&<function(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: pointer): UInt32>('wglSetGammaTableI3D');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: pointer): UInt32 := z_SetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue);
    
    {$endregion WGL_I3D_gamma}
    
    {$region OML_sync_control}
    
    public z_GetSyncValuesOML := GetGLFuncOrNil&<function(hdc: GDI_DC; ust: pointer; msc: pointer; sbc: pointer): UInt32>('wglGetSyncValuesOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(hdc, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(hdc, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := GetSyncValuesOML(hdc, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(hdc, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(hdc, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := GetSyncValuesOML(hdc, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := GetSyncValuesOML(hdc, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := GetSyncValuesOML(hdc, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := GetSyncValuesOML(hdc, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(hdc, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(hdc, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := GetSyncValuesOML(hdc, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(hdc, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(hdc, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := GetSyncValuesOML(hdc, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := GetSyncValuesOML(hdc, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := GetSyncValuesOML(hdc, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := GetSyncValuesOML(hdc, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(hdc, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(hdc, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := GetSyncValuesOML(hdc, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(hdc, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(hdc, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := GetSyncValuesOML(hdc, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := GetSyncValuesOML(hdc, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := GetSyncValuesOML(hdc, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_GetSyncValuesOML(hdc, ust, msc, sbc);
    
    public z_GetMscRateOML := GetGLFuncOrNil&<function(hdc: GDI_DC; numerator: pointer; denominator: pointer): UInt32>('wglGetMscRateOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: GDI_DC; numerator: array of Int32; denominator: array of Int32): UInt32 := GetMscRateOML(hdc, numerator[0], denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: GDI_DC; numerator: array of Int32; var denominator: Int32): UInt32 := GetMscRateOML(hdc, numerator[0], @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: GDI_DC; numerator: array of Int32; denominator: pointer): UInt32 := GetMscRateOML(hdc, numerator[0], denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: GDI_DC; var numerator: Int32; denominator: array of Int32): UInt32 := GetMscRateOML(hdc, @numerator, denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: GDI_DC; var numerator: Int32; var denominator: Int32): UInt32 := GetMscRateOML(hdc, @numerator, @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: GDI_DC; var numerator: Int32; denominator: pointer): UInt32 := GetMscRateOML(hdc, @numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: GDI_DC; numerator: pointer; denominator: array of Int32): UInt32 := GetMscRateOML(hdc, numerator, denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: GDI_DC; numerator: pointer; var denominator: Int32): UInt32 := GetMscRateOML(hdc, numerator, @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(hdc: GDI_DC; numerator: pointer; denominator: pointer): UInt32 := z_GetMscRateOML(hdc, numerator, denominator);
    
    public z_SwapBuffersMscOML := GetGLFuncOrNil&<function(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>('wglSwapBuffersMscOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapBuffersMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 := z_SwapBuffersMscOML(hdc, target_msc, divisor, remainder);
    
    public z_SwapLayerBuffersMscOML := GetGLFuncOrNil&<function(hdc: GDI_DC; fuPlanes: Int32; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>('wglSwapLayerBuffersMscOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapLayerBuffersMscOML(hdc: GDI_DC; fuPlanes: Int32; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 := z_SwapLayerBuffersMscOML(hdc, fuPlanes, target_msc, divisor, remainder);
    
    public z_WaitForMscOML := GetGLFuncOrNil&<function(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32>('wglWaitForMscOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := WaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_WaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    
    public z_WaitForSbcOML := GetGLFuncOrNil&<function(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32>('wglWaitForSbcOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := WaitForSbcOML(hdc, target_sbc, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := WaitForSbcOML(hdc, target_sbc, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := WaitForSbcOML(hdc, target_sbc, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := WaitForSbcOML(hdc, target_sbc, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := WaitForSbcOML(hdc, target_sbc, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := WaitForSbcOML(hdc, target_sbc, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := WaitForSbcOML(hdc, target_sbc, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := WaitForSbcOML(hdc, target_sbc, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := WaitForSbcOML(hdc, target_sbc, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_WaitForSbcOML(hdc, target_sbc, ust, msc, sbc);
    
    {$endregion OML_sync_control}
    
    {$region EXT_swap_control}
    
    public z_SwapIntervalEXT := GetGLFuncOrNil&<function(interval: Int32): UInt32>('wglSwapIntervalEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapIntervalEXT(interval: Int32): UInt32 := z_SwapIntervalEXT(interval);
    
    public z_GetSwapIntervalEXT := GetGLFuncOrNil&<function: Int32>('wglGetSwapIntervalEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSwapIntervalEXT: Int32 := z_GetSwapIntervalEXT;
    
    {$endregion EXT_swap_control}
    
    {$region WGL_3DL_stereo_control}
    
    public z_SetStereoEmitterState3DL := GetGLFuncOrNil&<function(hDC: GDI_DC; uState: UInt32): UInt32>('wglSetStereoEmitterState3DL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetStereoEmitterState3DL(hDC: GDI_DC; uState: UInt32): UInt32 := z_SetStereoEmitterState3DL(hDC, uState);
    
    {$endregion WGL_3DL_stereo_control}
    
  end;
  
  egl = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region KHR_fence_sync}
    
    public z_CreateSyncKHR := GetGLFuncOrNil&<function(dpy: EGLDisplay; &type: DummyEnum; attrib_list: pointer): EGLsync>('eglCreateSyncKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncKHR(dpy: EGLDisplay; &type: DummyEnum; attrib_list: array of Int32): EGLsync := CreateSyncKHR(dpy, &type, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncKHR(dpy: EGLDisplay; &type: DummyEnum; var attrib_list: Int32): EGLsync := CreateSyncKHR(dpy, &type, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncKHR(dpy: EGLDisplay; &type: DummyEnum; attrib_list: pointer): EGLsync := z_CreateSyncKHR(dpy, &type, attrib_list);
    
    public z_DestroySyncKHR := GetGLFuncOrNil&<function(dpy: EGLDisplay; sync: EGLsync): UInt32>('eglDestroySyncKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroySyncKHR(dpy: EGLDisplay; sync: EGLsync): UInt32 := z_DestroySyncKHR(dpy, sync);
    
    public z_ClientWaitSyncKHR := GetGLFuncOrNil&<function(dpy: EGLDisplay; sync: EGLsync; flags: Int32; timeout: TimeSpan): Int32>('eglClientWaitSyncKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ClientWaitSyncKHR(dpy: EGLDisplay; sync: EGLsync; flags: Int32; timeout: TimeSpan): Int32 := z_ClientWaitSyncKHR(dpy, sync, flags, timeout);
    
    public z_GetSyncAttribKHR := GetGLFuncOrNil&<function(dpy: EGLDisplay; sync: EGLsync; attribute: Int32; value: pointer): UInt32>('eglGetSyncAttribKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncAttribKHR(dpy: EGLDisplay; sync: EGLsync; attribute: Int32; value: array of Int32): UInt32 := GetSyncAttribKHR(dpy, sync, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncAttribKHR(dpy: EGLDisplay; sync: EGLsync; attribute: Int32; var value: Int32): UInt32 := GetSyncAttribKHR(dpy, sync, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncAttribKHR(dpy: EGLDisplay; sync: EGLsync; attribute: Int32; value: pointer): UInt32 := z_GetSyncAttribKHR(dpy, sync, attribute, value);
    
    {$endregion KHR_fence_sync}
    
  end;
  
  glu = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region EXT_nurbs_tessellator}
    
    public z_NurbsCallbackDataEXT := GetGLFuncOrNil&<procedure(theNurb: pointer; userData: pointer)>('gluNurbsCallbackDataEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NurbsCallbackDataEXT(theNurb: array of GLUnurbs; userData: pointer) := NurbsCallbackDataEXT(theNurb[0], userData);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NurbsCallbackDataEXT(var theNurb: GLUnurbs; userData: pointer) := NurbsCallbackDataEXT(@theNurb, userData);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NurbsCallbackDataEXT(theNurb: pointer; userData: pointer) := z_NurbsCallbackDataEXT(theNurb, userData);
    
    {$endregion EXT_nurbs_tessellator}
    
  end;
  
  glX = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region NV_video_capture}
    
    public z_BeginVideoCaptureNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32)>('glBeginVideoCaptureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginVideoCaptureNV(video_capture_slot: UInt32) := z_BeginVideoCaptureNV(video_capture_slot);
    
    public z_BindVideoCaptureStreamBufferNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr)>('glBindVideoCaptureStreamBufferNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVideoCaptureStreamBufferNV(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr) := z_BindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
    
    public z_BindVideoCaptureStreamTextureNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: UInt32)>('glBindVideoCaptureStreamTextureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVideoCaptureStreamTextureNV(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: UInt32) := z_BindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
    
    public z_EndVideoCaptureNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32)>('glEndVideoCaptureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndVideoCaptureNV(video_capture_slot: UInt32) := z_EndVideoCaptureNV(video_capture_slot);
    
    public z_GetVideoCaptureivNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoCaptureivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; &params: array of Int32) := GetVideoCaptureivNV(video_capture_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; var &params: Int32) := GetVideoCaptureivNV(video_capture_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoCaptureivNV(video_capture_slot, pname, &params);
    
    public z_GetVideoCaptureStreamivNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoCaptureStreamivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of Int32) := GetVideoCaptureStreamivNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32) := GetVideoCaptureStreamivNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoCaptureStreamivNV(video_capture_slot, stream, pname, &params);
    
    public z_GetVideoCaptureStreamfvNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoCaptureStreamfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of single) := GetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single) := GetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, &params);
    
    public z_GetVideoCaptureStreamdvNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoCaptureStreamdvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of double) := GetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: double) := GetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, &params);
    
    public z_VideoCaptureNV := GetGLFuncOrNil&<function(video_capture_slot: UInt32; sequence_num: pointer; capture_time: pointer): DummyEnum>('glVideoCaptureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; capture_time: array of UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, sequence_num[0], capture_time[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; var capture_time: UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, sequence_num[0], @capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; capture_time: pointer): DummyEnum := VideoCaptureNV(video_capture_slot, sequence_num[0], capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; capture_time: array of UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, @sequence_num, capture_time[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; var capture_time: UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, @sequence_num, @capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; capture_time: pointer): DummyEnum := VideoCaptureNV(video_capture_slot, @sequence_num, capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: pointer; capture_time: array of UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, sequence_num, capture_time[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: pointer; var capture_time: UInt64): DummyEnum := VideoCaptureNV(video_capture_slot, sequence_num, @capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VideoCaptureNV(video_capture_slot: UInt32; sequence_num: pointer; capture_time: pointer): DummyEnum := z_VideoCaptureNV(video_capture_slot, sequence_num, capture_time);
    
    public z_VideoCaptureStreamParameterivNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glVideoCaptureStreamParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of Int32) := VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32) := VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_VideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, &params);
    
    public z_VideoCaptureStreamParameterfvNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glVideoCaptureStreamParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of single) := VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single) := VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_VideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, &params);
    
    public z_VideoCaptureStreamParameterdvNV := GetGLFuncOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>('glVideoCaptureStreamParameterdvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of double) := VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: double) := VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_VideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, &params);
    
    public z_BindVideoCaptureDeviceNV := GetGLFuncOrNil&<function(dpy: PDisplay; video_capture_slot: UInt32; device: GLXVideoCaptureDeviceNV): Int32>('glXBindVideoCaptureDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoCaptureDeviceNV(dpy: PDisplay; video_capture_slot: UInt32; device: GLXVideoCaptureDeviceNV): Int32 := z_BindVideoCaptureDeviceNV(dpy, video_capture_slot, device);
    
    public z_EnumerateVideoCaptureDevicesNV := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; nelements: pointer): pointer>('glXEnumerateVideoCaptureDevicesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(dpy: PDisplay; screen: Int32; nelements: array of Int32): pointer := EnumerateVideoCaptureDevicesNV(dpy, screen, nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(dpy: PDisplay; screen: Int32; var nelements: Int32): pointer := EnumerateVideoCaptureDevicesNV(dpy, screen, @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoCaptureDevicesNV(dpy: PDisplay; screen: Int32; nelements: pointer): pointer := z_EnumerateVideoCaptureDevicesNV(dpy, screen, nelements);
    
    public z_LockVideoCaptureDeviceNV := GetGLFuncOrNil&<procedure(dpy: PDisplay; device: GLXVideoCaptureDeviceNV)>('glXLockVideoCaptureDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LockVideoCaptureDeviceNV(dpy: PDisplay; device: GLXVideoCaptureDeviceNV) := z_LockVideoCaptureDeviceNV(dpy, device);
    
    public z_QueryVideoCaptureDeviceNV := GetGLFuncOrNil&<function(dpy: PDisplay; device: GLXVideoCaptureDeviceNV; attribute: Int32; value: pointer): Int32>('glXQueryVideoCaptureDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(dpy: PDisplay; device: GLXVideoCaptureDeviceNV; attribute: Int32; value: array of Int32): Int32 := QueryVideoCaptureDeviceNV(dpy, device, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(dpy: PDisplay; device: GLXVideoCaptureDeviceNV; attribute: Int32; var value: Int32): Int32 := QueryVideoCaptureDeviceNV(dpy, device, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryVideoCaptureDeviceNV(dpy: PDisplay; device: GLXVideoCaptureDeviceNV; attribute: Int32; value: pointer): Int32 := z_QueryVideoCaptureDeviceNV(dpy, device, attribute, value);
    
    public z_ReleaseVideoCaptureDeviceNV := GetGLFuncOrNil&<procedure(dpy: PDisplay; device: GLXVideoCaptureDeviceNV)>('glXReleaseVideoCaptureDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseVideoCaptureDeviceNV(dpy: PDisplay; device: GLXVideoCaptureDeviceNV) := z_ReleaseVideoCaptureDeviceNV(dpy, device);
    
    {$endregion NV_video_capture}
    
    {$region SGIX_video_resize}
    
    public z_BindChannelToWindowSGIX := GetGLFuncOrNil&<function(display: PDisplay; screen: Int32; channel: Int32; window: GLXWindow): Int32>('glXBindChannelToWindowSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindChannelToWindowSGIX(display: PDisplay; screen: Int32; channel: Int32; window: GLXWindow): Int32 := z_BindChannelToWindowSGIX(display, screen, channel, window);
    
    public z_ChannelRectSGIX := GetGLFuncOrNil&<function(display: PDisplay; screen: Int32; channel: Int32; x: Int32; y: Int32; w: Int32; h: Int32): Int32>('glXChannelRectSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; x: Int32; y: Int32; w: Int32; h: Int32): Int32 := z_ChannelRectSGIX(display, screen, channel, x, y, w, h);
    
    public z_QueryChannelRectSGIX := GetGLFuncOrNil&<function(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: pointer; dh: pointer): Int32>('glXQueryChannelRectSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: pointer; dh: pointer): Int32 := z_QueryChannelRectSGIX(display, screen, channel, dx, dy, dw, dh);
    
    public z_QueryChannelDeltasSGIX := GetGLFuncOrNil&<function(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: pointer; h: pointer): Int32>('glXQueryChannelDeltasSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: pointer; h: pointer): Int32 := z_QueryChannelDeltasSGIX(display, screen, channel, x, y, w, h);
    
    public z_ChannelRectSyncSGIX := GetGLFuncOrNil&<function(display: PDisplay; screen: Int32; channel: Int32; synctype: DummyEnum): Int32>('glXChannelRectSyncSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChannelRectSyncSGIX(display: PDisplay; screen: Int32; channel: Int32; synctype: DummyEnum): Int32 := z_ChannelRectSyncSGIX(display, screen, channel, synctype);
    
    {$endregion SGIX_video_resize}
    
    {$region SGIX_hyperpipe}
    
    public z_QueryHyperpipeNetworkSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; npipes: pointer): pointer>('glXQueryHyperpipeNetworkSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeNetworkSGIX(dpy: PDisplay; npipes: array of Int32): pointer := QueryHyperpipeNetworkSGIX(dpy, npipes[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeNetworkSGIX(dpy: PDisplay; var npipes: Int32): pointer := QueryHyperpipeNetworkSGIX(dpy, @npipes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeNetworkSGIX(dpy: PDisplay; npipes: pointer): pointer := z_QueryHyperpipeNetworkSGIX(dpy, npipes);
    
    public z_HyperpipeConfigSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: pointer; hpId: pointer): Int32>('glXHyperpipeConfigSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: array of GLXHyperpipeConfigDataSGIX; hpId: array of Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, cfg[0], hpId[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: array of GLXHyperpipeConfigDataSGIX; var hpId: Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, cfg[0], @hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: array of GLXHyperpipeConfigDataSGIX; hpId: pointer): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, cfg[0], hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; var cfg: GLXHyperpipeConfigDataSGIX; hpId: array of Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, @cfg, hpId[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; var cfg: GLXHyperpipeConfigDataSGIX; var hpId: Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, @cfg, @hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; var cfg: GLXHyperpipeConfigDataSGIX; hpId: pointer): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, @cfg, hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: pointer; hpId: array of Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, cfg, hpId[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: pointer; var hpId: Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, cfg, @hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: pointer; hpId: pointer): Int32 := z_HyperpipeConfigSGIX(dpy, networkId, npipes, cfg, hpId);
    
    public z_QueryHyperpipeConfigSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; hpId: Int32; npipes: pointer): pointer>('glXQueryHyperpipeConfigSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeConfigSGIX(dpy: PDisplay; hpId: Int32; npipes: array of Int32): pointer := QueryHyperpipeConfigSGIX(dpy, hpId, npipes[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeConfigSGIX(dpy: PDisplay; hpId: Int32; var npipes: Int32): pointer := QueryHyperpipeConfigSGIX(dpy, hpId, @npipes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeConfigSGIX(dpy: PDisplay; hpId: Int32; npipes: pointer): pointer := z_QueryHyperpipeConfigSGIX(dpy, hpId, npipes);
    
    public z_DestroyHyperpipeConfigSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; hpId: Int32): Int32>('glXDestroyHyperpipeConfigSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyHyperpipeConfigSGIX(dpy: PDisplay; hpId: Int32): Int32 := z_DestroyHyperpipeConfigSGIX(dpy, hpId);
    
    public z_BindHyperpipeSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; hpId: Int32): Int32>('glXBindHyperpipeSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindHyperpipeSGIX(dpy: PDisplay; hpId: Int32): Int32 := z_BindHyperpipeSGIX(dpy, hpId);
    
    public z_QueryHyperpipeBestAttribSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; attribList: pointer; returnAttribList: pointer): Int32>('glXQueryHyperpipeBestAttribSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeBestAttribSGIX(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; attribList: pointer; returnAttribList: pointer): Int32 := z_QueryHyperpipeBestAttribSGIX(dpy, timeSlice, attrib, size, attribList, returnAttribList);
    
    public z_HyperpipeAttribSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; attribList: pointer): Int32>('glXHyperpipeAttribSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeAttribSGIX(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; attribList: pointer): Int32 := z_HyperpipeAttribSGIX(dpy, timeSlice, attrib, size, attribList);
    
    public z_QueryHyperpipeAttribSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: pointer): Int32>('glXQueryHyperpipeAttribSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeAttribSGIX(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: pointer): Int32 := z_QueryHyperpipeAttribSGIX(dpy, timeSlice, attrib, size, returnAttribList);
    
    {$endregion SGIX_hyperpipe}
    
    {$region NV_swap_group}
    
    public z_JoinSwapGroupNV := GetGLFuncOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; group: UInt32): UInt32>('glXJoinSwapGroupNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function JoinSwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: UInt32): UInt32 := z_JoinSwapGroupNV(dpy, drawable, group);
    
    public z_BindSwapBarrierNV := GetGLFuncOrNil&<function(dpy: PDisplay; group: UInt32; barrier: UInt32): UInt32>('glXBindSwapBarrierNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindSwapBarrierNV(dpy: PDisplay; group: UInt32; barrier: UInt32): UInt32 := z_BindSwapBarrierNV(dpy, group, barrier);
    
    public z_QuerySwapGroupNV := GetGLFuncOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; group: pointer; barrier: pointer): UInt32>('glXQuerySwapGroupNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: array of UInt32; barrier: array of UInt32): UInt32 := QuerySwapGroupNV(dpy, drawable, group[0], barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: array of UInt32; var barrier: UInt32): UInt32 := QuerySwapGroupNV(dpy, drawable, group[0], @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: array of UInt32; barrier: pointer): UInt32 := QuerySwapGroupNV(dpy, drawable, group[0], barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; var group: UInt32; barrier: array of UInt32): UInt32 := QuerySwapGroupNV(dpy, drawable, @group, barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; var group: UInt32; var barrier: UInt32): UInt32 := QuerySwapGroupNV(dpy, drawable, @group, @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; var group: UInt32; barrier: pointer): UInt32 := QuerySwapGroupNV(dpy, drawable, @group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: pointer; barrier: array of UInt32): UInt32 := QuerySwapGroupNV(dpy, drawable, group, barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: pointer; var barrier: UInt32): UInt32 := QuerySwapGroupNV(dpy, drawable, group, @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: pointer; barrier: pointer): UInt32 := z_QuerySwapGroupNV(dpy, drawable, group, barrier);
    
    public z_QueryMaxSwapGroupsNV := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; maxGroups: pointer; maxBarriers: pointer): UInt32>('glXQueryMaxSwapGroupsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: array of UInt32; maxBarriers: array of UInt32): UInt32 := QueryMaxSwapGroupsNV(dpy, screen, maxGroups[0], maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: array of UInt32; var maxBarriers: UInt32): UInt32 := QueryMaxSwapGroupsNV(dpy, screen, maxGroups[0], @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: array of UInt32; maxBarriers: pointer): UInt32 := QueryMaxSwapGroupsNV(dpy, screen, maxGroups[0], maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; var maxGroups: UInt32; maxBarriers: array of UInt32): UInt32 := QueryMaxSwapGroupsNV(dpy, screen, @maxGroups, maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; var maxGroups: UInt32; var maxBarriers: UInt32): UInt32 := QueryMaxSwapGroupsNV(dpy, screen, @maxGroups, @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; var maxGroups: UInt32; maxBarriers: pointer): UInt32 := QueryMaxSwapGroupsNV(dpy, screen, @maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: pointer; maxBarriers: array of UInt32): UInt32 := QueryMaxSwapGroupsNV(dpy, screen, maxGroups, maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: pointer; var maxBarriers: UInt32): UInt32 := QueryMaxSwapGroupsNV(dpy, screen, maxGroups, @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: pointer; maxBarriers: pointer): UInt32 := z_QueryMaxSwapGroupsNV(dpy, screen, maxGroups, maxBarriers);
    
    public z_QueryFrameCountNV := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; count: pointer): UInt32>('glXQueryFrameCountNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(dpy: PDisplay; screen: Int32; count: array of UInt32): UInt32 := QueryFrameCountNV(dpy, screen, count[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(dpy: PDisplay; screen: Int32; var count: UInt32): UInt32 := QueryFrameCountNV(dpy, screen, @count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameCountNV(dpy: PDisplay; screen: Int32; count: pointer): UInt32 := z_QueryFrameCountNV(dpy, screen, count);
    
    public z_ResetFrameCountNV := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32): UInt32>('glXResetFrameCountNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ResetFrameCountNV(dpy: PDisplay; screen: Int32): UInt32 := z_ResetFrameCountNV(dpy, screen);
    
    {$endregion NV_swap_group}
    
    {$region SGIX_swap_barrier}
    
    public z_BindSwapBarrierSGIX := GetGLFuncOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; barrier: Int32)>('glXBindSwapBarrierSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindSwapBarrierSGIX(dpy: PDisplay; drawable: GLXDrawable; barrier: Int32) := z_BindSwapBarrierSGIX(dpy, drawable, barrier);
    
    public z_QueryMaxSwapBarriersSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; max: pointer): UInt32>('glXQueryMaxSwapBarriersSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: PDisplay; screen: Int32; max: array of Int32): UInt32 := QueryMaxSwapBarriersSGIX(dpy, screen, max[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: PDisplay; screen: Int32; var max: Int32): UInt32 := QueryMaxSwapBarriersSGIX(dpy, screen, @max);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: PDisplay; screen: Int32; max: pointer): UInt32 := z_QueryMaxSwapBarriersSGIX(dpy, screen, max);
    
    {$endregion SGIX_swap_barrier}
    
    {$region EXT_texture_from_pixmap}
    
    public z_BindTexImageEXT := GetGLFuncOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32; attrib_list: pointer)>('glXBindTexImageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32; attrib_list: array of Int32) := BindTexImageEXT(dpy, drawable, buffer, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32; var attrib_list: Int32) := BindTexImageEXT(dpy, drawable, buffer, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32; attrib_list: pointer) := z_BindTexImageEXT(dpy, drawable, buffer, attrib_list);
    
    public z_ReleaseTexImageEXT := GetGLFuncOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32)>('glXReleaseTexImageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseTexImageEXT(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32) := z_ReleaseTexImageEXT(dpy, drawable, buffer);
    
    {$endregion EXT_texture_from_pixmap}
    
    {$region NV_present_video}
    
    public z_PresentFrameKeyedNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32)>('glPresentFrameKeyedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PresentFrameKeyedNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32) := z_PresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, &type, target0, fill0, key0, target1, fill1, key1);
    
    public z_PresentFrameDualFillNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32)>('glPresentFrameDualFillNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PresentFrameDualFillNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32) := z_PresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, &type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    
    public z_GetVideoivNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoivNV(video_slot: UInt32; pname: DummyEnum; &params: array of Int32) := GetVideoivNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoivNV(video_slot: UInt32; pname: DummyEnum; var &params: Int32) := GetVideoivNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoivNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoivNV(video_slot, pname, &params);
    
    public z_GetVideouivNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideouivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideouivNV(video_slot: UInt32; pname: DummyEnum; &params: array of UInt32) := GetVideouivNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideouivNV(video_slot: UInt32; pname: DummyEnum; var &params: UInt32) := GetVideouivNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideouivNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideouivNV(video_slot, pname, &params);
    
    public z_GetVideoi64vNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoi64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; &params: array of Int64) := GetVideoi64vNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; var &params: Int64) := GetVideoi64vNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoi64vNV(video_slot, pname, &params);
    
    public z_GetVideoui64vNV := GetGLFuncOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>('glGetVideoui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; &params: array of UInt64) := GetVideoui64vNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; var &params: UInt64) := GetVideoui64vNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_GetVideoui64vNV(video_slot, pname, &params);
    
    public z_EnumerateVideoDevicesNV := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; nelements: pointer): pointer>('glXEnumerateVideoDevicesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(dpy: PDisplay; screen: Int32; nelements: array of Int32): pointer := EnumerateVideoDevicesNV(dpy, screen, nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(dpy: PDisplay; screen: Int32; var nelements: Int32): pointer := EnumerateVideoDevicesNV(dpy, screen, @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumerateVideoDevicesNV(dpy: PDisplay; screen: Int32; nelements: pointer): pointer := z_EnumerateVideoDevicesNV(dpy, screen, nelements);
    
    public z_BindVideoDeviceNV := GetGLFuncOrNil&<function(dpy: PDisplay; video_slot: UInt32; video_device: UInt32; attrib_list: pointer): Int32>('glXBindVideoDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(dpy: PDisplay; video_slot: UInt32; video_device: UInt32; attrib_list: array of Int32): Int32 := BindVideoDeviceNV(dpy, video_slot, video_device, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(dpy: PDisplay; video_slot: UInt32; video_device: UInt32; var attrib_list: Int32): Int32 := BindVideoDeviceNV(dpy, video_slot, video_device, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoDeviceNV(dpy: PDisplay; video_slot: UInt32; video_device: UInt32; attrib_list: pointer): Int32 := z_BindVideoDeviceNV(dpy, video_slot, video_device, attrib_list);
    
    {$endregion NV_present_video}
    
    {$region NV_video_output}
    
    public z_GetVideoDeviceNV := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; numVideoDevices: Int32; pVideoDevice: pointer): Int32>('glXGetVideoDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(dpy: PDisplay; screen: Int32; numVideoDevices: Int32; pVideoDevice: array of GLXVideoDeviceNV): Int32 := GetVideoDeviceNV(dpy, screen, numVideoDevices, pVideoDevice[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(dpy: PDisplay; screen: Int32; numVideoDevices: Int32; var pVideoDevice: GLXVideoDeviceNV): Int32 := GetVideoDeviceNV(dpy, screen, numVideoDevices, @pVideoDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoDeviceNV(dpy: PDisplay; screen: Int32; numVideoDevices: Int32; pVideoDevice: pointer): Int32 := z_GetVideoDeviceNV(dpy, screen, numVideoDevices, pVideoDevice);
    
    public z_ReleaseVideoDeviceNV := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV): Int32>('glXReleaseVideoDeviceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoDeviceNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV): Int32 := z_ReleaseVideoDeviceNV(dpy, screen, VideoDevice);
    
    public z_BindVideoImageNV := GetGLFuncOrNil&<function(dpy: PDisplay; VideoDevice: GLXVideoDeviceNV; pbuf: GLXPbuffer; iVideoBuffer: Int32): Int32>('glXBindVideoImageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindVideoImageNV(dpy: PDisplay; VideoDevice: GLXVideoDeviceNV; pbuf: GLXPbuffer; iVideoBuffer: Int32): Int32 := z_BindVideoImageNV(dpy, VideoDevice, pbuf, iVideoBuffer);
    
    public z_ReleaseVideoImageNV := GetGLFuncOrNil&<function(dpy: PDisplay; pbuf: GLXPbuffer): Int32>('glXReleaseVideoImageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseVideoImageNV(dpy: PDisplay; pbuf: GLXPbuffer): Int32 := z_ReleaseVideoImageNV(dpy, pbuf);
    
    public z_SendPbufferToVideoNV := GetGLFuncOrNil&<function(dpy: PDisplay; pbuf: GLXPbuffer; iBufferType: Int32; pulCounterPbuffer: pointer; bBlock: boolean): Int32>('glXSendPbufferToVideoNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(dpy: PDisplay; pbuf: GLXPbuffer; iBufferType: Int32; pulCounterPbuffer: array of UInt64; bBlock: boolean): Int32 := SendPbufferToVideoNV(dpy, pbuf, iBufferType, pulCounterPbuffer[0], bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(dpy: PDisplay; pbuf: GLXPbuffer; iBufferType: Int32; var pulCounterPbuffer: UInt64; bBlock: boolean): Int32 := SendPbufferToVideoNV(dpy, pbuf, iBufferType, @pulCounterPbuffer, bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SendPbufferToVideoNV(dpy: PDisplay; pbuf: GLXPbuffer; iBufferType: Int32; pulCounterPbuffer: pointer; bBlock: boolean): Int32 := z_SendPbufferToVideoNV(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
    
    public z_GetVideoInfoNV := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: pointer): Int32>('glXGetVideoInfoNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: array of UInt64; pulCounterOutputVideo: array of UInt64): Int32 := GetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer[0], pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: array of UInt64; var pulCounterOutputVideo: UInt64): Int32 := GetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer[0], @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: array of UInt64; pulCounterOutputVideo: pointer): Int32 := GetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer[0], pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: array of UInt64): Int32 := GetVideoInfoNV(dpy, screen, VideoDevice, @pulCounterOutputPbuffer, pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; var pulCounterOutputPbuffer: UInt64; var pulCounterOutputVideo: UInt64): Int32 := GetVideoInfoNV(dpy, screen, VideoDevice, @pulCounterOutputPbuffer, @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: pointer): Int32 := GetVideoInfoNV(dpy, screen, VideoDevice, @pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: array of UInt64): Int32 := GetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: pointer; var pulCounterOutputVideo: UInt64): Int32 := GetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer, @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: pointer): Int32 := z_GetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    
    {$endregion NV_video_output}
    
    {$region AMD_gpu_association}
    
    public z_GetGPUIDsAMD := GetGLFuncOrNil&<function(maxCount: UInt32; ids: pointer): UInt32>('glXGetGPUIDsAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; ids: array of UInt32): UInt32 := GetGPUIDsAMD(maxCount, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; var ids: UInt32): UInt32 := GetGPUIDsAMD(maxCount, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUIDsAMD(maxCount: UInt32; ids: pointer): UInt32 := z_GetGPUIDsAMD(maxCount, ids);
    
    public z_GetGPUInfoAMD := GetGLFuncOrNil&<function(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: pointer): Int32>('glXGetGPUInfoAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGPUInfoAMD(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: pointer): Int32 := z_GetGPUInfoAMD(id, &property, dataType, size, data);
    
    public z_GetContextGPUIDAMD := GetGLFuncOrNil&<function(ctx: GLXContext): UInt32>('glXGetContextGPUIDAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetContextGPUIDAMD(ctx: GLXContext): UInt32 := z_GetContextGPUIDAMD(ctx);
    
    public z_CreateAssociatedContextAMD := GetGLFuncOrNil&<function(id: UInt32; share_list: GLXContext): GLXContext>('glXCreateAssociatedContextAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAMD(id: UInt32; share_list: GLXContext): GLXContext := z_CreateAssociatedContextAMD(id, share_list);
    
    public z_CreateAssociatedContextAttribsAMD := GetGLFuncOrNil&<function(id: UInt32; share_context: GLXContext; attribList: pointer): GLXContext>('glXCreateAssociatedContextAttribsAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; share_context: GLXContext; attribList: array of Int32): GLXContext := CreateAssociatedContextAttribsAMD(id, share_context, attribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; share_context: GLXContext; var attribList: Int32): GLXContext := CreateAssociatedContextAttribsAMD(id, share_context, @attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAssociatedContextAttribsAMD(id: UInt32; share_context: GLXContext; attribList: pointer): GLXContext := z_CreateAssociatedContextAttribsAMD(id, share_context, attribList);
    
    public z_DeleteAssociatedContextAMD := GetGLFuncOrNil&<function(ctx: GLXContext): UInt32>('glXDeleteAssociatedContextAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteAssociatedContextAMD(ctx: GLXContext): UInt32 := z_DeleteAssociatedContextAMD(ctx);
    
    public z_MakeAssociatedContextCurrentAMD := GetGLFuncOrNil&<function(ctx: GLXContext): UInt32>('glXMakeAssociatedContextCurrentAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeAssociatedContextCurrentAMD(ctx: GLXContext): UInt32 := z_MakeAssociatedContextCurrentAMD(ctx);
    
    public z_GetCurrentAssociatedContextAMD := GetGLFuncOrNil&<function: GLXContext>('glXGetCurrentAssociatedContextAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentAssociatedContextAMD: GLXContext := z_GetCurrentAssociatedContextAMD;
    
    public z_BlitContextFramebufferAMD := GetGLFuncOrNil&<procedure(dstCtx: GLXContext; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>('glXBlitContextFramebufferAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitContextFramebufferAMD(dstCtx: GLXContext; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := z_BlitContextFramebufferAMD(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    {$endregion AMD_gpu_association}
    
    {$region SGIX_fbconfig}
    
    public z_GetFBConfigAttribSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; config: GLXFBConfig; attribute: Int32; value: pointer): Int32>('glXGetFBConfigAttribSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigAttribSGIX(dpy: PDisplay; config: GLXFBConfig; attribute: Int32; value: array of Int32): Int32 := GetFBConfigAttribSGIX(dpy, config, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigAttribSGIX(dpy: PDisplay; config: GLXFBConfig; attribute: Int32; var value: Int32): Int32 := GetFBConfigAttribSGIX(dpy, config, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigAttribSGIX(dpy: PDisplay; config: GLXFBConfig; attribute: Int32; value: pointer): Int32 := z_GetFBConfigAttribSGIX(dpy, config, attribute, value);
    
    public z_ChooseFBConfigSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; attrib_list: pointer; nelements: pointer): pointer>('glXChooseFBConfigSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: PDisplay; screen: Int32; attrib_list: array of Int32; nelements: array of Int32): pointer := ChooseFBConfigSGIX(dpy, screen, attrib_list[0], nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: PDisplay; screen: Int32; attrib_list: array of Int32; var nelements: Int32): pointer := ChooseFBConfigSGIX(dpy, screen, attrib_list[0], @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: PDisplay; screen: Int32; attrib_list: array of Int32; nelements: pointer): pointer := ChooseFBConfigSGIX(dpy, screen, attrib_list[0], nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: PDisplay; screen: Int32; var attrib_list: Int32; nelements: array of Int32): pointer := ChooseFBConfigSGIX(dpy, screen, @attrib_list, nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: PDisplay; screen: Int32; var attrib_list: Int32; var nelements: Int32): pointer := ChooseFBConfigSGIX(dpy, screen, @attrib_list, @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: PDisplay; screen: Int32; var attrib_list: Int32; nelements: pointer): pointer := ChooseFBConfigSGIX(dpy, screen, @attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: PDisplay; screen: Int32; attrib_list: pointer; nelements: array of Int32): pointer := ChooseFBConfigSGIX(dpy, screen, attrib_list, nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: PDisplay; screen: Int32; attrib_list: pointer; var nelements: Int32): pointer := ChooseFBConfigSGIX(dpy, screen, attrib_list, @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfigSGIX(dpy: PDisplay; screen: Int32; attrib_list: pointer; nelements: pointer): pointer := z_ChooseFBConfigSGIX(dpy, screen, attrib_list, nelements);
    
    public z_CreateGLXPixmapWithConfigSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; config: GLXFBConfig; pixmap: GLXPixmap): GLXPixmap>('glXCreateGLXPixmapWithConfigSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPixmapWithConfigSGIX(dpy: PDisplay; config: GLXFBConfig; pixmap: GLXPixmap): GLXPixmap := z_CreateGLXPixmapWithConfigSGIX(dpy, config, pixmap);
    
    public z_CreateContextWithConfigSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; config: GLXFBConfig; render_type: Int32; share_list: GLXContext; direct: UInt32): GLXContext>('glXCreateContextWithConfigSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextWithConfigSGIX(dpy: PDisplay; config: GLXFBConfig; render_type: Int32; share_list: GLXContext; direct: UInt32): GLXContext := z_CreateContextWithConfigSGIX(dpy, config, render_type, share_list, direct);
    
    public z_GetVisualFromFBConfigSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; config: GLXFBConfig): PXVisualInfo>('glXGetVisualFromFBConfigSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVisualFromFBConfigSGIX(dpy: PDisplay; config: GLXFBConfig): PXVisualInfo := z_GetVisualFromFBConfigSGIX(dpy, config);
    
    public z_GetFBConfigFromVisualSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; vis: PXVisualInfo): GLXFBConfig>('glXGetFBConfigFromVisualSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigFromVisualSGIX(dpy: PDisplay; vis: PXVisualInfo): GLXFBConfig := z_GetFBConfigFromVisualSGIX(dpy, vis);
    
    {$endregion SGIX_fbconfig}
    
    {$region GLX_NV_copy_buffer}
    
    public z_CopyBufferSubDataNV := GetGLFuncOrNil&<procedure(dpy: PDisplay; readCtx: GLXContext; writeCtx: GLXContext; readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>('glXCopyBufferSubDataNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyBufferSubDataNV(dpy: PDisplay; readCtx: GLXContext; writeCtx: GLXContext; readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_CopyBufferSubDataNV(dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size);
    
    public z_NamedCopyBufferSubDataNV := GetGLFuncOrNil&<procedure(dpy: PDisplay; readCtx: GLXContext; writeCtx: GLXContext; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>('glXNamedCopyBufferSubDataNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedCopyBufferSubDataNV(dpy: PDisplay; readCtx: GLXContext; writeCtx: GLXContext; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_NamedCopyBufferSubDataNV(dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    {$endregion GLX_NV_copy_buffer}
    
    {$region NV_copy_image}
    
    public z_CopyImageSubDataNV := GetGLFuncOrNil&<procedure(dpy: PDisplay; srcCtx: GLXContext; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstCtx: GLXContext; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>('glXCopyImageSubDataNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubDataNV(dpy: PDisplay; srcCtx: GLXContext; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstCtx: GLXContext; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) := z_CopyImageSubDataNV(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
    {$endregion NV_copy_image}
    
    {$region MESA_copy_sub_buffer}
    
    public z_CopySubBufferMESA := GetGLFuncOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; x: Int32; y: Int32; width: Int32; height: Int32)>('glXCopySubBufferMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopySubBufferMESA(dpy: PDisplay; drawable: GLXDrawable; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopySubBufferMESA(dpy, drawable, x, y, width, height);
    
    {$endregion MESA_copy_sub_buffer}
    
    {$region ARB_create_context ARB_create_context_profile}
    
    public z_CreateContextAttribsARB := GetGLFuncOrNil&<function(dpy: PDisplay; config: GLXFBConfig; share_context: GLXContext; direct: UInt32; attrib_list: pointer): GLXContext>('glXCreateContextAttribsARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: PDisplay; config: GLXFBConfig; share_context: GLXContext; direct: UInt32; attrib_list: array of Int32): GLXContext := CreateContextAttribsARB(dpy, config, share_context, direct, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: PDisplay; config: GLXFBConfig; share_context: GLXContext; direct: UInt32; var attrib_list: Int32): GLXContext := CreateContextAttribsARB(dpy, config, share_context, direct, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: PDisplay; config: GLXFBConfig; share_context: GLXContext; direct: UInt32; attrib_list: pointer): GLXContext := z_CreateContextAttribsARB(dpy, config, share_context, direct, attrib_list);
    
    public z_CreateNewContext := GetGLFuncOrNil&<function(dpy: PDisplay; config: GLXFBConfig; render_type: Int32; share_list: GLXContext; direct: UInt32): GLXContext>('glXCreateNewContext');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateNewContext(dpy: PDisplay; config: GLXFBConfig; render_type: Int32; share_list: GLXContext; direct: UInt32): GLXContext := z_CreateNewContext(dpy, config, render_type, share_list, direct);
    
    {$endregion ARB_create_context ARB_create_context_profile}
    
    {$region SGIX_pbuffer}
    
    public z_CreateGLXPbufferSGIX := GetGLFuncOrNil&<function(dpy: PDisplay; config: GLXFBConfig; width: UInt32; height: UInt32; attrib_list: pointer): GLXPbuffer>('glXCreateGLXPbufferSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: PDisplay; config: GLXFBConfig; width: UInt32; height: UInt32; attrib_list: array of Int32): GLXPbuffer := CreateGLXPbufferSGIX(dpy, config, width, height, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: PDisplay; config: GLXFBConfig; width: UInt32; height: UInt32; var attrib_list: Int32): GLXPbuffer := CreateGLXPbufferSGIX(dpy, config, width, height, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: PDisplay; config: GLXFBConfig; width: UInt32; height: UInt32; attrib_list: pointer): GLXPbuffer := z_CreateGLXPbufferSGIX(dpy, config, width, height, attrib_list);
    
    public z_DestroyGLXPbufferSGIX := GetGLFuncOrNil&<procedure(dpy: PDisplay; pbuf: GLXPbuffer)>('glXDestroyGLXPbufferSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyGLXPbufferSGIX(dpy: PDisplay; pbuf: GLXPbuffer) := z_DestroyGLXPbufferSGIX(dpy, pbuf);
    
    public z_QueryGLXPbufferSGIX := GetGLFuncOrNil&<procedure(dpy: PDisplay; pbuf: GLXPbuffer; attribute: Int32; value: pointer)>('glXQueryGLXPbufferSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: PDisplay; pbuf: GLXPbuffer; attribute: Int32; value: array of UInt32) := QueryGLXPbufferSGIX(dpy, pbuf, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: PDisplay; pbuf: GLXPbuffer; attribute: Int32; var value: UInt32) := QueryGLXPbufferSGIX(dpy, pbuf, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: PDisplay; pbuf: GLXPbuffer; attribute: Int32; value: pointer) := z_QueryGLXPbufferSGIX(dpy, pbuf, attribute, value);
    
    public z_SelectEventSGIX := GetGLFuncOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; mask: UInt64)>('glXSelectEventSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectEventSGIX(dpy: PDisplay; drawable: GLXDrawable; mask: UInt64) := z_SelectEventSGIX(dpy, drawable, mask);
    
    public z_GetSelectedEventSGIX := GetGLFuncOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; mask: pointer)>('glXGetSelectedEventSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEventSGIX(dpy: PDisplay; drawable: GLXDrawable; mask: array of UInt64) := GetSelectedEventSGIX(dpy, drawable, mask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEventSGIX(dpy: PDisplay; drawable: GLXDrawable; var mask: UInt64) := GetSelectedEventSGIX(dpy, drawable, @mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEventSGIX(dpy: PDisplay; drawable: GLXDrawable; mask: pointer) := z_GetSelectedEventSGIX(dpy, drawable, mask);
    
    {$endregion SGIX_pbuffer}
    
    {$region MESA_pixmap_colormap}
    
    public z_CreateGLXPixmapMESA := GetGLFuncOrNil&<function(dpy: PDisplay; visual: PXVisualInfo; pixmap: GLXPixmap; cmap: GLXColormap): GLXPixmap>('glXCreateGLXPixmapMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPixmapMESA(dpy: PDisplay; visual: PXVisualInfo; pixmap: GLXPixmap; cmap: GLXColormap): GLXPixmap := z_CreateGLXPixmapMESA(dpy, visual, pixmap, cmap);
    
    {$endregion MESA_pixmap_colormap}
    
    {$region NV_delay_before_swap}
    
    public z_DelayBeforeSwapNV := GetGLFuncOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; seconds: single): UInt32>('glXDelayBeforeSwapNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DelayBeforeSwapNV(dpy: PDisplay; drawable: GLXDrawable; seconds: single): UInt32 := z_DelayBeforeSwapNV(dpy, drawable, seconds);
    
    {$endregion NV_delay_before_swap}
    
    {$region EXT_import_context}
    
    public z_GetCurrentDisplayEXT := GetGLFuncOrNil&<function: PDisplay>('glXGetCurrentDisplayEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentDisplayEXT: PDisplay := z_GetCurrentDisplayEXT;
    
    public z_QueryContextInfoEXT := GetGLFuncOrNil&<function(dpy: PDisplay; context: GLXContext; attribute: Int32; value: pointer): Int32>('glXQueryContextInfoEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: PDisplay; context: GLXContext; attribute: Int32; value: array of Int32): Int32 := QueryContextInfoEXT(dpy, context, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: PDisplay; context: GLXContext; attribute: Int32; var value: Int32): Int32 := QueryContextInfoEXT(dpy, context, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: PDisplay; context: GLXContext; attribute: Int32; value: pointer): Int32 := z_QueryContextInfoEXT(dpy, context, attribute, value);
    
    public z_GetContextIDEXT := GetGLFuncOrNil&<function(context: GLXContext): GLXContextID>('glXGetContextIDEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetContextIDEXT(context: GLXContext): GLXContextID := z_GetContextIDEXT(context);
    
    public z_ImportContextEXT := GetGLFuncOrNil&<function(dpy: PDisplay; contextID: GLXContextID): GLXContext>('glXImportContextEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportContextEXT(dpy: PDisplay; contextID: GLXContextID): GLXContext := z_ImportContextEXT(dpy, contextID);
    
    public z_FreeContextEXT := GetGLFuncOrNil&<procedure(dpy: PDisplay; context: GLXContext)>('glXFreeContextEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeContextEXT(dpy: PDisplay; context: GLXContext) := z_FreeContextEXT(dpy, context);
    
    {$endregion EXT_import_context}
    
    {$region MESA_agp_offset}
    
    public z_GetAGPOffsetMESA := GetGLFuncOrNil&<function(_pointer: pointer): UInt32>('glXGetAGPOffsetMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAGPOffsetMESA(_pointer: pointer): UInt32 := z_GetAGPOffsetMESA(_pointer);
    
    {$endregion MESA_agp_offset}
    
    {$region SGI_make_current_read}
    
    public z_MakeCurrentReadSGI := GetGLFuncOrNil&<function(dpy: PDisplay; draw: GLXDrawable; read: GLXDrawable; ctx: GLXContext): UInt32>('glXMakeCurrentReadSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeCurrentReadSGI(dpy: PDisplay; draw: GLXDrawable; read: GLXDrawable; ctx: GLXContext): UInt32 := z_MakeCurrentReadSGI(dpy, draw, read, ctx);
    
    public z_GetCurrentReadDrawableSGI := GetGLFuncOrNil&<function: GLXDrawable>('glXGetCurrentReadDrawableSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDrawableSGI: GLXDrawable := z_GetCurrentReadDrawableSGI;
    
    {$endregion SGI_make_current_read}
    
    {$region OML_sync_control}
    
    public z_GetSyncValuesOML := GetGLFuncOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: pointer; sbc: pointer): UInt32>('glXGetSyncValuesOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := GetSyncValuesOML(dpy, drawable, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := GetSyncValuesOML(dpy, drawable, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := GetSyncValuesOML(dpy, drawable, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(dpy, drawable, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(dpy, drawable, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := GetSyncValuesOML(dpy, drawable, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(dpy, drawable, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(dpy, drawable, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := GetSyncValuesOML(dpy, drawable, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := GetSyncValuesOML(dpy, drawable, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := GetSyncValuesOML(dpy, drawable, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := GetSyncValuesOML(dpy, drawable, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := GetSyncValuesOML(dpy, drawable, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := GetSyncValuesOML(dpy, drawable, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := GetSyncValuesOML(dpy, drawable, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_GetSyncValuesOML(dpy, drawable, ust, msc, sbc);
    
    public z_GetMscRateOML := GetGLFuncOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; numerator: pointer; denominator: pointer): UInt32>('glXGetMscRateOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: array of Int32; denominator: array of Int32): UInt32 := GetMscRateOML(dpy, drawable, numerator[0], denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: array of Int32; var denominator: Int32): UInt32 := GetMscRateOML(dpy, drawable, numerator[0], @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: array of Int32; denominator: pointer): UInt32 := GetMscRateOML(dpy, drawable, numerator[0], denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; var numerator: Int32; denominator: array of Int32): UInt32 := GetMscRateOML(dpy, drawable, @numerator, denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; var numerator: Int32; var denominator: Int32): UInt32 := GetMscRateOML(dpy, drawable, @numerator, @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; var numerator: Int32; denominator: pointer): UInt32 := GetMscRateOML(dpy, drawable, @numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: pointer; denominator: array of Int32): UInt32 := GetMscRateOML(dpy, drawable, numerator, denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: pointer; var denominator: Int32): UInt32 := GetMscRateOML(dpy, drawable, numerator, @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: pointer; denominator: pointer): UInt32 := z_GetMscRateOML(dpy, drawable, numerator, denominator);
    
    public z_SwapBuffersMscOML := GetGLFuncOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>('glXSwapBuffersMscOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapBuffersMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 := z_SwapBuffersMscOML(dpy, drawable, target_msc, divisor, remainder);
    
    public z_WaitForMscOML := GetGLFuncOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32>('glXWaitForMscOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_WaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    
    public z_WaitForSbcOML := GetGLFuncOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32>('glXWaitForSbcOML');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := WaitForSbcOML(dpy, drawable, target_sbc, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_WaitForSbcOML(dpy, drawable, target_sbc, ust, msc, sbc);
    
    {$endregion OML_sync_control}
    
    {$region EXT_stereo_tree}
    
    public z_GetSelectedEvent := GetGLFuncOrNil&<procedure(dpy: PDisplay; draw: GLXDrawable; event_mask: pointer)>('glXGetSelectedEvent');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEvent(dpy: PDisplay; draw: GLXDrawable; event_mask: array of UInt64) := GetSelectedEvent(dpy, draw, event_mask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEvent(dpy: PDisplay; draw: GLXDrawable; var event_mask: UInt64) := GetSelectedEvent(dpy, draw, @event_mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEvent(dpy: PDisplay; draw: GLXDrawable; event_mask: pointer) := z_GetSelectedEvent(dpy, draw, event_mask);
    
    {$endregion EXT_stereo_tree}
    
    {$region EXT_swap_control}
    
    public z_SwapIntervalEXT := GetGLFuncOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; interval: Int32)>('glXSwapIntervalEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SwapIntervalEXT(dpy: PDisplay; drawable: GLXDrawable; interval: Int32) := z_SwapIntervalEXT(dpy, drawable, interval);
    
    {$endregion EXT_swap_control}
    
    {$region MESA_swap_control}
    
    public z_SwapIntervalMESA := GetGLFuncOrNil&<function(interval: UInt32): Int32>('glXSwapIntervalMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapIntervalMESA(interval: UInt32): Int32 := z_SwapIntervalMESA(interval);
    
    public z_GetSwapIntervalMESA := GetGLFuncOrNil&<function: Int32>('glXGetSwapIntervalMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSwapIntervalMESA: Int32 := z_GetSwapIntervalMESA;
    
    {$endregion MESA_swap_control}
    
    {$region SUN_get_transparent_index}
    
    public z_GetTransparentIndexSUN := GetGLFuncOrNil&<function(dpy: PDisplay; overlay: GLXWindow; underlay: GLXWindow; pTransparentIndex: pointer): GLXStatus>('glXGetTransparentIndexSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTransparentIndexSUN(dpy: PDisplay; overlay: GLXWindow; underlay: GLXWindow; pTransparentIndex: array of UInt64): GLXStatus := GetTransparentIndexSUN(dpy, overlay, underlay, pTransparentIndex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTransparentIndexSUN(dpy: PDisplay; overlay: GLXWindow; underlay: GLXWindow; var pTransparentIndex: UInt64): GLXStatus := GetTransparentIndexSUN(dpy, overlay, underlay, @pTransparentIndex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTransparentIndexSUN(dpy: PDisplay; overlay: GLXWindow; underlay: GLXWindow; pTransparentIndex: pointer): GLXStatus := z_GetTransparentIndexSUN(dpy, overlay, underlay, pTransparentIndex);
    
    {$endregion SUN_get_transparent_index}
    
    {$region SGI_video_sync}
    
    public z_GetVideoSyncSGI := GetGLFuncOrNil&<function(count: pointer): Int32>('glXGetVideoSyncSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoSyncSGI(count: array of UInt32): Int32 := GetVideoSyncSGI(count[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoSyncSGI(var count: UInt32): Int32 := GetVideoSyncSGI(@count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoSyncSGI(count: pointer): Int32 := z_GetVideoSyncSGI(count);
    
    public z_WaitVideoSyncSGI := GetGLFuncOrNil&<function(divisor: Int32; remainder: Int32; count: pointer): Int32>('glXWaitVideoSyncSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; count: array of UInt32): Int32 := WaitVideoSyncSGI(divisor, remainder, count[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; var count: UInt32): Int32 := WaitVideoSyncSGI(divisor, remainder, @count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; count: pointer): Int32 := z_WaitVideoSyncSGI(divisor, remainder, count);
    
    {$endregion SGI_video_sync}
    
    {$region SGIX_swap_group}
    
    public z_JoinSwapGroupSGIX := GetGLFuncOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; member: GLXDrawable)>('glXJoinSwapGroupSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure JoinSwapGroupSGIX(dpy: PDisplay; drawable: GLXDrawable; member: GLXDrawable) := z_JoinSwapGroupSGIX(dpy, drawable, member);
    
    {$endregion SGIX_swap_group}
    
    {$region MESA_query_renderer}
    
    public z_QueryRendererIntegerMESA := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32; value: pointer): UInt32>('glXQueryRendererIntegerMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32; value: array of UInt32): UInt32 := QueryRendererIntegerMESA(dpy, screen, renderer, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32; var value: UInt32): UInt32 := QueryRendererIntegerMESA(dpy, screen, renderer, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32; value: pointer): UInt32 := z_QueryRendererIntegerMESA(dpy, screen, renderer, attribute, value);
    
    public z_QueryCurrentRendererIntegerMESA := GetGLFuncOrNil&<function(attribute: Int32; value: pointer): UInt32>('glXQueryCurrentRendererIntegerMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; value: array of UInt32): UInt32 := QueryCurrentRendererIntegerMESA(attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; var value: UInt32): UInt32 := QueryCurrentRendererIntegerMESA(attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; value: pointer): UInt32 := z_QueryCurrentRendererIntegerMESA(attribute, value);
    
    public z_QueryRendererStringMESA := GetGLFuncOrNil&<function(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32): IntPtr>('glXQueryRendererStringMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererStringMESA_Str(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32): string := Marshal.PtrToStringAnsi(QueryRendererStringMESA(dpy, screen, renderer, attribute));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererStringMESA(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32): IntPtr := z_QueryRendererStringMESA(dpy, screen, renderer, attribute);
    
    public z_QueryCurrentRendererStringMESA := GetGLFuncOrNil&<function(attribute: Int32): IntPtr>('glXQueryCurrentRendererStringMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererStringMESA_Str(attribute: Int32): string := Marshal.PtrToStringAnsi(QueryCurrentRendererStringMESA(attribute));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererStringMESA(attribute: Int32): IntPtr := z_QueryCurrentRendererStringMESA(attribute);
    
    {$endregion MESA_query_renderer}
    
    {$region MESA_release_buffers}
    
    public z_ReleaseBuffersMESA := GetGLFuncOrNil&<function(dpy: PDisplay; drawable: GLXDrawable): UInt32>('glXReleaseBuffersMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseBuffersMESA(dpy: PDisplay; drawable: GLXDrawable): UInt32 := z_ReleaseBuffersMESA(dpy, drawable);
    
    {$endregion MESA_release_buffers}
    
    {$region MESA_set_3dfx_mode}
    
    public z_Set3DfxModeMESA := GetGLFuncOrNil&<function(mode: Int32): boolean>('glXSet3DfxModeMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function Set3DfxModeMESA(mode: Int32): boolean := z_Set3DfxModeMESA(mode);
    
    {$endregion MESA_set_3dfx_mode}
    
    {$region SGI_swap_control}
    
    public z_SwapIntervalSGI := GetGLFuncOrNil&<function(interval: Int32): Int32>('glXSwapIntervalSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapIntervalSGI(interval: Int32): Int32 := z_SwapIntervalSGI(interval);
    
    {$endregion SGI_swap_control}
    
  end;
  
  gl_ARB = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region ARB_shader_objects}
    
    public z_DeleteObjectARB := GetGLFuncOrNil&<procedure(obj: GLhandleARB)>('glDeleteObjectARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteObjectARB(obj: GLhandleARB) := z_DeleteObjectARB(obj);
    
    public z_GetHandleARB := GetGLFuncOrNil&<function(pname: DummyEnum): GLhandleARB>('glGetHandleARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetHandleARB(pname: DummyEnum): GLhandleARB := z_GetHandleARB(pname);
    
    public z_DetachObjectARB := GetGLFuncOrNil&<procedure(containerObj: GLhandleARB; attachedObj: GLhandleARB)>('glDetachObjectARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetachObjectARB(containerObj: GLhandleARB; attachedObj: GLhandleARB) := z_DetachObjectARB(containerObj, attachedObj);
    
    public z_CreateShaderObjectARB := GetGLFuncOrNil&<function(shaderType: DummyEnum): GLhandleARB>('glCreateShaderObjectARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderObjectARB(shaderType: DummyEnum): GLhandleARB := z_CreateShaderObjectARB(shaderType);
    
    public z_ShaderSourceARB := GetGLFuncOrNil&<procedure(shaderObj: GLhandleARB; count: Int32; string: pointer; length: pointer)>('glShaderSourceARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: GLhandleARB; count: Int32; string: array of IntPtr; length: array of Int32) := ShaderSourceARB(shaderObj, count, string[0], length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: GLhandleARB; count: Int32; string: array of IntPtr; var length: Int32) := ShaderSourceARB(shaderObj, count, string[0], @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: GLhandleARB; count: Int32; string: array of IntPtr; length: pointer) := ShaderSourceARB(shaderObj, count, string[0], length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: GLhandleARB; count: Int32; var string: IntPtr; length: array of Int32) := ShaderSourceARB(shaderObj, count, @string, length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: GLhandleARB; count: Int32; var string: IntPtr; var length: Int32) := ShaderSourceARB(shaderObj, count, @string, @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: GLhandleARB; count: Int32; var string: IntPtr; length: pointer) := ShaderSourceARB(shaderObj, count, @string, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: GLhandleARB; count: Int32; string: pointer; length: array of Int32) := ShaderSourceARB(shaderObj, count, string, length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: GLhandleARB; count: Int32; string: pointer; var length: Int32) := ShaderSourceARB(shaderObj, count, string, @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderSourceARB(shaderObj: GLhandleARB; count: Int32; string: pointer; length: pointer) := z_ShaderSourceARB(shaderObj, count, string, length);
    
    public z_CompileShaderARB := GetGLFuncOrNil&<procedure(shaderObj: GLhandleARB)>('glCompileShaderARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderARB(shaderObj: GLhandleARB) := z_CompileShaderARB(shaderObj);
    
    public z_CreateProgramObjectARB := GetGLFuncOrNil&<function: GLhandleARB>('glCreateProgramObjectARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgramObjectARB: GLhandleARB := z_CreateProgramObjectARB;
    
    public z_AttachObjectARB := GetGLFuncOrNil&<procedure(containerObj: GLhandleARB; obj: GLhandleARB)>('glAttachObjectARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AttachObjectARB(containerObj: GLhandleARB; obj: GLhandleARB) := z_AttachObjectARB(containerObj, obj);
    
    public z_LinkProgramARB := GetGLFuncOrNil&<procedure(programObj: GLhandleARB)>('glLinkProgramARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LinkProgramARB(programObj: GLhandleARB) := z_LinkProgramARB(programObj);
    
    public z_UseProgramObjectARB := GetGLFuncOrNil&<procedure(programObj: GLhandleARB)>('glUseProgramObjectARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgramObjectARB(programObj: GLhandleARB) := z_UseProgramObjectARB(programObj);
    
    public z_ValidateProgramARB := GetGLFuncOrNil&<procedure(programObj: GLhandleARB)>('glValidateProgramARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgramARB(programObj: GLhandleARB) := z_ValidateProgramARB(programObj);
    
    public z_Uniform1fARB := GetGLFuncOrNil&<procedure(location: Int32; v0: single)>('glUniform1fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fARB(location: Int32; v0: single) := z_Uniform1fARB(location, v0);
    
    public z_Uniform2fARB := GetGLFuncOrNil&<procedure(location: Int32; v0: single; v1: single)>('glUniform2fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fARB(location: Int32; v0: single; v1: single) := z_Uniform2fARB(location, v0, v1);
    
    public z_Uniform3fARB := GetGLFuncOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single)>('glUniform3fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fARB(location: Int32; v0: single; v1: single; v2: single) := z_Uniform3fARB(location, v0, v1, v2);
    
    public z_Uniform4fARB := GetGLFuncOrNil&<procedure(location: Int32; v0: single; v1: single; v2: single; v3: single)>('glUniform4fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fARB(location: Int32; v0: single; v1: single; v2: single; v3: single) := z_Uniform4fARB(location, v0, v1, v2, v3);
    
    public z_Uniform1iARB := GetGLFuncOrNil&<procedure(location: Int32; v0: Int32)>('glUniform1iARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1iARB(location: Int32; v0: Int32) := z_Uniform1iARB(location, v0);
    
    public z_Uniform2iARB := GetGLFuncOrNil&<procedure(location: Int32; v0: Int32; v1: Int32)>('glUniform2iARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2iARB(location: Int32; v0: Int32; v1: Int32) := z_Uniform2iARB(location, v0, v1);
    
    public z_Uniform3iARB := GetGLFuncOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32)>('glUniform3iARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3iARB(location: Int32; v0: Int32; v1: Int32; v2: Int32) := z_Uniform3iARB(location, v0, v1, v2);
    
    public z_Uniform4iARB := GetGLFuncOrNil&<procedure(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>('glUniform4iARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4iARB(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) := z_Uniform4iARB(location, v0, v1, v2, v3);
    
    public z_Uniform1fvARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fvARB(location: Int32; count: Int32; value: array of single) := Uniform1fvARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fvARB(location: Int32; count: Int32; var value: single) := Uniform1fvARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1fvARB(location: Int32; count: Int32; value: pointer) := z_Uniform1fvARB(location, count, value);
    
    public z_Uniform2fvARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; value: array of single) := Uniform2fvARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; var value: single) := Uniform2fvARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2fvARB(location: Int32; count: Int32; value: pointer) := z_Uniform2fvARB(location, count, value);
    
    public z_Uniform3fvARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; value: array of single) := Uniform3fvARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; var value: single) := Uniform3fvARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3fvARB(location: Int32; count: Int32; value: pointer) := z_Uniform3fvARB(location, count, value);
    
    public z_Uniform4fvARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; value: array of single) := Uniform4fvARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; var value: single) := Uniform4fvARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4fvARB(location: Int32; count: Int32; value: pointer) := z_Uniform4fvARB(location, count, value);
    
    public z_Uniform1ivARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ivARB(location: Int32; count: Int32; value: array of Int32) := Uniform1ivARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ivARB(location: Int32; count: Int32; var value: Int32) := Uniform1ivARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ivARB(location: Int32; count: Int32; value: pointer) := z_Uniform1ivARB(location, count, value);
    
    public z_Uniform2ivARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; value: array of Int32) := Uniform2ivARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; var value: Int32) := Uniform2ivARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ivARB(location: Int32; count: Int32; value: pointer) := z_Uniform2ivARB(location, count, value);
    
    public z_Uniform3ivARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; value: array of Int32) := Uniform3ivARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; var value: Int32) := Uniform3ivARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ivARB(location: Int32; count: Int32; value: pointer) := z_Uniform3ivARB(location, count, value);
    
    public z_Uniform4ivARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; value: array of Int32) := Uniform4ivARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; var value: Int32) := Uniform4ivARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ivARB(location: Int32; count: Int32; value: pointer) := z_Uniform4ivARB(location, count, value);
    
    public z_UniformMatrix2fvARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix2fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix2fvARB(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix2fvARB(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2fvARB(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix2fvARB(location, count, transpose, value);
    
    public z_UniformMatrix3fvARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix3fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix3fvARB(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix3fvARB(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3fvARB(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix3fvARB(location, count, transpose, value);
    
    public z_UniformMatrix4fvARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix4fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix4fvARB(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix4fvARB(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4fvARB(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix4fvARB(location, count, transpose, value);
    
    public z_GetObjectParameterfvARB := GetGLFuncOrNil&<procedure(obj: GLhandleARB; pname: DummyEnum; &params: pointer)>('glGetObjectParameterfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterfvARB(obj: GLhandleARB; pname: DummyEnum; &params: array of single) := GetObjectParameterfvARB(obj, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterfvARB(obj: GLhandleARB; pname: DummyEnum; var &params: single) := GetObjectParameterfvARB(obj, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterfvARB(obj: GLhandleARB; pname: DummyEnum; &params: pointer) := z_GetObjectParameterfvARB(obj, pname, &params);
    
    public z_GetObjectParameterivARB := GetGLFuncOrNil&<procedure(obj: GLhandleARB; pname: DummyEnum; &params: pointer)>('glGetObjectParameterivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivARB(obj: GLhandleARB; pname: DummyEnum; &params: array of Int32) := GetObjectParameterivARB(obj, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivARB(obj: GLhandleARB; pname: DummyEnum; var &params: Int32) := GetObjectParameterivARB(obj, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivARB(obj: GLhandleARB; pname: DummyEnum; &params: pointer) := z_GetObjectParameterivARB(obj, pname, &params);
    
    public z_GetInfoLogARB := GetGLFuncOrNil&<procedure(obj: GLhandleARB; maxLength: Int32; length: pointer; infoLog: IntPtr)>('glGetInfoLogARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: array of Int32; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetInfoLogARB(obj, maxLength, length[0], ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: array of Int32; infoLog: IntPtr) := GetInfoLogARB(obj, maxLength, length[0], infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; var length: Int32; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetInfoLogARB(obj, maxLength, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; var length: Int32; infoLog: IntPtr) := GetInfoLogARB(obj, maxLength, @length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: pointer; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetInfoLogARB(obj, maxLength, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: pointer; infoLog: IntPtr) := z_GetInfoLogARB(obj, maxLength, length, infoLog);
    
    public z_GetAttachedObjectsARB := GetGLFuncOrNil&<procedure(containerObj: GLhandleARB; maxCount: Int32; count: pointer; obj: pointer)>('glGetAttachedObjectsARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: array of Int32; obj: array of GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, count[0], obj[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: array of Int32; var obj: GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, count[0], @obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: array of Int32; obj: pointer) := GetAttachedObjectsARB(containerObj, maxCount, count[0], obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; var count: Int32; obj: array of GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, @count, obj[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; var count: Int32; var obj: GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, @count, @obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; var count: Int32; obj: pointer) := GetAttachedObjectsARB(containerObj, maxCount, @count, obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: pointer; obj: array of GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, count, obj[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: pointer; var obj: GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, count, @obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: pointer; obj: pointer) := z_GetAttachedObjectsARB(containerObj, maxCount, count, obj);
    
    public z_GetUniformLocationARB := GetGLFuncOrNil&<function(programObj: GLhandleARB; name: IntPtr): Int32>('glGetUniformLocationARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocationARB(programObj: GLhandleARB; name: string): Int32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); Result := GetUniformLocationARB(programObj, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformLocationARB(programObj: GLhandleARB; name: IntPtr): Int32 := z_GetUniformLocationARB(programObj, name);
    
    public z_GetActiveUniformARB := GetGLFuncOrNil&<procedure(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr)>('glGetActiveUniformARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length[0], size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length[0], size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length[0], size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length[0], size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length[0], size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length[0], size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length[0], @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length[0], @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length[0], @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length[0], @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length[0], @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; &type: pointer; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length[0], @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length[0], size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length[0], size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length[0], size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length[0], size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length[0], size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; &type: pointer; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length[0], size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, @length, size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, @length, size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, @length, size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, @length, size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, @length, size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, @length, size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, @length, @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, @length, @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, @length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, @length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, @length, @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, @length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, @length, size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, @length, size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, @length, size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, @length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, @length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; &type: pointer; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, @length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length, size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length, size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length, size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length, size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length, size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length, size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length, @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length, @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length, @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; &type: pointer; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length, size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length, size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length, size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveUniformARB(programObj, index, maxLength, length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveUniformARB(programObj, index, maxLength, length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveUniformARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr) := z_GetActiveUniformARB(programObj, index, maxLength, length, size, &type, name);
    
    public z_GetUniformfvARB := GetGLFuncOrNil&<procedure(programObj: GLhandleARB; location: Int32; &params: pointer)>('glGetUniformfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfvARB(programObj: GLhandleARB; location: Int32; &params: array of single) := GetUniformfvARB(programObj, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfvARB(programObj: GLhandleARB; location: Int32; var &params: single) := GetUniformfvARB(programObj, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformfvARB(programObj: GLhandleARB; location: Int32; &params: pointer) := z_GetUniformfvARB(programObj, location, &params);
    
    public z_GetUniformivARB := GetGLFuncOrNil&<procedure(programObj: GLhandleARB; location: Int32; &params: pointer)>('glGetUniformivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformivARB(programObj: GLhandleARB; location: Int32; &params: array of Int32) := GetUniformivARB(programObj, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformivARB(programObj: GLhandleARB; location: Int32; var &params: Int32) := GetUniformivARB(programObj, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformivARB(programObj: GLhandleARB; location: Int32; &params: pointer) := z_GetUniformivARB(programObj, location, &params);
    
    public z_GetShaderSourceARB := GetGLFuncOrNil&<procedure(obj: GLhandleARB; maxLength: Int32; length: pointer; source: IntPtr)>('glGetShaderSourceARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSourceARB(obj: GLhandleARB; maxLength: Int32; length: array of Int32; source: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(source); GetShaderSourceARB(obj, maxLength, length[0], ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSourceARB(obj: GLhandleARB; maxLength: Int32; length: array of Int32; source: IntPtr) := GetShaderSourceARB(obj, maxLength, length[0], source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSourceARB(obj: GLhandleARB; maxLength: Int32; var length: Int32; source: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(source); GetShaderSourceARB(obj, maxLength, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSourceARB(obj: GLhandleARB; maxLength: Int32; var length: Int32; source: IntPtr) := GetShaderSourceARB(obj, maxLength, @length, source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSourceARB(obj: GLhandleARB; maxLength: Int32; length: pointer; source: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(source); GetShaderSourceARB(obj, maxLength, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShaderSourceARB(obj: GLhandleARB; maxLength: Int32; length: pointer; source: IntPtr) := z_GetShaderSourceARB(obj, maxLength, length, source);
    
    {$endregion ARB_shader_objects}
    
    {$region ARB_occlusion_query}
    
    public z_GenQueriesARB := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glGenQueriesARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesARB(n: Int32; ids: array of UInt32) := GenQueriesARB(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesARB(n: Int32; var ids: UInt32) := GenQueriesARB(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesARB(n: Int32; ids: pointer) := z_GenQueriesARB(n, ids);
    
    public z_DeleteQueriesARB := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glDeleteQueriesARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesARB(n: Int32; ids: array of UInt32) := DeleteQueriesARB(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesARB(n: Int32; var ids: UInt32) := DeleteQueriesARB(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesARB(n: Int32; ids: pointer) := z_DeleteQueriesARB(n, ids);
    
    public z_IsQueryARB := GetGLFuncOrNil&<function(id: UInt32): boolean>('glIsQueryARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsQueryARB(id: UInt32): boolean := z_IsQueryARB(id);
    
    public z_BeginQueryARB := GetGLFuncOrNil&<procedure(target: DummyEnum; id: UInt32)>('glBeginQueryARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQueryARB(target: DummyEnum; id: UInt32) := z_BeginQueryARB(target, id);
    
    public z_EndQueryARB := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glEndQueryARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQueryARB(target: DummyEnum) := z_EndQueryARB(target);
    
    public z_GetQueryivARB := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetQueryivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryivARB(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetQueryivARB(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryivARB(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetQueryivARB(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryivARB(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetQueryivARB(target, pname, &params);
    
    public z_GetQueryObjectivARB := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetQueryObjectivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectivARB(id: UInt32; pname: DummyEnum; &params: array of Int32) := GetQueryObjectivARB(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectivARB(id: UInt32; pname: DummyEnum; var &params: Int32) := GetQueryObjectivARB(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectivARB(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetQueryObjectivARB(id, pname, &params);
    
    public z_GetQueryObjectuivARB := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetQueryObjectuivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuivARB(id: UInt32; pname: DummyEnum; &params: array of UInt32) := GetQueryObjectuivARB(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuivARB(id: UInt32; pname: DummyEnum; var &params: UInt32) := GetQueryObjectuivARB(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuivARB(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetQueryObjectuivARB(id, pname, &params);
    
    {$endregion ARB_occlusion_query}
    
    {$region ARB_vertex_shader}
    
    public z_BindAttribLocationARB := GetGLFuncOrNil&<procedure(programObj: GLhandleARB; index: UInt32; name: IntPtr)>('glBindAttribLocationARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocationARB(programObj: GLhandleARB; index: UInt32; name: string); begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); BindAttribLocationARB(programObj, index, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindAttribLocationARB(programObj: GLhandleARB; index: UInt32; name: IntPtr) := z_BindAttribLocationARB(programObj, index, name);
    
    public z_GetActiveAttribARB := GetGLFuncOrNil&<procedure(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr)>('glGetActiveAttribARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length[0], size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length[0], size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length[0], size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length[0], size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length[0], size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length[0], size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length[0], @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length[0], @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length[0], @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length[0], @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length[0], @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; var size: Int32; &type: pointer; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length[0], @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length[0], size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length[0], size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length[0], size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length[0], size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length[0], size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: array of Int32; size: pointer; &type: pointer; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length[0], size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, @length, size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, @length, size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, @length, size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, @length, size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, @length, size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, @length, size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, @length, @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, @length, @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, @length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, @length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, @length, @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, @length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, @length, size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, @length, size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, @length, size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, @length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, @length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; var length: Int32; size: pointer; &type: pointer; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, @length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length, size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length, size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length, size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length, size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length, size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length, size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length, @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length, @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length, @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; var size: Int32; &type: pointer; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length, size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length, size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length, size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveAttribARB(programObj, index, maxLength, length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveAttribARB(programObj, index, maxLength, length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveAttribARB(programObj: GLhandleARB; index: UInt32; maxLength: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr) := z_GetActiveAttribARB(programObj, index, maxLength, length, size, &type, name);
    
    public z_GetAttribLocationARB := GetGLFuncOrNil&<function(programObj: GLhandleARB; name: IntPtr): Int32>('glGetAttribLocationARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocationARB(programObj: GLhandleARB; name: string): Int32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); Result := GetAttribLocationARB(programObj, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAttribLocationARB(programObj: GLhandleARB; name: IntPtr): Int32 := z_GetAttribLocationARB(programObj, name);
    
    {$endregion ARB_vertex_shader}
    
    {$region ARB_vertex_buffer_object}
    
    public z_BindBufferARB := GetGLFuncOrNil&<procedure(target: DummyEnum; buffer: UInt32)>('glBindBufferARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferARB(target: DummyEnum; buffer: UInt32) := z_BindBufferARB(target, buffer);
    
    public z_DeleteBuffersARB := GetGLFuncOrNil&<procedure(n: Int32; buffers: pointer)>('glDeleteBuffersARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffersARB(n: Int32; buffers: array of UInt32) := DeleteBuffersARB(n, buffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffersARB(n: Int32; var buffers: UInt32) := DeleteBuffersARB(n, @buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBuffersARB(n: Int32; buffers: pointer) := z_DeleteBuffersARB(n, buffers);
    
    public z_GenBuffersARB := GetGLFuncOrNil&<procedure(n: Int32; buffers: pointer)>('glGenBuffersARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffersARB(n: Int32; buffers: array of UInt32) := GenBuffersARB(n, buffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffersARB(n: Int32; var buffers: UInt32) := GenBuffersARB(n, @buffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenBuffersARB(n: Int32; buffers: pointer) := z_GenBuffersARB(n, buffers);
    
    public z_IsBufferARB := GetGLFuncOrNil&<function(buffer: UInt32): boolean>('glIsBufferARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsBufferARB(buffer: UInt32): boolean := z_IsBufferARB(buffer);
    
    public z_BufferDataARB := GetGLFuncOrNil&<procedure(target: DummyEnum; size: UIntPtr; data: pointer; usage: DummyEnum)>('glBufferDataARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferDataARB(target: DummyEnum; size: UIntPtr; data: pointer; usage: DummyEnum) := z_BufferDataARB(target, size, data, usage);
    
    public z_BufferSubDataARB := GetGLFuncOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; data: pointer)>('glBufferSubDataARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferSubDataARB(target: DummyEnum; offset: IntPtr; size: UIntPtr; data: pointer) := z_BufferSubDataARB(target, offset, size, data);
    
    public z_GetBufferSubDataARB := GetGLFuncOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; data: pointer)>('glGetBufferSubDataARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferSubDataARB(target: DummyEnum; offset: IntPtr; size: UIntPtr; data: pointer) := z_GetBufferSubDataARB(target, offset, size, data);
    
    public z_MapBufferARB := GetGLFuncOrNil&<function(target: DummyEnum; access: DummyEnum): pointer>('glMapBufferARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBufferARB(target: DummyEnum; access: DummyEnum): pointer := z_MapBufferARB(target, access);
    
    public z_UnmapBufferARB := GetGLFuncOrNil&<function(target: DummyEnum): boolean>('glUnmapBufferARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapBufferARB(target: DummyEnum): boolean := z_UnmapBufferARB(target);
    
    public z_GetBufferParameterivARB := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetBufferParameterivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterivARB(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetBufferParameterivARB(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterivARB(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetBufferParameterivARB(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterivARB(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetBufferParameterivARB(target, pname, &params);
    
    public z_GetBufferPointervARB := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetBufferPointervARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointervARB(target: DummyEnum; pname: DummyEnum; &params: array of IntPtr) := GetBufferPointervARB(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointervARB(target: DummyEnum; pname: DummyEnum; var &params: IntPtr) := GetBufferPointervARB(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointervARB(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetBufferPointervARB(target, pname, &params);
    
    {$endregion ARB_vertex_buffer_object}
    
    {$region ARB_fragment_program ARB_vertex_program}
    
    public z_ProgramStringARB := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; len: Int32; string: pointer)>('glProgramStringARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramStringARB(target: DummyEnum; format: DummyEnum; len: Int32; string: pointer) := z_ProgramStringARB(target, format, len, string);
    
    public z_BindProgramARB := GetGLFuncOrNil&<procedure(target: DummyEnum; &program: UInt32)>('glBindProgramARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramARB(target: DummyEnum; &program: UInt32) := z_BindProgramARB(target, &program);
    
    public z_DeleteProgramsARB := GetGLFuncOrNil&<procedure(n: Int32; programs: pointer)>('glDeleteProgramsARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: array of UInt32) := DeleteProgramsARB(n, programs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; var programs: UInt32) := DeleteProgramsARB(n, @programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: pointer) := z_DeleteProgramsARB(n, programs);
    
    public z_GenProgramsARB := GetGLFuncOrNil&<procedure(n: Int32; programs: pointer)>('glGenProgramsARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: array of UInt32) := GenProgramsARB(n, programs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; var programs: UInt32) := GenProgramsARB(n, @programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: pointer) := z_GenProgramsARB(n, programs);
    
    public z_ProgramEnvParameter4dARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double)>('glProgramEnvParameter4dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dARB(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := z_ProgramEnvParameter4dARB(target, index, x, y, z, w);
    
    public z_ProgramEnvParameter4dvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glProgramEnvParameter4dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: DummyEnum; index: UInt32; &params: array of double) := ProgramEnvParameter4dvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: DummyEnum; index: UInt32; var &params: double) := ProgramEnvParameter4dvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramEnvParameter4dvARB(target, index, &params);
    
    public z_ProgramEnvParameter4fARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single)>('glProgramEnvParameter4fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fARB(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := z_ProgramEnvParameter4fARB(target, index, x, y, z, w);
    
    public z_ProgramEnvParameter4fvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glProgramEnvParameter4fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: DummyEnum; index: UInt32; &params: array of single) := ProgramEnvParameter4fvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: DummyEnum; index: UInt32; var &params: single) := ProgramEnvParameter4fvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramEnvParameter4fvARB(target, index, &params);
    
    public z_GetProgramEnvParameterdvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glGetProgramEnvParameterdvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: DummyEnum; index: UInt32; &params: array of double) := GetProgramEnvParameterdvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: DummyEnum; index: UInt32; var &params: double) := GetProgramEnvParameterdvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramEnvParameterdvARB(target, index, &params);
    
    public z_GetProgramEnvParameterfvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glGetProgramEnvParameterfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: DummyEnum; index: UInt32; &params: array of single) := GetProgramEnvParameterfvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: DummyEnum; index: UInt32; var &params: single) := GetProgramEnvParameterfvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramEnvParameterfvARB(target, index, &params);
    
    public z_GetProgramivARB := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetProgramivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetProgramivARB(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetProgramivARB(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivARB(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetProgramivARB(target, pname, &params);
    
    public z_GetProgramStringARB := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; string: pointer)>('glGetProgramStringARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringARB(target: DummyEnum; pname: DummyEnum; string: pointer) := z_GetProgramStringARB(target, pname, string);
    
    public z_IsProgramARB := GetGLFuncOrNil&<function(&program: UInt32): boolean>('glIsProgramARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramARB(&program: UInt32): boolean := z_IsProgramARB(&program);
    
    {$endregion ARB_fragment_program ARB_vertex_program}
    
    {$region ARB_draw_buffers_blend}
    
    public z_BlendEquationiARB := GetGLFuncOrNil&<procedure(buf: UInt32; mode: DummyEnum)>('glBlendEquationiARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationiARB(buf: UInt32; mode: DummyEnum) := z_BlendEquationiARB(buf, mode);
    
    public z_BlendEquationSeparateiARB := GetGLFuncOrNil&<procedure(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum)>('glBlendEquationSeparateiARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateiARB(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum) := z_BlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
    
    public z_BlendFunciARB := GetGLFuncOrNil&<procedure(buf: UInt32; src: DummyEnum; dst: DummyEnum)>('glBlendFunciARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunciARB(buf: UInt32; src: DummyEnum; dst: DummyEnum) := z_BlendFunciARB(buf, src, dst);
    
    public z_BlendFuncSeparateiARB := GetGLFuncOrNil&<procedure(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum)>('glBlendFuncSeparateiARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateiARB(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum) := z_BlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    {$endregion ARB_draw_buffers_blend}
    
    {$region ARB_color_buffer_float}
    
    public z_ClampColorARB := GetGLFuncOrNil&<procedure(target: DummyEnum; clamp: DummyEnum)>('glClampColorARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClampColorARB(target: DummyEnum; clamp: DummyEnum) := z_ClampColorARB(target, clamp);
    
    {$endregion ARB_color_buffer_float}
    
    {$region ARB_vertex_type_2_10_10_10_rev}
    
    public z_VertexP2ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; value: UInt32)>('glVertexP2ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2ui(&type: DummyEnum; value: UInt32) := z_VertexP2ui(&type, value);
    
    public z_VertexP3ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; value: UInt32)>('glVertexP3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3ui(&type: DummyEnum; value: UInt32) := z_VertexP3ui(&type, value);
    
    public z_VertexP4ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; value: UInt32)>('glVertexP4ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4ui(&type: DummyEnum; value: UInt32) := z_VertexP4ui(&type, value);
    
    public z_VertexP2uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; value: pointer)>('glVertexP2uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: DummyEnum; value: array of UInt32) := VertexP2uiv(&type, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: DummyEnum; var value: UInt32) := VertexP2uiv(&type, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: DummyEnum; value: pointer) := z_VertexP2uiv(&type, value);
    
    public z_VertexP3uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; value: pointer)>('glVertexP3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: DummyEnum; value: array of UInt32) := VertexP3uiv(&type, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: DummyEnum; var value: UInt32) := VertexP3uiv(&type, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: DummyEnum; value: pointer) := z_VertexP3uiv(&type, value);
    
    public z_VertexP4uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; value: pointer)>('glVertexP4uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: DummyEnum; value: array of UInt32) := VertexP4uiv(&type, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: DummyEnum; var value: UInt32) := VertexP4uiv(&type, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: DummyEnum; value: pointer) := z_VertexP4uiv(&type, value);
    
    public z_TexCoordP1ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; coords: UInt32)>('glTexCoordP1ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1ui(&type: DummyEnum; coords: UInt32) := z_TexCoordP1ui(&type, coords);
    
    public z_TexCoordP2ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; coords: UInt32)>('glTexCoordP2ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2ui(&type: DummyEnum; coords: UInt32) := z_TexCoordP2ui(&type, coords);
    
    public z_TexCoordP3ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; coords: UInt32)>('glTexCoordP3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3ui(&type: DummyEnum; coords: UInt32) := z_TexCoordP3ui(&type, coords);
    
    public z_TexCoordP4ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; coords: UInt32)>('glTexCoordP4ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4ui(&type: DummyEnum; coords: UInt32) := z_TexCoordP4ui(&type, coords);
    
    public z_TexCoordP1uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; coords: pointer)>('glTexCoordP1uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: DummyEnum; coords: array of UInt32) := TexCoordP1uiv(&type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: DummyEnum; var coords: UInt32) := TexCoordP1uiv(&type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: DummyEnum; coords: pointer) := z_TexCoordP1uiv(&type, coords);
    
    public z_TexCoordP2uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; coords: pointer)>('glTexCoordP2uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: DummyEnum; coords: array of UInt32) := TexCoordP2uiv(&type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: DummyEnum; var coords: UInt32) := TexCoordP2uiv(&type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: DummyEnum; coords: pointer) := z_TexCoordP2uiv(&type, coords);
    
    public z_TexCoordP3uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; coords: pointer)>('glTexCoordP3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: DummyEnum; coords: array of UInt32) := TexCoordP3uiv(&type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: DummyEnum; var coords: UInt32) := TexCoordP3uiv(&type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: DummyEnum; coords: pointer) := z_TexCoordP3uiv(&type, coords);
    
    public z_TexCoordP4uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; coords: pointer)>('glTexCoordP4uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: DummyEnum; coords: array of UInt32) := TexCoordP4uiv(&type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: DummyEnum; var coords: UInt32) := TexCoordP4uiv(&type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: DummyEnum; coords: pointer) := z_TexCoordP4uiv(&type, coords);
    
    public z_MultiTexCoordP1ui := GetGLFuncOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32)>('glMultiTexCoordP1ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1ui(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := z_MultiTexCoordP1ui(texture, &type, coords);
    
    public z_MultiTexCoordP2ui := GetGLFuncOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32)>('glMultiTexCoordP2ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2ui(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := z_MultiTexCoordP2ui(texture, &type, coords);
    
    public z_MultiTexCoordP3ui := GetGLFuncOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32)>('glMultiTexCoordP3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3ui(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := z_MultiTexCoordP3ui(texture, &type, coords);
    
    public z_MultiTexCoordP4ui := GetGLFuncOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32)>('glMultiTexCoordP4ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4ui(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := z_MultiTexCoordP4ui(texture, &type, coords);
    
    public z_MultiTexCoordP1uiv := GetGLFuncOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer)>('glMultiTexCoordP1uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: DummyEnum; &type: DummyEnum; coords: array of UInt32) := MultiTexCoordP1uiv(texture, &type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: DummyEnum; &type: DummyEnum; var coords: UInt32) := MultiTexCoordP1uiv(texture, &type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: DummyEnum; &type: DummyEnum; coords: pointer) := z_MultiTexCoordP1uiv(texture, &type, coords);
    
    public z_MultiTexCoordP2uiv := GetGLFuncOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer)>('glMultiTexCoordP2uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: DummyEnum; &type: DummyEnum; coords: array of UInt32) := MultiTexCoordP2uiv(texture, &type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: DummyEnum; &type: DummyEnum; var coords: UInt32) := MultiTexCoordP2uiv(texture, &type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: DummyEnum; &type: DummyEnum; coords: pointer) := z_MultiTexCoordP2uiv(texture, &type, coords);
    
    public z_MultiTexCoordP3uiv := GetGLFuncOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer)>('glMultiTexCoordP3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: DummyEnum; &type: DummyEnum; coords: array of UInt32) := MultiTexCoordP3uiv(texture, &type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: DummyEnum; &type: DummyEnum; var coords: UInt32) := MultiTexCoordP3uiv(texture, &type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: DummyEnum; &type: DummyEnum; coords: pointer) := z_MultiTexCoordP3uiv(texture, &type, coords);
    
    public z_MultiTexCoordP4uiv := GetGLFuncOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer)>('glMultiTexCoordP4uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: DummyEnum; &type: DummyEnum; coords: array of UInt32) := MultiTexCoordP4uiv(texture, &type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: DummyEnum; &type: DummyEnum; var coords: UInt32) := MultiTexCoordP4uiv(texture, &type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: DummyEnum; &type: DummyEnum; coords: pointer) := z_MultiTexCoordP4uiv(texture, &type, coords);
    
    public z_NormalP3ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; coords: UInt32)>('glNormalP3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3ui(&type: DummyEnum; coords: UInt32) := z_NormalP3ui(&type, coords);
    
    public z_NormalP3uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; coords: pointer)>('glNormalP3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: DummyEnum; coords: array of UInt32) := NormalP3uiv(&type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: DummyEnum; var coords: UInt32) := NormalP3uiv(&type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: DummyEnum; coords: pointer) := z_NormalP3uiv(&type, coords);
    
    public z_ColorP3ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; color: UInt32)>('glColorP3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3ui(&type: DummyEnum; color: UInt32) := z_ColorP3ui(&type, color);
    
    public z_ColorP4ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; color: UInt32)>('glColorP4ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4ui(&type: DummyEnum; color: UInt32) := z_ColorP4ui(&type, color);
    
    public z_ColorP3uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; color: pointer)>('glColorP3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: DummyEnum; color: array of UInt32) := ColorP3uiv(&type, color[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: DummyEnum; var color: UInt32) := ColorP3uiv(&type, @color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: DummyEnum; color: pointer) := z_ColorP3uiv(&type, color);
    
    public z_ColorP4uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; color: pointer)>('glColorP4uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: DummyEnum; color: array of UInt32) := ColorP4uiv(&type, color[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: DummyEnum; var color: UInt32) := ColorP4uiv(&type, @color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: DummyEnum; color: pointer) := z_ColorP4uiv(&type, color);
    
    public z_SecondaryColorP3ui := GetGLFuncOrNil&<procedure(&type: DummyEnum; color: UInt32)>('glSecondaryColorP3ui');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3ui(&type: DummyEnum; color: UInt32) := z_SecondaryColorP3ui(&type, color);
    
    public z_SecondaryColorP3uiv := GetGLFuncOrNil&<procedure(&type: DummyEnum; color: pointer)>('glSecondaryColorP3uiv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: DummyEnum; color: array of UInt32) := SecondaryColorP3uiv(&type, color[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: DummyEnum; var color: UInt32) := SecondaryColorP3uiv(&type, @color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: DummyEnum; color: pointer) := z_SecondaryColorP3uiv(&type, color);
    
    {$endregion ARB_vertex_type_2_10_10_10_rev}
    
    {$region ARB_shading_language_include}
    
    public z_NamedStringARB := GetGLFuncOrNil&<procedure(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; string: IntPtr)>('glNamedStringARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: string; stringlen: Int32; _string: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(_string); var ptr_3 := Marshal.StringToHGlobalAnsi(name); NamedStringARB(&type, namelen, ptr_3, stringlen, ptr_5); Marshal.FreeHGlobal(ptr_3); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: string; stringlen: Int32; string: IntPtr); begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); NamedStringARB(&type, namelen, ptr_3, stringlen, string); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; _string: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(_string); NamedStringARB(&type, namelen, name, stringlen, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; string: IntPtr) := z_NamedStringARB(&type, namelen, name, stringlen, string);
    
    public z_DeleteNamedStringARB := GetGLFuncOrNil&<procedure(namelen: Int32; name: IntPtr)>('glDeleteNamedStringARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamedStringARB(namelen: Int32; name: string); begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); DeleteNamedStringARB(namelen, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamedStringARB(namelen: Int32; name: IntPtr) := z_DeleteNamedStringARB(namelen, name);
    
    public z_CompileShaderIncludeARB := GetGLFuncOrNil&<procedure(shader: UInt32; count: Int32; path: pointer; length: pointer)>('glCompileShaderIncludeARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: array of IntPtr; length: array of Int32) := CompileShaderIncludeARB(shader, count, path[0], length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: array of IntPtr; var length: Int32) := CompileShaderIncludeARB(shader, count, path[0], @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: array of IntPtr; length: pointer) := CompileShaderIncludeARB(shader, count, path[0], length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; var path: IntPtr; length: array of Int32) := CompileShaderIncludeARB(shader, count, @path, length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; var path: IntPtr; var length: Int32) := CompileShaderIncludeARB(shader, count, @path, @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; var path: IntPtr; length: pointer) := CompileShaderIncludeARB(shader, count, @path, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: pointer; length: array of Int32) := CompileShaderIncludeARB(shader, count, path, length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: pointer; var length: Int32) := CompileShaderIncludeARB(shader, count, path, @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: pointer; length: pointer) := z_CompileShaderIncludeARB(shader, count, path, length);
    
    public z_IsNamedStringARB := GetGLFuncOrNil&<function(namelen: Int32; name: IntPtr): boolean>('glIsNamedStringARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedStringARB(namelen: Int32; name: string): boolean; begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); Result := IsNamedStringARB(namelen, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedStringARB(namelen: Int32; name: IntPtr): boolean := z_IsNamedStringARB(namelen, name);
    
    public z_GetNamedStringARB := GetGLFuncOrNil&<procedure(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: pointer; string: IntPtr)>('glGetNamedStringARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; stringlen: array of Int32; _string: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(_string); var ptr_2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr_2, bufSize, stringlen[0], ptr_5); Marshal.FreeHGlobal(ptr_2); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; stringlen: array of Int32; string: IntPtr); begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr_2, bufSize, stringlen[0], string); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; var stringlen: Int32; _string: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(_string); var ptr_2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr_2, bufSize, @stringlen, ptr_5); Marshal.FreeHGlobal(ptr_2); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; var stringlen: Int32; string: IntPtr); begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr_2, bufSize, @stringlen, string); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; stringlen: pointer; _string: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(_string); var ptr_2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr_2, bufSize, stringlen, ptr_5); Marshal.FreeHGlobal(ptr_2); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; stringlen: pointer; string: IntPtr); begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr_2, bufSize, stringlen, string); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: array of Int32; _string: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(_string); GetNamedStringARB(namelen, name, bufSize, stringlen[0], ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: array of Int32; string: IntPtr) := GetNamedStringARB(namelen, name, bufSize, stringlen[0], string);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; var stringlen: Int32; _string: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(_string); GetNamedStringARB(namelen, name, bufSize, @stringlen, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; var stringlen: Int32; string: IntPtr) := GetNamedStringARB(namelen, name, bufSize, @stringlen, string);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: pointer; _string: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(_string); GetNamedStringARB(namelen, name, bufSize, stringlen, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: pointer; string: IntPtr) := z_GetNamedStringARB(namelen, name, bufSize, stringlen, string);
    
    public z_GetNamedStringivARB := GetGLFuncOrNil&<procedure(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: pointer)>('glGetNamedStringivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: string; pname: DummyEnum; &params: array of Int32); begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringivARB(namelen, ptr_2, pname, &params[0]); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: string; pname: DummyEnum; var &params: Int32); begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringivARB(namelen, ptr_2, pname, @&params); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: string; pname: DummyEnum; &params: pointer); begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringivARB(namelen, ptr_2, pname, &params); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: array of Int32) := GetNamedStringivARB(namelen, name, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: IntPtr; pname: DummyEnum; var &params: Int32) := GetNamedStringivARB(namelen, name, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: pointer) := z_GetNamedStringivARB(namelen, name, pname, &params);
    
    {$endregion ARB_shading_language_include}
    
    {$region ARB_texture_compression}
    
    public z_CompressedTexImage3DARB := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: pointer)>('glCompressedTexImage3DARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage3DARB(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: pointer) := z_CompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data);
    
    public z_CompressedTexImage2DARB := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: pointer)>('glCompressedTexImage2DARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage2DARB(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: pointer) := z_CompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data);
    
    public z_CompressedTexImage1DARB := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; data: pointer)>('glCompressedTexImage1DARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage1DARB(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; data: pointer) := z_CompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data);
    
    public z_CompressedTexSubImage3DARB := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; data: pointer)>('glCompressedTexSubImage3DARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage3DARB(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; data: pointer) := z_CompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    public z_CompressedTexSubImage2DARB := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; imageSize: Int32; data: pointer)>('glCompressedTexSubImage2DARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage2DARB(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; imageSize: Int32; data: pointer) := z_CompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);
    
    public z_CompressedTexSubImage1DARB := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; imageSize: Int32; data: pointer)>('glCompressedTexSubImage1DARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage1DARB(target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; imageSize: Int32; data: pointer) := z_CompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);
    
    public z_GetCompressedTexImageARB := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; img: pointer)>('glGetCompressedTexImageARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTexImageARB(target: DummyEnum; level: Int32; img: pointer) := z_GetCompressedTexImageARB(target, level, img);
    
    {$endregion ARB_texture_compression}
    
    {$region ARB_cl_event}
    
    public z_CreateSyncFromCLeventARB := GetGLFuncOrNil&<function(context: pointer; &event: pointer; flags: DummyFlags): GLsync>('glCreateSyncFromCLeventARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: array of cl_context; &event: array of cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(context[0], &event[0], flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: array of cl_context; var &event: cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(context[0], @&event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: array of cl_context; &event: pointer; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(context[0], &event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(var context: cl_context; &event: array of cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(@context, &event[0], flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(var context: cl_context; var &event: cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(@context, @&event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(var context: cl_context; &event: pointer; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(@context, &event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: pointer; &event: array of cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(context, &event[0], flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: pointer; var &event: cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(context, @&event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: pointer; &event: pointer; flags: DummyFlags): GLsync := z_CreateSyncFromCLeventARB(context, &event, flags);
    
    {$endregion ARB_cl_event}
    
    {$region ARB_matrix_palette}
    
    public z_CurrentPaletteMatrixARB := GetGLFuncOrNil&<procedure(index: Int32)>('glCurrentPaletteMatrixARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CurrentPaletteMatrixARB(index: Int32) := z_CurrentPaletteMatrixARB(index);
    
    public z_MatrixIndexubvARB := GetGLFuncOrNil&<procedure(size: Int32; indices: pointer)>('glMatrixIndexubvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; indices: array of Byte) := MatrixIndexubvARB(size, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; var indices: Byte) := MatrixIndexubvARB(size, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; indices: pointer) := z_MatrixIndexubvARB(size, indices);
    
    public z_MatrixIndexusvARB := GetGLFuncOrNil&<procedure(size: Int32; indices: pointer)>('glMatrixIndexusvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; indices: array of UInt16) := MatrixIndexusvARB(size, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; var indices: UInt16) := MatrixIndexusvARB(size, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; indices: pointer) := z_MatrixIndexusvARB(size, indices);
    
    public z_MatrixIndexuivARB := GetGLFuncOrNil&<procedure(size: Int32; indices: pointer)>('glMatrixIndexuivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; indices: array of UInt32) := MatrixIndexuivARB(size, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; var indices: UInt32) := MatrixIndexuivARB(size, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; indices: pointer) := z_MatrixIndexuivARB(size, indices);
    
    public z_MatrixIndexPointerARB := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glMatrixIndexPointerARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexPointerARB(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_MatrixIndexPointerARB(size, &type, stride, _pointer);
    
    {$endregion ARB_matrix_palette}
    
    {$region ARB_debug_output}
    
    public z_DebugMessageControlARB := GetGLFuncOrNil&<procedure(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: pointer; enabled: boolean)>('glDebugMessageControlARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlARB(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: array of UInt32; enabled: boolean) := DebugMessageControlARB(source, &type, severity, count, ids[0], enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlARB(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; var ids: UInt32; enabled: boolean) := DebugMessageControlARB(source, &type, severity, count, @ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlARB(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: pointer; enabled: boolean) := z_DebugMessageControlARB(source, &type, severity, count, ids, enabled);
    
    public z_DebugMessageInsertARB := GetGLFuncOrNil&<procedure(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: IntPtr)>('glDebugMessageInsertARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertARB(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: string); begin var ptr_6 := Marshal.StringToHGlobalAnsi(buf); DebugMessageInsertARB(source, &type, id, severity, length, ptr_6); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertARB(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: IntPtr) := z_DebugMessageInsertARB(source, &type, id, severity, length, buf);
    
    public z_DebugMessageCallbackARB := GetGLFuncOrNil&<procedure(callback: GLDEBUGPROC; userParam: pointer)>('glDebugMessageCallbackARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallbackARB(callback: GLDEBUGPROC; userParam: pointer) := z_DebugMessageCallbackARB(callback, userParam);
    
    public z_GetDebugMessageLogARB := GetGLFuncOrNil&<function(count: UInt32; bufSize: Int32; sources: pointer; types: pointer; ids: pointer; severities: pointer; lengths: pointer; messageLog: IntPtr): UInt32>('glGetDebugMessageLogARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogARB(count: UInt32; bufSize: Int32; sources: array of DebugSourceType; types: array of DebugMessageType; ids: array of UInt32; severities: array of DebugSeverityLevel; lengths: array of Int32; messageLog: IntPtr): UInt32 := GetDebugMessageLogARB(count, bufSize, sources[0], types[0], ids[0], severities[0], lengths[0], messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogARB(count: UInt32; bufSize: Int32; var sources: DebugSourceType; var types: DebugMessageType; var ids: UInt32; var severities: DebugSeverityLevel; var lengths: Int32; messageLog: string): UInt32; begin var ptr_8 := Marshal.StringToHGlobalAnsi(messageLog); Result := GetDebugMessageLogARB(count, bufSize, @sources, @types, @ids, @severities, @lengths, ptr_8); Marshal.FreeHGlobal(ptr_8); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogARB(count: UInt32; bufSize: Int32; var sources: DebugSourceType; var types: DebugMessageType; var ids: UInt32; var severities: DebugSeverityLevel; var lengths: Int32; messageLog: IntPtr): UInt32 := GetDebugMessageLogARB(count, bufSize, @sources, @types, @ids, @severities, @lengths, messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogARB(count: UInt32; bufSize: Int32; sources: pointer; types: pointer; ids: pointer; severities: pointer; lengths: pointer; messageLog: string): UInt32; begin var ptr_8 := Marshal.StringToHGlobalAnsi(messageLog); Result := GetDebugMessageLogARB(count, bufSize, sources, types, ids, severities, lengths, ptr_8); Marshal.FreeHGlobal(ptr_8); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogARB(count: UInt32; bufSize: Int32; sources: pointer; types: pointer; ids: pointer; severities: pointer; lengths: pointer; messageLog: IntPtr): UInt32 := z_GetDebugMessageLogARB(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    
    {$endregion ARB_debug_output}
    
    {$region ARB_vertex_program ARB_vertex_shader}
    
    public z_VertexAttrib1sARB := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16)>('glVertexAttrib1sARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sARB(index: UInt32; x: Int16) := z_VertexAttrib1sARB(index, x);
    
    public z_VertexAttrib1fARB := GetGLFuncOrNil&<procedure(index: UInt32; x: single)>('glVertexAttrib1fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fARB(index: UInt32; x: single) := z_VertexAttrib1fARB(index, x);
    
    public z_VertexAttrib1dARB := GetGLFuncOrNil&<procedure(index: UInt32; x: double)>('glVertexAttrib1dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dARB(index: UInt32; x: double) := z_VertexAttrib1dARB(index, x);
    
    public z_VertexAttrib2sARB := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>('glVertexAttrib2sARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sARB(index: UInt32; x: Int16; y: Int16) := z_VertexAttrib2sARB(index, x, y);
    
    public z_VertexAttrib2fARB := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single)>('glVertexAttrib2fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fARB(index: UInt32; x: single; y: single) := z_VertexAttrib2fARB(index, x, y);
    
    public z_VertexAttrib2dARB := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double)>('glVertexAttrib2dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dARB(index: UInt32; x: double; y: double) := z_VertexAttrib2dARB(index, x, y);
    
    public z_VertexAttrib3sARB := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>('glVertexAttrib3sARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sARB(index: UInt32; x: Int16; y: Int16; z: Int16) := z_VertexAttrib3sARB(index, x, y, z);
    
    public z_VertexAttrib3fARB := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>('glVertexAttrib3fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fARB(index: UInt32; x: single; y: single; z: single) := z_VertexAttrib3fARB(index, x, y, z);
    
    public z_VertexAttrib3dARB := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>('glVertexAttrib3dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dARB(index: UInt32; x: double; y: double; z: double) := z_VertexAttrib3dARB(index, x, y, z);
    
    public z_VertexAttrib4sARB := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>('glVertexAttrib4sARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sARB(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) := z_VertexAttrib4sARB(index, x, y, z, w);
    
    public z_VertexAttrib4fARB := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>('glVertexAttrib4fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fARB(index: UInt32; x: single; y: single; z: single; w: single) := z_VertexAttrib4fARB(index, x, y, z, w);
    
    public z_VertexAttrib4dARB := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>('glVertexAttrib4dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dARB(index: UInt32; x: double; y: double; z: double; w: double) := z_VertexAttrib4dARB(index, x, y, z, w);
    
    public z_VertexAttrib4NubARB := GetGLFuncOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>('glVertexAttrib4NubARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubARB(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) := z_VertexAttrib4NubARB(index, x, y, z, w);
    
    public z_VertexAttrib1svARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib1svARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; v: array of Int16) := VertexAttrib1svARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; var v: Int16) := VertexAttrib1svARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svARB(index: UInt32; v: pointer) := z_VertexAttrib1svARB(index, v);
    
    public z_VertexAttrib1fvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib1fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; v: array of single) := VertexAttrib1fvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; var v: single) := VertexAttrib1fvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvARB(index: UInt32; v: pointer) := z_VertexAttrib1fvARB(index, v);
    
    public z_VertexAttrib1dvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib1dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; v: array of double) := VertexAttrib1dvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; var v: double) := VertexAttrib1dvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvARB(index: UInt32; v: pointer) := z_VertexAttrib1dvARB(index, v);
    
    public z_VertexAttrib2svARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib2svARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; v: array of Int16) := VertexAttrib2svARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; var v: Int16) := VertexAttrib2svARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svARB(index: UInt32; v: pointer) := z_VertexAttrib2svARB(index, v);
    
    public z_VertexAttrib2fvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib2fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; v: array of single) := VertexAttrib2fvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; var v: single) := VertexAttrib2fvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvARB(index: UInt32; v: pointer) := z_VertexAttrib2fvARB(index, v);
    
    public z_VertexAttrib2dvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib2dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; v: array of double) := VertexAttrib2dvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; var v: double) := VertexAttrib2dvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvARB(index: UInt32; v: pointer) := z_VertexAttrib2dvARB(index, v);
    
    public z_VertexAttrib3svARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib3svARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; v: array of Int16) := VertexAttrib3svARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; var v: Int16) := VertexAttrib3svARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svARB(index: UInt32; v: pointer) := z_VertexAttrib3svARB(index, v);
    
    public z_VertexAttrib3fvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib3fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; v: array of single) := VertexAttrib3fvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; var v: single) := VertexAttrib3fvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvARB(index: UInt32; v: pointer) := z_VertexAttrib3fvARB(index, v);
    
    public z_VertexAttrib3dvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib3dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; v: array of double) := VertexAttrib3dvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; var v: double) := VertexAttrib3dvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvARB(index: UInt32; v: pointer) := z_VertexAttrib3dvARB(index, v);
    
    public z_VertexAttrib4bvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4bvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; v: array of SByte) := VertexAttrib4bvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; var v: SByte) := VertexAttrib4bvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4bvARB(index: UInt32; v: pointer) := z_VertexAttrib4bvARB(index, v);
    
    public z_VertexAttrib4svARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4svARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; v: array of Int16) := VertexAttrib4svARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; var v: Int16) := VertexAttrib4svARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svARB(index: UInt32; v: pointer) := z_VertexAttrib4svARB(index, v);
    
    public z_VertexAttrib4ivARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; v: array of Int32) := VertexAttrib4ivARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; var v: Int32) := VertexAttrib4ivARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ivARB(index: UInt32; v: pointer) := z_VertexAttrib4ivARB(index, v);
    
    public z_VertexAttrib4ubvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4ubvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; v: array of Byte) := VertexAttrib4ubvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; var v: Byte) := VertexAttrib4ubvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvARB(index: UInt32; v: pointer) := z_VertexAttrib4ubvARB(index, v);
    
    public z_VertexAttrib4usvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4usvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; v: array of UInt16) := VertexAttrib4usvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; var v: UInt16) := VertexAttrib4usvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4usvARB(index: UInt32; v: pointer) := z_VertexAttrib4usvARB(index, v);
    
    public z_VertexAttrib4uivARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4uivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; v: array of UInt32) := VertexAttrib4uivARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; var v: UInt32) := VertexAttrib4uivARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4uivARB(index: UInt32; v: pointer) := z_VertexAttrib4uivARB(index, v);
    
    public z_VertexAttrib4fvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; v: array of single) := VertexAttrib4fvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; var v: single) := VertexAttrib4fvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvARB(index: UInt32; v: pointer) := z_VertexAttrib4fvARB(index, v);
    
    public z_VertexAttrib4dvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; v: array of double) := VertexAttrib4dvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; var v: double) := VertexAttrib4dvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvARB(index: UInt32; v: pointer) := z_VertexAttrib4dvARB(index, v);
    
    public z_VertexAttrib4NbvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4NbvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; v: array of SByte) := VertexAttrib4NbvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; var v: SByte) := VertexAttrib4NbvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NbvARB(index: UInt32; v: pointer) := z_VertexAttrib4NbvARB(index, v);
    
    public z_VertexAttrib4NsvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4NsvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; v: array of Int16) := VertexAttrib4NsvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; var v: Int16) := VertexAttrib4NsvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NsvARB(index: UInt32; v: pointer) := z_VertexAttrib4NsvARB(index, v);
    
    public z_VertexAttrib4NivARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4NivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; v: array of Int32) := VertexAttrib4NivARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; var v: Int32) := VertexAttrib4NivARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NivARB(index: UInt32; v: pointer) := z_VertexAttrib4NivARB(index, v);
    
    public z_VertexAttrib4NubvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4NubvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; v: array of Byte) := VertexAttrib4NubvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; var v: Byte) := VertexAttrib4NubvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NubvARB(index: UInt32; v: pointer) := z_VertexAttrib4NubvARB(index, v);
    
    public z_VertexAttrib4NusvARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4NusvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; v: array of UInt16) := VertexAttrib4NusvARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; var v: UInt16) := VertexAttrib4NusvARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NusvARB(index: UInt32; v: pointer) := z_VertexAttrib4NusvARB(index, v);
    
    public z_VertexAttrib4NuivARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4NuivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; v: array of UInt32) := VertexAttrib4NuivARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; var v: UInt32) := VertexAttrib4NuivARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4NuivARB(index: UInt32; v: pointer) := z_VertexAttrib4NuivARB(index, v);
    
    public z_VertexAttribPointerARB := GetGLFuncOrNil&<procedure(index: UInt32; size: Int32; &type: DummyEnum; normalized: boolean; stride: Int32; _pointer: pointer)>('glVertexAttribPointerARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointerARB(index: UInt32; size: Int32; &type: DummyEnum; normalized: boolean; stride: Int32; _pointer: pointer) := z_VertexAttribPointerARB(index, size, &type, normalized, stride, _pointer);
    
    public z_EnableVertexAttribArrayARB := GetGLFuncOrNil&<procedure(index: UInt32)>('glEnableVertexAttribArrayARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribArrayARB(index: UInt32) := z_EnableVertexAttribArrayARB(index);
    
    public z_DisableVertexAttribArrayARB := GetGLFuncOrNil&<procedure(index: UInt32)>('glDisableVertexAttribArrayARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribArrayARB(index: UInt32) := z_DisableVertexAttribArrayARB(index);
    
    public z_GetVertexAttribdvARB := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribdvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: DummyEnum; &params: array of double) := GetVertexAttribdvARB(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: DummyEnum; var &params: double) := GetVertexAttribdvARB(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvARB(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribdvARB(index, pname, &params);
    
    public z_GetVertexAttribfvARB := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: DummyEnum; &params: array of single) := GetVertexAttribfvARB(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: DummyEnum; var &params: single) := GetVertexAttribfvARB(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvARB(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribfvARB(index, pname, &params);
    
    public z_GetVertexAttribivARB := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: DummyEnum; &params: array of Int32) := GetVertexAttribivARB(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: DummyEnum; var &params: Int32) := GetVertexAttribivARB(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivARB(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribivARB(index, pname, &params);
    
    public z_GetVertexAttribPointervARB := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; _pointer: pointer)>('glGetVertexAttribPointervARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: DummyEnum; _pointer: array of IntPtr) := GetVertexAttribPointervARB(index, pname, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: DummyEnum; var _pointer: IntPtr) := GetVertexAttribPointervARB(index, pname, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervARB(index: UInt32; pname: DummyEnum; _pointer: pointer) := z_GetVertexAttribPointervARB(index, pname, _pointer);
    
    {$endregion ARB_vertex_program ARB_vertex_shader}
    
    {$region ARB_compute_variable_group_size}
    
    public z_DispatchComputeGroupSizeARB := GetGLFuncOrNil&<procedure(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32; group_size_x: UInt32; group_size_y: UInt32; group_size_z: UInt32)>('glDispatchComputeGroupSizeARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchComputeGroupSizeARB(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32; group_size_x: UInt32; group_size_y: UInt32; group_size_z: UInt32) := z_DispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
    
    {$endregion ARB_compute_variable_group_size}
    
    {$region ARB_draw_instanced}
    
    public z_DrawArraysInstancedARB := GetGLFuncOrNil&<procedure(mode: DummyEnum; first: Int32; count: Int32; primcount: Int32)>('glDrawArraysInstancedARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedARB(mode: DummyEnum; first: Int32; count: Int32; primcount: Int32) := z_DrawArraysInstancedARB(mode, first, count, primcount);
    
    public z_DrawElementsInstancedARB := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32)>('glDrawElementsInstancedARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedARB(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32) := z_DrawElementsInstancedARB(mode, count, &type, indices, primcount);
    
    {$endregion ARB_draw_instanced}
    
    {$region ARB_draw_buffers}
    
    public z_DrawBuffersARB := GetGLFuncOrNil&<procedure(n: Int32; bufs: pointer)>('glDrawBuffersARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersARB(n: Int32; bufs: array of DummyEnum) := DrawBuffersARB(n, bufs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersARB(n: Int32; var bufs: DummyEnum) := DrawBuffersARB(n, @bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersARB(n: Int32; bufs: pointer) := z_DrawBuffersARB(n, bufs);
    
    {$endregion ARB_draw_buffers}
    
    {$region OES_draw_texture}
    
    public z_DrawTexsOES := GetGLFuncOrNil&<procedure(x: Int16; y: Int16; z: Int16; width: Int16; height: Int16)>('glDrawTexsOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexsOES(x: Int16; y: Int16; z: Int16; width: Int16; height: Int16) := z_DrawTexsOES(x, y, z, width, height);
    
    public z_DrawTexiOES := GetGLFuncOrNil&<procedure(x: Int32; y: Int32; z: Int32; width: Int32; height: Int32)>('glDrawTexiOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexiOES(x: Int32; y: Int32; z: Int32; width: Int32; height: Int32) := z_DrawTexiOES(x, y, z, width, height);
    
    public z_DrawTexfOES := GetGLFuncOrNil&<procedure(x: single; y: single; z: single; width: single; height: single)>('glDrawTexfOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexfOES(x: single; y: single; z: single; width: single; height: single) := z_DrawTexfOES(x, y, z, width, height);
    
    public z_DrawTexxOES := GetGLFuncOrNil&<procedure(x: fixed; y: fixed; z: fixed; width: fixed; height: fixed)>('glDrawTexxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexxOES(x: fixed; y: fixed; z: fixed; width: fixed; height: fixed) := z_DrawTexxOES(x, y, z, width, height);
    
    public z_DrawTexsvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glDrawTexsvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexsvOES(coords: array of Int16) := DrawTexsvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexsvOES(var coords: Int16) := DrawTexsvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexsvOES(coords: pointer) := z_DrawTexsvOES(coords);
    
    public z_DrawTexivOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glDrawTexivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexivOES(coords: array of Int32) := DrawTexivOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexivOES(var coords: Int32) := DrawTexivOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexivOES(coords: pointer) := z_DrawTexivOES(coords);
    
    public z_DrawTexfvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glDrawTexfvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexfvOES(coords: array of single) := DrawTexfvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexfvOES(var coords: single) := DrawTexfvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexfvOES(coords: pointer) := z_DrawTexfvOES(coords);
    
    public z_DrawTexxvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glDrawTexxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexxvOES(coords: array of fixed) := DrawTexxvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexxvOES(var coords: fixed) := DrawTexxvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexxvOES(coords: pointer) := z_DrawTexxvOES(coords);
    
    public z_TexParameterxv := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTexParameterxv');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxv(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := TexParameterxv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxv(target: DummyEnum; pname: DummyEnum; var &params: fixed) := TexParameterxv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexParameterxv(target, pname, &params);
    
    {$endregion OES_draw_texture}
    
    {$region ARB_sample_locations}
    
    public z_FramebufferSampleLocationsfvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; start: UInt32; count: Int32; v: pointer)>('glFramebufferSampleLocationsfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: DummyEnum; start: UInt32; count: Int32; v: array of single) := FramebufferSampleLocationsfvARB(target, start, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: DummyEnum; start: UInt32; count: Int32; var v: single) := FramebufferSampleLocationsfvARB(target, start, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: DummyEnum; start: UInt32; count: Int32; v: pointer) := z_FramebufferSampleLocationsfvARB(target, start, count, v);
    
    public z_NamedFramebufferSampleLocationsfvARB := GetGLFuncOrNil&<procedure(framebuffer: UInt32; start: UInt32; count: Int32; v: pointer)>('glNamedFramebufferSampleLocationsfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: UInt32; start: UInt32; count: Int32; v: array of single) := NamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: UInt32; start: UInt32; count: Int32; var v: single) := NamedFramebufferSampleLocationsfvARB(framebuffer, start, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: UInt32; start: UInt32; count: Int32; v: pointer) := z_NamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v);
    
    public z_EvaluateDepthValuesARB := GetGLFuncOrNil&<procedure>('glEvaluateDepthValuesARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvaluateDepthValuesARB := z_EvaluateDepthValuesARB;
    
    {$endregion ARB_sample_locations}
    
    {$region ARB_geometry_shader4}
    
    public z_ProgramParameteriARB := GetGLFuncOrNil&<procedure(&program: UInt32; pname: DummyEnum; value: Int32)>('glProgramParameteriARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteriARB(&program: UInt32; pname: DummyEnum; value: Int32) := z_ProgramParameteriARB(&program, pname, value);
    
    public z_FramebufferTextureARB := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32)>('glFramebufferTextureARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureARB(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32) := z_FramebufferTextureARB(target, attachment, texture, level);
    
    public z_FramebufferTextureLayerARB := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32)>('glFramebufferTextureLayerARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayerARB(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32) := z_FramebufferTextureLayerARB(target, attachment, texture, level, layer);
    
    public z_FramebufferTextureFaceARB := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum)>('glFramebufferTextureFaceARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureFaceARB(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum) := z_FramebufferTextureFaceARB(target, attachment, texture, level, face);
    
    {$endregion ARB_geometry_shader4}
    
    {$region ARB_robustness}
    
    public z_GetGraphicsResetStatusARB := GetGLFuncOrNil&<function: DummyEnum>('glGetGraphicsResetStatusARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGraphicsResetStatusARB: DummyEnum := z_GetGraphicsResetStatusARB;
    
    public z_GetnMapdvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer)>('glGetnMapdvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdvARB(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: array of double) := GetnMapdvARB(target, query, bufSize, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdvARB(target: DummyEnum; query: DummyEnum; bufSize: Int32; var v: double) := GetnMapdvARB(target, query, bufSize, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdvARB(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer) := z_GetnMapdvARB(target, query, bufSize, v);
    
    public z_GetnMapfvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer)>('glGetnMapfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfvARB(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: array of single) := GetnMapfvARB(target, query, bufSize, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfvARB(target: DummyEnum; query: DummyEnum; bufSize: Int32; var v: single) := GetnMapfvARB(target, query, bufSize, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfvARB(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer) := z_GetnMapfvARB(target, query, bufSize, v);
    
    public z_GetnMapivARB := GetGLFuncOrNil&<procedure(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer)>('glGetnMapivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapivARB(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: array of Int32) := GetnMapivARB(target, query, bufSize, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapivARB(target: DummyEnum; query: DummyEnum; bufSize: Int32; var v: Int32) := GetnMapivARB(target, query, bufSize, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapivARB(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer) := z_GetnMapivARB(target, query, bufSize, v);
    
    public z_GetnPixelMapfvARB := GetGLFuncOrNil&<procedure(map: DummyEnum; bufSize: Int32; values: pointer)>('glGetnPixelMapfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfvARB(map: DummyEnum; bufSize: Int32; values: array of single) := GetnPixelMapfvARB(map, bufSize, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfvARB(map: DummyEnum; bufSize: Int32; var values: single) := GetnPixelMapfvARB(map, bufSize, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfvARB(map: DummyEnum; bufSize: Int32; values: pointer) := z_GetnPixelMapfvARB(map, bufSize, values);
    
    public z_GetnPixelMapuivARB := GetGLFuncOrNil&<procedure(map: DummyEnum; bufSize: Int32; values: pointer)>('glGetnPixelMapuivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuivARB(map: DummyEnum; bufSize: Int32; values: array of UInt32) := GetnPixelMapuivARB(map, bufSize, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuivARB(map: DummyEnum; bufSize: Int32; var values: UInt32) := GetnPixelMapuivARB(map, bufSize, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuivARB(map: DummyEnum; bufSize: Int32; values: pointer) := z_GetnPixelMapuivARB(map, bufSize, values);
    
    public z_GetnPixelMapusvARB := GetGLFuncOrNil&<procedure(map: DummyEnum; bufSize: Int32; values: pointer)>('glGetnPixelMapusvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusvARB(map: DummyEnum; bufSize: Int32; values: array of UInt16) := GetnPixelMapusvARB(map, bufSize, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusvARB(map: DummyEnum; bufSize: Int32; var values: UInt16) := GetnPixelMapusvARB(map, bufSize, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusvARB(map: DummyEnum; bufSize: Int32; values: pointer) := z_GetnPixelMapusvARB(map, bufSize, values);
    
    public z_GetnPolygonStippleARB := GetGLFuncOrNil&<procedure(bufSize: Int32; pattern: pointer)>('glGetnPolygonStippleARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStippleARB(bufSize: Int32; pattern: array of Byte) := GetnPolygonStippleARB(bufSize, pattern[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStippleARB(bufSize: Int32; var pattern: Byte) := GetnPolygonStippleARB(bufSize, @pattern);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStippleARB(bufSize: Int32; pattern: pointer) := z_GetnPolygonStippleARB(bufSize, pattern);
    
    public z_GetnTexImageARB := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; format: DummyEnum; &type: DummyEnum; bufSize: Int32; img: pointer)>('glGetnTexImageARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnTexImageARB(target: DummyEnum; level: Int32; format: DummyEnum; &type: DummyEnum; bufSize: Int32; img: pointer) := z_GetnTexImageARB(target, level, format, &type, bufSize, img);
    
    public z_ReadnPixelsARB := GetGLFuncOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; bufSize: Int32; data: pointer)>('glReadnPixelsARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixelsARB(x: Int32; y: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; bufSize: Int32; data: pointer) := z_ReadnPixelsARB(x, y, width, height, format, &type, bufSize, data);
    
    public z_GetnColorTableARB := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; bufSize: Int32; table: pointer)>('glGetnColorTableARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnColorTableARB(target: DummyEnum; format: DummyEnum; &type: DummyEnum; bufSize: Int32; table: pointer) := z_GetnColorTableARB(target, format, &type, bufSize, table);
    
    public z_GetnConvolutionFilterARB := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; bufSize: Int32; image: pointer)>('glGetnConvolutionFilterARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnConvolutionFilterARB(target: DummyEnum; format: DummyEnum; &type: DummyEnum; bufSize: Int32; image: pointer) := z_GetnConvolutionFilterARB(target, format, &type, bufSize, image);
    
    public z_GetnSeparableFilterARB := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; rowBufSize: Int32; row: pointer; columnBufSize: Int32; column: pointer; span: pointer)>('glGetnSeparableFilterARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnSeparableFilterARB(target: DummyEnum; format: DummyEnum; &type: DummyEnum; rowBufSize: Int32; row: pointer; columnBufSize: Int32; column: pointer; span: pointer) := z_GetnSeparableFilterARB(target, format, &type, rowBufSize, row, columnBufSize, column, span);
    
    public z_GetnHistogramARB := GetGLFuncOrNil&<procedure(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; bufSize: Int32; values: pointer)>('glGetnHistogramARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnHistogramARB(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; bufSize: Int32; values: pointer) := z_GetnHistogramARB(target, reset, format, &type, bufSize, values);
    
    public z_GetnMinmaxARB := GetGLFuncOrNil&<procedure(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; bufSize: Int32; values: pointer)>('glGetnMinmaxARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMinmaxARB(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; bufSize: Int32; values: pointer) := z_GetnMinmaxARB(target, reset, format, &type, bufSize, values);
    
    public z_GetnCompressedTexImageARB := GetGLFuncOrNil&<procedure(target: DummyEnum; lod: Int32; bufSize: Int32; img: pointer)>('glGetnCompressedTexImageARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnCompressedTexImageARB(target: DummyEnum; lod: Int32; bufSize: Int32; img: pointer) := z_GetnCompressedTexImageARB(target, lod, bufSize, img);
    
    public z_GetnUniformfvARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvARB(&program: UInt32; location: Int32; bufSize: Int32; &params: array of single) := GetnUniformfvARB(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvARB(&program: UInt32; location: Int32; bufSize: Int32; var &params: single) := GetnUniformfvARB(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvARB(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformfvARB(&program, location, bufSize, &params);
    
    public z_GetnUniformivARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivARB(&program: UInt32; location: Int32; bufSize: Int32; &params: array of Int32) := GetnUniformivARB(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivARB(&program: UInt32; location: Int32; bufSize: Int32; var &params: Int32) := GetnUniformivARB(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivARB(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformivARB(&program, location, bufSize, &params);
    
    public z_GetnUniformuivARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformuivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuivARB(&program: UInt32; location: Int32; bufSize: Int32; &params: array of UInt32) := GetnUniformuivARB(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuivARB(&program: UInt32; location: Int32; bufSize: Int32; var &params: UInt32) := GetnUniformuivARB(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuivARB(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformuivARB(&program, location, bufSize, &params);
    
    public z_GetnUniformdvARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformdvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdvARB(&program: UInt32; location: Int32; bufSize: Int32; &params: array of double) := GetnUniformdvARB(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdvARB(&program: UInt32; location: Int32; bufSize: Int32; var &params: double) := GetnUniformdvARB(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformdvARB(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformdvARB(&program, location, bufSize, &params);
    
    {$endregion ARB_robustness}
    
    {$region ARB_bindless_texture}
    
    public z_GetTextureHandleARB := GetGLFuncOrNil&<function(texture: UInt32): UInt64>('glGetTextureHandleARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureHandleARB(texture: UInt32): UInt64 := z_GetTextureHandleARB(texture);
    
    public z_GetTextureSamplerHandleARB := GetGLFuncOrNil&<function(texture: UInt32; sampler: UInt32): UInt64>('glGetTextureSamplerHandleARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureSamplerHandleARB(texture: UInt32; sampler: UInt32): UInt64 := z_GetTextureSamplerHandleARB(texture, sampler);
    
    public z_MakeTextureHandleResidentARB := GetGLFuncOrNil&<procedure(handle: UInt64)>('glMakeTextureHandleResidentARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleResidentARB(handle: UInt64) := z_MakeTextureHandleResidentARB(handle);
    
    public z_MakeTextureHandleNonResidentARB := GetGLFuncOrNil&<procedure(handle: UInt64)>('glMakeTextureHandleNonResidentARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleNonResidentARB(handle: UInt64) := z_MakeTextureHandleNonResidentARB(handle);
    
    public z_GetImageHandleARB := GetGLFuncOrNil&<function(texture: UInt32; level: Int32; layered: boolean; layer: Int32; format: DummyEnum): UInt64>('glGetImageHandleARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageHandleARB(texture: UInt32; level: Int32; layered: boolean; layer: Int32; format: DummyEnum): UInt64 := z_GetImageHandleARB(texture, level, layered, layer, format);
    
    public z_MakeImageHandleResidentARB := GetGLFuncOrNil&<procedure(handle: UInt64; access: DummyEnum)>('glMakeImageHandleResidentARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleResidentARB(handle: UInt64; access: DummyEnum) := z_MakeImageHandleResidentARB(handle, access);
    
    public z_MakeImageHandleNonResidentARB := GetGLFuncOrNil&<procedure(handle: UInt64)>('glMakeImageHandleNonResidentARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleNonResidentARB(handle: UInt64) := z_MakeImageHandleNonResidentARB(handle);
    
    public z_UniformHandleui64ARB := GetGLFuncOrNil&<procedure(location: Int32; value: UInt64)>('glUniformHandleui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64ARB(location: Int32; value: UInt64) := z_UniformHandleui64ARB(location, value);
    
    public z_UniformHandleui64vARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniformHandleui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; value: array of UInt64) := UniformHandleui64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; var value: UInt64) := UniformHandleui64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; value: pointer) := z_UniformHandleui64vARB(location, count, value);
    
    public z_ProgramUniformHandleui64ARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; value: UInt64)>('glProgramUniformHandleui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64ARB(&program: UInt32; location: Int32; value: UInt64) := z_ProgramUniformHandleui64ARB(&program, location, value);
    
    public z_ProgramUniformHandleui64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; values: pointer)>('glProgramUniformHandleui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: UInt32; location: Int32; count: Int32; values: array of UInt64) := ProgramUniformHandleui64vARB(&program, location, count, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: UInt32; location: Int32; count: Int32; var values: UInt64) := ProgramUniformHandleui64vARB(&program, location, count, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: UInt32; location: Int32; count: Int32; values: pointer) := z_ProgramUniformHandleui64vARB(&program, location, count, values);
    
    public z_IsTextureHandleResidentARB := GetGLFuncOrNil&<function(handle: UInt64): boolean>('glIsTextureHandleResidentARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTextureHandleResidentARB(handle: UInt64): boolean := z_IsTextureHandleResidentARB(handle);
    
    public z_IsImageHandleResidentARB := GetGLFuncOrNil&<function(handle: UInt64): boolean>('glIsImageHandleResidentARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsImageHandleResidentARB(handle: UInt64): boolean := z_IsImageHandleResidentARB(handle);
    
    public z_VertexAttribL1ui64ARB := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt64)>('glVertexAttribL1ui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64ARB(index: UInt32; x: UInt64) := z_VertexAttribL1ui64ARB(index, x);
    
    public z_VertexAttribL1ui64vARB := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL1ui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; v: array of UInt64) := VertexAttribL1ui64vARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; var v: UInt64) := VertexAttribL1ui64vARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; v: pointer) := z_VertexAttribL1ui64vARB(index, v);
    
    public z_GetVertexAttribLui64vARB := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribLui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vARB(index: UInt32; pname: DummyEnum; &params: array of UInt64) := GetVertexAttribLui64vARB(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vARB(index: UInt32; pname: DummyEnum; var &params: UInt64) := GetVertexAttribLui64vARB(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vARB(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribLui64vARB(index, pname, &params);
    
    {$endregion ARB_bindless_texture}
    
    {$region ARB_gpu_shader_int64}
    
    public z_Uniform1i64ARB := GetGLFuncOrNil&<procedure(location: Int32; x: Int64)>('glUniform1i64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64ARB(location: Int32; x: Int64) := z_Uniform1i64ARB(location, x);
    
    public z_Uniform2i64ARB := GetGLFuncOrNil&<procedure(location: Int32; x: Int64; y: Int64)>('glUniform2i64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64ARB(location: Int32; x: Int64; y: Int64) := z_Uniform2i64ARB(location, x, y);
    
    public z_Uniform3i64ARB := GetGLFuncOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64)>('glUniform3i64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64ARB(location: Int32; x: Int64; y: Int64; z: Int64) := z_Uniform3i64ARB(location, x, y, z);
    
    public z_Uniform4i64ARB := GetGLFuncOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>('glUniform4i64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64ARB(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) := z_Uniform4i64ARB(location, x, y, z, w);
    
    public z_Uniform1i64vARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1i64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; value: array of Int64) := Uniform1i64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; var value: Int64) := Uniform1i64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform1i64vARB(location, count, value);
    
    public z_Uniform2i64vARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2i64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; value: array of Int64) := Uniform2i64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; var value: Int64) := Uniform2i64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform2i64vARB(location, count, value);
    
    public z_Uniform3i64vARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3i64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; value: array of Int64) := Uniform3i64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; var value: Int64) := Uniform3i64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform3i64vARB(location, count, value);
    
    public z_Uniform4i64vARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4i64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; value: array of Int64) := Uniform4i64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; var value: Int64) := Uniform4i64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform4i64vARB(location, count, value);
    
    public z_Uniform1ui64ARB := GetGLFuncOrNil&<procedure(location: Int32; x: UInt64)>('glUniform1ui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64ARB(location: Int32; x: UInt64) := z_Uniform1ui64ARB(location, x);
    
    public z_Uniform2ui64ARB := GetGLFuncOrNil&<procedure(location: Int32; x: UInt64; y: UInt64)>('glUniform2ui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64ARB(location: Int32; x: UInt64; y: UInt64) := z_Uniform2ui64ARB(location, x, y);
    
    public z_Uniform3ui64ARB := GetGLFuncOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64)>('glUniform3ui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64ARB(location: Int32; x: UInt64; y: UInt64; z: UInt64) := z_Uniform3ui64ARB(location, x, y, z);
    
    public z_Uniform4ui64ARB := GetGLFuncOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>('glUniform4ui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64ARB(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := z_Uniform4ui64ARB(location, x, y, z, w);
    
    public z_Uniform1ui64vARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1ui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; value: array of UInt64) := Uniform1ui64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; var value: UInt64) := Uniform1ui64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform1ui64vARB(location, count, value);
    
    public z_Uniform2ui64vARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2ui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; value: array of UInt64) := Uniform2ui64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; var value: UInt64) := Uniform2ui64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform2ui64vARB(location, count, value);
    
    public z_Uniform3ui64vARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3ui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; value: array of UInt64) := Uniform3ui64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; var value: UInt64) := Uniform3ui64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform3ui64vARB(location, count, value);
    
    public z_Uniform4ui64vARB := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4ui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; value: array of UInt64) := Uniform4ui64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; var value: UInt64) := Uniform4ui64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform4ui64vARB(location, count, value);
    
    public z_GetUniformi64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; &params: pointer)>('glGetUniformi64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vARB(&program: UInt32; location: Int32; &params: array of Int64) := GetUniformi64vARB(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vARB(&program: UInt32; location: Int32; var &params: Int64) := GetUniformi64vARB(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vARB(&program: UInt32; location: Int32; &params: pointer) := z_GetUniformi64vARB(&program, location, &params);
    
    public z_GetUniformui64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; &params: pointer)>('glGetUniformui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vARB(&program: UInt32; location: Int32; &params: array of UInt64) := GetUniformui64vARB(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vARB(&program: UInt32; location: Int32; var &params: UInt64) := GetUniformui64vARB(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vARB(&program: UInt32; location: Int32; &params: pointer) := z_GetUniformui64vARB(&program, location, &params);
    
    public z_GetnUniformi64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformi64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformi64vARB(&program: UInt32; location: Int32; bufSize: Int32; &params: array of Int64) := GetnUniformi64vARB(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformi64vARB(&program: UInt32; location: Int32; bufSize: Int32; var &params: Int64) := GetnUniformi64vARB(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformi64vARB(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformi64vARB(&program, location, bufSize, &params);
    
    public z_GetnUniformui64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformui64vARB(&program: UInt32; location: Int32; bufSize: Int32; &params: array of UInt64) := GetnUniformui64vARB(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformui64vARB(&program: UInt32; location: Int32; bufSize: Int32; var &params: UInt64) := GetnUniformui64vARB(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformui64vARB(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformui64vARB(&program, location, bufSize, &params);
    
    public z_ProgramUniform1i64ARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: Int64)>('glProgramUniform1i64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64ARB(&program: UInt32; location: Int32; x: Int64) := z_ProgramUniform1i64ARB(&program, location, x);
    
    public z_ProgramUniform2i64ARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: Int64; y: Int64)>('glProgramUniform2i64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64ARB(&program: UInt32; location: Int32; x: Int64; y: Int64) := z_ProgramUniform2i64ARB(&program, location, x, y);
    
    public z_ProgramUniform3i64ARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64)>('glProgramUniform3i64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64ARB(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64) := z_ProgramUniform3i64ARB(&program, location, x, y, z);
    
    public z_ProgramUniform4i64ARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>('glProgramUniform4i64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64ARB(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) := z_ProgramUniform4i64ARB(&program, location, x, y, z, w);
    
    public z_ProgramUniform1i64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform1i64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform1i64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform1i64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1i64vARB(&program, location, count, value);
    
    public z_ProgramUniform2i64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform2i64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform2i64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform2i64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2i64vARB(&program, location, count, value);
    
    public z_ProgramUniform3i64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform3i64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform3i64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform3i64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3i64vARB(&program, location, count, value);
    
    public z_ProgramUniform4i64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform4i64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform4i64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform4i64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4i64vARB(&program, location, count, value);
    
    public z_ProgramUniform1ui64ARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64)>('glProgramUniform1ui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64ARB(&program: UInt32; location: Int32; x: UInt64) := z_ProgramUniform1ui64ARB(&program, location, x);
    
    public z_ProgramUniform2ui64ARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64)>('glProgramUniform2ui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64ARB(&program: UInt32; location: Int32; x: UInt64; y: UInt64) := z_ProgramUniform2ui64ARB(&program, location, x, y);
    
    public z_ProgramUniform3ui64ARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64)>('glProgramUniform3ui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64ARB(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64) := z_ProgramUniform3ui64ARB(&program, location, x, y, z);
    
    public z_ProgramUniform4ui64ARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>('glProgramUniform4ui64ARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64ARB(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := z_ProgramUniform4ui64ARB(&program, location, x, y, z, w);
    
    public z_ProgramUniform1ui64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform1ui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform1ui64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform1ui64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1ui64vARB(&program, location, count, value);
    
    public z_ProgramUniform2ui64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform2ui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform2ui64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform2ui64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2ui64vARB(&program, location, count, value);
    
    public z_ProgramUniform3ui64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform3ui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform3ui64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform3ui64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3ui64vARB(&program, location, count, value);
    
    public z_ProgramUniform4ui64vARB := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform4ui64vARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform4ui64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform4ui64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4ui64vARB(&program, location, count, value);
    
    {$endregion ARB_gpu_shader_int64}
    
    {$region ARB_fragment_program ARB_vertex_program NV_fragment_program}
    
    public z_ProgramLocalParameter4dARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double)>('glProgramLocalParameter4dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dARB(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := z_ProgramLocalParameter4dARB(target, index, x, y, z, w);
    
    public z_ProgramLocalParameter4dvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glProgramLocalParameter4dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: DummyEnum; index: UInt32; &params: array of double) := ProgramLocalParameter4dvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: DummyEnum; index: UInt32; var &params: double) := ProgramLocalParameter4dvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramLocalParameter4dvARB(target, index, &params);
    
    public z_ProgramLocalParameter4fARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single)>('glProgramLocalParameter4fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fARB(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := z_ProgramLocalParameter4fARB(target, index, x, y, z, w);
    
    public z_ProgramLocalParameter4fvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glProgramLocalParameter4fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: DummyEnum; index: UInt32; &params: array of single) := ProgramLocalParameter4fvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: DummyEnum; index: UInt32; var &params: single) := ProgramLocalParameter4fvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramLocalParameter4fvARB(target, index, &params);
    
    public z_GetProgramLocalParameterdvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glGetProgramLocalParameterdvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: DummyEnum; index: UInt32; &params: array of double) := GetProgramLocalParameterdvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: DummyEnum; index: UInt32; var &params: double) := GetProgramLocalParameterdvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramLocalParameterdvARB(target, index, &params);
    
    public z_GetProgramLocalParameterfvARB := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glGetProgramLocalParameterfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: DummyEnum; index: UInt32; &params: array of single) := GetProgramLocalParameterfvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: DummyEnum; index: UInt32; var &params: single) := GetProgramLocalParameterfvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramLocalParameterfvARB(target, index, &params);
    
    {$endregion ARB_fragment_program ARB_vertex_program NV_fragment_program}
    
    {$region ARB_transpose_matrix}
    
    public z_LoadTransposeMatrixfARB := GetGLFuncOrNil&<procedure(m: pointer)>('glLoadTransposeMatrixfARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixfARB(m: array of single) := LoadTransposeMatrixfARB(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixfARB(var m: single) := LoadTransposeMatrixfARB(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixfARB(m: pointer) := z_LoadTransposeMatrixfARB(m);
    
    public z_LoadTransposeMatrixdARB := GetGLFuncOrNil&<procedure(m: pointer)>('glLoadTransposeMatrixdARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixdARB(m: array of double) := LoadTransposeMatrixdARB(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixdARB(var m: double) := LoadTransposeMatrixdARB(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixdARB(m: pointer) := z_LoadTransposeMatrixdARB(m);
    
    public z_MultTransposeMatrixfARB := GetGLFuncOrNil&<procedure(m: pointer)>('glMultTransposeMatrixfARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixfARB(m: array of single) := MultTransposeMatrixfARB(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixfARB(var m: single) := MultTransposeMatrixfARB(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixfARB(m: pointer) := z_MultTransposeMatrixfARB(m);
    
    public z_MultTransposeMatrixdARB := GetGLFuncOrNil&<procedure(m: pointer)>('glMultTransposeMatrixdARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixdARB(m: array of double) := MultTransposeMatrixdARB(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixdARB(var m: double) := MultTransposeMatrixdARB(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixdARB(m: pointer) := z_MultTransposeMatrixdARB(m);
    
    {$endregion ARB_transpose_matrix}
    
    {$region ARB_parallel_shader_compile}
    
    public z_MaxShaderCompilerThreadsARB := GetGLFuncOrNil&<procedure(count: UInt32)>('glMaxShaderCompilerThreadsARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaxShaderCompilerThreadsARB(count: UInt32) := z_MaxShaderCompilerThreadsARB(count);
    
    {$endregion ARB_parallel_shader_compile}
    
    {$region ARB_sample_shading}
    
    public z_MinSampleShadingARB := GetGLFuncOrNil&<procedure(value: single)>('glMinSampleShadingARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MinSampleShadingARB(value: single) := z_MinSampleShadingARB(value);
    
    {$endregion ARB_sample_shading}
    
    {$region ARB_indirect_parameters}
    
    public z_MultiDrawArraysIndirectCountARB := GetGLFuncOrNil&<procedure(mode: DummyEnum; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>('glMultiDrawArraysIndirectCountARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectCountARB(mode: DummyEnum; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) := z_MultiDrawArraysIndirectCountARB(mode, indirect, drawcount, maxdrawcount, stride);
    
    public z_MultiDrawElementsIndirectCountARB := GetGLFuncOrNil&<procedure(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>('glMultiDrawElementsIndirectCountARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectCountARB(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) := z_MultiDrawElementsIndirectCountARB(mode, &type, indirect, drawcount, maxdrawcount, stride);
    
    {$endregion ARB_indirect_parameters}
    
    {$region ARB_point_parameters}
    
    public z_PointParameterfARB := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: single)>('glPointParameterfARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfARB(pname: DummyEnum; param: single) := z_PointParameterfARB(pname, param);
    
    public z_PointParameterfvARB := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glPointParameterfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvARB(pname: DummyEnum; &params: array of single) := PointParameterfvARB(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvARB(pname: DummyEnum; var &params: single) := PointParameterfvARB(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvARB(pname: DummyEnum; &params: pointer) := z_PointParameterfvARB(pname, &params);
    
    {$endregion ARB_point_parameters}
    
    {$region ARB_ES3_2_compatibility}
    
    public z_PrimitiveBoundingBoxARB := GetGLFuncOrNil&<procedure(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single)>('glPrimitiveBoundingBoxARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveBoundingBoxARB(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single) := z_PrimitiveBoundingBoxARB(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    
    {$endregion ARB_ES3_2_compatibility}
    
    {$region ARB_multisample}
    
    public z_SampleCoverageARB := GetGLFuncOrNil&<procedure(value: single; invert: boolean)>('glSampleCoverageARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleCoverageARB(value: single; invert: boolean) := z_SampleCoverageARB(value, invert);
    
    {$endregion ARB_multisample}
    
    {$region ARB_gl_spirv}
    
    public z_SpecializeShaderARB := GetGLFuncOrNil&<procedure(shader: UInt32; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: pointer)>('glSpecializeShaderARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of UInt32); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShaderARB(shader, ptr_2, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; var pConstantValue: UInt32); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShaderARB(shader, ptr_2, numSpecializationConstants, pConstantIndex[0], @pConstantValue); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: pointer); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShaderARB(shader, ptr_2, numSpecializationConstants, pConstantIndex[0], pConstantValue); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: array of UInt32); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShaderARB(shader, ptr_2, numSpecializationConstants, @pConstantIndex, pConstantValue[0]); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShaderARB(shader, ptr_2, numSpecializationConstants, @pConstantIndex, @pConstantValue); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: pointer); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShaderARB(shader, ptr_2, numSpecializationConstants, @pConstantIndex, pConstantValue); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: array of UInt32); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShaderARB(shader, ptr_2, numSpecializationConstants, pConstantIndex, pConstantValue[0]); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: pointer; var pConstantValue: UInt32); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShaderARB(shader, ptr_2, numSpecializationConstants, pConstantIndex, @pConstantValue); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: pointer); begin var ptr_2 := Marshal.StringToHGlobalAnsi(pEntryPoint); SpecializeShaderARB(shader, ptr_2, numSpecializationConstants, pConstantIndex, pConstantValue); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: array of UInt32) := SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; var pConstantValue: UInt32) := SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], @pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: array of UInt32; pConstantValue: pointer) := SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex[0], pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: array of UInt32) := SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, @pConstantIndex, pConstantValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: UInt32) := SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, @pConstantIndex, @pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; pConstantValue: pointer) := SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, @pConstantIndex, pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: array of UInt32) := SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: pointer; var pConstantValue: UInt32) := SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, @pConstantValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpecializeShaderARB(shader: UInt32; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: pointer) := z_SpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
    
    {$endregion ARB_gl_spirv}
    
    {$region ARB_texture_buffer_object}
    
    public z_TexBufferARB := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; buffer: UInt32)>('glTexBufferARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferARB(target: DummyEnum; internalformat: DummyEnum; buffer: UInt32) := z_TexBufferARB(target, internalformat, buffer);
    
    {$endregion ARB_texture_buffer_object}
    
    {$region ARB_sparse_texture}
    
    public z_TexPageCommitmentARB := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean)>('glTexPageCommitmentARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexPageCommitmentARB(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean) := z_TexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    
    {$endregion ARB_sparse_texture}
    
    {$region ARB_vertex_blend}
    
    public z_WeightbvARB := GetGLFuncOrNil&<procedure(size: Int32; weights: pointer)>('glWeightbvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; weights: array of SByte) := WeightbvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; var weights: SByte) := WeightbvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; weights: pointer) := z_WeightbvARB(size, weights);
    
    public z_WeightsvARB := GetGLFuncOrNil&<procedure(size: Int32; weights: pointer)>('glWeightsvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; weights: array of Int16) := WeightsvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; var weights: Int16) := WeightsvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; weights: pointer) := z_WeightsvARB(size, weights);
    
    public z_WeightivARB := GetGLFuncOrNil&<procedure(size: Int32; weights: pointer)>('glWeightivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; weights: array of Int32) := WeightivARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; var weights: Int32) := WeightivARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; weights: pointer) := z_WeightivARB(size, weights);
    
    public z_WeightfvARB := GetGLFuncOrNil&<procedure(size: Int32; weights: pointer)>('glWeightfvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; weights: array of single) := WeightfvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; var weights: single) := WeightfvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; weights: pointer) := z_WeightfvARB(size, weights);
    
    public z_WeightdvARB := GetGLFuncOrNil&<procedure(size: Int32; weights: pointer)>('glWeightdvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; weights: array of double) := WeightdvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; var weights: double) := WeightdvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; weights: pointer) := z_WeightdvARB(size, weights);
    
    public z_WeightubvARB := GetGLFuncOrNil&<procedure(size: Int32; weights: pointer)>('glWeightubvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; weights: array of Byte) := WeightubvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; var weights: Byte) := WeightubvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; weights: pointer) := z_WeightubvARB(size, weights);
    
    public z_WeightusvARB := GetGLFuncOrNil&<procedure(size: Int32; weights: pointer)>('glWeightusvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; weights: array of UInt16) := WeightusvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; var weights: UInt16) := WeightusvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; weights: pointer) := z_WeightusvARB(size, weights);
    
    public z_WeightuivARB := GetGLFuncOrNil&<procedure(size: Int32; weights: pointer)>('glWeightuivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; weights: array of UInt32) := WeightuivARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; var weights: UInt32) := WeightuivARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; weights: pointer) := z_WeightuivARB(size, weights);
    
    public z_WeightPointerARB := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glWeightPointerARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPointerARB(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_WeightPointerARB(size, &type, stride, _pointer);
    
    public z_VertexBlendARB := GetGLFuncOrNil&<procedure(count: Int32)>('glVertexBlendARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendARB(count: Int32) := z_VertexBlendARB(count);
    
    {$endregion ARB_vertex_blend}
    
    {$region ARB_window_pos}
    
    public z_WindowPos2dARB := GetGLFuncOrNil&<procedure(x: double; y: double)>('glWindowPos2dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dARB(x: double; y: double) := z_WindowPos2dARB(x, y);
    
    public z_WindowPos2fARB := GetGLFuncOrNil&<procedure(x: single; y: single)>('glWindowPos2fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fARB(x: single; y: single) := z_WindowPos2fARB(x, y);
    
    public z_WindowPos2iARB := GetGLFuncOrNil&<procedure(x: Int32; y: Int32)>('glWindowPos2iARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iARB(x: Int32; y: Int32) := z_WindowPos2iARB(x, y);
    
    public z_WindowPos2sARB := GetGLFuncOrNil&<procedure(x: Int16; y: Int16)>('glWindowPos2sARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sARB(x: Int16; y: Int16) := z_WindowPos2sARB(x, y);
    
    public z_WindowPos2dvARB := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvARB(v: array of double) := WindowPos2dvARB(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvARB(var v: double) := WindowPos2dvARB(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvARB(v: pointer) := z_WindowPos2dvARB(v);
    
    public z_WindowPos2fvARB := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvARB(v: array of single) := WindowPos2fvARB(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvARB(var v: single) := WindowPos2fvARB(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvARB(v: pointer) := z_WindowPos2fvARB(v);
    
    public z_WindowPos2ivARB := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivARB(v: array of Int32) := WindowPos2ivARB(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivARB(var v: Int32) := WindowPos2ivARB(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivARB(v: pointer) := z_WindowPos2ivARB(v);
    
    public z_WindowPos2svARB := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2svARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svARB(v: array of Int16) := WindowPos2svARB(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svARB(var v: Int16) := WindowPos2svARB(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svARB(v: pointer) := z_WindowPos2svARB(v);
    
    public z_WindowPos3dARB := GetGLFuncOrNil&<procedure(x: double; y: double; z: double)>('glWindowPos3dARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dARB(x: double; y: double; z: double) := z_WindowPos3dARB(x, y, z);
    
    public z_WindowPos3fARB := GetGLFuncOrNil&<procedure(x: single; y: single; z: single)>('glWindowPos3fARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fARB(x: single; y: single; z: single) := z_WindowPos3fARB(x, y, z);
    
    public z_WindowPos3iARB := GetGLFuncOrNil&<procedure(x: Int32; y: Int32; z: Int32)>('glWindowPos3iARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iARB(x: Int32; y: Int32; z: Int32) := z_WindowPos3iARB(x, y, z);
    
    public z_WindowPos3sARB := GetGLFuncOrNil&<procedure(x: Int16; y: Int16; z: Int16)>('glWindowPos3sARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sARB(x: Int16; y: Int16; z: Int16) := z_WindowPos3sARB(x, y, z);
    
    public z_WindowPos3dvARB := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3dvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvARB(v: array of double) := WindowPos3dvARB(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvARB(var v: double) := WindowPos3dvARB(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvARB(v: pointer) := z_WindowPos3dvARB(v);
    
    public z_WindowPos3fvARB := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3fvARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvARB(v: array of single) := WindowPos3fvARB(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvARB(var v: single) := WindowPos3fvARB(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvARB(v: pointer) := z_WindowPos3fvARB(v);
    
    public z_WindowPos3ivARB := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3ivARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivARB(v: array of Int32) := WindowPos3ivARB(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivARB(var v: Int32) := WindowPos3ivARB(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivARB(v: pointer) := z_WindowPos3ivARB(v);
    
    public z_WindowPos3svARB := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3svARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svARB(v: array of Int16) := WindowPos3svARB(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svARB(var v: Int16) := WindowPos3svARB(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svARB(v: pointer) := z_WindowPos3svARB(v);
    
    {$endregion ARB_window_pos}
    
  end;
  
  gl_EXT = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region EXT_win32_keyed_mutex}
    
    public z_AcquireKeyedMutexWin32EXT := GetGLFuncOrNil&<function(memory: UInt32; key: UInt64; timeout: UInt32): boolean>('glAcquireKeyedMutexWin32EXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AcquireKeyedMutexWin32EXT(memory: UInt32; key: UInt64; timeout: UInt32): boolean := z_AcquireKeyedMutexWin32EXT(memory, key, timeout);
    
    public z_ReleaseKeyedMutexWin32EXT := GetGLFuncOrNil&<function(memory: UInt32; key: UInt64): boolean>('glReleaseKeyedMutexWin32EXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseKeyedMutexWin32EXT(memory: UInt32; key: UInt64): boolean := z_ReleaseKeyedMutexWin32EXT(memory, key);
    
    {$endregion EXT_win32_keyed_mutex}
    
    {$region EXT_separate_shader_objects}
    
    public z_UseShaderProgramEXT := GetGLFuncOrNil&<procedure(&type: DummyEnum; &program: UInt32)>('glUseShaderProgramEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseShaderProgramEXT(&type: DummyEnum; &program: UInt32) := z_UseShaderProgramEXT(&type, &program);
    
    public z_ActiveProgramEXT := GetGLFuncOrNil&<procedure(&program: UInt32)>('glActiveProgramEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveProgramEXT(&program: UInt32) := z_ActiveProgramEXT(&program);
    
    public z_CreateShaderProgramEXT := GetGLFuncOrNil&<function(&type: DummyEnum; string: IntPtr): UInt32>('glCreateShaderProgramEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramEXT(&type: DummyEnum; _string: string): UInt32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(_string); Result := CreateShaderProgramEXT(&type, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramEXT(&type: DummyEnum; string: IntPtr): UInt32 := z_CreateShaderProgramEXT(&type, string);
    
    public z_UseProgramStagesEXT := GetGLFuncOrNil&<procedure(pipeline: UInt32; stages: DummyFlags; &program: UInt32)>('glUseProgramStagesEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgramStagesEXT(pipeline: UInt32; stages: DummyFlags; &program: UInt32) := z_UseProgramStagesEXT(pipeline, stages, &program);
    
    public z_ActiveShaderProgramEXT := GetGLFuncOrNil&<procedure(pipeline: UInt32; &program: UInt32)>('glActiveShaderProgramEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveShaderProgramEXT(pipeline: UInt32; &program: UInt32) := z_ActiveShaderProgramEXT(pipeline, &program);
    
    public z_CreateShaderProgramvEXT := GetGLFuncOrNil&<function(&type: DummyEnum; count: Int32; strings: pointer): UInt32>('glCreateShaderProgramvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramvEXT(&type: DummyEnum; count: Int32; strings: array of IntPtr): UInt32 := CreateShaderProgramvEXT(&type, count, strings[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramvEXT(&type: DummyEnum; count: Int32; var strings: IntPtr): UInt32 := CreateShaderProgramvEXT(&type, count, @strings);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramvEXT(&type: DummyEnum; count: Int32; strings: pointer): UInt32 := z_CreateShaderProgramvEXT(&type, count, strings);
    
    public z_BindProgramPipelineEXT := GetGLFuncOrNil&<procedure(pipeline: UInt32)>('glBindProgramPipelineEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramPipelineEXT(pipeline: UInt32) := z_BindProgramPipelineEXT(pipeline);
    
    public z_DeleteProgramPipelinesEXT := GetGLFuncOrNil&<procedure(n: Int32; pipelines: pointer)>('glDeleteProgramPipelinesEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelinesEXT(n: Int32; pipelines: array of UInt32) := DeleteProgramPipelinesEXT(n, pipelines[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelinesEXT(n: Int32; var pipelines: UInt32) := DeleteProgramPipelinesEXT(n, @pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramPipelinesEXT(n: Int32; pipelines: pointer) := z_DeleteProgramPipelinesEXT(n, pipelines);
    
    public z_GenProgramPipelinesEXT := GetGLFuncOrNil&<procedure(n: Int32; pipelines: pointer)>('glGenProgramPipelinesEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelinesEXT(n: Int32; pipelines: array of UInt32) := GenProgramPipelinesEXT(n, pipelines[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelinesEXT(n: Int32; var pipelines: UInt32) := GenProgramPipelinesEXT(n, @pipelines);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramPipelinesEXT(n: Int32; pipelines: pointer) := z_GenProgramPipelinesEXT(n, pipelines);
    
    public z_IsProgramPipelineEXT := GetGLFuncOrNil&<function(pipeline: UInt32): boolean>('glIsProgramPipelineEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramPipelineEXT(pipeline: UInt32): boolean := z_IsProgramPipelineEXT(pipeline);
    
    public z_GetProgramPipelineivEXT := GetGLFuncOrNil&<procedure(pipeline: UInt32; pname: DummyEnum; &params: pointer)>('glGetProgramPipelineivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineivEXT(pipeline: UInt32; pname: DummyEnum; &params: array of Int32) := GetProgramPipelineivEXT(pipeline, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineivEXT(pipeline: UInt32; pname: DummyEnum; var &params: Int32) := GetProgramPipelineivEXT(pipeline, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineivEXT(pipeline: UInt32; pname: DummyEnum; &params: pointer) := z_GetProgramPipelineivEXT(pipeline, pname, &params);
    
    public z_ValidateProgramPipelineEXT := GetGLFuncOrNil&<procedure(pipeline: UInt32)>('glValidateProgramPipelineEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ValidateProgramPipelineEXT(pipeline: UInt32) := z_ValidateProgramPipelineEXT(pipeline);
    
    public z_GetProgramPipelineInfoLogEXT := GetGLFuncOrNil&<procedure(pipeline: UInt32; bufSize: Int32; length: pointer; infoLog: IntPtr)>('glGetProgramPipelineInfoLogEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLogEXT(pipeline: UInt32; bufSize: Int32; length: array of Int32; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetProgramPipelineInfoLogEXT(pipeline, bufSize, length[0], ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLogEXT(pipeline: UInt32; bufSize: Int32; length: array of Int32; infoLog: IntPtr) := GetProgramPipelineInfoLogEXT(pipeline, bufSize, length[0], infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLogEXT(pipeline: UInt32; bufSize: Int32; var length: Int32; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetProgramPipelineInfoLogEXT(pipeline, bufSize, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLogEXT(pipeline: UInt32; bufSize: Int32; var length: Int32; infoLog: IntPtr) := GetProgramPipelineInfoLogEXT(pipeline, bufSize, @length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLogEXT(pipeline: UInt32; bufSize: Int32; length: pointer; infoLog: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(infoLog); GetProgramPipelineInfoLogEXT(pipeline, bufSize, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramPipelineInfoLogEXT(pipeline: UInt32; bufSize: Int32; length: pointer; infoLog: IntPtr) := z_GetProgramPipelineInfoLogEXT(pipeline, bufSize, length, infoLog);
    
    {$endregion EXT_separate_shader_objects}
    
    {$region EXT_stencil_two_side}
    
    public z_ActiveStencilFaceEXT := GetGLFuncOrNil&<procedure(face: DummyEnum)>('glActiveStencilFaceEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveStencilFaceEXT(face: DummyEnum) := z_ActiveStencilFaceEXT(face);
    
    {$endregion EXT_stencil_two_side}
    
    {$region EXT_light_texture}
    
    public z_ApplyTextureEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glApplyTextureEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ApplyTextureEXT(mode: DummyEnum) := z_ApplyTextureEXT(mode);
    
    public z_TextureLightEXT := GetGLFuncOrNil&<procedure(pname: DummyEnum)>('glTextureLightEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureLightEXT(pname: DummyEnum) := z_TextureLightEXT(pname);
    
    public z_TextureMaterialEXT := GetGLFuncOrNil&<procedure(face: DummyEnum; mode: DummyEnum)>('glTextureMaterialEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureMaterialEXT(face: DummyEnum; mode: DummyEnum) := z_TextureMaterialEXT(face, mode);
    
    {$endregion EXT_light_texture}
    
    {$region EXT_texture_object}
    
    public z_GenTexturesEXT := GetGLFuncOrNil&<procedure(n: Int32; textures: pointer)>('glGenTexturesEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTexturesEXT(n: Int32; textures: array of UInt32) := GenTexturesEXT(n, textures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTexturesEXT(n: Int32; var textures: UInt32) := GenTexturesEXT(n, @textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTexturesEXT(n: Int32; textures: pointer) := z_GenTexturesEXT(n, textures);
    
    public z_DeleteTexturesEXT := GetGLFuncOrNil&<procedure(n: Int32; textures: pointer)>('glDeleteTexturesEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTexturesEXT(n: Int32; textures: array of UInt32) := DeleteTexturesEXT(n, textures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTexturesEXT(n: Int32; var textures: UInt32) := DeleteTexturesEXT(n, @textures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTexturesEXT(n: Int32; textures: pointer) := z_DeleteTexturesEXT(n, textures);
    
    public z_BindTextureEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; texture: UInt32)>('glBindTextureEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTextureEXT(target: DummyEnum; texture: UInt32) := z_BindTextureEXT(target, texture);
    
    public z_PrioritizeTexturesEXT := GetGLFuncOrNil&<procedure(n: Int32; textures: pointer; priorities: pointer)>('glPrioritizeTexturesEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: array of UInt32; priorities: array of single) := PrioritizeTexturesEXT(n, textures[0], priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: array of UInt32; var priorities: single) := PrioritizeTexturesEXT(n, textures[0], @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: array of UInt32; priorities: pointer) := PrioritizeTexturesEXT(n, textures[0], priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; var textures: UInt32; priorities: array of single) := PrioritizeTexturesEXT(n, @textures, priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; var textures: UInt32; var priorities: single) := PrioritizeTexturesEXT(n, @textures, @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; var textures: UInt32; priorities: pointer) := PrioritizeTexturesEXT(n, @textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: pointer; priorities: array of single) := PrioritizeTexturesEXT(n, textures, priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: pointer; var priorities: single) := PrioritizeTexturesEXT(n, textures, @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: pointer; priorities: pointer) := z_PrioritizeTexturesEXT(n, textures, priorities);
    
    public z_AreTexturesResidentEXT := GetGLFuncOrNil&<function(n: Int32; textures: pointer; residences: pointer): boolean>('glAreTexturesResidentEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: array of UInt32; residences: array of boolean): boolean := AreTexturesResidentEXT(n, textures[0], residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: array of UInt32; var residences: boolean): boolean := AreTexturesResidentEXT(n, textures[0], @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: array of UInt32; residences: pointer): boolean := AreTexturesResidentEXT(n, textures[0], residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; var textures: UInt32; residences: array of boolean): boolean := AreTexturesResidentEXT(n, @textures, residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; var textures: UInt32; var residences: boolean): boolean := AreTexturesResidentEXT(n, @textures, @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; var textures: UInt32; residences: pointer): boolean := AreTexturesResidentEXT(n, @textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: pointer; residences: array of boolean): boolean := AreTexturesResidentEXT(n, textures, residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: pointer; var residences: boolean): boolean := AreTexturesResidentEXT(n, textures, @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: pointer; residences: pointer): boolean := z_AreTexturesResidentEXT(n, textures, residences);
    
    public z_IsTextureEXT := GetGLFuncOrNil&<function(texture: UInt32): boolean>('glIsTextureEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTextureEXT(texture: UInt32): boolean := z_IsTextureEXT(texture);
    
    {$endregion EXT_texture_object}
    
    {$region EXT_vertex_array}
    
    public z_ArrayElementEXT := GetGLFuncOrNil&<procedure(i: Int32)>('glArrayElementEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayElementEXT(i: Int32) := z_ArrayElementEXT(i);
    
    public z_DrawArraysEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; first: Int32; count: Int32)>('glDrawArraysEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysEXT(mode: DummyEnum; first: Int32; count: Int32) := z_DrawArraysEXT(mode, first, count);
    
    public z_VertexPointerEXT := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer)>('glVertexPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerEXT(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := z_VertexPointerEXT(size, &type, stride, count, _pointer);
    
    public z_NormalPointerEXT := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer)>('glNormalPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerEXT(&type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := z_NormalPointerEXT(&type, stride, count, _pointer);
    
    public z_ColorPointerEXT := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer)>('glColorPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerEXT(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := z_ColorPointerEXT(size, &type, stride, count, _pointer);
    
    public z_IndexPointerEXT := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer)>('glIndexPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerEXT(&type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := z_IndexPointerEXT(&type, stride, count, _pointer);
    
    public z_TexCoordPointerEXT := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer)>('glTexCoordPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerEXT(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := z_TexCoordPointerEXT(size, &type, stride, count, _pointer);
    
    public z_EdgeFlagPointerEXT := GetGLFuncOrNil&<procedure(stride: Int32; count: Int32; _pointer: pointer)>('glEdgeFlagPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; _pointer: array of boolean) := EdgeFlagPointerEXT(stride, count, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; var _pointer: boolean) := EdgeFlagPointerEXT(stride, count, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; _pointer: pointer) := z_EdgeFlagPointerEXT(stride, count, _pointer);
    
    public z_GetPointervEXT := GetGLFuncOrNil&<procedure(pname: GLGetQueries; &params: pointer)>('glGetPointervEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointervEXT(pname: GLGetQueries; &params: array of IntPtr) := GetPointervEXT(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointervEXT(pname: GLGetQueries; var &params: IntPtr) := GetPointervEXT(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointervEXT(pname: GLGetQueries; &params: pointer) := z_GetPointervEXT(pname, &params);
    
    {$endregion EXT_vertex_array}
    
    {$region EXT_disjoint_timer_query EXT_occlusion_query_boolean}
    
    public z_GenQueriesEXT := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glGenQueriesEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesEXT(n: Int32; ids: array of UInt32) := GenQueriesEXT(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesEXT(n: Int32; var ids: UInt32) := GenQueriesEXT(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueriesEXT(n: Int32; ids: pointer) := z_GenQueriesEXT(n, ids);
    
    public z_DeleteQueriesEXT := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glDeleteQueriesEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesEXT(n: Int32; ids: array of UInt32) := DeleteQueriesEXT(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesEXT(n: Int32; var ids: UInt32) := DeleteQueriesEXT(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueriesEXT(n: Int32; ids: pointer) := z_DeleteQueriesEXT(n, ids);
    
    public z_IsQueryEXT := GetGLFuncOrNil&<function(id: UInt32): boolean>('glIsQueryEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsQueryEXT(id: UInt32): boolean := z_IsQueryEXT(id);
    
    public z_BeginQueryEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; id: UInt32)>('glBeginQueryEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginQueryEXT(target: DummyEnum; id: UInt32) := z_BeginQueryEXT(target, id);
    
    public z_EndQueryEXT := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glEndQueryEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndQueryEXT(target: DummyEnum) := z_EndQueryEXT(target);
    
    public z_GetQueryivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetQueryivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetQueryivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetQueryivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetQueryivEXT(target, pname, &params);
    
    public z_GetQueryObjectuivEXT := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetQueryObjectuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuivEXT(id: UInt32; pname: DummyEnum; &params: array of UInt32) := GetQueryObjectuivEXT(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuivEXT(id: UInt32; pname: DummyEnum; var &params: UInt32) := GetQueryObjectuivEXT(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectuivEXT(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetQueryObjectuivEXT(id, pname, &params);
    
    {$endregion EXT_disjoint_timer_query EXT_occlusion_query_boolean}
    
    {$region EXT_scene_marker}
    
    public z_BeginSceneEXT := GetGLFuncOrNil&<procedure>('glBeginSceneEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginSceneEXT := z_BeginSceneEXT;
    
    public z_EndSceneEXT := GetGLFuncOrNil&<procedure>('glEndSceneEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndSceneEXT := z_EndSceneEXT;
    
    {$endregion EXT_scene_marker}
    
    {$region EXT_transform_feedback}
    
    public z_BindBufferRangeEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr; size: UIntPtr)>('glBindBufferRangeEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRangeEXT(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr; size: UIntPtr) := z_BindBufferRangeEXT(target, index, buffer, offset, size);
    
    public z_BindBufferOffsetEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr)>('glBindBufferOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferOffsetEXT(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr) := z_BindBufferOffsetEXT(target, index, buffer, offset);
    
    public z_BindBufferBaseEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; buffer: UInt32)>('glBindBufferBaseEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBaseEXT(target: DummyEnum; index: UInt32; buffer: UInt32) := z_BindBufferBaseEXT(target, index, buffer);
    
    public z_BeginTransformFeedbackEXT := GetGLFuncOrNil&<procedure(primitiveMode: DummyEnum)>('glBeginTransformFeedbackEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginTransformFeedbackEXT(primitiveMode: DummyEnum) := z_BeginTransformFeedbackEXT(primitiveMode);
    
    public z_EndTransformFeedbackEXT := GetGLFuncOrNil&<procedure>('glEndTransformFeedbackEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTransformFeedbackEXT := z_EndTransformFeedbackEXT;
    
    public z_TransformFeedbackVaryingsEXT := GetGLFuncOrNil&<procedure(&program: UInt32; count: Int32; varyings: pointer; bufferMode: DummyEnum)>('glTransformFeedbackVaryingsEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsEXT(&program: UInt32; count: Int32; varyings: array of IntPtr; bufferMode: DummyEnum) := TransformFeedbackVaryingsEXT(&program, count, varyings[0], bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsEXT(&program: UInt32; count: Int32; var varyings: IntPtr; bufferMode: DummyEnum) := TransformFeedbackVaryingsEXT(&program, count, @varyings, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsEXT(&program: UInt32; count: Int32; varyings: pointer; bufferMode: DummyEnum) := z_TransformFeedbackVaryingsEXT(&program, count, varyings, bufferMode);
    
    public z_GetTransformFeedbackVaryingEXT := GetGLFuncOrNil&<procedure(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr)>('glGetTransformFeedbackVaryingEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: pointer; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: pointer; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; var &type: DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: pointer; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length[0], size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: pointer; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; var &type: DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: pointer; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, @length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: pointer; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: pointer; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: DummyEnum; name: IntPtr) := GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingEXT(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr) := z_GetTransformFeedbackVaryingEXT(&program, index, bufSize, length, size, &type, name);
    
    {$endregion EXT_transform_feedback}
    
    {$region EXT_vertex_shader}
    
    public z_BeginVertexShaderEXT := GetGLFuncOrNil&<procedure>('glBeginVertexShaderEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginVertexShaderEXT := z_BeginVertexShaderEXT;
    
    public z_EndVertexShaderEXT := GetGLFuncOrNil&<procedure>('glEndVertexShaderEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndVertexShaderEXT := z_EndVertexShaderEXT;
    
    public z_BindVertexShaderEXT := GetGLFuncOrNil&<procedure(id: UInt32)>('glBindVertexShaderEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexShaderEXT(id: UInt32) := z_BindVertexShaderEXT(id);
    
    public z_GenVertexShadersEXT := GetGLFuncOrNil&<function(range: UInt32): UInt32>('glGenVertexShadersEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenVertexShadersEXT(range: UInt32): UInt32 := z_GenVertexShadersEXT(range);
    
    public z_DeleteVertexShaderEXT := GetGLFuncOrNil&<procedure(id: UInt32)>('glDeleteVertexShaderEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexShaderEXT(id: UInt32) := z_DeleteVertexShaderEXT(id);
    
    public z_ShaderOp1EXT := GetGLFuncOrNil&<procedure(op: DummyEnum; res: UInt32; arg1: UInt32)>('glShaderOp1EXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp1EXT(op: DummyEnum; res: UInt32; arg1: UInt32) := z_ShaderOp1EXT(op, res, arg1);
    
    public z_ShaderOp2EXT := GetGLFuncOrNil&<procedure(op: DummyEnum; res: UInt32; arg1: UInt32; arg2: UInt32)>('glShaderOp2EXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp2EXT(op: DummyEnum; res: UInt32; arg1: UInt32; arg2: UInt32) := z_ShaderOp2EXT(op, res, arg1, arg2);
    
    public z_ShaderOp3EXT := GetGLFuncOrNil&<procedure(op: DummyEnum; res: UInt32; arg1: UInt32; arg2: UInt32; arg3: UInt32)>('glShaderOp3EXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp3EXT(op: DummyEnum; res: UInt32; arg1: UInt32; arg2: UInt32; arg3: UInt32) := z_ShaderOp3EXT(op, res, arg1, arg2, arg3);
    
    public z_SwizzleEXT := GetGLFuncOrNil&<procedure(res: UInt32; &in: UInt32; outX: DummyEnum; outY: DummyEnum; outZ: DummyEnum; outW: DummyEnum)>('glSwizzleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SwizzleEXT(res: UInt32; &in: UInt32; outX: DummyEnum; outY: DummyEnum; outZ: DummyEnum; outW: DummyEnum) := z_SwizzleEXT(res, &in, outX, outY, outZ, outW);
    
    public z_WriteMaskEXT := GetGLFuncOrNil&<procedure(res: UInt32; &in: UInt32; outX: DummyEnum; outY: DummyEnum; outZ: DummyEnum; outW: DummyEnum)>('glWriteMaskEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WriteMaskEXT(res: UInt32; &in: UInt32; outX: DummyEnum; outY: DummyEnum; outZ: DummyEnum; outW: DummyEnum) := z_WriteMaskEXT(res, &in, outX, outY, outZ, outW);
    
    public z_InsertComponentEXT := GetGLFuncOrNil&<procedure(res: UInt32; src: UInt32; num: UInt32)>('glInsertComponentEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertComponentEXT(res: UInt32; src: UInt32; num: UInt32) := z_InsertComponentEXT(res, src, num);
    
    public z_ExtractComponentEXT := GetGLFuncOrNil&<procedure(res: UInt32; src: UInt32; num: UInt32)>('glExtractComponentEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtractComponentEXT(res: UInt32; src: UInt32; num: UInt32) := z_ExtractComponentEXT(res, src, num);
    
    public z_GenSymbolsEXT := GetGLFuncOrNil&<function(datatype: DummyEnum; storagetype: DummyEnum; range: DummyEnum; components: UInt32): UInt32>('glGenSymbolsEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenSymbolsEXT(datatype: DummyEnum; storagetype: DummyEnum; range: DummyEnum; components: UInt32): UInt32 := z_GenSymbolsEXT(datatype, storagetype, range, components);
    
    public z_SetInvariantEXT := GetGLFuncOrNil&<procedure(id: UInt32; &type: DummyEnum; addr: pointer)>('glSetInvariantEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetInvariantEXT(id: UInt32; &type: DummyEnum; addr: pointer) := z_SetInvariantEXT(id, &type, addr);
    
    public z_SetLocalConstantEXT := GetGLFuncOrNil&<procedure(id: UInt32; &type: DummyEnum; addr: pointer)>('glSetLocalConstantEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetLocalConstantEXT(id: UInt32; &type: DummyEnum; addr: pointer) := z_SetLocalConstantEXT(id, &type, addr);
    
    public z_VariantbvEXT := GetGLFuncOrNil&<procedure(id: UInt32; addr: pointer)>('glVariantbvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; addr: array of SByte) := VariantbvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; var addr: SByte) := VariantbvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; addr: pointer) := z_VariantbvEXT(id, addr);
    
    public z_VariantsvEXT := GetGLFuncOrNil&<procedure(id: UInt32; addr: pointer)>('glVariantsvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; addr: array of Int16) := VariantsvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; var addr: Int16) := VariantsvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; addr: pointer) := z_VariantsvEXT(id, addr);
    
    public z_VariantivEXT := GetGLFuncOrNil&<procedure(id: UInt32; addr: pointer)>('glVariantivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; addr: array of Int32) := VariantivEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; var addr: Int32) := VariantivEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; addr: pointer) := z_VariantivEXT(id, addr);
    
    public z_VariantfvEXT := GetGLFuncOrNil&<procedure(id: UInt32; addr: pointer)>('glVariantfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; addr: array of single) := VariantfvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; var addr: single) := VariantfvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; addr: pointer) := z_VariantfvEXT(id, addr);
    
    public z_VariantdvEXT := GetGLFuncOrNil&<procedure(id: UInt32; addr: pointer)>('glVariantdvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; addr: array of double) := VariantdvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; var addr: double) := VariantdvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; addr: pointer) := z_VariantdvEXT(id, addr);
    
    public z_VariantubvEXT := GetGLFuncOrNil&<procedure(id: UInt32; addr: pointer)>('glVariantubvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; addr: array of Byte) := VariantubvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; var addr: Byte) := VariantubvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; addr: pointer) := z_VariantubvEXT(id, addr);
    
    public z_VariantusvEXT := GetGLFuncOrNil&<procedure(id: UInt32; addr: pointer)>('glVariantusvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; addr: array of UInt16) := VariantusvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; var addr: UInt16) := VariantusvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; addr: pointer) := z_VariantusvEXT(id, addr);
    
    public z_VariantuivEXT := GetGLFuncOrNil&<procedure(id: UInt32; addr: pointer)>('glVariantuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; addr: array of UInt32) := VariantuivEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; var addr: UInt32) := VariantuivEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; addr: pointer) := z_VariantuivEXT(id, addr);
    
    public z_VariantPointerEXT := GetGLFuncOrNil&<procedure(id: UInt32; &type: DummyEnum; stride: UInt32; addr: pointer)>('glVariantPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantPointerEXT(id: UInt32; &type: DummyEnum; stride: UInt32; addr: pointer) := z_VariantPointerEXT(id, &type, stride, addr);
    
    public z_EnableVariantClientStateEXT := GetGLFuncOrNil&<procedure(id: UInt32)>('glEnableVariantClientStateEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVariantClientStateEXT(id: UInt32) := z_EnableVariantClientStateEXT(id);
    
    public z_DisableVariantClientStateEXT := GetGLFuncOrNil&<procedure(id: UInt32)>('glDisableVariantClientStateEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVariantClientStateEXT(id: UInt32) := z_DisableVariantClientStateEXT(id);
    
    public z_BindLightParameterEXT := GetGLFuncOrNil&<function(light: DummyEnum; value: DummyEnum): UInt32>('glBindLightParameterEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindLightParameterEXT(light: DummyEnum; value: DummyEnum): UInt32 := z_BindLightParameterEXT(light, value);
    
    public z_BindMaterialParameterEXT := GetGLFuncOrNil&<function(face: DummyEnum; value: DummyEnum): UInt32>('glBindMaterialParameterEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindMaterialParameterEXT(face: DummyEnum; value: DummyEnum): UInt32 := z_BindMaterialParameterEXT(face, value);
    
    public z_BindTexGenParameterEXT := GetGLFuncOrNil&<function(&unit: DummyEnum; coord: DummyEnum; value: DummyEnum): UInt32>('glBindTexGenParameterEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTexGenParameterEXT(&unit: DummyEnum; coord: DummyEnum; value: DummyEnum): UInt32 := z_BindTexGenParameterEXT(&unit, coord, value);
    
    public z_BindTextureUnitParameterEXT := GetGLFuncOrNil&<function(&unit: DummyEnum; value: DummyEnum): UInt32>('glBindTextureUnitParameterEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTextureUnitParameterEXT(&unit: DummyEnum; value: DummyEnum): UInt32 := z_BindTextureUnitParameterEXT(&unit, value);
    
    public z_BindParameterEXT := GetGLFuncOrNil&<function(value: DummyEnum): UInt32>('glBindParameterEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindParameterEXT(value: DummyEnum): UInt32 := z_BindParameterEXT(value);
    
    public z_IsVariantEnabledEXT := GetGLFuncOrNil&<function(id: UInt32; cap: DummyEnum): boolean>('glIsVariantEnabledEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVariantEnabledEXT(id: UInt32; cap: DummyEnum): boolean := z_IsVariantEnabledEXT(id, cap);
    
    public z_GetVariantBooleanvEXT := GetGLFuncOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>('glGetVariantBooleanvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantBooleanvEXT(id: UInt32; value: DummyEnum; data: array of boolean) := GetVariantBooleanvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantBooleanvEXT(id: UInt32; value: DummyEnum; var data: boolean) := GetVariantBooleanvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantBooleanvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetVariantBooleanvEXT(id, value, data);
    
    public z_GetVariantIntegervEXT := GetGLFuncOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>('glGetVariantIntegervEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantIntegervEXT(id: UInt32; value: DummyEnum; data: array of Int32) := GetVariantIntegervEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantIntegervEXT(id: UInt32; value: DummyEnum; var data: Int32) := GetVariantIntegervEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantIntegervEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetVariantIntegervEXT(id, value, data);
    
    public z_GetVariantFloatvEXT := GetGLFuncOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>('glGetVariantFloatvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantFloatvEXT(id: UInt32; value: DummyEnum; data: array of single) := GetVariantFloatvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantFloatvEXT(id: UInt32; value: DummyEnum; var data: single) := GetVariantFloatvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantFloatvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetVariantFloatvEXT(id, value, data);
    
    public z_GetVariantPointervEXT := GetGLFuncOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>('glGetVariantPointervEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantPointervEXT(id: UInt32; value: DummyEnum; data: array of IntPtr) := GetVariantPointervEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantPointervEXT(id: UInt32; value: DummyEnum; var data: IntPtr) := GetVariantPointervEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantPointervEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetVariantPointervEXT(id, value, data);
    
    public z_GetInvariantBooleanvEXT := GetGLFuncOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>('glGetInvariantBooleanvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantBooleanvEXT(id: UInt32; value: DummyEnum; data: array of boolean) := GetInvariantBooleanvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantBooleanvEXT(id: UInt32; value: DummyEnum; var data: boolean) := GetInvariantBooleanvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantBooleanvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetInvariantBooleanvEXT(id, value, data);
    
    public z_GetInvariantIntegervEXT := GetGLFuncOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>('glGetInvariantIntegervEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantIntegervEXT(id: UInt32; value: DummyEnum; data: array of Int32) := GetInvariantIntegervEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantIntegervEXT(id: UInt32; value: DummyEnum; var data: Int32) := GetInvariantIntegervEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantIntegervEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetInvariantIntegervEXT(id, value, data);
    
    public z_GetInvariantFloatvEXT := GetGLFuncOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>('glGetInvariantFloatvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantFloatvEXT(id: UInt32; value: DummyEnum; data: array of single) := GetInvariantFloatvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantFloatvEXT(id: UInt32; value: DummyEnum; var data: single) := GetInvariantFloatvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantFloatvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetInvariantFloatvEXT(id, value, data);
    
    public z_GetLocalConstantBooleanvEXT := GetGLFuncOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>('glGetLocalConstantBooleanvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantBooleanvEXT(id: UInt32; value: DummyEnum; data: array of boolean) := GetLocalConstantBooleanvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantBooleanvEXT(id: UInt32; value: DummyEnum; var data: boolean) := GetLocalConstantBooleanvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantBooleanvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetLocalConstantBooleanvEXT(id, value, data);
    
    public z_GetLocalConstantIntegervEXT := GetGLFuncOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>('glGetLocalConstantIntegervEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantIntegervEXT(id: UInt32; value: DummyEnum; data: array of Int32) := GetLocalConstantIntegervEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantIntegervEXT(id: UInt32; value: DummyEnum; var data: Int32) := GetLocalConstantIntegervEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantIntegervEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetLocalConstantIntegervEXT(id, value, data);
    
    public z_GetLocalConstantFloatvEXT := GetGLFuncOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>('glGetLocalConstantFloatvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantFloatvEXT(id: UInt32; value: DummyEnum; data: array of single) := GetLocalConstantFloatvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantFloatvEXT(id: UInt32; value: DummyEnum; var data: single) := GetLocalConstantFloatvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantFloatvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetLocalConstantFloatvEXT(id, value, data);
    
    {$endregion EXT_vertex_shader}
    
    {$region EXT_vertex_array_set / GenName version}
    
    public z_GenArraySetsEXT := GetGLFuncOrNil&<procedure(n: Int32; arrayset: pointer)>('glGenArraySetsEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenArraySetsEXT(n: Int32; arrayset: array of UInt32) := GenArraySetsEXT(n, arrayset[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenArraySetsEXT(n: Int32; var arrayset: UInt32) := GenArraySetsEXT(n, @arrayset);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenArraySetsEXT(n: Int32; arrayset: pointer) := z_GenArraySetsEXT(n, arrayset);
    
    public z_BindArraySetEXT := GetGLFuncOrNil&<procedure(arrayset: UInt32)>('glBindArraySetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindArraySetEXT(arrayset: UInt32) := z_BindArraySetEXT(arrayset);
    
    public z_DeleteArraySetsEXT := GetGLFuncOrNil&<procedure(n: Int32; arrayset: pointer)>('glDeleteArraySetsEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteArraySetsEXT(n: Int32; arrayset: array of UInt32) := DeleteArraySetsEXT(n, arrayset[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteArraySetsEXT(n: Int32; var arrayset: UInt32) := DeleteArraySetsEXT(n, @arrayset);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteArraySetsEXT(n: Int32; arrayset: pointer) := z_DeleteArraySetsEXT(n, arrayset);
    
    public z_IsArraySetEXT := GetGLFuncOrNil&<function(arrayset: UInt32): UInt32>('glIsArraySetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsArraySetEXT(arrayset: UInt32): UInt32 := z_IsArraySetEXT(arrayset);
    
    {$endregion EXT_vertex_array_set / GenName version}
    
    {$region EXT_blend_func_extended EXT_gpu_shader4}
    
    public z_BindFragDataLocationEXT := GetGLFuncOrNil&<procedure(&program: UInt32; color: UInt32; name: IntPtr)>('glBindFragDataLocationEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationEXT(&program: UInt32; color: UInt32; name: string); begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); BindFragDataLocationEXT(&program, color, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationEXT(&program: UInt32; color: UInt32; name: IntPtr) := z_BindFragDataLocationEXT(&program, color, name);
    
    {$endregion EXT_blend_func_extended EXT_gpu_shader4}
    
    {$region EXT_blend_func_extended}
    
    public z_BindFragDataLocationIndexedEXT := GetGLFuncOrNil&<procedure(&program: UInt32; colorNumber: UInt32; index: UInt32; name: IntPtr)>('glBindFragDataLocationIndexedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexedEXT(&program: UInt32; colorNumber: UInt32; index: UInt32; name: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(name); BindFragDataLocationIndexedEXT(&program, colorNumber, index, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragDataLocationIndexedEXT(&program: UInt32; colorNumber: UInt32; index: UInt32; name: IntPtr) := z_BindFragDataLocationIndexedEXT(&program, colorNumber, index, name);
    
    public z_GetFragDataIndexEXT := GetGLFuncOrNil&<function(&program: UInt32; name: IntPtr): Int32>('glGetFragDataIndexEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndexEXT(&program: UInt32; name: string): Int32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); Result := GetFragDataIndexEXT(&program, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataIndexEXT(&program: UInt32; name: IntPtr): Int32 := z_GetFragDataIndexEXT(&program, name);
    
    public z_GetProgramResourceLocationIndexEXT := GetGLFuncOrNil&<function(&program: UInt32; programInterface: DummyEnum; name: IntPtr): Int32>('glGetProgramResourceLocationIndexEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndexEXT(&program: UInt32; programInterface: DummyEnum; name: string): Int32; begin var ptr_3 := Marshal.StringToHGlobalAnsi(name); Result := GetProgramResourceLocationIndexEXT(&program, programInterface, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProgramResourceLocationIndexEXT(&program: UInt32; programInterface: DummyEnum; name: IntPtr): Int32 := z_GetProgramResourceLocationIndexEXT(&program, programInterface, name);
    
    {$endregion EXT_blend_func_extended}
    
    {$region EXT_framebuffer_object}
    
    public z_IsRenderbufferEXT := GetGLFuncOrNil&<function(renderbuffer: UInt32): boolean>('glIsRenderbufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsRenderbufferEXT(renderbuffer: UInt32): boolean := z_IsRenderbufferEXT(renderbuffer);
    
    public z_BindRenderbufferEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; renderbuffer: UInt32)>('glBindRenderbufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindRenderbufferEXT(target: DummyEnum; renderbuffer: UInt32) := z_BindRenderbufferEXT(target, renderbuffer);
    
    public z_DeleteRenderbuffersEXT := GetGLFuncOrNil&<procedure(n: Int32; renderbuffers: pointer)>('glDeleteRenderbuffersEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersEXT(n: Int32; renderbuffers: array of UInt32) := DeleteRenderbuffersEXT(n, renderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersEXT(n: Int32; var renderbuffers: UInt32) := DeleteRenderbuffersEXT(n, @renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersEXT(n: Int32; renderbuffers: pointer) := z_DeleteRenderbuffersEXT(n, renderbuffers);
    
    public z_GenRenderbuffersEXT := GetGLFuncOrNil&<procedure(n: Int32; renderbuffers: pointer)>('glGenRenderbuffersEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersEXT(n: Int32; renderbuffers: array of UInt32) := GenRenderbuffersEXT(n, renderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersEXT(n: Int32; var renderbuffers: UInt32) := GenRenderbuffersEXT(n, @renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersEXT(n: Int32; renderbuffers: pointer) := z_GenRenderbuffersEXT(n, renderbuffers);
    
    public z_RenderbufferStorageEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32)>('glRenderbufferStorageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageEXT(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageEXT(target, internalformat, width, height);
    
    public z_GetRenderbufferParameterivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetRenderbufferParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetRenderbufferParameterivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetRenderbufferParameterivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetRenderbufferParameterivEXT(target, pname, &params);
    
    public z_IsFramebufferEXT := GetGLFuncOrNil&<function(framebuffer: UInt32): boolean>('glIsFramebufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFramebufferEXT(framebuffer: UInt32): boolean := z_IsFramebufferEXT(framebuffer);
    
    public z_BindFramebufferEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; framebuffer: UInt32)>('glBindFramebufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFramebufferEXT(target: DummyEnum; framebuffer: UInt32) := z_BindFramebufferEXT(target, framebuffer);
    
    public z_DeleteFramebuffersEXT := GetGLFuncOrNil&<procedure(n: Int32; framebuffers: pointer)>('glDeleteFramebuffersEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersEXT(n: Int32; framebuffers: array of UInt32) := DeleteFramebuffersEXT(n, framebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersEXT(n: Int32; var framebuffers: UInt32) := DeleteFramebuffersEXT(n, @framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersEXT(n: Int32; framebuffers: pointer) := z_DeleteFramebuffersEXT(n, framebuffers);
    
    public z_GenFramebuffersEXT := GetGLFuncOrNil&<procedure(n: Int32; framebuffers: pointer)>('glGenFramebuffersEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersEXT(n: Int32; framebuffers: array of UInt32) := GenFramebuffersEXT(n, framebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersEXT(n: Int32; var framebuffers: UInt32) := GenFramebuffersEXT(n, @framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersEXT(n: Int32; framebuffers: pointer) := z_GenFramebuffersEXT(n, framebuffers);
    
    public z_CheckFramebufferStatusEXT := GetGLFuncOrNil&<function(target: DummyEnum): DummyEnum>('glCheckFramebufferStatusEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckFramebufferStatusEXT(target: DummyEnum): DummyEnum := z_CheckFramebufferStatusEXT(target);
    
    public z_FramebufferTexture1DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32)>('glFramebufferTexture1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture1DEXT(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32) := z_FramebufferTexture1DEXT(target, attachment, textarget, texture, level);
    
    public z_FramebufferTexture2DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32)>('glFramebufferTexture2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2DEXT(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32) := z_FramebufferTexture2DEXT(target, attachment, textarget, texture, level);
    
    public z_FramebufferTexture3DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; zoffset: Int32)>('glFramebufferTexture3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture3DEXT(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; zoffset: Int32) := z_FramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
    
    public z_FramebufferRenderbufferEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; renderbuffertarget: DummyEnum; renderbuffer: UInt32)>('glFramebufferRenderbufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferRenderbufferEXT(target: DummyEnum; attachment: DummyEnum; renderbuffertarget: DummyEnum; renderbuffer: UInt32) := z_FramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
    
    public z_GetFramebufferAttachmentParameterivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetFramebufferAttachmentParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameterivEXT(target: DummyEnum; attachment: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetFramebufferAttachmentParameterivEXT(target, attachment, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameterivEXT(target: DummyEnum; attachment: DummyEnum; pname: DummyEnum; var &params: Int32) := GetFramebufferAttachmentParameterivEXT(target, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameterivEXT(target: DummyEnum; attachment: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetFramebufferAttachmentParameterivEXT(target, attachment, pname, &params);
    
    public z_GenerateMipmapEXT := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glGenerateMipmapEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMipmapEXT(target: DummyEnum) := z_GenerateMipmapEXT(target);
    
    {$endregion EXT_framebuffer_object}
    
    {$region EXT_shader_image_load_store}
    
    public z_BindImageTextureEXT := GetGLFuncOrNil&<procedure(index: UInt32; texture: UInt32; level: Int32; layered: boolean; layer: Int32; access: DummyEnum; format: Int32)>('glBindImageTextureEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindImageTextureEXT(index: UInt32; texture: UInt32; level: Int32; layered: boolean; layer: Int32; access: DummyEnum; format: Int32) := z_BindImageTextureEXT(index, texture, level, layered, layer, access, format);
    
    public z_MemoryBarrierEXT := GetGLFuncOrNil&<procedure(barriers: DummyFlags)>('glMemoryBarrierEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryBarrierEXT(barriers: DummyFlags) := z_MemoryBarrierEXT(barriers);
    
    {$endregion EXT_shader_image_load_store}
    
    {$region EXT_direct_state_access}
    
    public z_ClientAttribDefaultEXT := GetGLFuncOrNil&<procedure(mask: DummyFlags)>('glClientAttribDefaultEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientAttribDefaultEXT(mask: DummyFlags) := z_ClientAttribDefaultEXT(mask);
    
    public z_PushClientAttribDefaultEXT := GetGLFuncOrNil&<procedure(mask: DummyFlags)>('glPushClientAttribDefaultEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushClientAttribDefaultEXT(mask: DummyFlags) := z_PushClientAttribDefaultEXT(mask);
    
    public z_MatrixLoadfEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; m: pointer)>('glMatrixLoadfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: DummyEnum; m: array of single) := MatrixLoadfEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: DummyEnum; var m: single) := MatrixLoadfEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: DummyEnum; m: pointer) := z_MatrixLoadfEXT(mode, m);
    
    public z_MatrixLoaddEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; m: pointer)>('glMatrixLoaddEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: DummyEnum; m: array of double) := MatrixLoaddEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: DummyEnum; var m: double) := MatrixLoaddEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: DummyEnum; m: pointer) := z_MatrixLoaddEXT(mode, m);
    
    public z_MatrixMultfEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; m: pointer)>('glMatrixMultfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: DummyEnum; m: array of single) := MatrixMultfEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: DummyEnum; var m: single) := MatrixMultfEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: DummyEnum; m: pointer) := z_MatrixMultfEXT(mode, m);
    
    public z_MatrixMultdEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; m: pointer)>('glMatrixMultdEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: DummyEnum; m: array of double) := MatrixMultdEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: DummyEnum; var m: double) := MatrixMultdEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: DummyEnum; m: pointer) := z_MatrixMultdEXT(mode, m);
    
    public z_MatrixLoadIdentityEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glMatrixLoadIdentityEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadIdentityEXT(mode: DummyEnum) := z_MatrixLoadIdentityEXT(mode);
    
    public z_MatrixRotatefEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; angle: single; x: single; y: single; z: single)>('glMatrixRotatefEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatefEXT(mode: DummyEnum; angle: single; x: single; y: single; z: single) := z_MatrixRotatefEXT(mode, angle, x, y, z);
    
    public z_MatrixRotatedEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; angle: double; x: double; y: double; z: double)>('glMatrixRotatedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatedEXT(mode: DummyEnum; angle: double; x: double; y: double; z: double) := z_MatrixRotatedEXT(mode, angle, x, y, z);
    
    public z_MatrixScalefEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; x: single; y: single; z: single)>('glMatrixScalefEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScalefEXT(mode: DummyEnum; x: single; y: single; z: single) := z_MatrixScalefEXT(mode, x, y, z);
    
    public z_MatrixScaledEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; x: double; y: double; z: double)>('glMatrixScaledEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScaledEXT(mode: DummyEnum; x: double; y: double; z: double) := z_MatrixScaledEXT(mode, x, y, z);
    
    public z_MatrixTranslatefEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; x: single; y: single; z: single)>('glMatrixTranslatefEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatefEXT(mode: DummyEnum; x: single; y: single; z: single) := z_MatrixTranslatefEXT(mode, x, y, z);
    
    public z_MatrixTranslatedEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; x: double; y: double; z: double)>('glMatrixTranslatedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatedEXT(mode: DummyEnum; x: double; y: double; z: double) := z_MatrixTranslatedEXT(mode, x, y, z);
    
    public z_MatrixOrthoEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double)>('glMatrixOrthoEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixOrthoEXT(mode: DummyEnum; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) := z_MatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
    
    public z_MatrixFrustumEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double)>('glMatrixFrustumEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixFrustumEXT(mode: DummyEnum; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) := z_MatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
    
    public z_MatrixPushEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glMatrixPushEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPushEXT(mode: DummyEnum) := z_MatrixPushEXT(mode);
    
    public z_MatrixPopEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glMatrixPopEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPopEXT(mode: DummyEnum) := z_MatrixPopEXT(mode);
    
    public z_TextureParameteriEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; pname: DummyEnum; param: Int32)>('glTextureParameteriEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameteriEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; param: Int32) := z_TextureParameteriEXT(texture, target, pname, param);
    
    public z_TextureParameterivEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTextureParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := TextureParameterivEXT(texture, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; var &params: Int32) := TextureParameterivEXT(texture, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TextureParameterivEXT(texture, target, pname, &params);
    
    public z_TextureParameterfEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; pname: DummyEnum; param: single)>('glTextureParameterfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; param: single) := z_TextureParameterfEXT(texture, target, pname, param);
    
    public z_TextureParameterfvEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTextureParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfvEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: array of single) := TextureParameterfvEXT(texture, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfvEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; var &params: single) := TextureParameterfvEXT(texture, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterfvEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TextureParameterfvEXT(texture, target, pname, &params);
    
    public z_TextureImage1DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTextureImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage1DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TextureImage1DEXT(texture, target, level, internalformat, width, border, format, &type, pixels);
    
    public z_TextureImage2DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTextureImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, &type, pixels);
    
    public z_TextureSubImage1DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTextureSubImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage1DEXT(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TextureSubImage1DEXT(texture, target, level, xoffset, width, format, &type, pixels);
    
    public z_TextureSubImage2DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTextureSubImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage2DEXT(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    public z_CopyTextureImage1DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32)>('glCopyTextureImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureImage1DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32) := z_CopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);
    
    public z_CopyTextureImage2DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>('glCopyTextureImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureImage2DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) := z_CopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);
    
    public z_CopyTextureSubImage1DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>('glCopyTextureSubImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage1DEXT(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) := z_CopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);
    
    public z_CopyTextureSubImage2DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyTextureSubImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage2DEXT(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);
    
    public z_GetTextureImageEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glGetTextureImageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureImageEXT(texture: UInt32; target: DummyEnum; level: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_GetTextureImageEXT(texture, target, level, format, &type, pixels);
    
    public z_GetTextureParameterfvEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTextureParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfvEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: array of single) := GetTextureParameterfvEXT(texture, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfvEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; var &params: single) := GetTextureParameterfvEXT(texture, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterfvEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTextureParameterfvEXT(texture, target, pname, &params);
    
    public z_GetTextureParameterivEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTextureParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetTextureParameterivEXT(texture, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetTextureParameterivEXT(texture, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTextureParameterivEXT(texture, target, pname, &params);
    
    public z_GetTextureLevelParameterfvEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer)>('glGetTextureLevelParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfvEXT(texture: UInt32; target: DummyEnum; level: Int32; pname: DummyEnum; &params: array of single) := GetTextureLevelParameterfvEXT(texture, target, level, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfvEXT(texture: UInt32; target: DummyEnum; level: Int32; pname: DummyEnum; var &params: single) := GetTextureLevelParameterfvEXT(texture, target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterfvEXT(texture: UInt32; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := z_GetTextureLevelParameterfvEXT(texture, target, level, pname, &params);
    
    public z_GetTextureLevelParameterivEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer)>('glGetTextureLevelParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterivEXT(texture: UInt32; target: DummyEnum; level: Int32; pname: DummyEnum; &params: array of Int32) := GetTextureLevelParameterivEXT(texture, target, level, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterivEXT(texture: UInt32; target: DummyEnum; level: Int32; pname: DummyEnum; var &params: Int32) := GetTextureLevelParameterivEXT(texture, target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureLevelParameterivEXT(texture: UInt32; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := z_GetTextureLevelParameterivEXT(texture, target, level, pname, &params);
    
    public z_TextureImage3DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTextureImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    public z_TextureSubImage3DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTextureSubImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureSubImage3DEXT(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    public z_CopyTextureSubImage3DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyTextureSubImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureSubImage3DEXT(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    public z_BindMultiTextureEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; texture: UInt32)>('glBindMultiTextureEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindMultiTextureEXT(texunit: DummyEnum; target: DummyEnum; texture: UInt32) := z_BindMultiTextureEXT(texunit, target, texture);
    
    public z_MultiTexCoordPointerEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glMultiTexCoordPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordPointerEXT(texunit: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_MultiTexCoordPointerEXT(texunit, size, &type, stride, _pointer);
    
    public z_MultiTexEnvfEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: single)>('glMultiTexEnvfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: single) := z_MultiTexEnvfEXT(texunit, target, pname, param);
    
    public z_MultiTexEnvfvEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glMultiTexEnvfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of single) := MultiTexEnvfvEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: single) := MultiTexEnvfvEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexEnvfvEXT(texunit, target, pname, &params);
    
    public z_MultiTexEnviEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: Int32)>('glMultiTexEnviEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnviEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: Int32) := z_MultiTexEnviEXT(texunit, target, pname, param);
    
    public z_MultiTexEnvivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glMultiTexEnvivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := MultiTexEnvivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := MultiTexEnvivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexEnvivEXT(texunit, target, pname, &params);
    
    public z_MultiTexGendEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: double)>('glMultiTexGendEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: double) := z_MultiTexGendEXT(texunit, coord, pname, param);
    
    public z_MultiTexGendvEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glMultiTexGendvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of double) := MultiTexGendvEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: double) := MultiTexGendvEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexGendvEXT(texunit, coord, pname, &params);
    
    public z_MultiTexGenfEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: single)>('glMultiTexGenfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: single) := z_MultiTexGenfEXT(texunit, coord, pname, param);
    
    public z_MultiTexGenfvEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glMultiTexGenfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of single) := MultiTexGenfvEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: single) := MultiTexGenfvEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexGenfvEXT(texunit, coord, pname, &params);
    
    public z_MultiTexGeniEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: Int32)>('glMultiTexGeniEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGeniEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: Int32) := z_MultiTexGeniEXT(texunit, coord, pname, param);
    
    public z_MultiTexGenivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glMultiTexGenivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of Int32) := MultiTexGenivEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: Int32) := MultiTexGenivEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexGenivEXT(texunit, coord, pname, &params);
    
    public z_GetMultiTexEnvfvEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMultiTexEnvfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of single) := GetMultiTexEnvfvEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: single) := GetMultiTexEnvfvEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexEnvfvEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexEnvivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMultiTexEnvivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMultiTexEnvivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMultiTexEnvivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexEnvivEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexGendvEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMultiTexGendvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of double) := GetMultiTexGendvEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: double) := GetMultiTexGendvEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexGendvEXT(texunit, coord, pname, &params);
    
    public z_GetMultiTexGenfvEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMultiTexGenfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of single) := GetMultiTexGenfvEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: single) := GetMultiTexGenfvEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexGenfvEXT(texunit, coord, pname, &params);
    
    public z_GetMultiTexGenivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMultiTexGenivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMultiTexGenivEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMultiTexGenivEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexGenivEXT(texunit, coord, pname, &params);
    
    public z_MultiTexParameteriEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: Int32)>('glMultiTexParameteriEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameteriEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: Int32) := z_MultiTexParameteriEXT(texunit, target, pname, param);
    
    public z_MultiTexParameterivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glMultiTexParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := MultiTexParameterivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := MultiTexParameterivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexParameterivEXT(texunit, target, pname, &params);
    
    public z_MultiTexParameterfEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: single)>('glMultiTexParameterfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: single) := z_MultiTexParameterfEXT(texunit, target, pname, param);
    
    public z_MultiTexParameterfvEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glMultiTexParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of single) := MultiTexParameterfvEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: single) := MultiTexParameterfvEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexParameterfvEXT(texunit, target, pname, &params);
    
    public z_MultiTexImage1DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glMultiTexImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, &type, pixels);
    
    public z_MultiTexImage2DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glMultiTexImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, &type, pixels);
    
    public z_MultiTexSubImage1DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glMultiTexSubImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, &type, pixels);
    
    public z_MultiTexSubImage2DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glMultiTexSubImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    public z_CopyMultiTexImage1DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32)>('glCopyMultiTexImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32) := z_CopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);
    
    public z_CopyMultiTexImage2DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>('glCopyMultiTexImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) := z_CopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);
    
    public z_CopyMultiTexSubImage1DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>('glCopyMultiTexSubImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) := z_CopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
    
    public z_CopyMultiTexSubImage2DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyMultiTexSubImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
    
    public z_GetMultiTexImageEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glGetMultiTexImageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexImageEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_GetMultiTexImageEXT(texunit, target, level, format, &type, pixels);
    
    public z_GetMultiTexParameterfvEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMultiTexParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of single) := GetMultiTexParameterfvEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: single) := GetMultiTexParameterfvEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexParameterfvEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexParameterivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMultiTexParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMultiTexParameterivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMultiTexParameterivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexParameterivEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexLevelParameterfvEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer)>('glGetMultiTexLevelParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterfvEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: array of single) := GetMultiTexLevelParameterfvEXT(texunit, target, level, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterfvEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; var &params: single) := GetMultiTexLevelParameterfvEXT(texunit, target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterfvEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := z_GetMultiTexLevelParameterfvEXT(texunit, target, level, pname, &params);
    
    public z_GetMultiTexLevelParameterivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer)>('glGetMultiTexLevelParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterivEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: array of Int32) := GetMultiTexLevelParameterivEXT(texunit, target, level, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterivEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; var &params: Int32) := GetMultiTexLevelParameterivEXT(texunit, target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterivEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := z_GetMultiTexLevelParameterivEXT(texunit, target, level, pname, &params);
    
    public z_MultiTexImage3DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glMultiTexImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage3DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    public z_MultiTexSubImage3DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glMultiTexSubImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage3DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    public z_CopyMultiTexSubImage3DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyMultiTexSubImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage3DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    public z_EnableClientStateIndexedEXT := GetGLFuncOrNil&<procedure(&array: DummyEnum; index: UInt32)>('glEnableClientStateIndexedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientStateIndexedEXT(&array: DummyEnum; index: UInt32) := z_EnableClientStateIndexedEXT(&array, index);
    
    public z_DisableClientStateIndexedEXT := GetGLFuncOrNil&<procedure(&array: DummyEnum; index: UInt32)>('glDisableClientStateIndexedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientStateIndexedEXT(&array: DummyEnum; index: UInt32) := z_DisableClientStateIndexedEXT(&array, index);
    
    public z_EnableClientStateiEXT := GetGLFuncOrNil&<procedure(&array: DummyEnum; index: UInt32)>('glEnableClientStateiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientStateiEXT(&array: DummyEnum; index: UInt32) := z_EnableClientStateiEXT(&array, index);
    
    public z_DisableClientStateiEXT := GetGLFuncOrNil&<procedure(&array: DummyEnum; index: UInt32)>('glDisableClientStateiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientStateiEXT(&array: DummyEnum; index: UInt32) := z_DisableClientStateiEXT(&array, index);
    
    public z_GetFloatIndexedvEXT := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetFloatIndexedvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatIndexedvEXT(target: GLGetQueries; index: UInt32; data: array of single) := GetFloatIndexedvEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatIndexedvEXT(target: GLGetQueries; index: UInt32; var data: single) := GetFloatIndexedvEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatIndexedvEXT(target: GLGetQueries; index: UInt32; data: pointer) := z_GetFloatIndexedvEXT(target, index, data);
    
    public z_GetDoubleIndexedvEXT := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetDoubleIndexedvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoubleIndexedvEXT(target: GLGetQueries; index: UInt32; data: array of double) := GetDoubleIndexedvEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoubleIndexedvEXT(target: GLGetQueries; index: UInt32; var data: double) := GetDoubleIndexedvEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoubleIndexedvEXT(target: GLGetQueries; index: UInt32; data: pointer) := z_GetDoubleIndexedvEXT(target, index, data);
    
    public z_GetPointerIndexedvEXT := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetPointerIndexedvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerIndexedvEXT(target: GLGetQueries; index: UInt32; data: array of IntPtr) := GetPointerIndexedvEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerIndexedvEXT(target: GLGetQueries; index: UInt32; var data: IntPtr) := GetPointerIndexedvEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerIndexedvEXT(target: GLGetQueries; index: UInt32; data: pointer) := z_GetPointerIndexedvEXT(target, index, data);
    
    public z_GetFloati_vEXT := GetGLFuncOrNil&<procedure(pname: GLGetQueries; index: UInt32; &params: pointer)>('glGetFloati_vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vEXT(pname: GLGetQueries; index: UInt32; &params: array of single) := GetFloati_vEXT(pname, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vEXT(pname: GLGetQueries; index: UInt32; var &params: single) := GetFloati_vEXT(pname, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vEXT(pname: GLGetQueries; index: UInt32; &params: pointer) := z_GetFloati_vEXT(pname, index, &params);
    
    public z_GetDoublei_vEXT := GetGLFuncOrNil&<procedure(pname: GLGetQueries; index: UInt32; &params: pointer)>('glGetDoublei_vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_vEXT(pname: GLGetQueries; index: UInt32; &params: array of double) := GetDoublei_vEXT(pname, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_vEXT(pname: GLGetQueries; index: UInt32; var &params: double) := GetDoublei_vEXT(pname, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoublei_vEXT(pname: GLGetQueries; index: UInt32; &params: pointer) := z_GetDoublei_vEXT(pname, index, &params);
    
    public z_GetPointeri_vEXT := GetGLFuncOrNil&<procedure(pname: GLGetQueries; index: UInt32; &params: pointer)>('glGetPointeri_vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointeri_vEXT(pname: GLGetQueries; index: UInt32; &params: array of IntPtr) := GetPointeri_vEXT(pname, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointeri_vEXT(pname: GLGetQueries; index: UInt32; var &params: IntPtr) := GetPointeri_vEXT(pname, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointeri_vEXT(pname: GLGetQueries; index: UInt32; &params: pointer) := z_GetPointeri_vEXT(pname, index, &params);
    
    public z_NamedProgramStringEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; format: DummyEnum; len: Int32; string: pointer)>('glNamedProgramStringEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramStringEXT(&program: UInt32; target: DummyEnum; format: DummyEnum; len: Int32; string: pointer) := z_NamedProgramStringEXT(&program, target, format, len, string);
    
    public z_NamedProgramLocalParameter4dEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double)>('glNamedProgramLocalParameter4dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dEXT(&program: UInt32; target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := z_NamedProgramLocalParameter4dEXT(&program, target, index, x, y, z, w);
    
    public z_NamedProgramLocalParameter4dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>('glNamedProgramLocalParameter4dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of double) := NamedProgramLocalParameter4dvEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: double) := NamedProgramLocalParameter4dvEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_NamedProgramLocalParameter4dvEXT(&program, target, index, &params);
    
    public z_NamedProgramLocalParameter4fEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single)>('glNamedProgramLocalParameter4fEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fEXT(&program: UInt32; target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := z_NamedProgramLocalParameter4fEXT(&program, target, index, x, y, z, w);
    
    public z_NamedProgramLocalParameter4fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>('glNamedProgramLocalParameter4fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of single) := NamedProgramLocalParameter4fvEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: single) := NamedProgramLocalParameter4fvEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_NamedProgramLocalParameter4fvEXT(&program, target, index, &params);
    
    public z_GetNamedProgramLocalParameterdvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>('glGetNamedProgramLocalParameterdvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterdvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of double) := GetNamedProgramLocalParameterdvEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterdvEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: double) := GetNamedProgramLocalParameterdvEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterdvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_GetNamedProgramLocalParameterdvEXT(&program, target, index, &params);
    
    public z_GetNamedProgramLocalParameterfvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>('glGetNamedProgramLocalParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterfvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of single) := GetNamedProgramLocalParameterfvEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterfvEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: single) := GetNamedProgramLocalParameterfvEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterfvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_GetNamedProgramLocalParameterfvEXT(&program, target, index, &params);
    
    public z_GetNamedProgramivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetNamedProgramivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramivEXT(&program: UInt32; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetNamedProgramivEXT(&program, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramivEXT(&program: UInt32; target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetNamedProgramivEXT(&program, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramivEXT(&program: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetNamedProgramivEXT(&program, target, pname, &params);
    
    public z_GetNamedProgramStringEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; pname: DummyEnum; string: pointer)>('glGetNamedProgramStringEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramStringEXT(&program: UInt32; target: DummyEnum; pname: DummyEnum; string: pointer) := z_GetNamedProgramStringEXT(&program, target, pname, string);
    
    public z_CompressedTextureImage3DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer)>('glCompressedTextureImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage3DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
    
    public z_CompressedTextureImage2DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer)>('glCompressedTextureImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage2DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);
    
    public z_CompressedTextureImage1DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; bits: pointer)>('glCompressedTextureImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage1DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);
    
    public z_CompressedTextureSubImage3DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; bits: pointer)>('glCompressedTextureSubImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage3DEXT(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := z_CompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    
    public z_CompressedTextureSubImage2DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; imageSize: Int32; bits: pointer)>('glCompressedTextureSubImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage2DEXT(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := z_CompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    
    public z_CompressedTextureSubImage1DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; imageSize: Int32; bits: pointer)>('glCompressedTextureSubImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureSubImage1DEXT(texture: UInt32; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := z_CompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);
    
    public z_GetCompressedTextureImageEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; lod: Int32; img: pointer)>('glGetCompressedTextureImageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedTextureImageEXT(texture: UInt32; target: DummyEnum; lod: Int32; img: pointer) := z_GetCompressedTextureImageEXT(texture, target, lod, img);
    
    public z_CompressedMultiTexImage3DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer)>('glCompressedMultiTexImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage3DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
    
    public z_CompressedMultiTexImage2DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer)>('glCompressedMultiTexImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);
    
    public z_CompressedMultiTexImage1DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; bits: pointer)>('glCompressedMultiTexImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits);
    
    public z_CompressedMultiTexSubImage3DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; bits: pointer)>('glCompressedMultiTexSubImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage3DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := z_CompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    
    public z_CompressedMultiTexSubImage2DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; imageSize: Int32; bits: pointer)>('glCompressedMultiTexSubImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := z_CompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    
    public z_CompressedMultiTexSubImage1DEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; imageSize: Int32; bits: pointer)>('glCompressedMultiTexSubImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := z_CompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits);
    
    public z_GetCompressedMultiTexImageEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; lod: Int32; img: pointer)>('glGetCompressedMultiTexImageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedMultiTexImageEXT(texunit: DummyEnum; target: DummyEnum; lod: Int32; img: pointer) := z_GetCompressedMultiTexImageEXT(texunit, target, lod, img);
    
    public z_MatrixLoadTransposefEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; m: pointer)>('glMatrixLoadTransposefEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: DummyEnum; m: array of single) := MatrixLoadTransposefEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: DummyEnum; var m: single) := MatrixLoadTransposefEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: DummyEnum; m: pointer) := z_MatrixLoadTransposefEXT(mode, m);
    
    public z_MatrixLoadTransposedEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; m: pointer)>('glMatrixLoadTransposedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: DummyEnum; m: array of double) := MatrixLoadTransposedEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: DummyEnum; var m: double) := MatrixLoadTransposedEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: DummyEnum; m: pointer) := z_MatrixLoadTransposedEXT(mode, m);
    
    public z_MatrixMultTransposefEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; m: pointer)>('glMatrixMultTransposefEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: DummyEnum; m: array of single) := MatrixMultTransposefEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: DummyEnum; var m: single) := MatrixMultTransposefEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: DummyEnum; m: pointer) := z_MatrixMultTransposefEXT(mode, m);
    
    public z_MatrixMultTransposedEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; m: pointer)>('glMatrixMultTransposedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: DummyEnum; m: array of double) := MatrixMultTransposedEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: DummyEnum; var m: double) := MatrixMultTransposedEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: DummyEnum; m: pointer) := z_MatrixMultTransposedEXT(mode, m);
    
    public z_NamedBufferDataEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; size: UIntPtr; data: pointer; usage: DummyEnum)>('glNamedBufferDataEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferDataEXT(buffer: UInt32; size: UIntPtr; data: pointer; usage: DummyEnum) := z_NamedBufferDataEXT(buffer, size, data, usage);
    
    public z_NamedBufferSubDataEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer)>('glNamedBufferSubDataEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferSubDataEXT(buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer) := z_NamedBufferSubDataEXT(buffer, offset, size, data);
    
    public z_MapNamedBufferEXT := GetGLFuncOrNil&<function(buffer: UInt32; access: DummyEnum): pointer>('glMapNamedBufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferEXT(buffer: UInt32; access: DummyEnum): pointer := z_MapNamedBufferEXT(buffer, access);
    
    public z_UnmapNamedBufferEXT := GetGLFuncOrNil&<function(buffer: UInt32): boolean>('glUnmapNamedBufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapNamedBufferEXT(buffer: UInt32): boolean := z_UnmapNamedBufferEXT(buffer);
    
    public z_GetNamedBufferParameterivEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; pname: DummyEnum; &params: pointer)>('glGetNamedBufferParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterivEXT(buffer: UInt32; pname: DummyEnum; &params: array of Int32) := GetNamedBufferParameterivEXT(buffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterivEXT(buffer: UInt32; pname: DummyEnum; var &params: Int32) := GetNamedBufferParameterivEXT(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterivEXT(buffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetNamedBufferParameterivEXT(buffer, pname, &params);
    
    public z_GetNamedBufferPointervEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; pname: DummyEnum; &params: pointer)>('glGetNamedBufferPointervEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointervEXT(buffer: UInt32; pname: DummyEnum; &params: array of IntPtr) := GetNamedBufferPointervEXT(buffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointervEXT(buffer: UInt32; pname: DummyEnum; var &params: IntPtr) := GetNamedBufferPointervEXT(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferPointervEXT(buffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetNamedBufferPointervEXT(buffer, pname, &params);
    
    public z_GetNamedBufferSubDataEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer)>('glGetNamedBufferSubDataEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferSubDataEXT(buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer) := z_GetNamedBufferSubDataEXT(buffer, offset, size, data);
    
    public z_TextureBufferEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; internalformat: DummyEnum; buffer: UInt32)>('glTextureBufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferEXT(texture: UInt32; target: DummyEnum; internalformat: DummyEnum; buffer: UInt32) := z_TextureBufferEXT(texture, target, internalformat, buffer);
    
    public z_MultiTexBufferEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; internalformat: DummyEnum; buffer: UInt32)>('glMultiTexBufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexBufferEXT(texunit: DummyEnum; target: DummyEnum; internalformat: DummyEnum; buffer: UInt32) := z_MultiTexBufferEXT(texunit, target, internalformat, buffer);
    
    public z_TextureParameterIivEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTextureParameterIivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := TextureParameterIivEXT(texture, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; var &params: Int32) := TextureParameterIivEXT(texture, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TextureParameterIivEXT(texture, target, pname, &params);
    
    public z_TextureParameterIuivEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTextureParameterIuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: array of UInt32) := TextureParameterIuivEXT(texture, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; var &params: UInt32) := TextureParameterIuivEXT(texture, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureParameterIuivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TextureParameterIuivEXT(texture, target, pname, &params);
    
    public z_GetTextureParameterIivEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTextureParameterIivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetTextureParameterIivEXT(texture, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetTextureParameterIivEXT(texture, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTextureParameterIivEXT(texture, target, pname, &params);
    
    public z_GetTextureParameterIuivEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTextureParameterIuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: array of UInt32) := GetTextureParameterIuivEXT(texture, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; var &params: UInt32) := GetTextureParameterIuivEXT(texture, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTextureParameterIuivEXT(texture: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTextureParameterIuivEXT(texture, target, pname, &params);
    
    public z_MultiTexParameterIivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glMultiTexParameterIivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := MultiTexParameterIivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := MultiTexParameterIivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexParameterIivEXT(texunit, target, pname, &params);
    
    public z_MultiTexParameterIuivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glMultiTexParameterIuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of UInt32) := MultiTexParameterIuivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: UInt32) := MultiTexParameterIuivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexParameterIuivEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexParameterIivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMultiTexParameterIivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMultiTexParameterIivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMultiTexParameterIivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexParameterIivEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexParameterIuivEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMultiTexParameterIuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of UInt32) := GetMultiTexParameterIuivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: UInt32) := GetMultiTexParameterIuivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexParameterIuivEXT(texunit, target, pname, &params);
    
    public z_NamedProgramLocalParameters4fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>('glNamedProgramLocalParameters4fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: array of single) := NamedProgramLocalParameters4fvEXT(&program, target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; var &params: single) := NamedProgramLocalParameters4fvEXT(&program, target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_NamedProgramLocalParameters4fvEXT(&program, target, index, count, &params);
    
    public z_NamedProgramLocalParameterI4iEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>('glNamedProgramLocalParameterI4iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4iEXT(&program: UInt32; target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := z_NamedProgramLocalParameterI4iEXT(&program, target, index, x, y, z, w);
    
    public z_NamedProgramLocalParameterI4ivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>('glNamedProgramLocalParameterI4ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of Int32) := NamedProgramLocalParameterI4ivEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: Int32) := NamedProgramLocalParameterI4ivEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_NamedProgramLocalParameterI4ivEXT(&program, target, index, &params);
    
    public z_NamedProgramLocalParametersI4ivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>('glNamedProgramLocalParametersI4ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: array of Int32) := NamedProgramLocalParametersI4ivEXT(&program, target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; var &params: Int32) := NamedProgramLocalParametersI4ivEXT(&program, target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_NamedProgramLocalParametersI4ivEXT(&program, target, index, count, &params);
    
    public z_NamedProgramLocalParameterI4uiEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>('glNamedProgramLocalParameterI4uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uiEXT(&program: UInt32; target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := z_NamedProgramLocalParameterI4uiEXT(&program, target, index, x, y, z, w);
    
    public z_NamedProgramLocalParameterI4uivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>('glNamedProgramLocalParameterI4uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of UInt32) := NamedProgramLocalParameterI4uivEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: UInt32) := NamedProgramLocalParameterI4uivEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_NamedProgramLocalParameterI4uivEXT(&program, target, index, &params);
    
    public z_NamedProgramLocalParametersI4uivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>('glNamedProgramLocalParametersI4uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: array of UInt32) := NamedProgramLocalParametersI4uivEXT(&program, target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; var &params: UInt32) := NamedProgramLocalParametersI4uivEXT(&program, target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_NamedProgramLocalParametersI4uivEXT(&program, target, index, count, &params);
    
    public z_GetNamedProgramLocalParameterIivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>('glGetNamedProgramLocalParameterIivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of Int32) := GetNamedProgramLocalParameterIivEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIivEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: Int32) := GetNamedProgramLocalParameterIivEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_GetNamedProgramLocalParameterIivEXT(&program, target, index, &params);
    
    public z_GetNamedProgramLocalParameterIuivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>('glGetNamedProgramLocalParameterIuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIuivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of UInt32) := GetNamedProgramLocalParameterIuivEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIuivEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: UInt32) := GetNamedProgramLocalParameterIuivEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIuivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_GetNamedProgramLocalParameterIuivEXT(&program, target, index, &params);
    
    public z_NamedRenderbufferStorageEXT := GetGLFuncOrNil&<procedure(renderbuffer: UInt32; internalformat: DummyEnum; width: Int32; height: Int32)>('glNamedRenderbufferStorageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageEXT(renderbuffer: UInt32; internalformat: DummyEnum; width: Int32; height: Int32) := z_NamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);
    
    public z_GetNamedRenderbufferParameterivEXT := GetGLFuncOrNil&<procedure(renderbuffer: UInt32; pname: DummyEnum; &params: pointer)>('glGetNamedRenderbufferParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameterivEXT(renderbuffer: UInt32; pname: DummyEnum; &params: array of Int32) := GetNamedRenderbufferParameterivEXT(renderbuffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameterivEXT(renderbuffer: UInt32; pname: DummyEnum; var &params: Int32) := GetNamedRenderbufferParameterivEXT(renderbuffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedRenderbufferParameterivEXT(renderbuffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetNamedRenderbufferParameterivEXT(renderbuffer, pname, &params);
    
    public z_NamedRenderbufferStorageMultisampleEXT := GetGLFuncOrNil&<procedure(renderbuffer: UInt32; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glNamedRenderbufferStorageMultisampleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleEXT(renderbuffer: UInt32; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_NamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);
    
    public z_NamedRenderbufferStorageMultisampleCoverageEXT := GetGLFuncOrNil&<procedure(renderbuffer: UInt32; coverageSamples: Int32; colorSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glNamedRenderbufferStorageMultisampleCoverageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer: UInt32; coverageSamples: Int32; colorSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_NamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
    
    public z_CheckNamedFramebufferStatusEXT := GetGLFuncOrNil&<function(framebuffer: UInt32; target: DummyEnum): DummyEnum>('glCheckNamedFramebufferStatusEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckNamedFramebufferStatusEXT(framebuffer: UInt32; target: DummyEnum): DummyEnum := z_CheckNamedFramebufferStatusEXT(framebuffer, target);
    
    public z_NamedFramebufferTexture1DEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32)>('glNamedFramebufferTexture1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture1DEXT(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32) := z_NamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
    
    public z_NamedFramebufferTexture2DEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32)>('glNamedFramebufferTexture2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture2DEXT(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32) := z_NamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
    
    public z_NamedFramebufferTexture3DEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; zoffset: Int32)>('glNamedFramebufferTexture3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture3DEXT(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; zoffset: Int32) := z_NamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
    
    public z_NamedFramebufferRenderbufferEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; renderbuffertarget: DummyEnum; renderbuffer: UInt32)>('glNamedFramebufferRenderbufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferRenderbufferEXT(framebuffer: UInt32; attachment: DummyEnum; renderbuffertarget: DummyEnum; renderbuffer: UInt32) := z_NamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);
    
    public z_GetNamedFramebufferAttachmentParameterivEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetNamedFramebufferAttachmentParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameterivEXT(framebuffer: UInt32; attachment: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameterivEXT(framebuffer: UInt32; attachment: DummyEnum; pname: DummyEnum; var &params: Int32) := GetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferAttachmentParameterivEXT(framebuffer: UInt32; attachment: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, &params);
    
    public z_GenerateTextureMipmapEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum)>('glGenerateTextureMipmapEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateTextureMipmapEXT(texture: UInt32; target: DummyEnum) := z_GenerateTextureMipmapEXT(texture, target);
    
    public z_GenerateMultiTexMipmapEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum)>('glGenerateMultiTexMipmapEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMultiTexMipmapEXT(texunit: DummyEnum; target: DummyEnum) := z_GenerateMultiTexMipmapEXT(texunit, target);
    
    public z_FramebufferDrawBufferEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; mode: DummyEnum)>('glFramebufferDrawBufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBufferEXT(framebuffer: UInt32; mode: DummyEnum) := z_FramebufferDrawBufferEXT(framebuffer, mode);
    
    public z_FramebufferDrawBuffersEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; n: Int32; bufs: pointer)>('glFramebufferDrawBuffersEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: UInt32; n: Int32; bufs: array of DummyEnum) := FramebufferDrawBuffersEXT(framebuffer, n, bufs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: UInt32; n: Int32; var bufs: DummyEnum) := FramebufferDrawBuffersEXT(framebuffer, n, @bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: UInt32; n: Int32; bufs: pointer) := z_FramebufferDrawBuffersEXT(framebuffer, n, bufs);
    
    public z_FramebufferReadBufferEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; mode: DummyEnum)>('glFramebufferReadBufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferReadBufferEXT(framebuffer: UInt32; mode: DummyEnum) := z_FramebufferReadBufferEXT(framebuffer, mode);
    
    public z_GetFramebufferParameterivEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; pname: DummyEnum; &params: pointer)>('glGetFramebufferParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivEXT(framebuffer: UInt32; pname: DummyEnum; &params: array of Int32) := GetFramebufferParameterivEXT(framebuffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivEXT(framebuffer: UInt32; pname: DummyEnum; var &params: Int32) := GetFramebufferParameterivEXT(framebuffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterivEXT(framebuffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetFramebufferParameterivEXT(framebuffer, pname, &params);
    
    public z_NamedCopyBufferSubDataEXT := GetGLFuncOrNil&<procedure(readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>('glNamedCopyBufferSubDataEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedCopyBufferSubDataEXT(readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_NamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    public z_NamedFramebufferTextureEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32)>('glNamedFramebufferTextureEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureEXT(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32) := z_NamedFramebufferTextureEXT(framebuffer, attachment, texture, level);
    
    public z_NamedFramebufferTextureLayerEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32)>('glNamedFramebufferTextureLayerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureLayerEXT(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32) := z_NamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);
    
    public z_NamedFramebufferTextureFaceEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum)>('glNamedFramebufferTextureFaceEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureFaceEXT(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum) := z_NamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
    
    public z_TextureRenderbufferEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; renderbuffer: UInt32)>('glTextureRenderbufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureRenderbufferEXT(texture: UInt32; target: DummyEnum; renderbuffer: UInt32) := z_TextureRenderbufferEXT(texture, target, renderbuffer);
    
    public z_MultiTexRenderbufferEXT := GetGLFuncOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; renderbuffer: UInt32)>('glMultiTexRenderbufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexRenderbufferEXT(texunit: DummyEnum; target: DummyEnum; renderbuffer: UInt32) := z_MultiTexRenderbufferEXT(texunit, target, renderbuffer);
    
    public z_VertexArrayVertexOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>('glVertexArrayVertexOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayVertexOffsetEXT(vaobj, buffer, size, &type, stride, offset);
    
    public z_VertexArrayColorOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>('glVertexArrayColorOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayColorOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayColorOffsetEXT(vaobj, buffer, size, &type, stride, offset);
    
    public z_VertexArrayEdgeFlagOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; stride: Int32; offset: IntPtr)>('glVertexArrayEdgeFlagOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayEdgeFlagOffsetEXT(vaobj: UInt32; buffer: UInt32; stride: Int32; offset: IntPtr) := z_VertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
    
    public z_VertexArrayIndexOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr)>('glVertexArrayIndexOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayIndexOffsetEXT(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayIndexOffsetEXT(vaobj, buffer, &type, stride, offset);
    
    public z_VertexArrayNormalOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr)>('glVertexArrayNormalOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayNormalOffsetEXT(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayNormalOffsetEXT(vaobj, buffer, &type, stride, offset);
    
    public z_VertexArrayTexCoordOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>('glVertexArrayTexCoordOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayTexCoordOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayTexCoordOffsetEXT(vaobj, buffer, size, &type, stride, offset);
    
    public z_VertexArrayMultiTexCoordOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; texunit: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>('glVertexArrayMultiTexCoordOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayMultiTexCoordOffsetEXT(vaobj: UInt32; buffer: UInt32; texunit: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, &type, stride, offset);
    
    public z_VertexArrayFogCoordOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr)>('glVertexArrayFogCoordOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayFogCoordOffsetEXT(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayFogCoordOffsetEXT(vaobj, buffer, &type, stride, offset);
    
    public z_VertexArraySecondaryColorOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>('glVertexArraySecondaryColorOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArraySecondaryColorOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, &type, stride, offset);
    
    public z_VertexArrayVertexAttribOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; normalized: boolean; stride: Int32; offset: IntPtr)>('glVertexArrayVertexAttribOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribOffsetEXT(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; normalized: boolean; stride: Int32; offset: IntPtr) := z_VertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, &type, normalized, stride, offset);
    
    public z_VertexArrayVertexAttribIOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>('glVertexArrayVertexAttribIOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribIOffsetEXT(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, &type, stride, offset);
    
    public z_EnableVertexArrayEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; &array: DummyEnum)>('glEnableVertexArrayEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayEXT(vaobj: UInt32; &array: DummyEnum) := z_EnableVertexArrayEXT(vaobj, &array);
    
    public z_DisableVertexArrayEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; &array: DummyEnum)>('glDisableVertexArrayEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayEXT(vaobj: UInt32; &array: DummyEnum) := z_DisableVertexArrayEXT(vaobj, &array);
    
    public z_EnableVertexArrayAttribEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; index: UInt32)>('glEnableVertexArrayAttribEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayAttribEXT(vaobj: UInt32; index: UInt32) := z_EnableVertexArrayAttribEXT(vaobj, index);
    
    public z_DisableVertexArrayAttribEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; index: UInt32)>('glDisableVertexArrayAttribEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayAttribEXT(vaobj: UInt32; index: UInt32) := z_DisableVertexArrayAttribEXT(vaobj, index);
    
    public z_GetVertexArrayIntegervEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; pname: DummyEnum; param: pointer)>('glGetVertexArrayIntegervEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegervEXT(vaobj: UInt32; pname: DummyEnum; param: array of Int32) := GetVertexArrayIntegervEXT(vaobj, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegervEXT(vaobj: UInt32; pname: DummyEnum; var param: Int32) := GetVertexArrayIntegervEXT(vaobj, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegervEXT(vaobj: UInt32; pname: DummyEnum; param: pointer) := z_GetVertexArrayIntegervEXT(vaobj, pname, param);
    
    public z_GetVertexArrayPointervEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; pname: DummyEnum; param: pointer)>('glGetVertexArrayPointervEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointervEXT(vaobj: UInt32; pname: DummyEnum; param: array of IntPtr) := GetVertexArrayPointervEXT(vaobj, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointervEXT(vaobj: UInt32; pname: DummyEnum; var param: IntPtr) := GetVertexArrayPointervEXT(vaobj, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointervEXT(vaobj: UInt32; pname: DummyEnum; param: pointer) := z_GetVertexArrayPointervEXT(vaobj, pname, param);
    
    public z_GetVertexArrayIntegeri_vEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: pointer)>('glGetVertexArrayIntegeri_vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: array of Int32) := GetVertexArrayIntegeri_vEXT(vaobj, index, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; var param: Int32) := GetVertexArrayIntegeri_vEXT(vaobj, index, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: pointer) := z_GetVertexArrayIntegeri_vEXT(vaobj, index, pname, param);
    
    public z_GetVertexArrayPointeri_vEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: pointer)>('glGetVertexArrayPointeri_vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: array of IntPtr) := GetVertexArrayPointeri_vEXT(vaobj, index, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; var param: IntPtr) := GetVertexArrayPointeri_vEXT(vaobj, index, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: pointer) := z_GetVertexArrayPointeri_vEXT(vaobj, index, pname, param);
    
    public z_MapNamedBufferRangeEXT := GetGLFuncOrNil&<function(buffer: UInt32; offset: IntPtr; length: UIntPtr; access: DummyFlags): pointer>('glMapNamedBufferRangeEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapNamedBufferRangeEXT(buffer: UInt32; offset: IntPtr; length: UIntPtr; access: DummyFlags): pointer := z_MapNamedBufferRangeEXT(buffer, offset, length, access);
    
    public z_FlushMappedNamedBufferRangeEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; offset: IntPtr; length: UIntPtr)>('glFlushMappedNamedBufferRangeEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedNamedBufferRangeEXT(buffer: UInt32; offset: IntPtr; length: UIntPtr) := z_FlushMappedNamedBufferRangeEXT(buffer, offset, length);
    
    {$endregion EXT_direct_state_access}
    
    {$region EXT_coordinate_frame}
    
    public z_Tangent3bEXT := GetGLFuncOrNil&<procedure(tx: SByte; ty: SByte; tz: SByte)>('glTangent3bEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bEXT(tx: SByte; ty: SByte; tz: SByte) := z_Tangent3bEXT(tx, ty, tz);
    
    public z_Tangent3sEXT := GetGLFuncOrNil&<procedure(tx: Int16; ty: Int16; tz: Int16)>('glTangent3sEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3sEXT(tx: Int16; ty: Int16; tz: Int16) := z_Tangent3sEXT(tx, ty, tz);
    
    public z_Tangent3iEXT := GetGLFuncOrNil&<procedure(tx: Int32; ty: Int32; tz: Int32)>('glTangent3iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3iEXT(tx: Int32; ty: Int32; tz: Int32) := z_Tangent3iEXT(tx, ty, tz);
    
    public z_Tangent3fEXT := GetGLFuncOrNil&<procedure(tx: single; ty: single; tz: single)>('glTangent3fEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fEXT(tx: single; ty: single; tz: single) := z_Tangent3fEXT(tx, ty, tz);
    
    public z_Tangent3dEXT := GetGLFuncOrNil&<procedure(tx: double; ty: double; tz: double)>('glTangent3dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dEXT(tx: double; ty: double; tz: double) := z_Tangent3dEXT(tx, ty, tz);
    
    public z_Tangent3bvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glTangent3bvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(v: array of SByte) := Tangent3bvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(var v: SByte) := Tangent3bvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(v: pointer) := z_Tangent3bvEXT(v);
    
    public z_Tangent3svEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glTangent3svEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(v: array of Int16) := Tangent3svEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(var v: Int16) := Tangent3svEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(v: pointer) := z_Tangent3svEXT(v);
    
    public z_Tangent3ivEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glTangent3ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(v: array of Int32) := Tangent3ivEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(var v: Int32) := Tangent3ivEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(v: pointer) := z_Tangent3ivEXT(v);
    
    public z_Tangent3fvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glTangent3fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(v: array of single) := Tangent3fvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(var v: single) := Tangent3fvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(v: pointer) := z_Tangent3fvEXT(v);
    
    public z_Tangent3dvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glTangent3dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(v: array of double) := Tangent3dvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(var v: double) := Tangent3dvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(v: pointer) := z_Tangent3dvEXT(v);
    
    public z_Binormal3bEXT := GetGLFuncOrNil&<procedure(bx: SByte; by: SByte; bz: SByte)>('glBinormal3bEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bEXT(bx: SByte; by: SByte; bz: SByte) := z_Binormal3bEXT(bx, by, bz);
    
    public z_Binormal3sEXT := GetGLFuncOrNil&<procedure(bx: Int16; by: Int16; bz: Int16)>('glBinormal3sEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3sEXT(bx: Int16; by: Int16; bz: Int16) := z_Binormal3sEXT(bx, by, bz);
    
    public z_Binormal3iEXT := GetGLFuncOrNil&<procedure(bx: Int32; by: Int32; bz: Int32)>('glBinormal3iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3iEXT(bx: Int32; by: Int32; bz: Int32) := z_Binormal3iEXT(bx, by, bz);
    
    public z_Binormal3fEXT := GetGLFuncOrNil&<procedure(bx: single; by: single; bz: single)>('glBinormal3fEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fEXT(bx: single; by: single; bz: single) := z_Binormal3fEXT(bx, by, bz);
    
    public z_Binormal3dEXT := GetGLFuncOrNil&<procedure(bx: double; by: double; bz: double)>('glBinormal3dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dEXT(bx: double; by: double; bz: double) := z_Binormal3dEXT(bx, by, bz);
    
    public z_Binormal3bvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glBinormal3bvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(v: array of SByte) := Binormal3bvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(var v: SByte) := Binormal3bvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(v: pointer) := z_Binormal3bvEXT(v);
    
    public z_Binormal3svEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glBinormal3svEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(v: array of Int16) := Binormal3svEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(var v: Int16) := Binormal3svEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(v: pointer) := z_Binormal3svEXT(v);
    
    public z_Binormal3ivEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glBinormal3ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(v: array of Int32) := Binormal3ivEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(var v: Int32) := Binormal3ivEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(v: pointer) := z_Binormal3ivEXT(v);
    
    public z_Binormal3fvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glBinormal3fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(v: array of single) := Binormal3fvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(var v: single) := Binormal3fvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(v: pointer) := z_Binormal3fvEXT(v);
    
    public z_Binormal3dvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glBinormal3dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(v: array of double) := Binormal3dvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(var v: double) := Binormal3dvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(v: pointer) := z_Binormal3dvEXT(v);
    
    public z_TangentPointerEXT := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>('glTangentPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TangentPointerEXT(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_TangentPointerEXT(&type, stride, _pointer);
    
    public z_BinormalPointerEXT := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>('glBinormalPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BinormalPointerEXT(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_BinormalPointerEXT(&type, stride, _pointer);
    
    {$endregion EXT_coordinate_frame}
    
    {$region EXT_blend_color}
    
    public z_BlendColorEXT := GetGLFuncOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>('glBlendColorEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColorEXT(red: single; green: single; blue: single; alpha: single) := z_BlendColorEXT(red, green, blue, alpha);
    
    {$endregion EXT_blend_color}
    
    {$region EXT_blend_minmax}
    
    public z_BlendEquationEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glBlendEquationEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationEXT(mode: DummyEnum) := z_BlendEquationEXT(mode);
    
    {$endregion EXT_blend_minmax}
    
    {$region EXT_draw_buffers_indexed}
    
    public z_EnableiEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32)>('glEnableiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableiEXT(target: DummyEnum; index: UInt32) := z_EnableiEXT(target, index);
    
    public z_DisableiEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32)>('glDisableiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableiEXT(target: DummyEnum; index: UInt32) := z_DisableiEXT(target, index);
    
    public z_BlendEquationiEXT := GetGLFuncOrNil&<procedure(buf: UInt32; mode: DummyEnum)>('glBlendEquationiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationiEXT(buf: UInt32; mode: DummyEnum) := z_BlendEquationiEXT(buf, mode);
    
    public z_BlendEquationSeparateiEXT := GetGLFuncOrNil&<procedure(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum)>('glBlendEquationSeparateiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateiEXT(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum) := z_BlendEquationSeparateiEXT(buf, modeRGB, modeAlpha);
    
    public z_BlendFunciEXT := GetGLFuncOrNil&<procedure(buf: UInt32; src: DummyEnum; dst: DummyEnum)>('glBlendFunciEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunciEXT(buf: UInt32; src: DummyEnum; dst: DummyEnum) := z_BlendFunciEXT(buf, src, dst);
    
    public z_BlendFuncSeparateiEXT := GetGLFuncOrNil&<procedure(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum)>('glBlendFuncSeparateiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateiEXT(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum) := z_BlendFuncSeparateiEXT(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    public z_ColorMaskiEXT := GetGLFuncOrNil&<procedure(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean)>('glColorMaskiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaskiEXT(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean) := z_ColorMaskiEXT(index, r, g, b, a);
    
    public z_IsEnablediEXT := GetGLFuncOrNil&<function(target: DummyEnum; index: UInt32): boolean>('glIsEnablediEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnablediEXT(target: DummyEnum; index: UInt32): boolean := z_IsEnablediEXT(target, index);
    
    {$endregion EXT_draw_buffers_indexed}
    
    {$region EXT_blend_equation_separate}
    
    public z_BlendEquationSeparateEXT := GetGLFuncOrNil&<procedure(modeRGB: DummyEnum; modeAlpha: DummyEnum)>('glBlendEquationSeparateEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateEXT(modeRGB: DummyEnum; modeAlpha: DummyEnum) := z_BlendEquationSeparateEXT(modeRGB, modeAlpha);
    
    {$endregion EXT_blend_equation_separate}
    
    {$region EXT_blend_func_separate}
    
    public z_BlendFuncSeparateEXT := GetGLFuncOrNil&<procedure(sfactorRGB: DummyEnum; dfactorRGB: DummyEnum; sfactorAlpha: DummyEnum; dfactorAlpha: DummyEnum)>('glBlendFuncSeparateEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateEXT(sfactorRGB: DummyEnum; dfactorRGB: DummyEnum; sfactorAlpha: DummyEnum; dfactorAlpha: DummyEnum) := z_BlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    
    {$endregion EXT_blend_func_separate}
    
    {$region EXT_framebuffer_blit}
    
    public z_BlitFramebufferEXT := GetGLFuncOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>('glBlitFramebufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebufferEXT(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := z_BlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    {$endregion EXT_framebuffer_blit}
    
    {$region ARB_sparse_buffer}
    
    public z_BufferPageCommitmentARB := GetGLFuncOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; commit: boolean)>('glBufferPageCommitmentARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferPageCommitmentARB(target: DummyEnum; offset: IntPtr; size: UIntPtr; commit: boolean) := z_BufferPageCommitmentARB(target, offset, size, commit);
    
    public z_NamedBufferPageCommitmentEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; offset: IntPtr; size: UIntPtr; commit: boolean)>('glNamedBufferPageCommitmentEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferPageCommitmentEXT(buffer: UInt32; offset: IntPtr; size: UIntPtr; commit: boolean) := z_NamedBufferPageCommitmentEXT(buffer, offset, size, commit);
    
    public z_NamedBufferPageCommitmentARB := GetGLFuncOrNil&<procedure(buffer: UInt32; offset: IntPtr; size: UIntPtr; commit: boolean)>('glNamedBufferPageCommitmentARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferPageCommitmentARB(buffer: UInt32; offset: IntPtr; size: UIntPtr; commit: boolean) := z_NamedBufferPageCommitmentARB(buffer, offset, size, commit);
    
    {$endregion ARB_sparse_buffer}
    
    {$region EXT_buffer_storage}
    
    public z_BufferStorageEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; size: UIntPtr; data: pointer; flags: DummyFlags)>('glBufferStorageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorageEXT(target: DummyEnum; size: UIntPtr; data: pointer; flags: DummyFlags) := z_BufferStorageEXT(target, size, data, flags);
    
    {$endregion EXT_buffer_storage}
    
    {$region EXT_external_buffer}
    
    public z_BufferStorageExternalEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: DummyFlags)>('glBufferStorageExternalEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorageExternalEXT(target: DummyEnum; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: DummyFlags) := z_BufferStorageExternalEXT(target, offset, size, clientBuffer, flags);
    
    public z_NamedBufferStorageExternalEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: DummyFlags)>('glNamedBufferStorageExternalEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageExternalEXT(buffer: UInt32; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: DummyFlags) := z_NamedBufferStorageExternalEXT(buffer, offset, size, clientBuffer, flags);
    
    {$endregion EXT_external_buffer}
    
    {$region EXT_external_objects}
    
    public z_GetUnsignedBytevEXT := GetGLFuncOrNil&<procedure(pname: DummyEnum; data: pointer)>('glGetUnsignedBytevEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: DummyEnum; data: array of Byte) := GetUnsignedBytevEXT(pname, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: DummyEnum; var data: Byte) := GetUnsignedBytevEXT(pname, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: DummyEnum; data: pointer) := z_GetUnsignedBytevEXT(pname, data);
    
    public z_GetUnsignedBytei_vEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; data: pointer)>('glGetUnsignedBytei_vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; data: array of Byte) := GetUnsignedBytei_vEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; var data: Byte) := GetUnsignedBytei_vEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; data: pointer) := z_GetUnsignedBytei_vEXT(target, index, data);
    
    public z_DeleteMemoryObjectsEXT := GetGLFuncOrNil&<procedure(n: Int32; memoryObjects: pointer)>('glDeleteMemoryObjectsEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; memoryObjects: array of UInt32) := DeleteMemoryObjectsEXT(n, memoryObjects[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; var memoryObjects: UInt32) := DeleteMemoryObjectsEXT(n, @memoryObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; memoryObjects: pointer) := z_DeleteMemoryObjectsEXT(n, memoryObjects);
    
    public z_IsMemoryObjectEXT := GetGLFuncOrNil&<function(memoryObject: UInt32): boolean>('glIsMemoryObjectEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsMemoryObjectEXT(memoryObject: UInt32): boolean := z_IsMemoryObjectEXT(memoryObject);
    
    public z_CreateMemoryObjectsEXT := GetGLFuncOrNil&<procedure(n: Int32; memoryObjects: pointer)>('glCreateMemoryObjectsEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; memoryObjects: array of UInt32) := CreateMemoryObjectsEXT(n, memoryObjects[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; var memoryObjects: UInt32) := CreateMemoryObjectsEXT(n, @memoryObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; memoryObjects: pointer) := z_CreateMemoryObjectsEXT(n, memoryObjects);
    
    public z_MemoryObjectParameterivEXT := GetGLFuncOrNil&<procedure(memoryObject: UInt32; pname: DummyEnum; &params: pointer)>('glMemoryObjectParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; &params: array of Int32) := MemoryObjectParameterivEXT(memoryObject, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; var &params: Int32) := MemoryObjectParameterivEXT(memoryObject, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; &params: pointer) := z_MemoryObjectParameterivEXT(memoryObject, pname, &params);
    
    public z_GetMemoryObjectParameterivEXT := GetGLFuncOrNil&<procedure(memoryObject: UInt32; pname: DummyEnum; &params: pointer)>('glGetMemoryObjectParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; &params: array of Int32) := GetMemoryObjectParameterivEXT(memoryObject, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; var &params: Int32) := GetMemoryObjectParameterivEXT(memoryObject, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; &params: pointer) := z_GetMemoryObjectParameterivEXT(memoryObject, pname, &params);
    
    public z_TexStorageMem2DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; memory: UInt32; offset: UInt64)>('glTexStorageMem2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem2DEXT(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; memory: UInt32; offset: UInt64) := z_TexStorageMem2DEXT(target, levels, internalFormat, width, height, memory, offset);
    
    public z_TexStorageMem2DMultisampleEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64)>('glTexStorageMem2DMultisampleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem2DMultisampleEXT(target: DummyEnum; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64) := z_TexStorageMem2DMultisampleEXT(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
    
    public z_TexStorageMem3DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64)>('glTexStorageMem3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem3DEXT(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64) := z_TexStorageMem3DEXT(target, levels, internalFormat, width, height, depth, memory, offset);
    
    public z_TexStorageMem3DMultisampleEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64)>('glTexStorageMem3DMultisampleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem3DMultisampleEXT(target: DummyEnum; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64) := z_TexStorageMem3DMultisampleEXT(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    
    public z_BufferStorageMemEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; size: UIntPtr; memory: UInt32; offset: UInt64)>('glBufferStorageMemEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorageMemEXT(target: DummyEnum; size: UIntPtr; memory: UInt32; offset: UInt64) := z_BufferStorageMemEXT(target, size, memory, offset);
    
    public z_TextureStorageMem2DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; memory: UInt32; offset: UInt64)>('glTextureStorageMem2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem2DEXT(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; memory: UInt32; offset: UInt64) := z_TextureStorageMem2DEXT(texture, levels, internalFormat, width, height, memory, offset);
    
    public z_TextureStorageMem2DMultisampleEXT := GetGLFuncOrNil&<procedure(texture: UInt32; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64)>('glTextureStorageMem2DMultisampleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem2DMultisampleEXT(texture: UInt32; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64) := z_TextureStorageMem2DMultisampleEXT(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
    
    public z_TextureStorageMem3DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64)>('glTextureStorageMem3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem3DEXT(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64) := z_TextureStorageMem3DEXT(texture, levels, internalFormat, width, height, depth, memory, offset);
    
    public z_TextureStorageMem3DMultisampleEXT := GetGLFuncOrNil&<procedure(texture: UInt32; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64)>('glTextureStorageMem3DMultisampleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem3DMultisampleEXT(texture: UInt32; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean; memory: UInt32; offset: UInt64) := z_TextureStorageMem3DMultisampleEXT(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    
    public z_NamedBufferStorageMemEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; size: UIntPtr; memory: UInt32; offset: UInt64)>('glNamedBufferStorageMemEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageMemEXT(buffer: UInt32; size: UIntPtr; memory: UInt32; offset: UInt64) := z_NamedBufferStorageMemEXT(buffer, size, memory, offset);
    
    public z_TexStorageMem1DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; memory: UInt32; offset: UInt64)>('glTexStorageMem1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem1DEXT(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; memory: UInt32; offset: UInt64) := z_TexStorageMem1DEXT(target, levels, internalFormat, width, memory, offset);
    
    public z_TextureStorageMem1DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; memory: UInt32; offset: UInt64)>('glTextureStorageMem1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem1DEXT(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; memory: UInt32; offset: UInt64) := z_TextureStorageMem1DEXT(texture, levels, internalFormat, width, memory, offset);
    
    public z_GenSemaphoresEXT := GetGLFuncOrNil&<procedure(n: Int32; semaphores: pointer)>('glGenSemaphoresEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; semaphores: array of UInt32) := GenSemaphoresEXT(n, semaphores[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; var semaphores: UInt32) := GenSemaphoresEXT(n, @semaphores);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; semaphores: pointer) := z_GenSemaphoresEXT(n, semaphores);
    
    public z_DeleteSemaphoresEXT := GetGLFuncOrNil&<procedure(n: Int32; semaphores: pointer)>('glDeleteSemaphoresEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; semaphores: array of UInt32) := DeleteSemaphoresEXT(n, semaphores[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; var semaphores: UInt32) := DeleteSemaphoresEXT(n, @semaphores);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; semaphores: pointer) := z_DeleteSemaphoresEXT(n, semaphores);
    
    public z_IsSemaphoreEXT := GetGLFuncOrNil&<function(semaphore: UInt32): boolean>('glIsSemaphoreEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSemaphoreEXT(semaphore: UInt32): boolean := z_IsSemaphoreEXT(semaphore);
    
    public z_SemaphoreParameterui64vEXT := GetGLFuncOrNil&<procedure(semaphore: UInt32; pname: DummyEnum; &params: pointer)>('glSemaphoreParameterui64vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; &params: array of UInt64) := SemaphoreParameterui64vEXT(semaphore, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; var &params: UInt64) := SemaphoreParameterui64vEXT(semaphore, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; &params: pointer) := z_SemaphoreParameterui64vEXT(semaphore, pname, &params);
    
    public z_GetSemaphoreParameterui64vEXT := GetGLFuncOrNil&<procedure(semaphore: UInt32; pname: DummyEnum; &params: pointer)>('glGetSemaphoreParameterui64vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; &params: array of UInt64) := GetSemaphoreParameterui64vEXT(semaphore, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; var &params: UInt64) := GetSemaphoreParameterui64vEXT(semaphore, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; &params: pointer) := z_GetSemaphoreParameterui64vEXT(semaphore, pname, &params);
    
    public z_WaitSemaphoreEXT := GetGLFuncOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; srcLayouts: pointer)>('glWaitSemaphoreEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; srcLayouts: pointer) := z_WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    
    public z_SignalSemaphoreEXT := GetGLFuncOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; dstLayouts: pointer)>('glSignalSemaphoreEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; dstLayouts: pointer) := z_SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    
    {$endregion EXT_external_objects}
    
    {$region EXT_texture_integer}
    
    public z_ClearColorIiEXT := GetGLFuncOrNil&<procedure(red: Int32; green: Int32; blue: Int32; alpha: Int32)>('glClearColorIiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorIiEXT(red: Int32; green: Int32; blue: Int32; alpha: Int32) := z_ClearColorIiEXT(red, green, blue, alpha);
    
    public z_ClearColorIuiEXT := GetGLFuncOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32)>('glClearColorIuiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorIuiEXT(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32) := z_ClearColorIuiEXT(red, green, blue, alpha);
    
    {$endregion EXT_texture_integer}
    
    {$region ARB_clear_buffer_object}
    
    public z_ClearNamedBufferDataEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; internalformat: DummyEnum; format: DummyEnum; &type: DummyEnum; data: pointer)>('glClearNamedBufferDataEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferDataEXT(buffer: UInt32; internalformat: DummyEnum; format: DummyEnum; &type: DummyEnum; data: pointer) := z_ClearNamedBufferDataEXT(buffer, internalformat, format, &type, data);
    
    public z_ClearNamedBufferSubDataEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; internalformat: DummyEnum; offset: UIntPtr; size: UIntPtr; format: DummyEnum; &type: DummyEnum; data: pointer)>('glClearNamedBufferSubDataEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearNamedBufferSubDataEXT(buffer: UInt32; internalformat: DummyEnum; offset: UIntPtr; size: UIntPtr; format: DummyEnum; &type: DummyEnum; data: pointer) := z_ClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, &type, data);
    
    {$endregion ARB_clear_buffer_object}
    
    {$region EXT_shader_pixel_local_storage2}
    
    public z_FramebufferPixelLocalStorageSizeEXT := GetGLFuncOrNil&<procedure(target: UInt32; size: Int32)>('glFramebufferPixelLocalStorageSizeEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferPixelLocalStorageSizeEXT(target: UInt32; size: Int32) := z_FramebufferPixelLocalStorageSizeEXT(target, size);
    
    public z_GetFramebufferPixelLocalStorageSizeEXT := GetGLFuncOrNil&<function(target: UInt32): Int32>('glGetFramebufferPixelLocalStorageSizeEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFramebufferPixelLocalStorageSizeEXT(target: UInt32): Int32 := z_GetFramebufferPixelLocalStorageSizeEXT(target);
    
    public z_ClearPixelLocalStorageuiEXT := GetGLFuncOrNil&<procedure(offset: Int32; n: Int32; values: pointer)>('glClearPixelLocalStorageuiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearPixelLocalStorageuiEXT(offset: Int32; n: Int32; values: array of UInt32) := ClearPixelLocalStorageuiEXT(offset, n, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearPixelLocalStorageuiEXT(offset: Int32; n: Int32; var values: UInt32) := ClearPixelLocalStorageuiEXT(offset, n, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearPixelLocalStorageuiEXT(offset: Int32; n: Int32; values: pointer) := z_ClearPixelLocalStorageuiEXT(offset, n, values);
    
    {$endregion EXT_shader_pixel_local_storage2}
    
    {$region EXT_clear_texture}
    
    public z_ClearTexImageEXT := GetGLFuncOrNil&<procedure(texture: UInt32; level: Int32; format: DummyEnum; &type: DummyEnum; data: pointer)>('glClearTexImageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexImageEXT(texture: UInt32; level: Int32; format: DummyEnum; &type: DummyEnum; data: pointer) := z_ClearTexImageEXT(texture, level, format, &type, data);
    
    public z_ClearTexSubImageEXT := GetGLFuncOrNil&<procedure(texture: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; data: pointer)>('glClearTexSubImageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearTexSubImageEXT(texture: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; data: pointer) := z_ClearTexSubImageEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, data);
    
    {$endregion EXT_clear_texture}
    
    {$region EXT_clip_control}
    
    public z_ClipControlEXT := GetGLFuncOrNil&<procedure(origin: DummyEnum; depth: DummyEnum)>('glClipControlEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipControlEXT(origin: DummyEnum; depth: DummyEnum) := z_ClipControlEXT(origin, depth);
    
    {$endregion EXT_clip_control}
    
    {$region EXT_draw_buffers2}
    
    public z_ColorMaskIndexedEXT := GetGLFuncOrNil&<procedure(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean)>('glColorMaskIndexedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaskIndexedEXT(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean) := z_ColorMaskIndexedEXT(index, r, g, b, a);
    
    {$endregion EXT_draw_buffers2}
    
    {$region EXT_color_subtable EXT_paletted_texture}
    
    public z_ColorSubTableEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; start: Int32; count: Int32; format: DummyEnum; &type: DummyEnum; data: pointer)>('glColorSubTableEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorSubTableEXT(target: DummyEnum; start: Int32; count: Int32; format: DummyEnum; &type: DummyEnum; data: pointer) := z_ColorSubTableEXT(target, start, count, format, &type, data);
    
    {$endregion EXT_color_subtable EXT_paletted_texture}
    
    {$region EXT_paletted_texture}
    
    public z_ColorTableEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; internalFormat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; table: pointer)>('glColorTableEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableEXT(target: DummyEnum; internalFormat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; table: pointer) := z_ColorTableEXT(target, internalFormat, width, format, &type, table);
    
    public z_GetColorTableEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; data: pointer)>('glGetColorTableEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableEXT(target: DummyEnum; format: DummyEnum; &type: DummyEnum; data: pointer) := z_GetColorTableEXT(target, format, &type, data);
    
    public z_GetColorTableParameterivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetColorTableParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetColorTableParameterivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetColorTableParameterivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetColorTableParameterivEXT(target, pname, &params);
    
    public z_GetColorTableParameterfvEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetColorTableParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetColorTableParameterfvEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) := GetColorTableParameterfvEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetColorTableParameterfvEXT(target, pname, &params);
    
    {$endregion EXT_paletted_texture}
    
    {$region EXT_convolution}
    
    public z_ConvolutionFilter1DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; image: pointer)>('glConvolutionFilter1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter1DEXT(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; image: pointer) := z_ConvolutionFilter1DEXT(target, internalformat, width, format, &type, image);
    
    public z_ConvolutionFilter2DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; image: pointer)>('glConvolutionFilter2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter2DEXT(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; image: pointer) := z_ConvolutionFilter2DEXT(target, internalformat, width, height, format, &type, image);
    
    public z_CopyConvolutionFilter1DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32)>('glCopyConvolutionFilter1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter1DEXT(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32) := z_CopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
    
    public z_CopyConvolutionFilter2DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyConvolutionFilter2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter2DEXT(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
    
    public z_GetConvolutionFilterEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; image: pointer)>('glGetConvolutionFilterEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionFilterEXT(target: DummyEnum; format: DummyEnum; &type: DummyEnum; image: pointer) := z_GetConvolutionFilterEXT(target, format, &type, image);
    
    public z_SeparableFilter2DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer)>('glSeparableFilter2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SeparableFilter2DEXT(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer) := z_SeparableFilter2DEXT(target, internalformat, width, height, format, &type, row, column);
    
    public z_GetSeparableFilterEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer; span: pointer)>('glGetSeparableFilterEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSeparableFilterEXT(target: DummyEnum; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer; span: pointer) := z_GetSeparableFilterEXT(target, format, &type, row, column, span);
    
    public z_ConvolutionParameteriEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: Int32)>('glConvolutionParameteriEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriEXT(target: DummyEnum; pname: DummyEnum; &params: Int32) := z_ConvolutionParameteriEXT(target, pname, &params);
    
    public z_ConvolutionParameterivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glConvolutionParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := ConvolutionParameterivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := ConvolutionParameterivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ConvolutionParameterivEXT(target, pname, &params);
    
    public z_ConvolutionParameterfEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: single)>('glConvolutionParameterfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfEXT(target: DummyEnum; pname: DummyEnum; &params: single) := z_ConvolutionParameterfEXT(target, pname, &params);
    
    public z_ConvolutionParameterfvEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glConvolutionParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: array of single) := ConvolutionParameterfvEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) := ConvolutionParameterfvEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ConvolutionParameterfvEXT(target, pname, &params);
    
    public z_GetConvolutionParameterivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetConvolutionParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetConvolutionParameterivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetConvolutionParameterivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetConvolutionParameterivEXT(target, pname, &params);
    
    public z_GetConvolutionParameterfvEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetConvolutionParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetConvolutionParameterfvEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) := GetConvolutionParameterfvEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetConvolutionParameterfvEXT(target, pname, &params);
    
    {$endregion EXT_convolution}
    
    {$region EXT_color_subtable}
    
    public z_CopyColorSubTableEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; start: Int32; x: Int32; y: Int32; width: Int32)>('glCopyColorSubTableEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorSubTableEXT(target: DummyEnum; start: Int32; x: Int32; y: Int32; width: Int32) := z_CopyColorSubTableEXT(target, start, x, y, width);
    
    {$endregion EXT_color_subtable}
    
    {$region EXT_copy_image}
    
    public z_CopyImageSubDataEXT := GetGLFuncOrNil&<procedure(srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>('glCopyImageSubDataEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubDataEXT(srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) := z_CopyImageSubDataEXT(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
    {$endregion EXT_copy_image}
    
    {$region EXT_copy_texture}
    
    public z_CopyTexImage1DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32)>('glCopyTexImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage1DEXT(target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32) := z_CopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
    
    public z_CopyTexImage2DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>('glCopyTexImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexImage2DEXT(target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) := z_CopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
    
    public z_CopyTexSubImage1DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>('glCopyTexSubImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage1DEXT(target: DummyEnum; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) := z_CopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
    
    public z_CopyTexSubImage2DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyTexSubImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage2DEXT(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
    
    public z_CopyTexSubImage3DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyTexSubImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage3DEXT(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    {$endregion EXT_copy_texture}
    
    {$region EXT_depth_bounds_test}
    
    public z_DepthBoundsEXT := GetGLFuncOrNil&<procedure(zmin: double; zmax: double)>('glDepthBoundsEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthBoundsEXT(zmin: double; zmax: double) := z_DepthBoundsEXT(zmin, zmax);
    
    {$endregion EXT_depth_bounds_test}
    
    {$region ARB_viewport_array EXT_direct_state_access EXT_draw_buffers2}
    
    public z_EnableIndexedEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32)>('glEnableIndexedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableIndexedEXT(target: DummyEnum; index: UInt32) := z_EnableIndexedEXT(target, index);
    
    public z_DisableIndexedEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32)>('glDisableIndexedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableIndexedEXT(target: DummyEnum; index: UInt32) := z_DisableIndexedEXT(target, index);
    
    public z_IsEnabledIndexedEXT := GetGLFuncOrNil&<function(target: DummyEnum; index: UInt32): boolean>('glIsEnabledIndexedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledIndexedEXT(target: DummyEnum; index: UInt32): boolean := z_IsEnabledIndexedEXT(target, index);
    
    {$endregion ARB_viewport_array EXT_direct_state_access EXT_draw_buffers2}
    
    {$region EXT_discard_framebuffer}
    
    public z_DiscardFramebufferEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; numAttachments: Int32; attachments: pointer)>('glDiscardFramebufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DiscardFramebufferEXT(target: DummyEnum; numAttachments: Int32; attachments: array of DummyEnum) := DiscardFramebufferEXT(target, numAttachments, attachments[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DiscardFramebufferEXT(target: DummyEnum; numAttachments: Int32; var attachments: DummyEnum) := DiscardFramebufferEXT(target, numAttachments, @attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DiscardFramebufferEXT(target: DummyEnum; numAttachments: Int32; attachments: pointer) := z_DiscardFramebufferEXT(target, numAttachments, attachments);
    
    {$endregion EXT_discard_framebuffer}
    
    {$region EXT_base_instance}
    
    public z_DrawArraysInstancedBaseInstanceEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32)>('glDrawArraysInstancedBaseInstanceEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedBaseInstanceEXT(mode: DummyEnum; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32) := z_DrawArraysInstancedBaseInstanceEXT(mode, first, count, instancecount, baseinstance);
    
    public z_DrawElementsInstancedBaseInstanceEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; instancecount: Int32; baseinstance: UInt32)>('glDrawElementsInstancedBaseInstanceEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseInstanceEXT(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; instancecount: Int32; baseinstance: UInt32) := z_DrawElementsInstancedBaseInstanceEXT(mode, count, &type, indices, instancecount, baseinstance);
    
    public z_DrawElementsInstancedBaseVertexBaseInstanceEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; instancecount: Int32; basevertex: Int32; baseinstance: UInt32)>('glDrawElementsInstancedBaseVertexBaseInstanceEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexBaseInstanceEXT(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; instancecount: Int32; basevertex: Int32; baseinstance: UInt32) := z_DrawElementsInstancedBaseVertexBaseInstanceEXT(mode, count, &type, indices, instancecount, basevertex, baseinstance);
    
    {$endregion EXT_base_instance}
    
    {$region EXT_draw_instanced EXT_instanced_arrays}
    
    public z_DrawArraysInstancedEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; start: Int32; count: Int32; primcount: Int32)>('glDrawArraysInstancedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedEXT(mode: DummyEnum; start: Int32; count: Int32; primcount: Int32) := z_DrawArraysInstancedEXT(mode, start, count, primcount);
    
    public z_DrawElementsInstancedEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32)>('glDrawElementsInstancedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedEXT(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32) := z_DrawElementsInstancedEXT(mode, count, &type, indices, primcount);
    
    {$endregion EXT_draw_instanced EXT_instanced_arrays}
    
    {$region EXT_draw_buffers}
    
    public z_DrawBuffersEXT := GetGLFuncOrNil&<procedure(n: Int32; bufs: pointer)>('glDrawBuffersEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersEXT(n: Int32; bufs: array of DummyEnum) := DrawBuffersEXT(n, bufs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersEXT(n: Int32; var bufs: DummyEnum) := DrawBuffersEXT(n, @bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersEXT(n: Int32; bufs: pointer) := z_DrawBuffersEXT(n, bufs);
    
    {$endregion EXT_draw_buffers}
    
    {$region EXT_multiview_draw_buffers}
    
    public z_ReadBufferIndexedEXT := GetGLFuncOrNil&<procedure(src: DummyEnum; index: Int32)>('glReadBufferIndexedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadBufferIndexedEXT(src: DummyEnum; index: Int32) := z_ReadBufferIndexedEXT(src, index);
    
    public z_DrawBuffersIndexedEXT := GetGLFuncOrNil&<procedure(n: Int32; location: pointer; indices: pointer)>('glDrawBuffersIndexedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: array of DummyEnum; indices: array of Int32) := DrawBuffersIndexedEXT(n, location[0], indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: array of DummyEnum; var indices: Int32) := DrawBuffersIndexedEXT(n, location[0], @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: array of DummyEnum; indices: pointer) := DrawBuffersIndexedEXT(n, location[0], indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; var location: DummyEnum; indices: array of Int32) := DrawBuffersIndexedEXT(n, @location, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; var location: DummyEnum; var indices: Int32) := DrawBuffersIndexedEXT(n, @location, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; var location: DummyEnum; indices: pointer) := DrawBuffersIndexedEXT(n, @location, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: pointer; indices: array of Int32) := DrawBuffersIndexedEXT(n, location, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: pointer; var indices: Int32) := DrawBuffersIndexedEXT(n, location, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: pointer; indices: pointer) := z_DrawBuffersIndexedEXT(n, location, indices);
    
    public z_GetIntegeri_vEXT := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetIntegeri_vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_vEXT(target: GLGetQueries; index: UInt32; data: array of Int32) := GetIntegeri_vEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_vEXT(target: GLGetQueries; index: UInt32; var data: Int32) := GetIntegeri_vEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegeri_vEXT(target: GLGetQueries; index: UInt32; data: pointer) := z_GetIntegeri_vEXT(target, index, data);
    
    {$endregion EXT_multiview_draw_buffers}
    
    {$region EXT_draw_elements_base_vertex}
    
    public z_DrawElementsBaseVertexEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; basevertex: Int32)>('glDrawElementsBaseVertexEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertexEXT(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; basevertex: Int32) := z_DrawElementsBaseVertexEXT(mode, count, &type, indices, basevertex);
    
    public z_DrawRangeElementsBaseVertexEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; start: UInt32; &end: UInt32; count: Int32; &type: DummyEnum; indices: pointer; basevertex: Int32)>('glDrawRangeElementsBaseVertexEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertexEXT(mode: DummyEnum; start: UInt32; &end: UInt32; count: Int32; &type: DummyEnum; indices: pointer; basevertex: Int32) := z_DrawRangeElementsBaseVertexEXT(mode, start, &end, count, &type, indices, basevertex);
    
    public z_DrawElementsInstancedBaseVertexEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; instancecount: Int32; basevertex: Int32)>('glDrawElementsInstancedBaseVertexEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexEXT(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; instancecount: Int32; basevertex: Int32) := z_DrawElementsInstancedBaseVertexEXT(mode, count, &type, indices, instancecount, basevertex);
    
    {$endregion EXT_draw_elements_base_vertex}
    
    {$region EXT_draw_range_elements}
    
    public z_DrawRangeElementsEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; start: UInt32; &end: UInt32; count: Int32; &type: DummyEnum; indices: pointer)>('glDrawRangeElementsEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsEXT(mode: DummyEnum; start: UInt32; &end: UInt32; count: Int32; &type: DummyEnum; indices: pointer) := z_DrawRangeElementsEXT(mode, start, &end, count, &type, indices);
    
    {$endregion EXT_draw_range_elements}
    
    {$region EXT_draw_transform_feedback EXT_transform_feedback2}
    
    public z_DrawTransformFeedbackEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; id: UInt32)>('glDrawTransformFeedbackEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackEXT(mode: DummyEnum; id: UInt32) := z_DrawTransformFeedbackEXT(mode, id);
    
    {$endregion EXT_draw_transform_feedback EXT_transform_feedback2}
    
    {$region EXT_draw_transform_feedback}
    
    public z_DrawTransformFeedbackInstancedEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; id: UInt32; instancecount: Int32)>('glDrawTransformFeedbackInstancedEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackInstancedEXT(mode: DummyEnum; id: UInt32; instancecount: Int32) := z_DrawTransformFeedbackInstancedEXT(mode, id, instancecount);
    
    {$endregion EXT_draw_transform_feedback}
    
    {$region EXT_EGL_image_storage}
    
    public z_EGLImageTargetTexStorageEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; image: GLeglImageOES; attrib_list: pointer)>('glEGLImageTargetTexStorageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: GLeglImageOES; attrib_list: array of Int32) := EGLImageTargetTexStorageEXT(target, image, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: GLeglImageOES; var attrib_list: Int32) := EGLImageTargetTexStorageEXT(target, image, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: GLeglImageOES; attrib_list: pointer) := z_EGLImageTargetTexStorageEXT(target, image, attrib_list);
    
    public z_EGLImageTargetTextureStorageEXT := GetGLFuncOrNil&<procedure(texture: UInt32; image: GLeglImageOES; attrib_list: pointer)>('glEGLImageTargetTextureStorageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: UInt32; image: GLeglImageOES; attrib_list: array of Int32) := EGLImageTargetTextureStorageEXT(texture, image, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: UInt32; image: GLeglImageOES; var attrib_list: Int32) := EGLImageTargetTextureStorageEXT(texture, image, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: UInt32; image: GLeglImageOES; attrib_list: pointer) := z_EGLImageTargetTextureStorageEXT(texture, image, attrib_list);
    
    {$endregion EXT_EGL_image_storage}
    
    {$region EXT_map_buffer_range}
    
    public z_MapBufferRangeEXT := GetGLFuncOrNil&<function(target: DummyEnum; offset: IntPtr; length: UIntPtr; access: DummyFlags): pointer>('glMapBufferRangeEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBufferRangeEXT(target: DummyEnum; offset: IntPtr; length: UIntPtr; access: DummyFlags): pointer := z_MapBufferRangeEXT(target, offset, length, access);
    
    public z_FlushMappedBufferRangeEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; offset: IntPtr; length: UIntPtr)>('glFlushMappedBufferRangeEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedBufferRangeEXT(target: DummyEnum; offset: IntPtr; length: UIntPtr) := z_FlushMappedBufferRangeEXT(target, offset, length);
    
    {$endregion EXT_map_buffer_range}
    
    {$region EXT_fog_coord}
    
    public z_FogCoordfEXT := GetGLFuncOrNil&<procedure(coord: single)>('glFogCoordfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfEXT(coord: single) := z_FogCoordfEXT(coord);
    
    public z_FogCoorddEXT := GetGLFuncOrNil&<procedure(coord: double)>('glFogCoorddEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddEXT(coord: double) := z_FogCoorddEXT(coord);
    
    public z_FogCoordfvEXT := GetGLFuncOrNil&<procedure(coord: pointer)>('glFogCoordfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfvEXT(coord: array of single) := FogCoordfvEXT(coord[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfvEXT(var coord: single) := FogCoordfvEXT(@coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfvEXT(coord: pointer) := z_FogCoordfvEXT(coord);
    
    public z_FogCoorddvEXT := GetGLFuncOrNil&<procedure(coord: pointer)>('glFogCoorddvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddvEXT(coord: array of double) := FogCoorddvEXT(coord[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddvEXT(var coord: double) := FogCoorddvEXT(@coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddvEXT(coord: pointer) := z_FogCoorddvEXT(coord);
    
    public z_FogCoordPointerEXT := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>('glFogCoordPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerEXT(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_FogCoordPointerEXT(&type, stride, _pointer);
    
    {$endregion EXT_fog_coord}
    
    {$region EXT_shader_framebuffer_fetch}
    
    public z_FramebufferFetchBarrierEXT := GetGLFuncOrNil&<procedure>('glFramebufferFetchBarrierEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFetchBarrierEXT := z_FramebufferFetchBarrierEXT;
    
    {$endregion EXT_shader_framebuffer_fetch}
    
    {$region EXT_multisampled_render_to_texture}
    
    public z_FramebufferTexture2DMultisampleEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; samples: Int32)>('glFramebufferTexture2DMultisampleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2DMultisampleEXT(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; samples: Int32) := z_FramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);
    
    {$endregion EXT_multisampled_render_to_texture}
    
    {$region EXT_geometry_shader EXT_geometry_shader4 NV_geometry_program4}
    
    public z_FramebufferTextureEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32)>('glFramebufferTextureEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureEXT(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32) := z_FramebufferTextureEXT(target, attachment, texture, level);
    
    {$endregion EXT_geometry_shader EXT_geometry_shader4 NV_geometry_program4}
    
    {$region EXT_geometry_shader4 NV_geometry_program4}
    
    public z_FramebufferTextureFaceEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum)>('glFramebufferTextureFaceEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureFaceEXT(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum) := z_FramebufferTextureFaceEXT(target, attachment, texture, level, face);
    
    {$endregion EXT_geometry_shader4 NV_geometry_program4}
    
    {$region EXT_geometry_shader4 EXT_texture_array NV_geometry_program4}
    
    public z_FramebufferTextureLayerEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32)>('glFramebufferTextureLayerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayerEXT(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32) := z_FramebufferTextureLayerEXT(target, attachment, texture, level, layer);
    
    {$endregion EXT_geometry_shader4 EXT_texture_array NV_geometry_program4}
    
    {$region EXT_direct_state_access EXT_draw_buffers2 EXT_transform_feedback NV_explicit_multisample NV_transform_feedback}
    
    public z_GetBooleanIndexedvEXT := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetBooleanIndexedvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: GLGetQueries; index: UInt32; data: array of boolean) := GetBooleanIndexedvEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: GLGetQueries; index: UInt32; var data: boolean) := GetBooleanIndexedvEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: GLGetQueries; index: UInt32; data: pointer) := z_GetBooleanIndexedvEXT(target, index, data);
    
    {$endregion EXT_direct_state_access EXT_draw_buffers2 EXT_transform_feedback NV_explicit_multisample NV_transform_feedback}
    
    {$region EXT_gpu_shader4}
    
    public z_Uniform1uiEXT := GetGLFuncOrNil&<procedure(location: Int32; v0: UInt32)>('glUniform1uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uiEXT(location: Int32; v0: UInt32) := z_Uniform1uiEXT(location, v0);
    
    public z_Uniform2uiEXT := GetGLFuncOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32)>('glUniform2uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uiEXT(location: Int32; v0: UInt32; v1: UInt32) := z_Uniform2uiEXT(location, v0, v1);
    
    public z_Uniform3uiEXT := GetGLFuncOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>('glUniform3uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uiEXT(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) := z_Uniform3uiEXT(location, v0, v1, v2);
    
    public z_Uniform4uiEXT := GetGLFuncOrNil&<procedure(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>('glUniform4uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uiEXT(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) := z_Uniform4uiEXT(location, v0, v1, v2, v3);
    
    public z_Uniform1uivEXT := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uivEXT(location: Int32; count: Int32; value: array of UInt32) := Uniform1uivEXT(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uivEXT(location: Int32; count: Int32; var value: UInt32) := Uniform1uivEXT(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1uivEXT(location: Int32; count: Int32; value: pointer) := z_Uniform1uivEXT(location, count, value);
    
    public z_Uniform2uivEXT := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; value: array of UInt32) := Uniform2uivEXT(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; var value: UInt32) := Uniform2uivEXT(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2uivEXT(location: Int32; count: Int32; value: pointer) := z_Uniform2uivEXT(location, count, value);
    
    public z_Uniform3uivEXT := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; value: array of UInt32) := Uniform3uivEXT(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; var value: UInt32) := Uniform3uivEXT(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3uivEXT(location: Int32; count: Int32; value: pointer) := z_Uniform3uivEXT(location, count, value);
    
    public z_Uniform4uivEXT := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; value: array of UInt32) := Uniform4uivEXT(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; var value: UInt32) := Uniform4uivEXT(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4uivEXT(location: Int32; count: Int32; value: pointer) := z_Uniform4uivEXT(location, count, value);
    
    public z_GetUniformuivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; &params: pointer)>('glGetUniformuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuivEXT(&program: UInt32; location: Int32; &params: array of UInt32) := GetUniformuivEXT(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuivEXT(&program: UInt32; location: Int32; var &params: UInt32) := GetUniformuivEXT(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformuivEXT(&program: UInt32; location: Int32; &params: pointer) := z_GetUniformuivEXT(&program, location, &params);
    
    public z_GetFragDataLocationEXT := GetGLFuncOrNil&<function(&program: UInt32; name: IntPtr): Int32>('glGetFragDataLocationEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocationEXT(&program: UInt32; name: string): Int32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); Result := GetFragDataLocationEXT(&program, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFragDataLocationEXT(&program: UInt32; name: IntPtr): Int32 := z_GetFragDataLocationEXT(&program, name);
    
    {$endregion EXT_gpu_shader4}
    
    {$region EXT_robustness}
    
    public z_GetGraphicsResetStatusEXT := GetGLFuncOrNil&<function: DummyEnum>('glGetGraphicsResetStatusEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGraphicsResetStatusEXT: DummyEnum := z_GetGraphicsResetStatusEXT;
    
    public z_ReadnPixelsEXT := GetGLFuncOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; bufSize: Int32; data: pointer)>('glReadnPixelsEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixelsEXT(x: Int32; y: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; bufSize: Int32; data: pointer) := z_ReadnPixelsEXT(x, y, width, height, format, &type, bufSize, data);
    
    public z_GetnUniformfvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvEXT(&program: UInt32; location: Int32; bufSize: Int32; &params: array of single) := GetnUniformfvEXT(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvEXT(&program: UInt32; location: Int32; bufSize: Int32; var &params: single) := GetnUniformfvEXT(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvEXT(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformfvEXT(&program, location, bufSize, &params);
    
    public z_GetnUniformivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivEXT(&program: UInt32; location: Int32; bufSize: Int32; &params: array of Int32) := GetnUniformivEXT(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivEXT(&program: UInt32; location: Int32; bufSize: Int32; var &params: Int32) := GetnUniformivEXT(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivEXT(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformivEXT(&program, location, bufSize, &params);
    
    {$endregion EXT_robustness}
    
    {$region EXT_histogram}
    
    public z_HistogramEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; width: Int32; internalformat: DummyEnum; sink: boolean)>('glHistogramEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure HistogramEXT(target: DummyEnum; width: Int32; internalformat: DummyEnum; sink: boolean) := z_HistogramEXT(target, width, internalformat, sink);
    
    public z_ResetHistogramEXT := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glResetHistogramEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetHistogramEXT(target: DummyEnum) := z_ResetHistogramEXT(target);
    
    public z_GetHistogramEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; values: pointer)>('glGetHistogramEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramEXT(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; values: pointer) := z_GetHistogramEXT(target, reset, format, &type, values);
    
    public z_GetHistogramParameterivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetHistogramParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetHistogramParameterivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetHistogramParameterivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetHistogramParameterivEXT(target, pname, &params);
    
    public z_GetHistogramParameterfvEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetHistogramParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetHistogramParameterfvEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) := GetHistogramParameterfvEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetHistogramParameterfvEXT(target, pname, &params);
    
    public z_MinmaxEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; sink: boolean)>('glMinmaxEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MinmaxEXT(target: DummyEnum; internalformat: DummyEnum; sink: boolean) := z_MinmaxEXT(target, internalformat, sink);
    
    public z_ResetMinmaxEXT := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glResetMinmaxEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMinmaxEXT(target: DummyEnum) := z_ResetMinmaxEXT(target);
    
    public z_GetMinmaxEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; values: pointer)>('glGetMinmaxEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxEXT(target: DummyEnum; reset: boolean; format: DummyEnum; &type: DummyEnum; values: pointer) := z_GetMinmaxEXT(target, reset, format, &type, values);
    
    public z_GetMinmaxParameterivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMinmaxParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMinmaxParameterivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMinmaxParameterivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMinmaxParameterivEXT(target, pname, &params);
    
    public z_GetMinmaxParameterfvEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMinmaxParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetMinmaxParameterfvEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) := GetMinmaxParameterfvEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMinmaxParameterfvEXT(target, pname, &params);
    
    {$endregion EXT_histogram}
    
    {$region ARB_viewport_array EXT_direct_state_access EXT_draw_buffers2 EXT_transform_feedback NV_explicit_multisample NV_parameter_buffer_object NV_transform_feedback}
    
    public z_GetIntegerIndexedvEXT := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetIntegerIndexedvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: GLGetQueries; index: UInt32; data: array of Int32) := GetIntegerIndexedvEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: GLGetQueries; index: UInt32; var data: Int32) := GetIntegerIndexedvEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: GLGetQueries; index: UInt32; data: pointer) := z_GetIntegerIndexedvEXT(target, index, data);
    
    {$endregion ARB_viewport_array EXT_direct_state_access EXT_draw_buffers2 EXT_transform_feedback NV_explicit_multisample NV_parameter_buffer_object NV_transform_feedback}
    
    {$region ARB_framebuffer_no_attachments}
    
    public z_NamedFramebufferParameteriEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; pname: DummyEnum; param: Int32)>('glNamedFramebufferParameteriEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferParameteriEXT(framebuffer: UInt32; pname: DummyEnum; param: Int32) := z_NamedFramebufferParameteriEXT(framebuffer, pname, param);
    
    public z_GetNamedFramebufferParameterivEXT := GetGLFuncOrNil&<procedure(framebuffer: UInt32; pname: DummyEnum; &params: pointer)>('glGetNamedFramebufferParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterivEXT(framebuffer: UInt32; pname: DummyEnum; &params: array of Int32) := GetNamedFramebufferParameterivEXT(framebuffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterivEXT(framebuffer: UInt32; pname: DummyEnum; var &params: Int32) := GetNamedFramebufferParameterivEXT(framebuffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterivEXT(framebuffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetNamedFramebufferParameterivEXT(framebuffer, pname, &params);
    
    {$endregion ARB_framebuffer_no_attachments}
    
    {$region EXT_debug_label}
    
    public z_LabelObjectEXT := GetGLFuncOrNil&<procedure(&type: DummyEnum; object: UInt32; length: Int32; &label: IntPtr)>('glLabelObjectEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LabelObjectEXT(&type: DummyEnum; object: UInt32; length: Int32; &label: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(&label); LabelObjectEXT(&type, object, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LabelObjectEXT(&type: DummyEnum; object: UInt32; length: Int32; &label: IntPtr) := z_LabelObjectEXT(&type, object, length, &label);
    
    public z_GetObjectLabelEXT := GetGLFuncOrNil&<procedure(&type: DummyEnum; object: UInt32; bufSize: Int32; length: pointer; &label: IntPtr)>('glGetObjectLabelEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelEXT(&type: DummyEnum; object: UInt32; bufSize: Int32; length: array of Int32; &label: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(&label); GetObjectLabelEXT(&type, object, bufSize, length[0], ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelEXT(&type: DummyEnum; object: UInt32; bufSize: Int32; length: array of Int32; &label: IntPtr) := GetObjectLabelEXT(&type, object, bufSize, length[0], &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelEXT(&type: DummyEnum; object: UInt32; bufSize: Int32; var length: Int32; &label: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(&label); GetObjectLabelEXT(&type, object, bufSize, @length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelEXT(&type: DummyEnum; object: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr) := GetObjectLabelEXT(&type, object, bufSize, @length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelEXT(&type: DummyEnum; object: UInt32; bufSize: Int32; length: pointer; &label: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(&label); GetObjectLabelEXT(&type, object, bufSize, length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelEXT(&type: DummyEnum; object: UInt32; bufSize: Int32; length: pointer; &label: IntPtr) := z_GetObjectLabelEXT(&type, object, bufSize, length, &label);
    
    {$endregion EXT_debug_label}
    
    {$region EXT_pixel_transform}
    
    public z_PixelTransformParameteriEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>('glPixelTransformParameteriEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameteriEXT(target: DummyEnum; pname: DummyEnum; param: Int32) := z_PixelTransformParameteriEXT(target, pname, param);
    
    public z_PixelTransformParameterfEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: single)>('glPixelTransformParameterfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfEXT(target: DummyEnum; pname: DummyEnum; param: single) := z_PixelTransformParameterfEXT(target, pname, param);
    
    public z_PixelTransformParameterivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glPixelTransformParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := PixelTransformParameterivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := PixelTransformParameterivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_PixelTransformParameterivEXT(target, pname, &params);
    
    public z_PixelTransformParameterfvEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glPixelTransformParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: array of single) := PixelTransformParameterfvEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) := PixelTransformParameterfvEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_PixelTransformParameterfvEXT(target, pname, &params);
    
    public z_GetPixelTransformParameterivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetPixelTransformParameterivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetPixelTransformParameterivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetPixelTransformParameterivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetPixelTransformParameterivEXT(target, pname, &params);
    
    public z_GetPixelTransformParameterfvEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetPixelTransformParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetPixelTransformParameterfvEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) := GetPixelTransformParameterfvEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetPixelTransformParameterfvEXT(target, pname, &params);
    
    {$endregion EXT_pixel_transform}
    
    {$region EXT_disjoint_timer_query EXT_timer_query}
    
    public z_GetQueryObjecti64vEXT := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetQueryObjecti64vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64vEXT(id: UInt32; pname: DummyEnum; &params: array of Int64) := GetQueryObjecti64vEXT(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64vEXT(id: UInt32; pname: DummyEnum; var &params: Int64) := GetQueryObjecti64vEXT(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjecti64vEXT(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetQueryObjecti64vEXT(id, pname, &params);
    
    public z_GetQueryObjectui64vEXT := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetQueryObjectui64vEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64vEXT(id: UInt32; pname: DummyEnum; &params: array of UInt64) := GetQueryObjectui64vEXT(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64vEXT(id: UInt32; pname: DummyEnum; var &params: UInt64) := GetQueryObjectui64vEXT(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectui64vEXT(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetQueryObjectui64vEXT(id, pname, &params);
    
    {$endregion EXT_disjoint_timer_query EXT_timer_query}
    
    {$region EXT_disjoint_timer_query}
    
    public z_QueryCounterEXT := GetGLFuncOrNil&<procedure(id: UInt32; target: DummyEnum)>('glQueryCounterEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryCounterEXT(id: UInt32; target: DummyEnum) := z_QueryCounterEXT(id, target);
    
    public z_GetQueryObjectivEXT := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetQueryObjectivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectivEXT(id: UInt32; pname: DummyEnum; &params: array of Int32) := GetQueryObjectivEXT(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectivEXT(id: UInt32; pname: DummyEnum; var &params: Int32) := GetQueryObjectivEXT(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetQueryObjectivEXT(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetQueryObjectivEXT(id, pname, &params);
    
    {$endregion EXT_disjoint_timer_query}
    
    {$region EXT_texture_border_clamp}
    
    public z_SamplerParameterIivEXT := GetGLFuncOrNil&<procedure(sampler: UInt32; pname: DummyEnum; param: pointer)>('glSamplerParameterIivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIivEXT(sampler: UInt32; pname: DummyEnum; param: array of Int32) := SamplerParameterIivEXT(sampler, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIivEXT(sampler: UInt32; pname: DummyEnum; var param: Int32) := SamplerParameterIivEXT(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIivEXT(sampler: UInt32; pname: DummyEnum; param: pointer) := z_SamplerParameterIivEXT(sampler, pname, param);
    
    public z_SamplerParameterIuivEXT := GetGLFuncOrNil&<procedure(sampler: UInt32; pname: DummyEnum; param: pointer)>('glSamplerParameterIuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuivEXT(sampler: UInt32; pname: DummyEnum; param: array of UInt32) := SamplerParameterIuivEXT(sampler, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuivEXT(sampler: UInt32; pname: DummyEnum; var param: UInt32) := SamplerParameterIuivEXT(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuivEXT(sampler: UInt32; pname: DummyEnum; param: pointer) := z_SamplerParameterIuivEXT(sampler, pname, param);
    
    public z_GetSamplerParameterIivEXT := GetGLFuncOrNil&<procedure(sampler: UInt32; pname: DummyEnum; &params: pointer)>('glGetSamplerParameterIivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIivEXT(sampler: UInt32; pname: DummyEnum; &params: array of Int32) := GetSamplerParameterIivEXT(sampler, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIivEXT(sampler: UInt32; pname: DummyEnum; var &params: Int32) := GetSamplerParameterIivEXT(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIivEXT(sampler: UInt32; pname: DummyEnum; &params: pointer) := z_GetSamplerParameterIivEXT(sampler, pname, &params);
    
    public z_GetSamplerParameterIuivEXT := GetGLFuncOrNil&<procedure(sampler: UInt32; pname: DummyEnum; &params: pointer)>('glGetSamplerParameterIuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuivEXT(sampler: UInt32; pname: DummyEnum; &params: array of UInt32) := GetSamplerParameterIuivEXT(sampler, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuivEXT(sampler: UInt32; pname: DummyEnum; var &params: UInt32) := GetSamplerParameterIuivEXT(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuivEXT(sampler: UInt32; pname: DummyEnum; &params: pointer) := z_GetSamplerParameterIuivEXT(sampler, pname, &params);
    
    {$endregion EXT_texture_border_clamp}
    
    {$region EXT_texture_border_clamp EXT_texture_integer}
    
    public z_TexParameterIivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTexParameterIivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := TexParameterIivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := TexParameterIivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexParameterIivEXT(target, pname, &params);
    
    public z_TexParameterIuivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTexParameterIuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivEXT(target: DummyEnum; pname: DummyEnum; &params: array of UInt32) := TexParameterIuivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivEXT(target: DummyEnum; pname: DummyEnum; var &params: UInt32) := TexParameterIuivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexParameterIuivEXT(target, pname, &params);
    
    public z_GetTexParameterIivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexParameterIivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetTexParameterIivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetTexParameterIivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexParameterIivEXT(target, pname, &params);
    
    public z_GetTexParameterIuivEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexParameterIuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuivEXT(target: DummyEnum; pname: DummyEnum; &params: array of UInt32) := GetTexParameterIuivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuivEXT(target: DummyEnum; pname: DummyEnum; var &params: UInt32) := GetTexParameterIuivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexParameterIuivEXT(target, pname, &params);
    
    {$endregion EXT_texture_border_clamp EXT_texture_integer}
    
    {$region EXT_bindable_uniform}
    
    public z_UniformBufferEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; buffer: UInt32)>('glUniformBufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformBufferEXT(&program: UInt32; location: Int32; buffer: UInt32) := z_UniformBufferEXT(&program, location, buffer);
    
    public z_GetUniformBufferSizeEXT := GetGLFuncOrNil&<function(&program: UInt32; location: Int32): Int32>('glGetUniformBufferSizeEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBufferSizeEXT(&program: UInt32; location: Int32): Int32 := z_GetUniformBufferSizeEXT(&program, location);
    
    public z_GetUniformOffsetEXT := GetGLFuncOrNil&<function(&program: UInt32; location: Int32): IntPtr>('glGetUniformOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformOffsetEXT(&program: UInt32; location: Int32): IntPtr := z_GetUniformOffsetEXT(&program, location);
    
    {$endregion EXT_bindable_uniform}
    
    {$region EXT_gpu_shader4 NV_vertex_program4}
    
    public z_VertexAttribI1iEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: Int32)>('glVertexAttribI1iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1iEXT(index: UInt32; x: Int32) := z_VertexAttribI1iEXT(index, x);
    
    public z_VertexAttribI2iEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: Int32; y: Int32)>('glVertexAttribI2iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2iEXT(index: UInt32; x: Int32; y: Int32) := z_VertexAttribI2iEXT(index, x, y);
    
    public z_VertexAttribI3iEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32)>('glVertexAttribI3iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3iEXT(index: UInt32; x: Int32; y: Int32; z: Int32) := z_VertexAttribI3iEXT(index, x, y, z);
    
    public z_VertexAttribI4iEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>('glVertexAttribI4iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4iEXT(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := z_VertexAttribI4iEXT(index, x, y, z, w);
    
    public z_VertexAttribI1uiEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt32)>('glVertexAttribI1uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uiEXT(index: UInt32; x: UInt32) := z_VertexAttribI1uiEXT(index, x);
    
    public z_VertexAttribI2uiEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32)>('glVertexAttribI2uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uiEXT(index: UInt32; x: UInt32; y: UInt32) := z_VertexAttribI2uiEXT(index, x, y);
    
    public z_VertexAttribI3uiEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32)>('glVertexAttribI3uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32) := z_VertexAttribI3uiEXT(index, x, y, z);
    
    public z_VertexAttribI4uiEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>('glVertexAttribI4uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uiEXT(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := z_VertexAttribI4uiEXT(index, x, y, z, w);
    
    public z_VertexAttribI1ivEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI1ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; v: array of Int32) := VertexAttribI1ivEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; var v: Int32) := VertexAttribI1ivEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1ivEXT(index: UInt32; v: pointer) := z_VertexAttribI1ivEXT(index, v);
    
    public z_VertexAttribI2ivEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI2ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; v: array of Int32) := VertexAttribI2ivEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; var v: Int32) := VertexAttribI2ivEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2ivEXT(index: UInt32; v: pointer) := z_VertexAttribI2ivEXT(index, v);
    
    public z_VertexAttribI3ivEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI3ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; v: array of Int32) := VertexAttribI3ivEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; var v: Int32) := VertexAttribI3ivEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3ivEXT(index: UInt32; v: pointer) := z_VertexAttribI3ivEXT(index, v);
    
    public z_VertexAttribI4ivEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; v: array of Int32) := VertexAttribI4ivEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; var v: Int32) := VertexAttribI4ivEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ivEXT(index: UInt32; v: pointer) := z_VertexAttribI4ivEXT(index, v);
    
    public z_VertexAttribI1uivEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI1uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; v: array of UInt32) := VertexAttribI1uivEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; var v: UInt32) := VertexAttribI1uivEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI1uivEXT(index: UInt32; v: pointer) := z_VertexAttribI1uivEXT(index, v);
    
    public z_VertexAttribI2uivEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI2uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; v: array of UInt32) := VertexAttribI2uivEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; var v: UInt32) := VertexAttribI2uivEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI2uivEXT(index: UInt32; v: pointer) := z_VertexAttribI2uivEXT(index, v);
    
    public z_VertexAttribI3uivEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI3uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; v: array of UInt32) := VertexAttribI3uivEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; var v: UInt32) := VertexAttribI3uivEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI3uivEXT(index: UInt32; v: pointer) := z_VertexAttribI3uivEXT(index, v);
    
    public z_VertexAttribI4uivEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; v: array of UInt32) := VertexAttribI4uivEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; var v: UInt32) := VertexAttribI4uivEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4uivEXT(index: UInt32; v: pointer) := z_VertexAttribI4uivEXT(index, v);
    
    public z_VertexAttribI4bvEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4bvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; v: array of SByte) := VertexAttribI4bvEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; var v: SByte) := VertexAttribI4bvEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4bvEXT(index: UInt32; v: pointer) := z_VertexAttribI4bvEXT(index, v);
    
    public z_VertexAttribI4svEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4svEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; v: array of Int16) := VertexAttribI4svEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; var v: Int16) := VertexAttribI4svEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4svEXT(index: UInt32; v: pointer) := z_VertexAttribI4svEXT(index, v);
    
    public z_VertexAttribI4ubvEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4ubvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; v: array of Byte) := VertexAttribI4ubvEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; var v: Byte) := VertexAttribI4ubvEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4ubvEXT(index: UInt32; v: pointer) := z_VertexAttribI4ubvEXT(index, v);
    
    public z_VertexAttribI4usvEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribI4usvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; v: array of UInt16) := VertexAttribI4usvEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; var v: UInt16) := VertexAttribI4usvEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribI4usvEXT(index: UInt32; v: pointer) := z_VertexAttribI4usvEXT(index, v);
    
    public z_VertexAttribIPointerEXT := GetGLFuncOrNil&<procedure(index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glVertexAttribIPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIPointerEXT(index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_VertexAttribIPointerEXT(index, size, &type, stride, _pointer);
    
    public z_GetVertexAttribIivEXT := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribIivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: DummyEnum; &params: array of Int32) := GetVertexAttribIivEXT(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: DummyEnum; var &params: Int32) := GetVertexAttribIivEXT(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIivEXT(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribIivEXT(index, pname, &params);
    
    public z_GetVertexAttribIuivEXT := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribIuivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: DummyEnum; &params: array of UInt32) := GetVertexAttribIuivEXT(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: DummyEnum; var &params: UInt32) := GetVertexAttribIuivEXT(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribIuivEXT(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribIuivEXT(index, pname, &params);
    
    {$endregion EXT_gpu_shader4 NV_vertex_program4}
    
    {$region EXT_vertex_attrib_64bit}
    
    public z_VertexAttribL1dEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: double)>('glVertexAttribL1dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dEXT(index: UInt32; x: double) := z_VertexAttribL1dEXT(index, x);
    
    public z_VertexAttribL2dEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double)>('glVertexAttribL2dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dEXT(index: UInt32; x: double; y: double) := z_VertexAttribL2dEXT(index, x, y);
    
    public z_VertexAttribL3dEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>('glVertexAttribL3dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dEXT(index: UInt32; x: double; y: double; z: double) := z_VertexAttribL3dEXT(index, x, y, z);
    
    public z_VertexAttribL4dEXT := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>('glVertexAttribL4dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dEXT(index: UInt32; x: double; y: double; z: double; w: double) := z_VertexAttribL4dEXT(index, x, y, z, w);
    
    public z_VertexAttribL1dvEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL1dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dvEXT(index: UInt32; v: array of double) := VertexAttribL1dvEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dvEXT(index: UInt32; var v: double) := VertexAttribL1dvEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1dvEXT(index: UInt32; v: pointer) := z_VertexAttribL1dvEXT(index, v);
    
    public z_VertexAttribL2dvEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL2dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dvEXT(index: UInt32; v: array of double) := VertexAttribL2dvEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dvEXT(index: UInt32; var v: double) := VertexAttribL2dvEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2dvEXT(index: UInt32; v: pointer) := z_VertexAttribL2dvEXT(index, v);
    
    public z_VertexAttribL3dvEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL3dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dvEXT(index: UInt32; v: array of double) := VertexAttribL3dvEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dvEXT(index: UInt32; var v: double) := VertexAttribL3dvEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3dvEXT(index: UInt32; v: pointer) := z_VertexAttribL3dvEXT(index, v);
    
    public z_VertexAttribL4dvEXT := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL4dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dvEXT(index: UInt32; v: array of double) := VertexAttribL4dvEXT(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dvEXT(index: UInt32; var v: double) := VertexAttribL4dvEXT(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4dvEXT(index: UInt32; v: pointer) := z_VertexAttribL4dvEXT(index, v);
    
    public z_VertexAttribLPointerEXT := GetGLFuncOrNil&<procedure(index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glVertexAttribLPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLPointerEXT(index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_VertexAttribLPointerEXT(index, size, &type, stride, _pointer);
    
    public z_GetVertexAttribLdvEXT := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribLdvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdvEXT(index: UInt32; pname: DummyEnum; &params: array of double) := GetVertexAttribLdvEXT(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdvEXT(index: UInt32; pname: DummyEnum; var &params: double) := GetVertexAttribLdvEXT(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLdvEXT(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribLdvEXT(index, pname, &params);
    
    {$endregion EXT_vertex_attrib_64bit}
    
    {$region EXT_external_objects_fd}
    
    public z_ImportMemoryFdEXT := GetGLFuncOrNil&<procedure(memory: UInt32; size: UInt64; handleType: DummyEnum; fd: Int32)>('glImportMemoryFdEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryFdEXT(memory: UInt32; size: UInt64; handleType: DummyEnum; fd: Int32) := z_ImportMemoryFdEXT(memory, size, handleType, fd);
    
    public z_ImportSemaphoreFdEXT := GetGLFuncOrNil&<procedure(semaphore: UInt32; handleType: DummyEnum; fd: Int32)>('glImportSemaphoreFdEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreFdEXT(semaphore: UInt32; handleType: DummyEnum; fd: Int32) := z_ImportSemaphoreFdEXT(semaphore, handleType, fd);
    
    {$endregion EXT_external_objects_fd}
    
    {$region EXT_external_objects_win32}
    
    public z_ImportMemoryWin32HandleEXT := GetGLFuncOrNil&<procedure(memory: UInt32; size: UInt64; handleType: DummyEnum; handle: pointer)>('glImportMemoryWin32HandleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryWin32HandleEXT(memory: UInt32; size: UInt64; handleType: DummyEnum; handle: pointer) := z_ImportMemoryWin32HandleEXT(memory, size, handleType, handle);
    
    public z_ImportMemoryWin32NameEXT := GetGLFuncOrNil&<procedure(memory: UInt32; size: UInt64; handleType: DummyEnum; name: pointer)>('glImportMemoryWin32NameEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryWin32NameEXT(memory: UInt32; size: UInt64; handleType: DummyEnum; name: pointer) := z_ImportMemoryWin32NameEXT(memory, size, handleType, name);
    
    public z_ImportSemaphoreWin32HandleEXT := GetGLFuncOrNil&<procedure(semaphore: UInt32; handleType: DummyEnum; handle: pointer)>('glImportSemaphoreWin32HandleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreWin32HandleEXT(semaphore: UInt32; handleType: DummyEnum; handle: pointer) := z_ImportSemaphoreWin32HandleEXT(semaphore, handleType, handle);
    
    public z_ImportSemaphoreWin32NameEXT := GetGLFuncOrNil&<procedure(semaphore: UInt32; handleType: DummyEnum; name: pointer)>('glImportSemaphoreWin32NameEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreWin32NameEXT(semaphore: UInt32; handleType: DummyEnum; name: pointer) := z_ImportSemaphoreWin32NameEXT(semaphore, handleType, name);
    
    {$endregion EXT_external_objects_win32}
    
    {$region EXT_x11_sync_object}
    
    public z_ImportSyncEXT := GetGLFuncOrNil&<function(external_sync_type: DummyEnum; external_sync: IntPtr; flags: DummyFlags): GLsync>('glImportSyncEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportSyncEXT(external_sync_type: DummyEnum; external_sync: IntPtr; flags: DummyFlags): GLsync := z_ImportSyncEXT(external_sync_type, external_sync, flags);
    
    {$endregion EXT_x11_sync_object}
    
    {$region EXT_debug_marker}
    
    public z_InsertEventMarkerEXT := GetGLFuncOrNil&<procedure(length: Int32; marker: IntPtr)>('glInsertEventMarkerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertEventMarkerEXT(length: Int32; marker: string); begin var ptr_2 := Marshal.StringToHGlobalAnsi(marker); InsertEventMarkerEXT(length, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertEventMarkerEXT(length: Int32; marker: IntPtr) := z_InsertEventMarkerEXT(length, marker);
    
    public z_PushGroupMarkerEXT := GetGLFuncOrNil&<procedure(length: Int32; marker: IntPtr)>('glPushGroupMarkerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushGroupMarkerEXT(length: Int32; marker: string); begin var ptr_2 := Marshal.StringToHGlobalAnsi(marker); PushGroupMarkerEXT(length, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushGroupMarkerEXT(length: Int32; marker: IntPtr) := z_PushGroupMarkerEXT(length, marker);
    
    public z_PopGroupMarkerEXT := GetGLFuncOrNil&<procedure>('glPopGroupMarkerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopGroupMarkerEXT := z_PopGroupMarkerEXT;
    
    {$endregion EXT_debug_marker}
    
    {$region EXT_static_vertex_array}
    
    public z_LockArraysEXT := GetGLFuncOrNil&<procedure(first: Int32; count: Int32)>('glLockArraysEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LockArraysEXT(first: Int32; count: Int32) := z_LockArraysEXT(first, count);
    
    public z_UnlockArraysEXT := GetGLFuncOrNil&<procedure>('glUnlockArraysEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnlockArraysEXT := z_UnlockArraysEXT;
    
    {$endregion EXT_static_vertex_array}
    
    {$region EXT_multi_draw_arrays SUN_multi_draw_arrays}
    
    public z_MultiDrawArraysEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; first: pointer; count: pointer; primcount: Int32)>('glMultiDrawArraysEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: DummyEnum; first: array of Int32; count: array of Int32; primcount: Int32) := MultiDrawArraysEXT(mode, first[0], count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: DummyEnum; first: array of Int32; var count: Int32; primcount: Int32) := MultiDrawArraysEXT(mode, first[0], @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: DummyEnum; first: array of Int32; count: pointer; primcount: Int32) := MultiDrawArraysEXT(mode, first[0], count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: DummyEnum; var first: Int32; count: array of Int32; primcount: Int32) := MultiDrawArraysEXT(mode, @first, count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: DummyEnum; var first: Int32; var count: Int32; primcount: Int32) := MultiDrawArraysEXT(mode, @first, @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: DummyEnum; var first: Int32; count: pointer; primcount: Int32) := MultiDrawArraysEXT(mode, @first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: DummyEnum; first: pointer; count: array of Int32; primcount: Int32) := MultiDrawArraysEXT(mode, first, count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: DummyEnum; first: pointer; var count: Int32; primcount: Int32) := MultiDrawArraysEXT(mode, first, @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysEXT(mode: DummyEnum; first: pointer; count: pointer; primcount: Int32) := z_MultiDrawArraysEXT(mode, first, count, primcount);
    
    public z_MultiDrawElementsEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32)>('glMultiDrawElementsEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32) := MultiDrawElementsEXT(mode, count[0], &type, indices[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32) := MultiDrawElementsEXT(mode, count[0], &type, @indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; primcount: Int32) := MultiDrawElementsEXT(mode, count[0], &type, indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32) := MultiDrawElementsEXT(mode, @count, &type, indices[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32) := MultiDrawElementsEXT(mode, @count, &type, @indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32) := MultiDrawElementsEXT(mode, @count, &type, indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; primcount: Int32) := MultiDrawElementsEXT(mode, count, &type, indices[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; primcount: Int32) := MultiDrawElementsEXT(mode, count, &type, @indices, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32) := z_MultiDrawElementsEXT(mode, count, &type, indices, primcount);
    
    {$endregion EXT_multi_draw_arrays SUN_multi_draw_arrays}
    
    {$region EXT_multi_draw_indirect}
    
    public z_MultiDrawArraysIndirectEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; indirect: pointer; drawcount: Int32; stride: Int32)>('glMultiDrawArraysIndirectEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectEXT(mode: DummyEnum; indirect: pointer; drawcount: Int32; stride: Int32) := z_MultiDrawArraysIndirectEXT(mode, indirect, drawcount, stride);
    
    public z_MultiDrawElementsIndirectEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawcount: Int32; stride: Int32)>('glMultiDrawElementsIndirectEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectEXT(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawcount: Int32; stride: Int32) := z_MultiDrawElementsIndirectEXT(mode, &type, indirect, drawcount, stride);
    
    {$endregion EXT_multi_draw_indirect}
    
    {$region EXT_draw_elements_base_vertex OES_draw_elements_base_vertex}
    
    public z_MultiDrawElementsBaseVertexEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; basevertex: pointer)>('glMultiDrawElementsBaseVertexEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertexEXT(mode, count[0], &type, indices[0], primcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertexEXT(mode, count[0], &type, indices[0], primcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertexEXT(mode, count[0], &type, indices[0], primcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertexEXT(mode, count[0], &type, @indices, primcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertexEXT(mode, count[0], &type, @indices, primcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertexEXT(mode, count[0], &type, @indices, primcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; primcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertexEXT(mode, count[0], &type, indices, primcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; primcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertexEXT(mode, count[0], &type, indices, primcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; primcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertexEXT(mode, count[0], &type, indices, primcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertexEXT(mode, @count, &type, indices[0], primcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertexEXT(mode, @count, &type, indices[0], primcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertexEXT(mode, @count, &type, indices[0], primcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertexEXT(mode, @count, &type, @indices, primcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertexEXT(mode, @count, &type, @indices, primcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertexEXT(mode, @count, &type, @indices, primcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertexEXT(mode, @count, &type, indices, primcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertexEXT(mode, @count, &type, indices, primcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertexEXT(mode, @count, &type, indices, primcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertexEXT(mode, count, &type, indices[0], primcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertexEXT(mode, count, &type, indices[0], primcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertexEXT(mode, count, &type, indices[0], primcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; primcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertexEXT(mode, count, &type, @indices, primcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; primcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertexEXT(mode, count, &type, @indices, primcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; primcount: Int32; basevertex: pointer) := MultiDrawElementsBaseVertexEXT(mode, count, &type, @indices, primcount, basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; basevertex: array of Int32) := MultiDrawElementsBaseVertexEXT(mode, count, &type, indices, primcount, basevertex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; var basevertex: Int32) := MultiDrawElementsBaseVertexEXT(mode, count, &type, indices, primcount, @basevertex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsBaseVertexEXT(mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; basevertex: pointer) := z_MultiDrawElementsBaseVertexEXT(mode, count, &type, indices, primcount, basevertex);
    
    {$endregion EXT_draw_elements_base_vertex OES_draw_elements_base_vertex}
    
    {$region ARB_buffer_storage EXT_buffer_storage}
    
    public z_NamedBufferStorageEXT := GetGLFuncOrNil&<procedure(buffer: UInt32; size: UIntPtr; data: pointer; flags: DummyFlags)>('glNamedBufferStorageEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageEXT(buffer: UInt32; size: UIntPtr; data: pointer; flags: DummyFlags) := z_NamedBufferStorageEXT(buffer, size, data, flags);
    
    {$endregion ARB_buffer_storage EXT_buffer_storage}
    
    {$region EXT_tessellation_shader}
    
    public z_PatchParameteriEXT := GetGLFuncOrNil&<procedure(pname: DummyEnum; value: Int32)>('glPatchParameteriEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameteriEXT(pname: DummyEnum; value: Int32) := z_PatchParameteriEXT(pname, value);
    
    {$endregion EXT_tessellation_shader}
    
    {$region EXT_point_parameters}
    
    public z_PointParameterfEXT := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: single)>('glPointParameterfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfEXT(pname: DummyEnum; param: single) := z_PointParameterfEXT(pname, param);
    
    public z_PointParameterfvEXT := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glPointParameterfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvEXT(pname: DummyEnum; &params: array of single) := PointParameterfvEXT(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvEXT(pname: DummyEnum; var &params: single) := PointParameterfvEXT(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterfvEXT(pname: DummyEnum; &params: pointer) := z_PointParameterfvEXT(pname, &params);
    
    {$endregion EXT_point_parameters}
    
    {$region EXT_polygon_offset_clamp}
    
    public z_PolygonOffsetClampEXT := GetGLFuncOrNil&<procedure(factor: single; units: single; clamp: single)>('glPolygonOffsetClampEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetClampEXT(factor: single; units: single; clamp: single) := z_PolygonOffsetClampEXT(factor, units, clamp);
    
    {$endregion EXT_polygon_offset_clamp}
    
    {$region EXT_polygon_offset}
    
    public z_PolygonOffsetEXT := GetGLFuncOrNil&<procedure(factor: single; bias: single)>('glPolygonOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetEXT(factor: single; bias: single) := z_PolygonOffsetEXT(factor, bias);
    
    {$endregion EXT_polygon_offset}
    
    {$region EXT_primitive_bounding_box}
    
    public z_PrimitiveBoundingBoxEXT := GetGLFuncOrNil&<procedure(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single)>('glPrimitiveBoundingBoxEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveBoundingBoxEXT(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single) := z_PrimitiveBoundingBoxEXT(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    
    {$endregion EXT_primitive_bounding_box}
    
    {$region EXT_gpu_program_parameters}
    
    public z_ProgramEnvParameters4fvEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>('glProgramEnvParameters4fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; &params: array of single) := ProgramEnvParameters4fvEXT(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; var &params: single) := ProgramEnvParameters4fvEXT(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramEnvParameters4fvEXT(target, index, count, &params);
    
    public z_ProgramLocalParameters4fvEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>('glProgramLocalParameters4fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; &params: array of single) := ProgramLocalParameters4fvEXT(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; var &params: single) := ProgramLocalParameters4fvEXT(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramLocalParameters4fvEXT(target, index, count, &params);
    
    {$endregion EXT_gpu_program_parameters}
    
    {$region EXT_geometry_shader4 EXT_separate_shader_objects}
    
    public z_ProgramParameteriEXT := GetGLFuncOrNil&<procedure(&program: UInt32; pname: DummyEnum; value: Int32)>('glProgramParameteriEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameteriEXT(&program: UInt32; pname: DummyEnum; value: Int32) := z_ProgramParameteriEXT(&program, pname, value);
    
    {$endregion EXT_geometry_shader4 EXT_separate_shader_objects}
    
    {$region ARB_gpu_shader_fp64}
    
    public z_ProgramUniform1dEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: double)>('glProgramUniform1dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dEXT(&program: UInt32; location: Int32; x: double) := z_ProgramUniform1dEXT(&program, location, x);
    
    public z_ProgramUniform2dEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: double; y: double)>('glProgramUniform2dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dEXT(&program: UInt32; location: Int32; x: double; y: double) := z_ProgramUniform2dEXT(&program, location, x, y);
    
    public z_ProgramUniform3dEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: double; y: double; z: double)>('glProgramUniform3dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dEXT(&program: UInt32; location: Int32; x: double; y: double; z: double) := z_ProgramUniform3dEXT(&program, location, x, y, z);
    
    public z_ProgramUniform4dEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: double; y: double; z: double; w: double)>('glProgramUniform4dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dEXT(&program: UInt32; location: Int32; x: double; y: double; z: double; w: double) := z_ProgramUniform4dEXT(&program, location, x, y, z, w);
    
    public z_ProgramUniform1dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform1dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dvEXT(&program: UInt32; location: Int32; count: Int32; value: array of double) := ProgramUniform1dvEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dvEXT(&program: UInt32; location: Int32; count: Int32; var value: double) := ProgramUniform1dvEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1dvEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1dvEXT(&program, location, count, value);
    
    public z_ProgramUniform2dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform2dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dvEXT(&program: UInt32; location: Int32; count: Int32; value: array of double) := ProgramUniform2dvEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dvEXT(&program: UInt32; location: Int32; count: Int32; var value: double) := ProgramUniform2dvEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2dvEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2dvEXT(&program, location, count, value);
    
    public z_ProgramUniform3dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform3dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dvEXT(&program: UInt32; location: Int32; count: Int32; value: array of double) := ProgramUniform3dvEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dvEXT(&program: UInt32; location: Int32; count: Int32; var value: double) := ProgramUniform3dvEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3dvEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3dvEXT(&program, location, count, value);
    
    public z_ProgramUniform4dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform4dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dvEXT(&program: UInt32; location: Int32; count: Int32; value: array of double) := ProgramUniform4dvEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dvEXT(&program: UInt32; location: Int32; count: Int32; var value: double) := ProgramUniform4dvEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4dvEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4dvEXT(&program, location, count, value);
    
    public z_ProgramUniformMatrix2dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix2dvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix2dvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2dvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix3dvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix3dvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3dvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix4dvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix4dvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4dvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix2x3dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2x3dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix2x3dvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix2x3dvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2x3dvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix2x4dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2x4dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix2x4dvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix2x4dvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2x4dvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3x2dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3x2dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix3x2dvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix3x2dvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3x2dvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3x4dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3x4dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix3x4dvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix3x4dvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3x4dvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4x2dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4x2dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix4x2dvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix4x2dvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4x2dvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4x3dvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4x3dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of double) := ProgramUniformMatrix4x3dvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: double) := ProgramUniformMatrix4x3dvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3dvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4x3dvEXT(&program, location, count, transpose, value);
    
    {$endregion ARB_gpu_shader_fp64}
    
    {$region EXT_direct_state_access EXT_separate_shader_objects}
    
    public z_ProgramUniform1fEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: single)>('glProgramUniform1fEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fEXT(&program: UInt32; location: Int32; v0: single) := z_ProgramUniform1fEXT(&program, location, v0);
    
    public z_ProgramUniform2fEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: single; v1: single)>('glProgramUniform2fEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fEXT(&program: UInt32; location: Int32; v0: single; v1: single) := z_ProgramUniform2fEXT(&program, location, v0, v1);
    
    public z_ProgramUniform3fEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: single; v1: single; v2: single)>('glProgramUniform3fEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fEXT(&program: UInt32; location: Int32; v0: single; v1: single; v2: single) := z_ProgramUniform3fEXT(&program, location, v0, v1, v2);
    
    public z_ProgramUniform4fEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: single; v1: single; v2: single; v3: single)>('glProgramUniform4fEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fEXT(&program: UInt32; location: Int32; v0: single; v1: single; v2: single; v3: single) := z_ProgramUniform4fEXT(&program, location, v0, v1, v2, v3);
    
    public z_ProgramUniform1iEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: Int32)>('glProgramUniform1iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1iEXT(&program: UInt32; location: Int32; v0: Int32) := z_ProgramUniform1iEXT(&program, location, v0);
    
    public z_ProgramUniform2iEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: Int32; v1: Int32)>('glProgramUniform2iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2iEXT(&program: UInt32; location: Int32; v0: Int32; v1: Int32) := z_ProgramUniform2iEXT(&program, location, v0, v1);
    
    public z_ProgramUniform3iEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: Int32; v1: Int32; v2: Int32)>('glProgramUniform3iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3iEXT(&program: UInt32; location: Int32; v0: Int32; v1: Int32; v2: Int32) := z_ProgramUniform3iEXT(&program, location, v0, v1, v2);
    
    public z_ProgramUniform4iEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32)>('glProgramUniform4iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4iEXT(&program: UInt32; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32) := z_ProgramUniform4iEXT(&program, location, v0, v1, v2, v3);
    
    public z_ProgramUniform1fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform1fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fvEXT(&program: UInt32; location: Int32; count: Int32; value: array of single) := ProgramUniform1fvEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fvEXT(&program: UInt32; location: Int32; count: Int32; var value: single) := ProgramUniform1fvEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1fvEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1fvEXT(&program, location, count, value);
    
    public z_ProgramUniform2fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform2fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fvEXT(&program: UInt32; location: Int32; count: Int32; value: array of single) := ProgramUniform2fvEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fvEXT(&program: UInt32; location: Int32; count: Int32; var value: single) := ProgramUniform2fvEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2fvEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2fvEXT(&program, location, count, value);
    
    public z_ProgramUniform3fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform3fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fvEXT(&program: UInt32; location: Int32; count: Int32; value: array of single) := ProgramUniform3fvEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fvEXT(&program: UInt32; location: Int32; count: Int32; var value: single) := ProgramUniform3fvEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3fvEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3fvEXT(&program, location, count, value);
    
    public z_ProgramUniform4fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform4fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fvEXT(&program: UInt32; location: Int32; count: Int32; value: array of single) := ProgramUniform4fvEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fvEXT(&program: UInt32; location: Int32; count: Int32; var value: single) := ProgramUniform4fvEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4fvEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4fvEXT(&program, location, count, value);
    
    public z_ProgramUniform1ivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform1ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ivEXT(&program: UInt32; location: Int32; count: Int32; value: array of Int32) := ProgramUniform1ivEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ivEXT(&program: UInt32; location: Int32; count: Int32; var value: Int32) := ProgramUniform1ivEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ivEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1ivEXT(&program, location, count, value);
    
    public z_ProgramUniform2ivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform2ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ivEXT(&program: UInt32; location: Int32; count: Int32; value: array of Int32) := ProgramUniform2ivEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ivEXT(&program: UInt32; location: Int32; count: Int32; var value: Int32) := ProgramUniform2ivEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ivEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2ivEXT(&program, location, count, value);
    
    public z_ProgramUniform3ivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform3ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ivEXT(&program: UInt32; location: Int32; count: Int32; value: array of Int32) := ProgramUniform3ivEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ivEXT(&program: UInt32; location: Int32; count: Int32; var value: Int32) := ProgramUniform3ivEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ivEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3ivEXT(&program, location, count, value);
    
    public z_ProgramUniform4ivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform4ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ivEXT(&program: UInt32; location: Int32; count: Int32; value: array of Int32) := ProgramUniform4ivEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ivEXT(&program: UInt32; location: Int32; count: Int32; var value: Int32) := ProgramUniform4ivEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ivEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4ivEXT(&program, location, count, value);
    
    public z_ProgramUniformMatrix2fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix2fvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix2fvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2fvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix3fvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix3fvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3fvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix4fvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix4fvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4fvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix2x3fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2x3fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix2x3fvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix2x3fvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2x3fvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3x2fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3x2fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix3x2fvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix3x2fvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3x2fvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix2x4fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix2x4fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix2x4fvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix2x4fvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix2x4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix2x4fvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4x2fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4x2fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix4x2fvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix4x2fvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x2fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4x2fvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix3x4fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix3x4fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix3x4fvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix3x4fvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix3x4fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix3x4fvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniformMatrix4x3fvEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer)>('glProgramUniformMatrix4x3fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: array of single) := ProgramUniformMatrix4x3fvEXT(&program, location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; var value: single) := ProgramUniformMatrix4x3fvEXT(&program, location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformMatrix4x3fvEXT(&program: UInt32; location: Int32; count: Int32; transpose: boolean; value: pointer) := z_ProgramUniformMatrix4x3fvEXT(&program, location, count, transpose, value);
    
    public z_ProgramUniform1uiEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: UInt32)>('glProgramUniform1uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uiEXT(&program: UInt32; location: Int32; v0: UInt32) := z_ProgramUniform1uiEXT(&program, location, v0);
    
    public z_ProgramUniform2uiEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: UInt32; v1: UInt32)>('glProgramUniform2uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uiEXT(&program: UInt32; location: Int32; v0: UInt32; v1: UInt32) := z_ProgramUniform2uiEXT(&program, location, v0, v1);
    
    public z_ProgramUniform3uiEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32)>('glProgramUniform3uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uiEXT(&program: UInt32; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32) := z_ProgramUniform3uiEXT(&program, location, v0, v1, v2);
    
    public z_ProgramUniform4uiEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32)>('glProgramUniform4uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uiEXT(&program: UInt32; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32) := z_ProgramUniform4uiEXT(&program, location, v0, v1, v2, v3);
    
    public z_ProgramUniform1uivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform1uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uivEXT(&program: UInt32; location: Int32; count: Int32; value: array of UInt32) := ProgramUniform1uivEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uivEXT(&program: UInt32; location: Int32; count: Int32; var value: UInt32) := ProgramUniform1uivEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1uivEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1uivEXT(&program, location, count, value);
    
    public z_ProgramUniform2uivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform2uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uivEXT(&program: UInt32; location: Int32; count: Int32; value: array of UInt32) := ProgramUniform2uivEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uivEXT(&program: UInt32; location: Int32; count: Int32; var value: UInt32) := ProgramUniform2uivEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2uivEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2uivEXT(&program, location, count, value);
    
    public z_ProgramUniform3uivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform3uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uivEXT(&program: UInt32; location: Int32; count: Int32; value: array of UInt32) := ProgramUniform3uivEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uivEXT(&program: UInt32; location: Int32; count: Int32; var value: UInt32) := ProgramUniform3uivEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3uivEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3uivEXT(&program, location, count, value);
    
    public z_ProgramUniform4uivEXT := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform4uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uivEXT(&program: UInt32; location: Int32; count: Int32; value: array of UInt32) := ProgramUniform4uivEXT(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uivEXT(&program: UInt32; location: Int32; count: Int32; var value: UInt32) := ProgramUniform4uivEXT(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4uivEXT(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4uivEXT(&program, location, count, value);
    
    {$endregion EXT_direct_state_access EXT_separate_shader_objects}
    
    {$region EXT_provoking_vertex}
    
    public z_ProvokingVertexEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glProvokingVertexEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProvokingVertexEXT(mode: DummyEnum) := z_ProvokingVertexEXT(mode);
    
    {$endregion EXT_provoking_vertex}
    
    {$region EXT_raster_multisample NV_framebuffer_mixed_samples}
    
    public z_RasterSamplesEXT := GetGLFuncOrNil&<procedure(samples: UInt32; fixedsamplelocations: boolean)>('glRasterSamplesEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterSamplesEXT(samples: UInt32; fixedsamplelocations: boolean) := z_RasterSamplesEXT(samples, fixedsamplelocations);
    
    {$endregion EXT_raster_multisample NV_framebuffer_mixed_samples}
    
    {$region EXT_framebuffer_multisample EXT_multisampled_render_to_texture}
    
    public z_RenderbufferStorageMultisampleEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glRenderbufferStorageMultisampleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleEXT(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
    
    {$endregion EXT_framebuffer_multisample EXT_multisampled_render_to_texture}
    
    {$region EXT_multisample}
    
    public z_SampleMaskEXT := GetGLFuncOrNil&<procedure(value: single; invert: boolean)>('glSampleMaskEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskEXT(value: single; invert: boolean) := z_SampleMaskEXT(value, invert);
    
    public z_SamplePatternEXT := GetGLFuncOrNil&<procedure(pattern: DummyEnum)>('glSamplePatternEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplePatternEXT(pattern: DummyEnum) := z_SamplePatternEXT(pattern);
    
    {$endregion EXT_multisample}
    
    {$region EXT_secondary_color}
    
    public z_SecondaryColor3bEXT := GetGLFuncOrNil&<procedure(red: SByte; green: SByte; blue: SByte)>('glSecondaryColor3bEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bEXT(red: SByte; green: SByte; blue: SByte) := z_SecondaryColor3bEXT(red, green, blue);
    
    public z_SecondaryColor3sEXT := GetGLFuncOrNil&<procedure(red: Int16; green: Int16; blue: Int16)>('glSecondaryColor3sEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sEXT(red: Int16; green: Int16; blue: Int16) := z_SecondaryColor3sEXT(red, green, blue);
    
    public z_SecondaryColor3iEXT := GetGLFuncOrNil&<procedure(red: Int32; green: Int32; blue: Int32)>('glSecondaryColor3iEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iEXT(red: Int32; green: Int32; blue: Int32) := z_SecondaryColor3iEXT(red, green, blue);
    
    public z_SecondaryColor3fEXT := GetGLFuncOrNil&<procedure(red: single; green: single; blue: single)>('glSecondaryColor3fEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fEXT(red: single; green: single; blue: single) := z_SecondaryColor3fEXT(red, green, blue);
    
    public z_SecondaryColor3dEXT := GetGLFuncOrNil&<procedure(red: double; green: double; blue: double)>('glSecondaryColor3dEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dEXT(red: double; green: double; blue: double) := z_SecondaryColor3dEXT(red, green, blue);
    
    public z_SecondaryColor3ubEXT := GetGLFuncOrNil&<procedure(red: Byte; green: Byte; blue: Byte)>('glSecondaryColor3ubEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubEXT(red: Byte; green: Byte; blue: Byte) := z_SecondaryColor3ubEXT(red, green, blue);
    
    public z_SecondaryColor3usEXT := GetGLFuncOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16)>('glSecondaryColor3usEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usEXT(red: UInt16; green: UInt16; blue: UInt16) := z_SecondaryColor3usEXT(red, green, blue);
    
    public z_SecondaryColor3uiEXT := GetGLFuncOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32)>('glSecondaryColor3uiEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiEXT(red: UInt32; green: UInt32; blue: UInt32) := z_SecondaryColor3uiEXT(red, green, blue);
    
    public z_SecondaryColor3bvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3bvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bvEXT(v: array of SByte) := SecondaryColor3bvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bvEXT(var v: SByte) := SecondaryColor3bvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bvEXT(v: pointer) := z_SecondaryColor3bvEXT(v);
    
    public z_SecondaryColor3svEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3svEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3svEXT(v: array of Int16) := SecondaryColor3svEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3svEXT(var v: Int16) := SecondaryColor3svEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3svEXT(v: pointer) := z_SecondaryColor3svEXT(v);
    
    public z_SecondaryColor3ivEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3ivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ivEXT(v: array of Int32) := SecondaryColor3ivEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ivEXT(var v: Int32) := SecondaryColor3ivEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ivEXT(v: pointer) := z_SecondaryColor3ivEXT(v);
    
    public z_SecondaryColor3fvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3fvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fvEXT(v: array of single) := SecondaryColor3fvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fvEXT(var v: single) := SecondaryColor3fvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fvEXT(v: pointer) := z_SecondaryColor3fvEXT(v);
    
    public z_SecondaryColor3dvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3dvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dvEXT(v: array of double) := SecondaryColor3dvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dvEXT(var v: double) := SecondaryColor3dvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dvEXT(v: pointer) := z_SecondaryColor3dvEXT(v);
    
    public z_SecondaryColor3ubvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3ubvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubvEXT(v: array of Byte) := SecondaryColor3ubvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubvEXT(var v: Byte) := SecondaryColor3ubvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubvEXT(v: pointer) := z_SecondaryColor3ubvEXT(v);
    
    public z_SecondaryColor3usvEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3usvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usvEXT(v: array of UInt16) := SecondaryColor3usvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usvEXT(var v: UInt16) := SecondaryColor3usvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usvEXT(v: pointer) := z_SecondaryColor3usvEXT(v);
    
    public z_SecondaryColor3uivEXT := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3uivEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uivEXT(v: array of UInt32) := SecondaryColor3uivEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uivEXT(var v: UInt32) := SecondaryColor3uivEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uivEXT(v: pointer) := z_SecondaryColor3uivEXT(v);
    
    public z_SecondaryColorPointerEXT := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glSecondaryColorPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerEXT(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_SecondaryColorPointerEXT(size, &type, stride, _pointer);
    
    {$endregion EXT_secondary_color}
    
    {$region EXT_stencil_clear_tag}
    
    public z_StencilClearTagEXT := GetGLFuncOrNil&<procedure(stencilTagBits: Int32; stencilClearTag: UInt32)>('glStencilClearTagEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilClearTagEXT(stencilTagBits: Int32; stencilClearTag: UInt32) := z_StencilClearTagEXT(stencilTagBits, stencilClearTag);
    
    {$endregion EXT_stencil_clear_tag}
    
    {$region EXT_texture_buffer EXT_texture_buffer_object}
    
    public z_TexBufferEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; buffer: UInt32)>('glTexBufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferEXT(target: DummyEnum; internalformat: DummyEnum; buffer: UInt32) := z_TexBufferEXT(target, internalformat, buffer);
    
    {$endregion EXT_texture_buffer EXT_texture_buffer_object}
    
    {$region EXT_texture_buffer}
    
    public z_TexBufferRangeEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; buffer: UInt32; offset: IntPtr; size: UIntPtr)>('glTexBufferRangeEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferRangeEXT(target: DummyEnum; internalformat: DummyEnum; buffer: UInt32; offset: IntPtr; size: UIntPtr) := z_TexBufferRangeEXT(target, internalformat, buffer, offset, size);
    
    {$endregion EXT_texture_buffer}
    
    {$region EXT_texture3D}
    
    public z_TexImage3DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTexImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DEXT(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TexImage3DEXT(target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    {$endregion EXT_texture3D}
    
    {$region EXT_sparse_texture}
    
    public z_TexPageCommitmentEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean)>('glTexPageCommitmentEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexPageCommitmentEXT(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean) := z_TexPageCommitmentEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    
    {$endregion EXT_sparse_texture}
    
    {$region EXT_texture_storage}
    
    public z_TexStorage1DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32)>('glTexStorage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage1DEXT(target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32) := z_TexStorage1DEXT(target, levels, internalformat, width);
    
    public z_TexStorage2DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glTexStorage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage2DEXT(target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_TexStorage2DEXT(target, levels, internalformat, width, height);
    
    public z_TexStorage3DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32)>('glTexStorage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3DEXT(target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32) := z_TexStorage3DEXT(target, levels, internalformat, width, height, depth);
    
    {$endregion EXT_texture_storage}
    
    {$region EXT_subtexture}
    
    public z_TexSubImage1DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTexSubImage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage1DEXT(target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TexSubImage1DEXT(target, level, xoffset, width, format, &type, pixels);
    
    public z_TexSubImage2DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTexSubImage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage2DEXT(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    public z_TexSubImage3DEXT := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTexSubImage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage3DEXT(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    {$endregion EXT_subtexture}
    
    {$region ARB_texture_buffer_range}
    
    public z_TextureBufferRangeEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; internalformat: DummyEnum; buffer: UInt32; offset: IntPtr; size: UIntPtr)>('glTextureBufferRangeEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBufferRangeEXT(texture: UInt32; target: DummyEnum; internalformat: DummyEnum; buffer: UInt32; offset: IntPtr; size: UIntPtr) := z_TextureBufferRangeEXT(texture, target, internalformat, buffer, offset, size);
    
    {$endregion ARB_texture_buffer_range}
    
    {$region EXT_texture_perturb_normal}
    
    public z_TextureNormalEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glTextureNormalEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureNormalEXT(mode: DummyEnum) := z_TextureNormalEXT(mode);
    
    {$endregion EXT_texture_perturb_normal}
    
    {$region ARB_sparse_texture EXT_sparse_texture}
    
    public z_TexturePageCommitmentEXT := GetGLFuncOrNil&<procedure(texture: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean)>('glTexturePageCommitmentEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexturePageCommitmentEXT(texture: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: boolean) := z_TexturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    
    {$endregion ARB_sparse_texture EXT_sparse_texture}
    
    {$region ARB_texture_storage EXT_texture_storage}
    
    public z_TextureStorage1DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32)>('glTextureStorage1DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage1DEXT(texture: UInt32; target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32) := z_TextureStorage1DEXT(texture, target, levels, internalformat, width);
    
    public z_TextureStorage2DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glTextureStorage2DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DEXT(texture: UInt32; target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_TextureStorage2DEXT(texture, target, levels, internalformat, width, height);
    
    public z_TextureStorage3DEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32)>('glTextureStorage3DEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DEXT(texture: UInt32; target: DummyEnum; levels: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32) := z_TextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
    
    {$endregion ARB_texture_storage EXT_texture_storage}
    
    {$region ARB_texture_storage_multisample}
    
    public z_TextureStorage2DMultisampleEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32; fixedsamplelocations: boolean)>('glTextureStorage2DMultisampleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage2DMultisampleEXT(texture: UInt32; target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32; fixedsamplelocations: boolean) := z_TextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations);
    
    public z_TextureStorage3DMultisampleEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>('glTextureStorage3DMultisampleEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorage3DMultisampleEXT(texture: UInt32; target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) := z_TextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    {$endregion ARB_texture_storage_multisample}
    
    {$region EXT_texture_view}
    
    public z_TextureViewEXT := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; origtexture: UInt32; internalformat: DummyEnum; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32)>('glTextureViewEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureViewEXT(texture: UInt32; target: DummyEnum; origtexture: UInt32; internalformat: DummyEnum; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32) := z_TextureViewEXT(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    
    {$endregion EXT_texture_view}
    
    {$region ARB_vertex_attrib_binding}
    
    public z_VertexArrayBindVertexBufferEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; bindingindex: UInt32; buffer: UInt32; offset: IntPtr; stride: Int32)>('glVertexArrayBindVertexBufferEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayBindVertexBufferEXT(vaobj: UInt32; bindingindex: UInt32; buffer: UInt32; offset: IntPtr; stride: Int32) := z_VertexArrayBindVertexBufferEXT(vaobj, bindingindex, buffer, offset, stride);
    
    public z_VertexArrayVertexAttribFormatEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; normalized: boolean; relativeoffset: UInt32)>('glVertexArrayVertexAttribFormatEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribFormatEXT(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; normalized: boolean; relativeoffset: UInt32) := z_VertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, &type, normalized, relativeoffset);
    
    public z_VertexArrayVertexAttribIFormatEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; relativeoffset: UInt32)>('glVertexArrayVertexAttribIFormatEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribIFormatEXT(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; relativeoffset: UInt32) := z_VertexArrayVertexAttribIFormatEXT(vaobj, attribindex, size, &type, relativeoffset);
    
    public z_VertexArrayVertexAttribLFormatEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; relativeoffset: UInt32)>('glVertexArrayVertexAttribLFormatEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribLFormatEXT(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; relativeoffset: UInt32) := z_VertexArrayVertexAttribLFormatEXT(vaobj, attribindex, size, &type, relativeoffset);
    
    public z_VertexArrayVertexAttribBindingEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; attribindex: UInt32; bindingindex: UInt32)>('glVertexArrayVertexAttribBindingEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribBindingEXT(vaobj: UInt32; attribindex: UInt32; bindingindex: UInt32) := z_VertexArrayVertexAttribBindingEXT(vaobj, attribindex, bindingindex);
    
    public z_VertexArrayVertexBindingDivisorEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; bindingindex: UInt32; divisor: UInt32)>('glVertexArrayVertexBindingDivisorEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBindingDivisorEXT(vaobj: UInt32; bindingindex: UInt32; divisor: UInt32) := z_VertexArrayVertexBindingDivisorEXT(vaobj, bindingindex, divisor);
    
    {$endregion ARB_vertex_attrib_binding}
    
    {$region ARB_instanced_arrays}
    
    public z_VertexAttribDivisorARB := GetGLFuncOrNil&<procedure(index: UInt32; divisor: UInt32)>('glVertexAttribDivisorARB');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribDivisorARB(index: UInt32; divisor: UInt32) := z_VertexAttribDivisorARB(index, divisor);
    
    public z_VertexArrayVertexAttribDivisorEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; index: UInt32; divisor: UInt32)>('glVertexArrayVertexAttribDivisorEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribDivisorEXT(vaobj: UInt32; index: UInt32; divisor: UInt32) := z_VertexArrayVertexAttribDivisorEXT(vaobj, index, divisor);
    
    {$endregion ARB_instanced_arrays}
    
    {$region ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit}
    
    public z_VertexArrayVertexAttribLOffsetEXT := GetGLFuncOrNil&<procedure(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>('glVertexArrayVertexAttribLOffsetEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribLOffsetEXT(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, &type, stride, offset);
    
    {$endregion ARB_vertex_attrib_64bit EXT_vertex_attrib_64bit}
    
    {$region EXT_instanced_arrays}
    
    public z_VertexAttribDivisorEXT := GetGLFuncOrNil&<procedure(index: UInt32; divisor: UInt32)>('glVertexAttribDivisorEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribDivisorEXT(index: UInt32; divisor: UInt32) := z_VertexAttribDivisorEXT(index, divisor);
    
    {$endregion EXT_instanced_arrays}
    
    {$region EXT_vertex_weighting}
    
    public z_VertexWeightfEXT := GetGLFuncOrNil&<procedure(weight: single)>('glVertexWeightfEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfEXT(weight: single) := z_VertexWeightfEXT(weight);
    
    public z_VertexWeightfvEXT := GetGLFuncOrNil&<procedure(weight: pointer)>('glVertexWeightfvEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(weight: array of single) := VertexWeightfvEXT(weight[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(var weight: single) := VertexWeightfvEXT(@weight);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(weight: pointer) := z_VertexWeightfvEXT(weight);
    
    public z_VertexWeightPointerEXT := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glVertexWeightPointerEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightPointerEXT(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_VertexWeightPointerEXT(size, &type, stride, _pointer);
    
    {$endregion EXT_vertex_weighting}
    
    {$region EXT_window_rectangles}
    
    public z_WindowRectanglesEXT := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; box: pointer)>('glWindowRectanglesEXT');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; box: array of Int32) := WindowRectanglesEXT(mode, count, box[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; var box: Int32) := WindowRectanglesEXT(mode, count, @box);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; box: pointer) := z_WindowRectanglesEXT(mode, count, box);
    
    {$endregion EXT_window_rectangles}
    
  end;
  
  gl_3DFX = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region 3DFX_tbuffer}
    
    public z_TbufferMask3DFX := GetGLFuncOrNil&<procedure(mask: UInt32)>('glTbufferMask3DFX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TbufferMask3DFX(mask: UInt32) := z_TbufferMask3DFX(mask);
    
    {$endregion 3DFX_tbuffer}
    
  end;
  
  gl_AMD = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region AMD_performance_monitor}
    
    public z_GetPerfMonitorGroupsAMD := GetGLFuncOrNil&<procedure(numGroups: pointer; groupsSize: Int32; groups: pointer)>('glGetPerfMonitorGroupsAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: array of Int32; groupsSize: Int32; groups: array of UInt32) := GetPerfMonitorGroupsAMD(numGroups[0], groupsSize, groups[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: array of Int32; groupsSize: Int32; var groups: UInt32) := GetPerfMonitorGroupsAMD(numGroups[0], groupsSize, @groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: array of Int32; groupsSize: Int32; groups: pointer) := GetPerfMonitorGroupsAMD(numGroups[0], groupsSize, groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(var numGroups: Int32; groupsSize: Int32; groups: array of UInt32) := GetPerfMonitorGroupsAMD(@numGroups, groupsSize, groups[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(var numGroups: Int32; groupsSize: Int32; var groups: UInt32) := GetPerfMonitorGroupsAMD(@numGroups, groupsSize, @groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(var numGroups: Int32; groupsSize: Int32; groups: pointer) := GetPerfMonitorGroupsAMD(@numGroups, groupsSize, groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: pointer; groupsSize: Int32; groups: array of UInt32) := GetPerfMonitorGroupsAMD(numGroups, groupsSize, groups[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: pointer; groupsSize: Int32; var groups: UInt32) := GetPerfMonitorGroupsAMD(numGroups, groupsSize, @groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: pointer; groupsSize: Int32; groups: pointer) := z_GetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
    
    public z_GetPerfMonitorCountersAMD := GetGLFuncOrNil&<procedure(group: UInt32; numCounters: pointer; maxActiveCounters: pointer; counterSize: Int32; counters: pointer)>('glGetPerfMonitorCountersAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: array of Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters[0], counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: array of Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters[0], counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: array of Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters[0], counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], @maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], @maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, numCounters[0], @maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: pointer; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: pointer; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: pointer; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: array of Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters[0], counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: array of Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters[0], counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: array of Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters[0], counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, @maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, @maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, @numCounters, @maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: pointer; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: pointer; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: pointer; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: array of Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters[0], counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: array of Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters[0], counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: array of Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters[0], counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; var maxActiveCounters: Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters, @maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters, @maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; var maxActiveCounters: Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, numCounters, @maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: pointer; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: pointer; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: pointer; counterSize: Int32; counters: pointer) := z_GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
    
    public z_GetPerfMonitorGroupStringAMD := GetGLFuncOrNil&<procedure(group: UInt32; bufSize: Int32; length: pointer; groupString: IntPtr)>('glGetPerfMonitorGroupStringAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: array of Int32; groupString: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(groupString); GetPerfMonitorGroupStringAMD(group, bufSize, length[0], ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: array of Int32; groupString: IntPtr) := GetPerfMonitorGroupStringAMD(group, bufSize, length[0], groupString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; var length: Int32; groupString: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(groupString); GetPerfMonitorGroupStringAMD(group, bufSize, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; var length: Int32; groupString: IntPtr) := GetPerfMonitorGroupStringAMD(group, bufSize, @length, groupString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: pointer; groupString: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(groupString); GetPerfMonitorGroupStringAMD(group, bufSize, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: pointer; groupString: IntPtr) := z_GetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
    
    public z_GetPerfMonitorCounterStringAMD := GetGLFuncOrNil&<procedure(group: UInt32; counter: UInt32; bufSize: Int32; length: pointer; counterString: IntPtr)>('glGetPerfMonitorCounterStringAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: array of Int32; counterString: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(counterString); GetPerfMonitorCounterStringAMD(group, counter, bufSize, length[0], ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: array of Int32; counterString: IntPtr) := GetPerfMonitorCounterStringAMD(group, counter, bufSize, length[0], counterString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; var length: Int32; counterString: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(counterString); GetPerfMonitorCounterStringAMD(group, counter, bufSize, @length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; var length: Int32; counterString: IntPtr) := GetPerfMonitorCounterStringAMD(group, counter, bufSize, @length, counterString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: pointer; counterString: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(counterString); GetPerfMonitorCounterStringAMD(group, counter, bufSize, length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: pointer; counterString: IntPtr) := z_GetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
    
    public z_GetPerfMonitorCounterInfoAMD := GetGLFuncOrNil&<procedure(group: UInt32; counter: UInt32; pname: DummyEnum; data: pointer)>('glGetPerfMonitorCounterInfoAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterInfoAMD(group: UInt32; counter: UInt32; pname: DummyEnum; data: pointer) := z_GetPerfMonitorCounterInfoAMD(group, counter, pname, data);
    
    public z_GenPerfMonitorsAMD := GetGLFuncOrNil&<procedure(n: Int32; monitors: pointer)>('glGenPerfMonitorsAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; monitors: array of UInt32) := GenPerfMonitorsAMD(n, monitors[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; var monitors: UInt32) := GenPerfMonitorsAMD(n, @monitors);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; monitors: pointer) := z_GenPerfMonitorsAMD(n, monitors);
    
    public z_DeletePerfMonitorsAMD := GetGLFuncOrNil&<procedure(n: Int32; monitors: pointer)>('glDeletePerfMonitorsAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; monitors: array of UInt32) := DeletePerfMonitorsAMD(n, monitors[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; var monitors: UInt32) := DeletePerfMonitorsAMD(n, @monitors);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; monitors: pointer) := z_DeletePerfMonitorsAMD(n, monitors);
    
    public z_SelectPerfMonitorCountersAMD := GetGLFuncOrNil&<procedure(monitor: UInt32; enable: boolean; group: UInt32; numCounters: Int32; counterList: pointer)>('glSelectPerfMonitorCountersAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: boolean; group: UInt32; numCounters: Int32; counterList: array of UInt32) := SelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: boolean; group: UInt32; numCounters: Int32; var counterList: UInt32) := SelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, @counterList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: boolean; group: UInt32; numCounters: Int32; counterList: pointer) := z_SelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
    
    public z_BeginPerfMonitorAMD := GetGLFuncOrNil&<procedure(monitor: UInt32)>('glBeginPerfMonitorAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginPerfMonitorAMD(monitor: UInt32) := z_BeginPerfMonitorAMD(monitor);
    
    public z_EndPerfMonitorAMD := GetGLFuncOrNil&<procedure(monitor: UInt32)>('glEndPerfMonitorAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndPerfMonitorAMD(monitor: UInt32) := z_EndPerfMonitorAMD(monitor);
    
    public z_GetPerfMonitorCounterDataAMD := GetGLFuncOrNil&<procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: pointer; bytesWritten: pointer)>('glGetPerfMonitorCounterDataAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: array of UInt32; bytesWritten: array of Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data[0], bytesWritten[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: array of UInt32; var bytesWritten: Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data[0], @bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: array of UInt32; bytesWritten: pointer) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data[0], bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; bytesWritten: array of Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, @data, bytesWritten[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; var bytesWritten: Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, @data, @bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; bytesWritten: pointer) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, @data, bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: pointer; bytesWritten: array of Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: pointer; var bytesWritten: Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, @bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: pointer; bytesWritten: pointer) := z_GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
    
    {$endregion AMD_performance_monitor}
    
    {$region AMD_draw_buffers_blend}
    
    public z_BlendFuncIndexedAMD := GetGLFuncOrNil&<procedure(buf: UInt32; src: DummyEnum; dst: DummyEnum)>('glBlendFuncIndexedAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncIndexedAMD(buf: UInt32; src: DummyEnum; dst: DummyEnum) := z_BlendFuncIndexedAMD(buf, src, dst);
    
    public z_BlendFuncSeparateIndexedAMD := GetGLFuncOrNil&<procedure(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum)>('glBlendFuncSeparateIndexedAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateIndexedAMD(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum) := z_BlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    public z_BlendEquationIndexedAMD := GetGLFuncOrNil&<procedure(buf: UInt32; mode: DummyEnum)>('glBlendEquationIndexedAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationIndexedAMD(buf: UInt32; mode: DummyEnum) := z_BlendEquationIndexedAMD(buf, mode);
    
    public z_BlendEquationSeparateIndexedAMD := GetGLFuncOrNil&<procedure(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum)>('glBlendEquationSeparateIndexedAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateIndexedAMD(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum) := z_BlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
    
    {$endregion AMD_draw_buffers_blend}
    
    {$region AMD_debug_output}
    
    public z_DebugMessageEnableAMD := GetGLFuncOrNil&<procedure(category: DebugSourceType; severity: DebugMessageType; count: Int32; ids: pointer; enabled: boolean)>('glDebugMessageEnableAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DebugSourceType; severity: DebugMessageType; count: Int32; ids: array of UInt32; enabled: boolean) := DebugMessageEnableAMD(category, severity, count, ids[0], enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DebugSourceType; severity: DebugMessageType; count: Int32; var ids: UInt32; enabled: boolean) := DebugMessageEnableAMD(category, severity, count, @ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DebugSourceType; severity: DebugMessageType; count: Int32; ids: pointer; enabled: boolean) := z_DebugMessageEnableAMD(category, severity, count, ids, enabled);
    
    public z_DebugMessageInsertAMD := GetGLFuncOrNil&<procedure(category: DebugSourceType; severity: DebugMessageType; id: UInt32; length: Int32; buf: IntPtr)>('glDebugMessageInsertAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertAMD(category: DebugSourceType; severity: DebugMessageType; id: UInt32; length: Int32; buf: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(buf); DebugMessageInsertAMD(category, severity, id, length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertAMD(category: DebugSourceType; severity: DebugMessageType; id: UInt32; length: Int32; buf: IntPtr) := z_DebugMessageInsertAMD(category, severity, id, length, buf);
    
    public z_DebugMessageCallbackAMD := GetGLFuncOrNil&<procedure(callback: GLDEBUGPROC; userParam: pointer)>('glDebugMessageCallbackAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallbackAMD(callback: GLDEBUGPROC; userParam: pointer) := z_DebugMessageCallbackAMD(callback, userParam);
    
    public z_GetDebugMessageLogAMD := GetGLFuncOrNil&<function(count: UInt32; bufsize: Int32; categories: pointer; severities: pointer; ids: pointer; lengths: pointer; message: IntPtr): UInt32>('glGetDebugMessageLogAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogAMD(count: UInt32; bufsize: Int32; categories: array of DebugMessageCategoryAMD; severities: array of DebugSeverityLevel; ids: array of UInt32; lengths: array of Int32; message: IntPtr): UInt32 := GetDebugMessageLogAMD(count, bufsize, categories[0], severities[0], ids[0], lengths[0], message);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogAMD(count: UInt32; bufsize: Int32; var categories: DebugMessageCategoryAMD; var severities: DebugSeverityLevel; var ids: UInt32; var lengths: Int32; message: string): UInt32; begin var ptr_7 := Marshal.StringToHGlobalAnsi(message); Result := GetDebugMessageLogAMD(count, bufsize, @categories, @severities, @ids, @lengths, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogAMD(count: UInt32; bufsize: Int32; var categories: DebugMessageCategoryAMD; var severities: DebugSeverityLevel; var ids: UInt32; var lengths: Int32; message: IntPtr): UInt32 := GetDebugMessageLogAMD(count, bufsize, @categories, @severities, @ids, @lengths, message);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogAMD(count: UInt32; bufsize: Int32; categories: pointer; severities: pointer; ids: pointer; lengths: pointer; message: string): UInt32; begin var ptr_7 := Marshal.StringToHGlobalAnsi(message); Result := GetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogAMD(count: UInt32; bufsize: Int32; categories: pointer; severities: pointer; ids: pointer; lengths: pointer; message: IntPtr): UInt32 := z_GetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths, message);
    
    {$endregion AMD_debug_output}
    
    {$region AMD_name_gen_delete}
    
    public z_GenNamesAMD := GetGLFuncOrNil&<procedure(identifier: DummyEnum; num: UInt32; names: pointer)>('glGenNamesAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; names: array of UInt32) := GenNamesAMD(identifier, num, names[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; var names: UInt32) := GenNamesAMD(identifier, num, @names);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; names: pointer) := z_GenNamesAMD(identifier, num, names);
    
    public z_DeleteNamesAMD := GetGLFuncOrNil&<procedure(identifier: DummyEnum; num: UInt32; names: pointer)>('glDeleteNamesAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; names: array of UInt32) := DeleteNamesAMD(identifier, num, names[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; var names: UInt32) := DeleteNamesAMD(identifier, num, @names);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; names: pointer) := z_DeleteNamesAMD(identifier, num, names);
    
    public z_IsNameAMD := GetGLFuncOrNil&<function(identifier: DummyEnum; name: UInt32): boolean>('glIsNameAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNameAMD(identifier: DummyEnum; name: UInt32): boolean := z_IsNameAMD(identifier, name);
    
    {$endregion AMD_name_gen_delete}
    
    {$region AMD_framebuffer_sample_positions}
    
    public z_FramebufferSamplePositionsfvAMD := GetGLFuncOrNil&<procedure(target: DummyEnum; numsamples: UInt32; pixelindex: UInt32; values: pointer)>('glFramebufferSamplePositionsfvAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: DummyEnum; numsamples: UInt32; pixelindex: UInt32; values: array of single) := FramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: DummyEnum; numsamples: UInt32; pixelindex: UInt32; var values: single) := FramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: DummyEnum; numsamples: UInt32; pixelindex: UInt32; values: pointer) := z_FramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, values);
    
    public z_NamedFramebufferSamplePositionsfvAMD := GetGLFuncOrNil&<procedure(framebuffer: UInt32; numsamples: UInt32; pixelindex: UInt32; values: pointer)>('glNamedFramebufferSamplePositionsfvAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: UInt32; numsamples: UInt32; pixelindex: UInt32; values: array of single) := NamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: UInt32; numsamples: UInt32; pixelindex: UInt32; var values: single) := NamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: UInt32; numsamples: UInt32; pixelindex: UInt32; values: pointer) := z_NamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, values);
    
    public z_GetFramebufferParameterfvAMD := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: pointer)>('glGetFramebufferParameterfvAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterfvAMD(target: DummyEnum; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: array of single) := GetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterfvAMD(target: DummyEnum; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single) := GetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterfvAMD(target: DummyEnum; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: pointer) := z_GetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, values);
    
    public z_GetNamedFramebufferParameterfvAMD := GetGLFuncOrNil&<procedure(framebuffer: UInt32; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: pointer)>('glGetNamedFramebufferParameterfvAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterfvAMD(framebuffer: UInt32; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: array of single) := GetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterfvAMD(framebuffer: UInt32; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single) := GetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterfvAMD(framebuffer: UInt32; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: pointer) := z_GetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, values);
    
    {$endregion AMD_framebuffer_sample_positions}
    
    {$region AMD_multi_draw_indirect}
    
    public z_MultiDrawArraysIndirectAMD := GetGLFuncOrNil&<procedure(mode: DummyEnum; indirect: pointer; primcount: Int32; stride: Int32)>('glMultiDrawArraysIndirectAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectAMD(mode: DummyEnum; indirect: pointer; primcount: Int32; stride: Int32) := z_MultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);
    
    public z_MultiDrawElementsIndirectAMD := GetGLFuncOrNil&<procedure(mode: DummyEnum; &type: DummyEnum; indirect: pointer; primcount: Int32; stride: Int32)>('glMultiDrawElementsIndirectAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectAMD(mode: DummyEnum; &type: DummyEnum; indirect: pointer; primcount: Int32; stride: Int32) := z_MultiDrawElementsIndirectAMD(mode, &type, indirect, primcount, stride);
    
    {$endregion AMD_multi_draw_indirect}
    
    {$region AMD_framebuffer_multisample_advanced}
    
    public z_RenderbufferStorageMultisampleAdvancedAMD := GetGLFuncOrNil&<procedure(target: DummyEnum; samples: Int32; storageSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glRenderbufferStorageMultisampleAdvancedAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleAdvancedAMD(target: DummyEnum; samples: Int32; storageSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageMultisampleAdvancedAMD(target, samples, storageSamples, internalformat, width, height);
    
    public z_NamedRenderbufferStorageMultisampleAdvancedAMD := GetGLFuncOrNil&<procedure(renderbuffer: UInt32; samples: Int32; storageSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glNamedRenderbufferStorageMultisampleAdvancedAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer: UInt32; samples: Int32; storageSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_NamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer, samples, storageSamples, internalformat, width, height);
    
    {$endregion AMD_framebuffer_multisample_advanced}
    
    {$region AMD_occlusion_query_event}
    
    public z_QueryObjectParameteruiAMD := GetGLFuncOrNil&<procedure(target: DummyEnum; id: UInt32; pname: DummyEnum; param: UInt32)>('glQueryObjectParameteruiAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryObjectParameteruiAMD(target: DummyEnum; id: UInt32; pname: DummyEnum; param: UInt32) := z_QueryObjectParameteruiAMD(target, id, pname, param);
    
    {$endregion AMD_occlusion_query_event}
    
    {$region AMD_sample_positions}
    
    public z_SetMultisamplefvAMD := GetGLFuncOrNil&<procedure(pname: DummyEnum; index: UInt32; val: pointer)>('glSetMultisamplefvAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; val: array of single) := SetMultisamplefvAMD(pname, index, val[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; var val: single) := SetMultisamplefvAMD(pname, index, @val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; val: pointer) := z_SetMultisamplefvAMD(pname, index, val);
    
    {$endregion AMD_sample_positions}
    
    {$region AMD_stencil_operation_extended}
    
    public z_StencilOpValueAMD := GetGLFuncOrNil&<procedure(face: DummyEnum; value: UInt32)>('glStencilOpValueAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOpValueAMD(face: DummyEnum; value: UInt32) := z_StencilOpValueAMD(face, value);
    
    {$endregion AMD_stencil_operation_extended}
    
    {$region AMD_vertex_shader_tessellator}
    
    public z_TessellationFactorAMD := GetGLFuncOrNil&<procedure(factor: single)>('glTessellationFactorAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TessellationFactorAMD(factor: single) := z_TessellationFactorAMD(factor);
    
    public z_TessellationModeAMD := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glTessellationModeAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TessellationModeAMD(mode: DummyEnum) := z_TessellationModeAMD(mode);
    
    {$endregion AMD_vertex_shader_tessellator}
    
    {$region AMD_sparse_texture}
    
    public z_TexStorageSparseAMD := GetGLFuncOrNil&<procedure(target: DummyEnum; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: DummyFlags)>('glTexStorageSparseAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageSparseAMD(target: DummyEnum; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: DummyFlags) := z_TexStorageSparseAMD(target, internalFormat, width, height, depth, layers, flags);
    
    public z_TextureStorageSparseAMD := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: DummyFlags)>('glTextureStorageSparseAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageSparseAMD(texture: UInt32; target: DummyEnum; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: DummyFlags) := z_TextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, flags);
    
    {$endregion AMD_sparse_texture}
    
    {$region AMD_interleaved_elements}
    
    public z_VertexAttribParameteriAMD := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; param: Int32)>('glVertexAttribParameteriAMD');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribParameteriAMD(index: UInt32; pname: DummyEnum; param: Int32) := z_VertexAttribParameteriAMD(index, pname, param);
    
    {$endregion AMD_interleaved_elements}
    
  end;
  
  gl_ANGLE = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region ANGLE_framebuffer_blit}
    
    public z_BlitFramebufferANGLE := GetGLFuncOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>('glBlitFramebufferANGLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebufferANGLE(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := z_BlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    {$endregion ANGLE_framebuffer_blit}
    
    {$region ANGLE_instanced_arrays}
    
    public z_DrawArraysInstancedANGLE := GetGLFuncOrNil&<procedure(mode: DummyEnum; first: Int32; count: Int32; primcount: Int32)>('glDrawArraysInstancedANGLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedANGLE(mode: DummyEnum; first: Int32; count: Int32; primcount: Int32) := z_DrawArraysInstancedANGLE(mode, first, count, primcount);
    
    public z_DrawElementsInstancedANGLE := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32)>('glDrawElementsInstancedANGLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedANGLE(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32) := z_DrawElementsInstancedANGLE(mode, count, &type, indices, primcount);
    
    public z_VertexAttribDivisorANGLE := GetGLFuncOrNil&<procedure(index: UInt32; divisor: UInt32)>('glVertexAttribDivisorANGLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribDivisorANGLE(index: UInt32; divisor: UInt32) := z_VertexAttribDivisorANGLE(index, divisor);
    
    {$endregion ANGLE_instanced_arrays}
    
    {$region ANGLE_translated_shader_source}
    
    public z_GetTranslatedShaderSourceANGLE := GetGLFuncOrNil&<procedure(shader: UInt32; bufsize: Int32; length: pointer; source: IntPtr)>('glGetTranslatedShaderSourceANGLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; length: array of Int32; source: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(source); GetTranslatedShaderSourceANGLE(shader, bufsize, length[0], ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; length: array of Int32; source: IntPtr) := GetTranslatedShaderSourceANGLE(shader, bufsize, length[0], source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; var length: Int32; source: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(source); GetTranslatedShaderSourceANGLE(shader, bufsize, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; var length: Int32; source: IntPtr) := GetTranslatedShaderSourceANGLE(shader, bufsize, @length, source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; length: pointer; source: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(source); GetTranslatedShaderSourceANGLE(shader, bufsize, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; length: pointer; source: IntPtr) := z_GetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
    
    {$endregion ANGLE_translated_shader_source}
    
    {$region ANGLE_framebuffer_multisample}
    
    public z_RenderbufferStorageMultisampleANGLE := GetGLFuncOrNil&<procedure(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glRenderbufferStorageMultisampleANGLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleANGLE(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);
    
    {$endregion ANGLE_framebuffer_multisample}
    
  end;
  
  gl_APPLE = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region APPLE_vertex_array_object}
    
    public z_BindVertexArrayAPPLE := GetGLFuncOrNil&<procedure(&array: UInt32)>('glBindVertexArrayAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexArrayAPPLE(&array: UInt32) := z_BindVertexArrayAPPLE(&array);
    
    public z_DeleteVertexArraysAPPLE := GetGLFuncOrNil&<procedure(n: Int32; arrays: pointer)>('glDeleteVertexArraysAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysAPPLE(n: Int32; arrays: array of UInt32) := DeleteVertexArraysAPPLE(n, arrays[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysAPPLE(n: Int32; var arrays: UInt32) := DeleteVertexArraysAPPLE(n, @arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysAPPLE(n: Int32; arrays: pointer) := z_DeleteVertexArraysAPPLE(n, arrays);
    
    public z_GenVertexArraysAPPLE := GetGLFuncOrNil&<procedure(n: Int32; arrays: pointer)>('glGenVertexArraysAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysAPPLE(n: Int32; arrays: array of UInt32) := GenVertexArraysAPPLE(n, arrays[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysAPPLE(n: Int32; var arrays: UInt32) := GenVertexArraysAPPLE(n, @arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysAPPLE(n: Int32; arrays: pointer) := z_GenVertexArraysAPPLE(n, arrays);
    
    public z_IsVertexArrayAPPLE := GetGLFuncOrNil&<function(&array: UInt32): boolean>('glIsVertexArrayAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexArrayAPPLE(&array: UInt32): boolean := z_IsVertexArrayAPPLE(&array);
    
    {$endregion APPLE_vertex_array_object}
    
    {$region APPLE_flush_buffer_range}
    
    public z_BufferParameteriAPPLE := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>('glBufferParameteriAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferParameteriAPPLE(target: DummyEnum; pname: DummyEnum; param: Int32) := z_BufferParameteriAPPLE(target, pname, param);
    
    public z_FlushMappedBufferRangeAPPLE := GetGLFuncOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr)>('glFlushMappedBufferRangeAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushMappedBufferRangeAPPLE(target: DummyEnum; offset: IntPtr; size: UIntPtr) := z_FlushMappedBufferRangeAPPLE(target, offset, size);
    
    {$endregion APPLE_flush_buffer_range}
    
    {$region APPLE_sync}
    
    public z_FenceSyncAPPLE := GetGLFuncOrNil&<function(condition: DummyEnum; flags: DummyFlags): GLsync>('glFenceSyncAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FenceSyncAPPLE(condition: DummyEnum; flags: DummyFlags): GLsync := z_FenceSyncAPPLE(condition, flags);
    
    public z_IsSyncAPPLE := GetGLFuncOrNil&<function(sync: GLsync): boolean>('glIsSyncAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSyncAPPLE(sync: GLsync): boolean := z_IsSyncAPPLE(sync);
    
    public z_DeleteSyncAPPLE := GetGLFuncOrNil&<procedure(sync: GLsync)>('glDeleteSyncAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSyncAPPLE(sync: GLsync) := z_DeleteSyncAPPLE(sync);
    
    public z_ClientWaitSyncAPPLE := GetGLFuncOrNil&<function(sync: GLsync; flags: DummyFlags; timeout: UInt64): DummyEnum>('glClientWaitSyncAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ClientWaitSyncAPPLE(sync: GLsync; flags: DummyFlags; timeout: UInt64): DummyEnum := z_ClientWaitSyncAPPLE(sync, flags, timeout);
    
    public z_WaitSyncAPPLE := GetGLFuncOrNil&<procedure(sync: GLsync; flags: DummyFlags; timeout: UInt64)>('glWaitSyncAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSyncAPPLE(sync: GLsync; flags: DummyFlags; timeout: UInt64) := z_WaitSyncAPPLE(sync, flags, timeout);
    
    public z_GetInteger64vAPPLE := GetGLFuncOrNil&<procedure(pname: GLGetQueries; &params: pointer)>('glGetInteger64vAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64vAPPLE(pname: GLGetQueries; &params: array of Int64) := GetInteger64vAPPLE(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64vAPPLE(pname: GLGetQueries; var &params: Int64) := GetInteger64vAPPLE(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInteger64vAPPLE(pname: GLGetQueries; &params: pointer) := z_GetInteger64vAPPLE(pname, &params);
    
    public z_GetSyncivAPPLE := GetGLFuncOrNil&<procedure(sync: GLsync; pname: DummyEnum; bufSize: Int32; length: pointer; values: pointer)>('glGetSyncivAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSyncivAPPLE(sync: GLsync; pname: DummyEnum; bufSize: Int32; length: array of Int32; values: array of Int32) := GetSyncivAPPLE(sync, pname, bufSize, length[0], values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSyncivAPPLE(sync: GLsync; pname: DummyEnum; bufSize: Int32; length: array of Int32; var values: Int32) := GetSyncivAPPLE(sync, pname, bufSize, length[0], @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSyncivAPPLE(sync: GLsync; pname: DummyEnum; bufSize: Int32; length: array of Int32; values: pointer) := GetSyncivAPPLE(sync, pname, bufSize, length[0], values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSyncivAPPLE(sync: GLsync; pname: DummyEnum; bufSize: Int32; var length: Int32; values: array of Int32) := GetSyncivAPPLE(sync, pname, bufSize, @length, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSyncivAPPLE(sync: GLsync; pname: DummyEnum; bufSize: Int32; var length: Int32; var values: Int32) := GetSyncivAPPLE(sync, pname, bufSize, @length, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSyncivAPPLE(sync: GLsync; pname: DummyEnum; bufSize: Int32; var length: Int32; values: pointer) := GetSyncivAPPLE(sync, pname, bufSize, @length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSyncivAPPLE(sync: GLsync; pname: DummyEnum; bufSize: Int32; length: pointer; values: array of Int32) := GetSyncivAPPLE(sync, pname, bufSize, length, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSyncivAPPLE(sync: GLsync; pname: DummyEnum; bufSize: Int32; length: pointer; var values: Int32) := GetSyncivAPPLE(sync, pname, bufSize, length, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSyncivAPPLE(sync: GLsync; pname: DummyEnum; bufSize: Int32; length: pointer; values: pointer) := z_GetSyncivAPPLE(sync, pname, bufSize, length, values);
    
    {$endregion APPLE_sync}
    
    {$region APPLE_copy_texture_levels}
    
    public z_CopyTextureLevelsAPPLE := GetGLFuncOrNil&<procedure(destinationTexture: UInt32; sourceTexture: UInt32; sourceBaseLevel: Int32; sourceLevelCount: Int32)>('glCopyTextureLevelsAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureLevelsAPPLE(destinationTexture: UInt32; sourceTexture: UInt32; sourceBaseLevel: Int32; sourceLevelCount: Int32) := z_CopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
    
    {$endregion APPLE_copy_texture_levels}
    
    {$region APPLE_fence}
    
    public z_GenFencesAPPLE := GetGLFuncOrNil&<procedure(n: Int32; fences: pointer)>('glGenFencesAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; fences: array of UInt32) := GenFencesAPPLE(n, fences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; var fences: UInt32) := GenFencesAPPLE(n, @fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; fences: pointer) := z_GenFencesAPPLE(n, fences);
    
    public z_DeleteFencesAPPLE := GetGLFuncOrNil&<procedure(n: Int32; fences: pointer)>('glDeleteFencesAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; fences: array of UInt32) := DeleteFencesAPPLE(n, fences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; var fences: UInt32) := DeleteFencesAPPLE(n, @fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; fences: pointer) := z_DeleteFencesAPPLE(n, fences);
    
    public z_SetFenceAPPLE := GetGLFuncOrNil&<procedure(fence: UInt32)>('glSetFenceAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFenceAPPLE(fence: UInt32) := z_SetFenceAPPLE(fence);
    
    public z_IsFenceAPPLE := GetGLFuncOrNil&<function(fence: UInt32): boolean>('glIsFenceAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFenceAPPLE(fence: UInt32): boolean := z_IsFenceAPPLE(fence);
    
    public z_TestFenceAPPLE := GetGLFuncOrNil&<function(fence: UInt32): boolean>('glTestFenceAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestFenceAPPLE(fence: UInt32): boolean := z_TestFenceAPPLE(fence);
    
    public z_FinishFenceAPPLE := GetGLFuncOrNil&<procedure(fence: UInt32)>('glFinishFenceAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishFenceAPPLE(fence: UInt32) := z_FinishFenceAPPLE(fence);
    
    public z_TestObjectAPPLE := GetGLFuncOrNil&<function(object: DummyEnum; name: UInt32): boolean>('glTestObjectAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestObjectAPPLE(object: DummyEnum; name: UInt32): boolean := z_TestObjectAPPLE(object, name);
    
    public z_FinishObjectAPPLE := GetGLFuncOrNil&<procedure(object: DummyEnum; name: Int32)>('glFinishObjectAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishObjectAPPLE(object: DummyEnum; name: Int32) := z_FinishObjectAPPLE(object, name);
    
    {$endregion APPLE_fence}
    
    {$region APPLE_vertex_program_evaluators}
    
    public z_EnableVertexAttribAPPLE := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum)>('glEnableVertexAttribAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribAPPLE(index: UInt32; pname: DummyEnum) := z_EnableVertexAttribAPPLE(index, pname);
    
    public z_DisableVertexAttribAPPLE := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum)>('glDisableVertexAttribAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribAPPLE(index: UInt32; pname: DummyEnum) := z_DisableVertexAttribAPPLE(index, pname);
    
    public z_IsVertexAttribEnabledAPPLE := GetGLFuncOrNil&<function(index: UInt32; pname: DummyEnum): boolean>('glIsVertexAttribEnabledAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexAttribEnabledAPPLE(index: UInt32; pname: DummyEnum): boolean := z_IsVertexAttribEnabledAPPLE(index, pname);
    
    public z_MapVertexAttrib1dAPPLE := GetGLFuncOrNil&<procedure(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: pointer)>('glMapVertexAttrib1dAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: array of double) := MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; var points: double) := MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: pointer) := z_MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
    
    public z_MapVertexAttrib1fAPPLE := GetGLFuncOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: pointer)>('glMapVertexAttrib1fAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: array of single) := MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; var points: single) := MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: pointer) := z_MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
    
    public z_MapVertexAttrib2dAPPLE := GetGLFuncOrNil&<procedure(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: pointer)>('glMapVertexAttrib2dAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: array of double) := MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; var points: double) := MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: pointer) := z_MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    public z_MapVertexAttrib2fAPPLE := GetGLFuncOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: pointer)>('glMapVertexAttrib2fAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: array of single) := MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single) := MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: pointer) := z_MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    {$endregion APPLE_vertex_program_evaluators}
    
    {$region APPLE_element_array}
    
    public z_ElementPointerAPPLE := GetGLFuncOrNil&<procedure(&type: DummyEnum; _pointer: pointer)>('glElementPointerAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ElementPointerAPPLE(&type: DummyEnum; _pointer: pointer) := z_ElementPointerAPPLE(&type, _pointer);
    
    public z_DrawElementArrayAPPLE := GetGLFuncOrNil&<procedure(mode: DummyEnum; first: Int32; count: Int32)>('glDrawElementArrayAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementArrayAPPLE(mode: DummyEnum; first: Int32; count: Int32) := z_DrawElementArrayAPPLE(mode, first, count);
    
    public z_DrawRangeElementArrayAPPLE := GetGLFuncOrNil&<procedure(mode: DummyEnum; start: UInt32; &end: UInt32; first: Int32; count: Int32)>('glDrawRangeElementArrayAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: Int32; count: Int32) := z_DrawRangeElementArrayAPPLE(mode, start, &end, first, count);
    
    public z_MultiDrawElementArrayAPPLE := GetGLFuncOrNil&<procedure(mode: DummyEnum; first: pointer; count: pointer; primcount: Int32)>('glMultiDrawElementArrayAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: array of Int32; count: array of Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, first[0], count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: array of Int32; var count: Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, first[0], @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: array of Int32; count: pointer; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, first[0], count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; var first: Int32; count: array of Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, @first, count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; var first: Int32; var count: Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, @first, @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; var first: Int32; count: pointer; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, @first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: pointer; count: array of Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, first, count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: pointer; var count: Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, first, @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: pointer; count: pointer; primcount: Int32) := z_MultiDrawElementArrayAPPLE(mode, first, count, primcount);
    
    public z_MultiDrawRangeElementArrayAPPLE := GetGLFuncOrNil&<procedure(mode: DummyEnum; start: UInt32; &end: UInt32; first: pointer; count: pointer; primcount: Int32)>('glMultiDrawRangeElementArrayAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: array of Int32; count: array of Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, first[0], count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: array of Int32; var count: Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, first[0], @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: array of Int32; count: pointer; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, first[0], count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; var first: Int32; count: array of Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, @first, count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; var first: Int32; var count: Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, @first, @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; var first: Int32; count: pointer; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, @first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: pointer; count: array of Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, first, count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: pointer; var count: Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, first, @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: pointer; count: pointer; primcount: Int32) := z_MultiDrawRangeElementArrayAPPLE(mode, start, &end, first, count, primcount);
    
    {$endregion APPLE_element_array}
    
    {$region APPLE_vertex_array_range}
    
    public z_VertexArrayRangeAPPLE := GetGLFuncOrNil&<procedure(length: Int32; _pointer: pointer)>('glVertexArrayRangeAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayRangeAPPLE(length: Int32; _pointer: pointer) := z_VertexArrayRangeAPPLE(length, _pointer);
    
    public z_FlushVertexArrayRangeAPPLE := GetGLFuncOrNil&<procedure(length: Int32; _pointer: pointer)>('glFlushVertexArrayRangeAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushVertexArrayRangeAPPLE(length: Int32; _pointer: pointer) := z_FlushVertexArrayRangeAPPLE(length, _pointer);
    
    public z_VertexArrayParameteriAPPLE := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: Int32)>('glVertexArrayParameteriAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayParameteriAPPLE(pname: DummyEnum; param: Int32) := z_VertexArrayParameteriAPPLE(pname, param);
    
    {$endregion APPLE_vertex_array_range}
    
    {$region APPLE_object_purgeable}
    
    public z_ObjectPurgeableAPPLE := GetGLFuncOrNil&<function(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum>('glObjectPurgeableAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ObjectPurgeableAPPLE(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum := z_ObjectPurgeableAPPLE(objectType, name, option);
    
    public z_ObjectUnpurgeableAPPLE := GetGLFuncOrNil&<function(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum>('glObjectUnpurgeableAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ObjectUnpurgeableAPPLE(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum := z_ObjectUnpurgeableAPPLE(objectType, name, option);
    
    public z_GetObjectParameterivAPPLE := GetGLFuncOrNil&<procedure(objectType: DummyEnum; name: UInt32; pname: DummyEnum; &params: pointer)>('glGetObjectParameterivAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivAPPLE(objectType: DummyEnum; name: UInt32; pname: DummyEnum; &params: array of Int32) := GetObjectParameterivAPPLE(objectType, name, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivAPPLE(objectType: DummyEnum; name: UInt32; pname: DummyEnum; var &params: Int32) := GetObjectParameterivAPPLE(objectType, name, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivAPPLE(objectType: DummyEnum; name: UInt32; pname: DummyEnum; &params: pointer) := z_GetObjectParameterivAPPLE(objectType, name, pname, &params);
    
    {$endregion APPLE_object_purgeable}
    
    {$region APPLE_texture_range}
    
    public z_TextureRangeAPPLE := GetGLFuncOrNil&<procedure(target: DummyEnum; length: Int32; _pointer: pointer)>('glTextureRangeAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureRangeAPPLE(target: DummyEnum; length: Int32; _pointer: pointer) := z_TextureRangeAPPLE(target, length, _pointer);
    
    public z_GetTexParameterPointervAPPLE := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexParameterPointervAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterPointervAPPLE(target: DummyEnum; pname: DummyEnum; &params: array of IntPtr) := GetTexParameterPointervAPPLE(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterPointervAPPLE(target: DummyEnum; pname: DummyEnum; var &params: IntPtr) := GetTexParameterPointervAPPLE(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterPointervAPPLE(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexParameterPointervAPPLE(target, pname, &params);
    
    {$endregion APPLE_texture_range}
    
    {$region APPLE_framebuffer_multisample}
    
    public z_RenderbufferStorageMultisampleAPPLE := GetGLFuncOrNil&<procedure(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glRenderbufferStorageMultisampleAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleAPPLE(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageMultisampleAPPLE(target, samples, internalformat, width, height);
    
    public z_ResolveMultisampleFramebufferAPPLE := GetGLFuncOrNil&<procedure>('glResolveMultisampleFramebufferAPPLE');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResolveMultisampleFramebufferAPPLE := z_ResolveMultisampleFramebufferAPPLE;
    
    {$endregion APPLE_framebuffer_multisample}
    
  end;
  
  gl_ATI = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region ATI_fragment_shader}
    
    public z_GenFragmentShadersATI := GetGLFuncOrNil&<function(range: UInt32): UInt32>('glGenFragmentShadersATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenFragmentShadersATI(range: UInt32): UInt32 := z_GenFragmentShadersATI(range);
    
    public z_BindFragmentShaderATI := GetGLFuncOrNil&<procedure(id: UInt32)>('glBindFragmentShaderATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragmentShaderATI(id: UInt32) := z_BindFragmentShaderATI(id);
    
    public z_DeleteFragmentShaderATI := GetGLFuncOrNil&<procedure(id: UInt32)>('glDeleteFragmentShaderATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFragmentShaderATI(id: UInt32) := z_DeleteFragmentShaderATI(id);
    
    public z_BeginFragmentShaderATI := GetGLFuncOrNil&<procedure>('glBeginFragmentShaderATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginFragmentShaderATI := z_BeginFragmentShaderATI;
    
    public z_EndFragmentShaderATI := GetGLFuncOrNil&<procedure>('glEndFragmentShaderATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndFragmentShaderATI := z_EndFragmentShaderATI;
    
    public z_PassTexCoordATI := GetGLFuncOrNil&<procedure(dst: UInt32; coord: UInt32; swizzle: DummyEnum)>('glPassTexCoordATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassTexCoordATI(dst: UInt32; coord: UInt32; swizzle: DummyEnum) := z_PassTexCoordATI(dst, coord, swizzle);
    
    public z_SampleMapATI := GetGLFuncOrNil&<procedure(dst: UInt32; interp: UInt32; swizzle: DummyEnum)>('glSampleMapATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMapATI(dst: UInt32; interp: UInt32; swizzle: DummyEnum) := z_SampleMapATI(dst, interp, swizzle);
    
    public z_ColorFragmentOp1ATI := GetGLFuncOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32)>('glColorFragmentOp1ATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp1ATI(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32) := z_ColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
    
    public z_ColorFragmentOp2ATI := GetGLFuncOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32)>('glColorFragmentOp2ATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp2ATI(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32) := z_ColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    
    public z_ColorFragmentOp3ATI := GetGLFuncOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32)>('glColorFragmentOp3ATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp3ATI(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32) := z_ColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    
    public z_AlphaFragmentOp1ATI := GetGLFuncOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32)>('glAlphaFragmentOp1ATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp1ATI(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32) := z_AlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
    
    public z_AlphaFragmentOp2ATI := GetGLFuncOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32)>('glAlphaFragmentOp2ATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp2ATI(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32) := z_AlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    
    public z_AlphaFragmentOp3ATI := GetGLFuncOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32)>('glAlphaFragmentOp3ATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp3ATI(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32) := z_AlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    
    public z_SetFragmentShaderConstantATI := GetGLFuncOrNil&<procedure(dst: UInt32; value: pointer)>('glSetFragmentShaderConstantATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: UInt32; value: array of single) := SetFragmentShaderConstantATI(dst, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: UInt32; var value: single) := SetFragmentShaderConstantATI(dst, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: UInt32; value: pointer) := z_SetFragmentShaderConstantATI(dst, value);
    
    {$endregion ATI_fragment_shader}
    
    {$region ATI_vertex_array_object}
    
    public z_NewObjectBufferATI := GetGLFuncOrNil&<function(size: Int32; _pointer: pointer; usage: DummyEnum): UInt32>('glNewObjectBufferATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function NewObjectBufferATI(size: Int32; _pointer: pointer; usage: DummyEnum): UInt32 := z_NewObjectBufferATI(size, _pointer, usage);
    
    public z_IsObjectBufferATI := GetGLFuncOrNil&<function(buffer: UInt32): boolean>('glIsObjectBufferATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsObjectBufferATI(buffer: UInt32): boolean := z_IsObjectBufferATI(buffer);
    
    public z_UpdateObjectBufferATI := GetGLFuncOrNil&<procedure(buffer: UInt32; offset: UInt32; size: Int32; _pointer: pointer; preserve: DummyEnum)>('glUpdateObjectBufferATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UpdateObjectBufferATI(buffer: UInt32; offset: UInt32; size: Int32; _pointer: pointer; preserve: DummyEnum) := z_UpdateObjectBufferATI(buffer, offset, size, _pointer, preserve);
    
    public z_GetObjectBufferfvATI := GetGLFuncOrNil&<procedure(buffer: UInt32; pname: DummyEnum; &params: pointer)>('glGetObjectBufferfvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferfvATI(buffer: UInt32; pname: DummyEnum; &params: array of single) := GetObjectBufferfvATI(buffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferfvATI(buffer: UInt32; pname: DummyEnum; var &params: single) := GetObjectBufferfvATI(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferfvATI(buffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetObjectBufferfvATI(buffer, pname, &params);
    
    public z_GetObjectBufferivATI := GetGLFuncOrNil&<procedure(buffer: UInt32; pname: DummyEnum; &params: pointer)>('glGetObjectBufferivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferivATI(buffer: UInt32; pname: DummyEnum; &params: array of Int32) := GetObjectBufferivATI(buffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferivATI(buffer: UInt32; pname: DummyEnum; var &params: Int32) := GetObjectBufferivATI(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferivATI(buffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetObjectBufferivATI(buffer, pname, &params);
    
    public z_FreeObjectBufferATI := GetGLFuncOrNil&<procedure(buffer: UInt32)>('glFreeObjectBufferATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeObjectBufferATI(buffer: UInt32) := z_FreeObjectBufferATI(buffer);
    
    public z_ArrayObjectATI := GetGLFuncOrNil&<procedure(&array: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; buffer: UInt32; offset: UInt32)>('glArrayObjectATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayObjectATI(&array: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; buffer: UInt32; offset: UInt32) := z_ArrayObjectATI(&array, size, &type, stride, buffer, offset);
    
    public z_GetArrayObjectfvATI := GetGLFuncOrNil&<procedure(&array: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetArrayObjectfvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectfvATI(&array: DummyEnum; pname: DummyEnum; &params: array of single) := GetArrayObjectfvATI(&array, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectfvATI(&array: DummyEnum; pname: DummyEnum; var &params: single) := GetArrayObjectfvATI(&array, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectfvATI(&array: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetArrayObjectfvATI(&array, pname, &params);
    
    public z_GetArrayObjectivATI := GetGLFuncOrNil&<procedure(&array: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetArrayObjectivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectivATI(&array: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetArrayObjectivATI(&array, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectivATI(&array: DummyEnum; pname: DummyEnum; var &params: Int32) := GetArrayObjectivATI(&array, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectivATI(&array: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetArrayObjectivATI(&array, pname, &params);
    
    public z_VariantArrayObjectATI := GetGLFuncOrNil&<procedure(id: UInt32; &type: DummyEnum; stride: Int32; buffer: UInt32; offset: UInt32)>('glVariantArrayObjectATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantArrayObjectATI(id: UInt32; &type: DummyEnum; stride: Int32; buffer: UInt32; offset: UInt32) := z_VariantArrayObjectATI(id, &type, stride, buffer, offset);
    
    public z_GetVariantArrayObjectfvATI := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetVariantArrayObjectfvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectfvATI(id: UInt32; pname: DummyEnum; &params: array of single) := GetVariantArrayObjectfvATI(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectfvATI(id: UInt32; pname: DummyEnum; var &params: single) := GetVariantArrayObjectfvATI(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectfvATI(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetVariantArrayObjectfvATI(id, pname, &params);
    
    public z_GetVariantArrayObjectivATI := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetVariantArrayObjectivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectivATI(id: UInt32; pname: DummyEnum; &params: array of Int32) := GetVariantArrayObjectivATI(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectivATI(id: UInt32; pname: DummyEnum; var &params: Int32) := GetVariantArrayObjectivATI(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectivATI(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetVariantArrayObjectivATI(id, pname, &params);
    
    {$endregion ATI_vertex_array_object}
    
    {$region ATI_vertex_streams}
    
    public z_VertexStream1sATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: Int16)>('glVertexStream1sATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1sATI(stream: DummyEnum; x: Int16) := z_VertexStream1sATI(stream, x);
    
    public z_VertexStream1iATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: Int32)>('glVertexStream1iATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1iATI(stream: DummyEnum; x: Int32) := z_VertexStream1iATI(stream, x);
    
    public z_VertexStream1fATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: single)>('glVertexStream1fATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fATI(stream: DummyEnum; x: single) := z_VertexStream1fATI(stream, x);
    
    public z_VertexStream1dATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: double)>('glVertexStream1dATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dATI(stream: DummyEnum; x: double) := z_VertexStream1dATI(stream, x);
    
    public z_VertexStream2sATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: Int16; y: Int16)>('glVertexStream2sATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2sATI(stream: DummyEnum; x: Int16; y: Int16) := z_VertexStream2sATI(stream, x, y);
    
    public z_VertexStream2iATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: Int32; y: Int32)>('glVertexStream2iATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2iATI(stream: DummyEnum; x: Int32; y: Int32) := z_VertexStream2iATI(stream, x, y);
    
    public z_VertexStream2fATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: single; y: single)>('glVertexStream2fATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fATI(stream: DummyEnum; x: single; y: single) := z_VertexStream2fATI(stream, x, y);
    
    public z_VertexStream2dATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: double; y: double)>('glVertexStream2dATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dATI(stream: DummyEnum; x: double; y: double) := z_VertexStream2dATI(stream, x, y);
    
    public z_VertexStream3sATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: Int16; y: Int16; z: Int16)>('glVertexStream3sATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3sATI(stream: DummyEnum; x: Int16; y: Int16; z: Int16) := z_VertexStream3sATI(stream, x, y, z);
    
    public z_VertexStream3iATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: Int32; y: Int32; z: Int32)>('glVertexStream3iATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3iATI(stream: DummyEnum; x: Int32; y: Int32; z: Int32) := z_VertexStream3iATI(stream, x, y, z);
    
    public z_VertexStream3fATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: single; y: single; z: single)>('glVertexStream3fATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fATI(stream: DummyEnum; x: single; y: single; z: single) := z_VertexStream3fATI(stream, x, y, z);
    
    public z_VertexStream3dATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: double; y: double; z: double)>('glVertexStream3dATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dATI(stream: DummyEnum; x: double; y: double; z: double) := z_VertexStream3dATI(stream, x, y, z);
    
    public z_VertexStream4sATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: Int16; y: Int16; z: Int16; w: Int16)>('glVertexStream4sATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4sATI(stream: DummyEnum; x: Int16; y: Int16; z: Int16; w: Int16) := z_VertexStream4sATI(stream, x, y, z, w);
    
    public z_VertexStream4iATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: Int32; y: Int32; z: Int32; w: Int32)>('glVertexStream4iATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4iATI(stream: DummyEnum; x: Int32; y: Int32; z: Int32; w: Int32) := z_VertexStream4iATI(stream, x, y, z, w);
    
    public z_VertexStream4fATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: single; y: single; z: single; w: single)>('glVertexStream4fATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fATI(stream: DummyEnum; x: single; y: single; z: single; w: single) := z_VertexStream4fATI(stream, x, y, z, w);
    
    public z_VertexStream4dATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; x: double; y: double; z: double; w: double)>('glVertexStream4dATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dATI(stream: DummyEnum; x: double; y: double; z: double; w: double) := z_VertexStream4dATI(stream, x, y, z, w);
    
    public z_VertexStream1svATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream1svATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: DummyEnum; coords: array of Int16) := VertexStream1svATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: DummyEnum; var coords: Int16) := VertexStream1svATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: DummyEnum; coords: pointer) := z_VertexStream1svATI(stream, coords);
    
    public z_VertexStream1ivATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream1ivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: DummyEnum; coords: array of Int32) := VertexStream1ivATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: DummyEnum; var coords: Int32) := VertexStream1ivATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: DummyEnum; coords: pointer) := z_VertexStream1ivATI(stream, coords);
    
    public z_VertexStream1fvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream1fvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: DummyEnum; coords: array of single) := VertexStream1fvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: DummyEnum; var coords: single) := VertexStream1fvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: DummyEnum; coords: pointer) := z_VertexStream1fvATI(stream, coords);
    
    public z_VertexStream1dvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream1dvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: DummyEnum; coords: array of double) := VertexStream1dvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: DummyEnum; var coords: double) := VertexStream1dvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: DummyEnum; coords: pointer) := z_VertexStream1dvATI(stream, coords);
    
    public z_VertexStream2svATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream2svATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: DummyEnum; coords: array of Int16) := VertexStream2svATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: DummyEnum; var coords: Int16) := VertexStream2svATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: DummyEnum; coords: pointer) := z_VertexStream2svATI(stream, coords);
    
    public z_VertexStream2ivATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream2ivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: DummyEnum; coords: array of Int32) := VertexStream2ivATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: DummyEnum; var coords: Int32) := VertexStream2ivATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: DummyEnum; coords: pointer) := z_VertexStream2ivATI(stream, coords);
    
    public z_VertexStream2fvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream2fvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: DummyEnum; coords: array of single) := VertexStream2fvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: DummyEnum; var coords: single) := VertexStream2fvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: DummyEnum; coords: pointer) := z_VertexStream2fvATI(stream, coords);
    
    public z_VertexStream2dvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream2dvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: DummyEnum; coords: array of double) := VertexStream2dvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: DummyEnum; var coords: double) := VertexStream2dvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: DummyEnum; coords: pointer) := z_VertexStream2dvATI(stream, coords);
    
    public z_VertexStream3svATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream3svATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: DummyEnum; coords: array of Int16) := VertexStream3svATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: DummyEnum; var coords: Int16) := VertexStream3svATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: DummyEnum; coords: pointer) := z_VertexStream3svATI(stream, coords);
    
    public z_VertexStream3ivATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream3ivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: DummyEnum; coords: array of Int32) := VertexStream3ivATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: DummyEnum; var coords: Int32) := VertexStream3ivATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: DummyEnum; coords: pointer) := z_VertexStream3ivATI(stream, coords);
    
    public z_VertexStream3fvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream3fvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: DummyEnum; coords: array of single) := VertexStream3fvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: DummyEnum; var coords: single) := VertexStream3fvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: DummyEnum; coords: pointer) := z_VertexStream3fvATI(stream, coords);
    
    public z_VertexStream3dvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream3dvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: DummyEnum; coords: array of double) := VertexStream3dvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: DummyEnum; var coords: double) := VertexStream3dvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: DummyEnum; coords: pointer) := z_VertexStream3dvATI(stream, coords);
    
    public z_VertexStream4svATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream4svATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: DummyEnum; coords: array of Int16) := VertexStream4svATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: DummyEnum; var coords: Int16) := VertexStream4svATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: DummyEnum; coords: pointer) := z_VertexStream4svATI(stream, coords);
    
    public z_VertexStream4ivATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream4ivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: DummyEnum; coords: array of Int32) := VertexStream4ivATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: DummyEnum; var coords: Int32) := VertexStream4ivATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: DummyEnum; coords: pointer) := z_VertexStream4ivATI(stream, coords);
    
    public z_VertexStream4fvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream4fvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: DummyEnum; coords: array of single) := VertexStream4fvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: DummyEnum; var coords: single) := VertexStream4fvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: DummyEnum; coords: pointer) := z_VertexStream4fvATI(stream, coords);
    
    public z_VertexStream4dvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glVertexStream4dvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: DummyEnum; coords: array of double) := VertexStream4dvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: DummyEnum; var coords: double) := VertexStream4dvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: DummyEnum; coords: pointer) := z_VertexStream4dvATI(stream, coords);
    
    public z_NormalStream3bATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; nx: SByte; ny: SByte; nz: SByte)>('glNormalStream3bATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bATI(stream: DummyEnum; nx: SByte; ny: SByte; nz: SByte) := z_NormalStream3bATI(stream, nx, ny, nz);
    
    public z_NormalStream3sATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; nx: Int16; ny: Int16; nz: Int16)>('glNormalStream3sATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3sATI(stream: DummyEnum; nx: Int16; ny: Int16; nz: Int16) := z_NormalStream3sATI(stream, nx, ny, nz);
    
    public z_NormalStream3iATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; nx: Int32; ny: Int32; nz: Int32)>('glNormalStream3iATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3iATI(stream: DummyEnum; nx: Int32; ny: Int32; nz: Int32) := z_NormalStream3iATI(stream, nx, ny, nz);
    
    public z_NormalStream3fATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; nx: single; ny: single; nz: single)>('glNormalStream3fATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fATI(stream: DummyEnum; nx: single; ny: single; nz: single) := z_NormalStream3fATI(stream, nx, ny, nz);
    
    public z_NormalStream3dATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; nx: double; ny: double; nz: double)>('glNormalStream3dATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dATI(stream: DummyEnum; nx: double; ny: double; nz: double) := z_NormalStream3dATI(stream, nx, ny, nz);
    
    public z_NormalStream3bvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glNormalStream3bvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: DummyEnum; coords: array of SByte) := NormalStream3bvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: DummyEnum; var coords: SByte) := NormalStream3bvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: DummyEnum; coords: pointer) := z_NormalStream3bvATI(stream, coords);
    
    public z_NormalStream3svATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glNormalStream3svATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: DummyEnum; coords: array of Int16) := NormalStream3svATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: DummyEnum; var coords: Int16) := NormalStream3svATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: DummyEnum; coords: pointer) := z_NormalStream3svATI(stream, coords);
    
    public z_NormalStream3ivATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glNormalStream3ivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: DummyEnum; coords: array of Int32) := NormalStream3ivATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: DummyEnum; var coords: Int32) := NormalStream3ivATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: DummyEnum; coords: pointer) := z_NormalStream3ivATI(stream, coords);
    
    public z_NormalStream3fvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glNormalStream3fvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: DummyEnum; coords: array of single) := NormalStream3fvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: DummyEnum; var coords: single) := NormalStream3fvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: DummyEnum; coords: pointer) := z_NormalStream3fvATI(stream, coords);
    
    public z_NormalStream3dvATI := GetGLFuncOrNil&<procedure(stream: DummyEnum; coords: pointer)>('glNormalStream3dvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: DummyEnum; coords: array of double) := NormalStream3dvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: DummyEnum; var coords: double) := NormalStream3dvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: DummyEnum; coords: pointer) := z_NormalStream3dvATI(stream, coords);
    
    public z_ClientActiveVertexStreamATI := GetGLFuncOrNil&<procedure(stream: DummyEnum)>('glClientActiveVertexStreamATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveVertexStreamATI(stream: DummyEnum) := z_ClientActiveVertexStreamATI(stream);
    
    public z_VertexBlendEnviATI := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: Int32)>('glVertexBlendEnviATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendEnviATI(pname: DummyEnum; param: Int32) := z_VertexBlendEnviATI(pname, param);
    
    public z_VertexBlendEnvfATI := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: single)>('glVertexBlendEnvfATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendEnvfATI(pname: DummyEnum; param: single) := z_VertexBlendEnvfATI(pname, param);
    
    {$endregion ATI_vertex_streams}
    
    {$region ATI_draw_buffers}
    
    public z_DrawBuffersATI := GetGLFuncOrNil&<procedure(n: Int32; bufs: pointer)>('glDrawBuffersATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersATI(n: Int32; bufs: array of DummyEnum) := DrawBuffersATI(n, bufs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersATI(n: Int32; var bufs: DummyEnum) := DrawBuffersATI(n, @bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersATI(n: Int32; bufs: pointer) := z_DrawBuffersATI(n, bufs);
    
    {$endregion ATI_draw_buffers}
    
    {$region ATI_element_array}
    
    public z_ElementPointerATI := GetGLFuncOrNil&<procedure(&type: DummyEnum; _pointer: pointer)>('glElementPointerATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ElementPointerATI(&type: DummyEnum; _pointer: pointer) := z_ElementPointerATI(&type, _pointer);
    
    public z_DrawElementArrayATI := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32)>('glDrawElementArrayATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementArrayATI(mode: DummyEnum; count: Int32) := z_DrawElementArrayATI(mode, count);
    
    public z_DrawRangeElementArrayATI := GetGLFuncOrNil&<procedure(mode: DummyEnum; start: UInt32; &end: UInt32; count: Int32)>('glDrawRangeElementArrayATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementArrayATI(mode: DummyEnum; start: UInt32; &end: UInt32; count: Int32) := z_DrawRangeElementArrayATI(mode, start, &end, count);
    
    {$endregion ATI_element_array}
    
    {$region ATI_envmap_bumpmap}
    
    public z_TexBumpParameterivATI := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: pointer)>('glTexBumpParameterivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: DummyEnum; param: array of Int32) := TexBumpParameterivATI(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: DummyEnum; var param: Int32) := TexBumpParameterivATI(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: DummyEnum; param: pointer) := z_TexBumpParameterivATI(pname, param);
    
    public z_TexBumpParameterfvATI := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: pointer)>('glTexBumpParameterfvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: DummyEnum; param: array of single) := TexBumpParameterfvATI(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: DummyEnum; var param: single) := TexBumpParameterfvATI(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: DummyEnum; param: pointer) := z_TexBumpParameterfvATI(pname, param);
    
    public z_GetTexBumpParameterivATI := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: pointer)>('glGetTexBumpParameterivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterivATI(pname: DummyEnum; param: array of Int32) := GetTexBumpParameterivATI(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterivATI(pname: DummyEnum; var param: Int32) := GetTexBumpParameterivATI(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterivATI(pname: DummyEnum; param: pointer) := z_GetTexBumpParameterivATI(pname, param);
    
    public z_GetTexBumpParameterfvATI := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: pointer)>('glGetTexBumpParameterfvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterfvATI(pname: DummyEnum; param: array of single) := GetTexBumpParameterfvATI(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterfvATI(pname: DummyEnum; var param: single) := GetTexBumpParameterfvATI(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterfvATI(pname: DummyEnum; param: pointer) := z_GetTexBumpParameterfvATI(pname, param);
    
    {$endregion ATI_envmap_bumpmap}
    
    {$region ATI_vertex_attrib_array_object}
    
    public z_VertexAttribArrayObjectATI := GetGLFuncOrNil&<procedure(index: UInt32; size: Int32; &type: DummyEnum; normalized: boolean; stride: Int32; buffer: UInt32; offset: UInt32)>('glVertexAttribArrayObjectATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribArrayObjectATI(index: UInt32; size: Int32; &type: DummyEnum; normalized: boolean; stride: Int32; buffer: UInt32; offset: UInt32) := z_VertexAttribArrayObjectATI(index, size, &type, normalized, stride, buffer, offset);
    
    public z_GetVertexAttribArrayObjectfvATI := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribArrayObjectfvATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: DummyEnum; &params: array of single) := GetVertexAttribArrayObjectfvATI(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: DummyEnum; var &params: single) := GetVertexAttribArrayObjectfvATI(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribArrayObjectfvATI(index, pname, &params);
    
    public z_GetVertexAttribArrayObjectivATI := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribArrayObjectivATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: DummyEnum; &params: array of Int32) := GetVertexAttribArrayObjectivATI(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: DummyEnum; var &params: Int32) := GetVertexAttribArrayObjectivATI(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribArrayObjectivATI(index, pname, &params);
    
    {$endregion ATI_vertex_attrib_array_object}
    
    {$region ATI_map_object_buffer}
    
    public z_MapObjectBufferATI := GetGLFuncOrNil&<function(buffer: UInt32): pointer>('glMapObjectBufferATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapObjectBufferATI(buffer: UInt32): pointer := z_MapObjectBufferATI(buffer);
    
    public z_UnmapObjectBufferATI := GetGLFuncOrNil&<procedure(buffer: UInt32)>('glUnmapObjectBufferATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnmapObjectBufferATI(buffer: UInt32) := z_UnmapObjectBufferATI(buffer);
    
    {$endregion ATI_map_object_buffer}
    
    {$region ATI_pn_triangles}
    
    public z_PNTrianglesiATI := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: Int32)>('glPNTrianglesiATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PNTrianglesiATI(pname: DummyEnum; param: Int32) := z_PNTrianglesiATI(pname, param);
    
    public z_PNTrianglesfATI := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: single)>('glPNTrianglesfATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PNTrianglesfATI(pname: DummyEnum; param: single) := z_PNTrianglesfATI(pname, param);
    
    {$endregion ATI_pn_triangles}
    
    {$region ATI_separate_stencil}
    
    public z_StencilOpSeparateATI := GetGLFuncOrNil&<procedure(face: DummyEnum; sfail: DummyEnum; dpfail: DummyEnum; dppass: DummyEnum)>('glStencilOpSeparateATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOpSeparateATI(face: DummyEnum; sfail: DummyEnum; dpfail: DummyEnum; dppass: DummyEnum) := z_StencilOpSeparateATI(face, sfail, dpfail, dppass);
    
    public z_StencilFuncSeparateATI := GetGLFuncOrNil&<procedure(frontfunc: DummyEnum; backfunc: DummyEnum; ref: Int32; mask: UInt32)>('glStencilFuncSeparateATI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFuncSeparateATI(frontfunc: DummyEnum; backfunc: DummyEnum; ref: Int32; mask: UInt32) := z_StencilFuncSeparateATI(frontfunc, backfunc, ref, mask);
    
    {$endregion ATI_separate_stencil}
    
  end;
  
  gl_GREMEDY = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region GREMEDY_frame_terminator}
    
    public z_FrameTerminatorGREMEDY := GetGLFuncOrNil&<procedure>('glFrameTerminatorGREMEDY');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrameTerminatorGREMEDY := z_FrameTerminatorGREMEDY;
    
    {$endregion GREMEDY_frame_terminator}
    
    {$region GREMEDY_string_marker}
    
    public z_StringMarkerGREMEDY := GetGLFuncOrNil&<procedure(len: Int32; string: pointer)>('glStringMarkerGREMEDY');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StringMarkerGREMEDY(len: Int32; string: pointer) := z_StringMarkerGREMEDY(len, string);
    
    {$endregion GREMEDY_string_marker}
    
  end;
  
  gl_HP = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region HP_image_transform}
    
    public z_ImageTransformParameteriHP := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>('glImageTransformParameteriHP');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameteriHP(target: DummyEnum; pname: DummyEnum; param: Int32) := z_ImageTransformParameteriHP(target, pname, param);
    
    public z_ImageTransformParameterfHP := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: single)>('glImageTransformParameterfHP');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfHP(target: DummyEnum; pname: DummyEnum; param: single) := z_ImageTransformParameterfHP(target, pname, param);
    
    public z_ImageTransformParameterivHP := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glImageTransformParameterivHP');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := ImageTransformParameterivHP(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; var &params: Int32) := ImageTransformParameterivHP(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ImageTransformParameterivHP(target, pname, &params);
    
    public z_ImageTransformParameterfvHP := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glImageTransformParameterfvHP');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; &params: array of single) := ImageTransformParameterfvHP(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; var &params: single) := ImageTransformParameterfvHP(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ImageTransformParameterfvHP(target, pname, &params);
    
    public z_GetImageTransformParameterivHP := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetImageTransformParameterivHP');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetImageTransformParameterivHP(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetImageTransformParameterivHP(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetImageTransformParameterivHP(target, pname, &params);
    
    public z_GetImageTransformParameterfvHP := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetImageTransformParameterfvHP');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetImageTransformParameterfvHP(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; var &params: single) := GetImageTransformParameterfvHP(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetImageTransformParameterfvHP(target, pname, &params);
    
    {$endregion HP_image_transform}
    
  end;
  
  gl_IBM = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region IBM_vertex_array_lists}
    
    public z_ColorPointerListIBM := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>('glColorPointerListIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := ColorPointerListIBM(size, &type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := ColorPointerListIBM(size, &type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_ColorPointerListIBM(size, &type, stride, _pointer, ptrstride);
    
    public z_SecondaryColorPointerListIBM := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>('glSecondaryColorPointerListIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := SecondaryColorPointerListIBM(size, &type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := SecondaryColorPointerListIBM(size, &type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_SecondaryColorPointerListIBM(size, &type, stride, _pointer, ptrstride);
    
    public z_EdgeFlagPointerListIBM := GetGLFuncOrNil&<procedure(stride: Int32; _pointer: pointer; ptrstride: Int32)>('glEdgeFlagPointerListIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerListIBM(stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := EdgeFlagPointerListIBM(stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerListIBM(stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := EdgeFlagPointerListIBM(stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerListIBM(stride: Int32; _pointer: pointer; ptrstride: Int32) := z_EdgeFlagPointerListIBM(stride, _pointer, ptrstride);
    
    public z_FogCoordPointerListIBM := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>('glFogCoordPointerListIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := FogCoordPointerListIBM(&type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := FogCoordPointerListIBM(&type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_FogCoordPointerListIBM(&type, stride, _pointer, ptrstride);
    
    public z_IndexPointerListIBM := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>('glIndexPointerListIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := IndexPointerListIBM(&type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := IndexPointerListIBM(&type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_IndexPointerListIBM(&type, stride, _pointer, ptrstride);
    
    public z_NormalPointerListIBM := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>('glNormalPointerListIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := NormalPointerListIBM(&type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := NormalPointerListIBM(&type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_NormalPointerListIBM(&type, stride, _pointer, ptrstride);
    
    public z_TexCoordPointerListIBM := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>('glTexCoordPointerListIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := TexCoordPointerListIBM(size, &type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := TexCoordPointerListIBM(size, &type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_TexCoordPointerListIBM(size, &type, stride, _pointer, ptrstride);
    
    public z_VertexPointerListIBM := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>('glVertexPointerListIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := VertexPointerListIBM(size, &type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := VertexPointerListIBM(size, &type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_VertexPointerListIBM(size, &type, stride, _pointer, ptrstride);
    
    {$endregion IBM_vertex_array_lists}
    
    {$region IBM_static_data}
    
    public z_FlushStaticDataIBM := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glFlushStaticDataIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushStaticDataIBM(target: DummyEnum) := z_FlushStaticDataIBM(target);
    
    {$endregion IBM_static_data}
    
    {$region IBM_multimode_draw_arrays}
    
    public z_MultiModeDrawArraysIBM := GetGLFuncOrNil&<procedure(mode: pointer; first: pointer; count: pointer; primcount: Int32; modestride: Int32)>('glMultiModeDrawArraysIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: array of Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first[0], count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: array of Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first[0], @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: array of Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first[0], count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; var first: Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], @first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], @first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; var first: Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], @first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: pointer; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: pointer; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: pointer; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: array of Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first[0], count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: array of Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first[0], @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: array of Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first[0], count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; var first: Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, @first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, @first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; var first: Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, @first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: pointer; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: pointer; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: pointer; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: array of Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, first[0], count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: array of Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, first[0], @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: array of Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, first[0], count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; var first: Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, @first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, @first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; var first: Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, @first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: pointer; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: pointer; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: pointer; count: pointer; primcount: Int32; modestride: Int32) := z_MultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
    
    public z_MultiModeDrawElementsIBM := GetGLFuncOrNil&<procedure(mode: pointer; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32)>('glMultiModeDrawElementsIBM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count[0], &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count[0], &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count[0], &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], @count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], @count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], @count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count[0], &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count[0], &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count[0], &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, @count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, @count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, @count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, count[0], &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: array of Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, count[0], &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: array of Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, count[0], &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; var count: Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, @count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; var count: Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, @count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; var count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, @count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: pointer; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: pointer; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := z_MultiModeDrawElementsIBM(mode, count, &type, indices, primcount, modestride);
    
    {$endregion IBM_multimode_draw_arrays}
    
  end;
  
  gl_IMG = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region IMG_user_clip_plane}
    
    public z_ClipPlanefIMG := GetGLFuncOrNil&<procedure(p: DummyEnum; eqn: pointer)>('glClipPlanefIMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefIMG(p: DummyEnum; eqn: array of single) := ClipPlanefIMG(p, eqn[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefIMG(p: DummyEnum; var eqn: single) := ClipPlanefIMG(p, @eqn);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefIMG(p: DummyEnum; eqn: pointer) := z_ClipPlanefIMG(p, eqn);
    
    public z_ClipPlanexIMG := GetGLFuncOrNil&<procedure(p: DummyEnum; eqn: pointer)>('glClipPlanexIMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexIMG(p: DummyEnum; eqn: array of fixed) := ClipPlanexIMG(p, eqn[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexIMG(p: DummyEnum; var eqn: fixed) := ClipPlanexIMG(p, @eqn);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexIMG(p: DummyEnum; eqn: pointer) := z_ClipPlanexIMG(p, eqn);
    
    {$endregion IMG_user_clip_plane}
    
    {$region IMG_framebuffer_downsample}
    
    public z_FramebufferTexture2DDownsampleIMG := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; xscale: Int32; yscale: Int32)>('glFramebufferTexture2DDownsampleIMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2DDownsampleIMG(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; xscale: Int32; yscale: Int32) := z_FramebufferTexture2DDownsampleIMG(target, attachment, textarget, texture, level, xscale, yscale);
    
    public z_FramebufferTextureLayerDownsampleIMG := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32; xscale: Int32; yscale: Int32)>('glFramebufferTextureLayerDownsampleIMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayerDownsampleIMG(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32; xscale: Int32; yscale: Int32) := z_FramebufferTextureLayerDownsampleIMG(target, attachment, texture, level, layer, xscale, yscale);
    
    {$endregion IMG_framebuffer_downsample}
    
    {$region IMG_multisampled_render_to_texture}
    
    public z_RenderbufferStorageMultisampleIMG := GetGLFuncOrNil&<procedure(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glRenderbufferStorageMultisampleIMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleIMG(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height);
    
    public z_FramebufferTexture2DMultisampleIMG := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; samples: Int32)>('glFramebufferTexture2DMultisampleIMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2DMultisampleIMG(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; samples: Int32) := z_FramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);
    
    {$endregion IMG_multisampled_render_to_texture}
    
    {$region IMG_bindless_texture}
    
    public z_GetTextureHandleIMG := GetGLFuncOrNil&<function(texture: UInt32): UInt64>('glGetTextureHandleIMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureHandleIMG(texture: UInt32): UInt64 := z_GetTextureHandleIMG(texture);
    
    public z_GetTextureSamplerHandleIMG := GetGLFuncOrNil&<function(texture: UInt32; sampler: UInt32): UInt64>('glGetTextureSamplerHandleIMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureSamplerHandleIMG(texture: UInt32; sampler: UInt32): UInt64 := z_GetTextureSamplerHandleIMG(texture, sampler);
    
    public z_UniformHandleui64IMG := GetGLFuncOrNil&<procedure(location: Int32; value: UInt64)>('glUniformHandleui64IMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64IMG(location: Int32; value: UInt64) := z_UniformHandleui64IMG(location, value);
    
    public z_UniformHandleui64vIMG := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniformHandleui64vIMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vIMG(location: Int32; count: Int32; value: array of UInt64) := UniformHandleui64vIMG(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vIMG(location: Int32; count: Int32; var value: UInt64) := UniformHandleui64vIMG(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vIMG(location: Int32; count: Int32; value: pointer) := z_UniformHandleui64vIMG(location, count, value);
    
    public z_ProgramUniformHandleui64IMG := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; value: UInt64)>('glProgramUniformHandleui64IMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64IMG(&program: UInt32; location: Int32; value: UInt64) := z_ProgramUniformHandleui64IMG(&program, location, value);
    
    public z_ProgramUniformHandleui64vIMG := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; values: pointer)>('glProgramUniformHandleui64vIMG');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vIMG(&program: UInt32; location: Int32; count: Int32; values: array of UInt64) := ProgramUniformHandleui64vIMG(&program, location, count, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vIMG(&program: UInt32; location: Int32; count: Int32; var values: UInt64) := ProgramUniformHandleui64vIMG(&program, location, count, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vIMG(&program: UInt32; location: Int32; count: Int32; values: pointer) := z_ProgramUniformHandleui64vIMG(&program, location, count, values);
    
    {$endregion IMG_bindless_texture}
    
  end;
  
  gl_INGR = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region INGR_blend_func_separate}
    
    public z_BlendFuncSeparateINGR := GetGLFuncOrNil&<procedure(sfactorRGB: DummyEnum; dfactorRGB: DummyEnum; sfactorAlpha: DummyEnum; dfactorAlpha: DummyEnum)>('glBlendFuncSeparateINGR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateINGR(sfactorRGB: DummyEnum; dfactorRGB: DummyEnum; sfactorAlpha: DummyEnum; dfactorAlpha: DummyEnum) := z_BlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
    
    {$endregion INGR_blend_func_separate}
    
  end;
  
  gl_INTEL = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region INTEL_framebuffer_CMAA}
    
    public z_ApplyFramebufferAttachmentCMAAINTEL := GetGLFuncOrNil&<procedure>('glApplyFramebufferAttachmentCMAAINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ApplyFramebufferAttachmentCMAAINTEL := z_ApplyFramebufferAttachmentCMAAINTEL;
    
    {$endregion INTEL_framebuffer_CMAA}
    
    {$region INTEL_performance_query}
    
    public z_GetFirstPerfQueryIdINTEL := GetGLFuncOrNil&<procedure(queryId: pointer)>('glGetFirstPerfQueryIdINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFirstPerfQueryIdINTEL(var queryId: PerfQueryIdINTEL) := GetFirstPerfQueryIdINTEL(@queryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFirstPerfQueryIdINTEL(queryId: pointer) := z_GetFirstPerfQueryIdINTEL(queryId);
    
    public z_GetNextPerfQueryIdINTEL := GetGLFuncOrNil&<procedure(queryId: PerfQueryIdINTEL; nextQueryId: pointer)>('glGetNextPerfQueryIdINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNextPerfQueryIdINTEL(queryId: PerfQueryIdINTEL; var nextQueryId: PerfQueryIdINTEL) := GetNextPerfQueryIdINTEL(queryId, @nextQueryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNextPerfQueryIdINTEL(queryId: PerfQueryIdINTEL; nextQueryId: pointer) := z_GetNextPerfQueryIdINTEL(queryId, nextQueryId);
    
    public z_GetPerfQueryIdByNameINTEL := GetGLFuncOrNil&<procedure(queryName: IntPtr; queryId: pointer)>('glGetPerfQueryIdByNameINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: string; var queryId: PerfQueryIdINTEL); begin var ptr_1 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryIdByNameINTEL(ptr_1, @queryId); Marshal.FreeHGlobal(ptr_1); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: string; queryId: pointer); begin var ptr_1 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryIdByNameINTEL(ptr_1, queryId); Marshal.FreeHGlobal(ptr_1); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: IntPtr; var queryId: PerfQueryIdINTEL) := GetPerfQueryIdByNameINTEL(queryName, @queryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: IntPtr; queryId: pointer) := z_GetPerfQueryIdByNameINTEL(queryName, queryId);
    
    public z_GetPerfQueryInfoINTEL := GetGLFuncOrNil&<procedure(queryId: PerfQueryIdINTEL; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; noInstances: pointer; capsMask: pointer)>('glGetPerfQueryInfoINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: PerfQueryIdINTEL; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; var capsMask: PerfQueryCapFlagsINTEL); begin var ptr_3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr_3, @dataSize, @noCounters, @noInstances, @capsMask); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: PerfQueryIdINTEL; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: pointer; noInstances: pointer; capsMask: pointer); begin var ptr_3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr_3, dataSize, noCounters, noInstances, capsMask); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: PerfQueryIdINTEL; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; var capsMask: PerfQueryCapFlagsINTEL) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, @noCounters, @noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: PerfQueryIdINTEL; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; noInstances: pointer; capsMask: pointer) := z_GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    
    public z_GetPerfCounterInfoINTEL := GetGLFuncOrNil&<procedure(queryId: PerfQueryIdINTEL; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer)>('glGetPerfCounterInfoINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: PerfQueryIdINTEL; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: PerfQueryCounterTypeINTEL; var counterDataTypeEnum: PerfQueryCounterDataTypeINTEL; var rawCounterMaxValue: UInt64); begin var ptr_6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr_4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr_4, counterDescLength, ptr_6, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); Marshal.FreeHGlobal(ptr_4); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: PerfQueryIdINTEL; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr_6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr_4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr_4, counterDescLength, ptr_6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); Marshal.FreeHGlobal(ptr_4); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: PerfQueryIdINTEL; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: PerfQueryCounterTypeINTEL; var counterDataTypeEnum: PerfQueryCounterDataTypeINTEL; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: PerfQueryIdINTEL; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := z_GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    
    public z_CreatePerfQueryINTEL := GetGLFuncOrNil&<procedure(queryId: PerfQueryIdINTEL; queryHandle: pointer)>('glCreatePerfQueryINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreatePerfQueryINTEL(queryId: PerfQueryIdINTEL; var queryHandle: PerfQueryHandleINTEL) := CreatePerfQueryINTEL(queryId, @queryHandle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreatePerfQueryINTEL(queryId: PerfQueryIdINTEL; queryHandle: pointer) := z_CreatePerfQueryINTEL(queryId, queryHandle);
    
    public z_DeletePerfQueryINTEL := GetGLFuncOrNil&<procedure(queryHandle: PerfQueryHandleINTEL)>('glDeletePerfQueryINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfQueryINTEL(queryHandle: PerfQueryHandleINTEL) := z_DeletePerfQueryINTEL(queryHandle);
    
    public z_BeginPerfQueryINTEL := GetGLFuncOrNil&<procedure(queryHandle: PerfQueryHandleINTEL)>('glBeginPerfQueryINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginPerfQueryINTEL(queryHandle: PerfQueryHandleINTEL) := z_BeginPerfQueryINTEL(queryHandle);
    
    public z_EndPerfQueryINTEL := GetGLFuncOrNil&<procedure(queryHandle: PerfQueryHandleINTEL)>('glEndPerfQueryINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndPerfQueryINTEL(queryHandle: PerfQueryHandleINTEL) := z_EndPerfQueryINTEL(queryHandle);
    
    public z_GetPerfQueryDataINTEL := GetGLFuncOrNil&<procedure(queryHandle: PerfQueryHandleINTEL; flags: PerfQueryDataFlagsINTEL; dataSize: Int32; data: pointer; bytesWritten: pointer)>('glGetPerfQueryDataINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: PerfQueryHandleINTEL; flags: PerfQueryDataFlagsINTEL; dataSize: Int32; data: IntPtr; var bytesWritten: UInt32) := GetPerfQueryDataINTEL(queryHandle, flags, dataSize, pointer(data), @bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: PerfQueryHandleINTEL; flags: PerfQueryDataFlagsINTEL; dataSize: Int32; data: IntPtr; bytesWritten: pointer) := GetPerfQueryDataINTEL(queryHandle, flags, dataSize, pointer(data), bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: PerfQueryHandleINTEL; flags: PerfQueryDataFlagsINTEL; dataSize: Int32; data: pointer; var bytesWritten: UInt32) := GetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, @bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: PerfQueryHandleINTEL; flags: PerfQueryDataFlagsINTEL; dataSize: Int32; data: pointer; bytesWritten: pointer) := z_GetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
    
    {$endregion INTEL_performance_query}
    
    {$region INTEL_parallel_arrays}
    
    public z_VertexPointervINTEL := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; _pointer: pointer)>('glVertexPointervINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: DummyEnum; _pointer: array of IntPtr) := VertexPointervINTEL(size, &type, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: DummyEnum; var _pointer: IntPtr) := VertexPointervINTEL(size, &type, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: DummyEnum; _pointer: pointer) := z_VertexPointervINTEL(size, &type, _pointer);
    
    public z_NormalPointervINTEL := GetGLFuncOrNil&<procedure(&type: DummyEnum; _pointer: pointer)>('glNormalPointervINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: DummyEnum; _pointer: array of IntPtr) := NormalPointervINTEL(&type, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: DummyEnum; var _pointer: IntPtr) := NormalPointervINTEL(&type, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: DummyEnum; _pointer: pointer) := z_NormalPointervINTEL(&type, _pointer);
    
    public z_ColorPointervINTEL := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; _pointer: pointer)>('glColorPointervINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: DummyEnum; _pointer: array of IntPtr) := ColorPointervINTEL(size, &type, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: DummyEnum; var _pointer: IntPtr) := ColorPointervINTEL(size, &type, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: DummyEnum; _pointer: pointer) := z_ColorPointervINTEL(size, &type, _pointer);
    
    public z_TexCoordPointervINTEL := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; _pointer: pointer)>('glTexCoordPointervINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: DummyEnum; _pointer: array of IntPtr) := TexCoordPointervINTEL(size, &type, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: DummyEnum; var _pointer: IntPtr) := TexCoordPointervINTEL(size, &type, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: DummyEnum; _pointer: pointer) := z_TexCoordPointervINTEL(size, &type, _pointer);
    
    {$endregion INTEL_parallel_arrays}
    
    {$region INTEL_map_texture}
    
    public z_MapTexture2DINTEL := GetGLFuncOrNil&<function(texture: UInt32; level: Int32; access: DummyFlags; stride: pointer; layout: pointer): pointer>('glMapTexture2DINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: array of Int32; layout: array of DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, stride[0], layout[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: array of Int32; var layout: DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, stride[0], @layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: array of Int32; layout: pointer): pointer := MapTexture2DINTEL(texture, level, access, stride[0], layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; var stride: Int32; layout: array of DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, @stride, layout[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; var stride: Int32; var layout: DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, @stride, @layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; var stride: Int32; layout: pointer): pointer := MapTexture2DINTEL(texture, level, access, @stride, layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: pointer; layout: array of DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, stride, layout[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: pointer; var layout: DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, stride, @layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: pointer; layout: pointer): pointer := z_MapTexture2DINTEL(texture, level, access, stride, layout);
    
    public z_UnmapTexture2DINTEL := GetGLFuncOrNil&<procedure(texture: UInt32; level: Int32)>('glUnmapTexture2DINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnmapTexture2DINTEL(texture: UInt32; level: Int32) := z_UnmapTexture2DINTEL(texture, level);
    
    public z_SyncTextureINTEL := GetGLFuncOrNil&<procedure(texture: UInt32)>('glSyncTextureINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SyncTextureINTEL(texture: UInt32) := z_SyncTextureINTEL(texture);
    
    {$endregion INTEL_map_texture}
    
    {$region INTEL_texture_scissor}
    
    public z_TexScissorINTEL := GetGLFuncOrNil&<procedure(target: DummyEnum; tlow: single; thigh: single)>('glTexScissorINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexScissorINTEL(target: DummyEnum; tlow: single; thigh: single) := z_TexScissorINTEL(target, tlow, thigh);
    
    public z_TexScissorFuncINTEL := GetGLFuncOrNil&<procedure(target: DummyEnum; lfunc: DummyEnum; hfunc: DummyEnum)>('glTexScissorFuncINTEL');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexScissorFuncINTEL(target: DummyEnum; lfunc: DummyEnum; hfunc: DummyEnum) := z_TexScissorFuncINTEL(target, lfunc, hfunc);
    
    {$endregion INTEL_texture_scissor}
    
  end;
  
  gl_KHR = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region KHR_blend_equation_advanced}
    
    public z_BlendBarrierKHR := GetGLFuncOrNil&<procedure>('glBlendBarrierKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendBarrierKHR := z_BlendBarrierKHR;
    
    {$endregion KHR_blend_equation_advanced}
    
    {$region KHR_debug}
    
    public z_DebugMessageControlKHR := GetGLFuncOrNil&<procedure(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: pointer; enabled: boolean)>('glDebugMessageControlKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlKHR(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: array of UInt32; enabled: boolean) := DebugMessageControlKHR(source, &type, severity, count, ids[0], enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlKHR(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; var ids: UInt32; enabled: boolean) := DebugMessageControlKHR(source, &type, severity, count, @ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageControlKHR(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: pointer; enabled: boolean) := z_DebugMessageControlKHR(source, &type, severity, count, ids, enabled);
    
    public z_DebugMessageInsertKHR := GetGLFuncOrNil&<procedure(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: IntPtr)>('glDebugMessageInsertKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertKHR(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: string); begin var ptr_6 := Marshal.StringToHGlobalAnsi(buf); DebugMessageInsertKHR(source, &type, id, severity, length, ptr_6); Marshal.FreeHGlobal(ptr_6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageInsertKHR(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: IntPtr) := z_DebugMessageInsertKHR(source, &type, id, severity, length, buf);
    
    public z_DebugMessageCallbackKHR := GetGLFuncOrNil&<procedure(callback: GLDEBUGPROC; userParam: pointer)>('glDebugMessageCallbackKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageCallbackKHR(callback: GLDEBUGPROC; userParam: pointer) := z_DebugMessageCallbackKHR(callback, userParam);
    
    public z_GetDebugMessageLogKHR := GetGLFuncOrNil&<function(count: UInt32; bufSize: Int32; sources: pointer; types: pointer; ids: pointer; severities: pointer; lengths: pointer; messageLog: IntPtr): UInt32>('glGetDebugMessageLogKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogKHR(count: UInt32; bufSize: Int32; sources: array of DebugSourceType; types: array of DebugMessageType; ids: array of UInt32; severities: array of DebugSeverityLevel; lengths: array of Int32; messageLog: IntPtr): UInt32 := GetDebugMessageLogKHR(count, bufSize, sources[0], types[0], ids[0], severities[0], lengths[0], messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogKHR(count: UInt32; bufSize: Int32; var sources: DebugSourceType; var types: DebugMessageType; var ids: UInt32; var severities: DebugSeverityLevel; var lengths: Int32; messageLog: string): UInt32; begin var ptr_8 := Marshal.StringToHGlobalAnsi(messageLog); Result := GetDebugMessageLogKHR(count, bufSize, @sources, @types, @ids, @severities, @lengths, ptr_8); Marshal.FreeHGlobal(ptr_8); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogKHR(count: UInt32; bufSize: Int32; var sources: DebugSourceType; var types: DebugMessageType; var ids: UInt32; var severities: DebugSeverityLevel; var lengths: Int32; messageLog: IntPtr): UInt32 := GetDebugMessageLogKHR(count, bufSize, @sources, @types, @ids, @severities, @lengths, messageLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogKHR(count: UInt32; bufSize: Int32; sources: pointer; types: pointer; ids: pointer; severities: pointer; lengths: pointer; messageLog: string): UInt32; begin var ptr_8 := Marshal.StringToHGlobalAnsi(messageLog); Result := GetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities, lengths, ptr_8); Marshal.FreeHGlobal(ptr_8); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDebugMessageLogKHR(count: UInt32; bufSize: Int32; sources: pointer; types: pointer; ids: pointer; severities: pointer; lengths: pointer; messageLog: IntPtr): UInt32 := z_GetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities, lengths, messageLog);
    
    public z_GetPointervKHR := GetGLFuncOrNil&<procedure(pname: GLGetQueries; &params: pointer)>('glGetPointervKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointervKHR(pname: GLGetQueries; &params: array of IntPtr) := GetPointervKHR(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointervKHR(pname: GLGetQueries; var &params: IntPtr) := GetPointervKHR(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointervKHR(pname: GLGetQueries; &params: pointer) := z_GetPointervKHR(pname, &params);
    
    public z_PushDebugGroupKHR := GetGLFuncOrNil&<procedure(source: DummyEnum; id: UInt32; length: Int32; message: IntPtr)>('glPushDebugGroupKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroupKHR(source: DummyEnum; id: UInt32; length: Int32; message: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(message); PushDebugGroupKHR(source, id, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushDebugGroupKHR(source: DummyEnum; id: UInt32; length: Int32; message: IntPtr) := z_PushDebugGroupKHR(source, id, length, message);
    
    public z_PopDebugGroupKHR := GetGLFuncOrNil&<procedure>('glPopDebugGroupKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopDebugGroupKHR := z_PopDebugGroupKHR;
    
    public z_ObjectLabelKHR := GetGLFuncOrNil&<procedure(identifier: DummyEnum; name: UInt32; length: Int32; &label: IntPtr)>('glObjectLabelKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabelKHR(identifier: DummyEnum; name: UInt32; length: Int32; &label: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(&label); ObjectLabelKHR(identifier, name, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectLabelKHR(identifier: DummyEnum; name: UInt32; length: Int32; &label: IntPtr) := z_ObjectLabelKHR(identifier, name, length, &label);
    
    public z_GetObjectLabelKHR := GetGLFuncOrNil&<procedure(identifier: DummyEnum; name: UInt32; bufSize: Int32; length: pointer; &label: IntPtr)>('glGetObjectLabelKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelKHR(identifier: DummyEnum; name: UInt32; bufSize: Int32; length: array of Int32; &label: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(&label); GetObjectLabelKHR(identifier, name, bufSize, length[0], ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelKHR(identifier: DummyEnum; name: UInt32; bufSize: Int32; length: array of Int32; &label: IntPtr) := GetObjectLabelKHR(identifier, name, bufSize, length[0], &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelKHR(identifier: DummyEnum; name: UInt32; bufSize: Int32; var length: Int32; &label: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(&label); GetObjectLabelKHR(identifier, name, bufSize, @length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelKHR(identifier: DummyEnum; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr) := GetObjectLabelKHR(identifier, name, bufSize, @length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelKHR(identifier: DummyEnum; name: UInt32; bufSize: Int32; length: pointer; &label: string); begin var ptr_5 := Marshal.StringToHGlobalAnsi(&label); GetObjectLabelKHR(identifier, name, bufSize, length, ptr_5); Marshal.FreeHGlobal(ptr_5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectLabelKHR(identifier: DummyEnum; name: UInt32; bufSize: Int32; length: pointer; &label: IntPtr) := z_GetObjectLabelKHR(identifier, name, bufSize, length, &label);
    
    public z_ObjectPtrLabelKHR := GetGLFuncOrNil&<procedure(ptr: pointer; length: Int32; &label: IntPtr)>('glObjectPtrLabelKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabelKHR(ptr: pointer; length: Int32; &label: string); begin var ptr_3 := Marshal.StringToHGlobalAnsi(&label); ObjectPtrLabelKHR(ptr, length, ptr_3); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ObjectPtrLabelKHR(ptr: pointer; length: Int32; &label: IntPtr) := z_ObjectPtrLabelKHR(ptr, length, &label);
    
    public z_GetObjectPtrLabelKHR := GetGLFuncOrNil&<procedure(ptr: pointer; bufSize: Int32; length: pointer; &label: IntPtr)>('glGetObjectPtrLabelKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabelKHR(ptr: pointer; bufSize: Int32; length: array of Int32; &label: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(&label); GetObjectPtrLabelKHR(ptr, bufSize, length[0], ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabelKHR(ptr: pointer; bufSize: Int32; length: array of Int32; &label: IntPtr) := GetObjectPtrLabelKHR(ptr, bufSize, length[0], &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabelKHR(ptr: pointer; bufSize: Int32; var length: Int32; &label: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(&label); GetObjectPtrLabelKHR(ptr, bufSize, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabelKHR(ptr: pointer; bufSize: Int32; var length: Int32; &label: IntPtr) := GetObjectPtrLabelKHR(ptr, bufSize, @length, &label);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabelKHR(ptr: pointer; bufSize: Int32; length: pointer; &label: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(&label); GetObjectPtrLabelKHR(ptr, bufSize, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectPtrLabelKHR(ptr: pointer; bufSize: Int32; length: pointer; &label: IntPtr) := z_GetObjectPtrLabelKHR(ptr, bufSize, length, &label);
    
    {$endregion KHR_debug}
    
    {$region KHR_robustness}
    
    public z_GetGraphicsResetStatusKHR := GetGLFuncOrNil&<function: DummyEnum>('glGetGraphicsResetStatusKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGraphicsResetStatusKHR: DummyEnum := z_GetGraphicsResetStatusKHR;
    
    public z_ReadnPixelsKHR := GetGLFuncOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; bufSize: Int32; data: pointer)>('glReadnPixelsKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadnPixelsKHR(x: Int32; y: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; bufSize: Int32; data: pointer) := z_ReadnPixelsKHR(x, y, width, height, format, &type, bufSize, data);
    
    public z_GetnUniformfvKHR := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformfvKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvKHR(&program: UInt32; location: Int32; bufSize: Int32; &params: array of single) := GetnUniformfvKHR(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvKHR(&program: UInt32; location: Int32; bufSize: Int32; var &params: single) := GetnUniformfvKHR(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformfvKHR(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformfvKHR(&program, location, bufSize, &params);
    
    public z_GetnUniformivKHR := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformivKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivKHR(&program: UInt32; location: Int32; bufSize: Int32; &params: array of Int32) := GetnUniformivKHR(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivKHR(&program: UInt32; location: Int32; bufSize: Int32; var &params: Int32) := GetnUniformivKHR(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformivKHR(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformivKHR(&program, location, bufSize, &params);
    
    public z_GetnUniformuivKHR := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>('glGetnUniformuivKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuivKHR(&program: UInt32; location: Int32; bufSize: Int32; &params: array of UInt32) := GetnUniformuivKHR(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuivKHR(&program: UInt32; location: Int32; bufSize: Int32; var &params: UInt32) := GetnUniformuivKHR(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformuivKHR(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformuivKHR(&program, location, bufSize, &params);
    
    {$endregion KHR_robustness}
    
    {$region KHR_parallel_shader_compile}
    
    public z_MaxShaderCompilerThreadsKHR := GetGLFuncOrNil&<procedure(count: UInt32)>('glMaxShaderCompilerThreadsKHR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaxShaderCompilerThreadsKHR(count: UInt32) := z_MaxShaderCompilerThreadsKHR(count);
    
    {$endregion KHR_parallel_shader_compile}
    
  end;
  
  gl_MESA = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region MESA_resize_buffers}
    
    public z_ResizeBuffersMESA := GetGLFuncOrNil&<procedure>('glResizeBuffersMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResizeBuffersMESA := z_ResizeBuffersMESA;
    
    {$endregion MESA_resize_buffers}
    
    {$region MESA_window_pos}
    
    public z_WindowPos2dMESA := GetGLFuncOrNil&<procedure(x: double; y: double)>('glWindowPos2dMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dMESA(x: double; y: double) := z_WindowPos2dMESA(x, y);
    
    public z_WindowPos2fMESA := GetGLFuncOrNil&<procedure(x: single; y: single)>('glWindowPos2fMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fMESA(x: single; y: single) := z_WindowPos2fMESA(x, y);
    
    public z_WindowPos2iMESA := GetGLFuncOrNil&<procedure(x: Int32; y: Int32)>('glWindowPos2iMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iMESA(x: Int32; y: Int32) := z_WindowPos2iMESA(x, y);
    
    public z_WindowPos2sMESA := GetGLFuncOrNil&<procedure(x: Int16; y: Int16)>('glWindowPos2sMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sMESA(x: Int16; y: Int16) := z_WindowPos2sMESA(x, y);
    
    public z_WindowPos2ivMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2ivMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivMESA(v: array of Int32) := WindowPos2ivMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivMESA(var v: Int32) := WindowPos2ivMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2ivMESA(v: pointer) := z_WindowPos2ivMESA(v);
    
    public z_WindowPos2svMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2svMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svMESA(v: array of Int16) := WindowPos2svMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svMESA(var v: Int16) := WindowPos2svMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2svMESA(v: pointer) := z_WindowPos2svMESA(v);
    
    public z_WindowPos2fvMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2fvMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvMESA(v: array of single) := WindowPos2fvMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvMESA(var v: single) := WindowPos2fvMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fvMESA(v: pointer) := z_WindowPos2fvMESA(v);
    
    public z_WindowPos2dvMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos2dvMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvMESA(v: array of double) := WindowPos2dvMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvMESA(var v: double) := WindowPos2dvMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dvMESA(v: pointer) := z_WindowPos2dvMESA(v);
    
    public z_WindowPos3iMESA := GetGLFuncOrNil&<procedure(x: Int32; y: Int32; z: Int32)>('glWindowPos3iMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iMESA(x: Int32; y: Int32; z: Int32) := z_WindowPos3iMESA(x, y, z);
    
    public z_WindowPos3sMESA := GetGLFuncOrNil&<procedure(x: Int16; y: Int16; z: Int16)>('glWindowPos3sMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sMESA(x: Int16; y: Int16; z: Int16) := z_WindowPos3sMESA(x, y, z);
    
    public z_WindowPos3fMESA := GetGLFuncOrNil&<procedure(x: single; y: single; z: single)>('glWindowPos3fMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fMESA(x: single; y: single; z: single) := z_WindowPos3fMESA(x, y, z);
    
    public z_WindowPos3dMESA := GetGLFuncOrNil&<procedure(x: double; y: double; z: double)>('glWindowPos3dMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dMESA(x: double; y: double; z: double) := z_WindowPos3dMESA(x, y, z);
    
    public z_WindowPos3ivMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3ivMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivMESA(v: array of Int32) := WindowPos3ivMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivMESA(var v: Int32) := WindowPos3ivMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3ivMESA(v: pointer) := z_WindowPos3ivMESA(v);
    
    public z_WindowPos3svMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3svMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svMESA(v: array of Int16) := WindowPos3svMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svMESA(var v: Int16) := WindowPos3svMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3svMESA(v: pointer) := z_WindowPos3svMESA(v);
    
    public z_WindowPos3fvMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3fvMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvMESA(v: array of single) := WindowPos3fvMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvMESA(var v: single) := WindowPos3fvMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fvMESA(v: pointer) := z_WindowPos3fvMESA(v);
    
    public z_WindowPos3dvMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos3dvMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvMESA(v: array of double) := WindowPos3dvMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvMESA(var v: double) := WindowPos3dvMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dvMESA(v: pointer) := z_WindowPos3dvMESA(v);
    
    public z_WindowPos4iMESA := GetGLFuncOrNil&<procedure(x: Int32; y: Int32; z: Int32; w: Int32)>('glWindowPos4iMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4iMESA(x: Int32; y: Int32; z: Int32; w: Int32) := z_WindowPos4iMESA(x, y, z, w);
    
    public z_WindowPos4sMESA := GetGLFuncOrNil&<procedure(x: Int16; y: Int16; z: Int16; w: Int16)>('glWindowPos4sMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4sMESA(x: Int16; y: Int16; z: Int16; w: Int16) := z_WindowPos4sMESA(x, y, z, w);
    
    public z_WindowPos4fMESA := GetGLFuncOrNil&<procedure(x: single; y: single; z: single; w: single)>('glWindowPos4fMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fMESA(x: single; y: single; z: single; w: single) := z_WindowPos4fMESA(x, y, z, w);
    
    public z_WindowPos4dMESA := GetGLFuncOrNil&<procedure(x: double; y: double; z: double; w: double)>('glWindowPos4dMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dMESA(x: double; y: double; z: double; w: double) := z_WindowPos4dMESA(x, y, z, w);
    
    public z_WindowPos4ivMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos4ivMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(v: array of Int32) := WindowPos4ivMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(var v: Int32) := WindowPos4ivMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(v: pointer) := z_WindowPos4ivMESA(v);
    
    public z_WindowPos4svMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos4svMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(v: array of Int16) := WindowPos4svMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(var v: Int16) := WindowPos4svMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(v: pointer) := z_WindowPos4svMESA(v);
    
    public z_WindowPos4fvMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos4fvMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(v: array of single) := WindowPos4fvMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(var v: single) := WindowPos4fvMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(v: pointer) := z_WindowPos4fvMESA(v);
    
    public z_WindowPos4dvMESA := GetGLFuncOrNil&<procedure(v: pointer)>('glWindowPos4dvMESA');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(v: array of double) := WindowPos4dvMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(var v: double) := WindowPos4dvMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(v: pointer) := z_WindowPos4dvMESA(v);
    
    {$endregion MESA_window_pos}
    
  end;
  
  gl_NV = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region NV_transform_feedback}
    
    public z_BeginTransformFeedbackNV := GetGLFuncOrNil&<procedure(primitiveMode: DummyEnum)>('glBeginTransformFeedbackNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginTransformFeedbackNV(primitiveMode: DummyEnum) := z_BeginTransformFeedbackNV(primitiveMode);
    
    public z_EndTransformFeedbackNV := GetGLFuncOrNil&<procedure>('glEndTransformFeedbackNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTransformFeedbackNV := z_EndTransformFeedbackNV;
    
    public z_GetVaryingLocationNV := GetGLFuncOrNil&<function(&program: UInt32; name: IntPtr): Int32>('glGetVaryingLocationNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVaryingLocationNV(&program: UInt32; name: string): Int32; begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); Result := GetVaryingLocationNV(&program, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVaryingLocationNV(&program: UInt32; name: IntPtr): Int32 := z_GetVaryingLocationNV(&program, name);
    
    public z_GetActiveVaryingNV := GetGLFuncOrNil&<procedure(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr)>('glGetActiveVaryingNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size[0], &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size[0], @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size[0], &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, @size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, @size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, @size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: array of DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size, &type[0], ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: DummyEnum; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size, @&type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: string); begin var ptr_7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size, &type, ptr_7); Marshal.FreeHGlobal(ptr_7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr) := z_GetActiveVaryingNV(&program, index, bufSize, length, size, &type, name);
    
    public z_ActiveVaryingNV := GetGLFuncOrNil&<procedure(&program: UInt32; name: IntPtr)>('glActiveVaryingNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveVaryingNV(&program: UInt32; name: string); begin var ptr_2 := Marshal.StringToHGlobalAnsi(name); ActiveVaryingNV(&program, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveVaryingNV(&program: UInt32; name: IntPtr) := z_ActiveVaryingNV(&program, name);
    
    {$endregion NV_transform_feedback}
    
    {$region NV_alpha_to_coverage_dither_control}
    
    public z_AlphaToCoverageDitherControlNV := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glAlphaToCoverageDitherControlNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaToCoverageDitherControlNV(mode: DummyEnum) := z_AlphaToCoverageDitherControlNV(mode);
    
    {$endregion NV_alpha_to_coverage_dither_control}
    
    {$region NV_vertex_program}
    
    public z_BindProgramNV := GetGLFuncOrNil&<procedure(target: DummyEnum; id: UInt32)>('glBindProgramNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramNV(target: DummyEnum; id: UInt32) := z_BindProgramNV(target, id);
    
    public z_DeleteProgramsNV := GetGLFuncOrNil&<procedure(n: Int32; programs: pointer)>('glDeleteProgramsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsNV(n: Int32; programs: array of UInt32) := DeleteProgramsNV(n, programs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsNV(n: Int32; var programs: UInt32) := DeleteProgramsNV(n, @programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsNV(n: Int32; programs: pointer) := z_DeleteProgramsNV(n, programs);
    
    public z_ExecuteProgramNV := GetGLFuncOrNil&<procedure(target: DummyEnum; id: UInt32; &params: pointer)>('glExecuteProgramNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: DummyEnum; id: UInt32; &params: array of single) := ExecuteProgramNV(target, id, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: DummyEnum; id: UInt32; var &params: single) := ExecuteProgramNV(target, id, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: DummyEnum; id: UInt32; &params: pointer) := z_ExecuteProgramNV(target, id, &params);
    
    public z_GenProgramsNV := GetGLFuncOrNil&<procedure(n: Int32; programs: pointer)>('glGenProgramsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsNV(n: Int32; programs: array of UInt32) := GenProgramsNV(n, programs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsNV(n: Int32; var programs: UInt32) := GenProgramsNV(n, @programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsNV(n: Int32; programs: pointer) := z_GenProgramsNV(n, programs);
    
    public z_AreProgramsResidentNV := GetGLFuncOrNil&<function(n: Int32; programs: pointer; residences: pointer): boolean>('glAreProgramsResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: array of UInt32; residences: array of boolean): boolean := AreProgramsResidentNV(n, programs[0], residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: array of UInt32; var residences: boolean): boolean := AreProgramsResidentNV(n, programs[0], @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: array of UInt32; residences: pointer): boolean := AreProgramsResidentNV(n, programs[0], residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; var programs: UInt32; residences: array of boolean): boolean := AreProgramsResidentNV(n, @programs, residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; var programs: UInt32; var residences: boolean): boolean := AreProgramsResidentNV(n, @programs, @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; var programs: UInt32; residences: pointer): boolean := AreProgramsResidentNV(n, @programs, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: pointer; residences: array of boolean): boolean := AreProgramsResidentNV(n, programs, residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: pointer; var residences: boolean): boolean := AreProgramsResidentNV(n, programs, @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: pointer; residences: pointer): boolean := z_AreProgramsResidentNV(n, programs, residences);
    
    public z_RequestResidentProgramsNV := GetGLFuncOrNil&<procedure(n: Int32; programs: pointer)>('glRequestResidentProgramsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; programs: array of UInt32) := RequestResidentProgramsNV(n, programs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; var programs: UInt32) := RequestResidentProgramsNV(n, @programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; programs: pointer) := z_RequestResidentProgramsNV(n, programs);
    
    public z_GetProgramParameterfvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer)>('glGetProgramParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: array of single) := GetProgramParameterfvNV(target, index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; var &params: single) := GetProgramParameterfvNV(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := z_GetProgramParameterfvNV(target, index, pname, &params);
    
    public z_GetProgramParameterdvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer)>('glGetProgramParameterdvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterdvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: array of double) := GetProgramParameterdvNV(target, index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterdvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; var &params: double) := GetProgramParameterdvNV(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterdvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := z_GetProgramParameterdvNV(target, index, pname, &params);
    
    public z_GetProgramivNV := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetProgramivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivNV(id: UInt32; pname: DummyEnum; &params: array of Int32) := GetProgramivNV(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivNV(id: UInt32; pname: DummyEnum; var &params: Int32) := GetProgramivNV(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramivNV(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetProgramivNV(id, pname, &params);
    
    public z_GetProgramStringNV := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &program: pointer)>('glGetProgramStringNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringNV(id: UInt32; pname: DummyEnum; &program: array of Byte) := GetProgramStringNV(id, pname, &program[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringNV(id: UInt32; pname: DummyEnum; var &program: Byte) := GetProgramStringNV(id, pname, @&program);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringNV(id: UInt32; pname: DummyEnum; &program: pointer) := z_GetProgramStringNV(id, pname, &program);
    
    public z_GetTrackMatrixivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; address: UInt32; pname: DummyEnum; &params: pointer)>('glGetTrackMatrixivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTrackMatrixivNV(target: DummyEnum; address: UInt32; pname: DummyEnum; &params: array of Int32) := GetTrackMatrixivNV(target, address, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTrackMatrixivNV(target: DummyEnum; address: UInt32; pname: DummyEnum; var &params: Int32) := GetTrackMatrixivNV(target, address, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTrackMatrixivNV(target: DummyEnum; address: UInt32; pname: DummyEnum; &params: pointer) := z_GetTrackMatrixivNV(target, address, pname, &params);
    
    public z_GetVertexAttribdvNV := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribdvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvNV(index: UInt32; pname: DummyEnum; &params: array of double) := GetVertexAttribdvNV(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvNV(index: UInt32; pname: DummyEnum; var &params: double) := GetVertexAttribdvNV(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribdvNV(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribdvNV(index, pname, &params);
    
    public z_GetVertexAttribfvNV := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvNV(index: UInt32; pname: DummyEnum; &params: array of single) := GetVertexAttribfvNV(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvNV(index: UInt32; pname: DummyEnum; var &params: single) := GetVertexAttribfvNV(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribfvNV(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribfvNV(index, pname, &params);
    
    public z_GetVertexAttribivNV := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivNV(index: UInt32; pname: DummyEnum; &params: array of Int32) := GetVertexAttribivNV(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivNV(index: UInt32; pname: DummyEnum; var &params: Int32) := GetVertexAttribivNV(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribivNV(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribivNV(index, pname, &params);
    
    public z_GetVertexAttribPointervNV := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; _pointer: pointer)>('glGetVertexAttribPointervNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervNV(index: UInt32; pname: DummyEnum; _pointer: array of IntPtr) := GetVertexAttribPointervNV(index, pname, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervNV(index: UInt32; pname: DummyEnum; var _pointer: IntPtr) := GetVertexAttribPointervNV(index, pname, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribPointervNV(index: UInt32; pname: DummyEnum; _pointer: pointer) := z_GetVertexAttribPointervNV(index, pname, _pointer);
    
    public z_IsProgramNV := GetGLFuncOrNil&<function(id: UInt32): boolean>('glIsProgramNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsProgramNV(id: UInt32): boolean := z_IsProgramNV(id);
    
    public z_LoadProgramNV := GetGLFuncOrNil&<procedure(target: DummyEnum; id: UInt32; len: Int32; &program: pointer)>('glLoadProgramNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: DummyEnum; id: UInt32; len: Int32; &program: array of Byte) := LoadProgramNV(target, id, len, &program[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: DummyEnum; id: UInt32; len: Int32; var &program: Byte) := LoadProgramNV(target, id, len, @&program);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: DummyEnum; id: UInt32; len: Int32; &program: pointer) := z_LoadProgramNV(target, id, len, &program);
    
    public z_ProgramParameter4fNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single)>('glProgramParameter4fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fNV(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := z_ProgramParameter4fNV(target, index, x, y, z, w);
    
    public z_ProgramParameter4dNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double)>('glProgramParameter4dNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dNV(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := z_ProgramParameter4dNV(target, index, x, y, z, w);
    
    public z_ProgramParameter4dvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; v: pointer)>('glProgramParameter4dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: DummyEnum; index: UInt32; v: array of double) := ProgramParameter4dvNV(target, index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: DummyEnum; index: UInt32; var v: double) := ProgramParameter4dvNV(target, index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: DummyEnum; index: UInt32; v: pointer) := z_ProgramParameter4dvNV(target, index, v);
    
    public z_ProgramParameter4fvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; v: pointer)>('glProgramParameter4fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: DummyEnum; index: UInt32; v: array of single) := ProgramParameter4fvNV(target, index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: DummyEnum; index: UInt32; var v: single) := ProgramParameter4fvNV(target, index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: DummyEnum; index: UInt32; v: pointer) := z_ProgramParameter4fvNV(target, index, v);
    
    public z_ProgramParameters4dvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; v: pointer)>('glProgramParameters4dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: DummyEnum; index: UInt32; count: Int32; v: array of double) := ProgramParameters4dvNV(target, index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: DummyEnum; index: UInt32; count: Int32; var v: double) := ProgramParameters4dvNV(target, index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: DummyEnum; index: UInt32; count: Int32; v: pointer) := z_ProgramParameters4dvNV(target, index, count, v);
    
    public z_ProgramParameters4fvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; v: pointer)>('glProgramParameters4fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: DummyEnum; index: UInt32; count: Int32; v: array of single) := ProgramParameters4fvNV(target, index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: DummyEnum; index: UInt32; count: Int32; var v: single) := ProgramParameters4fvNV(target, index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: DummyEnum; index: UInt32; count: Int32; v: pointer) := z_ProgramParameters4fvNV(target, index, count, v);
    
    public z_TrackMatrixNV := GetGLFuncOrNil&<procedure(target: DummyEnum; address: UInt32; matrix: DummyEnum; transform: DummyEnum)>('glTrackMatrixNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TrackMatrixNV(target: DummyEnum; address: UInt32; matrix: DummyEnum; transform: DummyEnum) := z_TrackMatrixNV(target, address, matrix, transform);
    
    public z_VertexAttribPointerNV := GetGLFuncOrNil&<procedure(index: UInt32; fsize: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glVertexAttribPointerNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribPointerNV(index: UInt32; fsize: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_VertexAttribPointerNV(index, fsize, &type, stride, _pointer);
    
    public z_VertexAttrib1sNV := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16)>('glVertexAttrib1sNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1sNV(index: UInt32; x: Int16) := z_VertexAttrib1sNV(index, x);
    
    public z_VertexAttrib1fNV := GetGLFuncOrNil&<procedure(index: UInt32; x: single)>('glVertexAttrib1fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fNV(index: UInt32; x: single) := z_VertexAttrib1fNV(index, x);
    
    public z_VertexAttrib1dNV := GetGLFuncOrNil&<procedure(index: UInt32; x: double)>('glVertexAttrib1dNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dNV(index: UInt32; x: double) := z_VertexAttrib1dNV(index, x);
    
    public z_VertexAttrib2sNV := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16; y: Int16)>('glVertexAttrib2sNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2sNV(index: UInt32; x: Int16; y: Int16) := z_VertexAttrib2sNV(index, x, y);
    
    public z_VertexAttrib2fNV := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single)>('glVertexAttrib2fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fNV(index: UInt32; x: single; y: single) := z_VertexAttrib2fNV(index, x, y);
    
    public z_VertexAttrib2dNV := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double)>('glVertexAttrib2dNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dNV(index: UInt32; x: double; y: double) := z_VertexAttrib2dNV(index, x, y);
    
    public z_VertexAttrib3sNV := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16)>('glVertexAttrib3sNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3sNV(index: UInt32; x: Int16; y: Int16; z: Int16) := z_VertexAttrib3sNV(index, x, y, z);
    
    public z_VertexAttrib3fNV := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single; z: single)>('glVertexAttrib3fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fNV(index: UInt32; x: single; y: single; z: single) := z_VertexAttrib3fNV(index, x, y, z);
    
    public z_VertexAttrib3dNV := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double; z: double)>('glVertexAttrib3dNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dNV(index: UInt32; x: double; y: double; z: double) := z_VertexAttrib3dNV(index, x, y, z);
    
    public z_VertexAttrib4sNV := GetGLFuncOrNil&<procedure(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16)>('glVertexAttrib4sNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4sNV(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16) := z_VertexAttrib4sNV(index, x, y, z, w);
    
    public z_VertexAttrib4fNV := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single; z: single; w: single)>('glVertexAttrib4fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fNV(index: UInt32; x: single; y: single; z: single; w: single) := z_VertexAttrib4fNV(index, x, y, z, w);
    
    public z_VertexAttrib4dNV := GetGLFuncOrNil&<procedure(index: UInt32; x: double; y: double; z: double; w: double)>('glVertexAttrib4dNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dNV(index: UInt32; x: double; y: double; z: double; w: double) := z_VertexAttrib4dNV(index, x, y, z, w);
    
    public z_VertexAttrib4ubNV := GetGLFuncOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>('glVertexAttrib4ubNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubNV(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) := z_VertexAttrib4ubNV(index, x, y, z, w);
    
    public z_VertexAttrib1svNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib1svNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svNV(index: UInt32; v: array of Int16) := VertexAttrib1svNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svNV(index: UInt32; var v: Int16) := VertexAttrib1svNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1svNV(index: UInt32; v: pointer) := z_VertexAttrib1svNV(index, v);
    
    public z_VertexAttrib1fvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib1fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvNV(index: UInt32; v: array of single) := VertexAttrib1fvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvNV(index: UInt32; var v: single) := VertexAttrib1fvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1fvNV(index: UInt32; v: pointer) := z_VertexAttrib1fvNV(index, v);
    
    public z_VertexAttrib1dvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib1dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvNV(index: UInt32; v: array of double) := VertexAttrib1dvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvNV(index: UInt32; var v: double) := VertexAttrib1dvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1dvNV(index: UInt32; v: pointer) := z_VertexAttrib1dvNV(index, v);
    
    public z_VertexAttrib2svNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib2svNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svNV(index: UInt32; v: array of Int16) := VertexAttrib2svNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svNV(index: UInt32; var v: Int16) := VertexAttrib2svNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2svNV(index: UInt32; v: pointer) := z_VertexAttrib2svNV(index, v);
    
    public z_VertexAttrib2fvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib2fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvNV(index: UInt32; v: array of single) := VertexAttrib2fvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvNV(index: UInt32; var v: single) := VertexAttrib2fvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2fvNV(index: UInt32; v: pointer) := z_VertexAttrib2fvNV(index, v);
    
    public z_VertexAttrib2dvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib2dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvNV(index: UInt32; v: array of double) := VertexAttrib2dvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvNV(index: UInt32; var v: double) := VertexAttrib2dvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2dvNV(index: UInt32; v: pointer) := z_VertexAttrib2dvNV(index, v);
    
    public z_VertexAttrib3svNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib3svNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svNV(index: UInt32; v: array of Int16) := VertexAttrib3svNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svNV(index: UInt32; var v: Int16) := VertexAttrib3svNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3svNV(index: UInt32; v: pointer) := z_VertexAttrib3svNV(index, v);
    
    public z_VertexAttrib3fvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib3fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvNV(index: UInt32; v: array of single) := VertexAttrib3fvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvNV(index: UInt32; var v: single) := VertexAttrib3fvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3fvNV(index: UInt32; v: pointer) := z_VertexAttrib3fvNV(index, v);
    
    public z_VertexAttrib3dvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib3dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvNV(index: UInt32; v: array of double) := VertexAttrib3dvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvNV(index: UInt32; var v: double) := VertexAttrib3dvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3dvNV(index: UInt32; v: pointer) := z_VertexAttrib3dvNV(index, v);
    
    public z_VertexAttrib4svNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4svNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svNV(index: UInt32; v: array of Int16) := VertexAttrib4svNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svNV(index: UInt32; var v: Int16) := VertexAttrib4svNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4svNV(index: UInt32; v: pointer) := z_VertexAttrib4svNV(index, v);
    
    public z_VertexAttrib4fvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvNV(index: UInt32; v: array of single) := VertexAttrib4fvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvNV(index: UInt32; var v: single) := VertexAttrib4fvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4fvNV(index: UInt32; v: pointer) := z_VertexAttrib4fvNV(index, v);
    
    public z_VertexAttrib4dvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvNV(index: UInt32; v: array of double) := VertexAttrib4dvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvNV(index: UInt32; var v: double) := VertexAttrib4dvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4dvNV(index: UInt32; v: pointer) := z_VertexAttrib4dvNV(index, v);
    
    public z_VertexAttrib4ubvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4ubvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvNV(index: UInt32; v: array of Byte) := VertexAttrib4ubvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvNV(index: UInt32; var v: Byte) := VertexAttrib4ubvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubvNV(index: UInt32; v: pointer) := z_VertexAttrib4ubvNV(index, v);
    
    public z_VertexAttribs1svNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs1svNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; v: array of Int16) := VertexAttribs1svNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; var v: Int16) := VertexAttribs1svNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs1svNV(index, count, v);
    
    public z_VertexAttribs1fvNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs1fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; v: array of single) := VertexAttribs1fvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; var v: single) := VertexAttribs1fvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs1fvNV(index, count, v);
    
    public z_VertexAttribs1dvNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs1dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; v: array of double) := VertexAttribs1dvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; var v: double) := VertexAttribs1dvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs1dvNV(index, count, v);
    
    public z_VertexAttribs2svNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs2svNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; v: array of Int16) := VertexAttribs2svNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; var v: Int16) := VertexAttribs2svNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs2svNV(index, count, v);
    
    public z_VertexAttribs2fvNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs2fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; v: array of single) := VertexAttribs2fvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; var v: single) := VertexAttribs2fvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs2fvNV(index, count, v);
    
    public z_VertexAttribs2dvNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs2dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; v: array of double) := VertexAttribs2dvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; var v: double) := VertexAttribs2dvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs2dvNV(index, count, v);
    
    public z_VertexAttribs3svNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs3svNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; v: array of Int16) := VertexAttribs3svNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; var v: Int16) := VertexAttribs3svNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs3svNV(index, count, v);
    
    public z_VertexAttribs3fvNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs3fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; v: array of single) := VertexAttribs3fvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; var v: single) := VertexAttribs3fvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs3fvNV(index, count, v);
    
    public z_VertexAttribs3dvNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs3dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; v: array of double) := VertexAttribs3dvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; var v: double) := VertexAttribs3dvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs3dvNV(index, count, v);
    
    public z_VertexAttribs4svNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs4svNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; v: array of Int16) := VertexAttribs4svNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; var v: Int16) := VertexAttribs4svNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs4svNV(index, count, v);
    
    public z_VertexAttribs4fvNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs4fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; v: array of single) := VertexAttribs4fvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; var v: single) := VertexAttribs4fvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs4fvNV(index, count, v);
    
    public z_VertexAttribs4dvNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs4dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; v: array of double) := VertexAttribs4dvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; var v: double) := VertexAttribs4dvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs4dvNV(index, count, v);
    
    public z_VertexAttribs4ubvNV := GetGLFuncOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>('glVertexAttribs4ubvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; v: array of Byte) := VertexAttribs4ubvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; var v: Byte) := VertexAttribs4ubvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs4ubvNV(index, count, v);
    
    {$endregion NV_vertex_program}
    
    {$region NV_conditional_render}
    
    public z_BeginConditionalRenderNV := GetGLFuncOrNil&<procedure(id: UInt32; mode: DummyEnum)>('glBeginConditionalRenderNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginConditionalRenderNV(id: UInt32; mode: DummyEnum) := z_BeginConditionalRenderNV(id, mode);
    
    public z_EndConditionalRenderNV := GetGLFuncOrNil&<procedure>('glEndConditionalRenderNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndConditionalRenderNV := z_EndConditionalRenderNV;
    
    {$endregion NV_conditional_render}
    
    {$region NV_occlusion_query}
    
    public z_GenOcclusionQueriesNV := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glGenOcclusionQueriesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; ids: array of UInt32) := GenOcclusionQueriesNV(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; var ids: UInt32) := GenOcclusionQueriesNV(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; ids: pointer) := z_GenOcclusionQueriesNV(n, ids);
    
    public z_DeleteOcclusionQueriesNV := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glDeleteOcclusionQueriesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; ids: array of UInt32) := DeleteOcclusionQueriesNV(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; var ids: UInt32) := DeleteOcclusionQueriesNV(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; ids: pointer) := z_DeleteOcclusionQueriesNV(n, ids);
    
    public z_IsOcclusionQueryNV := GetGLFuncOrNil&<function(id: UInt32): boolean>('glIsOcclusionQueryNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsOcclusionQueryNV(id: UInt32): boolean := z_IsOcclusionQueryNV(id);
    
    public z_BeginOcclusionQueryNV := GetGLFuncOrNil&<procedure(id: UInt32)>('glBeginOcclusionQueryNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginOcclusionQueryNV(id: UInt32) := z_BeginOcclusionQueryNV(id);
    
    public z_EndOcclusionQueryNV := GetGLFuncOrNil&<procedure>('glEndOcclusionQueryNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndOcclusionQueryNV := z_EndOcclusionQueryNV;
    
    public z_GetOcclusionQueryivNV := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetOcclusionQueryivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryivNV(id: UInt32; pname: DummyEnum; &params: array of Int32) := GetOcclusionQueryivNV(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryivNV(id: UInt32; pname: DummyEnum; var &params: Int32) := GetOcclusionQueryivNV(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryivNV(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetOcclusionQueryivNV(id, pname, &params);
    
    public z_GetOcclusionQueryuivNV := GetGLFuncOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>('glGetOcclusionQueryuivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryuivNV(id: UInt32; pname: DummyEnum; &params: array of UInt32) := GetOcclusionQueryuivNV(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryuivNV(id: UInt32; pname: DummyEnum; var &params: UInt32) := GetOcclusionQueryuivNV(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryuivNV(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetOcclusionQueryuivNV(id, pname, &params);
    
    {$endregion NV_occlusion_query}
    
    {$region NV_parameter_buffer_object NV_transform_feedback}
    
    public z_BindBufferRangeNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr; size: UIntPtr)>('glBindBufferRangeNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferRangeNV(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr; size: UIntPtr) := z_BindBufferRangeNV(target, index, buffer, offset, size);
    
    public z_BindBufferBaseNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; buffer: UInt32)>('glBindBufferBaseNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferBaseNV(target: DummyEnum; index: UInt32; buffer: UInt32) := z_BindBufferBaseNV(target, index, buffer);
    
    {$endregion NV_parameter_buffer_object NV_transform_feedback}
    
    {$region ARB_transform_feedback3 NV_parameter_buffer_object NV_transform_feedback}
    
    public z_BindBufferOffsetNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr)>('glBindBufferOffsetNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferOffsetNV(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr) := z_BindBufferOffsetNV(target, index, buffer, offset);
    
    {$endregion ARB_transform_feedback3 NV_parameter_buffer_object NV_transform_feedback}
    
    {$region NV_shading_rate_image}
    
    public z_BindShadingRateImageNV := GetGLFuncOrNil&<procedure(texture: UInt32)>('glBindShadingRateImageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindShadingRateImageNV(texture: UInt32) := z_BindShadingRateImageNV(texture);
    
    public z_ShadingRateImagePaletteNV := GetGLFuncOrNil&<procedure(viewport: UInt32; first: UInt32; count: Int32; rates: pointer)>('glShadingRateImagePaletteNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; rates: array of DummyEnum) := ShadingRateImagePaletteNV(viewport, first, count, rates[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; var rates: DummyEnum) := ShadingRateImagePaletteNV(viewport, first, count, @rates);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; rates: pointer) := z_ShadingRateImagePaletteNV(viewport, first, count, rates);
    
    public z_GetShadingRateImagePaletteNV := GetGLFuncOrNil&<procedure(viewport: UInt32; entry: UInt32; rate: pointer)>('glGetShadingRateImagePaletteNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; rate: array of DummyEnum) := GetShadingRateImagePaletteNV(viewport, entry, rate[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; var rate: DummyEnum) := GetShadingRateImagePaletteNV(viewport, entry, @rate);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; rate: pointer) := z_GetShadingRateImagePaletteNV(viewport, entry, rate);
    
    public z_ShadingRateSampleOrderCustomNV := GetGLFuncOrNil&<procedure(rate: DummyEnum; samples: UInt32; locations: pointer)>('glShadingRateSampleOrderCustomNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; locations: array of Int32) := ShadingRateSampleOrderCustomNV(rate, samples, locations[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; var locations: Int32) := ShadingRateSampleOrderCustomNV(rate, samples, @locations);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; locations: pointer) := z_ShadingRateSampleOrderCustomNV(rate, samples, locations);
    
    public z_GetShadingRateSampleLocationivNV := GetGLFuncOrNil&<procedure(rate: DummyEnum; samples: UInt32; index: UInt32; location: pointer)>('glGetShadingRateSampleLocationivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateSampleLocationivNV(rate: DummyEnum; samples: UInt32; index: UInt32; location: array of Int32) := GetShadingRateSampleLocationivNV(rate, samples, index, location[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateSampleLocationivNV(rate: DummyEnum; samples: UInt32; index: UInt32; var location: Int32) := GetShadingRateSampleLocationivNV(rate, samples, index, @location);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateSampleLocationivNV(rate: DummyEnum; samples: UInt32; index: UInt32; location: pointer) := z_GetShadingRateSampleLocationivNV(rate, samples, index, location);
    
    public z_ShadingRateSampleOrderNV := GetGLFuncOrNil&<procedure(order: DummyEnum)>('glShadingRateSampleOrderNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderNV(order: DummyEnum) := z_ShadingRateSampleOrderNV(order);
    
    {$endregion NV_shading_rate_image}
    
    {$region NV_transform_feedback2}
    
    public z_BindTransformFeedbackNV := GetGLFuncOrNil&<procedure(target: DummyEnum; id: UInt32)>('glBindTransformFeedbackNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTransformFeedbackNV(target: DummyEnum; id: UInt32) := z_BindTransformFeedbackNV(target, id);
    
    public z_DeleteTransformFeedbacksNV := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glDeleteTransformFeedbacksNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacksNV(n: Int32; ids: array of UInt32) := DeleteTransformFeedbacksNV(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacksNV(n: Int32; var ids: UInt32) := DeleteTransformFeedbacksNV(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteTransformFeedbacksNV(n: Int32; ids: pointer) := z_DeleteTransformFeedbacksNV(n, ids);
    
    public z_GenTransformFeedbacksNV := GetGLFuncOrNil&<procedure(n: Int32; ids: pointer)>('glGenTransformFeedbacksNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacksNV(n: Int32; ids: array of UInt32) := GenTransformFeedbacksNV(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacksNV(n: Int32; var ids: UInt32) := GenTransformFeedbacksNV(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenTransformFeedbacksNV(n: Int32; ids: pointer) := z_GenTransformFeedbacksNV(n, ids);
    
    public z_IsTransformFeedbackNV := GetGLFuncOrNil&<function(id: UInt32): boolean>('glIsTransformFeedbackNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTransformFeedbackNV(id: UInt32): boolean := z_IsTransformFeedbackNV(id);
    
    public z_PauseTransformFeedbackNV := GetGLFuncOrNil&<procedure>('glPauseTransformFeedbackNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PauseTransformFeedbackNV := z_PauseTransformFeedbackNV;
    
    public z_ResumeTransformFeedbackNV := GetGLFuncOrNil&<procedure>('glResumeTransformFeedbackNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResumeTransformFeedbackNV := z_ResumeTransformFeedbackNV;
    
    public z_DrawTransformFeedbackNV := GetGLFuncOrNil&<procedure(mode: DummyEnum; id: UInt32)>('glDrawTransformFeedbackNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTransformFeedbackNV(mode: DummyEnum; id: UInt32) := z_DrawTransformFeedbackNV(mode, id);
    
    {$endregion NV_transform_feedback2}
    
    {$region NV_blend_equation_advanced}
    
    public z_BlendParameteriNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; value: Int32)>('glBlendParameteriNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendParameteriNV(pname: DummyEnum; value: Int32) := z_BlendParameteriNV(pname, value);
    
    public z_BlendBarrierNV := GetGLFuncOrNil&<procedure>('glBlendBarrierNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendBarrierNV := z_BlendBarrierNV;
    
    {$endregion NV_blend_equation_advanced}
    
    {$region NV_framebuffer_blit}
    
    public z_BlitFramebufferNV := GetGLFuncOrNil&<procedure(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>('glBlitFramebufferNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlitFramebufferNV(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := z_BlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    {$endregion NV_framebuffer_blit}
    
    {$region NV_vertex_buffer_unified_memory}
    
    public z_BufferAddressRangeNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; index: UInt32; address: UInt64; length: UIntPtr)>('glBufferAddressRangeNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferAddressRangeNV(pname: DummyEnum; index: UInt32; address: UInt64; length: UIntPtr) := z_BufferAddressRangeNV(pname, index, address, length);
    
    public z_VertexFormatNV := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>('glVertexFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexFormatNV(size: Int32; &type: DummyEnum; stride: Int32) := z_VertexFormatNV(size, &type, stride);
    
    public z_NormalFormatNV := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32)>('glNormalFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalFormatNV(&type: DummyEnum; stride: Int32) := z_NormalFormatNV(&type, stride);
    
    public z_ColorFormatNV := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>('glColorFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFormatNV(size: Int32; &type: DummyEnum; stride: Int32) := z_ColorFormatNV(size, &type, stride);
    
    public z_IndexFormatNV := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32)>('glIndexFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexFormatNV(&type: DummyEnum; stride: Int32) := z_IndexFormatNV(&type, stride);
    
    public z_TexCoordFormatNV := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>('glTexCoordFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordFormatNV(size: Int32; &type: DummyEnum; stride: Int32) := z_TexCoordFormatNV(size, &type, stride);
    
    public z_EdgeFlagFormatNV := GetGLFuncOrNil&<procedure(stride: Int32)>('glEdgeFlagFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagFormatNV(stride: Int32) := z_EdgeFlagFormatNV(stride);
    
    public z_SecondaryColorFormatNV := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>('glSecondaryColorFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorFormatNV(size: Int32; &type: DummyEnum; stride: Int32) := z_SecondaryColorFormatNV(size, &type, stride);
    
    public z_FogCoordFormatNV := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32)>('glFogCoordFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordFormatNV(&type: DummyEnum; stride: Int32) := z_FogCoordFormatNV(&type, stride);
    
    public z_VertexAttribFormatNV := GetGLFuncOrNil&<procedure(index: UInt32; size: Int32; &type: DummyEnum; normalized: boolean; stride: Int32)>('glVertexAttribFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribFormatNV(index: UInt32; size: Int32; &type: DummyEnum; normalized: boolean; stride: Int32) := z_VertexAttribFormatNV(index, size, &type, normalized, stride);
    
    public z_VertexAttribIFormatNV := GetGLFuncOrNil&<procedure(index: UInt32; size: Int32; &type: DummyEnum; stride: Int32)>('glVertexAttribIFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribIFormatNV(index: UInt32; size: Int32; &type: DummyEnum; stride: Int32) := z_VertexAttribIFormatNV(index, size, &type, stride);
    
    public z_GetIntegerui64i_vNV := GetGLFuncOrNil&<procedure(value: GLGetQueries; index: UInt32; result: pointer)>('glGetIntegerui64i_vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64i_vNV(value: GLGetQueries; index: UInt32; result: array of UInt64) := GetIntegerui64i_vNV(value, index, result[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64i_vNV(value: GLGetQueries; index: UInt32; var result: UInt64) := GetIntegerui64i_vNV(value, index, @result);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64i_vNV(value: GLGetQueries; index: UInt32; result: pointer) := z_GetIntegerui64i_vNV(value, index, result);
    
    {$endregion NV_vertex_buffer_unified_memory}
    
    {$region NV_memory_attachment}
    
    public z_GetMemoryObjectDetachedResourcesuivNV := GetGLFuncOrNil&<procedure(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: pointer)>('glGetMemoryObjectDetachedResourcesuivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: array of UInt32) := GetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; var &params: UInt32) := GetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: pointer) := z_GetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, &params);
    
    public z_ResetMemoryObjectParameterNV := GetGLFuncOrNil&<procedure(memory: UInt32; pname: DummyEnum)>('glResetMemoryObjectParameterNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMemoryObjectParameterNV(memory: UInt32; pname: DummyEnum) := z_ResetMemoryObjectParameterNV(memory, pname);
    
    public z_TexAttachMemoryNV := GetGLFuncOrNil&<procedure(target: DummyEnum; memory: UInt32; offset: UInt64)>('glTexAttachMemoryNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexAttachMemoryNV(target: DummyEnum; memory: UInt32; offset: UInt64) := z_TexAttachMemoryNV(target, memory, offset);
    
    public z_BufferAttachMemoryNV := GetGLFuncOrNil&<procedure(target: DummyEnum; memory: UInt32; offset: UInt64)>('glBufferAttachMemoryNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferAttachMemoryNV(target: DummyEnum; memory: UInt32; offset: UInt64) := z_BufferAttachMemoryNV(target, memory, offset);
    
    public z_TextureAttachMemoryNV := GetGLFuncOrNil&<procedure(texture: UInt32; memory: UInt32; offset: UInt64)>('glTextureAttachMemoryNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureAttachMemoryNV(texture: UInt32; memory: UInt32; offset: UInt64) := z_TextureAttachMemoryNV(texture, memory, offset);
    
    public z_NamedBufferAttachMemoryNV := GetGLFuncOrNil&<procedure(buffer: UInt32; memory: UInt32; offset: UInt64)>('glNamedBufferAttachMemoryNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferAttachMemoryNV(buffer: UInt32; memory: UInt32; offset: UInt64) := z_NamedBufferAttachMemoryNV(buffer, memory, offset);
    
    {$endregion NV_memory_attachment}
    
    {$region NV_command_list}
    
    public z_CreateStatesNV := GetGLFuncOrNil&<procedure(n: Int32; states: pointer)>('glCreateStatesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; states: array of UInt32) := CreateStatesNV(n, states[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; var states: UInt32) := CreateStatesNV(n, @states);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; states: pointer) := z_CreateStatesNV(n, states);
    
    public z_DeleteStatesNV := GetGLFuncOrNil&<procedure(n: Int32; states: pointer)>('glDeleteStatesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; states: array of UInt32) := DeleteStatesNV(n, states[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; var states: UInt32) := DeleteStatesNV(n, @states);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; states: pointer) := z_DeleteStatesNV(n, states);
    
    public z_IsStateNV := GetGLFuncOrNil&<function(state: UInt32): boolean>('glIsStateNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsStateNV(state: UInt32): boolean := z_IsStateNV(state);
    
    public z_StateCaptureNV := GetGLFuncOrNil&<procedure(state: UInt32; mode: DummyEnum)>('glStateCaptureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StateCaptureNV(state: UInt32; mode: DummyEnum) := z_StateCaptureNV(state, mode);
    
    public z_GetCommandHeaderNV := GetGLFuncOrNil&<function(tokenID: DummyEnum; size: UInt32): UInt32>('glGetCommandHeaderNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandHeaderNV(tokenID: DummyEnum; size: UInt32): UInt32 := z_GetCommandHeaderNV(tokenID, size);
    
    public z_GetStageIndexNV := GetGLFuncOrNil&<function(shadertype: DummyEnum): UInt16>('glGetStageIndexNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetStageIndexNV(shadertype: DummyEnum): UInt16 := z_GetStageIndexNV(shadertype);
    
    public z_DrawCommandsNV := GetGLFuncOrNil&<procedure(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: pointer; count: UInt32)>('glDrawCommandsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, indirects[0], sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, indirects[0], @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: array of IntPtr; sizes: pointer; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, indirects[0], sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, @indirects, sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; var sizes: Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, @indirects, @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; sizes: pointer; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, @indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: array of Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, indirects, sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; var sizes: Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, indirects, @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: pointer; count: UInt32) := z_DrawCommandsNV(primitiveMode, buffer, indirects, sizes, count);
    
    public z_DrawCommandsAddressNV := GetGLFuncOrNil&<procedure(primitiveMode: DummyEnum; indirects: pointer; sizes: pointer; count: UInt32)>('glDrawCommandsAddressNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: array of UInt64; sizes: array of Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, indirects[0], sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: array of UInt64; var sizes: Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, indirects[0], @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: array of UInt64; sizes: pointer; count: UInt32) := DrawCommandsAddressNV(primitiveMode, indirects[0], sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; var indirects: UInt64; sizes: array of Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, @indirects, sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; var indirects: UInt64; var sizes: Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, @indirects, @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; var indirects: UInt64; sizes: pointer; count: UInt32) := DrawCommandsAddressNV(primitiveMode, @indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: pointer; sizes: array of Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, indirects, sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: pointer; var sizes: Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, indirects, @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: pointer; sizes: pointer; count: UInt32) := z_DrawCommandsAddressNV(primitiveMode, indirects, sizes, count);
    
    public z_DrawCommandsStatesNV := GetGLFuncOrNil&<procedure(buffer: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32)>('glDrawCommandsStatesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := z_DrawCommandsStatesNV(buffer, indirects, sizes, states, fbos, count);
    
    public z_DrawCommandsStatesAddressNV := GetGLFuncOrNil&<procedure(indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32)>('glDrawCommandsStatesAddressNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := z_DrawCommandsStatesAddressNV(indirects, sizes, states, fbos, count);
    
    public z_CreateCommandListsNV := GetGLFuncOrNil&<procedure(n: Int32; lists: pointer)>('glCreateCommandListsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; lists: array of UInt32) := CreateCommandListsNV(n, lists[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; var lists: UInt32) := CreateCommandListsNV(n, @lists);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; lists: pointer) := z_CreateCommandListsNV(n, lists);
    
    public z_DeleteCommandListsNV := GetGLFuncOrNil&<procedure(n: Int32; lists: pointer)>('glDeleteCommandListsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; lists: array of UInt32) := DeleteCommandListsNV(n, lists[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; var lists: UInt32) := DeleteCommandListsNV(n, @lists);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; lists: pointer) := z_DeleteCommandListsNV(n, lists);
    
    public z_IsCommandListNV := GetGLFuncOrNil&<function(list: UInt32): boolean>('glIsCommandListNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsCommandListNV(list: UInt32): boolean := z_IsCommandListNV(list);
    
    public z_ListDrawCommandsStatesClientNV := GetGLFuncOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32)>('glListDrawCommandsStatesClientNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := z_ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, fbos, count);
    
    public z_CommandListSegmentsNV := GetGLFuncOrNil&<procedure(list: UInt32; segments: UInt32)>('glCommandListSegmentsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CommandListSegmentsNV(list: UInt32; segments: UInt32) := z_CommandListSegmentsNV(list, segments);
    
    public z_CompileCommandListNV := GetGLFuncOrNil&<procedure(list: UInt32)>('glCompileCommandListNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileCommandListNV(list: UInt32) := z_CompileCommandListNV(list);
    
    public z_CallCommandListNV := GetGLFuncOrNil&<procedure(list: UInt32)>('glCallCommandListNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallCommandListNV(list: UInt32) := z_CallCommandListNV(list);
    
    {$endregion NV_command_list}
    
    {$region NV_depth_buffer_float}
    
    public z_DepthRangedNV := GetGLFuncOrNil&<procedure(zNear: double; zFar: double)>('glDepthRangedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangedNV(zNear: double; zFar: double) := z_DepthRangedNV(zNear, zFar);
    
    public z_ClearDepthdNV := GetGLFuncOrNil&<procedure(depth: double)>('glClearDepthdNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthdNV(depth: double) := z_ClearDepthdNV(depth);
    
    public z_DepthBoundsdNV := GetGLFuncOrNil&<procedure(zmin: double; zmax: double)>('glDepthBoundsdNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthBoundsdNV(zmin: double; zmax: double) := z_DepthBoundsdNV(zmin, zmax);
    
    {$endregion NV_depth_buffer_float}
    
    {$region NV_half_float}
    
    public z_Vertex2hNV := GetGLFuncOrNil&<procedure(x: half; y: half)>('glVertex2hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hNV(x: half; y: half) := z_Vertex2hNV(x, y);
    
    public z_Vertex2hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glVertex2hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(v: array of half) := Vertex2hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(var v: half) := Vertex2hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(v: pointer) := z_Vertex2hvNV(v);
    
    public z_Vertex3hNV := GetGLFuncOrNil&<procedure(x: half; y: half; z: half)>('glVertex3hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hNV(x: half; y: half; z: half) := z_Vertex3hNV(x, y, z);
    
    public z_Vertex3hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glVertex3hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(v: array of half) := Vertex3hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(var v: half) := Vertex3hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(v: pointer) := z_Vertex3hvNV(v);
    
    public z_Vertex4hNV := GetGLFuncOrNil&<procedure(x: half; y: half; z: half; w: half)>('glVertex4hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hNV(x: half; y: half; z: half; w: half) := z_Vertex4hNV(x, y, z, w);
    
    public z_Vertex4hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glVertex4hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(v: array of half) := Vertex4hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(var v: half) := Vertex4hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(v: pointer) := z_Vertex4hvNV(v);
    
    public z_Normal3hNV := GetGLFuncOrNil&<procedure(nx: half; ny: half; nz: half)>('glNormal3hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hNV(nx: half; ny: half; nz: half) := z_Normal3hNV(nx, ny, nz);
    
    public z_Normal3hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glNormal3hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(v: array of half) := Normal3hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(var v: half) := Normal3hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(v: pointer) := z_Normal3hvNV(v);
    
    public z_Color3hNV := GetGLFuncOrNil&<procedure(red: half; green: half; blue: half)>('glColor3hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hNV(red: half; green: half; blue: half) := z_Color3hNV(red, green, blue);
    
    public z_Color3hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glColor3hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(v: array of half) := Color3hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(var v: half) := Color3hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(v: pointer) := z_Color3hvNV(v);
    
    public z_Color4hNV := GetGLFuncOrNil&<procedure(red: half; green: half; blue: half; alpha: half)>('glColor4hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hNV(red: half; green: half; blue: half; alpha: half) := z_Color4hNV(red, green, blue, alpha);
    
    public z_Color4hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glColor4hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(v: array of half) := Color4hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(var v: half) := Color4hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(v: pointer) := z_Color4hvNV(v);
    
    public z_TexCoord1hNV := GetGLFuncOrNil&<procedure(s: half)>('glTexCoord1hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hNV(s: half) := z_TexCoord1hNV(s);
    
    public z_TexCoord1hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glTexCoord1hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(v: array of half) := TexCoord1hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(var v: half) := TexCoord1hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(v: pointer) := z_TexCoord1hvNV(v);
    
    public z_TexCoord2hNV := GetGLFuncOrNil&<procedure(s: half; t: half)>('glTexCoord2hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hNV(s: half; t: half) := z_TexCoord2hNV(s, t);
    
    public z_TexCoord2hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glTexCoord2hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(v: array of half) := TexCoord2hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(var v: half) := TexCoord2hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(v: pointer) := z_TexCoord2hvNV(v);
    
    public z_TexCoord3hNV := GetGLFuncOrNil&<procedure(s: half; t: half; r: half)>('glTexCoord3hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hNV(s: half; t: half; r: half) := z_TexCoord3hNV(s, t, r);
    
    public z_TexCoord3hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glTexCoord3hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(v: array of half) := TexCoord3hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(var v: half) := TexCoord3hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(v: pointer) := z_TexCoord3hvNV(v);
    
    public z_TexCoord4hNV := GetGLFuncOrNil&<procedure(s: half; t: half; r: half; q: half)>('glTexCoord4hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hNV(s: half; t: half; r: half; q: half) := z_TexCoord4hNV(s, t, r, q);
    
    public z_TexCoord4hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glTexCoord4hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(v: array of half) := TexCoord4hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(var v: half) := TexCoord4hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(v: pointer) := z_TexCoord4hvNV(v);
    
    public z_MultiTexCoord1hNV := GetGLFuncOrNil&<procedure(target: DummyEnum; s: half)>('glMultiTexCoord1hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hNV(target: DummyEnum; s: half) := z_MultiTexCoord1hNV(target, s);
    
    public z_MultiTexCoord1hvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord1hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: DummyEnum; v: array of half) := MultiTexCoord1hvNV(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: DummyEnum; var v: half) := MultiTexCoord1hvNV(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: DummyEnum; v: pointer) := z_MultiTexCoord1hvNV(target, v);
    
    public z_MultiTexCoord2hNV := GetGLFuncOrNil&<procedure(target: DummyEnum; s: half; t: half)>('glMultiTexCoord2hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hNV(target: DummyEnum; s: half; t: half) := z_MultiTexCoord2hNV(target, s, t);
    
    public z_MultiTexCoord2hvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord2hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: DummyEnum; v: array of half) := MultiTexCoord2hvNV(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: DummyEnum; var v: half) := MultiTexCoord2hvNV(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: DummyEnum; v: pointer) := z_MultiTexCoord2hvNV(target, v);
    
    public z_MultiTexCoord3hNV := GetGLFuncOrNil&<procedure(target: DummyEnum; s: half; t: half; r: half)>('glMultiTexCoord3hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hNV(target: DummyEnum; s: half; t: half; r: half) := z_MultiTexCoord3hNV(target, s, t, r);
    
    public z_MultiTexCoord3hvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord3hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: DummyEnum; v: array of half) := MultiTexCoord3hvNV(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: DummyEnum; var v: half) := MultiTexCoord3hvNV(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: DummyEnum; v: pointer) := z_MultiTexCoord3hvNV(target, v);
    
    public z_MultiTexCoord4hNV := GetGLFuncOrNil&<procedure(target: DummyEnum; s: half; t: half; r: half; q: half)>('glMultiTexCoord4hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hNV(target: DummyEnum; s: half; t: half; r: half; q: half) := z_MultiTexCoord4hNV(target, s, t, r, q);
    
    public z_MultiTexCoord4hvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; v: pointer)>('glMultiTexCoord4hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: DummyEnum; v: array of half) := MultiTexCoord4hvNV(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: DummyEnum; var v: half) := MultiTexCoord4hvNV(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: DummyEnum; v: pointer) := z_MultiTexCoord4hvNV(target, v);
    
    public z_VertexAttrib1hNV := GetGLFuncOrNil&<procedure(index: UInt32; x: half)>('glVertexAttrib1hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hNV(index: UInt32; x: half) := z_VertexAttrib1hNV(index, x);
    
    public z_VertexAttrib1hvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib1hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; v: array of half) := VertexAttrib1hvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; var v: half) := VertexAttrib1hvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; v: pointer) := z_VertexAttrib1hvNV(index, v);
    
    public z_VertexAttrib2hNV := GetGLFuncOrNil&<procedure(index: UInt32; x: half; y: half)>('glVertexAttrib2hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hNV(index: UInt32; x: half; y: half) := z_VertexAttrib2hNV(index, x, y);
    
    public z_VertexAttrib2hvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib2hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; v: array of half) := VertexAttrib2hvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; var v: half) := VertexAttrib2hvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; v: pointer) := z_VertexAttrib2hvNV(index, v);
    
    public z_VertexAttrib3hNV := GetGLFuncOrNil&<procedure(index: UInt32; x: half; y: half; z: half)>('glVertexAttrib3hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hNV(index: UInt32; x: half; y: half; z: half) := z_VertexAttrib3hNV(index, x, y, z);
    
    public z_VertexAttrib3hvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib3hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; v: array of half) := VertexAttrib3hvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; var v: half) := VertexAttrib3hvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; v: pointer) := z_VertexAttrib3hvNV(index, v);
    
    public z_VertexAttrib4hNV := GetGLFuncOrNil&<procedure(index: UInt32; x: half; y: half; z: half; w: half)>('glVertexAttrib4hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hNV(index: UInt32; x: half; y: half; z: half; w: half) := z_VertexAttrib4hNV(index, x, y, z, w);
    
    public z_VertexAttrib4hvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttrib4hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; v: array of half) := VertexAttrib4hvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; var v: half) := VertexAttrib4hvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; v: pointer) := z_VertexAttrib4hvNV(index, v);
    
    public z_VertexAttribs1hvNV := GetGLFuncOrNil&<procedure(index: UInt32; n: Int32; v: pointer)>('glVertexAttribs1hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; v: array of half) := VertexAttribs1hvNV(index, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; var v: half) := VertexAttribs1hvNV(index, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; v: pointer) := z_VertexAttribs1hvNV(index, n, v);
    
    public z_VertexAttribs2hvNV := GetGLFuncOrNil&<procedure(index: UInt32; n: Int32; v: pointer)>('glVertexAttribs2hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; v: array of half) := VertexAttribs2hvNV(index, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; var v: half) := VertexAttribs2hvNV(index, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; v: pointer) := z_VertexAttribs2hvNV(index, n, v);
    
    public z_VertexAttribs3hvNV := GetGLFuncOrNil&<procedure(index: UInt32; n: Int32; v: pointer)>('glVertexAttribs3hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; v: array of half) := VertexAttribs3hvNV(index, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; var v: half) := VertexAttribs3hvNV(index, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; v: pointer) := z_VertexAttribs3hvNV(index, n, v);
    
    public z_VertexAttribs4hvNV := GetGLFuncOrNil&<procedure(index: UInt32; n: Int32; v: pointer)>('glVertexAttribs4hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; v: array of half) := VertexAttribs4hvNV(index, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; var v: half) := VertexAttribs4hvNV(index, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; v: pointer) := z_VertexAttribs4hvNV(index, n, v);
    
    public z_FogCoordhNV := GetGLFuncOrNil&<procedure(fog: half)>('glFogCoordhNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhNV(fog: half) := z_FogCoordhNV(fog);
    
    public z_FogCoordhvNV := GetGLFuncOrNil&<procedure(fog: pointer)>('glFogCoordhvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(fog: array of half) := FogCoordhvNV(fog[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(var fog: half) := FogCoordhvNV(@fog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(fog: pointer) := z_FogCoordhvNV(fog);
    
    public z_SecondaryColor3hNV := GetGLFuncOrNil&<procedure(red: half; green: half; blue: half)>('glSecondaryColor3hNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hNV(red: half; green: half; blue: half) := z_SecondaryColor3hNV(red, green, blue);
    
    public z_SecondaryColor3hvNV := GetGLFuncOrNil&<procedure(v: pointer)>('glSecondaryColor3hvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(v: array of half) := SecondaryColor3hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(var v: half) := SecondaryColor3hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(v: pointer) := z_SecondaryColor3hvNV(v);
    
    public z_VertexWeighthNV := GetGLFuncOrNil&<procedure(weight: half)>('glVertexWeighthNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthNV(weight: half) := z_VertexWeighthNV(weight);
    
    public z_VertexWeighthvNV := GetGLFuncOrNil&<procedure(weight: pointer)>('glVertexWeighthvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(weight: array of half) := VertexWeighthvNV(weight[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(var weight: half) := VertexWeighthvNV(@weight);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(weight: pointer) := z_VertexWeighthvNV(weight);
    
    {$endregion NV_half_float}
    
    {$region NV_register_combiners}
    
    public z_CombinerParameterfvNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glCombinerParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: DummyEnum; &params: array of single) := CombinerParameterfvNV(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: DummyEnum; var &params: single) := CombinerParameterfvNV(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: DummyEnum; &params: pointer) := z_CombinerParameterfvNV(pname, &params);
    
    public z_CombinerParameterivNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glCombinerParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: DummyEnum; &params: array of Int32) := CombinerParameterivNV(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: DummyEnum; var &params: Int32) := CombinerParameterivNV(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: DummyEnum; &params: pointer) := z_CombinerParameterivNV(pname, &params);
    
    public z_CombinerParameterfNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: single)>('glCombinerParameterfNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfNV(pname: DummyEnum; param: single) := z_CombinerParameterfNV(pname, param);
    
    public z_CombinerParameteriNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: Int32)>('glCombinerParameteriNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameteriNV(pname: DummyEnum; param: Int32) := z_CombinerParameteriNV(pname, param);
    
    public z_CombinerInputNV := GetGLFuncOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; input: DummyEnum; mapping: DummyEnum; componentUsage: DummyEnum)>('glCombinerInputNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerInputNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; input: DummyEnum; mapping: DummyEnum; componentUsage: DummyEnum) := z_CombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
    
    public z_CombinerOutputNV := GetGLFuncOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; abOutput: DummyEnum; cdOutput: DummyEnum; sumOutput: DummyEnum; scale: DummyEnum; bias: DummyEnum; abDotProduct: boolean; cdDotProduct: boolean; muxSum: boolean)>('glCombinerOutputNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerOutputNV(stage: DummyEnum; portion: DummyEnum; abOutput: DummyEnum; cdOutput: DummyEnum; sumOutput: DummyEnum; scale: DummyEnum; bias: DummyEnum; abDotProduct: boolean; cdDotProduct: boolean; muxSum: boolean) := z_CombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
    
    public z_FinalCombinerInputNV := GetGLFuncOrNil&<procedure(variable: DummyEnum; input: DummyEnum; mapping: DummyEnum; componentUsage: DummyEnum)>('glFinalCombinerInputNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinalCombinerInputNV(variable: DummyEnum; input: DummyEnum; mapping: DummyEnum; componentUsage: DummyEnum) := z_FinalCombinerInputNV(variable, input, mapping, componentUsage);
    
    public z_GetCombinerInputParameterfvNV := GetGLFuncOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetCombinerInputParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterfvNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: array of single) := GetCombinerInputParameterfvNV(stage, portion, variable, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterfvNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; var &params: single) := GetCombinerInputParameterfvNV(stage, portion, variable, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterfvNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetCombinerInputParameterfvNV(stage, portion, variable, pname, &params);
    
    public z_GetCombinerInputParameterivNV := GetGLFuncOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetCombinerInputParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterivNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetCombinerInputParameterivNV(stage, portion, variable, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterivNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; var &params: Int32) := GetCombinerInputParameterivNV(stage, portion, variable, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterivNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetCombinerInputParameterivNV(stage, portion, variable, pname, &params);
    
    public z_GetCombinerOutputParameterfvNV := GetGLFuncOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetCombinerOutputParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterfvNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: array of single) := GetCombinerOutputParameterfvNV(stage, portion, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterfvNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; var &params: single) := GetCombinerOutputParameterfvNV(stage, portion, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterfvNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetCombinerOutputParameterfvNV(stage, portion, pname, &params);
    
    public z_GetCombinerOutputParameterivNV := GetGLFuncOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetCombinerOutputParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterivNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetCombinerOutputParameterivNV(stage, portion, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterivNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; var &params: Int32) := GetCombinerOutputParameterivNV(stage, portion, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterivNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetCombinerOutputParameterivNV(stage, portion, pname, &params);
    
    public z_GetFinalCombinerInputParameterfvNV := GetGLFuncOrNil&<procedure(variable: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetFinalCombinerInputParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterfvNV(variable: DummyEnum; pname: DummyEnum; &params: array of single) := GetFinalCombinerInputParameterfvNV(variable, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterfvNV(variable: DummyEnum; pname: DummyEnum; var &params: single) := GetFinalCombinerInputParameterfvNV(variable, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterfvNV(variable: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetFinalCombinerInputParameterfvNV(variable, pname, &params);
    
    public z_GetFinalCombinerInputParameterivNV := GetGLFuncOrNil&<procedure(variable: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetFinalCombinerInputParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterivNV(variable: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetFinalCombinerInputParameterivNV(variable, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterivNV(variable: DummyEnum; pname: DummyEnum; var &params: Int32) := GetFinalCombinerInputParameterivNV(variable, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterivNV(variable: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetFinalCombinerInputParameterivNV(variable, pname, &params);
    
    {$endregion NV_register_combiners}
    
    {$region NV_register_combiners2}
    
    public z_CombinerStageParameterfvNV := GetGLFuncOrNil&<procedure(stage: DummyEnum; pname: DummyEnum; &params: pointer)>('glCombinerStageParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; &params: array of single) := CombinerStageParameterfvNV(stage, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; var &params: single) := CombinerStageParameterfvNV(stage, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; &params: pointer) := z_CombinerStageParameterfvNV(stage, pname, &params);
    
    public z_GetCombinerStageParameterfvNV := GetGLFuncOrNil&<procedure(stage: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetCombinerStageParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; &params: array of single) := GetCombinerStageParameterfvNV(stage, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; var &params: single) := GetCombinerStageParameterfvNV(stage, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetCombinerStageParameterfvNV(stage, pname, &params);
    
    {$endregion NV_register_combiners2}
    
    {$region NV_conservative_raster_dilate}
    
    public z_ConservativeRasterParameterfNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; value: single)>('glConservativeRasterParameterfNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConservativeRasterParameterfNV(pname: DummyEnum; value: single) := z_ConservativeRasterParameterfNV(pname, value);
    
    {$endregion NV_conservative_raster_dilate}
    
    {$region NV_conservative_raster_pre_snap_triangles}
    
    public z_ConservativeRasterParameteriNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: Int32)>('glConservativeRasterParameteriNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConservativeRasterParameteriNV(pname: DummyEnum; param: Int32) := z_ConservativeRasterParameteriNV(pname, param);
    
    {$endregion NV_conservative_raster_pre_snap_triangles}
    
    {$region NV_copy_buffer}
    
    public z_CopyBufferSubDataNV := GetGLFuncOrNil&<procedure(readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>('glCopyBufferSubDataNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyBufferSubDataNV(readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_CopyBufferSubDataNV(readTarget, writeTarget, readOffset, writeOffset, size);
    
    {$endregion NV_copy_buffer}
    
    {$region NV_copy_image}
    
    public z_CopyImageSubDataNV := GetGLFuncOrNil&<procedure(srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>('glCopyImageSubDataNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubDataNV(srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) := z_CopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
    {$endregion NV_copy_image}
    
    {$region NV_path_rendering}
    
    public z_PathCommandsNV := GetGLFuncOrNil&<procedure(path: UInt32; numCommands: Int32; commands: pointer; numCoords: Int32; coordType: DummyEnum; coords: pointer)>('glPathCommandsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; commands: array of Byte; numCoords: Int32; coordType: DummyEnum; coords: pointer) := PathCommandsNV(path, numCommands, commands[0], numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; var commands: Byte; numCoords: Int32; coordType: DummyEnum; coords: pointer) := PathCommandsNV(path, numCommands, @commands, numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; commands: pointer; numCoords: Int32; coordType: DummyEnum; coords: pointer) := z_PathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
    
    public z_PathCoordsNV := GetGLFuncOrNil&<procedure(path: UInt32; numCoords: Int32; coordType: DummyEnum; coords: pointer)>('glPathCoordsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCoordsNV(path: UInt32; numCoords: Int32; coordType: DummyEnum; coords: pointer) := z_PathCoordsNV(path, numCoords, coordType, coords);
    
    public z_PathSubCommandsNV := GetGLFuncOrNil&<procedure(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: pointer; numCoords: Int32; coordType: DummyEnum; coords: pointer)>('glPathSubCommandsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: array of Byte; numCoords: Int32; coordType: DummyEnum; coords: pointer) := PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands[0], numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; var commands: Byte; numCoords: Int32; coordType: DummyEnum; coords: pointer) := PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, @commands, numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: pointer; numCoords: Int32; coordType: DummyEnum; coords: pointer) := z_PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    
    public z_PathSubCoordsNV := GetGLFuncOrNil&<procedure(path: UInt32; coordStart: Int32; numCoords: Int32; coordType: DummyEnum; coords: pointer)>('glPathSubCoordsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCoordsNV(path: UInt32; coordStart: Int32; numCoords: Int32; coordType: DummyEnum; coords: pointer) := z_PathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
    
    public z_PathStringNV := GetGLFuncOrNil&<procedure(path: UInt32; format: DummyEnum; length: Int32; pathString: pointer)>('glPathStringNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStringNV(path: UInt32; format: DummyEnum; length: Int32; pathString: pointer) := z_PathStringNV(path, format, length, pathString);
    
    public z_PathGlyphsNV := GetGLFuncOrNil&<procedure(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; numGlyphs: Int32; &type: DummyEnum; charcodes: pointer; handleMissingGlyphs: DummyEnum; pathParameterTemplate: UInt32; emScale: single)>('glPathGlyphsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathGlyphsNV(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; numGlyphs: Int32; &type: DummyEnum; charcodes: pointer; handleMissingGlyphs: DummyEnum; pathParameterTemplate: UInt32; emScale: single) := z_PathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, &type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
    
    public z_PathGlyphRangeNV := GetGLFuncOrNil&<procedure(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; firstGlyph: UInt32; numGlyphs: Int32; handleMissingGlyphs: DummyEnum; pathParameterTemplate: UInt32; emScale: single)>('glPathGlyphRangeNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathGlyphRangeNV(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; firstGlyph: UInt32; numGlyphs: Int32; handleMissingGlyphs: DummyEnum; pathParameterTemplate: UInt32; emScale: single) := z_PathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
    
    public z_PathGlyphIndexArrayNV := GetGLFuncOrNil&<function(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum>('glPathGlyphIndexArrayNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexArrayNV(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum := z_PathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    
    public z_PathMemoryGlyphIndexArrayNV := GetGLFuncOrNil&<function(firstPathName: UInt32; fontTarget: DummyEnum; fontSize: UIntPtr; fontData: pointer; faceIndex: Int32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum>('glPathMemoryGlyphIndexArrayNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathMemoryGlyphIndexArrayNV(firstPathName: UInt32; fontTarget: DummyEnum; fontSize: UIntPtr; fontData: pointer; faceIndex: Int32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum := z_PathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    
    public z_PathGlyphIndexRangeNV := GetGLFuncOrNil&<function(fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; pathParameterTemplate: UInt32; emScale: single; baseAndCount: Vec2ui): DummyEnum>('glPathGlyphIndexRangeNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexRangeNV(fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; pathParameterTemplate: UInt32; emScale: single; baseAndCount: Vec2ui): DummyEnum := z_PathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    
    public z_WeightPathsNV := GetGLFuncOrNil&<procedure(resultPath: UInt32; numPaths: Int32; paths: pointer; weights: pointer)>('glWeightPathsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: array of UInt32; weights: array of single) := WeightPathsNV(resultPath, numPaths, paths[0], weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: array of UInt32; var weights: single) := WeightPathsNV(resultPath, numPaths, paths[0], @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: array of UInt32; weights: pointer) := WeightPathsNV(resultPath, numPaths, paths[0], weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; var paths: UInt32; weights: array of single) := WeightPathsNV(resultPath, numPaths, @paths, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; var paths: UInt32; var weights: single) := WeightPathsNV(resultPath, numPaths, @paths, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; var paths: UInt32; weights: pointer) := WeightPathsNV(resultPath, numPaths, @paths, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: pointer; weights: array of single) := WeightPathsNV(resultPath, numPaths, paths, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: pointer; var weights: single) := WeightPathsNV(resultPath, numPaths, paths, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: pointer; weights: pointer) := z_WeightPathsNV(resultPath, numPaths, paths, weights);
    
    public z_CopyPathNV := GetGLFuncOrNil&<procedure(resultPath: UInt32; srcPath: UInt32)>('glCopyPathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyPathNV(resultPath: UInt32; srcPath: UInt32) := z_CopyPathNV(resultPath, srcPath);
    
    public z_InterpolatePathsNV := GetGLFuncOrNil&<procedure(resultPath: UInt32; pathA: UInt32; pathB: UInt32; weight: single)>('glInterpolatePathsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InterpolatePathsNV(resultPath: UInt32; pathA: UInt32; pathB: UInt32; weight: single) := z_InterpolatePathsNV(resultPath, pathA, pathB, weight);
    
    public z_TransformPathNV := GetGLFuncOrNil&<procedure(resultPath: UInt32; srcPath: UInt32; transformType: DummyEnum; transformValues: pointer)>('glTransformPathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: DummyEnum; transformValues: array of single) := TransformPathNV(resultPath, srcPath, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: DummyEnum; var transformValues: single) := TransformPathNV(resultPath, srcPath, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: DummyEnum; transformValues: pointer) := z_TransformPathNV(resultPath, srcPath, transformType, transformValues);
    
    public z_PathParameterivNV := GetGLFuncOrNil&<procedure(path: UInt32; pname: DummyEnum; value: pointer)>('glPathParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: DummyEnum; value: array of Int32) := PathParameterivNV(path, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: DummyEnum; var value: Int32) := PathParameterivNV(path, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: DummyEnum; value: pointer) := z_PathParameterivNV(path, pname, value);
    
    public z_PathParameteriNV := GetGLFuncOrNil&<procedure(path: UInt32; pname: DummyEnum; value: Int32)>('glPathParameteriNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameteriNV(path: UInt32; pname: DummyEnum; value: Int32) := z_PathParameteriNV(path, pname, value);
    
    public z_PathParameterfvNV := GetGLFuncOrNil&<procedure(path: UInt32; pname: DummyEnum; value: pointer)>('glPathParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: DummyEnum; value: array of single) := PathParameterfvNV(path, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: DummyEnum; var value: single) := PathParameterfvNV(path, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: DummyEnum; value: pointer) := z_PathParameterfvNV(path, pname, value);
    
    public z_PathParameterfNV := GetGLFuncOrNil&<procedure(path: UInt32; pname: DummyEnum; value: single)>('glPathParameterfNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfNV(path: UInt32; pname: DummyEnum; value: single) := z_PathParameterfNV(path, pname, value);
    
    public z_PathDashArrayNV := GetGLFuncOrNil&<procedure(path: UInt32; dashCount: Int32; dashArray: pointer)>('glPathDashArrayNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; dashArray: array of single) := PathDashArrayNV(path, dashCount, dashArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; var dashArray: single) := PathDashArrayNV(path, dashCount, @dashArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; dashArray: pointer) := z_PathDashArrayNV(path, dashCount, dashArray);
    
    public z_GenPathsNV := GetGLFuncOrNil&<function(range: Int32): UInt32>('glGenPathsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenPathsNV(range: Int32): UInt32 := z_GenPathsNV(range);
    
    public z_DeletePathsNV := GetGLFuncOrNil&<procedure(path: UInt32; range: Int32)>('glDeletePathsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePathsNV(path: UInt32; range: Int32) := z_DeletePathsNV(path, range);
    
    public z_IsPathNV := GetGLFuncOrNil&<function(path: UInt32): boolean>('glIsPathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPathNV(path: UInt32): boolean := z_IsPathNV(path);
    
    public z_PathStencilFuncNV := GetGLFuncOrNil&<procedure(func: DummyEnum; ref: Int32; mask: UInt32)>('glPathStencilFuncNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStencilFuncNV(func: DummyEnum; ref: Int32; mask: UInt32) := z_PathStencilFuncNV(func, ref, mask);
    
    public z_PathStencilDepthOffsetNV := GetGLFuncOrNil&<procedure(factor: single; units: single)>('glPathStencilDepthOffsetNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStencilDepthOffsetNV(factor: single; units: single) := z_PathStencilDepthOffsetNV(factor, units);
    
    public z_StencilFillPathNV := GetGLFuncOrNil&<procedure(path: UInt32; fillMode: DummyEnum; mask: UInt32)>('glStencilFillPathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathNV(path: UInt32; fillMode: DummyEnum; mask: UInt32) := z_StencilFillPathNV(path, fillMode, mask);
    
    public z_StencilStrokePathNV := GetGLFuncOrNil&<procedure(path: UInt32; reference: Int32; mask: UInt32)>('glStencilStrokePathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathNV(path: UInt32; reference: Int32; mask: UInt32) := z_StencilStrokePathNV(path, reference, mask);
    
    public z_StencilFillPathInstancedNV := GetGLFuncOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; transformType: DummyEnum; transformValues: pointer)>('glStencilFillPathInstancedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; transformType: DummyEnum; transformValues: array of single) := StencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; transformType: DummyEnum; var transformValues: single) := StencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; transformType: DummyEnum; transformValues: pointer) := z_StencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    
    public z_StencilStrokePathInstancedNV := GetGLFuncOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: DummyEnum; transformValues: pointer)>('glStencilStrokePathInstancedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: DummyEnum; transformValues: array of single) := StencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: DummyEnum; var transformValues: single) := StencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: DummyEnum; transformValues: pointer) := z_StencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    
    public z_PathCoverDepthFuncNV := GetGLFuncOrNil&<procedure(func: DummyEnum)>('glPathCoverDepthFuncNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCoverDepthFuncNV(func: DummyEnum) := z_PathCoverDepthFuncNV(func);
    
    public z_PathColorGenNV := GetGLFuncOrNil&<procedure(color: DummyEnum; genMode: DummyEnum; colorFormat: DummyEnum; coeffs: pointer)>('glPathColorGenNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: DummyEnum; genMode: DummyEnum; colorFormat: DummyEnum; coeffs: array of single) := PathColorGenNV(color, genMode, colorFormat, coeffs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: DummyEnum; genMode: DummyEnum; colorFormat: DummyEnum; var coeffs: single) := PathColorGenNV(color, genMode, colorFormat, @coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: DummyEnum; genMode: DummyEnum; colorFormat: DummyEnum; coeffs: pointer) := z_PathColorGenNV(color, genMode, colorFormat, coeffs);
    
    public z_PathTexGenNV := GetGLFuncOrNil&<procedure(texCoordSet: DummyEnum; genMode: DummyEnum; components: Int32; coeffs: pointer)>('glPathTexGenNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: DummyEnum; genMode: DummyEnum; components: Int32; coeffs: array of single) := PathTexGenNV(texCoordSet, genMode, components, coeffs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: DummyEnum; genMode: DummyEnum; components: Int32; var coeffs: single) := PathTexGenNV(texCoordSet, genMode, components, @coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: DummyEnum; genMode: DummyEnum; components: Int32; coeffs: pointer) := z_PathTexGenNV(texCoordSet, genMode, components, coeffs);
    
    public z_PathFogGenNV := GetGLFuncOrNil&<procedure(genMode: DummyEnum)>('glPathFogGenNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathFogGenNV(genMode: DummyEnum) := z_PathFogGenNV(genMode);
    
    public z_CoverFillPathNV := GetGLFuncOrNil&<procedure(path: UInt32; coverMode: DummyEnum)>('glCoverFillPathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathNV(path: UInt32; coverMode: DummyEnum) := z_CoverFillPathNV(path, coverMode);
    
    public z_CoverStrokePathNV := GetGLFuncOrNil&<procedure(path: UInt32; coverMode: DummyEnum)>('glCoverStrokePathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathNV(path: UInt32; coverMode: DummyEnum) := z_CoverStrokePathNV(path, coverMode);
    
    public z_CoverFillPathInstancedNV := GetGLFuncOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer)>('glCoverFillPathInstancedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: array of single) := CoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single) := CoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := z_CoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    
    public z_CoverStrokePathInstancedNV := GetGLFuncOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer)>('glCoverStrokePathInstancedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: array of single) := CoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single) := CoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := z_CoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    
    public z_StencilThenCoverFillPathNV := GetGLFuncOrNil&<procedure(path: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum)>('glStencilThenCoverFillPathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathNV(path: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum) := z_StencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
    
    public z_StencilThenCoverStrokePathNV := GetGLFuncOrNil&<procedure(path: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum)>('glStencilThenCoverStrokePathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathNV(path: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum) := z_StencilThenCoverStrokePathNV(path, reference, mask, coverMode);
    
    public z_StencilThenCoverFillPathInstancedNV := GetGLFuncOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer)>('glStencilThenCoverFillPathInstancedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: array of single) := StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single) := StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := z_StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    
    public z_StencilThenCoverStrokePathInstancedNV := GetGLFuncOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer)>('glStencilThenCoverStrokePathInstancedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: array of single) := StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single) := StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := z_StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    
    public z_ProgramPathFragmentInputGenNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; genMode: DummyEnum; components: Int32; coeffs: pointer)>('glProgramPathFragmentInputGenNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: UInt32; location: Int32; genMode: DummyEnum; components: Int32; coeffs: array of single) := ProgramPathFragmentInputGenNV(&program, location, genMode, components, coeffs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: UInt32; location: Int32; genMode: DummyEnum; components: Int32; var coeffs: single) := ProgramPathFragmentInputGenNV(&program, location, genMode, components, @coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: UInt32; location: Int32; genMode: DummyEnum; components: Int32; coeffs: pointer) := z_ProgramPathFragmentInputGenNV(&program, location, genMode, components, coeffs);
    
    public z_GetPathParameterivNV := GetGLFuncOrNil&<procedure(path: UInt32; pname: DummyEnum; value: pointer)>('glGetPathParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterivNV(path: UInt32; pname: DummyEnum; value: array of Int32) := GetPathParameterivNV(path, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterivNV(path: UInt32; pname: DummyEnum; var value: Int32) := GetPathParameterivNV(path, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterivNV(path: UInt32; pname: DummyEnum; value: pointer) := z_GetPathParameterivNV(path, pname, value);
    
    public z_GetPathParameterfvNV := GetGLFuncOrNil&<procedure(path: UInt32; pname: DummyEnum; value: pointer)>('glGetPathParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterfvNV(path: UInt32; pname: DummyEnum; value: array of single) := GetPathParameterfvNV(path, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterfvNV(path: UInt32; pname: DummyEnum; var value: single) := GetPathParameterfvNV(path, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterfvNV(path: UInt32; pname: DummyEnum; value: pointer) := z_GetPathParameterfvNV(path, pname, value);
    
    public z_GetPathCommandsNV := GetGLFuncOrNil&<procedure(path: UInt32; commands: pointer)>('glGetPathCommandsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCommandsNV(path: UInt32; commands: array of Byte) := GetPathCommandsNV(path, commands[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCommandsNV(path: UInt32; var commands: Byte) := GetPathCommandsNV(path, @commands);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCommandsNV(path: UInt32; commands: pointer) := z_GetPathCommandsNV(path, commands);
    
    public z_GetPathCoordsNV := GetGLFuncOrNil&<procedure(path: UInt32; coords: pointer)>('glGetPathCoordsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCoordsNV(path: UInt32; coords: array of single) := GetPathCoordsNV(path, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCoordsNV(path: UInt32; var coords: single) := GetPathCoordsNV(path, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCoordsNV(path: UInt32; coords: pointer) := z_GetPathCoordsNV(path, coords);
    
    public z_GetPathDashArrayNV := GetGLFuncOrNil&<procedure(path: UInt32; dashArray: pointer)>('glGetPathDashArrayNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathDashArrayNV(path: UInt32; dashArray: array of single) := GetPathDashArrayNV(path, dashArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathDashArrayNV(path: UInt32; var dashArray: single) := GetPathDashArrayNV(path, @dashArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathDashArrayNV(path: UInt32; dashArray: pointer) := z_GetPathDashArrayNV(path, dashArray);
    
    public z_GetPathMetricsNV := GetGLFuncOrNil&<procedure(metricQueryMask: DummyFlags; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; stride: Int32; metrics: pointer)>('glGetPathMetricsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricsNV(metricQueryMask: DummyFlags; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; stride: Int32; metrics: array of single) := GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricsNV(metricQueryMask: DummyFlags; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; stride: Int32; var metrics: single) := GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, @metrics);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricsNV(metricQueryMask: DummyFlags; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; stride: Int32; metrics: pointer) := z_GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    
    public z_GetPathMetricRangeNV := GetGLFuncOrNil&<procedure(metricQueryMask: DummyFlags; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: pointer)>('glGetPathMetricRangeNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricRangeNV(metricQueryMask: DummyFlags; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: array of single) := GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricRangeNV(metricQueryMask: DummyFlags; firstPathName: UInt32; numPaths: Int32; stride: Int32; var metrics: single) := GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, @metrics);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricRangeNV(metricQueryMask: DummyFlags; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: pointer) := z_GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
    
    public z_GetPathSpacingNV := GetGLFuncOrNil&<procedure(pathListMode: DummyEnum; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: DummyEnum; returnedSpacing: pointer)>('glGetPathSpacingNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathSpacingNV(pathListMode: DummyEnum; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: DummyEnum; returnedSpacing: array of single) := GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathSpacingNV(pathListMode: DummyEnum; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: DummyEnum; var returnedSpacing: single) := GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, @returnedSpacing);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathSpacingNV(pathListMode: DummyEnum; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: DummyEnum; returnedSpacing: pointer) := z_GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    
    public z_GetPathColorGenivNV := GetGLFuncOrNil&<procedure(color: DummyEnum; pname: DummyEnum; value: pointer)>('glGetPathColorGenivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenivNV(color: DummyEnum; pname: DummyEnum; value: array of Int32) := GetPathColorGenivNV(color, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenivNV(color: DummyEnum; pname: DummyEnum; var value: Int32) := GetPathColorGenivNV(color, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenivNV(color: DummyEnum; pname: DummyEnum; value: pointer) := z_GetPathColorGenivNV(color, pname, value);
    
    public z_GetPathColorGenfvNV := GetGLFuncOrNil&<procedure(color: DummyEnum; pname: DummyEnum; value: pointer)>('glGetPathColorGenfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenfvNV(color: DummyEnum; pname: DummyEnum; value: array of single) := GetPathColorGenfvNV(color, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenfvNV(color: DummyEnum; pname: DummyEnum; var value: single) := GetPathColorGenfvNV(color, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenfvNV(color: DummyEnum; pname: DummyEnum; value: pointer) := z_GetPathColorGenfvNV(color, pname, value);
    
    public z_GetPathTexGenivNV := GetGLFuncOrNil&<procedure(texCoordSet: DummyEnum; pname: DummyEnum; value: pointer)>('glGetPathTexGenivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenivNV(texCoordSet: DummyEnum; pname: DummyEnum; value: array of Int32) := GetPathTexGenivNV(texCoordSet, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenivNV(texCoordSet: DummyEnum; pname: DummyEnum; var value: Int32) := GetPathTexGenivNV(texCoordSet, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenivNV(texCoordSet: DummyEnum; pname: DummyEnum; value: pointer) := z_GetPathTexGenivNV(texCoordSet, pname, value);
    
    public z_GetPathTexGenfvNV := GetGLFuncOrNil&<procedure(texCoordSet: DummyEnum; pname: DummyEnum; value: pointer)>('glGetPathTexGenfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenfvNV(texCoordSet: DummyEnum; pname: DummyEnum; value: array of single) := GetPathTexGenfvNV(texCoordSet, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenfvNV(texCoordSet: DummyEnum; pname: DummyEnum; var value: single) := GetPathTexGenfvNV(texCoordSet, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenfvNV(texCoordSet: DummyEnum; pname: DummyEnum; value: pointer) := z_GetPathTexGenfvNV(texCoordSet, pname, value);
    
    public z_IsPointInFillPathNV := GetGLFuncOrNil&<function(path: UInt32; mask: UInt32; x: single; y: single): boolean>('glIsPointInFillPathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPointInFillPathNV(path: UInt32; mask: UInt32; x: single; y: single): boolean := z_IsPointInFillPathNV(path, mask, x, y);
    
    public z_IsPointInStrokePathNV := GetGLFuncOrNil&<function(path: UInt32; x: single; y: single): boolean>('glIsPointInStrokePathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPointInStrokePathNV(path: UInt32; x: single; y: single): boolean := z_IsPointInStrokePathNV(path, x, y);
    
    public z_GetPathLengthNV := GetGLFuncOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32): single>('glGetPathLengthNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPathLengthNV(path: UInt32; startSegment: Int32; numSegments: Int32): single := z_GetPathLengthNV(path, startSegment, numSegments);
    
    public z_PointAlongPathNV := GetGLFuncOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: pointer; tangentY: pointer): boolean>('glPointAlongPathNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: array of single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: array of single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: array of single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; var tangentX: single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; var tangentX: single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; var tangentX: single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: pointer; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: pointer; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: pointer; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: array of single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: array of single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: array of single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; var tangentX: single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; var tangentX: single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; var tangentX: single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: pointer; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: pointer; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: pointer; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: array of single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: array of single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: array of single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; var tangentX: single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; var tangentX: single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; var tangentX: single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: pointer; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: pointer; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: pointer; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: array of single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: array of single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: array of single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; var tangentX: single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; var tangentX: single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; var tangentX: single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: pointer; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: pointer; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: pointer; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: array of single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: array of single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: array of single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; var tangentX: single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; var tangentX: single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; var tangentX: single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: pointer; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: pointer; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: pointer; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: array of single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: array of single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: array of single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; var tangentX: single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; var tangentX: single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; var tangentX: single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: pointer; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: pointer; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: pointer; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: array of single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: array of single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: array of single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; var tangentX: single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; var tangentX: single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; var tangentX: single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: pointer; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: pointer; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: pointer; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: array of single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: array of single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: array of single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; var tangentX: single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; var tangentX: single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; var tangentX: single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: pointer; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: pointer; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: pointer; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: array of single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: array of single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: array of single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; var tangentX: single; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; var tangentX: single; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; var tangentX: single; tangentY: pointer): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: pointer; tangentY: array of single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: pointer; var tangentY: single): boolean := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: pointer; tangentY: pointer): boolean := z_PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    
    public z_MatrixLoad3x2fNV := GetGLFuncOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>('glMatrixLoad3x2fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; m: array of single) := MatrixLoad3x2fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; var m: single) := MatrixLoad3x2fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixLoad3x2fNV(matrixMode, m);
    
    public z_MatrixLoad3x3fNV := GetGLFuncOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>('glMatrixLoad3x3fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; m: array of single) := MatrixLoad3x3fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; var m: single) := MatrixLoad3x3fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixLoad3x3fNV(matrixMode, m);
    
    public z_MatrixLoadTranspose3x3fNV := GetGLFuncOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>('glMatrixLoadTranspose3x3fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; m: array of single) := MatrixLoadTranspose3x3fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; var m: single) := MatrixLoadTranspose3x3fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixLoadTranspose3x3fNV(matrixMode, m);
    
    public z_MatrixMult3x2fNV := GetGLFuncOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>('glMatrixMult3x2fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; m: array of single) := MatrixMult3x2fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; var m: single) := MatrixMult3x2fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixMult3x2fNV(matrixMode, m);
    
    public z_MatrixMult3x3fNV := GetGLFuncOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>('glMatrixMult3x3fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; m: array of single) := MatrixMult3x3fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; var m: single) := MatrixMult3x3fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixMult3x3fNV(matrixMode, m);
    
    public z_MatrixMultTranspose3x3fNV := GetGLFuncOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>('glMatrixMultTranspose3x3fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; m: array of single) := MatrixMultTranspose3x3fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; var m: single) := MatrixMultTranspose3x3fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixMultTranspose3x3fNV(matrixMode, m);
    
    public z_GetProgramResourcefvNV := GetGLFuncOrNil&<procedure(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: pointer)>('glGetProgramResourcefvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: array of Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: array of Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: array of Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; var length: Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, @length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; var length: Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, @length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; var length: Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, @length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: pointer; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: pointer; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: pointer; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: array of Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: array of Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: array of Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; var length: Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, @length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; var length: Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, @length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; var length: Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, @length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: pointer; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: pointer; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: pointer; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: array of Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: array of Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: array of Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; var length: Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, @length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; var length: Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, @length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; var length: Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, @length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: pointer) := z_GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length, &params);
    
    {$endregion NV_path_rendering}
    
    {$region NV_coverage_sample}
    
    public z_CoverageMaskNV := GetGLFuncOrNil&<procedure(mask: boolean)>('glCoverageMaskNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageMaskNV(mask: boolean) := z_CoverageMaskNV(mask);
    
    public z_CoverageOperationNV := GetGLFuncOrNil&<procedure(operation: DummyEnum)>('glCoverageOperationNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageOperationNV(operation: DummyEnum) := z_CoverageOperationNV(operation);
    
    {$endregion NV_coverage_sample}
    
    {$region NV_framebuffer_mixed_samples}
    
    public z_CoverageModulationTableNV := GetGLFuncOrNil&<procedure(n: Int32; v: pointer)>('glCoverageModulationTableNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; v: array of single) := CoverageModulationTableNV(n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; var v: single) := CoverageModulationTableNV(n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; v: pointer) := z_CoverageModulationTableNV(n, v);
    
    public z_GetCoverageModulationTableNV := GetGLFuncOrNil&<procedure(bufsize: Int32; v: pointer)>('glGetCoverageModulationTableNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCoverageModulationTableNV(bufsize: Int32; v: array of single) := GetCoverageModulationTableNV(bufsize, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCoverageModulationTableNV(bufsize: Int32; var v: single) := GetCoverageModulationTableNV(bufsize, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCoverageModulationTableNV(bufsize: Int32; v: pointer) := z_GetCoverageModulationTableNV(bufsize, v);
    
    public z_CoverageModulationNV := GetGLFuncOrNil&<procedure(components: DummyEnum)>('glCoverageModulationNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationNV(components: DummyEnum) := z_CoverageModulationNV(components);
    
    {$endregion NV_framebuffer_mixed_samples}
    
    {$region NV_fence}
    
    public z_GenFencesNV := GetGLFuncOrNil&<procedure(n: Int32; fences: pointer)>('glGenFencesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesNV(n: Int32; fences: array of UInt32) := GenFencesNV(n, fences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesNV(n: Int32; var fences: UInt32) := GenFencesNV(n, @fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesNV(n: Int32; fences: pointer) := z_GenFencesNV(n, fences);
    
    public z_DeleteFencesNV := GetGLFuncOrNil&<procedure(n: Int32; fences: pointer)>('glDeleteFencesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesNV(n: Int32; fences: array of UInt32) := DeleteFencesNV(n, fences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesNV(n: Int32; var fences: UInt32) := DeleteFencesNV(n, @fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesNV(n: Int32; fences: pointer) := z_DeleteFencesNV(n, fences);
    
    public z_SetFenceNV := GetGLFuncOrNil&<procedure(fence: UInt32; condition: DummyEnum)>('glSetFenceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFenceNV(fence: UInt32; condition: DummyEnum) := z_SetFenceNV(fence, condition);
    
    public z_TestFenceNV := GetGLFuncOrNil&<function(fence: UInt32): boolean>('glTestFenceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestFenceNV(fence: UInt32): boolean := z_TestFenceNV(fence);
    
    public z_FinishFenceNV := GetGLFuncOrNil&<procedure(fence: UInt32)>('glFinishFenceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishFenceNV(fence: UInt32) := z_FinishFenceNV(fence);
    
    public z_IsFenceNV := GetGLFuncOrNil&<function(fence: UInt32): boolean>('glIsFenceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFenceNV(fence: UInt32): boolean := z_IsFenceNV(fence);
    
    public z_GetFenceivNV := GetGLFuncOrNil&<procedure(fence: UInt32; pname: DummyEnum; &params: pointer)>('glGetFenceivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFenceivNV(fence: UInt32; pname: DummyEnum; &params: array of Int32) := GetFenceivNV(fence, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFenceivNV(fence: UInt32; pname: DummyEnum; var &params: Int32) := GetFenceivNV(fence, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFenceivNV(fence: UInt32; pname: DummyEnum; &params: pointer) := z_GetFenceivNV(fence, pname, &params);
    
    {$endregion NV_fence}
    
    {$region NV_query_resource_tag}
    
    public z_GenQueryResourceTagNV := GetGLFuncOrNil&<procedure(n: Int32; tagIds: pointer)>('glGenQueryResourceTagNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; tagIds: array of Int32) := GenQueryResourceTagNV(n, tagIds[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; var tagIds: Int32) := GenQueryResourceTagNV(n, @tagIds);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; tagIds: pointer) := z_GenQueryResourceTagNV(n, tagIds);
    
    public z_DeleteQueryResourceTagNV := GetGLFuncOrNil&<procedure(n: Int32; tagIds: pointer)>('glDeleteQueryResourceTagNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; tagIds: array of Int32) := DeleteQueryResourceTagNV(n, tagIds[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; var tagIds: Int32) := DeleteQueryResourceTagNV(n, @tagIds);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; tagIds: pointer) := z_DeleteQueryResourceTagNV(n, tagIds);
    
    public z_QueryResourceTagNV := GetGLFuncOrNil&<procedure(tagId: Int32; tagString: IntPtr)>('glQueryResourceTagNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryResourceTagNV(tagId: Int32; tagString: string); begin var ptr_2 := Marshal.StringToHGlobalAnsi(tagString); QueryResourceTagNV(tagId, ptr_2); Marshal.FreeHGlobal(ptr_2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryResourceTagNV(tagId: Int32; tagString: IntPtr) := z_QueryResourceTagNV(tagId, tagString);
    
    {$endregion NV_query_resource_tag}
    
    {$region NV_viewport_array}
    
    public z_ViewportArrayvNV := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>('glViewportArrayvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayvNV(first: UInt32; count: Int32; v: array of single) := ViewportArrayvNV(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayvNV(first: UInt32; count: Int32; var v: single) := ViewportArrayvNV(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayvNV(first: UInt32; count: Int32; v: pointer) := z_ViewportArrayvNV(first, count, v);
    
    public z_ViewportIndexedfNV := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single; w: single; h: single)>('glViewportIndexedfNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfNV(index: UInt32; x: single; y: single; w: single; h: single) := z_ViewportIndexedfNV(index, x, y, w, h);
    
    public z_ViewportIndexedfvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glViewportIndexedfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfvNV(index: UInt32; v: array of single) := ViewportIndexedfvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfvNV(index: UInt32; var v: single) := ViewportIndexedfvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfvNV(index: UInt32; v: pointer) := z_ViewportIndexedfvNV(index, v);
    
    public z_ScissorArrayvNV := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>('glScissorArrayvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayvNV(first: UInt32; count: Int32; v: array of Int32) := ScissorArrayvNV(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayvNV(first: UInt32; count: Int32; var v: Int32) := ScissorArrayvNV(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayvNV(first: UInt32; count: Int32; v: pointer) := z_ScissorArrayvNV(first, count, v);
    
    public z_ScissorIndexedNV := GetGLFuncOrNil&<procedure(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32)>('glScissorIndexedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedNV(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32) := z_ScissorIndexedNV(index, left, bottom, width, height);
    
    public z_ScissorIndexedvNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glScissorIndexedvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedvNV(index: UInt32; v: array of Int32) := ScissorIndexedvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedvNV(index: UInt32; var v: Int32) := ScissorIndexedvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedvNV(index: UInt32; v: pointer) := z_ScissorIndexedvNV(index, v);
    
    public z_DepthRangeArrayfvNV := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>('glDepthRangeArrayfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayfvNV(first: UInt32; count: Int32; v: array of single) := DepthRangeArrayfvNV(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayfvNV(first: UInt32; count: Int32; var v: single) := DepthRangeArrayfvNV(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayfvNV(first: UInt32; count: Int32; v: pointer) := z_DepthRangeArrayfvNV(first, count, v);
    
    public z_DepthRangeIndexedfNV := GetGLFuncOrNil&<procedure(index: UInt32; n: single; f: single)>('glDepthRangeIndexedfNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeIndexedfNV(index: UInt32; n: single; f: single) := z_DepthRangeIndexedfNV(index, n, f);
    
    public z_GetFloati_vNV := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetFloati_vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vNV(target: GLGetQueries; index: UInt32; data: array of single) := GetFloati_vNV(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vNV(target: GLGetQueries; index: UInt32; var data: single) := GetFloati_vNV(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vNV(target: GLGetQueries; index: UInt32; data: pointer) := z_GetFloati_vNV(target, index, data);
    
    public z_EnableiNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32)>('glEnableiNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableiNV(target: DummyEnum; index: UInt32) := z_EnableiNV(target, index);
    
    public z_DisableiNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32)>('glDisableiNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableiNV(target: DummyEnum; index: UInt32) := z_DisableiNV(target, index);
    
    public z_IsEnablediNV := GetGLFuncOrNil&<function(target: DummyEnum; index: UInt32): boolean>('glIsEnablediNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnablediNV(target: DummyEnum; index: UInt32): boolean := z_IsEnablediNV(target, index);
    
    {$endregion NV_viewport_array}
    
    {$region NV_draw_instanced}
    
    public z_DrawArraysInstancedNV := GetGLFuncOrNil&<procedure(mode: DummyEnum; first: Int32; count: Int32; primcount: Int32)>('glDrawArraysInstancedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawArraysInstancedNV(mode: DummyEnum; first: Int32; count: Int32; primcount: Int32) := z_DrawArraysInstancedNV(mode, first, count, primcount);
    
    public z_DrawElementsInstancedNV := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32)>('glDrawElementsInstancedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedNV(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32) := z_DrawElementsInstancedNV(mode, count, &type, indices, primcount);
    
    {$endregion NV_draw_instanced}
    
    {$region NV_draw_buffers}
    
    public z_DrawBuffersNV := GetGLFuncOrNil&<procedure(n: Int32; bufs: pointer)>('glDrawBuffersNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersNV(n: Int32; bufs: array of DummyEnum) := DrawBuffersNV(n, bufs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersNV(n: Int32; var bufs: DummyEnum) := DrawBuffersNV(n, @bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersNV(n: Int32; bufs: pointer) := z_DrawBuffersNV(n, bufs);
    
    {$endregion NV_draw_buffers}
    
    {$region NV_mesh_shader}
    
    public z_DrawMeshTasksNV := GetGLFuncOrNil&<procedure(first: UInt32; count: UInt32)>('glDrawMeshTasksNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshTasksNV(first: UInt32; count: UInt32) := z_DrawMeshTasksNV(first, count);
    
    public z_DrawMeshTasksIndirectNV := GetGLFuncOrNil&<procedure(indirect: IntPtr)>('glDrawMeshTasksIndirectNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshTasksIndirectNV(indirect: IntPtr) := z_DrawMeshTasksIndirectNV(indirect);
    
    public z_MultiDrawMeshTasksIndirectNV := GetGLFuncOrNil&<procedure(indirect: IntPtr; drawcount: Int32; stride: Int32)>('glMultiDrawMeshTasksIndirectNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawMeshTasksIndirectNV(indirect: IntPtr; drawcount: Int32; stride: Int32) := z_MultiDrawMeshTasksIndirectNV(indirect, drawcount, stride);
    
    public z_MultiDrawMeshTasksIndirectCountNV := GetGLFuncOrNil&<procedure(indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>('glMultiDrawMeshTasksIndirectCountNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawMeshTasksIndirectCountNV(indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) := z_MultiDrawMeshTasksIndirectCountNV(indirect, drawcount, maxdrawcount, stride);
    
    {$endregion NV_mesh_shader}
    
    {$region NV_draw_texture}
    
    public z_DrawTextureNV := GetGLFuncOrNil&<procedure(texture: UInt32; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single)>('glDrawTextureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTextureNV(texture: UInt32; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single) := z_DrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    
    {$endregion NV_draw_texture}
    
    {$region NV_draw_vulkan_image}
    
    public z_DrawVkImageNV := GetGLFuncOrNil&<procedure(vkImage: UInt64; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single)>('glDrawVkImageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawVkImageNV(vkImage: UInt64; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single) := z_DrawVkImageNV(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    
    public z_GetVkProcAddrNV := GetGLFuncOrNil&<function(name: IntPtr): GLVULKANPROCNV>('glGetVkProcAddrNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVkProcAddrNV(name: string): GLVULKANPROCNV; begin var ptr_1 := Marshal.StringToHGlobalAnsi(name); Result := GetVkProcAddrNV(ptr_1); Marshal.FreeHGlobal(ptr_1); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVkProcAddrNV(name: IntPtr): GLVULKANPROCNV := z_GetVkProcAddrNV(name);
    
    public z_WaitVkSemaphoreNV := GetGLFuncOrNil&<procedure(vkSemaphore: UInt64)>('glWaitVkSemaphoreNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitVkSemaphoreNV(vkSemaphore: UInt64) := z_WaitVkSemaphoreNV(vkSemaphore);
    
    public z_SignalVkSemaphoreNV := GetGLFuncOrNil&<procedure(vkSemaphore: UInt64)>('glSignalVkSemaphoreNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalVkSemaphoreNV(vkSemaphore: UInt64) := z_SignalVkSemaphoreNV(vkSemaphore);
    
    public z_SignalVkFenceNV := GetGLFuncOrNil&<procedure(vkFence: UInt64)>('glSignalVkFenceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalVkFenceNV(vkFence: UInt64) := z_SignalVkFenceNV(vkFence);
    
    {$endregion NV_draw_vulkan_image}
    
    {$region NV_evaluators}
    
    public z_MapControlPointsNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &type: DummyEnum; ustride: Int32; vstride: Int32; uorder: Int32; vorder: Int32; &packed: boolean; points: pointer)>('glMapControlPointsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapControlPointsNV(target: DummyEnum; index: UInt32; &type: DummyEnum; ustride: Int32; vstride: Int32; uorder: Int32; vorder: Int32; &packed: boolean; points: pointer) := z_MapControlPointsNV(target, index, &type, ustride, vstride, uorder, vorder, &packed, points);
    
    public z_MapParameterivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glMapParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := MapParameterivNV(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: DummyEnum; pname: DummyEnum; var &params: Int32) := MapParameterivNV(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MapParameterivNV(target, pname, &params);
    
    public z_MapParameterfvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glMapParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: DummyEnum; pname: DummyEnum; &params: array of single) := MapParameterfvNV(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: DummyEnum; pname: DummyEnum; var &params: single) := MapParameterfvNV(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MapParameterfvNV(target, pname, &params);
    
    public z_GetMapControlPointsNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &type: DummyEnum; ustride: Int32; vstride: Int32; &packed: boolean; points: pointer)>('glGetMapControlPointsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapControlPointsNV(target: DummyEnum; index: UInt32; &type: DummyEnum; ustride: Int32; vstride: Int32; &packed: boolean; points: pointer) := z_GetMapControlPointsNV(target, index, &type, ustride, vstride, &packed, points);
    
    public z_GetMapParameterivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMapParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterivNV(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMapParameterivNV(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterivNV(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMapParameterivNV(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterivNV(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMapParameterivNV(target, pname, &params);
    
    public z_GetMapParameterfvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMapParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterfvNV(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetMapParameterfvNV(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterfvNV(target: DummyEnum; pname: DummyEnum; var &params: single) := GetMapParameterfvNV(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterfvNV(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMapParameterfvNV(target, pname, &params);
    
    public z_GetMapAttribParameterivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer)>('glGetMapAttribParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterivNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: array of Int32) := GetMapAttribParameterivNV(target, index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterivNV(target: DummyEnum; index: UInt32; pname: DummyEnum; var &params: Int32) := GetMapAttribParameterivNV(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterivNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := z_GetMapAttribParameterivNV(target, index, pname, &params);
    
    public z_GetMapAttribParameterfvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer)>('glGetMapAttribParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: array of single) := GetMapAttribParameterfvNV(target, index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; var &params: single) := GetMapAttribParameterfvNV(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := z_GetMapAttribParameterfvNV(target, index, pname, &params);
    
    public z_EvalMapsNV := GetGLFuncOrNil&<procedure(target: DummyEnum; mode: DummyEnum)>('glEvalMapsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalMapsNV(target: DummyEnum; mode: DummyEnum) := z_EvalMapsNV(target, mode);
    
    {$endregion NV_evaluators}
    
    {$region NV_pixel_data_range}
    
    public z_PixelDataRangeNV := GetGLFuncOrNil&<procedure(target: DummyEnum; length: Int32; _pointer: pointer)>('glPixelDataRangeNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelDataRangeNV(target: DummyEnum; length: Int32; _pointer: pointer) := z_PixelDataRangeNV(target, length, _pointer);
    
    public z_FlushPixelDataRangeNV := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glFlushPixelDataRangeNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushPixelDataRangeNV(target: DummyEnum) := z_FlushPixelDataRangeNV(target);
    
    {$endregion NV_pixel_data_range}
    
    {$region NV_fragment_coverage_to_color}
    
    public z_FragmentCoverageColorNV := GetGLFuncOrNil&<procedure(color: UInt32)>('glFragmentCoverageColorNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentCoverageColorNV(color: UInt32) := z_FragmentCoverageColorNV(color);
    
    {$endregion NV_fragment_coverage_to_color}
    
    {$region NV_sample_locations}
    
    public z_FramebufferSampleLocationsfvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; start: UInt32; count: Int32; v: pointer)>('glFramebufferSampleLocationsfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvNV(target: DummyEnum; start: UInt32; count: Int32; v: array of single) := FramebufferSampleLocationsfvNV(target, start, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvNV(target: DummyEnum; start: UInt32; count: Int32; var v: single) := FramebufferSampleLocationsfvNV(target, start, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvNV(target: DummyEnum; start: UInt32; count: Int32; v: pointer) := z_FramebufferSampleLocationsfvNV(target, start, count, v);
    
    public z_NamedFramebufferSampleLocationsfvNV := GetGLFuncOrNil&<procedure(framebuffer: UInt32; start: UInt32; count: Int32; v: pointer)>('glNamedFramebufferSampleLocationsfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvNV(framebuffer: UInt32; start: UInt32; count: Int32; v: array of single) := NamedFramebufferSampleLocationsfvNV(framebuffer, start, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvNV(framebuffer: UInt32; start: UInt32; count: Int32; var v: single) := NamedFramebufferSampleLocationsfvNV(framebuffer, start, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvNV(framebuffer: UInt32; start: UInt32; count: Int32; v: pointer) := z_NamedFramebufferSampleLocationsfvNV(framebuffer, start, count, v);
    
    public z_ResolveDepthValuesNV := GetGLFuncOrNil&<procedure>('glResolveDepthValuesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResolveDepthValuesNV := z_ResolveDepthValuesNV;
    
    {$endregion NV_sample_locations}
    
    {$region NV_shader_buffer_load}
    
    public z_MakeBufferResidentNV := GetGLFuncOrNil&<procedure(target: DummyEnum; access: DummyEnum)>('glMakeBufferResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeBufferResidentNV(target: DummyEnum; access: DummyEnum) := z_MakeBufferResidentNV(target, access);
    
    public z_MakeBufferNonResidentNV := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glMakeBufferNonResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeBufferNonResidentNV(target: DummyEnum) := z_MakeBufferNonResidentNV(target);
    
    public z_IsBufferResidentNV := GetGLFuncOrNil&<function(target: DummyEnum): boolean>('glIsBufferResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsBufferResidentNV(target: DummyEnum): boolean := z_IsBufferResidentNV(target);
    
    public z_MakeNamedBufferResidentNV := GetGLFuncOrNil&<procedure(buffer: UInt32; access: DummyEnum)>('glMakeNamedBufferResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeNamedBufferResidentNV(buffer: UInt32; access: DummyEnum) := z_MakeNamedBufferResidentNV(buffer, access);
    
    public z_MakeNamedBufferNonResidentNV := GetGLFuncOrNil&<procedure(buffer: UInt32)>('glMakeNamedBufferNonResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeNamedBufferNonResidentNV(buffer: UInt32) := z_MakeNamedBufferNonResidentNV(buffer);
    
    public z_IsNamedBufferResidentNV := GetGLFuncOrNil&<function(buffer: UInt32): boolean>('glIsNamedBufferResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedBufferResidentNV(buffer: UInt32): boolean := z_IsNamedBufferResidentNV(buffer);
    
    public z_GetBufferParameterui64vNV := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetBufferParameterui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterui64vNV(target: DummyEnum; pname: DummyEnum; &params: array of UInt64) := GetBufferParameterui64vNV(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterui64vNV(target: DummyEnum; pname: DummyEnum; var &params: UInt64) := GetBufferParameterui64vNV(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterui64vNV(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetBufferParameterui64vNV(target, pname, &params);
    
    public z_GetNamedBufferParameterui64vNV := GetGLFuncOrNil&<procedure(buffer: UInt32; pname: DummyEnum; &params: pointer)>('glGetNamedBufferParameterui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterui64vNV(buffer: UInt32; pname: DummyEnum; &params: array of UInt64) := GetNamedBufferParameterui64vNV(buffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterui64vNV(buffer: UInt32; pname: DummyEnum; var &params: UInt64) := GetNamedBufferParameterui64vNV(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterui64vNV(buffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetNamedBufferParameterui64vNV(buffer, pname, &params);
    
    public z_GetIntegerui64vNV := GetGLFuncOrNil&<procedure(value: GLGetQueries; result: pointer)>('glGetIntegerui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64vNV(value: GLGetQueries; result: array of UInt64) := GetIntegerui64vNV(value, result[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64vNV(value: GLGetQueries; var result: UInt64) := GetIntegerui64vNV(value, @result);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64vNV(value: GLGetQueries; result: pointer) := z_GetIntegerui64vNV(value, result);
    
    public z_Uniformui64NV := GetGLFuncOrNil&<procedure(location: Int32; value: UInt64)>('glUniformui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64NV(location: Int32; value: UInt64) := z_Uniformui64NV(location, value);
    
    public z_Uniformui64vNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniformui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; value: array of UInt64) := Uniformui64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; var value: UInt64) := Uniformui64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; value: pointer) := z_Uniformui64vNV(location, count, value);
    
    public z_ProgramUniformui64NV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; value: UInt64)>('glProgramUniformui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64NV(&program: UInt32; location: Int32; value: UInt64) := z_ProgramUniformui64NV(&program, location, value);
    
    public z_ProgramUniformui64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniformui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniformui64vNV(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniformui64vNV(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniformui64vNV(&program, location, count, value);
    
    {$endregion NV_shader_buffer_load}
    
    {$region NV_bindless_texture}
    
    public z_GetTextureHandleNV := GetGLFuncOrNil&<function(texture: UInt32): UInt64>('glGetTextureHandleNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureHandleNV(texture: UInt32): UInt64 := z_GetTextureHandleNV(texture);
    
    public z_GetTextureSamplerHandleNV := GetGLFuncOrNil&<function(texture: UInt32; sampler: UInt32): UInt64>('glGetTextureSamplerHandleNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureSamplerHandleNV(texture: UInt32; sampler: UInt32): UInt64 := z_GetTextureSamplerHandleNV(texture, sampler);
    
    public z_MakeTextureHandleResidentNV := GetGLFuncOrNil&<procedure(handle: UInt64)>('glMakeTextureHandleResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleResidentNV(handle: UInt64) := z_MakeTextureHandleResidentNV(handle);
    
    public z_MakeTextureHandleNonResidentNV := GetGLFuncOrNil&<procedure(handle: UInt64)>('glMakeTextureHandleNonResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleNonResidentNV(handle: UInt64) := z_MakeTextureHandleNonResidentNV(handle);
    
    public z_GetImageHandleNV := GetGLFuncOrNil&<function(texture: UInt32; level: Int32; layered: boolean; layer: Int32; format: DummyEnum): UInt64>('glGetImageHandleNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageHandleNV(texture: UInt32; level: Int32; layered: boolean; layer: Int32; format: DummyEnum): UInt64 := z_GetImageHandleNV(texture, level, layered, layer, format);
    
    public z_MakeImageHandleResidentNV := GetGLFuncOrNil&<procedure(handle: UInt64; access: DummyEnum)>('glMakeImageHandleResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleResidentNV(handle: UInt64; access: DummyEnum) := z_MakeImageHandleResidentNV(handle, access);
    
    public z_MakeImageHandleNonResidentNV := GetGLFuncOrNil&<procedure(handle: UInt64)>('glMakeImageHandleNonResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleNonResidentNV(handle: UInt64) := z_MakeImageHandleNonResidentNV(handle);
    
    public z_UniformHandleui64NV := GetGLFuncOrNil&<procedure(location: Int32; value: UInt64)>('glUniformHandleui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64NV(location: Int32; value: UInt64) := z_UniformHandleui64NV(location, value);
    
    public z_UniformHandleui64vNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniformHandleui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vNV(location: Int32; count: Int32; value: array of UInt64) := UniformHandleui64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vNV(location: Int32; count: Int32; var value: UInt64) := UniformHandleui64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vNV(location: Int32; count: Int32; value: pointer) := z_UniformHandleui64vNV(location, count, value);
    
    public z_ProgramUniformHandleui64NV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; value: UInt64)>('glProgramUniformHandleui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64NV(&program: UInt32; location: Int32; value: UInt64) := z_ProgramUniformHandleui64NV(&program, location, value);
    
    public z_ProgramUniformHandleui64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; values: pointer)>('glProgramUniformHandleui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vNV(&program: UInt32; location: Int32; count: Int32; values: array of UInt64) := ProgramUniformHandleui64vNV(&program, location, count, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vNV(&program: UInt32; location: Int32; count: Int32; var values: UInt64) := ProgramUniformHandleui64vNV(&program, location, count, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vNV(&program: UInt32; location: Int32; count: Int32; values: pointer) := z_ProgramUniformHandleui64vNV(&program, location, count, values);
    
    public z_IsTextureHandleResidentNV := GetGLFuncOrNil&<function(handle: UInt64): boolean>('glIsTextureHandleResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTextureHandleResidentNV(handle: UInt64): boolean := z_IsTextureHandleResidentNV(handle);
    
    public z_IsImageHandleResidentNV := GetGLFuncOrNil&<function(handle: UInt64): boolean>('glIsImageHandleResidentNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsImageHandleResidentNV(handle: UInt64): boolean := z_IsImageHandleResidentNV(handle);
    
    {$endregion NV_bindless_texture}
    
    {$region NV_internalformat_sample_query}
    
    public z_GetInternalformatSampleivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; samples: Int32; pname: DummyEnum; bufSize: Int32; &params: pointer)>('glGetInternalformatSampleivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformatSampleivNV(target: DummyEnum; internalformat: DummyEnum; samples: Int32; pname: DummyEnum; bufSize: Int32; &params: array of Int32) := GetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformatSampleivNV(target: DummyEnum; internalformat: DummyEnum; samples: Int32; pname: DummyEnum; bufSize: Int32; var &params: Int32) := GetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformatSampleivNV(target: DummyEnum; internalformat: DummyEnum; samples: Int32; pname: DummyEnum; bufSize: Int32; &params: pointer) := z_GetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, &params);
    
    {$endregion NV_internalformat_sample_query}
    
    {$region NV_explicit_multisample}
    
    public z_GetMultisamplefvNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; index: UInt32; val: pointer)>('glGetMultisamplefvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefvNV(pname: DummyEnum; index: UInt32; val: array of single) := GetMultisamplefvNV(pname, index, val[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefvNV(pname: DummyEnum; index: UInt32; var val: single) := GetMultisamplefvNV(pname, index, @val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultisamplefvNV(pname: DummyEnum; index: UInt32; val: pointer) := z_GetMultisamplefvNV(pname, index, val);
    
    public z_SampleMaskIndexedNV := GetGLFuncOrNil&<procedure(index: UInt32; mask: DummyFlags)>('glSampleMaskIndexedNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskIndexedNV(index: UInt32; mask: DummyFlags) := z_SampleMaskIndexedNV(index, mask);
    
    public z_TexRenderbufferNV := GetGLFuncOrNil&<procedure(target: DummyEnum; renderbuffer: UInt32)>('glTexRenderbufferNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexRenderbufferNV(target: DummyEnum; renderbuffer: UInt32) := z_TexRenderbufferNV(target, renderbuffer);
    
    {$endregion NV_explicit_multisample}
    
    {$region NV_gpu_program4}
    
    public z_ProgramLocalParameterI4iNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>('glProgramLocalParameterI4iNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4iNV(target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := z_ProgramLocalParameterI4iNV(target, index, x, y, z, w);
    
    public z_ProgramLocalParameterI4ivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glProgramLocalParameterI4ivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: DummyEnum; index: UInt32; &params: array of Int32) := ProgramLocalParameterI4ivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: DummyEnum; index: UInt32; var &params: Int32) := ProgramLocalParameterI4ivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramLocalParameterI4ivNV(target, index, &params);
    
    public z_ProgramLocalParametersI4ivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>('glProgramLocalParametersI4ivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; &params: array of Int32) := ProgramLocalParametersI4ivNV(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; var &params: Int32) := ProgramLocalParametersI4ivNV(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramLocalParametersI4ivNV(target, index, count, &params);
    
    public z_ProgramLocalParameterI4uiNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>('glProgramLocalParameterI4uiNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uiNV(target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := z_ProgramLocalParameterI4uiNV(target, index, x, y, z, w);
    
    public z_ProgramLocalParameterI4uivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glProgramLocalParameterI4uivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: DummyEnum; index: UInt32; &params: array of UInt32) := ProgramLocalParameterI4uivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: DummyEnum; index: UInt32; var &params: UInt32) := ProgramLocalParameterI4uivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramLocalParameterI4uivNV(target, index, &params);
    
    public z_ProgramLocalParametersI4uivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>('glProgramLocalParametersI4uivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; &params: array of UInt32) := ProgramLocalParametersI4uivNV(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; var &params: UInt32) := ProgramLocalParametersI4uivNV(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramLocalParametersI4uivNV(target, index, count, &params);
    
    public z_ProgramEnvParameterI4iNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>('glProgramEnvParameterI4iNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4iNV(target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := z_ProgramEnvParameterI4iNV(target, index, x, y, z, w);
    
    public z_ProgramEnvParameterI4ivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glProgramEnvParameterI4ivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: DummyEnum; index: UInt32; &params: array of Int32) := ProgramEnvParameterI4ivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: DummyEnum; index: UInt32; var &params: Int32) := ProgramEnvParameterI4ivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramEnvParameterI4ivNV(target, index, &params);
    
    public z_ProgramEnvParametersI4ivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>('glProgramEnvParametersI4ivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; &params: array of Int32) := ProgramEnvParametersI4ivNV(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; var &params: Int32) := ProgramEnvParametersI4ivNV(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramEnvParametersI4ivNV(target, index, count, &params);
    
    public z_ProgramEnvParameterI4uiNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>('glProgramEnvParameterI4uiNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uiNV(target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := z_ProgramEnvParameterI4uiNV(target, index, x, y, z, w);
    
    public z_ProgramEnvParameterI4uivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glProgramEnvParameterI4uivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: DummyEnum; index: UInt32; &params: array of UInt32) := ProgramEnvParameterI4uivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: DummyEnum; index: UInt32; var &params: UInt32) := ProgramEnvParameterI4uivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramEnvParameterI4uivNV(target, index, &params);
    
    public z_ProgramEnvParametersI4uivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>('glProgramEnvParametersI4uivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; &params: array of UInt32) := ProgramEnvParametersI4uivNV(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; var &params: UInt32) := ProgramEnvParametersI4uivNV(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramEnvParametersI4uivNV(target, index, count, &params);
    
    public z_GetProgramLocalParameterIivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glGetProgramLocalParameterIivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIivNV(target: DummyEnum; index: UInt32; &params: array of Int32) := GetProgramLocalParameterIivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIivNV(target: DummyEnum; index: UInt32; var &params: Int32) := GetProgramLocalParameterIivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramLocalParameterIivNV(target, index, &params);
    
    public z_GetProgramLocalParameterIuivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glGetProgramLocalParameterIuivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIuivNV(target: DummyEnum; index: UInt32; &params: array of UInt32) := GetProgramLocalParameterIuivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIuivNV(target: DummyEnum; index: UInt32; var &params: UInt32) := GetProgramLocalParameterIuivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIuivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramLocalParameterIuivNV(target, index, &params);
    
    public z_GetProgramEnvParameterIivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glGetProgramEnvParameterIivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIivNV(target: DummyEnum; index: UInt32; &params: array of Int32) := GetProgramEnvParameterIivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIivNV(target: DummyEnum; index: UInt32; var &params: Int32) := GetProgramEnvParameterIivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramEnvParameterIivNV(target, index, &params);
    
    public z_GetProgramEnvParameterIuivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>('glGetProgramEnvParameterIuivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIuivNV(target: DummyEnum; index: UInt32; &params: array of UInt32) := GetProgramEnvParameterIuivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIuivNV(target: DummyEnum; index: UInt32; var &params: UInt32) := GetProgramEnvParameterIuivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIuivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramEnvParameterIuivNV(target, index, &params);
    
    {$endregion NV_gpu_program4}
    
    {$region NV_fragment_program}
    
    public z_ProgramNamedParameter4fNV := GetGLFuncOrNil&<procedure(id: UInt32; len: Int32; name: pointer; x: single; y: single; z: single; w: single)>('glProgramNamedParameter4fNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: UInt32; len: Int32; name: array of Byte; x: single; y: single; z: single; w: single) := ProgramNamedParameter4fNV(id, len, name[0], x, y, z, w);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: UInt32; len: Int32; var name: Byte; x: single; y: single; z: single; w: single) := ProgramNamedParameter4fNV(id, len, @name, x, y, z, w);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: UInt32; len: Int32; name: pointer; x: single; y: single; z: single; w: single) := z_ProgramNamedParameter4fNV(id, len, name, x, y, z, w);
    
    public z_ProgramNamedParameter4dNV := GetGLFuncOrNil&<procedure(id: UInt32; len: Int32; name: pointer; x: double; y: double; z: double; w: double)>('glProgramNamedParameter4dNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: UInt32; len: Int32; name: array of Byte; x: double; y: double; z: double; w: double) := ProgramNamedParameter4dNV(id, len, name[0], x, y, z, w);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: UInt32; len: Int32; var name: Byte; x: double; y: double; z: double; w: double) := ProgramNamedParameter4dNV(id, len, @name, x, y, z, w);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: UInt32; len: Int32; name: pointer; x: double; y: double; z: double; w: double) := z_ProgramNamedParameter4dNV(id, len, name, x, y, z, w);
    
    public z_ProgramNamedParameter4fvNV := GetGLFuncOrNil&<procedure(id: UInt32; len: Int32; name: pointer; v: pointer)>('glProgramNamedParameter4fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: array of Byte; v: array of single) := ProgramNamedParameter4fvNV(id, len, name[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: array of Byte; var v: single) := ProgramNamedParameter4fvNV(id, len, name[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: array of Byte; v: pointer) := ProgramNamedParameter4fvNV(id, len, name[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; var name: Byte; v: array of single) := ProgramNamedParameter4fvNV(id, len, @name, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; var name: Byte; var v: single) := ProgramNamedParameter4fvNV(id, len, @name, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; var name: Byte; v: pointer) := ProgramNamedParameter4fvNV(id, len, @name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: pointer; v: array of single) := ProgramNamedParameter4fvNV(id, len, name, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: pointer; var v: single) := ProgramNamedParameter4fvNV(id, len, name, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: pointer; v: pointer) := z_ProgramNamedParameter4fvNV(id, len, name, v);
    
    public z_ProgramNamedParameter4dvNV := GetGLFuncOrNil&<procedure(id: UInt32; len: Int32; name: pointer; v: pointer)>('glProgramNamedParameter4dvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: array of Byte; v: array of double) := ProgramNamedParameter4dvNV(id, len, name[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: array of Byte; var v: double) := ProgramNamedParameter4dvNV(id, len, name[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: array of Byte; v: pointer) := ProgramNamedParameter4dvNV(id, len, name[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; var name: Byte; v: array of double) := ProgramNamedParameter4dvNV(id, len, @name, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; var name: Byte; var v: double) := ProgramNamedParameter4dvNV(id, len, @name, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; var name: Byte; v: pointer) := ProgramNamedParameter4dvNV(id, len, @name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: pointer; v: array of double) := ProgramNamedParameter4dvNV(id, len, name, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: pointer; var v: double) := ProgramNamedParameter4dvNV(id, len, name, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: pointer; v: pointer) := z_ProgramNamedParameter4dvNV(id, len, name, v);
    
    public z_GetProgramNamedParameterfvNV := GetGLFuncOrNil&<procedure(id: UInt32; len: Int32; name: pointer; &params: pointer)>('glGetProgramNamedParameterfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: array of Byte; &params: array of single) := GetProgramNamedParameterfvNV(id, len, name[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: array of Byte; var &params: single) := GetProgramNamedParameterfvNV(id, len, name[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: array of Byte; &params: pointer) := GetProgramNamedParameterfvNV(id, len, name[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; var name: Byte; &params: array of single) := GetProgramNamedParameterfvNV(id, len, @name, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; var name: Byte; var &params: single) := GetProgramNamedParameterfvNV(id, len, @name, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; var name: Byte; &params: pointer) := GetProgramNamedParameterfvNV(id, len, @name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: pointer; &params: array of single) := GetProgramNamedParameterfvNV(id, len, name, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: pointer; var &params: single) := GetProgramNamedParameterfvNV(id, len, name, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: pointer; &params: pointer) := z_GetProgramNamedParameterfvNV(id, len, name, &params);
    
    public z_GetProgramNamedParameterdvNV := GetGLFuncOrNil&<procedure(id: UInt32; len: Int32; name: pointer; &params: pointer)>('glGetProgramNamedParameterdvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: array of Byte; &params: array of double) := GetProgramNamedParameterdvNV(id, len, name[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: array of Byte; var &params: double) := GetProgramNamedParameterdvNV(id, len, name[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: array of Byte; &params: pointer) := GetProgramNamedParameterdvNV(id, len, name[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; var name: Byte; &params: array of double) := GetProgramNamedParameterdvNV(id, len, @name, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; var name: Byte; var &params: double) := GetProgramNamedParameterdvNV(id, len, @name, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; var name: Byte; &params: pointer) := GetProgramNamedParameterdvNV(id, len, @name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: pointer; &params: array of double) := GetProgramNamedParameterdvNV(id, len, name, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: pointer; var &params: double) := GetProgramNamedParameterdvNV(id, len, name, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: pointer; &params: pointer) := z_GetProgramNamedParameterdvNV(id, len, name, &params);
    
    {$endregion NV_fragment_program}
    
    {$region ARB_shader_subroutine}
    
    public z_ProgramSubroutineParametersuivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; count: Int32; &params: pointer)>('glProgramSubroutineParametersuivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; &params: array of UInt32) := ProgramSubroutineParametersuivNV(target, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; var &params: UInt32) := ProgramSubroutineParametersuivNV(target, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; &params: pointer) := z_ProgramSubroutineParametersuivNV(target, count, &params);
    
    public z_GetProgramSubroutineParameteruivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32; param: pointer)>('glGetProgramSubroutineParameteruivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramSubroutineParameteruivNV(target: DummyEnum; index: UInt32; param: array of UInt32) := GetProgramSubroutineParameteruivNV(target, index, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramSubroutineParameteruivNV(target: DummyEnum; index: UInt32; var param: UInt32) := GetProgramSubroutineParameteruivNV(target, index, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramSubroutineParameteruivNV(target: DummyEnum; index: UInt32; param: pointer) := z_GetProgramSubroutineParameteruivNV(target, index, param);
    
    {$endregion ARB_shader_subroutine}
    
    {$region ARB_transform_feedback3 NV_transform_feedback}
    
    public z_TransformFeedbackAttribsNV := GetGLFuncOrNil&<procedure(count: Int32; attribs: pointer; bufferMode: DummyEnum)>('glTransformFeedbackAttribsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; attribs: array of Int32; bufferMode: DummyEnum) := TransformFeedbackAttribsNV(count, attribs[0], bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; var attribs: Int32; bufferMode: DummyEnum) := TransformFeedbackAttribsNV(count, @attribs, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; attribs: pointer; bufferMode: DummyEnum) := z_TransformFeedbackAttribsNV(count, attribs, bufferMode);
    
    public z_TransformFeedbackVaryingsNV := GetGLFuncOrNil&<procedure(&program: UInt32; count: Int32; locations: pointer; bufferMode: DummyEnum)>('glTransformFeedbackVaryingsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsNV(&program: UInt32; count: Int32; locations: array of Int32; bufferMode: DummyEnum) := TransformFeedbackVaryingsNV(&program, count, locations[0], bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsNV(&program: UInt32; count: Int32; var locations: Int32; bufferMode: DummyEnum) := TransformFeedbackVaryingsNV(&program, count, @locations, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackVaryingsNV(&program: UInt32; count: Int32; locations: pointer; bufferMode: DummyEnum) := z_TransformFeedbackVaryingsNV(&program, count, locations, bufferMode);
    
    public z_GetTransformFeedbackVaryingNV := GetGLFuncOrNil&<procedure(&program: UInt32; index: UInt32; location: pointer)>('glGetTransformFeedbackVaryingNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingNV(&program: UInt32; index: UInt32; location: array of Int32) := GetTransformFeedbackVaryingNV(&program, index, location[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingNV(&program: UInt32; index: UInt32; var location: Int32) := GetTransformFeedbackVaryingNV(&program, index, @location);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTransformFeedbackVaryingNV(&program: UInt32; index: UInt32; location: pointer) := z_GetTransformFeedbackVaryingNV(&program, index, location);
    
    {$endregion ARB_transform_feedback3 NV_transform_feedback}
    
    {$region AMD_gpu_shader_int64 NV_gpu_shader5}
    
    public z_Uniform1i64NV := GetGLFuncOrNil&<procedure(location: Int32; x: Int64)>('glUniform1i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64NV(location: Int32; x: Int64) := z_Uniform1i64NV(location, x);
    
    public z_Uniform2i64NV := GetGLFuncOrNil&<procedure(location: Int32; x: Int64; y: Int64)>('glUniform2i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64NV(location: Int32; x: Int64; y: Int64) := z_Uniform2i64NV(location, x, y);
    
    public z_Uniform3i64NV := GetGLFuncOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64)>('glUniform3i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64NV(location: Int32; x: Int64; y: Int64; z: Int64) := z_Uniform3i64NV(location, x, y, z);
    
    public z_Uniform4i64NV := GetGLFuncOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>('glUniform4i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64NV(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) := z_Uniform4i64NV(location, x, y, z, w);
    
    public z_Uniform1i64vNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; value: array of Int64) := Uniform1i64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; var value: Int64) := Uniform1i64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vNV(location: Int32; count: Int32; value: pointer) := z_Uniform1i64vNV(location, count, value);
    
    public z_Uniform2i64vNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; value: array of Int64) := Uniform2i64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; var value: Int64) := Uniform2i64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vNV(location: Int32; count: Int32; value: pointer) := z_Uniform2i64vNV(location, count, value);
    
    public z_Uniform3i64vNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; value: array of Int64) := Uniform3i64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; var value: Int64) := Uniform3i64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vNV(location: Int32; count: Int32; value: pointer) := z_Uniform3i64vNV(location, count, value);
    
    public z_Uniform4i64vNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; value: array of Int64) := Uniform4i64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; var value: Int64) := Uniform4i64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vNV(location: Int32; count: Int32; value: pointer) := z_Uniform4i64vNV(location, count, value);
    
    public z_Uniform1ui64NV := GetGLFuncOrNil&<procedure(location: Int32; x: UInt64)>('glUniform1ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64NV(location: Int32; x: UInt64) := z_Uniform1ui64NV(location, x);
    
    public z_Uniform2ui64NV := GetGLFuncOrNil&<procedure(location: Int32; x: UInt64; y: UInt64)>('glUniform2ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64NV(location: Int32; x: UInt64; y: UInt64) := z_Uniform2ui64NV(location, x, y);
    
    public z_Uniform3ui64NV := GetGLFuncOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64)>('glUniform3ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64) := z_Uniform3ui64NV(location, x, y, z);
    
    public z_Uniform4ui64NV := GetGLFuncOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>('glUniform4ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64NV(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := z_Uniform4ui64NV(location, x, y, z, w);
    
    public z_Uniform1ui64vNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform1ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; value: array of UInt64) := Uniform1ui64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; var value: UInt64) := Uniform1ui64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vNV(location: Int32; count: Int32; value: pointer) := z_Uniform1ui64vNV(location, count, value);
    
    public z_Uniform2ui64vNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform2ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; value: array of UInt64) := Uniform2ui64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; var value: UInt64) := Uniform2ui64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vNV(location: Int32; count: Int32; value: pointer) := z_Uniform2ui64vNV(location, count, value);
    
    public z_Uniform3ui64vNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform3ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; value: array of UInt64) := Uniform3ui64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; var value: UInt64) := Uniform3ui64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vNV(location: Int32; count: Int32; value: pointer) := z_Uniform3ui64vNV(location, count, value);
    
    public z_Uniform4ui64vNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; value: pointer)>('glUniform4ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; value: array of UInt64) := Uniform4ui64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; var value: UInt64) := Uniform4ui64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vNV(location: Int32; count: Int32; value: pointer) := z_Uniform4ui64vNV(location, count, value);
    
    public z_GetUniformi64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; &params: pointer)>('glGetUniformi64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: UInt32; location: Int32; &params: array of Int64) := GetUniformi64vNV(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: UInt32; location: Int32; var &params: Int64) := GetUniformi64vNV(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vNV(&program: UInt32; location: Int32; &params: pointer) := z_GetUniformi64vNV(&program, location, &params);
    
    public z_ProgramUniform1i64NV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: Int64)>('glProgramUniform1i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64NV(&program: UInt32; location: Int32; x: Int64) := z_ProgramUniform1i64NV(&program, location, x);
    
    public z_ProgramUniform2i64NV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: Int64; y: Int64)>('glProgramUniform2i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64NV(&program: UInt32; location: Int32; x: Int64; y: Int64) := z_ProgramUniform2i64NV(&program, location, x, y);
    
    public z_ProgramUniform3i64NV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64)>('glProgramUniform3i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64NV(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64) := z_ProgramUniform3i64NV(&program, location, x, y, z);
    
    public z_ProgramUniform4i64NV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>('glProgramUniform4i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64NV(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) := z_ProgramUniform4i64NV(&program, location, x, y, z, w);
    
    public z_ProgramUniform1i64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform1i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform1i64vNV(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform1i64vNV(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vNV(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1i64vNV(&program, location, count, value);
    
    public z_ProgramUniform2i64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform2i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform2i64vNV(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform2i64vNV(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vNV(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2i64vNV(&program, location, count, value);
    
    public z_ProgramUniform3i64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform3i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform3i64vNV(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform3i64vNV(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vNV(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3i64vNV(&program, location, count, value);
    
    public z_ProgramUniform4i64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform4i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform4i64vNV(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform4i64vNV(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vNV(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4i64vNV(&program, location, count, value);
    
    public z_ProgramUniform1ui64NV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64)>('glProgramUniform1ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64NV(&program: UInt32; location: Int32; x: UInt64) := z_ProgramUniform1ui64NV(&program, location, x);
    
    public z_ProgramUniform2ui64NV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64)>('glProgramUniform2ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64NV(&program: UInt32; location: Int32; x: UInt64; y: UInt64) := z_ProgramUniform2ui64NV(&program, location, x, y);
    
    public z_ProgramUniform3ui64NV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64)>('glProgramUniform3ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64NV(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64) := z_ProgramUniform3ui64NV(&program, location, x, y, z);
    
    public z_ProgramUniform4ui64NV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>('glProgramUniform4ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64NV(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := z_ProgramUniform4ui64NV(&program, location, x, y, z, w);
    
    public z_ProgramUniform1ui64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform1ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform1ui64vNV(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform1ui64vNV(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vNV(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1ui64vNV(&program, location, count, value);
    
    public z_ProgramUniform2ui64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform2ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform2ui64vNV(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform2ui64vNV(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vNV(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2ui64vNV(&program, location, count, value);
    
    public z_ProgramUniform3ui64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform3ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform3ui64vNV(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform3ui64vNV(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vNV(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3ui64vNV(&program, location, count, value);
    
    public z_ProgramUniform4ui64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>('glProgramUniform4ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform4ui64vNV(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform4ui64vNV(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vNV(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4ui64vNV(&program, location, count, value);
    
    {$endregion AMD_gpu_shader_int64 NV_gpu_shader5}
    
    {$region AMD_gpu_shader_int64 NV_gpu_shader5 NV_shader_buffer_load}
    
    public z_GetUniformui64vNV := GetGLFuncOrNil&<procedure(&program: UInt32; location: Int32; &params: pointer)>('glGetUniformui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: UInt32; location: Int32; &params: array of UInt64) := GetUniformui64vNV(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: UInt32; location: Int32; var &params: UInt64) := GetUniformui64vNV(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vNV(&program: UInt32; location: Int32; &params: pointer) := z_GetUniformui64vNV(&program, location, &params);
    
    {$endregion AMD_gpu_shader_int64 NV_gpu_shader5 NV_shader_buffer_load}
    
    {$region NV_vertex_attrib_integer_64bit}
    
    public z_VertexAttribL1i64NV := GetGLFuncOrNil&<procedure(index: UInt32; x: Int64)>('glVertexAttribL1i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64NV(index: UInt32; x: Int64) := z_VertexAttribL1i64NV(index, x);
    
    public z_VertexAttribL2i64NV := GetGLFuncOrNil&<procedure(index: UInt32; x: Int64; y: Int64)>('glVertexAttribL2i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64NV(index: UInt32; x: Int64; y: Int64) := z_VertexAttribL2i64NV(index, x, y);
    
    public z_VertexAttribL3i64NV := GetGLFuncOrNil&<procedure(index: UInt32; x: Int64; y: Int64; z: Int64)>('glVertexAttribL3i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64NV(index: UInt32; x: Int64; y: Int64; z: Int64) := z_VertexAttribL3i64NV(index, x, y, z);
    
    public z_VertexAttribL4i64NV := GetGLFuncOrNil&<procedure(index: UInt32; x: Int64; y: Int64; z: Int64; w: Int64)>('glVertexAttribL4i64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64NV(index: UInt32; x: Int64; y: Int64; z: Int64; w: Int64) := z_VertexAttribL4i64NV(index, x, y, z, w);
    
    public z_VertexAttribL1i64vNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL1i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; v: array of Int64) := VertexAttribL1i64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; var v: Int64) := VertexAttribL1i64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; v: pointer) := z_VertexAttribL1i64vNV(index, v);
    
    public z_VertexAttribL2i64vNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL2i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; v: array of Int64) := VertexAttribL2i64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; var v: Int64) := VertexAttribL2i64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; v: pointer) := z_VertexAttribL2i64vNV(index, v);
    
    public z_VertexAttribL3i64vNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL3i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; v: array of Int64) := VertexAttribL3i64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; var v: Int64) := VertexAttribL3i64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; v: pointer) := z_VertexAttribL3i64vNV(index, v);
    
    public z_VertexAttribL4i64vNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL4i64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; v: array of Int64) := VertexAttribL4i64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; var v: Int64) := VertexAttribL4i64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; v: pointer) := z_VertexAttribL4i64vNV(index, v);
    
    public z_VertexAttribL1ui64NV := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt64)>('glVertexAttribL1ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64NV(index: UInt32; x: UInt64) := z_VertexAttribL1ui64NV(index, x);
    
    public z_VertexAttribL2ui64NV := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64)>('glVertexAttribL2ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64NV(index: UInt32; x: UInt64; y: UInt64) := z_VertexAttribL2ui64NV(index, x, y);
    
    public z_VertexAttribL3ui64NV := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64; z: UInt64)>('glVertexAttribL3ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64NV(index: UInt32; x: UInt64; y: UInt64; z: UInt64) := z_VertexAttribL3ui64NV(index, x, y, z);
    
    public z_VertexAttribL4ui64NV := GetGLFuncOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>('glVertexAttribL4ui64NV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64NV(index: UInt32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := z_VertexAttribL4ui64NV(index, x, y, z, w);
    
    public z_VertexAttribL1ui64vNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL1ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vNV(index: UInt32; v: array of UInt64) := VertexAttribL1ui64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vNV(index: UInt32; var v: UInt64) := VertexAttribL1ui64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vNV(index: UInt32; v: pointer) := z_VertexAttribL1ui64vNV(index, v);
    
    public z_VertexAttribL2ui64vNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL2ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; v: array of UInt64) := VertexAttribL2ui64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; var v: UInt64) := VertexAttribL2ui64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; v: pointer) := z_VertexAttribL2ui64vNV(index, v);
    
    public z_VertexAttribL3ui64vNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL3ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; v: array of UInt64) := VertexAttribL3ui64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; var v: UInt64) := VertexAttribL3ui64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; v: pointer) := z_VertexAttribL3ui64vNV(index, v);
    
    public z_VertexAttribL4ui64vNV := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glVertexAttribL4ui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; v: array of UInt64) := VertexAttribL4ui64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; var v: UInt64) := VertexAttribL4ui64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; v: pointer) := z_VertexAttribL4ui64vNV(index, v);
    
    public z_GetVertexAttribLi64vNV := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribLi64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLi64vNV(index: UInt32; pname: DummyEnum; &params: array of Int64) := GetVertexAttribLi64vNV(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLi64vNV(index: UInt32; pname: DummyEnum; var &params: Int64) := GetVertexAttribLi64vNV(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLi64vNV(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribLi64vNV(index, pname, &params);
    
    public z_GetVertexAttribLui64vNV := GetGLFuncOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>('glGetVertexAttribLui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vNV(index: UInt32; pname: DummyEnum; &params: array of UInt64) := GetVertexAttribLui64vNV(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vNV(index: UInt32; pname: DummyEnum; var &params: UInt64) := GetVertexAttribLui64vNV(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vNV(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribLui64vNV(index, pname, &params);
    
    public z_VertexAttribLFormatNV := GetGLFuncOrNil&<procedure(index: UInt32; size: Int32; &type: DummyEnum; stride: Int32)>('glVertexAttribLFormatNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribLFormatNV(index: UInt32; size: Int32; &type: DummyEnum; stride: Int32) := z_VertexAttribLFormatNV(index, size, &type, stride);
    
    {$endregion NV_vertex_attrib_integer_64bit}
    
    {$region NV_gpu_multicast}
    
    public z_RenderGpuMaskNV := GetGLFuncOrNil&<procedure(mask: DummyFlags)>('glRenderGpuMaskNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderGpuMaskNV(mask: DummyFlags) := z_RenderGpuMaskNV(mask);
    
    public z_MulticastBufferSubDataNV := GetGLFuncOrNil&<procedure(gpuMask: DummyFlags; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer)>('glMulticastBufferSubDataNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBufferSubDataNV(gpuMask: DummyFlags; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer) := z_MulticastBufferSubDataNV(gpuMask, buffer, offset, size, data);
    
    public z_MulticastCopyBufferSubDataNV := GetGLFuncOrNil&<procedure(readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>('glMulticastCopyBufferSubDataNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastCopyBufferSubDataNV(readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_MulticastCopyBufferSubDataNV(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    public z_MulticastCopyImageSubDataNV := GetGLFuncOrNil&<procedure(srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>('glMulticastCopyImageSubDataNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastCopyImageSubDataNV(srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) := z_MulticastCopyImageSubDataNV(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
    public z_MulticastBlitFramebufferNV := GetGLFuncOrNil&<procedure(srcGpu: UInt32; dstGpu: UInt32; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>('glMulticastBlitFramebufferNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBlitFramebufferNV(srcGpu: UInt32; dstGpu: UInt32; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := z_MulticastBlitFramebufferNV(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    public z_MulticastFramebufferSampleLocationsfvNV := GetGLFuncOrNil&<procedure(gpu: UInt32; framebuffer: UInt32; start: UInt32; count: Int32; v: pointer)>('glMulticastFramebufferSampleLocationsfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: UInt32; start: UInt32; count: Int32; v: array of single) := MulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: UInt32; start: UInt32; count: Int32; var v: single) := MulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: UInt32; start: UInt32; count: Int32; v: pointer) := z_MulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v);
    
    public z_MulticastBarrierNV := GetGLFuncOrNil&<procedure>('glMulticastBarrierNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBarrierNV := z_MulticastBarrierNV;
    
    public z_MulticastWaitSyncNV := GetGLFuncOrNil&<procedure(signalGpu: UInt32; waitGpuMask: DummyFlags)>('glMulticastWaitSyncNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastWaitSyncNV(signalGpu: UInt32; waitGpuMask: DummyFlags) := z_MulticastWaitSyncNV(signalGpu, waitGpuMask);
    
    public z_MulticastGetQueryObjectivNV := GetGLFuncOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer)>('glMulticastGetQueryObjectivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of Int32) := MulticastGetQueryObjectivNV(gpu, id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int32) := MulticastGetQueryObjectivNV(gpu, id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := z_MulticastGetQueryObjectivNV(gpu, id, pname, &params);
    
    public z_MulticastGetQueryObjectuivNV := GetGLFuncOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer)>('glMulticastGetQueryObjectuivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of UInt32) := MulticastGetQueryObjectuivNV(gpu, id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt32) := MulticastGetQueryObjectuivNV(gpu, id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := z_MulticastGetQueryObjectuivNV(gpu, id, pname, &params);
    
    public z_MulticastGetQueryObjecti64vNV := GetGLFuncOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer)>('glMulticastGetQueryObjecti64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of Int64) := MulticastGetQueryObjecti64vNV(gpu, id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int64) := MulticastGetQueryObjecti64vNV(gpu, id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := z_MulticastGetQueryObjecti64vNV(gpu, id, pname, &params);
    
    public z_MulticastGetQueryObjectui64vNV := GetGLFuncOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer)>('glMulticastGetQueryObjectui64vNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of UInt64) := MulticastGetQueryObjectui64vNV(gpu, id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt64) := MulticastGetQueryObjectui64vNV(gpu, id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := z_MulticastGetQueryObjectui64vNV(gpu, id, pname, &params);
    
    {$endregion NV_gpu_multicast}
    
    {$region NV_bindless_multi_draw_indirect_count}
    
    public z_MultiDrawArraysIndirectBindlessCountNV := GetGLFuncOrNil&<procedure(mode: DummyEnum; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32)>('glMultiDrawArraysIndirectBindlessCountNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectBindlessCountNV(mode: DummyEnum; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32) := z_MultiDrawArraysIndirectBindlessCountNV(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    
    public z_MultiDrawElementsIndirectBindlessCountNV := GetGLFuncOrNil&<procedure(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32)>('glMultiDrawElementsIndirectBindlessCountNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectBindlessCountNV(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32) := z_MultiDrawElementsIndirectBindlessCountNV(mode, &type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    
    {$endregion NV_bindless_multi_draw_indirect_count}
    
    {$region NV_bindless_multi_draw_indirect}
    
    public z_MultiDrawArraysIndirectBindlessNV := GetGLFuncOrNil&<procedure(mode: DummyEnum; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32)>('glMultiDrawArraysIndirectBindlessNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectBindlessNV(mode: DummyEnum; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32) := z_MultiDrawArraysIndirectBindlessNV(mode, indirect, drawCount, stride, vertexBufferCount);
    
    public z_MultiDrawElementsIndirectBindlessNV := GetGLFuncOrNil&<procedure(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32)>('glMultiDrawElementsIndirectBindlessNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectBindlessNV(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32) := z_MultiDrawElementsIndirectBindlessNV(mode, &type, indirect, drawCount, stride, vertexBufferCount);
    
    {$endregion NV_bindless_multi_draw_indirect}
    
    {$region NV_point_sprite}
    
    public z_PointParameteriNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: Int32)>('glPointParameteriNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameteriNV(pname: DummyEnum; param: Int32) := z_PointParameteriNV(pname, param);
    
    public z_PointParameterivNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glPointParameterivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterivNV(pname: DummyEnum; &params: array of Int32) := PointParameterivNV(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterivNV(pname: DummyEnum; var &params: Int32) := PointParameterivNV(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterivNV(pname: DummyEnum; &params: pointer) := z_PointParameterivNV(pname, &params);
    
    {$endregion NV_point_sprite}
    
    {$region NV_polygon_mode}
    
    public z_PolygonModeNV := GetGLFuncOrNil&<procedure(face: DummyEnum; mode: DummyEnum)>('glPolygonModeNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonModeNV(face: DummyEnum; mode: DummyEnum) := z_PolygonModeNV(face, mode);
    
    {$endregion NV_polygon_mode}
    
    {$region NV_primitive_restart}
    
    public z_PrimitiveRestartNV := GetGLFuncOrNil&<procedure>('glPrimitiveRestartNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveRestartNV := z_PrimitiveRestartNV;
    
    public z_PrimitiveRestartIndexNV := GetGLFuncOrNil&<procedure(index: UInt32)>('glPrimitiveRestartIndexNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveRestartIndexNV(index: UInt32) := z_PrimitiveRestartIndexNV(index);
    
    {$endregion NV_primitive_restart}
    
    {$region NV_parameter_buffer_object}
    
    public z_ProgramBufferParametersfvNV := GetGLFuncOrNil&<procedure(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer)>('glProgramBufferParametersfvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of single) := ProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: single) := ProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer) := z_ProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, &params);
    
    public z_ProgramBufferParametersIivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer)>('glProgramBufferParametersIivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of Int32) := ProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: Int32) := ProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer) := z_ProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, &params);
    
    public z_ProgramBufferParametersIuivNV := GetGLFuncOrNil&<procedure(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer)>('glProgramBufferParametersIuivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of UInt32) := ProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: UInt32) := ProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer) := z_ProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, &params);
    
    {$endregion NV_parameter_buffer_object}
    
    {$region NV_geometry_program4}
    
    public z_ProgramVertexLimitNV := GetGLFuncOrNil&<procedure(target: DummyEnum; limit: Int32)>('glProgramVertexLimitNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramVertexLimitNV(target: DummyEnum; limit: Int32) := z_ProgramVertexLimitNV(target, limit);
    
    {$endregion NV_geometry_program4}
    
    {$region NV_query_resource}
    
    public z_QueryResourceNV := GetGLFuncOrNil&<function(queryType: DummyEnum; tagId: Int32; bufSize: UInt32; buffer: pointer): Int32>('glQueryResourceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; bufSize: UInt32; buffer: array of Int32): Int32 := QueryResourceNV(queryType, tagId, bufSize, buffer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; bufSize: UInt32; var buffer: Int32): Int32 := QueryResourceNV(queryType, tagId, bufSize, @buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; bufSize: UInt32; buffer: pointer): Int32 := z_QueryResourceNV(queryType, tagId, bufSize, buffer);
    
    {$endregion NV_query_resource}
    
    {$region NV_read_buffer NV_read_buffer_front}
    
    public z_ReadBufferNV := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glReadBufferNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadBufferNV(mode: DummyEnum) := z_ReadBufferNV(mode);
    
    {$endregion NV_read_buffer NV_read_buffer_front}
    
    {$region NV_framebuffer_multisample_coverage}
    
    public z_RenderbufferStorageMultisampleCoverageNV := GetGLFuncOrNil&<procedure(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glRenderbufferStorageMultisampleCoverageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleCoverageNV(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
    
    {$endregion NV_framebuffer_multisample_coverage}
    
    {$region NV_framebuffer_multisample}
    
    public z_RenderbufferStorageMultisampleNV := GetGLFuncOrNil&<procedure(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>('glRenderbufferStorageMultisampleNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleNV(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageMultisampleNV(target, samples, internalformat, width, height);
    
    {$endregion NV_framebuffer_multisample}
    
    {$region NV_scissor_exclusive}
    
    public z_ScissorExclusiveArrayvNV := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>('glScissorExclusiveArrayvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; v: array of Int32) := ScissorExclusiveArrayvNV(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; var v: Int32) := ScissorExclusiveArrayvNV(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; v: pointer) := z_ScissorExclusiveArrayvNV(first, count, v);
    
    public z_ScissorExclusiveNV := GetGLFuncOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32)>('glScissorExclusiveNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveNV(x: Int32; y: Int32; width: Int32; height: Int32) := z_ScissorExclusiveNV(x, y, width, height);
    
    {$endregion NV_scissor_exclusive}
    
    {$region NV_shading_rate_image NV_shading_rate_image}
    
    public z_ShadingRateImageBarrierNV := GetGLFuncOrNil&<procedure(synchronize: boolean)>('glShadingRateImageBarrierNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImageBarrierNV(synchronize: boolean) := z_ShadingRateImageBarrierNV(synchronize);
    
    {$endregion NV_shading_rate_image NV_shading_rate_image}
    
    {$region NV_3dvision_settings}
    
    public z_StereoParameterfNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: single)>('glStereoParameterfNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StereoParameterfNV(pname: DummyEnum; param: single) := z_StereoParameterfNV(pname, param);
    
    public z_StereoParameteriNV := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: Int32)>('glStereoParameteriNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StereoParameteriNV(pname: DummyEnum; param: Int32) := z_StereoParameteriNV(pname, param);
    
    {$endregion NV_3dvision_settings}
    
    {$region NV_conservative_raster}
    
    public z_SubpixelPrecisionBiasNV := GetGLFuncOrNil&<procedure(xbits: UInt32; ybits: UInt32)>('glSubpixelPrecisionBiasNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SubpixelPrecisionBiasNV(xbits: UInt32; ybits: UInt32) := z_SubpixelPrecisionBiasNV(xbits, ybits);
    
    {$endregion NV_conservative_raster}
    
    {$region NV_texture_multisample}
    
    public z_TexImage2DMultisampleCoverageNV := GetGLFuncOrNil&<procedure(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: boolean)>('glTexImage2DMultisampleCoverageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2DMultisampleCoverageNV(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: boolean) := z_TexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    
    public z_TexImage3DMultisampleCoverageNV := GetGLFuncOrNil&<procedure(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean)>('glTexImage3DMultisampleCoverageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DMultisampleCoverageNV(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean) := z_TexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    
    public z_TextureImage2DMultisampleNV := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: boolean)>('glTextureImage2DMultisampleNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DMultisampleNV(texture: UInt32; target: DummyEnum; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: boolean) := z_TextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
    
    public z_TextureImage3DMultisampleNV := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean)>('glTextureImage3DMultisampleNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DMultisampleNV(texture: UInt32; target: DummyEnum; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean) := z_TextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
    
    public z_TextureImage2DMultisampleCoverageNV := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: boolean)>('glTextureImage2DMultisampleCoverageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DMultisampleCoverageNV(texture: UInt32; target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: boolean) := z_TextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    
    public z_TextureImage3DMultisampleCoverageNV := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean)>('glTextureImage3DMultisampleCoverageNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DMultisampleCoverageNV(texture: UInt32; target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: boolean) := z_TextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    
    {$endregion NV_texture_multisample}
    
    {$region NV_texture_barrier}
    
    public z_TextureBarrierNV := GetGLFuncOrNil&<procedure>('glTextureBarrierNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureBarrierNV := z_TextureBarrierNV;
    
    {$endregion NV_texture_barrier}
    
    {$region ARB_transform_feedback3}
    
    public z_TransformFeedbackStreamAttribsNV := GetGLFuncOrNil&<procedure(count: Int32; attribs: pointer; nbuffers: Int32; bufstreams: pointer; bufferMode: DummyEnum)>('glTransformFeedbackStreamAttribsNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: array of Int32; nbuffers: Int32; bufstreams: array of Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, attribs[0], nbuffers, bufstreams[0], bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: array of Int32; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, attribs[0], nbuffers, @bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: array of Int32; nbuffers: Int32; bufstreams: pointer; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, attribs[0], nbuffers, bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; var attribs: Int32; nbuffers: Int32; bufstreams: array of Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, @attribs, nbuffers, bufstreams[0], bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; var attribs: Int32; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, @attribs, nbuffers, @bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; var attribs: Int32; nbuffers: Int32; bufstreams: pointer; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, @attribs, nbuffers, bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: pointer; nbuffers: Int32; bufstreams: array of Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams[0], bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: pointer; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, attribs, nbuffers, @bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: pointer; nbuffers: Int32; bufstreams: pointer; bufferMode: DummyEnum) := z_TransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode);
    
    {$endregion ARB_transform_feedback3}
    
    {$region NV_non_square_matrices}
    
    public z_UniformMatrix2x3fvNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix2x3fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fvNV(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix2x3fvNV(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fvNV(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix2x3fvNV(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x3fvNV(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix2x3fvNV(location, count, transpose, value);
    
    public z_UniformMatrix3x2fvNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix3x2fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fvNV(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix3x2fvNV(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fvNV(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix3x2fvNV(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x2fvNV(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix3x2fvNV(location, count, transpose, value);
    
    public z_UniformMatrix2x4fvNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix2x4fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fvNV(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix2x4fvNV(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fvNV(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix2x4fvNV(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix2x4fvNV(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix2x4fvNV(location, count, transpose, value);
    
    public z_UniformMatrix4x2fvNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix4x2fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fvNV(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix4x2fvNV(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fvNV(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix4x2fvNV(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x2fvNV(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix4x2fvNV(location, count, transpose, value);
    
    public z_UniformMatrix3x4fvNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix3x4fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fvNV(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix3x4fvNV(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fvNV(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix3x4fvNV(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix3x4fvNV(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix3x4fvNV(location, count, transpose, value);
    
    public z_UniformMatrix4x3fvNV := GetGLFuncOrNil&<procedure(location: Int32; count: Int32; transpose: boolean; value: pointer)>('glUniformMatrix4x3fvNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fvNV(location: Int32; count: Int32; transpose: boolean; value: array of single) := UniformMatrix4x3fvNV(location, count, transpose, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fvNV(location: Int32; count: Int32; transpose: boolean; var value: single) := UniformMatrix4x3fvNV(location, count, transpose, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformMatrix4x3fvNV(location: Int32; count: Int32; transpose: boolean; value: pointer) := z_UniformMatrix4x3fvNV(location, count, transpose, value);
    
    {$endregion NV_non_square_matrices}
    
    {$region NV_vdpau_interop}
    
    public z_VDPAUInitNV := GetGLFuncOrNil&<procedure(vdpDevice: pointer; getProcAddress: pointer)>('glVDPAUInitNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUInitNV(vdpDevice: pointer; getProcAddress: pointer) := z_VDPAUInitNV(vdpDevice, getProcAddress);
    
    public z_VDPAUFiniNV := GetGLFuncOrNil&<procedure>('glVDPAUFiniNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUFiniNV := z_VDPAUFiniNV;
    
    public z_VDPAURegisterVideoSurfaceNV := GetGLFuncOrNil&<function(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer): GLvdpauSurfaceNV>('glVDPAURegisterVideoSurfaceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32): GLvdpauSurfaceNV := VDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): GLvdpauSurfaceNV := VDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, @textureNames);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer): GLvdpauSurfaceNV := z_VDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
    
    public z_VDPAURegisterOutputSurfaceNV := GetGLFuncOrNil&<function(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer): GLvdpauSurfaceNV>('glVDPAURegisterOutputSurfaceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32): GLvdpauSurfaceNV := VDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): GLvdpauSurfaceNV := VDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, @textureNames);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer): GLvdpauSurfaceNV := z_VDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
    
    public z_VDPAUIsSurfaceNV := GetGLFuncOrNil&<function(surface: GLvdpauSurfaceNV): boolean>('glVDPAUIsSurfaceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAUIsSurfaceNV(surface: GLvdpauSurfaceNV): boolean := z_VDPAUIsSurfaceNV(surface);
    
    public z_VDPAUUnregisterSurfaceNV := GetGLFuncOrNil&<procedure(surface: GLvdpauSurfaceNV)>('glVDPAUUnregisterSurfaceNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnregisterSurfaceNV(surface: GLvdpauSurfaceNV) := z_VDPAUUnregisterSurfaceNV(surface);
    
    public z_VDPAUGetSurfaceivNV := GetGLFuncOrNil&<procedure(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: pointer; values: pointer)>('glVDPAUGetSurfaceivNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: array of Int32; values: array of Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, length[0], values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: array of Int32; var values: Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, length[0], @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: array of Int32; values: pointer) := VDPAUGetSurfaceivNV(surface, pname, bufSize, length[0], values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; var length: Int32; values: array of Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, @length, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; var length: Int32; var values: Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, @length, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; var length: Int32; values: pointer) := VDPAUGetSurfaceivNV(surface, pname, bufSize, @length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: pointer; values: array of Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, length, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: pointer; var values: Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, length, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: pointer; values: pointer) := z_VDPAUGetSurfaceivNV(surface, pname, bufSize, length, values);
    
    public z_VDPAUSurfaceAccessNV := GetGLFuncOrNil&<procedure(surface: GLvdpauSurfaceNV; access: DummyEnum)>('glVDPAUSurfaceAccessNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUSurfaceAccessNV(surface: GLvdpauSurfaceNV; access: DummyEnum) := z_VDPAUSurfaceAccessNV(surface, access);
    
    public z_VDPAUMapSurfacesNV := GetGLFuncOrNil&<procedure(numSurfaces: Int32; surfaces: pointer)>('glVDPAUMapSurfacesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; surfaces: array of GLvdpauSurfaceNV) := VDPAUMapSurfacesNV(numSurfaces, surfaces[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; var surfaces: GLvdpauSurfaceNV) := VDPAUMapSurfacesNV(numSurfaces, @surfaces);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; surfaces: pointer) := z_VDPAUMapSurfacesNV(numSurfaces, surfaces);
    
    public z_VDPAUUnmapSurfacesNV := GetGLFuncOrNil&<procedure(numSurface: Int32; surfaces: pointer)>('glVDPAUUnmapSurfacesNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; surfaces: array of GLvdpauSurfaceNV) := VDPAUUnmapSurfacesNV(numSurface, surfaces[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; var surfaces: GLvdpauSurfaceNV) := VDPAUUnmapSurfacesNV(numSurface, @surfaces);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; surfaces: pointer) := z_VDPAUUnmapSurfacesNV(numSurface, surfaces);
    
    {$endregion NV_vdpau_interop}
    
    {$region NV_vdpau_interop2}
    
    public z_VDPAURegisterVideoSurfaceWithPictureStructureNV := GetGLFuncOrNil&<function(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer; isFrameStructure: boolean): GLvdpauSurfaceNV>('glVDPAURegisterVideoSurfaceWithPictureStructureNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32; isFrameStructure: boolean): GLvdpauSurfaceNV := VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface, target, numTextureNames, textureNames[0], isFrameStructure);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32; isFrameStructure: boolean): GLvdpauSurfaceNV := VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface, target, numTextureNames, @textureNames, isFrameStructure);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer; isFrameStructure: boolean): GLvdpauSurfaceNV := z_VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
    
    {$endregion NV_vdpau_interop2}
    
    {$region NV_instanced_arrays}
    
    public z_VertexAttribDivisorNV := GetGLFuncOrNil&<procedure(index: UInt32; divisor: UInt32)>('glVertexAttribDivisorNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribDivisorNV(index: UInt32; divisor: UInt32) := z_VertexAttribDivisorNV(index, divisor);
    
    {$endregion NV_instanced_arrays}
    
    {$region NV_clip_space_w_scaling}
    
    public z_ViewportPositionWScaleNV := GetGLFuncOrNil&<procedure(index: UInt32; xcoeff: single; ycoeff: single)>('glViewportPositionWScaleNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportPositionWScaleNV(index: UInt32; xcoeff: single; ycoeff: single) := z_ViewportPositionWScaleNV(index, xcoeff, ycoeff);
    
    {$endregion NV_clip_space_w_scaling}
    
    {$region NV_viewport_swizzle}
    
    public z_ViewportSwizzleNV := GetGLFuncOrNil&<procedure(index: UInt32; swizzlex: DummyEnum; swizzley: DummyEnum; swizzlez: DummyEnum; swizzlew: DummyEnum)>('glViewportSwizzleNV');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportSwizzleNV(index: UInt32; swizzlex: DummyEnum; swizzley: DummyEnum; swizzlez: DummyEnum; swizzlew: DummyEnum) := z_ViewportSwizzleNV(index, swizzlex, swizzley, swizzlez, swizzlew);
    
    {$endregion NV_viewport_swizzle}
    
  end;
  
  gl_NVX = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region NVX_gpu_multicast2}
    
    public z_AsyncCopyImageSubDataNVX := GetGLFuncOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32>('glAsyncCopyImageSubDataNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := z_AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    
    public z_AsyncCopyBufferSubDataNVX := GetGLFuncOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32>('glAsyncCopyBufferSubDataNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := z_AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    
    public z_UploadGpuMaskNVX := GetGLFuncOrNil&<procedure(mask: DummyFlags)>('glUploadGpuMaskNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UploadGpuMaskNVX(mask: DummyFlags) := z_UploadGpuMaskNVX(mask);
    
    public z_MulticastViewportArrayvNVX := GetGLFuncOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; v: pointer)>('glMulticastViewportArrayvNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: array of single) := MulticastViewportArrayvNVX(gpu, first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; var v: single) := MulticastViewportArrayvNVX(gpu, first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: pointer) := z_MulticastViewportArrayvNVX(gpu, first, count, v);
    
    public z_MulticastScissorArrayvNVX := GetGLFuncOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; v: pointer)>('glMulticastScissorArrayvNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: array of Int32) := MulticastScissorArrayvNVX(gpu, first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; var v: Int32) := MulticastScissorArrayvNVX(gpu, first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: pointer) := z_MulticastScissorArrayvNVX(gpu, first, count, v);
    
    public z_MulticastViewportPositionWScaleNVX := GetGLFuncOrNil&<procedure(gpu: UInt32; index: UInt32; xcoeff: single; ycoeff: single)>('glMulticastViewportPositionWScaleNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportPositionWScaleNVX(gpu: UInt32; index: UInt32; xcoeff: single; ycoeff: single) := z_MulticastViewportPositionWScaleNVX(gpu, index, xcoeff, ycoeff);
    
    {$endregion NVX_gpu_multicast2}
    
    {$region NVX_conditional_render}
    
    public z_BeginConditionalRenderNVX := GetGLFuncOrNil&<procedure(id: UInt32)>('glBeginConditionalRenderNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginConditionalRenderNVX(id: UInt32) := z_BeginConditionalRenderNVX(id);
    
    public z_EndConditionalRenderNVX := GetGLFuncOrNil&<procedure>('glEndConditionalRenderNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndConditionalRenderNVX := z_EndConditionalRenderNVX;
    
    {$endregion NVX_conditional_render}
    
    {$region NVX_progress_fence}
    
    public z_CreateProgressFenceNVX := GetGLFuncOrNil&<function: UInt32>('glCreateProgressFenceNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgressFenceNVX: UInt32 := z_CreateProgressFenceNVX;
    
    public z_SignalSemaphoreui64NVX := GetGLFuncOrNil&<procedure(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer)>('glSignalSemaphoreui64NVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; var fenceValueArray: UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray[0], @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: pointer) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: array of UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, @semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, @semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: pointer) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, @semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: array of UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; var fenceValueArray: UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer) := z_SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    
    public z_WaitSemaphoreui64NVX := GetGLFuncOrNil&<procedure(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer)>('glWaitSemaphoreui64NVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; var fenceValueArray: UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray[0], @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: pointer) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: array of UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, @semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, @semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: pointer) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, @semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: array of UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; var fenceValueArray: UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer) := z_WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    
    public z_ClientWaitSemaphoreui64NVX := GetGLFuncOrNil&<procedure(fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer)>('glClientWaitSemaphoreui64NVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray[0], fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: array of UInt32; var fenceValueArray: UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray[0], @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: pointer) := ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray[0], fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: array of UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, @semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, @semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: pointer) := ClientWaitSemaphoreui64NVX(fenceObjectCount, @semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: array of UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: pointer; var fenceValueArray: UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer) := z_ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray, fenceValueArray);
    
    {$endregion NVX_progress_fence}
    
    {$region NVX_linked_gpu_multicast}
    
    public z_LGPUNamedBufferSubDataNVX := GetGLFuncOrNil&<procedure(gpuMask: DummyFlags; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer)>('glLGPUNamedBufferSubDataNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUNamedBufferSubDataNVX(gpuMask: DummyFlags; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer) := z_LGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, data);
    
    public z_LGPUCopyImageSubDataNVX := GetGLFuncOrNil&<procedure(sourceGpu: UInt32; destinationGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srxY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>('glLGPUCopyImageSubDataNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUCopyImageSubDataNVX(sourceGpu: UInt32; destinationGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srxY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) := z_LGPUCopyImageSubDataNVX(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
    public z_LGPUInterlockNVX := GetGLFuncOrNil&<procedure>('glLGPUInterlockNVX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUInterlockNVX := z_LGPUInterlockNVX;
    
    {$endregion NVX_linked_gpu_multicast}
    
  end;
  
  gl_OES = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region OES_fixed_point}
    
    public z_Vertex2xOES := GetGLFuncOrNil&<procedure(x: fixed)>('glVertex2xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xOES(x: fixed) := z_Vertex2xOES(x);
    
    public z_Vertex3xOES := GetGLFuncOrNil&<procedure(x: fixed; y: fixed)>('glVertex3xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xOES(x: fixed; y: fixed) := z_Vertex3xOES(x, y);
    
    public z_Vertex4xOES := GetGLFuncOrNil&<procedure(x: fixed; y: fixed; z: fixed)>('glVertex4xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xOES(x: fixed; y: fixed; z: fixed) := z_Vertex4xOES(x, y, z);
    
    public z_Vertex2xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glVertex2xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(coords: array of fixed) := Vertex2xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(var coords: fixed) := Vertex2xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(coords: pointer) := z_Vertex2xvOES(coords);
    
    public z_Vertex3xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glVertex3xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(coords: array of fixed) := Vertex3xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(var coords: fixed) := Vertex3xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(coords: pointer) := z_Vertex3xvOES(coords);
    
    public z_Vertex4xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glVertex4xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(coords: array of fixed) := Vertex4xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(var coords: fixed) := Vertex4xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(coords: pointer) := z_Vertex4xvOES(coords);
    
    public z_Normal3xOES := GetGLFuncOrNil&<procedure(nx: fixed; ny: fixed; nz: fixed)>('glNormal3xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xOES(nx: fixed; ny: fixed; nz: fixed) := z_Normal3xOES(nx, ny, nz);
    
    public z_Normal3xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glNormal3xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(coords: array of fixed) := Normal3xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(var coords: fixed) := Normal3xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(coords: pointer) := z_Normal3xvOES(coords);
    
    public z_TexCoord1xOES := GetGLFuncOrNil&<procedure(s: fixed)>('glTexCoord1xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xOES(s: fixed) := z_TexCoord1xOES(s);
    
    public z_TexCoord2xOES := GetGLFuncOrNil&<procedure(s: fixed; t: fixed)>('glTexCoord2xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xOES(s: fixed; t: fixed) := z_TexCoord2xOES(s, t);
    
    public z_TexCoord3xOES := GetGLFuncOrNil&<procedure(s: fixed; t: fixed; r: fixed)>('glTexCoord3xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xOES(s: fixed; t: fixed; r: fixed) := z_TexCoord3xOES(s, t, r);
    
    public z_TexCoord4xOES := GetGLFuncOrNil&<procedure(s: fixed; t: fixed; r: fixed; q: fixed)>('glTexCoord4xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xOES(s: fixed; t: fixed; r: fixed; q: fixed) := z_TexCoord4xOES(s, t, r, q);
    
    public z_TexCoord1xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glTexCoord1xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(coords: array of fixed) := TexCoord1xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(var coords: fixed) := TexCoord1xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(coords: pointer) := z_TexCoord1xvOES(coords);
    
    public z_TexCoord2xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glTexCoord2xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(coords: array of fixed) := TexCoord2xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(var coords: fixed) := TexCoord2xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(coords: pointer) := z_TexCoord2xvOES(coords);
    
    public z_TexCoord3xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glTexCoord3xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(coords: array of fixed) := TexCoord3xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(var coords: fixed) := TexCoord3xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(coords: pointer) := z_TexCoord3xvOES(coords);
    
    public z_TexCoord4xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glTexCoord4xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(coords: array of fixed) := TexCoord4xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(var coords: fixed) := TexCoord4xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(coords: pointer) := z_TexCoord4xvOES(coords);
    
    public z_MultiTexCoord1xOES := GetGLFuncOrNil&<procedure(texture: DummyEnum; s: fixed)>('glMultiTexCoord1xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xOES(texture: DummyEnum; s: fixed) := z_MultiTexCoord1xOES(texture, s);
    
    public z_MultiTexCoord2xOES := GetGLFuncOrNil&<procedure(texture: DummyEnum; s: fixed; t: fixed)>('glMultiTexCoord2xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xOES(texture: DummyEnum; s: fixed; t: fixed) := z_MultiTexCoord2xOES(texture, s, t);
    
    public z_MultiTexCoord3xOES := GetGLFuncOrNil&<procedure(texture: DummyEnum; s: fixed; t: fixed; r: fixed)>('glMultiTexCoord3xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xOES(texture: DummyEnum; s: fixed; t: fixed; r: fixed) := z_MultiTexCoord3xOES(texture, s, t, r);
    
    public z_MultiTexCoord4xOES := GetGLFuncOrNil&<procedure(texture: DummyEnum; s: fixed; t: fixed; r: fixed; q: fixed)>('glMultiTexCoord4xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xOES(texture: DummyEnum; s: fixed; t: fixed; r: fixed; q: fixed) := z_MultiTexCoord4xOES(texture, s, t, r, q);
    
    public z_MultiTexCoord1xvOES := GetGLFuncOrNil&<procedure(texture: DummyEnum; coords: pointer)>('glMultiTexCoord1xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: DummyEnum; coords: array of fixed) := MultiTexCoord1xvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: DummyEnum; var coords: fixed) := MultiTexCoord1xvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord1xvOES(texture, coords);
    
    public z_MultiTexCoord2xvOES := GetGLFuncOrNil&<procedure(texture: DummyEnum; coords: pointer)>('glMultiTexCoord2xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: DummyEnum; coords: array of fixed) := MultiTexCoord2xvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: DummyEnum; var coords: fixed) := MultiTexCoord2xvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord2xvOES(texture, coords);
    
    public z_MultiTexCoord3xvOES := GetGLFuncOrNil&<procedure(texture: DummyEnum; coords: pointer)>('glMultiTexCoord3xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: DummyEnum; coords: array of fixed) := MultiTexCoord3xvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: DummyEnum; var coords: fixed) := MultiTexCoord3xvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord3xvOES(texture, coords);
    
    public z_MultiTexCoord4xvOES := GetGLFuncOrNil&<procedure(texture: DummyEnum; coords: pointer)>('glMultiTexCoord4xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: DummyEnum; coords: array of fixed) := MultiTexCoord4xvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: DummyEnum; var coords: fixed) := MultiTexCoord4xvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord4xvOES(texture, coords);
    
    public z_Color3xOES := GetGLFuncOrNil&<procedure(red: fixed; green: fixed; blue: fixed)>('glColor3xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xOES(red: fixed; green: fixed; blue: fixed) := z_Color3xOES(red, green, blue);
    
    public z_Color4xOES := GetGLFuncOrNil&<procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed)>('glColor4xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xOES(red: fixed; green: fixed; blue: fixed; alpha: fixed) := z_Color4xOES(red, green, blue, alpha);
    
    public z_Color3xvOES := GetGLFuncOrNil&<procedure(components: pointer)>('glColor3xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(components: array of fixed) := Color3xvOES(components[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(var components: fixed) := Color3xvOES(@components);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(components: pointer) := z_Color3xvOES(components);
    
    public z_Color4xvOES := GetGLFuncOrNil&<procedure(components: pointer)>('glColor4xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(components: array of fixed) := Color4xvOES(components[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(var components: fixed) := Color4xvOES(@components);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(components: pointer) := z_Color4xvOES(components);
    
    public z_IndexxOES := GetGLFuncOrNil&<procedure(component: fixed)>('glIndexxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxOES(component: fixed) := z_IndexxOES(component);
    
    public z_IndexxvOES := GetGLFuncOrNil&<procedure(component: pointer)>('glIndexxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(component: array of fixed) := IndexxvOES(component[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(var component: fixed) := IndexxvOES(@component);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(component: pointer) := z_IndexxvOES(component);
    
    public z_RectxOES := GetGLFuncOrNil&<procedure(x1: fixed; y1: fixed; x2: fixed; y2: fixed)>('glRectxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxOES(x1: fixed; y1: fixed; x2: fixed; y2: fixed) := z_RectxOES(x1, y1, x2, y2);
    
    public z_RectxvOES := GetGLFuncOrNil&<procedure(v1: pointer; v2: pointer)>('glRectxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: array of fixed; v2: array of fixed) := RectxvOES(v1[0], v2[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: array of fixed; var v2: fixed) := RectxvOES(v1[0], @v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: array of fixed; v2: pointer) := RectxvOES(v1[0], v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(var v1: fixed; v2: array of fixed) := RectxvOES(@v1, v2[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(var v1: fixed; var v2: fixed) := RectxvOES(@v1, @v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(var v1: fixed; v2: pointer) := RectxvOES(@v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: pointer; v2: array of fixed) := RectxvOES(v1, v2[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: pointer; var v2: fixed) := RectxvOES(v1, @v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: pointer; v2: pointer) := z_RectxvOES(v1, v2);
    
    public z_DepthRangexOES := GetGLFuncOrNil&<procedure(n: fixed; f: fixed)>('glDepthRangexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangexOES(n: fixed; f: fixed) := z_DepthRangexOES(n, f);
    
    public z_LoadMatrixxOES := GetGLFuncOrNil&<procedure(m: pointer)>('glLoadMatrixxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(m: array of fixed) := LoadMatrixxOES(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(var m: fixed) := LoadMatrixxOES(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(m: pointer) := z_LoadMatrixxOES(m);
    
    public z_MultMatrixxOES := GetGLFuncOrNil&<procedure(m: pointer)>('glMultMatrixxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(m: array of fixed) := MultMatrixxOES(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(var m: fixed) := MultMatrixxOES(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(m: pointer) := z_MultMatrixxOES(m);
    
    public z_LoadTransposeMatrixxOES := GetGLFuncOrNil&<procedure(m: pointer)>('glLoadTransposeMatrixxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(m: array of fixed) := LoadTransposeMatrixxOES(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(var m: fixed) := LoadTransposeMatrixxOES(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(m: pointer) := z_LoadTransposeMatrixxOES(m);
    
    public z_MultTransposeMatrixxOES := GetGLFuncOrNil&<procedure(m: pointer)>('glMultTransposeMatrixxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(m: array of fixed) := MultTransposeMatrixxOES(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(var m: fixed) := MultTransposeMatrixxOES(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(m: pointer) := z_MultTransposeMatrixxOES(m);
    
    public z_RotatexOES := GetGLFuncOrNil&<procedure(angle: fixed; x: fixed; y: fixed; z: fixed)>('glRotatexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RotatexOES(angle: fixed; x: fixed; y: fixed; z: fixed) := z_RotatexOES(angle, x, y, z);
    
    public z_ScalexOES := GetGLFuncOrNil&<procedure(x: fixed; y: fixed; z: fixed)>('glScalexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScalexOES(x: fixed; y: fixed; z: fixed) := z_ScalexOES(x, y, z);
    
    public z_TranslatexOES := GetGLFuncOrNil&<procedure(x: fixed; y: fixed; z: fixed)>('glTranslatexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TranslatexOES(x: fixed; y: fixed; z: fixed) := z_TranslatexOES(x, y, z);
    
    public z_FrustumxOES := GetGLFuncOrNil&<procedure(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed)>('glFrustumxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrustumxOES(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed) := z_FrustumxOES(l, r, b, t, n, f);
    
    public z_OrthoxOES := GetGLFuncOrNil&<procedure(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed)>('glOrthoxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure OrthoxOES(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed) := z_OrthoxOES(l, r, b, t, n, f);
    
    public z_ClipPlanexOES := GetGLFuncOrNil&<procedure(plane: DummyEnum; equation: pointer)>('glClipPlanexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: DummyEnum; equation: array of fixed) := ClipPlanexOES(plane, equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: DummyEnum; var equation: fixed) := ClipPlanexOES(plane, @equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: DummyEnum; equation: pointer) := z_ClipPlanexOES(plane, equation);
    
    public z_GetClipPlanexOES := GetGLFuncOrNil&<procedure(plane: DummyEnum; equation: pointer)>('glGetClipPlanexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanexOES(plane: DummyEnum; equation: array of fixed) := GetClipPlanexOES(plane, equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanexOES(plane: DummyEnum; var equation: fixed) := GetClipPlanexOES(plane, @equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanexOES(plane: DummyEnum; equation: pointer) := z_GetClipPlanexOES(plane, equation);
    
    public z_RasterPos2xOES := GetGLFuncOrNil&<procedure(x: fixed; y: fixed)>('glRasterPos2xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xOES(x: fixed; y: fixed) := z_RasterPos2xOES(x, y);
    
    public z_RasterPos3xOES := GetGLFuncOrNil&<procedure(x: fixed; y: fixed; z: fixed)>('glRasterPos3xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xOES(x: fixed; y: fixed; z: fixed) := z_RasterPos3xOES(x, y, z);
    
    public z_RasterPos4xOES := GetGLFuncOrNil&<procedure(x: fixed; y: fixed; z: fixed; w: fixed)>('glRasterPos4xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xOES(x: fixed; y: fixed; z: fixed; w: fixed) := z_RasterPos4xOES(x, y, z, w);
    
    public z_RasterPos2xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glRasterPos2xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(coords: array of fixed) := RasterPos2xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(var coords: fixed) := RasterPos2xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(coords: pointer) := z_RasterPos2xvOES(coords);
    
    public z_RasterPos3xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glRasterPos3xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(coords: array of fixed) := RasterPos3xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(var coords: fixed) := RasterPos3xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(coords: pointer) := z_RasterPos3xvOES(coords);
    
    public z_RasterPos4xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glRasterPos4xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(coords: array of fixed) := RasterPos4xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(var coords: fixed) := RasterPos4xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(coords: pointer) := z_RasterPos4xvOES(coords);
    
    public z_MaterialxOES := GetGLFuncOrNil&<procedure(face: DummyEnum; pname: DummyEnum; param: fixed)>('glMaterialxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxOES(face: DummyEnum; pname: DummyEnum; param: fixed) := z_MaterialxOES(face, pname, param);
    
    public z_MaterialxvOES := GetGLFuncOrNil&<procedure(face: DummyEnum; pname: DummyEnum; param: pointer)>('glMaterialxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: DummyEnum; pname: DummyEnum; param: array of fixed) := MaterialxvOES(face, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: DummyEnum; pname: DummyEnum; var param: fixed) := MaterialxvOES(face, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: DummyEnum; pname: DummyEnum; param: pointer) := z_MaterialxvOES(face, pname, param);
    
    public z_GetMaterialxOES := GetGLFuncOrNil&<procedure(face: DummyEnum; pname: DummyEnum; param: fixed)>('glGetMaterialxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialxOES(face: DummyEnum; pname: DummyEnum; param: fixed) := z_GetMaterialxOES(face, pname, param);
    
    public z_LightxOES := GetGLFuncOrNil&<procedure(light: DummyEnum; pname: DummyEnum; param: fixed)>('glLightxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxOES(light: DummyEnum; pname: DummyEnum; param: fixed) := z_LightxOES(light, pname, param);
    
    public z_LightxvOES := GetGLFuncOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>('glLightxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: DummyEnum; pname: DummyEnum; &params: array of fixed) := LightxvOES(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: DummyEnum; pname: DummyEnum; var &params: fixed) := LightxvOES(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_LightxvOES(light, pname, &params);
    
    public z_GetLightxOES := GetGLFuncOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetLightxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxOES(light: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetLightxOES(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxOES(light: DummyEnum; pname: DummyEnum; var &params: fixed) := GetLightxOES(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxOES(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetLightxOES(light, pname, &params);
    
    public z_LightModelxOES := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: fixed)>('glLightModelxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxOES(pname: DummyEnum; param: fixed) := z_LightModelxOES(pname, param);
    
    public z_LightModelxvOES := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: pointer)>('glLightModelxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: DummyEnum; param: array of fixed) := LightModelxvOES(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: DummyEnum; var param: fixed) := LightModelxvOES(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: DummyEnum; param: pointer) := z_LightModelxvOES(pname, param);
    
    public z_PointSizexOES := GetGLFuncOrNil&<procedure(size: fixed)>('glPointSizexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointSizexOES(size: fixed) := z_PointSizexOES(size);
    
    public z_PointParameterxvOES := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glPointParameterxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: DummyEnum; &params: array of fixed) := PointParameterxvOES(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: DummyEnum; var &params: fixed) := PointParameterxvOES(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: DummyEnum; &params: pointer) := z_PointParameterxvOES(pname, &params);
    
    public z_LineWidthxOES := GetGLFuncOrNil&<procedure(width: fixed)>('glLineWidthxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineWidthxOES(width: fixed) := z_LineWidthxOES(width);
    
    public z_PolygonOffsetxOES := GetGLFuncOrNil&<procedure(factor: fixed; units: fixed)>('glPolygonOffsetxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetxOES(factor: fixed; units: fixed) := z_PolygonOffsetxOES(factor, units);
    
    public z_PixelTransferxOES := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: fixed)>('glPixelTransferxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransferxOES(pname: DummyEnum; param: fixed) := z_PixelTransferxOES(pname, param);
    
    public z_ConvolutionParameterxOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: fixed)>('glConvolutionParameterxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxOES(target: DummyEnum; pname: DummyEnum; param: fixed) := z_ConvolutionParameterxOES(target, pname, param);
    
    public z_ConvolutionParameterxvOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glConvolutionParameterxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := ConvolutionParameterxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := ConvolutionParameterxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ConvolutionParameterxvOES(target, pname, &params);
    
    public z_GetConvolutionParameterxvOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetConvolutionParameterxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetConvolutionParameterxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := GetConvolutionParameterxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetConvolutionParameterxvOES(target, pname, &params);
    
    public z_GetHistogramParameterxvOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetHistogramParameterxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetHistogramParameterxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := GetHistogramParameterxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetHistogramParameterxvOES(target, pname, &params);
    
    public z_PixelZoomxOES := GetGLFuncOrNil&<procedure(xfactor: fixed; yfactor: fixed)>('glPixelZoomxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelZoomxOES(xfactor: fixed; yfactor: fixed) := z_PixelZoomxOES(xfactor, yfactor);
    
    public z_BitmapxOES := GetGLFuncOrNil&<procedure(width: Int32; height: Int32; xorig: fixed; yorig: fixed; xmove: fixed; ymove: fixed; bitmap: pointer)>('glBitmapxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: fixed; yorig: fixed; xmove: fixed; ymove: fixed; bitmap: array of Byte) := BitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: fixed; yorig: fixed; xmove: fixed; ymove: fixed; var bitmap: Byte) := BitmapxOES(width, height, xorig, yorig, xmove, ymove, @bitmap);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: fixed; yorig: fixed; xmove: fixed; ymove: fixed; bitmap: pointer) := z_BitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap);
    
    public z_TexParameterxOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: fixed)>('glTexParameterxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxOES(target: DummyEnum; pname: DummyEnum; param: fixed) := z_TexParameterxOES(target, pname, param);
    
    public z_TexParameterxvOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTexParameterxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := TexParameterxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := TexParameterxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexParameterxvOES(target, pname, &params);
    
    public z_GetTexParameterxvOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexParameterxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetTexParameterxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := GetTexParameterxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexParameterxvOES(target, pname, &params);
    
    public z_GetTexLevelParameterxvOES := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer)>('glGetTexLevelParameterxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterxvOES(target: DummyEnum; level: Int32; pname: DummyEnum; &params: array of fixed) := GetTexLevelParameterxvOES(target, level, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterxvOES(target: DummyEnum; level: Int32; pname: DummyEnum; var &params: fixed) := GetTexLevelParameterxvOES(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterxvOES(target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := z_GetTexLevelParameterxvOES(target, level, pname, &params);
    
    public z_PrioritizeTexturesxOES := GetGLFuncOrNil&<procedure(n: Int32; textures: pointer; priorities: pointer)>('glPrioritizeTexturesxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: array of UInt32; priorities: array of fixed) := PrioritizeTexturesxOES(n, textures[0], priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: array of UInt32; var priorities: fixed) := PrioritizeTexturesxOES(n, textures[0], @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: array of UInt32; priorities: pointer) := PrioritizeTexturesxOES(n, textures[0], priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; var textures: UInt32; priorities: array of fixed) := PrioritizeTexturesxOES(n, @textures, priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; var textures: UInt32; var priorities: fixed) := PrioritizeTexturesxOES(n, @textures, @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; var textures: UInt32; priorities: pointer) := PrioritizeTexturesxOES(n, @textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: pointer; priorities: array of fixed) := PrioritizeTexturesxOES(n, textures, priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: pointer; var priorities: fixed) := PrioritizeTexturesxOES(n, textures, @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: pointer; priorities: pointer) := z_PrioritizeTexturesxOES(n, textures, priorities);
    
    public z_TexEnvxOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: fixed)>('glTexEnvxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxOES(target: DummyEnum; pname: DummyEnum; param: fixed) := z_TexEnvxOES(target, pname, param);
    
    public z_TexEnvxvOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTexEnvxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := TexEnvxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := TexEnvxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexEnvxvOES(target, pname, &params);
    
    public z_GetTexEnvxvOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexEnvxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetTexEnvxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := GetTexEnvxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexEnvxvOES(target, pname, &params);
    
    public z_FogxOES := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: fixed)>('glFogxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxOES(pname: DummyEnum; param: fixed) := z_FogxOES(pname, param);
    
    public z_FogxvOES := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: pointer)>('glFogxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: DummyEnum; param: array of fixed) := FogxvOES(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: DummyEnum; var param: fixed) := FogxvOES(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: DummyEnum; param: pointer) := z_FogxvOES(pname, param);
    
    public z_SampleCoveragexOES := GetGLFuncOrNil&<procedure(value: Int32; invert: boolean)>('glSampleCoveragexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleCoveragexOES(value: Int32; invert: boolean) := z_SampleCoveragexOES(value, invert);
    
    public z_AlphaFuncxOES := GetGLFuncOrNil&<procedure(func: DummyEnum; ref: fixed)>('glAlphaFuncxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFuncxOES(func: DummyEnum; ref: fixed) := z_AlphaFuncxOES(func, ref);
    
    public z_BlendColorxOES := GetGLFuncOrNil&<procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed)>('glBlendColorxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColorxOES(red: fixed; green: fixed; blue: fixed; alpha: fixed) := z_BlendColorxOES(red, green, blue, alpha);
    
    public z_ClearColorxOES := GetGLFuncOrNil&<procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed)>('glClearColorxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorxOES(red: fixed; green: fixed; blue: fixed; alpha: fixed) := z_ClearColorxOES(red, green, blue, alpha);
    
    public z_ClearDepthxOES := GetGLFuncOrNil&<procedure(depth: fixed)>('glClearDepthxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthxOES(depth: fixed) := z_ClearDepthxOES(depth);
    
    public z_ClearAccumxOES := GetGLFuncOrNil&<procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed)>('glClearAccumxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearAccumxOES(red: fixed; green: fixed; blue: fixed; alpha: fixed) := z_ClearAccumxOES(red, green, blue, alpha);
    
    public z_AccumxOES := GetGLFuncOrNil&<procedure(op: DummyEnum; value: fixed)>('glAccumxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AccumxOES(op: DummyEnum; value: fixed) := z_AccumxOES(op, value);
    
    public z_Map1xOES := GetGLFuncOrNil&<procedure(target: DummyEnum; u1: fixed; u2: fixed; stride: Int32; order: Int32; points: fixed)>('glMap1xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1xOES(target: DummyEnum; u1: fixed; u2: fixed; stride: Int32; order: Int32; points: fixed) := z_Map1xOES(target, u1, u2, stride, order, points);
    
    public z_Map2xOES := GetGLFuncOrNil&<procedure(target: DummyEnum; u1: fixed; u2: fixed; ustride: Int32; uorder: Int32; v1: fixed; v2: fixed; vstride: Int32; vorder: Int32; points: fixed)>('glMap2xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2xOES(target: DummyEnum; u1: fixed; u2: fixed; ustride: Int32; uorder: Int32; v1: fixed; v2: fixed; vstride: Int32; vorder: Int32; points: fixed) := z_Map2xOES(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    public z_MapGrid1xOES := GetGLFuncOrNil&<procedure(n: Int32; u1: fixed; u2: fixed)>('glMapGrid1xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid1xOES(n: Int32; u1: fixed; u2: fixed) := z_MapGrid1xOES(n, u1, u2);
    
    public z_MapGrid2xOES := GetGLFuncOrNil&<procedure(n: Int32; u1: fixed; u2: fixed; v1: fixed; v2: fixed)>('glMapGrid2xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid2xOES(n: Int32; u1: fixed; u2: fixed; v1: fixed; v2: fixed) := z_MapGrid2xOES(n, u1, u2, v1, v2);
    
    public z_GetMapxvOES := GetGLFuncOrNil&<procedure(target: DummyEnum; query: DummyEnum; v: pointer)>('glGetMapxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapxvOES(target: DummyEnum; query: DummyEnum; v: array of fixed) := GetMapxvOES(target, query, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapxvOES(target: DummyEnum; query: DummyEnum; var v: fixed) := GetMapxvOES(target, query, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapxvOES(target: DummyEnum; query: DummyEnum; v: pointer) := z_GetMapxvOES(target, query, v);
    
    public z_EvalCoord1xOES := GetGLFuncOrNil&<procedure(u: fixed)>('glEvalCoord1xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xOES(u: fixed) := z_EvalCoord1xOES(u);
    
    public z_EvalCoord2xOES := GetGLFuncOrNil&<procedure(u: fixed; v: fixed)>('glEvalCoord2xOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xOES(u: fixed; v: fixed) := z_EvalCoord2xOES(u, v);
    
    public z_EvalCoord1xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glEvalCoord1xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(coords: array of fixed) := EvalCoord1xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(var coords: fixed) := EvalCoord1xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(coords: pointer) := z_EvalCoord1xvOES(coords);
    
    public z_EvalCoord2xvOES := GetGLFuncOrNil&<procedure(coords: pointer)>('glEvalCoord2xvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(coords: array of fixed) := EvalCoord2xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(var coords: fixed) := EvalCoord2xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(coords: pointer) := z_EvalCoord2xvOES(coords);
    
    public z_FeedbackBufferxOES := GetGLFuncOrNil&<procedure(n: Int32; &type: DummyEnum; buffer: pointer)>('glFeedbackBufferxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; buffer: array of fixed) := FeedbackBufferxOES(n, &type, buffer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; var buffer: fixed) := FeedbackBufferxOES(n, &type, @buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; buffer: pointer) := z_FeedbackBufferxOES(n, &type, buffer);
    
    public z_PassThroughxOES := GetGLFuncOrNil&<procedure(token: fixed)>('glPassThroughxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassThroughxOES(token: fixed) := z_PassThroughxOES(token);
    
    public z_GetFixedvOES := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glGetFixedvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFixedvOES(pname: DummyEnum; &params: array of fixed) := GetFixedvOES(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFixedvOES(pname: DummyEnum; var &params: fixed) := GetFixedvOES(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFixedvOES(pname: DummyEnum; &params: pointer) := z_GetFixedvOES(pname, &params);
    
    {$endregion OES_fixed_point}
    
    {$region OES_framebuffer_object}
    
    public z_IsRenderbufferOES := GetGLFuncOrNil&<function(renderbuffer: UInt32): boolean>('glIsRenderbufferOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsRenderbufferOES(renderbuffer: UInt32): boolean := z_IsRenderbufferOES(renderbuffer);
    
    public z_BindRenderbufferOES := GetGLFuncOrNil&<procedure(target: DummyEnum; renderbuffer: UInt32)>('glBindRenderbufferOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindRenderbufferOES(target: DummyEnum; renderbuffer: UInt32) := z_BindRenderbufferOES(target, renderbuffer);
    
    public z_DeleteRenderbuffersOES := GetGLFuncOrNil&<procedure(n: Int32; renderbuffers: pointer)>('glDeleteRenderbuffersOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersOES(n: Int32; renderbuffers: array of UInt32) := DeleteRenderbuffersOES(n, renderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersOES(n: Int32; var renderbuffers: UInt32) := DeleteRenderbuffersOES(n, @renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteRenderbuffersOES(n: Int32; renderbuffers: pointer) := z_DeleteRenderbuffersOES(n, renderbuffers);
    
    public z_GenRenderbuffersOES := GetGLFuncOrNil&<procedure(n: Int32; renderbuffers: pointer)>('glGenRenderbuffersOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersOES(n: Int32; renderbuffers: array of UInt32) := GenRenderbuffersOES(n, renderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersOES(n: Int32; var renderbuffers: UInt32) := GenRenderbuffersOES(n, @renderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenRenderbuffersOES(n: Int32; renderbuffers: pointer) := z_GenRenderbuffersOES(n, renderbuffers);
    
    public z_RenderbufferStorageOES := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32)>('glRenderbufferStorageOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageOES(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageOES(target, internalformat, width, height);
    
    public z_GetRenderbufferParameterivOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetRenderbufferParameterivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameterivOES(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetRenderbufferParameterivOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameterivOES(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetRenderbufferParameterivOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetRenderbufferParameterivOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetRenderbufferParameterivOES(target, pname, &params);
    
    public z_IsFramebufferOES := GetGLFuncOrNil&<function(framebuffer: UInt32): boolean>('glIsFramebufferOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFramebufferOES(framebuffer: UInt32): boolean := z_IsFramebufferOES(framebuffer);
    
    public z_BindFramebufferOES := GetGLFuncOrNil&<procedure(target: DummyEnum; framebuffer: UInt32)>('glBindFramebufferOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFramebufferOES(target: DummyEnum; framebuffer: UInt32) := z_BindFramebufferOES(target, framebuffer);
    
    public z_DeleteFramebuffersOES := GetGLFuncOrNil&<procedure(n: Int32; framebuffers: pointer)>('glDeleteFramebuffersOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersOES(n: Int32; framebuffers: array of UInt32) := DeleteFramebuffersOES(n, framebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersOES(n: Int32; var framebuffers: UInt32) := DeleteFramebuffersOES(n, @framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFramebuffersOES(n: Int32; framebuffers: pointer) := z_DeleteFramebuffersOES(n, framebuffers);
    
    public z_GenFramebuffersOES := GetGLFuncOrNil&<procedure(n: Int32; framebuffers: pointer)>('glGenFramebuffersOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersOES(n: Int32; framebuffers: array of UInt32) := GenFramebuffersOES(n, framebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersOES(n: Int32; var framebuffers: UInt32) := GenFramebuffersOES(n, @framebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFramebuffersOES(n: Int32; framebuffers: pointer) := z_GenFramebuffersOES(n, framebuffers);
    
    public z_CheckFramebufferStatusOES := GetGLFuncOrNil&<function(target: DummyEnum): DummyEnum>('glCheckFramebufferStatusOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CheckFramebufferStatusOES(target: DummyEnum): DummyEnum := z_CheckFramebufferStatusOES(target);
    
    public z_FramebufferTexture2DOES := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32)>('glFramebufferTexture2DOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2DOES(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32) := z_FramebufferTexture2DOES(target, attachment, textarget, texture, level);
    
    public z_FramebufferRenderbufferOES := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; renderbuffertarget: DummyEnum; renderbuffer: UInt32)>('glFramebufferRenderbufferOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferRenderbufferOES(target: DummyEnum; attachment: DummyEnum; renderbuffertarget: DummyEnum; renderbuffer: UInt32) := z_FramebufferRenderbufferOES(target, attachment, renderbuffertarget, renderbuffer);
    
    public z_GetFramebufferAttachmentParameterivOES := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetFramebufferAttachmentParameterivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameterivOES(target: DummyEnum; attachment: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetFramebufferAttachmentParameterivOES(target, attachment, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameterivOES(target: DummyEnum; attachment: DummyEnum; pname: DummyEnum; var &params: Int32) := GetFramebufferAttachmentParameterivOES(target, attachment, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferAttachmentParameterivOES(target: DummyEnum; attachment: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetFramebufferAttachmentParameterivOES(target, attachment, pname, &params);
    
    public z_GenerateMipmapOES := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glGenerateMipmapOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMipmapOES(target: DummyEnum) := z_GenerateMipmapOES(target);
    
    {$endregion OES_framebuffer_object}
    
    {$region OES_vertex_array_object}
    
    public z_BindVertexArrayOES := GetGLFuncOrNil&<procedure(&array: UInt32)>('glBindVertexArrayOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexArrayOES(&array: UInt32) := z_BindVertexArrayOES(&array);
    
    public z_DeleteVertexArraysOES := GetGLFuncOrNil&<procedure(n: Int32; arrays: pointer)>('glDeleteVertexArraysOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysOES(n: Int32; arrays: array of UInt32) := DeleteVertexArraysOES(n, arrays[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysOES(n: Int32; var arrays: UInt32) := DeleteVertexArraysOES(n, @arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexArraysOES(n: Int32; arrays: pointer) := z_DeleteVertexArraysOES(n, arrays);
    
    public z_GenVertexArraysOES := GetGLFuncOrNil&<procedure(n: Int32; arrays: pointer)>('glGenVertexArraysOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysOES(n: Int32; arrays: array of UInt32) := GenVertexArraysOES(n, arrays[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysOES(n: Int32; var arrays: UInt32) := GenVertexArraysOES(n, @arrays);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenVertexArraysOES(n: Int32; arrays: pointer) := z_GenVertexArraysOES(n, arrays);
    
    public z_IsVertexArrayOES := GetGLFuncOrNil&<function(&array: UInt32): boolean>('glIsVertexArrayOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexArrayOES(&array: UInt32): boolean := z_IsVertexArrayOES(&array);
    
    {$endregion OES_vertex_array_object}
    
    {$region OES_draw_buffers_indexed}
    
    public z_BlendEquationiOES := GetGLFuncOrNil&<procedure(buf: UInt32; mode: DummyEnum)>('glBlendEquationiOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationiOES(buf: UInt32; mode: DummyEnum) := z_BlendEquationiOES(buf, mode);
    
    public z_BlendEquationSeparateiOES := GetGLFuncOrNil&<procedure(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum)>('glBlendEquationSeparateiOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateiOES(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum) := z_BlendEquationSeparateiOES(buf, modeRGB, modeAlpha);
    
    public z_BlendFunciOES := GetGLFuncOrNil&<procedure(buf: UInt32; src: DummyEnum; dst: DummyEnum)>('glBlendFunciOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFunciOES(buf: UInt32; src: DummyEnum; dst: DummyEnum) := z_BlendFunciOES(buf, src, dst);
    
    public z_BlendFuncSeparateiOES := GetGLFuncOrNil&<procedure(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum)>('glBlendFuncSeparateiOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateiOES(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum) := z_BlendFuncSeparateiOES(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    public z_ColorMaskiOES := GetGLFuncOrNil&<procedure(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean)>('glColorMaskiOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaskiOES(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean) := z_ColorMaskiOES(index, r, g, b, a);
    
    {$endregion OES_draw_buffers_indexed}
    
    {$region OES_blend_subtract}
    
    public z_BlendEquationOES := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glBlendEquationOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationOES(mode: DummyEnum) := z_BlendEquationOES(mode);
    
    {$endregion OES_blend_subtract}
    
    {$region OES_blend_equation_separate}
    
    public z_BlendEquationSeparateOES := GetGLFuncOrNil&<procedure(modeRGB: DummyEnum; modeAlpha: DummyEnum)>('glBlendEquationSeparateOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateOES(modeRGB: DummyEnum; modeAlpha: DummyEnum) := z_BlendEquationSeparateOES(modeRGB, modeAlpha);
    
    {$endregion OES_blend_equation_separate}
    
    {$region OES_blend_func_separate}
    
    public z_BlendFuncSeparateOES := GetGLFuncOrNil&<procedure(srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum)>('glBlendFuncSeparateOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateOES(srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum) := z_BlendFuncSeparateOES(srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    {$endregion OES_blend_func_separate}
    
    {$region OES_single_precision}
    
    public z_DepthRangefOES := GetGLFuncOrNil&<procedure(n: single; f: single)>('glDepthRangefOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangefOES(n: single; f: single) := z_DepthRangefOES(n, f);
    
    public z_FrustumfOES := GetGLFuncOrNil&<procedure(l: single; r: single; b: single; t: single; n: single; f: single)>('glFrustumfOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrustumfOES(l: single; r: single; b: single; t: single; n: single; f: single) := z_FrustumfOES(l, r, b, t, n, f);
    
    public z_OrthofOES := GetGLFuncOrNil&<procedure(l: single; r: single; b: single; t: single; n: single; f: single)>('glOrthofOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure OrthofOES(l: single; r: single; b: single; t: single; n: single; f: single) := z_OrthofOES(l, r, b, t, n, f);
    
    public z_ClipPlanefOES := GetGLFuncOrNil&<procedure(plane: DummyEnum; equation: pointer)>('glClipPlanefOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: DummyEnum; equation: array of single) := ClipPlanefOES(plane, equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: DummyEnum; var equation: single) := ClipPlanefOES(plane, @equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: DummyEnum; equation: pointer) := z_ClipPlanefOES(plane, equation);
    
    public z_GetClipPlanefOES := GetGLFuncOrNil&<procedure(plane: DummyEnum; equation: pointer)>('glGetClipPlanefOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanefOES(plane: DummyEnum; equation: array of single) := GetClipPlanefOES(plane, equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanefOES(plane: DummyEnum; var equation: single) := GetClipPlanefOES(plane, @equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanefOES(plane: DummyEnum; equation: pointer) := z_GetClipPlanefOES(plane, equation);
    
    public z_ClearDepthfOES := GetGLFuncOrNil&<procedure(depth: single)>('glClearDepthfOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthfOES(depth: single) := z_ClearDepthfOES(depth);
    
    {$endregion OES_single_precision}
    
    {$region OES_texture_3D}
    
    public z_TexImage3DOES := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTexImage3DOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DOES(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TexImage3DOES(target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    public z_TexSubImage3DOES := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>('glTexSubImage3DOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage3DOES(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    public z_CopyTexSubImage3DOES := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>('glCopyTexSubImage3DOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTexSubImage3DOES(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    public z_CompressedTexImage3DOES := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: pointer)>('glCompressedTexImage3DOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexImage3DOES(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: pointer) := z_CompressedTexImage3DOES(target, level, internalformat, width, height, depth, border, imageSize, data);
    
    public z_CompressedTexSubImage3DOES := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; data: pointer)>('glCompressedTexSubImage3DOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTexSubImage3DOES(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; data: pointer) := z_CompressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
    
    public z_FramebufferTexture3DOES := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; zoffset: Int32)>('glFramebufferTexture3DOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture3DOES(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; zoffset: Int32) := z_FramebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset);
    
    {$endregion OES_texture_3D}
    
    {$region OES_copy_image}
    
    public z_CopyImageSubDataOES := GetGLFuncOrNil&<procedure(srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>('glCopyImageSubDataOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubDataOES(srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) := z_CopyImageSubDataOES(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
    {$endregion OES_copy_image}
    
    {$region OES_matrix_palette}
    
    public z_CurrentPaletteMatrixOES := GetGLFuncOrNil&<procedure(matrixpaletteindex: UInt32)>('glCurrentPaletteMatrixOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CurrentPaletteMatrixOES(matrixpaletteindex: UInt32) := z_CurrentPaletteMatrixOES(matrixpaletteindex);
    
    public z_LoadPaletteFromModelViewMatrixOES := GetGLFuncOrNil&<procedure>('glLoadPaletteFromModelViewMatrixOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadPaletteFromModelViewMatrixOES := z_LoadPaletteFromModelViewMatrixOES;
    
    public z_MatrixIndexPointerOES := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glMatrixIndexPointerOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexPointerOES(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_MatrixIndexPointerOES(size, &type, stride, _pointer);
    
    public z_WeightPointerOES := GetGLFuncOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>('glWeightPointerOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPointerOES(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_WeightPointerOES(size, &type, stride, _pointer);
    
    {$endregion OES_matrix_palette}
    
    {$region OES_viewport_array}
    
    public z_ViewportArrayvOES := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>('glViewportArrayvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayvOES(first: UInt32; count: Int32; v: array of single) := ViewportArrayvOES(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayvOES(first: UInt32; count: Int32; var v: single) := ViewportArrayvOES(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportArrayvOES(first: UInt32; count: Int32; v: pointer) := z_ViewportArrayvOES(first, count, v);
    
    public z_ViewportIndexedfOES := GetGLFuncOrNil&<procedure(index: UInt32; x: single; y: single; w: single; h: single)>('glViewportIndexedfOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfOES(index: UInt32; x: single; y: single; w: single; h: single) := z_ViewportIndexedfOES(index, x, y, w, h);
    
    public z_ViewportIndexedfvOES := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glViewportIndexedfvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfvOES(index: UInt32; v: array of single) := ViewportIndexedfvOES(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfvOES(index: UInt32; var v: single) := ViewportIndexedfvOES(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportIndexedfvOES(index: UInt32; v: pointer) := z_ViewportIndexedfvOES(index, v);
    
    public z_ScissorArrayvOES := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>('glScissorArrayvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayvOES(first: UInt32; count: Int32; v: array of Int32) := ScissorArrayvOES(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayvOES(first: UInt32; count: Int32; var v: Int32) := ScissorArrayvOES(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorArrayvOES(first: UInt32; count: Int32; v: pointer) := z_ScissorArrayvOES(first, count, v);
    
    public z_ScissorIndexedOES := GetGLFuncOrNil&<procedure(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32)>('glScissorIndexedOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedOES(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32) := z_ScissorIndexedOES(index, left, bottom, width, height);
    
    public z_ScissorIndexedvOES := GetGLFuncOrNil&<procedure(index: UInt32; v: pointer)>('glScissorIndexedvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedvOES(index: UInt32; v: array of Int32) := ScissorIndexedvOES(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedvOES(index: UInt32; var v: Int32) := ScissorIndexedvOES(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorIndexedvOES(index: UInt32; v: pointer) := z_ScissorIndexedvOES(index, v);
    
    public z_DepthRangeArrayfvOES := GetGLFuncOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>('glDepthRangeArrayfvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayfvOES(first: UInt32; count: Int32; v: array of single) := DepthRangeArrayfvOES(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayfvOES(first: UInt32; count: Int32; var v: single) := DepthRangeArrayfvOES(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayfvOES(first: UInt32; count: Int32; v: pointer) := z_DepthRangeArrayfvOES(first, count, v);
    
    public z_DepthRangeIndexedfOES := GetGLFuncOrNil&<procedure(index: UInt32; n: single; f: single)>('glDepthRangeIndexedfOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeIndexedfOES(index: UInt32; n: single; f: single) := z_DepthRangeIndexedfOES(index, n, f);
    
    public z_GetFloati_vOES := GetGLFuncOrNil&<procedure(target: GLGetQueries; index: UInt32; data: pointer)>('glGetFloati_vOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vOES(target: GLGetQueries; index: UInt32; data: array of single) := GetFloati_vOES(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vOES(target: GLGetQueries; index: UInt32; var data: single) := GetFloati_vOES(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloati_vOES(target: GLGetQueries; index: UInt32; data: pointer) := z_GetFloati_vOES(target, index, data);
    
    {$endregion OES_viewport_array}
    
    {$region OES_draw_buffers_indexed OES_viewport_array}
    
    public z_EnableiOES := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32)>('glEnableiOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableiOES(target: DummyEnum; index: UInt32) := z_EnableiOES(target, index);
    
    public z_DisableiOES := GetGLFuncOrNil&<procedure(target: DummyEnum; index: UInt32)>('glDisableiOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableiOES(target: DummyEnum; index: UInt32) := z_DisableiOES(target, index);
    
    public z_IsEnablediOES := GetGLFuncOrNil&<function(target: DummyEnum; index: UInt32): boolean>('glIsEnablediOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnablediOES(target: DummyEnum; index: UInt32): boolean := z_IsEnablediOES(target, index);
    
    {$endregion OES_draw_buffers_indexed OES_viewport_array}
    
    {$region OES_draw_elements_base_vertex}
    
    public z_DrawElementsBaseVertexOES := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; basevertex: Int32)>('glDrawElementsBaseVertexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsBaseVertexOES(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; basevertex: Int32) := z_DrawElementsBaseVertexOES(mode, count, &type, indices, basevertex);
    
    public z_DrawRangeElementsBaseVertexOES := GetGLFuncOrNil&<procedure(mode: DummyEnum; start: UInt32; &end: UInt32; count: Int32; &type: DummyEnum; indices: pointer; basevertex: Int32)>('glDrawRangeElementsBaseVertexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementsBaseVertexOES(mode: DummyEnum; start: UInt32; &end: UInt32; count: Int32; &type: DummyEnum; indices: pointer; basevertex: Int32) := z_DrawRangeElementsBaseVertexOES(mode, start, &end, count, &type, indices, basevertex);
    
    public z_DrawElementsInstancedBaseVertexOES := GetGLFuncOrNil&<procedure(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; instancecount: Int32; basevertex: Int32)>('glDrawElementsInstancedBaseVertexOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementsInstancedBaseVertexOES(mode: DummyEnum; count: Int32; &type: DummyEnum; indices: pointer; instancecount: Int32; basevertex: Int32) := z_DrawElementsInstancedBaseVertexOES(mode, count, &type, indices, instancecount, basevertex);
    
    {$endregion OES_draw_elements_base_vertex}
    
    {$region OES_EGL_image}
    
    public z_EGLImageTargetRenderbufferStorageOES := GetGLFuncOrNil&<procedure(target: DummyEnum; image: GLeglImageOES)>('glEGLImageTargetRenderbufferStorageOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetRenderbufferStorageOES(target: DummyEnum; image: GLeglImageOES) := z_EGLImageTargetRenderbufferStorageOES(target, image);
    
    {$endregion OES_EGL_image}
    
    {$region OES_EGL_image OES_EGL_image_external}
    
    public z_EGLImageTargetTexture2DOES := GetGLFuncOrNil&<procedure(target: DummyEnum; image: GLeglImageOES)>('glEGLImageTargetTexture2DOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexture2DOES(target: DummyEnum; image: GLeglImageOES) := z_EGLImageTargetTexture2DOES(target, image);
    
    {$endregion OES_EGL_image OES_EGL_image_external}
    
    {$region OES_geometry_shader}
    
    public z_FramebufferTextureOES := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32)>('glFramebufferTextureOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureOES(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32) := z_FramebufferTextureOES(target, attachment, texture, level);
    
    {$endregion OES_geometry_shader}
    
    {$region OES_mapbuffer}
    
    public z_GetBufferPointervOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetBufferPointervOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointervOES(target: DummyEnum; pname: DummyEnum; &params: array of IntPtr) := GetBufferPointervOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointervOES(target: DummyEnum; pname: DummyEnum; var &params: IntPtr) := GetBufferPointervOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferPointervOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetBufferPointervOES(target, pname, &params);
    
    public z_MapBufferOES := GetGLFuncOrNil&<function(target: DummyEnum; access: DummyEnum): pointer>('glMapBufferOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapBufferOES(target: DummyEnum; access: DummyEnum): pointer := z_MapBufferOES(target, access);
    
    public z_UnmapBufferOES := GetGLFuncOrNil&<function(target: DummyEnum): boolean>('glUnmapBufferOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UnmapBufferOES(target: DummyEnum): boolean := z_UnmapBufferOES(target);
    
    {$endregion OES_mapbuffer}
    
    public z_GetLightxvOES := GetGLFuncOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetLightxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxvOES(light: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetLightxvOES(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxvOES(light: DummyEnum; pname: DummyEnum; var &params: fixed) := GetLightxvOES(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxvOES(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetLightxvOES(light, pname, &params);
    
    public z_GetMaterialxvOES := GetGLFuncOrNil&<procedure(face: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetMaterialxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialxvOES(face: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetMaterialxvOES(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialxvOES(face: DummyEnum; pname: DummyEnum; var &params: fixed) := GetMaterialxvOES(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialxvOES(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMaterialxvOES(face, pname, &params);
    
    {$region OES_get_program_binary}
    
    public z_GetProgramBinaryOES := GetGLFuncOrNil&<procedure(&program: UInt32; bufSize: Int32; length: pointer; binaryFormat: pointer; binary: pointer)>('glGetProgramBinaryOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinaryOES(&program: UInt32; bufSize: Int32; length: array of Int32; binaryFormat: array of DummyEnum; binary: pointer) := GetProgramBinaryOES(&program, bufSize, length[0], binaryFormat[0], binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinaryOES(&program: UInt32; bufSize: Int32; length: array of Int32; var binaryFormat: DummyEnum; binary: pointer) := GetProgramBinaryOES(&program, bufSize, length[0], @binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinaryOES(&program: UInt32; bufSize: Int32; length: array of Int32; binaryFormat: pointer; binary: pointer) := GetProgramBinaryOES(&program, bufSize, length[0], binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinaryOES(&program: UInt32; bufSize: Int32; var length: Int32; binaryFormat: array of DummyEnum; binary: pointer) := GetProgramBinaryOES(&program, bufSize, @length, binaryFormat[0], binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinaryOES(&program: UInt32; bufSize: Int32; var length: Int32; var binaryFormat: DummyEnum; binary: pointer) := GetProgramBinaryOES(&program, bufSize, @length, @binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinaryOES(&program: UInt32; bufSize: Int32; var length: Int32; binaryFormat: pointer; binary: pointer) := GetProgramBinaryOES(&program, bufSize, @length, binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinaryOES(&program: UInt32; bufSize: Int32; length: pointer; binaryFormat: array of DummyEnum; binary: pointer) := GetProgramBinaryOES(&program, bufSize, length, binaryFormat[0], binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinaryOES(&program: UInt32; bufSize: Int32; length: pointer; var binaryFormat: DummyEnum; binary: pointer) := GetProgramBinaryOES(&program, bufSize, length, @binaryFormat, binary);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramBinaryOES(&program: UInt32; bufSize: Int32; length: pointer; binaryFormat: pointer; binary: pointer) := z_GetProgramBinaryOES(&program, bufSize, length, binaryFormat, binary);
    
    public z_ProgramBinaryOES := GetGLFuncOrNil&<procedure(&program: UInt32; binaryFormat: DummyEnum; binary: pointer; length: Int32)>('glProgramBinaryOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBinaryOES(&program: UInt32; binaryFormat: DummyEnum; binary: pointer; length: Int32) := z_ProgramBinaryOES(&program, binaryFormat, binary, length);
    
    {$endregion OES_get_program_binary}
    
    {$region OES_texture_border_clamp}
    
    public z_TexParameterIivOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTexParameterIivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivOES(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := TexParameterIivOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivOES(target: DummyEnum; pname: DummyEnum; var &params: Int32) := TexParameterIivOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIivOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexParameterIivOES(target, pname, &params);
    
    public z_TexParameterIuivOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glTexParameterIuivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivOES(target: DummyEnum; pname: DummyEnum; &params: array of UInt32) := TexParameterIuivOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivOES(target: DummyEnum; pname: DummyEnum; var &params: UInt32) := TexParameterIuivOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterIuivOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexParameterIuivOES(target, pname, &params);
    
    public z_GetTexParameterIivOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexParameterIivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIivOES(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetTexParameterIivOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIivOES(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetTexParameterIivOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIivOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexParameterIivOES(target, pname, &params);
    
    public z_GetTexParameterIuivOES := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexParameterIuivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuivOES(target: DummyEnum; pname: DummyEnum; &params: array of UInt32) := GetTexParameterIuivOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuivOES(target: DummyEnum; pname: DummyEnum; var &params: UInt32) := GetTexParameterIuivOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterIuivOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexParameterIuivOES(target, pname, &params);
    
    public z_SamplerParameterIivOES := GetGLFuncOrNil&<procedure(sampler: UInt32; pname: DummyEnum; param: pointer)>('glSamplerParameterIivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIivOES(sampler: UInt32; pname: DummyEnum; param: array of Int32) := SamplerParameterIivOES(sampler, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIivOES(sampler: UInt32; pname: DummyEnum; var param: Int32) := SamplerParameterIivOES(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIivOES(sampler: UInt32; pname: DummyEnum; param: pointer) := z_SamplerParameterIivOES(sampler, pname, param);
    
    public z_SamplerParameterIuivOES := GetGLFuncOrNil&<procedure(sampler: UInt32; pname: DummyEnum; param: pointer)>('glSamplerParameterIuivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuivOES(sampler: UInt32; pname: DummyEnum; param: array of UInt32) := SamplerParameterIuivOES(sampler, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuivOES(sampler: UInt32; pname: DummyEnum; var param: UInt32) := SamplerParameterIuivOES(sampler, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplerParameterIuivOES(sampler: UInt32; pname: DummyEnum; param: pointer) := z_SamplerParameterIuivOES(sampler, pname, param);
    
    public z_GetSamplerParameterIivOES := GetGLFuncOrNil&<procedure(sampler: UInt32; pname: DummyEnum; &params: pointer)>('glGetSamplerParameterIivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIivOES(sampler: UInt32; pname: DummyEnum; &params: array of Int32) := GetSamplerParameterIivOES(sampler, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIivOES(sampler: UInt32; pname: DummyEnum; var &params: Int32) := GetSamplerParameterIivOES(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIivOES(sampler: UInt32; pname: DummyEnum; &params: pointer) := z_GetSamplerParameterIivOES(sampler, pname, &params);
    
    public z_GetSamplerParameterIuivOES := GetGLFuncOrNil&<procedure(sampler: UInt32; pname: DummyEnum; &params: pointer)>('glGetSamplerParameterIuivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuivOES(sampler: UInt32; pname: DummyEnum; &params: array of UInt32) := GetSamplerParameterIuivOES(sampler, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuivOES(sampler: UInt32; pname: DummyEnum; var &params: UInt32) := GetSamplerParameterIuivOES(sampler, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSamplerParameterIuivOES(sampler: UInt32; pname: DummyEnum; &params: pointer) := z_GetSamplerParameterIuivOES(sampler, pname, &params);
    
    {$endregion OES_texture_border_clamp}
    
    {$region OES_texture_cube_map}
    
    public z_TexGenfOES := GetGLFuncOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; param: single)>('glTexGenfOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfOES(coord: DummyEnum; pname: DummyEnum; param: single) := z_TexGenfOES(coord, pname, param);
    
    public z_TexGenfvOES := GetGLFuncOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glTexGenfvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfvOES(coord: DummyEnum; pname: DummyEnum; &params: array of single) := TexGenfvOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfvOES(coord: DummyEnum; pname: DummyEnum; var &params: single) := TexGenfvOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfvOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexGenfvOES(coord, pname, &params);
    
    public z_TexGeniOES := GetGLFuncOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; param: Int32)>('glTexGeniOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniOES(coord: DummyEnum; pname: DummyEnum; param: Int32) := z_TexGeniOES(coord, pname, param);
    
    public z_TexGenivOES := GetGLFuncOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glTexGenivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenivOES(coord: DummyEnum; pname: DummyEnum; &params: array of Int32) := TexGenivOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenivOES(coord: DummyEnum; pname: DummyEnum; var &params: Int32) := TexGenivOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenivOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexGenivOES(coord, pname, &params);
    
    public z_GetTexGenfvOES := GetGLFuncOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexGenfvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfvOES(coord: DummyEnum; pname: DummyEnum; &params: array of single) := GetTexGenfvOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfvOES(coord: DummyEnum; pname: DummyEnum; var &params: single) := GetTexGenfvOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfvOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexGenfvOES(coord, pname, &params);
    
    public z_GetTexGenivOES := GetGLFuncOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexGenivOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenivOES(coord: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetTexGenivOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenivOES(coord: DummyEnum; pname: DummyEnum; var &params: Int32) := GetTexGenivOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenivOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexGenivOES(coord, pname, &params);
    
    {$endregion OES_texture_cube_map}
    
    {$region OES_fixed_point OES_texture_cube_map}
    
    public z_TexGenxOES := GetGLFuncOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; param: fixed)>('glTexGenxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxOES(coord: DummyEnum; pname: DummyEnum; param: fixed) := z_TexGenxOES(coord, pname, param);
    
    public z_TexGenxvOES := GetGLFuncOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glTexGenxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: DummyEnum; pname: DummyEnum; &params: array of fixed) := TexGenxvOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: DummyEnum; pname: DummyEnum; var &params: fixed) := TexGenxvOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexGenxvOES(coord, pname, &params);
    
    public z_GetTexGenxvOES := GetGLFuncOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetTexGenxvOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenxvOES(coord: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetTexGenxvOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenxvOES(coord: DummyEnum; pname: DummyEnum; var &params: fixed) := GetTexGenxvOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenxvOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexGenxvOES(coord, pname, &params);
    
    {$endregion OES_fixed_point OES_texture_cube_map}
    
    {$region OES_sample_shading}
    
    public z_MinSampleShadingOES := GetGLFuncOrNil&<procedure(value: single)>('glMinSampleShadingOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MinSampleShadingOES(value: single) := z_MinSampleShadingOES(value);
    
    {$endregion OES_sample_shading}
    
    {$region OES_tessellation_shader}
    
    public z_PatchParameteriOES := GetGLFuncOrNil&<procedure(pname: DummyEnum; value: Int32)>('glPatchParameteriOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PatchParameteriOES(pname: DummyEnum; value: Int32) := z_PatchParameteriOES(pname, value);
    
    {$endregion OES_tessellation_shader}
    
    {$region OES_point_size_array}
    
    public z_PointSizePointerOES := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>('glPointSizePointerOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointSizePointerOES(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_PointSizePointerOES(&type, stride, _pointer);
    
    {$endregion OES_point_size_array}
    
    {$region OES_primitive_bounding_box}
    
    public z_PrimitiveBoundingBoxOES := GetGLFuncOrNil&<procedure(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single)>('glPrimitiveBoundingBoxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveBoundingBoxOES(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single) := z_PrimitiveBoundingBoxOES(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    
    {$endregion OES_primitive_bounding_box}
    
    {$region OES_query_matrix}
    
    public z_QueryMatrixxOES := GetGLFuncOrNil&<function(mantissa: pointer; exponent: pointer): DummyFlags>('glQueryMatrixxOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: array of fixed; exponent: array of Int32): DummyFlags := QueryMatrixxOES(mantissa[0], exponent[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: array of fixed; var exponent: Int32): DummyFlags := QueryMatrixxOES(mantissa[0], @exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: array of fixed; exponent: pointer): DummyFlags := QueryMatrixxOES(mantissa[0], exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(var mantissa: fixed; exponent: array of Int32): DummyFlags := QueryMatrixxOES(@mantissa, exponent[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(var mantissa: fixed; var exponent: Int32): DummyFlags := QueryMatrixxOES(@mantissa, @exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(var mantissa: fixed; exponent: pointer): DummyFlags := QueryMatrixxOES(@mantissa, exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: pointer; exponent: array of Int32): DummyFlags := QueryMatrixxOES(mantissa, exponent[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: pointer; var exponent: Int32): DummyFlags := QueryMatrixxOES(mantissa, @exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: pointer; exponent: pointer): DummyFlags := z_QueryMatrixxOES(mantissa, exponent);
    
    {$endregion OES_query_matrix}
    
    {$region OES_texture_buffer}
    
    public z_TexBufferOES := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; buffer: UInt32)>('glTexBufferOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferOES(target: DummyEnum; internalformat: DummyEnum; buffer: UInt32) := z_TexBufferOES(target, internalformat, buffer);
    
    public z_TexBufferRangeOES := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; buffer: UInt32; offset: IntPtr; size: UIntPtr)>('glTexBufferRangeOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBufferRangeOES(target: DummyEnum; internalformat: DummyEnum; buffer: UInt32; offset: IntPtr; size: UIntPtr) := z_TexBufferRangeOES(target, internalformat, buffer, offset, size);
    
    {$endregion OES_texture_buffer}
    
    {$region OES_texture_storage_multisample_2d_array}
    
    public z_TexStorage3DMultisampleOES := GetGLFuncOrNil&<procedure(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean)>('glTexStorage3DMultisampleOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorage3DMultisampleOES(target: DummyEnum; samples: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean) := z_TexStorage3DMultisampleOES(target, samples, internalformat, width, height, depth, fixedsamplelocations);
    
    {$endregion OES_texture_storage_multisample_2d_array}
    
    {$region OES_texture_view}
    
    public z_TextureViewOES := GetGLFuncOrNil&<procedure(texture: UInt32; target: DummyEnum; origtexture: UInt32; internalformat: DummyEnum; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32)>('glTextureViewOES');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureViewOES(texture: UInt32; target: DummyEnum; origtexture: UInt32; internalformat: DummyEnum; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32) := z_TextureViewOES(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
    
    {$endregion OES_texture_view}
    
  end;
  
  gl_OVR = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region OVR_multiview_multisampled_render_to_texture}
    
    public z_FramebufferTextureMultisampleMultiviewOVR := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; samples: Int32; baseViewIndex: Int32; numViews: Int32)>('glFramebufferTextureMultisampleMultiviewOVR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureMultisampleMultiviewOVR(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; samples: Int32; baseViewIndex: Int32; numViews: Int32) := z_FramebufferTextureMultisampleMultiviewOVR(target, attachment, texture, level, samples, baseViewIndex, numViews);
    
    {$endregion OVR_multiview_multisampled_render_to_texture}
    
    {$region OVR_multiview}
    
    public z_FramebufferTextureMultiviewOVR := GetGLFuncOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32)>('glFramebufferTextureMultiviewOVR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureMultiviewOVR(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32) := z_FramebufferTextureMultiviewOVR(target, attachment, texture, level, baseViewIndex, numViews);
    
    public z_NamedFramebufferTextureMultiviewOVR := GetGLFuncOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32)>('glNamedFramebufferTextureMultiviewOVR');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureMultiviewOVR(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32) := z_NamedFramebufferTextureMultiviewOVR(framebuffer, attachment, texture, level, baseViewIndex, numViews);
    
    {$endregion OVR_multiview}
    
  end;
  
  gl_PGI = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region PGI_misc_hints}
    
    public z_HintPGI := GetGLFuncOrNil&<procedure(target: DummyEnum; mode: Int32)>('glHintPGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure HintPGI(target: DummyEnum; mode: Int32) := z_HintPGI(target, mode);
    
    {$endregion PGI_misc_hints}
    
  end;
  
  gl_QCOM = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region QCOM_alpha_test}
    
    public z_AlphaFuncQCOM := GetGLFuncOrNil&<procedure(func: DummyEnum; ref: single)>('glAlphaFuncQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFuncQCOM(func: DummyEnum; ref: single) := z_AlphaFuncQCOM(func, ref);
    
    {$endregion QCOM_alpha_test}
    
    {$region QCOM_driver_control}
    
    public z_GetDriverControlsQCOM := GetGLFuncOrNil&<procedure(num: pointer; size: Int32; driverControls: pointer)>('glGetDriverControlsQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: array of Int32; size: Int32; driverControls: array of UInt32) := GetDriverControlsQCOM(num[0], size, driverControls[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: array of Int32; size: Int32; var driverControls: UInt32) := GetDriverControlsQCOM(num[0], size, @driverControls);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: array of Int32; size: Int32; driverControls: pointer) := GetDriverControlsQCOM(num[0], size, driverControls);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(var num: Int32; size: Int32; driverControls: array of UInt32) := GetDriverControlsQCOM(@num, size, driverControls[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(var num: Int32; size: Int32; var driverControls: UInt32) := GetDriverControlsQCOM(@num, size, @driverControls);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(var num: Int32; size: Int32; driverControls: pointer) := GetDriverControlsQCOM(@num, size, driverControls);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: pointer; size: Int32; driverControls: array of UInt32) := GetDriverControlsQCOM(num, size, driverControls[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: pointer; size: Int32; var driverControls: UInt32) := GetDriverControlsQCOM(num, size, @driverControls);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: pointer; size: Int32; driverControls: pointer) := z_GetDriverControlsQCOM(num, size, driverControls);
    
    public z_GetDriverControlStringQCOM := GetGLFuncOrNil&<procedure(driverControl: UInt32; bufSize: Int32; length: pointer; driverControlString: IntPtr)>('glGetDriverControlStringQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; length: array of Int32; driverControlString: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(driverControlString); GetDriverControlStringQCOM(driverControl, bufSize, length[0], ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; length: array of Int32; driverControlString: IntPtr) := GetDriverControlStringQCOM(driverControl, bufSize, length[0], driverControlString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; var length: Int32; driverControlString: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(driverControlString); GetDriverControlStringQCOM(driverControl, bufSize, @length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; var length: Int32; driverControlString: IntPtr) := GetDriverControlStringQCOM(driverControl, bufSize, @length, driverControlString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; length: pointer; driverControlString: string); begin var ptr_4 := Marshal.StringToHGlobalAnsi(driverControlString); GetDriverControlStringQCOM(driverControl, bufSize, length, ptr_4); Marshal.FreeHGlobal(ptr_4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; length: pointer; driverControlString: IntPtr) := z_GetDriverControlStringQCOM(driverControl, bufSize, length, driverControlString);
    
    public z_EnableDriverControlQCOM := GetGLFuncOrNil&<procedure(driverControl: UInt32)>('glEnableDriverControlQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableDriverControlQCOM(driverControl: UInt32) := z_EnableDriverControlQCOM(driverControl);
    
    public z_DisableDriverControlQCOM := GetGLFuncOrNil&<procedure(driverControl: UInt32)>('glDisableDriverControlQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableDriverControlQCOM(driverControl: UInt32) := z_DisableDriverControlQCOM(driverControl);
    
    {$endregion QCOM_driver_control}
    
    {$region QCOM_tiled_rendering}
    
    public z_StartTilingQCOM := GetGLFuncOrNil&<procedure(x: UInt32; y: UInt32; width: UInt32; height: UInt32; preserveMask: DummyFlags)>('glStartTilingQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StartTilingQCOM(x: UInt32; y: UInt32; width: UInt32; height: UInt32; preserveMask: DummyFlags) := z_StartTilingQCOM(x, y, width, height, preserveMask);
    
    public z_EndTilingQCOM := GetGLFuncOrNil&<procedure(preserveMask: DummyFlags)>('glEndTilingQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTilingQCOM(preserveMask: DummyFlags) := z_EndTilingQCOM(preserveMask);
    
    {$endregion QCOM_tiled_rendering}
    
    {$region QCOM_extended_get}
    
    public z_ExtGetTexturesQCOM := GetGLFuncOrNil&<procedure(textures: pointer; maxTextures: Int32; numTextures: pointer)>('glExtGetTexturesQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: array of UInt32; maxTextures: Int32; numTextures: array of Int32) := ExtGetTexturesQCOM(textures[0], maxTextures, numTextures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: array of UInt32; maxTextures: Int32; var numTextures: Int32) := ExtGetTexturesQCOM(textures[0], maxTextures, @numTextures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: array of UInt32; maxTextures: Int32; numTextures: pointer) := ExtGetTexturesQCOM(textures[0], maxTextures, numTextures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(var textures: UInt32; maxTextures: Int32; numTextures: array of Int32) := ExtGetTexturesQCOM(@textures, maxTextures, numTextures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(var textures: UInt32; maxTextures: Int32; var numTextures: Int32) := ExtGetTexturesQCOM(@textures, maxTextures, @numTextures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(var textures: UInt32; maxTextures: Int32; numTextures: pointer) := ExtGetTexturesQCOM(@textures, maxTextures, numTextures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: pointer; maxTextures: Int32; numTextures: array of Int32) := ExtGetTexturesQCOM(textures, maxTextures, numTextures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: pointer; maxTextures: Int32; var numTextures: Int32) := ExtGetTexturesQCOM(textures, maxTextures, @numTextures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: pointer; maxTextures: Int32; numTextures: pointer) := z_ExtGetTexturesQCOM(textures, maxTextures, numTextures);
    
    public z_ExtGetBuffersQCOM := GetGLFuncOrNil&<procedure(buffers: pointer; maxBuffers: Int32; numBuffers: pointer)>('glExtGetBuffersQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: array of UInt32; maxBuffers: Int32; numBuffers: array of Int32) := ExtGetBuffersQCOM(buffers[0], maxBuffers, numBuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: array of UInt32; maxBuffers: Int32; var numBuffers: Int32) := ExtGetBuffersQCOM(buffers[0], maxBuffers, @numBuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: array of UInt32; maxBuffers: Int32; numBuffers: pointer) := ExtGetBuffersQCOM(buffers[0], maxBuffers, numBuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(var buffers: UInt32; maxBuffers: Int32; numBuffers: array of Int32) := ExtGetBuffersQCOM(@buffers, maxBuffers, numBuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(var buffers: UInt32; maxBuffers: Int32; var numBuffers: Int32) := ExtGetBuffersQCOM(@buffers, maxBuffers, @numBuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(var buffers: UInt32; maxBuffers: Int32; numBuffers: pointer) := ExtGetBuffersQCOM(@buffers, maxBuffers, numBuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: pointer; maxBuffers: Int32; numBuffers: array of Int32) := ExtGetBuffersQCOM(buffers, maxBuffers, numBuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: pointer; maxBuffers: Int32; var numBuffers: Int32) := ExtGetBuffersQCOM(buffers, maxBuffers, @numBuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: pointer; maxBuffers: Int32; numBuffers: pointer) := z_ExtGetBuffersQCOM(buffers, maxBuffers, numBuffers);
    
    public z_ExtGetRenderbuffersQCOM := GetGLFuncOrNil&<procedure(renderbuffers: pointer; maxRenderbuffers: Int32; numRenderbuffers: pointer)>('glExtGetRenderbuffersQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: array of UInt32; maxRenderbuffers: Int32; numRenderbuffers: array of Int32) := ExtGetRenderbuffersQCOM(renderbuffers[0], maxRenderbuffers, numRenderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: array of UInt32; maxRenderbuffers: Int32; var numRenderbuffers: Int32) := ExtGetRenderbuffersQCOM(renderbuffers[0], maxRenderbuffers, @numRenderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: array of UInt32; maxRenderbuffers: Int32; numRenderbuffers: pointer) := ExtGetRenderbuffersQCOM(renderbuffers[0], maxRenderbuffers, numRenderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(var renderbuffers: UInt32; maxRenderbuffers: Int32; numRenderbuffers: array of Int32) := ExtGetRenderbuffersQCOM(@renderbuffers, maxRenderbuffers, numRenderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(var renderbuffers: UInt32; maxRenderbuffers: Int32; var numRenderbuffers: Int32) := ExtGetRenderbuffersQCOM(@renderbuffers, maxRenderbuffers, @numRenderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(var renderbuffers: UInt32; maxRenderbuffers: Int32; numRenderbuffers: pointer) := ExtGetRenderbuffersQCOM(@renderbuffers, maxRenderbuffers, numRenderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: pointer; maxRenderbuffers: Int32; numRenderbuffers: array of Int32) := ExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: pointer; maxRenderbuffers: Int32; var numRenderbuffers: Int32) := ExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, @numRenderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: pointer; maxRenderbuffers: Int32; numRenderbuffers: pointer) := z_ExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers);
    
    public z_ExtGetFramebuffersQCOM := GetGLFuncOrNil&<procedure(framebuffers: pointer; maxFramebuffers: Int32; numFramebuffers: pointer)>('glExtGetFramebuffersQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: array of UInt32; maxFramebuffers: Int32; numFramebuffers: array of Int32) := ExtGetFramebuffersQCOM(framebuffers[0], maxFramebuffers, numFramebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: array of UInt32; maxFramebuffers: Int32; var numFramebuffers: Int32) := ExtGetFramebuffersQCOM(framebuffers[0], maxFramebuffers, @numFramebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: array of UInt32; maxFramebuffers: Int32; numFramebuffers: pointer) := ExtGetFramebuffersQCOM(framebuffers[0], maxFramebuffers, numFramebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(var framebuffers: UInt32; maxFramebuffers: Int32; numFramebuffers: array of Int32) := ExtGetFramebuffersQCOM(@framebuffers, maxFramebuffers, numFramebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(var framebuffers: UInt32; maxFramebuffers: Int32; var numFramebuffers: Int32) := ExtGetFramebuffersQCOM(@framebuffers, maxFramebuffers, @numFramebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(var framebuffers: UInt32; maxFramebuffers: Int32; numFramebuffers: pointer) := ExtGetFramebuffersQCOM(@framebuffers, maxFramebuffers, numFramebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: pointer; maxFramebuffers: Int32; numFramebuffers: array of Int32) := ExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: pointer; maxFramebuffers: Int32; var numFramebuffers: Int32) := ExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, @numFramebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: pointer; maxFramebuffers: Int32; numFramebuffers: pointer) := z_ExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers);
    
    public z_ExtGetTexLevelParameterivQCOM := GetGLFuncOrNil&<procedure(texture: UInt32; face: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer)>('glExtGetTexLevelParameterivQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexLevelParameterivQCOM(texture: UInt32; face: DummyEnum; level: Int32; pname: DummyEnum; &params: array of Int32) := ExtGetTexLevelParameterivQCOM(texture, face, level, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexLevelParameterivQCOM(texture: UInt32; face: DummyEnum; level: Int32; pname: DummyEnum; var &params: Int32) := ExtGetTexLevelParameterivQCOM(texture, face, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexLevelParameterivQCOM(texture: UInt32; face: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := z_ExtGetTexLevelParameterivQCOM(texture, face, level, pname, &params);
    
    public z_ExtTexObjectStateOverrideiQCOM := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>('glExtTexObjectStateOverrideiQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtTexObjectStateOverrideiQCOM(target: DummyEnum; pname: DummyEnum; param: Int32) := z_ExtTexObjectStateOverrideiQCOM(target, pname, param);
    
    public z_ExtGetTexSubImageQCOM := GetGLFuncOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; texels: pointer)>('glExtGetTexSubImageQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexSubImageQCOM(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; texels: pointer) := z_ExtGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, texels);
    
    public z_ExtGetBufferPointervQCOM := GetGLFuncOrNil&<procedure(target: DummyEnum; &params: pointer)>('glExtGetBufferPointervQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBufferPointervQCOM(target: DummyEnum; &params: array of IntPtr) := ExtGetBufferPointervQCOM(target, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBufferPointervQCOM(target: DummyEnum; var &params: IntPtr) := ExtGetBufferPointervQCOM(target, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBufferPointervQCOM(target: DummyEnum; &params: pointer) := z_ExtGetBufferPointervQCOM(target, &params);
    
    {$endregion QCOM_extended_get}
    
    {$region QCOM_extended_get2}
    
    public z_ExtGetShadersQCOM := GetGLFuncOrNil&<procedure(shaders: pointer; maxShaders: Int32; numShaders: pointer)>('glExtGetShadersQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: array of UInt32; maxShaders: Int32; numShaders: array of Int32) := ExtGetShadersQCOM(shaders[0], maxShaders, numShaders[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: array of UInt32; maxShaders: Int32; var numShaders: Int32) := ExtGetShadersQCOM(shaders[0], maxShaders, @numShaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: array of UInt32; maxShaders: Int32; numShaders: pointer) := ExtGetShadersQCOM(shaders[0], maxShaders, numShaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(var shaders: UInt32; maxShaders: Int32; numShaders: array of Int32) := ExtGetShadersQCOM(@shaders, maxShaders, numShaders[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(var shaders: UInt32; maxShaders: Int32; var numShaders: Int32) := ExtGetShadersQCOM(@shaders, maxShaders, @numShaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(var shaders: UInt32; maxShaders: Int32; numShaders: pointer) := ExtGetShadersQCOM(@shaders, maxShaders, numShaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: pointer; maxShaders: Int32; numShaders: array of Int32) := ExtGetShadersQCOM(shaders, maxShaders, numShaders[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: pointer; maxShaders: Int32; var numShaders: Int32) := ExtGetShadersQCOM(shaders, maxShaders, @numShaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: pointer; maxShaders: Int32; numShaders: pointer) := z_ExtGetShadersQCOM(shaders, maxShaders, numShaders);
    
    public z_ExtGetProgramsQCOM := GetGLFuncOrNil&<procedure(programs: pointer; maxPrograms: Int32; numPrograms: pointer)>('glExtGetProgramsQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: array of UInt32; maxPrograms: Int32; numPrograms: array of Int32) := ExtGetProgramsQCOM(programs[0], maxPrograms, numPrograms[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: array of UInt32; maxPrograms: Int32; var numPrograms: Int32) := ExtGetProgramsQCOM(programs[0], maxPrograms, @numPrograms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: array of UInt32; maxPrograms: Int32; numPrograms: pointer) := ExtGetProgramsQCOM(programs[0], maxPrograms, numPrograms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(var programs: UInt32; maxPrograms: Int32; numPrograms: array of Int32) := ExtGetProgramsQCOM(@programs, maxPrograms, numPrograms[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(var programs: UInt32; maxPrograms: Int32; var numPrograms: Int32) := ExtGetProgramsQCOM(@programs, maxPrograms, @numPrograms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(var programs: UInt32; maxPrograms: Int32; numPrograms: pointer) := ExtGetProgramsQCOM(@programs, maxPrograms, numPrograms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: pointer; maxPrograms: Int32; numPrograms: array of Int32) := ExtGetProgramsQCOM(programs, maxPrograms, numPrograms[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: pointer; maxPrograms: Int32; var numPrograms: Int32) := ExtGetProgramsQCOM(programs, maxPrograms, @numPrograms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: pointer; maxPrograms: Int32; numPrograms: pointer) := z_ExtGetProgramsQCOM(programs, maxPrograms, numPrograms);
    
    public z_ExtIsProgramBinaryQCOM := GetGLFuncOrNil&<function(&program: UInt32): boolean>('glExtIsProgramBinaryQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ExtIsProgramBinaryQCOM(&program: UInt32): boolean := z_ExtIsProgramBinaryQCOM(&program);
    
    public z_ExtGetProgramBinarySourceQCOM := GetGLFuncOrNil&<procedure(&program: UInt32; shadertype: DummyEnum; source: IntPtr; length: pointer)>('glExtGetProgramBinarySourceQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: string; length: array of Int32); begin var ptr_3 := Marshal.StringToHGlobalAnsi(source); ExtGetProgramBinarySourceQCOM(&program, shadertype, ptr_3, length[0]); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: string; var length: Int32); begin var ptr_3 := Marshal.StringToHGlobalAnsi(source); ExtGetProgramBinarySourceQCOM(&program, shadertype, ptr_3, @length); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: string; length: pointer); begin var ptr_3 := Marshal.StringToHGlobalAnsi(source); ExtGetProgramBinarySourceQCOM(&program, shadertype, ptr_3, length); Marshal.FreeHGlobal(ptr_3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: IntPtr; length: array of Int32) := ExtGetProgramBinarySourceQCOM(&program, shadertype, source, length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: IntPtr; var length: Int32) := ExtGetProgramBinarySourceQCOM(&program, shadertype, source, @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: IntPtr; length: pointer) := z_ExtGetProgramBinarySourceQCOM(&program, shadertype, source, length);
    
    {$endregion QCOM_extended_get2}
    
    {$region QCOM_shader_framebuffer_fetch_noncoherent}
    
    public z_FramebufferFetchBarrierQCOM := GetGLFuncOrNil&<procedure>('glFramebufferFetchBarrierQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFetchBarrierQCOM := z_FramebufferFetchBarrierQCOM;
    
    {$endregion QCOM_shader_framebuffer_fetch_noncoherent}
    
    {$region QCOM_framebuffer_foveated}
    
    public z_FramebufferFoveationConfigQCOM := GetGLFuncOrNil&<procedure(framebuffer: UInt32; numLayers: UInt32; focalPointsPerLayer: UInt32; requestedFeatures: UInt32; providedFeatures: pointer)>('glFramebufferFoveationConfigQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFoveationConfigQCOM(framebuffer: UInt32; numLayers: UInt32; focalPointsPerLayer: UInt32; requestedFeatures: UInt32; providedFeatures: array of UInt32) := FramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, providedFeatures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFoveationConfigQCOM(framebuffer: UInt32; numLayers: UInt32; focalPointsPerLayer: UInt32; requestedFeatures: UInt32; var providedFeatures: UInt32) := FramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, @providedFeatures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFoveationConfigQCOM(framebuffer: UInt32; numLayers: UInt32; focalPointsPerLayer: UInt32; requestedFeatures: UInt32; providedFeatures: pointer) := z_FramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, providedFeatures);
    
    public z_FramebufferFoveationParametersQCOM := GetGLFuncOrNil&<procedure(framebuffer: UInt32; layer: UInt32; focalPoint: UInt32; focalX: single; focalY: single; gainX: single; gainY: single; foveaArea: single)>('glFramebufferFoveationParametersQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFoveationParametersQCOM(framebuffer: UInt32; layer: UInt32; focalPoint: UInt32; focalX: single; focalY: single; gainX: single; gainY: single; foveaArea: single) := z_FramebufferFoveationParametersQCOM(framebuffer, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
    
    {$endregion QCOM_framebuffer_foveated}
    
    {$region QCOM_texture_foveated}
    
    public z_TextureFoveationParametersQCOM := GetGLFuncOrNil&<procedure(texture: UInt32; layer: UInt32; focalPoint: UInt32; focalX: single; focalY: single; gainX: single; gainY: single; foveaArea: single)>('glTextureFoveationParametersQCOM');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureFoveationParametersQCOM(texture: UInt32; layer: UInt32; focalPoint: UInt32; focalX: single; focalY: single; gainX: single; gainY: single; foveaArea: single) := z_TextureFoveationParametersQCOM(texture, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
    
    {$endregion QCOM_texture_foveated}
    
  end;
  
  gl_SGI = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region SGI_color_table}
    
    public z_ColorTableSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; table: pointer)>('glColorTableSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableSGI(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; table: pointer) := z_ColorTableSGI(target, internalformat, width, format, &type, table);
    
    public z_CopyColorTableSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32)>('glCopyColorTableSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorTableSGI(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32) := z_CopyColorTableSGI(target, internalformat, x, y, width);
    
    public z_ColorTableParameterivSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glColorTableParameterivSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterivSGI(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := ColorTableParameterivSGI(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterivSGI(target: DummyEnum; pname: DummyEnum; var &params: Int32) := ColorTableParameterivSGI(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterivSGI(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ColorTableParameterivSGI(target, pname, &params);
    
    public z_ColorTableParameterfvSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glColorTableParameterfvSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfvSGI(target: DummyEnum; pname: DummyEnum; &params: array of single) := ColorTableParameterfvSGI(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfvSGI(target: DummyEnum; pname: DummyEnum; var &params: single) := ColorTableParameterfvSGI(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfvSGI(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ColorTableParameterfvSGI(target, pname, &params);
    
    public z_GetColorTableSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; table: pointer)>('glGetColorTableSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableSGI(target: DummyEnum; format: DummyEnum; &type: DummyEnum; table: pointer) := z_GetColorTableSGI(target, format, &type, table);
    
    public z_GetColorTableParameterivSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetColorTableParameterivSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivSGI(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetColorTableParameterivSGI(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivSGI(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetColorTableParameterivSGI(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterivSGI(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetColorTableParameterivSGI(target, pname, &params);
    
    public z_GetColorTableParameterfvSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetColorTableParameterfvSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvSGI(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetColorTableParameterfvSGI(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvSGI(target: DummyEnum; pname: DummyEnum; var &params: single) := GetColorTableParameterfvSGI(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfvSGI(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetColorTableParameterfvSGI(target, pname, &params);
    
    {$endregion SGI_color_table}
    
    {$region SGI_fft}
    
    public z_PixelTransformSGI := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glPixelTransformSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformSGI(target: DummyEnum) := z_PixelTransformSGI(target);
    
    public z_PixelTransformParameterfSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: single)>('glPixelTransformParameterfSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfSGI(target: DummyEnum; pname: DummyEnum; param: single) := z_PixelTransformParameterfSGI(target, pname, param);
    
    public z_PixelTransformParameterfvSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glPixelTransformParameterfvSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvSGI(target: DummyEnum; pname: DummyEnum; &params: array of single) := PixelTransformParameterfvSGI(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvSGI(target: DummyEnum; pname: DummyEnum; var &params: single) := PixelTransformParameterfvSGI(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvSGI(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_PixelTransformParameterfvSGI(target, pname, &params);
    
    public z_PixelTransformParameteriSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>('glPixelTransformParameteriSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameteriSGI(target: DummyEnum; pname: DummyEnum; param: Int32) := z_PixelTransformParameteriSGI(target, pname, param);
    
    public z_PixelTransformParameterivSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glPixelTransformParameterivSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivSGI(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := PixelTransformParameterivSGI(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivSGI(target: DummyEnum; pname: DummyEnum; var &params: Int32) := PixelTransformParameterivSGI(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivSGI(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_PixelTransformParameterivSGI(target, pname, &params);
    
    public z_GetPixelTransformParameterfvSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetPixelTransformParameterfvSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvSGI(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetPixelTransformParameterfvSGI(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvSGI(target: DummyEnum; pname: DummyEnum; var &params: single) := GetPixelTransformParameterfvSGI(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvSGI(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetPixelTransformParameterfvSGI(target, pname, &params);
    
    public z_GetPixelTransformParameterivSGI := GetGLFuncOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>('glGetPixelTransformParameterivSGI');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivSGI(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetPixelTransformParameterivSGI(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivSGI(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetPixelTransformParameterivSGI(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivSGI(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetPixelTransformParameterivSGI(target, pname, &params);
    
    {$endregion SGI_fft}
    
  end;
  
  gl_SGIS = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region SGIS_detail_texture}
    
    public z_DetailTexFuncSGIS := GetGLFuncOrNil&<procedure(target: DummyEnum; n: Int32; points: pointer)>('glDetailTexFuncSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: DummyEnum; n: Int32; points: array of single) := DetailTexFuncSGIS(target, n, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: DummyEnum; n: Int32; var points: single) := DetailTexFuncSGIS(target, n, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: DummyEnum; n: Int32; points: pointer) := z_DetailTexFuncSGIS(target, n, points);
    
    public z_GetDetailTexFuncSGIS := GetGLFuncOrNil&<procedure(target: DummyEnum; points: pointer)>('glGetDetailTexFuncSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDetailTexFuncSGIS(target: DummyEnum; points: array of single) := GetDetailTexFuncSGIS(target, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDetailTexFuncSGIS(target: DummyEnum; var points: single) := GetDetailTexFuncSGIS(target, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDetailTexFuncSGIS(target: DummyEnum; points: pointer) := z_GetDetailTexFuncSGIS(target, points);
    
    {$endregion SGIS_detail_texture}
    
    {$region SGIS_fog_function}
    
    public z_FogFuncSGIS := GetGLFuncOrNil&<procedure(n: Int32; points: pointer)>('glFogFuncSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; points: array of single) := FogFuncSGIS(n, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; var points: single) := FogFuncSGIS(n, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; points: pointer) := z_FogFuncSGIS(n, points);
    
    public z_GetFogFuncSGIS := GetGLFuncOrNil&<procedure(points: pointer)>('glGetFogFuncSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFogFuncSGIS(points: array of single) := GetFogFuncSGIS(points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFogFuncSGIS(var points: single) := GetFogFuncSGIS(@points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFogFuncSGIS(points: pointer) := z_GetFogFuncSGIS(points);
    
    {$endregion SGIS_fog_function}
    
    {$region SGIS_pixel_texture}
    
    public z_PixelTexGenParameteriSGIS := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: Int32)>('glPixelTexGenParameteriSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameteriSGIS(pname: DummyEnum; param: Int32) := z_PixelTexGenParameteriSGIS(pname, param);
    
    public z_PixelTexGenParameterfSGIS := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: single)>('glPixelTexGenParameterfSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfSGIS(pname: DummyEnum; param: single) := z_PixelTexGenParameterfSGIS(pname, param);
    
    public z_GetPixelTexGenParameterivSGIS := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glGetPixelTexGenParameterivSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterivSGIS(pname: DummyEnum; &params: array of Int32) := GetPixelTexGenParameterivSGIS(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterivSGIS(pname: DummyEnum; var &params: Int32) := GetPixelTexGenParameterivSGIS(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterivSGIS(pname: DummyEnum; &params: pointer) := z_GetPixelTexGenParameterivSGIS(pname, &params);
    
    public z_GetPixelTexGenParameterfvSGIS := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glGetPixelTexGenParameterfvSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterfvSGIS(pname: DummyEnum; &params: array of single) := GetPixelTexGenParameterfvSGIS(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterfvSGIS(pname: DummyEnum; var &params: single) := GetPixelTexGenParameterfvSGIS(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterfvSGIS(pname: DummyEnum; &params: pointer) := z_GetPixelTexGenParameterfvSGIS(pname, &params);
    
    public z_PixelTexGenParameterivSGIS := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glPixelTexGenParameterivSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: DummyEnum; &params: array of Int32) := PixelTexGenParameterivSGIS(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: DummyEnum; var &params: Int32) := PixelTexGenParameterivSGIS(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: DummyEnum; &params: pointer) := z_PixelTexGenParameterivSGIS(pname, &params);
    
    public z_PixelTexGenParameterfvSGIS := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glPixelTexGenParameterfvSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: DummyEnum; &params: array of single) := PixelTexGenParameterfvSGIS(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: DummyEnum; var &params: single) := PixelTexGenParameterfvSGIS(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: DummyEnum; &params: pointer) := z_PixelTexGenParameterfvSGIS(pname, &params);
    
    {$endregion SGIS_pixel_texture}
    
    {$region SGIS_sharpen_texture}
    
    public z_SharpenTexFuncSGIS := GetGLFuncOrNil&<procedure(target: DummyEnum; n: Int32; points: pointer)>('glSharpenTexFuncSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: DummyEnum; n: Int32; points: array of single) := SharpenTexFuncSGIS(target, n, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: DummyEnum; n: Int32; var points: single) := SharpenTexFuncSGIS(target, n, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: DummyEnum; n: Int32; points: pointer) := z_SharpenTexFuncSGIS(target, n, points);
    
    public z_GetSharpenTexFuncSGIS := GetGLFuncOrNil&<procedure(target: DummyEnum; points: pointer)>('glGetSharpenTexFuncSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSharpenTexFuncSGIS(target: DummyEnum; points: array of single) := GetSharpenTexFuncSGIS(target, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSharpenTexFuncSGIS(target: DummyEnum; var points: single) := GetSharpenTexFuncSGIS(target, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSharpenTexFuncSGIS(target: DummyEnum; points: pointer) := z_GetSharpenTexFuncSGIS(target, points);
    
    {$endregion SGIS_sharpen_texture}
    
    {$region SGIS_texture_filter4}
    
    public z_TexFilterFuncSGIS := GetGLFuncOrNil&<procedure(target: DummyEnum; filter: DummyEnum; n: Int32; weights: pointer)>('glTexFilterFuncSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; n: Int32; weights: array of single) := TexFilterFuncSGIS(target, filter, n, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; n: Int32; var weights: single) := TexFilterFuncSGIS(target, filter, n, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; n: Int32; weights: pointer) := z_TexFilterFuncSGIS(target, filter, n, weights);
    
    public z_GetTexFilterFuncSGIS := GetGLFuncOrNil&<procedure(target: DummyEnum; filter: DummyEnum; weights: pointer)>('glGetTexFilterFuncSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; weights: array of single) := GetTexFilterFuncSGIS(target, filter, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; var weights: single) := GetTexFilterFuncSGIS(target, filter, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; weights: pointer) := z_GetTexFilterFuncSGIS(target, filter, weights);
    
    {$endregion SGIS_texture_filter4}
    
    {$region SGIS_multitexture}
    
    public z_InterleavedTextureCoordSetsSGIS := GetGLFuncOrNil&<procedure(factor: Int32)>('glInterleavedTextureCoordSetsSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InterleavedTextureCoordSetsSGIS(factor: Int32) := z_InterleavedTextureCoordSetsSGIS(factor);
    
    public z_SelectTextureSGIS := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glSelectTextureSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectTextureSGIS(target: DummyEnum) := z_SelectTextureSGIS(target);
    
    public z_SelectTextureCoordSetSGIS := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glSelectTextureCoordSetSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectTextureCoordSetSGIS(target: DummyEnum) := z_SelectTextureCoordSetSGIS(target);
    
    public z_SelectTextureTransformSGIS := GetGLFuncOrNil&<procedure(target: DummyEnum)>('glSelectTextureTransformSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectTextureTransformSGIS(target: DummyEnum) := z_SelectTextureTransformSGIS(target);
    
    {$endregion SGIS_multitexture}
    
    {$region SGIS_shared_multisample}
    
    public z_MultisampleSubRectPosSGIS := GetGLFuncOrNil&<procedure(x: Int32; y: Int32)>('glMultisampleSubRectPosSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultisampleSubRectPosSGIS(x: Int32; y: Int32) := z_MultisampleSubRectPosSGIS(x, y);
    
    {$endregion SGIS_shared_multisample}
    
    {$region SGIS_multisample}
    
    public z_SampleMaskSGIS := GetGLFuncOrNil&<procedure(value: single; invert: boolean)>('glSampleMaskSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskSGIS(value: single; invert: boolean) := z_SampleMaskSGIS(value, invert);
    
    public z_SamplePatternSGIS := GetGLFuncOrNil&<procedure(pattern: DummyEnum)>('glSamplePatternSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplePatternSGIS(pattern: DummyEnum) := z_SamplePatternSGIS(pattern);
    
    {$endregion SGIS_multisample}
    
    {$region SGIS_texture_color_mask}
    
    public z_TextureColorMaskSGIS := GetGLFuncOrNil&<procedure(red: boolean; green: boolean; blue: boolean; alpha: boolean)>('glTextureColorMaskSGIS');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureColorMaskSGIS(red: boolean; green: boolean; blue: boolean; alpha: boolean) := z_TextureColorMaskSGIS(red, green, blue, alpha);
    
    {$endregion SGIS_texture_color_mask}
    
  end;
  
  gl_SGIX = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region SGIX_polynomial_ffd}
    
    public z_DeformationMap3fSGIX := GetGLFuncOrNil&<procedure(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: pointer)>('glDeformationMap3fSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: array of single) := DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; var points: single) := DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: pointer) := z_DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    
    public z_DeformationMap3dSGIX := GetGLFuncOrNil&<procedure(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: pointer)>('glDeformationMap3dSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: array of double) := DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; var points: double) := DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: pointer) := z_DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    
    public z_LoadIdentityDeformationMapSGIX := GetGLFuncOrNil&<procedure(mask: DummyFlags)>('glLoadIdentityDeformationMapSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadIdentityDeformationMapSGIX(mask: DummyFlags) := z_LoadIdentityDeformationMapSGIX(mask);
    
    public z_DeformSGIX := GetGLFuncOrNil&<procedure(mask: DummyFlags)>('glDeformSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformSGIX(mask: DummyFlags) := z_DeformSGIX(mask);
    
    {$endregion SGIX_polynomial_ffd}
    
    {$region SGIX_framezoom}
    
    public z_FrameZoomSGIX := GetGLFuncOrNil&<procedure(factor: Int32)>('glFrameZoomSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrameZoomSGIX(factor: Int32) := z_FrameZoomSGIX(factor);
    
    {$endregion SGIX_framezoom}
    
    {$region SGIX_igloo_interface}
    
    public z_IglooInterfaceSGIX := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glIglooInterfaceSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IglooInterfaceSGIX(pname: DummyEnum; &params: pointer) := z_IglooInterfaceSGIX(pname, &params);
    
    {$endregion SGIX_igloo_interface}
    
    {$region SGIX_pixel_texture}
    
    public z_PixelTexGenSGIX := GetGLFuncOrNil&<procedure(mode: DummyEnum)>('glPixelTexGenSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenSGIX(mode: DummyEnum) := z_PixelTexGenSGIX(mode);
    
    {$endregion SGIX_pixel_texture}
    
    {$region SGIX_reference_plane}
    
    public z_ReferencePlaneSGIX := GetGLFuncOrNil&<procedure(equation: pointer)>('glReferencePlaneSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(equation: array of double) := ReferencePlaneSGIX(equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(var equation: double) := ReferencePlaneSGIX(@equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(equation: pointer) := z_ReferencePlaneSGIX(equation);
    
    {$endregion SGIX_reference_plane}
    
    {$region SGIX_sprite}
    
    public z_SpriteParameteriSGIX := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: Int32)>('glSpriteParameteriSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameteriSGIX(pname: DummyEnum; param: Int32) := z_SpriteParameteriSGIX(pname, param);
    
    public z_SpriteParameterfSGIX := GetGLFuncOrNil&<procedure(pname: DummyEnum; param: single)>('glSpriteParameterfSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfSGIX(pname: DummyEnum; param: single) := z_SpriteParameterfSGIX(pname, param);
    
    public z_SpriteParameterivSGIX := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glSpriteParameterivSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: DummyEnum; &params: array of Int32) := SpriteParameterivSGIX(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: DummyEnum; var &params: Int32) := SpriteParameterivSGIX(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: DummyEnum; &params: pointer) := z_SpriteParameterivSGIX(pname, &params);
    
    public z_SpriteParameterfvSGIX := GetGLFuncOrNil&<procedure(pname: DummyEnum; &params: pointer)>('glSpriteParameterfvSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: DummyEnum; &params: array of single) := SpriteParameterfvSGIX(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: DummyEnum; var &params: single) := SpriteParameterfvSGIX(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: DummyEnum; &params: pointer) := z_SpriteParameterfvSGIX(pname, &params);
    
    {$endregion SGIX_sprite}
    
    {$region SGIX_tag_sample_buffer}
    
    public z_TagSampleBufferSGIX := GetGLFuncOrNil&<procedure>('glTagSampleBufferSGIX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TagSampleBufferSGIX := z_TagSampleBufferSGIX;
    
    {$endregion SGIX_tag_sample_buffer}
    
  end;
  
  gl_SUN = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region SUN_vertex}
    
    public z_Color4ubVertex2fSUN := GetGLFuncOrNil&<procedure(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single)>('glColor4ubVertex2fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fSUN(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single) := z_Color4ubVertex2fSUN(r, g, b, a, x, y);
    
    public z_Color4ubVertex2fvSUN := GetGLFuncOrNil&<procedure(c: pointer; v: pointer)>('glColor4ubVertex2fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(var c: Vec4ub; var v: Vec2f) := Color4ubVertex2fvSUN(@c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: array of Byte; v: array of single) := Color4ubVertex2fvSUN(c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(var c: Byte; var v: single) := Color4ubVertex2fvSUN(@c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: pointer; v: pointer) := z_Color4ubVertex2fvSUN(c, v);
    
    public z_Color4ubVertex3fSUN := GetGLFuncOrNil&<procedure(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>('glColor4ubVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fSUN(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) := z_Color4ubVertex3fSUN(r, g, b, a, x, y, z);
    
    public z_Color4ubVertex3fvSUN := GetGLFuncOrNil&<procedure(c: pointer; v: pointer)>('glColor4ubVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(var c: Vec4ub; var v: Vec3f) := Color4ubVertex3fvSUN(@c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: array of Byte; v: array of single) := Color4ubVertex3fvSUN(c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(var c: Byte; var v: single) := Color4ubVertex3fvSUN(@c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: pointer; v: pointer) := z_Color4ubVertex3fvSUN(c, v);
    
    public z_Color3fVertex3fSUN := GetGLFuncOrNil&<procedure(r: single; g: single; b: single; x: single; y: single; z: single)>('glColor3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fSUN(r: single; g: single; b: single; x: single; y: single; z: single) := z_Color3fVertex3fSUN(r, g, b, x, y, z);
    
    public z_Color3fVertex3fvSUN := GetGLFuncOrNil&<procedure(c: pointer; v: pointer)>('glColor3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(var c: Vec3f; var v: Vec3f) := Color3fVertex3fvSUN(@c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: array of single; v: array of single) := Color3fVertex3fvSUN(c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(var c: single; var v: single) := Color3fVertex3fvSUN(@c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: pointer; v: pointer) := z_Color3fVertex3fvSUN(c, v);
    
    public z_Normal3fVertex3fSUN := GetGLFuncOrNil&<procedure(nx: single; ny: single; nz: single; x: single; y: single; z: single)>('glNormal3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fSUN(nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_Normal3fVertex3fSUN(nx, ny, nz, x, y, z);
    
    public z_Normal3fVertex3fvSUN := GetGLFuncOrNil&<procedure(n: pointer; v: pointer)>('glNormal3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(var n: Vec3f; var v: Vec3f) := Normal3fVertex3fvSUN(@n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: array of single; v: array of single) := Normal3fVertex3fvSUN(n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(var n: single; var v: single) := Normal3fVertex3fvSUN(@n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: pointer; v: pointer) := z_Normal3fVertex3fvSUN(n, v);
    
    public z_Color4fNormal3fVertex3fSUN := GetGLFuncOrNil&<procedure(r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>('glColor4fNormal3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fSUN(r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_Color4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
    
    public z_Color4fNormal3fVertex3fvSUN := GetGLFuncOrNil&<procedure(c: pointer; n: pointer; v: pointer)>('glColor4fNormal3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: Vec4f; var n: Vec3f; var v: Vec3f) := Color4fNormal3fVertex3fvSUN(@c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; n: array of single; v: array of single) := Color4fNormal3fVertex3fvSUN(c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; var n: single; var v: single) := Color4fNormal3fVertex3fvSUN(@c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: pointer; n: pointer; v: pointer) := z_Color4fNormal3fVertex3fvSUN(c, n, v);
    
    public z_TexCoord2fVertex3fSUN := GetGLFuncOrNil&<procedure(s: single; t: single; x: single; y: single; z: single)>('glTexCoord2fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fSUN(s: single; t: single; x: single; y: single; z: single) := z_TexCoord2fVertex3fSUN(s, t, x, y, z);
    
    public z_TexCoord2fVertex3fvSUN := GetGLFuncOrNil&<procedure(tc: pointer; v: pointer)>('glTexCoord2fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(var tc: Vec2f; var v: Vec3f) := TexCoord2fVertex3fvSUN(@tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: array of single; v: array of single) := TexCoord2fVertex3fvSUN(tc[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(var tc: single; var v: single) := TexCoord2fVertex3fvSUN(@tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: pointer; v: pointer) := z_TexCoord2fVertex3fvSUN(tc, v);
    
    public z_TexCoord4fVertex4fSUN := GetGLFuncOrNil&<procedure(s: single; t: single; p: single; q: single; x: single; y: single; z: single; w: single)>('glTexCoord4fVertex4fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fSUN(s: single; t: single; p: single; q: single; x: single; y: single; z: single; w: single) := z_TexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
    
    public z_TexCoord4fVertex4fvSUN := GetGLFuncOrNil&<procedure(tc: pointer; v: pointer)>('glTexCoord4fVertex4fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(var tc: Vec4f; var v: Vec4f) := TexCoord4fVertex4fvSUN(@tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: array of single; v: array of single) := TexCoord4fVertex4fvSUN(tc[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(var tc: single; var v: single) := TexCoord4fVertex4fvSUN(@tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: pointer; v: pointer) := z_TexCoord4fVertex4fvSUN(tc, v);
    
    public z_TexCoord2fColor4ubVertex3fSUN := GetGLFuncOrNil&<procedure(s: single; t: single; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>('glTexCoord2fColor4ubVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fSUN(s: single; t: single; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) := z_TexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
    
    public z_TexCoord2fColor4ubVertex3fvSUN := GetGLFuncOrNil&<procedure(tc: pointer; c: pointer; v: pointer)>('glTexCoord2fColor4ubVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: Vec2f; var c: Vec4ub; var v: Vec3f) := TexCoord2fColor4ubVertex3fvSUN(@tc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; c: array of Byte; v: array of single) := TexCoord2fColor4ubVertex3fvSUN(tc[0], c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; var c: Byte; var v: single) := TexCoord2fColor4ubVertex3fvSUN(@tc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: pointer; c: pointer; v: pointer) := z_TexCoord2fColor4ubVertex3fvSUN(tc, c, v);
    
    public z_TexCoord2fColor3fVertex3fSUN := GetGLFuncOrNil&<procedure(s: single; t: single; r: single; g: single; b: single; x: single; y: single; z: single)>('glTexCoord2fColor3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fSUN(s: single; t: single; r: single; g: single; b: single; x: single; y: single; z: single) := z_TexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
    
    public z_TexCoord2fColor3fVertex3fvSUN := GetGLFuncOrNil&<procedure(tc: pointer; c: pointer; v: pointer)>('glTexCoord2fColor3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: Vec2f; var c: Vec3f; var v: Vec3f) := TexCoord2fColor3fVertex3fvSUN(@tc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; c: array of single; v: array of single) := TexCoord2fColor3fVertex3fvSUN(tc[0], c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; var c: single; var v: single) := TexCoord2fColor3fVertex3fvSUN(@tc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: pointer; c: pointer; v: pointer) := z_TexCoord2fColor3fVertex3fvSUN(tc, c, v);
    
    public z_TexCoord2fNormal3fVertex3fSUN := GetGLFuncOrNil&<procedure(s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>('glTexCoord2fNormal3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fSUN(s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_TexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
    
    public z_TexCoord2fNormal3fVertex3fvSUN := GetGLFuncOrNil&<procedure(tc: pointer; n: pointer; v: pointer)>('glTexCoord2fNormal3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: Vec2f; var n: Vec3f; var v: Vec3f) := TexCoord2fNormal3fVertex3fvSUN(@tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; n: array of single; v: array of single) := TexCoord2fNormal3fVertex3fvSUN(tc[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; var n: single; var v: single) := TexCoord2fNormal3fVertex3fvSUN(@tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: pointer; n: pointer; v: pointer) := z_TexCoord2fNormal3fVertex3fvSUN(tc, n, v);
    
    public z_TexCoord2fColor4fNormal3fVertex3fSUN := GetGLFuncOrNil&<procedure(s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>('glTexCoord2fColor4fNormal3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fSUN(s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_TexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
    
    public z_TexCoord2fColor4fNormal3fVertex3fvSUN := GetGLFuncOrNil&<procedure(tc: pointer; c: pointer; n: pointer; v: pointer)>('glTexCoord2fColor4fNormal3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: Vec2f; var c: Vec4f; var n: Vec3f; var v: Vec3f) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; n: array of single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; var n: single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: pointer; n: pointer; v: pointer) := z_TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
    
    public z_TexCoord4fColor4fNormal3fVertex4fSUN := GetGLFuncOrNil&<procedure(s: single; t: single; p: single; q: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single; w: single)>('glTexCoord4fColor4fNormal3fVertex4fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fSUN(s: single; t: single; p: single; q: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single; w: single) := z_TexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
    
    public z_TexCoord4fColor4fNormal3fVertex4fvSUN := GetGLFuncOrNil&<procedure(tc: pointer; c: pointer; n: pointer; v: pointer)>('glTexCoord4fColor4fNormal3fVertex4fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: Vec4f; var c: Vec4f; var n: Vec3f; var v: Vec4f) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; n: array of single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; var n: single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: pointer; n: pointer; v: pointer) := z_TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
    
    public z_ReplacementCodeuiVertex3fSUN := GetGLFuncOrNil&<procedure(rc: UInt32; x: single; y: single; z: single)>('glReplacementCodeuiVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fSUN(rc: UInt32; x: single; y: single; z: single) := z_ReplacementCodeuiVertex3fSUN(rc, x, y, z);
    
    public z_ReplacementCodeuiVertex3fvSUN := GetGLFuncOrNil&<procedure(rc: pointer; v: pointer)>('glReplacementCodeuiVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: UInt32; var v: Vec3f) := ReplacementCodeuiVertex3fvSUN(@rc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: UInt32; v: array of single) := ReplacementCodeuiVertex3fvSUN(@rc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: UInt32; var v: single) := ReplacementCodeuiVertex3fvSUN(@rc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(rc: pointer; var v: single) := ReplacementCodeuiVertex3fvSUN(rc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(rc: pointer; v: pointer) := z_ReplacementCodeuiVertex3fvSUN(rc, v);
    
    public z_ReplacementCodeuiColor4ubVertex3fSUN := GetGLFuncOrNil&<procedure(rc: UInt32; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>('glReplacementCodeuiColor4ubVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fSUN(rc: UInt32; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) := z_ReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
    
    public z_ReplacementCodeuiColor4ubVertex3fvSUN := GetGLFuncOrNil&<procedure(rc: pointer; c: pointer; v: pointer)>('glReplacementCodeuiColor4ubVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; var c: Vec4ub; var v: Vec3f) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; c: array of Byte; v: array of single) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; var c: Byte; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; var c: Byte; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; c: pointer; v: pointer) := z_ReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
    
    public z_ReplacementCodeuiColor3fVertex3fSUN := GetGLFuncOrNil&<procedure(rc: UInt32; r: single; g: single; b: single; x: single; y: single; z: single)>('glReplacementCodeuiColor3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fSUN(rc: UInt32; r: single; g: single; b: single; x: single; y: single; z: single) := z_ReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
    
    public z_ReplacementCodeuiColor3fVertex3fvSUN := GetGLFuncOrNil&<procedure(rc: pointer; c: pointer; v: pointer)>('glReplacementCodeuiColor3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; var c: Vec3f; var v: Vec3f) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; c: array of single; v: array of single) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; var c: single; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; var c: single; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(rc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; c: pointer; v: pointer) := z_ReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
    
    public z_ReplacementCodeuiNormal3fVertex3fSUN := GetGLFuncOrNil&<procedure(rc: UInt32; nx: single; ny: single; nz: single; x: single; y: single; z: single)>('glReplacementCodeuiNormal3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fSUN(rc: UInt32; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_ReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
    
    public z_ReplacementCodeuiNormal3fVertex3fvSUN := GetGLFuncOrNil&<procedure(rc: pointer; n: pointer; v: pointer)>('glReplacementCodeuiNormal3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; var n: Vec3f; var v: Vec3f) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; n: array of single; v: array of single) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; var n: single; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; var n: single; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; n: pointer; v: pointer) := z_ReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
    
    public z_ReplacementCodeuiColor4fNormal3fVertex3fSUN := GetGLFuncOrNil&<procedure(rc: UInt32; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>('glReplacementCodeuiColor4fNormal3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fSUN(rc: UInt32; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_ReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
    
    public z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN := GetGLFuncOrNil&<procedure(rc: pointer; c: pointer; n: pointer; v: pointer)>('glReplacementCodeuiColor4fNormal3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: Vec4f; var n: Vec3f; var v: Vec3f) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: single; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; var c: single; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: pointer; n: pointer; v: pointer) := z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
    
    public z_ReplacementCodeuiTexCoord2fVertex3fSUN := GetGLFuncOrNil&<procedure(rc: UInt32; s: single; t: single; x: single; y: single; z: single)>('glReplacementCodeuiTexCoord2fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fSUN(rc: UInt32; s: single; t: single; x: single; y: single; z: single) := z_ReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
    
    public z_ReplacementCodeuiTexCoord2fVertex3fvSUN := GetGLFuncOrNil&<procedure(rc: pointer; tc: pointer; v: pointer)>('glReplacementCodeuiTexCoord2fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; var tc: Vec2f; var v: Vec3f) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, @tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; tc: array of single; v: array of single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, tc[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; var tc: single; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, @tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; var tc: single; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, @tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; tc: pointer; v: pointer) := z_ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
    
    public z_ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN := GetGLFuncOrNil&<procedure(rc: UInt32; s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>('glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc: UInt32; s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
    
    public z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN := GetGLFuncOrNil&<procedure(rc: pointer; tc: pointer; n: pointer; v: pointer)>('glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: Vec2f; var n: Vec3f; var v: Vec3f) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, @tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; n: pointer; v: pointer) := z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
    
    public z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN := GetGLFuncOrNil&<procedure(rc: UInt32; s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc: UInt32; s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
    
    public z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN := GetGLFuncOrNil&<procedure(rc: pointer; tc: pointer; c: pointer; n: pointer; v: pointer)>('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: Vec2f; var c: Vec4f; var n: Vec3f; var v: Vec3f) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: pointer; n: pointer; v: pointer) := z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
    
    {$endregion SUN_vertex}
    
    {$region SUN_mesh_array}
    
    public z_DrawMeshArraysSUN := GetGLFuncOrNil&<procedure(mode: DummyEnum; first: Int32; count: Int32; width: Int32)>('glDrawMeshArraysSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshArraysSUN(mode: DummyEnum; first: Int32; count: Int32; width: Int32) := z_DrawMeshArraysSUN(mode, first, count, width);
    
    {$endregion SUN_mesh_array}
    
    {$region SUN_global_alpha}
    
    public z_GlobalAlphaFactorbSUN := GetGLFuncOrNil&<procedure(factor: SByte)>('glGlobalAlphaFactorbSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorbSUN(factor: SByte) := z_GlobalAlphaFactorbSUN(factor);
    
    public z_GlobalAlphaFactorsSUN := GetGLFuncOrNil&<procedure(factor: Int16)>('glGlobalAlphaFactorsSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorsSUN(factor: Int16) := z_GlobalAlphaFactorsSUN(factor);
    
    public z_GlobalAlphaFactoriSUN := GetGLFuncOrNil&<procedure(factor: Int32)>('glGlobalAlphaFactoriSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactoriSUN(factor: Int32) := z_GlobalAlphaFactoriSUN(factor);
    
    public z_GlobalAlphaFactorfSUN := GetGLFuncOrNil&<procedure(factor: single)>('glGlobalAlphaFactorfSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorfSUN(factor: single) := z_GlobalAlphaFactorfSUN(factor);
    
    public z_GlobalAlphaFactordSUN := GetGLFuncOrNil&<procedure(factor: double)>('glGlobalAlphaFactordSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactordSUN(factor: double) := z_GlobalAlphaFactordSUN(factor);
    
    public z_GlobalAlphaFactorubSUN := GetGLFuncOrNil&<procedure(factor: Byte)>('glGlobalAlphaFactorubSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorubSUN(factor: Byte) := z_GlobalAlphaFactorubSUN(factor);
    
    public z_GlobalAlphaFactorusSUN := GetGLFuncOrNil&<procedure(factor: UInt16)>('glGlobalAlphaFactorusSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorusSUN(factor: UInt16) := z_GlobalAlphaFactorusSUN(factor);
    
    public z_GlobalAlphaFactoruiSUN := GetGLFuncOrNil&<procedure(factor: UInt32)>('glGlobalAlphaFactoruiSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactoruiSUN(factor: UInt32) := z_GlobalAlphaFactoruiSUN(factor);
    
    {$endregion SUN_global_alpha}
    
    {$region SUN_triangle_list}
    
    public z_ReplacementCodeuiSUN := GetGLFuncOrNil&<procedure(code: UInt32)>('glReplacementCodeuiSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiSUN(code: UInt32) := z_ReplacementCodeuiSUN(code);
    
    public z_ReplacementCodeusSUN := GetGLFuncOrNil&<procedure(code: UInt16)>('glReplacementCodeusSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusSUN(code: UInt16) := z_ReplacementCodeusSUN(code);
    
    public z_ReplacementCodeubSUN := GetGLFuncOrNil&<procedure(code: Byte)>('glReplacementCodeubSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubSUN(code: Byte) := z_ReplacementCodeubSUN(code);
    
    public z_ReplacementCodeuivSUN := GetGLFuncOrNil&<procedure(code: pointer)>('glReplacementCodeuivSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(code: array of UInt32) := ReplacementCodeuivSUN(code[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(var code: UInt32) := ReplacementCodeuivSUN(@code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(code: pointer) := z_ReplacementCodeuivSUN(code);
    
    public z_ReplacementCodeusvSUN := GetGLFuncOrNil&<procedure(code: pointer)>('glReplacementCodeusvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(code: array of UInt16) := ReplacementCodeusvSUN(code[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(var code: UInt16) := ReplacementCodeusvSUN(@code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(code: pointer) := z_ReplacementCodeusvSUN(code);
    
    public z_ReplacementCodeubvSUN := GetGLFuncOrNil&<procedure(code: pointer)>('glReplacementCodeubvSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(code: array of Byte) := ReplacementCodeubvSUN(code[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(var code: Byte) := ReplacementCodeubvSUN(@code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(code: pointer) := z_ReplacementCodeubvSUN(code);
    
    public z_ReplacementCodePointerSUN := GetGLFuncOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>('glReplacementCodePointerSUN');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: DummyEnum; stride: Int32; _pointer: array of IntPtr) := ReplacementCodePointerSUN(&type, stride, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: DummyEnum; stride: Int32; var _pointer: IntPtr) := ReplacementCodePointerSUN(&type, stride, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_ReplacementCodePointerSUN(&type, stride, _pointer);
    
    {$endregion SUN_triangle_list}
    
  end;
  
  gl_SUNX = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    {$region SUNX_constant_data}
    
    public z_FinishTextureSUNX := GetGLFuncOrNil&<procedure>('glFinishTextureSUNX');
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishTextureSUNX := z_FinishTextureSUNX;
    
    {$endregion SUNX_constant_data}
    
  end;
  
  gdi = sealed class
    private static function _GetGLFuncAdr(lpszProc: IntPtr): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static GetGLFuncAdr := _GetGLFuncAdr;
    public static function GetGLFuncOrNil<T>(fn: string): T;
    begin
      var str_ptr := Marshal.StringToHGlobalAnsi(fn);
      var ptr := GetGLFuncAdr(str_ptr);
      Marshal.FreeHGlobal(str_ptr);
      Result := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    end;
    
    private static function _ChoosePixelFormat(hDc: GDI_DC; pPfd: pointer): Int32; external 'gdi32.dll' name 'ChoosePixelFormat';
    public static z_ChoosePixelFormat := _ChoosePixelFormat;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChoosePixelFormat(hDc: GDI_DC; pPfd: array of GDI_PixelFormatDescriptor): Int32 := ChoosePixelFormat(hDc, pPfd[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChoosePixelFormat(hDc: GDI_DC; var pPfd: GDI_PixelFormatDescriptor): Int32 := ChoosePixelFormat(hDc, @pPfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function ChoosePixelFormat(hDc: GDI_DC; pPfd: pointer): Int32 := z_ChoosePixelFormat(hDc, pPfd);
    
    private static function _DescribePixelFormat(hdc: GDI_DC; ipfd: Int32; cjpfd: UInt32; ppfd: pointer): Int32; external 'gdi32.dll' name 'DescribePixelFormat';
    public static z_DescribePixelFormat := _DescribePixelFormat;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribePixelFormat(hdc: GDI_DC; ipfd: Int32; cjpfd: UInt32; ppfd: array of GDI_PixelFormatDescriptor): Int32 := DescribePixelFormat(hdc, ipfd, cjpfd, ppfd[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribePixelFormat(hdc: GDI_DC; ipfd: Int32; cjpfd: UInt32; var ppfd: GDI_PixelFormatDescriptor): Int32 := DescribePixelFormat(hdc, ipfd, cjpfd, @ppfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function DescribePixelFormat(hdc: GDI_DC; ipfd: Int32; cjpfd: UInt32; ppfd: pointer): Int32 := z_DescribePixelFormat(hdc, ipfd, cjpfd, ppfd);
    
    private static function _GetEnhMetaFilePixelFormat(hemf: GDI_HENHMetafile; ppfd: pointer): UInt32; external 'gdi32.dll' name 'GetEnhMetaFilePixelFormat';
    public static z_GetEnhMetaFilePixelFormat := _GetEnhMetaFilePixelFormat;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEnhMetaFilePixelFormat(hemf: GDI_HENHMetafile; ppfd: array of GDI_PixelFormatDescriptor): UInt32 := GetEnhMetaFilePixelFormat(hemf, ppfd[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEnhMetaFilePixelFormat(hemf: GDI_HENHMetafile; var ppfd: GDI_PixelFormatDescriptor): UInt32 := GetEnhMetaFilePixelFormat(hemf, @ppfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetEnhMetaFilePixelFormat(hemf: GDI_HENHMetafile; ppfd: pointer): UInt32 := z_GetEnhMetaFilePixelFormat(hemf, ppfd);
    
    private static function _GetPixelFormat(hdc: GDI_DC): Int32; external 'gdi32.dll' name 'GetPixelFormat';
    public static z_GetPixelFormat := _GetPixelFormat;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function GetPixelFormat(hdc: GDI_DC): Int32 := z_GetPixelFormat(hdc);
    
    private static function _SetPixelFormat(hdc: GDI_DC; ipfd: Int32; ppfd: pointer): UInt32; external 'gdi32.dll' name 'SetPixelFormat';
    public static z_SetPixelFormat := _SetPixelFormat;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetPixelFormat(hdc: GDI_DC; ipfd: Int32; ppfd: array of GDI_PixelFormatDescriptor): UInt32 := SetPixelFormat(hdc, ipfd, ppfd[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetPixelFormat(hdc: GDI_DC; ipfd: Int32; var ppfd: GDI_PixelFormatDescriptor): UInt32 := SetPixelFormat(hdc, ipfd, @ppfd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SetPixelFormat(hdc: GDI_DC; ipfd: Int32; ppfd: pointer): UInt32 := z_SetPixelFormat(hdc, ipfd, ppfd);
    
    private static function _SwapBuffers(hdc: GDI_DC): UInt32; external 'gdi32.dll' name 'SwapBuffers';
    public static z_SwapBuffers := _SwapBuffers;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] static function SwapBuffers(hdc: GDI_DC): UInt32 := z_SwapBuffers(hdc);
    
  end;
  
  ///Методы для интеграции с gdi
  gl_gdi = static class
    {$reference System.Windows.Forms.dll}
    
    {$region Misc}
    
    ///Создаёт новую поверхность рисования GDI для дескриптора элемента управления
    public static function GetControlDC(hwnd: IntPtr): GDI_DC;
    external 'user32.dll' name 'GetDC';
    
    {$endregion Misc}
    
    {$region InitControl}
    
    ///Создаёт и настраивает поверхность рисования GDI элемента управления WF
    ///hwnd - дескриптор элемента управления
    public static function InitControl(hwnd: IntPtr): GDI_DC;
    begin
      Result := gl_gdi.GetControlDC(hwnd);
      
      var pfd: GDI_PixelFormatDescriptor;
      pfd.nVersion := 1;
      
      pfd.dwFlags :=
        GDI_PixelFormatFlags.DRAW_TO_WINDOW or
        GDI_PixelFormatFlags.SUPPORT_OPENGL or
        GDI_PixelFormatFlags.DOUBLEBUFFER
      ;
      pfd.cColorBits := 24;
      pfd.cDepthBits := 16;
      
      if 1 <> gdi.SetPixelFormat(
        Result,
        gdi.ChoosePixelFormat(Result, pfd),
        pfd
      ) then raise new InvalidOperationException;
      
    end;
    
    ///Создаёт и настраивает поверхность рисования GDI элемента управления WF
    public static function InitControl(c: System.Windows.Forms.Control) := InitControl(c.Handle);
    
    {$endregion InitControl}
    
    {$region SetupControlRedrawing}
    
    ///Добавляет в эвент Form.Load формы (f) обработчик, который:
    ///1. Создаёт контекст OpenGL на поверхности рисования GDI (hdc)
    ///2. Запускает перерисовку (RedrawThreadProc)
    public static procedure SetupControlRedrawing(f: System.Windows.Forms.Form; hdc: GDI_DC; RedrawThreadProc: procedure(EndFrame: ()->()); vsync_fps: integer := 65);
    begin
      
      f.Load += (o,e)->
        System.Threading.Thread.Create(()->
        begin
          
          var context := wgl.z_CreateContext(hdc);
          if 1 <> wgl.z_MakeCurrent(hdc, context) then raise new InvalidOperationException('Не удалось применить контекст');
          
          var EndFrame: ()->();
          if vsync_fps<=0 then
            EndFrame := ()->gdi.SwapBuffers(hdc) else
          begin
            var LastRedr := DateTime.UtcNow;
            var FrameDuration := new TimeSpan(Trunc(TimeSpan.TicksPerSecond/vsync_fps));
            var MaxSlowDown := FrameDuration.Ticks*3;
            
            EndFrame := ()->
            begin
              gdi.SwapBuffers(hdc);
              
              LastRedr := LastRedr+FrameDuration;
              var time_left := LastRedr-DateTime.UtcNow;
              
              if time_left.Ticks>0 then
                System.Threading.Thread.Sleep(time_left) else
              if -time_left.Ticks > MaxSlowDown then
                LastRedr := LastRedr.AddTicks(-time_left.Ticks - MaxSlowDown);
              
            end;
            
          end;
          
          RedrawThreadProc(EndFrame);
        end).Start();
      
    end;
    
    {$endregion SetupControlRedrawing}
    
  end;
  
implementation

{$region MtrMlt}

function operator*(m1: Mtr2x2f; m2: Mtr2x2f): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
end;

function operator*(m1: Mtr2x2f; m2: Mtr2x3f): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
end;

function operator*(m1: Mtr2x2f; m2: Mtr2x4f): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
end;

function operator*(m1: Mtr2x2f; m2: Mtr2x2d): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
end;

function operator*(m1: Mtr2x2f; m2: Mtr2x3d): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
end;

function operator*(m1: Mtr2x2f; m2: Mtr2x4d): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x3f): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x2f): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x4f): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x3d): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x2d): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x4d): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x4f): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x2f): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x3f): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x4d): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x2d): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x3d): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x3f): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x2f): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x4f): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x3d): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x2d): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x4d): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x2f): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x3f): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x4f): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x2d): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x3d): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x4d): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x4f): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x2f): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x3f): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x4d): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x2d): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x3d): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x2f): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x3f): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x4f): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x2d): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x3d): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x4d): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x4f): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x2f): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x3f): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x4d): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x2d): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x3d): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x3f): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x2f): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x4f): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x3d): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x2d): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x4d): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x2f): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x3f): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x4f): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x2d): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x3d): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x4d): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x3f): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x2f): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x4f): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x3d): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x2d): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x4d): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x4f): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x2f): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x3f): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x4d): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x2d): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x3d): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x3f): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x2f): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x4f): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x3d): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x2d): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x4d): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x2f): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x3f): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x4f): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x2d): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x3d): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x4d): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x4f): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x2f): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x3f): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x4d): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x2d): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x3d): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x2f): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x3f): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x4f): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x2d): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x3d): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x4d): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x4f): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x2f): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x3f): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x4d): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x2d): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x3d): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x3f): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x2f): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x4f): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x3d): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x2d): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x4d): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
end;

{$endregion MtrMlt}

{$region MtrTranspose}

function Transpose(self: Mtr2x2f); extensionmethod :=
new Mtr2x2f(self.val00, self.val10, self.val01, self.val11);

function Transpose(self: Mtr3x3f); extensionmethod :=
new Mtr3x3f(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22);

function Transpose(self: Mtr4x4f); extensionmethod :=
new Mtr4x4f(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32, self.val03, self.val13, self.val23, self.val33);

function Transpose(self: Mtr2x3f); extensionmethod :=
new Mtr3x2f(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12);
function Transpose(self: Mtr3x2f); extensionmethod :=
new Mtr2x3f(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21);

function Transpose(self: Mtr2x4f); extensionmethod :=
new Mtr4x2f(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12, self.val03, self.val13);
function Transpose(self: Mtr4x2f); extensionmethod :=
new Mtr2x4f(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31);

function Transpose(self: Mtr3x4f); extensionmethod :=
new Mtr4x3f(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22, self.val03, self.val13, self.val23);
function Transpose(self: Mtr4x3f); extensionmethod :=
new Mtr3x4f(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32);

function Transpose(self: Mtr2x2d); extensionmethod :=
new Mtr2x2d(self.val00, self.val10, self.val01, self.val11);

function Transpose(self: Mtr3x3d); extensionmethod :=
new Mtr3x3d(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22);

function Transpose(self: Mtr4x4d); extensionmethod :=
new Mtr4x4d(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32, self.val03, self.val13, self.val23, self.val33);

function Transpose(self: Mtr2x3d); extensionmethod :=
new Mtr3x2d(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12);
function Transpose(self: Mtr3x2d); extensionmethod :=
new Mtr2x3d(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21);

function Transpose(self: Mtr2x4d); extensionmethod :=
new Mtr4x2d(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12, self.val03, self.val13);
function Transpose(self: Mtr4x2d); extensionmethod :=
new Mtr2x4d(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31);

function Transpose(self: Mtr3x4d); extensionmethod :=
new Mtr4x3d(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22, self.val03, self.val13, self.val23);
function Transpose(self: Mtr4x3d); extensionmethod :=
new Mtr3x4d(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32);

{$endregion MtrTranspose}

end.