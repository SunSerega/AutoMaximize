
//*****************************************************************************************************\\
// Copyright (©) Cergey Latchenko ( github.com/SunSerega | forum.mmcs.sfedu.ru/u/sun_serega )
// This code is distributed under the Unlicense
// For details see LICENSE file or this:
// https://github.com/SunSerega/POCGL/blob/master/LICENSE
//*****************************************************************************************************\\
// Copyright (©) Сергей Латченко ( github.com/SunSerega | forum.mmcs.sfedu.ru/u/sun_serega )
// Этот код распространяется под Unlicense
// Подробнее в файле LICENSE или тут:
// https://github.com/SunSerega/POCGL/blob/master/LICENSE
//*****************************************************************************************************\\

///
///Код переведён отсюда:
/// https://github.com/KhronosGroup/OpenGL-Registry
/// (Основная часть не_расширений - \api\GL\ )
///
///Спецификация (что то типа справки):
/// https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf
///
///Если чего то не хватает - писать сюда:
/// https://github.com/SunSerega/POCGL/issues
///
unit OpenGL;

interface

uses System;
uses System.Runtime.InteropServices;
uses System.Runtime.CompilerServices;

{$region Основные типы} type
  
  GLsync                        = IntPtr;
  GLeglImageOES                 = IntPtr;
  
  QueryName                     = UInt32;
  BufferName                    = UInt32;
  ShaderName                    = UInt32;
  ProgramName                   = UInt32;
  ProgramPipelineName           = UInt32;
  TextureName                   = UInt32;
  SamplerName                   = UInt32;
  FramebufferName               = UInt32;
  RenderbufferName              = UInt32;
  VertexArrayName               = UInt32;
  TransformFeedbackName         = UInt32;
  
  GLContext                     = UInt32;
  GDI_DC                        = IntPtr;
  
  // типы для совместимости с OpenCL
  ///--
  cl_context                    = IntPtr;
  ///--
  cl_event                      = IntPtr;
  
  
  
  //ToDo убрать после чистки
  DummyEnum                     = UInt32;
  DummyFlags                    = UInt32;
  
  
  
  //ToDo переименовать и проверить типы всего дальше:
  
  EGLsync                       = IntPtr;
  EGLDisplay                    = IntPtr;
  
  ShaderBinaryFormat            = UInt32;
  ProgramResourceIndex          = UInt32;
  ProgramBinaryFormat           = UInt32;
  
  GLhandleARB                   = UInt32;
  PBufferName                   = UInt32;
  GLeglClientBufferEXT          = IntPtr;
  VideoOutputDeviceHandleNV     = IntPtr;
  VideoInputDeviceHandleNV      = IntPtr;
  VideoDeviceHandleNV           = IntPtr;
  GLvdpauSurfaceNV              = IntPtr;
  GPUAffinityHandle             = IntPtr;
  GLXFBConfig                   = IntPtr;
  GLXContextID                  = UInt64;
  GLXPbuffer                    = UInt64;
  GLXWindow                     = UInt64;
  GLXPixmap                     = UInt64;
  GLXColormap                   = UInt64;
  GLXDrawable                   = UInt64;
  GLXContext                    = UInt64;
  GLXVideoCaptureDeviceNV       = UInt64;
  GLXVideoSourceSGIX            = UInt64;
  GLXVideoDeviceNV              = UInt32;
  GLXFuncPtr                    = IntPtr;
  
  PDisplay                      = IntPtr;
  PXVisualInfo                  = IntPtr;
  
  
  
  //ToDo эти типы вообще угадывал, перепроверить
  
  GLXDMparams                   = IntPtr;
  GLXDMbuffer                   = IntPtr;
  GLXVLServer                   = IntPtr;
  GLXVLPath                     = IntPtr;
  GLXVLNode                     = IntPtr;
  GLXStatus                     = IntPtr;
  GLUnurbs                      = IntPtr;
  GDI_HENHMetafile              = IntPtr;
  GDI_LayerPlaneDescriptor      = IntPtr;
  
  
  
  OpenGLException = class(Exception)
    
    constructor(text: string) :=
    inherited Create($'Ошибка OpenGL: "{text}"');
    
  end;
  
{$endregion Основные типы}

{$region Энумы} type
  
  {$region case Result of}
  
  //R
  ErrorCode = record
    public val: UInt32;
    
    public const NO_ERROR =                                 0;
    public const FRAMEBUFFER_COMPLETE =                     $8CD5;
    
    public const INVALID_ENUM =                             $0500;
    public const INVALID_VALUE =                            $0501;
    public const INVALID_OPERATION =                        $0502;
    public const STACK_OVERFLOW =                           $0503;
    public const STACK_UNDERFLOW =                          $0504;
    public const OUT_OF_MEMORY =                            $0505;
    public const INVALID_FRAMEBUFFER_OPERATION =            $0506;
    public const CONTEXT_LOST =                             $0507;
    
    public const GUILTY_CONTEXT_RESET =                     $8253;
    public const INNOCENT_CONTEXT_RESET =                   $8254;
    public const UNKNOWN_CONTEXT_RESET =                    $8255;
    
    ///Устарело, в 3.1 уже не существует
    public const TABLE_TOO_LARGE =                          $8031;
    
    
    
    public function ToString: string; override;
    begin
      var res := typeof(ErrorCode).GetFields.Where(fi->fi.IsLiteral).FirstOrDefault(prop->integer(prop.GetValue(nil)) = self.val);
      Result := res=nil?
        $'ErrorCode[${self.val:X}]':
        res.Name.ToWords('_').Select(w->w[1].ToUpper+w.Substring(1).ToLower).JoinIntoString;
    end;
    
    public procedure RaiseIfError :=
    case val of
      NO_ERROR, FRAMEBUFFER_COMPLETE: ;
      else raise new OpenGLException(self.ToString);
    end;
    
  end;
  
  {$endregion case Result of}
  
  {$region 1 значение}
  
  {$region ...InfoType}
  
  //S
  RenderbufferInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WIDTH:           RenderbufferInfoType read new RenderbufferInfoType($8D42);
    public static property HEIGHT:          RenderbufferInfoType read new RenderbufferInfoType($8D43);
    public static property INTERNAL_FORMAT: RenderbufferInfoType read new RenderbufferInfoType($8D44);
    public static property SAMPLES:         RenderbufferInfoType read new RenderbufferInfoType($8CAB);
    public static property RED_SIZE:        RenderbufferInfoType read new RenderbufferInfoType($8D50);
    public static property GREEN_SIZE:      RenderbufferInfoType read new RenderbufferInfoType($8D51);
    public static property BLUE_SIZE:       RenderbufferInfoType read new RenderbufferInfoType($8D52);
    public static property ALPHA_SIZE:      RenderbufferInfoType read new RenderbufferInfoType($8D53);
    public static property DEPTH_SIZE:      RenderbufferInfoType read new RenderbufferInfoType($8D54);
    public static property STENCIL_SIZE:    RenderbufferInfoType read new RenderbufferInfoType($8D55);
    
  end;
  
  //S
  ActiveSubroutineInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORMS:              ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8DE6);
    public static property UNIFORM_LOCATIONS:     ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8E47);
    public static property GL_ACTIVE_SUBROUTINES: ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8DE5);
    public static property UNIFORM_MAX_LENGTH:    ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8E49);
    public static property MAX_LENGTH:            ActiveSubroutineInfoType read new ActiveSubroutineInfoType($8E48);
    
  end;
  
  //S
  ProgramPipelineInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_PROGRAM:          ProgramPipelineInfoType read new ProgramPipelineInfoType($8259);
    public static property VERTEX_SHADER:           ProgramPipelineInfoType read new ProgramPipelineInfoType($8B31);
    public static property TESS_CONTROL_SHADER:     ProgramPipelineInfoType read new ProgramPipelineInfoType($8E88);
    public static property TESS_EVALUATION_SHADER:  ProgramPipelineInfoType read new ProgramPipelineInfoType($8E87);
    public static property GEOMETRY_SHADER:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8DD9);
    public static property FRAGMENT_SHADER:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8B30);
    public static property COMPUTE_SHADER:          ProgramPipelineInfoType read new ProgramPipelineInfoType($91B9);
    public static property VALIDATE_STATUS:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8B83);
    public static property INFO_LOG_LENGTH:         ProgramPipelineInfoType read new ProgramPipelineInfoType($8B84);
    
  end;
  
  //S
  ProgramInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DELETE_STATUS:                         ProgramInfoType read new ProgramInfoType($8B80);
    public static property LINK_STATUS:                           ProgramInfoType read new ProgramInfoType($8B82);
    public static property VALIDATE_STATUS:                       ProgramInfoType read new ProgramInfoType($8B83);
    public static property INFO_LOG_LENGTH:                       ProgramInfoType read new ProgramInfoType($8B84);
    public static property ATTACHED_SHADERS:                      ProgramInfoType read new ProgramInfoType($8B85);
    public static property ACTIVE_ATTRIBUTES:                     ProgramInfoType read new ProgramInfoType($8B89);
    public static property ACTIVE_ATTRIBUTE_MAX_LENGTH:           ProgramInfoType read new ProgramInfoType($8B8A);
    public static property ACTIVE_UNIFORMS:                       ProgramInfoType read new ProgramInfoType($8B86);
    public static property ACTIVE_UNIFORM_MAX_LENGTH:             ProgramInfoType read new ProgramInfoType($8B87);
    public static property TRANSFORM_FEEDBACK_BUFFER_MODE:        ProgramInfoType read new ProgramInfoType($8C7F);
    public static property TRANSFORM_FEEDBACK_VARYINGS:           ProgramInfoType read new ProgramInfoType($8C83);
    public static property TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH: ProgramInfoType read new ProgramInfoType($8C76);
    public static property ACTIVE_UNIFORM_BLOCKS:                 ProgramInfoType read new ProgramInfoType($8A36);
    public static property ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH:  ProgramInfoType read new ProgramInfoType($8A35);
    public static property GEOMETRY_VERTICES_OUT:                 ProgramInfoType read new ProgramInfoType($8916);
    public static property GEOMETRY_INPUT_TYPE:                   ProgramInfoType read new ProgramInfoType($8917);
    public static property GEOMETRY_OUTPUT_TYPE:                  ProgramInfoType read new ProgramInfoType($8918);
    public static property GEOMETRY_SHADER_INVOCATIONS:           ProgramInfoType read new ProgramInfoType($887F);
    public static property TESS_CONTROL_OUTPUT_VERTICES:          ProgramInfoType read new ProgramInfoType($8E75);
    public static property TESS_GEN_MODE:                         ProgramInfoType read new ProgramInfoType($8E76);
    public static property TESS_GEN_SPACING:                      ProgramInfoType read new ProgramInfoType($8E77);
    public static property TESS_GEN_VERTEX_ORDER:                 ProgramInfoType read new ProgramInfoType($8E78);
    public static property TESS_GEN_POINT_MODE:                   ProgramInfoType read new ProgramInfoType($8E79);
    public static property COMPUTE_WORK_GROUP_SIZE:               ProgramInfoType read new ProgramInfoType($8267);
    public static property PROGRAM_SEPARABLE:                     ProgramInfoType read new ProgramInfoType($8258);
    public static property PROGRAM_BINARY_RETRIEVABLE_HINT:       ProgramInfoType read new ProgramInfoType($8257);
    public static property ACTIVE_ATOMIC_COUNTER_BUFFERS:         ProgramInfoType read new ProgramInfoType($92D9);
    
  end;
  
  //S
  ShaderInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SHADER_TYPE:           ShaderInfoType read new ShaderInfoType($8B4F);
    public static property DELETE_STATUS:         ShaderInfoType read new ShaderInfoType($8B80);
    public static property COMPILE_STATUS:        ShaderInfoType read new ShaderInfoType($8B81);
    public static property INFO_LOG_LENGTH:       ShaderInfoType read new ShaderInfoType($8B84);
    public static property SHADER_SOURCE_LENGTH:  ShaderInfoType read new ShaderInfoType($8B88);
    public static property SPIR_V_BINARY:         ShaderInfoType read new ShaderInfoType($9552);
    
  end;
  
  //S
  SyncObjInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OBJECT_TYPE:     SyncObjInfoType read new SyncObjInfoType($9112);
    public static property SYNC_CONDITION:  SyncObjInfoType read new SyncObjInfoType($9113);
    public static property SYNC_STATUS:     SyncObjInfoType read new SyncObjInfoType($9114);
    public static property SYNC_FLAGS:      SyncObjInfoType read new SyncObjInfoType($9115);
    
  end;
  
  //S
  QueryTargetType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SAMPLES_PASSED:                        QueryTargetType read new QueryTargetType($8914);
    public static property ANY_SAMPLES_PASSED:                    QueryTargetType read new QueryTargetType($8C2F);
    public static property ANY_SAMPLES_PASSED_CONSERVATIVE:       QueryTargetType read new QueryTargetType($8D6A);
    public static property PRIMITIVES_GENERATED:                  QueryTargetType read new QueryTargetType($8C87);
    public static property TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: QueryTargetType read new QueryTargetType($8C88);
    public static property TIME_ELAPSED:                          QueryTargetType read new QueryTargetType($88BF);
    public static property TIMESTAMP:                             QueryTargetType read new QueryTargetType($8E28);
    
  end;
  
  //S
  GetQueryInfoName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property QUERY_COUNTER_BITS:  GetQueryInfoName read new GetQueryInfoName($8864);
    public static property CURRENT_QUERY:       GetQueryInfoName read new GetQueryInfoName($8865);
    
  end;
  
  //S
  GetQueryObjectInfoName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RESULT:            GetQueryObjectInfoName read new GetQueryObjectInfoName($8866);
    public static property RESULT_AVAILABLE:  GetQueryObjectInfoName read new GetQueryObjectInfoName($8867);
    
  end;
  
  //S
  BufferInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SIZE:              BufferInfoType read new BufferInfoType($8764);
    public static property USAGE:             BufferInfoType read new BufferInfoType($8765);
    public static property ACCESS:            BufferInfoType read new BufferInfoType($88BB);
    public static property ACCESS_FLAGS:      BufferInfoType read new BufferInfoType($911F);
    public static property IMMUTABLE_STORAGE: BufferInfoType read new BufferInfoType($821F);
    public static property MAPPED:            BufferInfoType read new BufferInfoType($88BC);
    public static property MAP_LENGTH:        BufferInfoType read new BufferInfoType($9120);
    public static property MAP_OFFSET:        BufferInfoType read new BufferInfoType($9121);
    public static property STORAGE_FLAGS:     BufferInfoType read new BufferInfoType($8220);
    public static property MAP_POINTER:       BufferInfoType read new BufferInfoType($88BD);
    
  end;
  
  {$endregion ...InfoType}
  
  //S
  CompatibilityViewClassType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property C_128_BITS:        CompatibilityViewClassType read new CompatibilityViewClassType($82C4);
    public static property C_96_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C5);
    public static property C_64_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C6);
    public static property C_48_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C7);
    public static property C_32_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C8);
    public static property C_24_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82C9);
    public static property C_16_BITS:         CompatibilityViewClassType read new CompatibilityViewClassType($82CA);
    public static property C_8_BITS:          CompatibilityViewClassType read new CompatibilityViewClassType($82CB);
    public static property C_S3TC_DXT1_RGB:   CompatibilityViewClassType read new CompatibilityViewClassType($82CC);
    public static property C_S3TC_DXT1_RGBA:  CompatibilityViewClassType read new CompatibilityViewClassType($82CD);
    public static property C_S3TC_DXT3_RGBA:  CompatibilityViewClassType read new CompatibilityViewClassType($82CE);
    public static property C_S3TC_DXT5_RGBA:  CompatibilityViewClassType read new CompatibilityViewClassType($82CF);
    public static property C_RGTC1_RED:       CompatibilityViewClassType read new CompatibilityViewClassType($82D0);
    public static property C_RGTC2_RG:        CompatibilityViewClassType read new CompatibilityViewClassType($82D1);
    public static property C_BPTC_UNORM:      CompatibilityViewClassType read new CompatibilityViewClassType($82D2);
    public static property C_BPTC_FLOAT:      CompatibilityViewClassType read new CompatibilityViewClassType($82D3);
    
  end;
  
  //S
  CompatibilityImageClassType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property C_4_X_32:      CompatibilityImageClassType read new CompatibilityImageClassType($82B9);
    public static property C_2_X_32:      CompatibilityImageClassType read new CompatibilityImageClassType($82BA);
    public static property C_1_X_32:      CompatibilityImageClassType read new CompatibilityImageClassType($82BB);
    public static property C_4_X_16:      CompatibilityImageClassType read new CompatibilityImageClassType($82BC);
    public static property C_2_X_16:      CompatibilityImageClassType read new CompatibilityImageClassType($82BD);
    public static property C_1_X_16:      CompatibilityImageClassType read new CompatibilityImageClassType($82BE);
    public static property C_4_X_8:       CompatibilityImageClassType read new CompatibilityImageClassType($82BF);
    public static property C_2_X_8:       CompatibilityImageClassType read new CompatibilityImageClassType($82C0);
    public static property C_1_X_8:       CompatibilityImageClassType read new CompatibilityImageClassType($82C1);
    public static property C_11_11_10:    CompatibilityImageClassType read new CompatibilityImageClassType($82C2);
    public static property C_10_10_10_2:  CompatibilityImageClassType read new CompatibilityImageClassType($82C3);
    
  end;
  
  //S
  ImageFormatCompatibilityMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COMPATIBILITY1_BY_SIZE:  ImageFormatCompatibilityMode read new ImageFormatCompatibilityMode($90C8);
    public static property COMPATIBILITY2_BY_CLASS: ImageFormatCompatibilityMode read new ImageFormatCompatibilityMode($90C9);
    public static property NONE:                    ImageFormatCompatibilityMode read new ImageFormatCompatibilityMode($90C9);
    
  end;
  
  //S
  SupportLevel = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:            SupportLevel read new SupportLevel(0);
    public static property FULL_SUPPORT:    SupportLevel read new SupportLevel($82B7);
    public static property CAVEAT_SUPPORT:  SupportLevel read new SupportLevel($82B8);
    
  end;
  
  //S
  GDI_LayerType = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property MAIN_PLANE:      GDI_LayerType read new GDI_LayerType(0);
    public static property OVERLAY_PLANE:   GDI_LayerType read new GDI_LayerType(1);
    public static property UNDERLAY_PLANE:  GDI_LayerType read new GDI_LayerType(-1);
    
  end;
  
  //S
  GDI_PixelDataType = record
    public val: Byte;
    public constructor(val: Byte) := self.val := val;
    
    public static property RGBA:        GDI_PixelDataType read new GDI_PixelDataType(0);
    public static property COLORINDEX:  GDI_PixelDataType read new GDI_PixelDataType(1);
    
  end;
  
  //S
  CopyableImageBuffer = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR:   CopyableImageBuffer read new CopyableImageBuffer($1800);
    public static property DEPTH:   CopyableImageBuffer read new CopyableImageBuffer($1801);
    public static property STENCIL: CopyableImageBuffer read new CopyableImageBuffer($1802);
    
  end;
  
  //S
  VertexProvokingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FIRST_VERTEX_CONVENTION: VertexProvokingMode read new VertexProvokingMode($8E4D);
    public static property LAST_VERTEX_CONVENTION:  VertexProvokingMode read new VertexProvokingMode($8E4E);
    
  end;
  
  //S
  SwizzleMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RED:   SwizzleMode read new SwizzleMode($1903);
    public static property GREEN: SwizzleMode read new SwizzleMode($1904);
    public static property BLUE:  SwizzleMode read new SwizzleMode($1905);
    public static property ALPHA: SwizzleMode read new SwizzleMode($1906);
    public static property ZERO:  SwizzleMode read new SwizzleMode(0);
    public static property ONE:   SwizzleMode read new SwizzleMode(1);
    
  end;
  
  //S
  DepthStencilMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEPTH_COMPONENT: DepthStencilMode read new DepthStencilMode($1902);
    public static property STENCIL_INDEX:   DepthStencilMode read new DepthStencilMode($1901);
    
  end;
  
  //S
  PixelWrapMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLAMP_TO_EDGE:         PixelWrapMode read new PixelWrapMode($812F);
    public static property &REPEAT:               PixelWrapMode read new PixelWrapMode($2901);
    public static property CLAMP_TO_BORDER:       PixelWrapMode read new PixelWrapMode($812D);
    public static property MIRRORED_REPEAT:       PixelWrapMode read new PixelWrapMode($8370);
    public static property MIRROR_CLAMP_TO_EDGE:  PixelWrapMode read new PixelWrapMode($8743);
    
  end;
  
  //S
  TextureCompareMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:                    TextureCompareMode read new TextureCompareMode(0);
    public static property COMPARE_REF_TO_TEXTURE:  TextureCompareMode read new TextureCompareMode($884E);
    
  end;
  
  //S
  ReservedTimeoutMode = record
    public val: uint64;
    public constructor(val: uint64) := self.val := val;
    
    public static property GL_TIMEOUT_IGNORED:  ReservedTimeoutMode read new ReservedTimeoutMode(uint64.MaxValue);
    
  end;
  
  //S
  InternalFormatInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INTERNALFORMAT_SUPPORTED:                InternalFormatInfoType read new InternalFormatInfoType($826F);
    public static property INTERNALFORMAT_PREFERRED:                InternalFormatInfoType read new InternalFormatInfoType($8270);
    public static property INTERNALFORMAT_RED_SIZE:                 InternalFormatInfoType read new InternalFormatInfoType($8271);
    public static property INTERNALFORMAT_RED_TYPE:                 InternalFormatInfoType read new InternalFormatInfoType($8278);
    public static property MAX_WIDTH:                               InternalFormatInfoType read new InternalFormatInfoType($827E);
    public static property MAX_HEIGHT:                              InternalFormatInfoType read new InternalFormatInfoType($827F);
    public static property MAX_DEPTH:                               InternalFormatInfoType read new InternalFormatInfoType($8280);
    public static property MAX_LAYERS:                              InternalFormatInfoType read new InternalFormatInfoType($8281);
    public static property COLOR_COMPONENTS:                        InternalFormatInfoType read new InternalFormatInfoType($8283);
    public static property COLOR_RENDERABLE:                        InternalFormatInfoType read new InternalFormatInfoType($8286);
    public static property DEPTH_RENDERABLE:                        InternalFormatInfoType read new InternalFormatInfoType($8287);
    public static property STENCIL_RENDERABLE:                      InternalFormatInfoType read new InternalFormatInfoType($8288);
    public static property FRAMEBUFFER_RENDERABLE:                  InternalFormatInfoType read new InternalFormatInfoType($8289);
    public static property FRAMEBUFFER_RENDERABLE_LAYERED:          InternalFormatInfoType read new InternalFormatInfoType($828A);
    public static property FRAMEBUFFER_BLEND:                       InternalFormatInfoType read new InternalFormatInfoType($828B);
    public static property READ_PIXELS:                             InternalFormatInfoType read new InternalFormatInfoType($828C);
    public static property READ_PIXELS_FORMAT:                      InternalFormatInfoType read new InternalFormatInfoType($828D);
    public static property READ_PIXELS_TYPE:                        InternalFormatInfoType read new InternalFormatInfoType($828E);
    public static property GET_TEXTURE_IMAGE_FORMAT:                InternalFormatInfoType read new InternalFormatInfoType($8291);
    public static property GET_TEXTURE_IMAGE_TYPE:                  InternalFormatInfoType read new InternalFormatInfoType($8292);
    public static property TEXTURE_IMAGE_FORMAT:                    InternalFormatInfoType read new InternalFormatInfoType($828F);
    public static property TEXTURE_IMAGE_TYPE:                      InternalFormatInfoType read new InternalFormatInfoType($8290);
    public static property MIPMAP:                                  InternalFormatInfoType read new InternalFormatInfoType($8293);
    public static property GENERATE_MIPMAP:                         InternalFormatInfoType read new InternalFormatInfoType($8191);
    public static property AUTO_GENERATE_MIPMAP:                    InternalFormatInfoType read new InternalFormatInfoType($8295);
    public static property COLOR_ENCODING:                          InternalFormatInfoType read new InternalFormatInfoType($8296);
    public static property SRGB_READ:                               InternalFormatInfoType read new InternalFormatInfoType($8297);
    public static property SRGB_WRITE:                              InternalFormatInfoType read new InternalFormatInfoType($8298);
    public static property FILTER:                                  InternalFormatInfoType read new InternalFormatInfoType($829A);
    public static property VERTEX_TEXTURE:                          InternalFormatInfoType read new InternalFormatInfoType($829B);
    public static property TESS_CONTROL_TEXTURE:                    InternalFormatInfoType read new InternalFormatInfoType($829C);
    public static property TESS_EVALUATION_TEXTURE:                 InternalFormatInfoType read new InternalFormatInfoType($829D);
    public static property GEOMETRY_TEXTURE:                        InternalFormatInfoType read new InternalFormatInfoType($829E);
    public static property FRAGMENT_TEXTURE:                        InternalFormatInfoType read new InternalFormatInfoType($829F);
    public static property COMPUTE_TEXTURE:                         InternalFormatInfoType read new InternalFormatInfoType($82A0);
    public static property TEXTURE_SHADOW:                          InternalFormatInfoType read new InternalFormatInfoType($82A1);
    public static property TEXTURE_GATHER:                          InternalFormatInfoType read new InternalFormatInfoType($82A2);
    public static property TEXTURE_GATHER_SHADOW:                   InternalFormatInfoType read new InternalFormatInfoType($82A3);
    public static property SHADER_IMAGE_LOAD:                       InternalFormatInfoType read new InternalFormatInfoType($82A4);
    public static property SHADER_IMAGE_STORE:                      InternalFormatInfoType read new InternalFormatInfoType($82A5);
    public static property SHADER_IMAGE_ATOMIC:                     InternalFormatInfoType read new InternalFormatInfoType($82A6);
    public static property IMAGE_TEXEL_SIZE:                        InternalFormatInfoType read new InternalFormatInfoType($82A7);
    public static property IMAGE_COMPATIBILITY_CLASS:               InternalFormatInfoType read new InternalFormatInfoType($82A8);
    public static property IMAGE_PIXEL_FORMAT:                      InternalFormatInfoType read new InternalFormatInfoType($82A9);
    public static property IMAGE_PIXEL_TYPE:                        InternalFormatInfoType read new InternalFormatInfoType($82AA);
    public static property IMAGE_FORMAT_COMPATIBILITY_TYPE:         InternalFormatInfoType read new InternalFormatInfoType($90C7);
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_TEST:     InternalFormatInfoType read new InternalFormatInfoType($82AC);
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_TEST:   InternalFormatInfoType read new InternalFormatInfoType($82AD);
    public static property SIMULTANEOUS_TEXTURE_AND_DEPTH_WRITE:    InternalFormatInfoType read new InternalFormatInfoType($82AE);
    public static property SIMULTANEOUS_TEXTURE_AND_STENCIL_WRITE:  InternalFormatInfoType read new InternalFormatInfoType($82AF);
    public static property TEXTURE_COMPRESSED:                      InternalFormatInfoType read new InternalFormatInfoType($86A1);
    public static property TEXTURE_COMPRESSED_BLOCK_WIDTH:          InternalFormatInfoType read new InternalFormatInfoType($82B1);
    public static property TEXTURE_COMPRESSED_BLOCK_HEIGHT:         InternalFormatInfoType read new InternalFormatInfoType($82B2);
    public static property TEXTURE_COMPRESSED_BLOCK_SIZE:           InternalFormatInfoType read new InternalFormatInfoType($82B3);
    public static property CLEAR_BUFFER:                            InternalFormatInfoType read new InternalFormatInfoType($82B4);
    public static property TEXTURE_VIEW:                            InternalFormatInfoType read new InternalFormatInfoType($82B5);
    public static property VIEW_COMPATIBILITY_CLASS:                InternalFormatInfoType read new InternalFormatInfoType($82B6);
    public static property CLEAR_TEXTURE:                           InternalFormatInfoType read new InternalFormatInfoType($9365);
    
  end;
  
  //S
  TransformFeedbackInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER_BINDING:  TransformFeedbackInfoType read new TransformFeedbackInfoType($8C8F);
    public static property BUFFER_START:    TransformFeedbackInfoType read new TransformFeedbackInfoType($8C84);
    public static property BUFFER_SIZE:     TransformFeedbackInfoType read new TransformFeedbackInfoType($8C85);
    public static property PAUSED:          TransformFeedbackInfoType read new TransformFeedbackInfoType($8E23);
    public static property ACTIVE:          TransformFeedbackInfoType read new TransformFeedbackInfoType($8E24);
    
  end;
  
  //S
  HintValue = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FASTEST:   HintValue read new HintValue($1101);
    public static property NICEST:    HintValue read new HintValue($1102);
    public static property DONT_CARE: HintValue read new HintValue($1100);
    
  end;
  
  //S
  HintType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LINE_SMOOTH_HINT:                HintType read new HintType($0C52);
    public static property POLYGON_SMOOTH_HINT:             HintType read new HintType($0C53);
    public static property TEXTURE_COMPRESSION_HINT:        HintType read new HintType($84EF);
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT: HintType read new HintType($8B8B);
    
  end;
  
  //S
  ObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BUFFER:              ObjectType read new ObjectType($82E0);
    public static property FRAMEBUFFER:         ObjectType read new ObjectType($8D40);
    public static property PROGRAM_PIPELINE:    ObjectType read new ObjectType($82E4);
    public static property &PROGRAM:            ObjectType read new ObjectType($82E2);
    public static property QUERY:               ObjectType read new ObjectType($82E3);
    public static property RENDERBUFFER:        ObjectType read new ObjectType($8D41);
    public static property SAMPLER:             ObjectType read new ObjectType($82E6);
    public static property SHADER:              ObjectType read new ObjectType($82E1);
    public static property TEXTURE:             ObjectType read new ObjectType($1702);
    public static property TRANSFORM_FEEDBACK:  ObjectType read new ObjectType($8E22);
    public static property VERTEX_ARRAY:        ObjectType read new ObjectType($8074);
    
  end;
  
  //S
  PixelMagFilterMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST: PixelMagFilterMode read new PixelMagFilterMode($2600);
    public static property LINEAR:  PixelMagFilterMode read new PixelMagFilterMode($2601);
    
  end;
  
  //S
  PixelMinFilterMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEAREST:                 PixelMinFilterMode read new PixelMinFilterMode($2600);
    public static property LINEAR:                  PixelMinFilterMode read new PixelMinFilterMode($2601);
    public static property NEAREST_MIPMAP_NEAREST:  PixelMinFilterMode read new PixelMinFilterMode($2700);
    public static property NEAREST_MIPMAP_LINEAR:   PixelMinFilterMode read new PixelMinFilterMode($2702);
    public static property LINEAR_MIPMAP_NEAREST:   PixelMinFilterMode read new PixelMinFilterMode($2701);
    public static property LINEAR_MIPMAP_LINEAR:    PixelMinFilterMode read new PixelMinFilterMode($2703);
    
  end;
  
  //S
  ColorClampTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_CLAMP_READ_COLOR: ColorClampTarget read new ColorClampTarget($891C);
    
  end;
  
  //S
  FrameBufferPart = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE:            FrameBufferPart read new FrameBufferPart(0);
    public static property FRONT_LEFT:      FrameBufferPart read new FrameBufferPart($0400);
    public static property FRONT_RIGHT:     FrameBufferPart read new FrameBufferPart($0401);
    public static property BACK_LEFT:       FrameBufferPart read new FrameBufferPart($0402);
    public static property BACK_RIGHT:      FrameBufferPart read new FrameBufferPart($0403);
    public static property FRONT:           FrameBufferPart read new FrameBufferPart($0404);
    public static property BACK:            FrameBufferPart read new FrameBufferPart($0405);
    public static property LEFT:            FrameBufferPart read new FrameBufferPart($0406);
    public static property RIGHT:           FrameBufferPart read new FrameBufferPart($0407);
    public static property FRONT_AND_BACK:  FrameBufferPart read new FrameBufferPart($0408);
    
  end;
  
  //S
  LogicOpCode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property CLEAR:         LogicOpCode read new LogicOpCode($1500);
    public static property &AND:          LogicOpCode read new LogicOpCode($1501);
    public static property AND_REVERSE:   LogicOpCode read new LogicOpCode($1502);
    public static property COPY:          LogicOpCode read new LogicOpCode($1503);
    public static property AND_INVERTED:  LogicOpCode read new LogicOpCode($1504);
    public static property NOOP:          LogicOpCode read new LogicOpCode($1505);
    public static property &XOR:          LogicOpCode read new LogicOpCode($1506);
    public static property &OR:           LogicOpCode read new LogicOpCode($1507);
    public static property NOR:           LogicOpCode read new LogicOpCode($1508);
    public static property EQUIV:         LogicOpCode read new LogicOpCode($1509);
    public static property INVERT:        LogicOpCode read new LogicOpCode($150A);
    public static property OR_REVERSE:    LogicOpCode read new LogicOpCode($150B);
    public static property COPY_INVERTED: LogicOpCode read new LogicOpCode($150C);
    public static property OR_INVERTED:   LogicOpCode read new LogicOpCode($150D);
    public static property NAND:          LogicOpCode read new LogicOpCode($150E);
    public static property &SET:          LogicOpCode read new LogicOpCode($150F);
    
  end;
  
  //S
  BlendFuncMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ZERO:                      BlendFuncMode read new BlendFuncMode(0);
    public static property ONE:                       BlendFuncMode read new BlendFuncMode(1);
    public static property SRC_COLOR:                 BlendFuncMode read new BlendFuncMode($0300);
    public static property ONE_MINUS_SRC_COLOR:       BlendFuncMode read new BlendFuncMode($0301);
    public static property DST_COLOR:                 BlendFuncMode read new BlendFuncMode($0306);
    public static property ONE_MINUS_DST_COLOR:       BlendFuncMode read new BlendFuncMode($0307);
    public static property SRC_ALPHA:                 BlendFuncMode read new BlendFuncMode($0302);
    public static property ONE_MINUS_SRC_ALPHA:       BlendFuncMode read new BlendFuncMode($0303);
    public static property DST_ALPHA:                 BlendFuncMode read new BlendFuncMode($0304);
    public static property ONE_MINUS_DST_ALPHA:       BlendFuncMode read new BlendFuncMode($0305);
    public static property CONSTANT_COLOR:            BlendFuncMode read new BlendFuncMode($8001);
    public static property ONE_MINUS_CONSTANT_COLOR:  BlendFuncMode read new BlendFuncMode($8002);
    public static property CONSTANT_ALPHA:            BlendFuncMode read new BlendFuncMode($8003);
    public static property ONE_MINUS_CONSTANT_ALPHA:  BlendFuncMode read new BlendFuncMode($8004);
    public static property SRC_ALPHA_SATURATE:        BlendFuncMode read new BlendFuncMode($0308);
    public static property SRC1_COLOR:                BlendFuncMode read new BlendFuncMode($88F9);
    public static property ONE_MINUS_SRC1_COLOR:      BlendFuncMode read new BlendFuncMode($88FA);
    public static property SRC1_ALPHA:                BlendFuncMode read new BlendFuncMode($8589);
    public static property ONE_MINUS_SRC1_ALPHA:      BlendFuncMode read new BlendFuncMode($88FB);
    
  end;
  
  //S
  BlendEquationMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FUNC_ADD:              BlendEquationMode read new BlendEquationMode($8006);
    public static property FUNC_SUBTRACT:         BlendEquationMode read new BlendEquationMode($800A);
    public static property FUNC_REVERSE_SUBTRACT: BlendEquationMode read new BlendEquationMode($800B);
    public static property MIN:                   BlendEquationMode read new BlendEquationMode($8007);
    public static property MAX:                   BlendEquationMode read new BlendEquationMode($8008);
    
  end;
  
  //S
  StencilOpFailMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property KEEP:      StencilOpFailMode read new StencilOpFailMode($1E00);
    public static property ZERO:      StencilOpFailMode read new StencilOpFailMode(0);
    public static property REPLACE:   StencilOpFailMode read new StencilOpFailMode($1E01);
    public static property INCR:      StencilOpFailMode read new StencilOpFailMode($1E02);
    public static property INCR_WRAP: StencilOpFailMode read new StencilOpFailMode($8507);
    public static property DECR:      StencilOpFailMode read new StencilOpFailMode($1E03);
    public static property DECR_WRAP: StencilOpFailMode read new StencilOpFailMode($8508);
    public static property INVERT:    StencilOpFailMode read new StencilOpFailMode($150A);
    
  end;
  
  //S
  ActivationFunc = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEVER:     ActivationFunc read new ActivationFunc($0200);
    public static property LESS:      ActivationFunc read new ActivationFunc($0201);
    public static property LEQUAL:    ActivationFunc read new ActivationFunc($0203);
    public static property GREATER:   ActivationFunc read new ActivationFunc($0204);
    public static property GEQUAL:    ActivationFunc read new ActivationFunc($0206);
    public static property EQUAL:     ActivationFunc read new ActivationFunc($0202);
    public static property NOTEQUAL:  ActivationFunc read new ActivationFunc($0205);
    public static property ALWAYS:    ActivationFunc read new ActivationFunc($0207);
    
  end;
  
  //S
  PolygonRasterizationMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINT: PolygonRasterizationMode read new PolygonRasterizationMode($1B00);
    public static property LINE:  PolygonRasterizationMode read new PolygonRasterizationMode($1B01);
    public static property FILL:  PolygonRasterizationMode read new PolygonRasterizationMode($1B02);
    
  end;
  
  //S
  PolygonFace = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FRONT:           PolygonFace read new PolygonFace($0404);
    public static property BACK:            PolygonFace read new PolygonFace($0405);
    public static property FRONT_AND_BACK:  PolygonFace read new PolygonFace($0408);
    
  end;
  
  //S
  FrontFaceDirection = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property СW:  FrontFaceDirection read new FrontFaceDirection($0900);
    public static property СCW: FrontFaceDirection read new FrontFaceDirection($0901);
    
  end;
  
  //S
  PointInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property FADE_THRESHOLD_SIZE: PointInfoType read new PointInfoType($8128);
    public static property SPRITE_COORD_ORIGIN: PointInfoType read new PointInfoType($8CA0);
    
  end;
  
  //S
  MultisampleInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_SAMPLE_POSITION:  MultisampleInfoType read new MultisampleInfoType($8E50);
    
  end;
  
  //S
  ClipDepthMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NEGATIVE_ONE_TO_ONE: ClipDepthMode read new ClipDepthMode($935E);
    public static property ZERO_TO_ONE:         ClipDepthMode read new ClipDepthMode($935F);
    
  end;
  
  //S
  ClipOriginMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOWER_LEFT:  ClipOriginMode read new ClipOriginMode($8CA1);
    public static property UPPER_LEFT:  ClipOriginMode read new ClipOriginMode($8CA2);
    
  end;
  
  //S
  TransformFeedbackBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_TRANSFORM_FEEDBACK: TransformFeedbackBindTarget read new TransformFeedbackBindTarget($8E22);
    
  end;
  
  //S
  TransformFeedbackBufferMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property INTERLEAVED_ATTRIBS: TransformFeedbackBufferMode read new TransformFeedbackBufferMode($8C8C);
    public static property SEPARATE_ATTRIBS:    TransformFeedbackBufferMode read new TransformFeedbackBufferMode($8C8D);
    
  end;
  
  //S
  ConditionalRenderingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WAIT:                        ConditionalRenderingMode read new ConditionalRenderingMode($8E13);
    public static property NO_WAIT:                     ConditionalRenderingMode read new ConditionalRenderingMode($8E14);
    public static property BY_REGION_WAIT:              ConditionalRenderingMode read new ConditionalRenderingMode($8E15);
    public static property BY_REGION_NO_WAIT:           ConditionalRenderingMode read new ConditionalRenderingMode($8E16);
    public static property WAIT_INVERTED:               ConditionalRenderingMode read new ConditionalRenderingMode($8E17);
    public static property NO_WAIT_INVERTED:            ConditionalRenderingMode read new ConditionalRenderingMode($8E18);
    public static property BY_REGION_WAIT_INVERTED:     ConditionalRenderingMode read new ConditionalRenderingMode($8E19);
    public static property BY_REGION_NO_WAIT_INVERTED:  ConditionalRenderingMode read new ConditionalRenderingMode($8E1A);
    
  end;
  
  //S
  VertexAttribInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ELEMENT_ARRAY_BUFFER_BINDING:        VertexAttribInfoType read new VertexAttribInfoType($8895);
    public static property VERTEX_ATTRIB_ARRAY_ENABLED:         VertexAttribInfoType read new VertexAttribInfoType($8622);
    public static property VERTEX_ATTRIB_ARRAY_SIZE:            VertexAttribInfoType read new VertexAttribInfoType($8623);
    public static property VERTEX_ATTRIB_ARRAY_STRIDE:          VertexAttribInfoType read new VertexAttribInfoType($8624);
    public static property VERTEX_ATTRIB_ARRAY_TYPE:            VertexAttribInfoType read new VertexAttribInfoType($8625);
    public static property VERTEX_ATTRIB_ARRAY_NORMALIZED:      VertexAttribInfoType read new VertexAttribInfoType($886A);
    public static property VERTEX_ATTRIB_ARRAY_INTEGER:         VertexAttribInfoType read new VertexAttribInfoType($88FD);
    public static property VERTEX_ATTRIB_ARRAY_LONG:            VertexAttribInfoType read new VertexAttribInfoType($874E);
    public static property VERTEX_ATTRIB_ARRAY_DIVISOR:         VertexAttribInfoType read new VertexAttribInfoType($88FE);
    public static property VERTEX_ATTRIB_RELATIVE_OFFSET:       VertexAttribInfoType read new VertexAttribInfoType($82D5);
    public static property VERTEX_BINDING_OFFSET:               VertexAttribInfoType read new VertexAttribInfoType($82D7);
    public static property VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:  VertexAttribInfoType read new VertexAttribInfoType($889F);
    public static property VERTEX_ATTRIB_BINDING:               VertexAttribInfoType read new VertexAttribInfoType($82D4);
    public static property CURRENT_VERTEX_ATTRIB:               VertexAttribInfoType read new VertexAttribInfoType($8626);
    
  end;
  
  //S
  PatchMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTICES:            PatchMode read new PatchMode($8E72);
    public static property DEFAULT_INNER_LEVEL: PatchMode read new PatchMode($8E73);
    public static property DEFAULT_OUTER_LEVEL: PatchMode read new PatchMode($8E74);
    
  end;
  
  //S
  PrimitiveType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POINTS:                    PrimitiveType read new PrimitiveType($0000);
    
    public static property LINES:                     PrimitiveType read new PrimitiveType($0001);
    public static property LINE_LOOP:                 PrimitiveType read new PrimitiveType($0002);
    public static property LINE_STRIP:                PrimitiveType read new PrimitiveType($0003);
    public static property LINES_ADJACENCY:           PrimitiveType read new PrimitiveType($000A);
    public static property LINE_STRIP_ADJACENCY:      PrimitiveType read new PrimitiveType($000B);
    
    public static property TRIANGLES:                 PrimitiveType read new PrimitiveType($0004);
    public static property TRIANGLE_STRIP:            PrimitiveType read new PrimitiveType($0005);
    public static property TRIANGLE_FAN:              PrimitiveType read new PrimitiveType($0006);
    public static property TRIANGLES_ADJACENCY:       PrimitiveType read new PrimitiveType($000C);
    public static property TRIANGLE_STRIP_ADJACENCY:  PrimitiveType read new PrimitiveType($000D);
    
    public static property PATCHES:                   PrimitiveType read new PrimitiveType($000E);
    
  end;
  
  //S
  FramebufferAttachmentInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property OBJECT_TYPE:           FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD0); // FramebufferAttachmentObjectType
    
    // non- NONE
    public static property OBJECT_NAME:           FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD1); // UInt32
    public static property RED_SIZE:              FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8212); // Int32
    public static property GREEN_SIZE:            FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8213); // Int32
    public static property BLUE_SIZE:             FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8214); // Int32
    public static property ALPHA_SIZE:            FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8215); // Int32
    public static property DEPTH_SIZE:            FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8216); // Int32
    public static property STENCIL_SIZE:          FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8217); // Int32
    public static property COMPONENT_TYPE:        FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8211); // Int32
    public static property COLOR_ENCODING:        FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8210); // Int32
    
    // TEXTURE
    public static property TEXTURE_LEVEL:         FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD2); // Int32
    public static property TEXTURE_CUBE_MAP_FACE: FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD3); // Int32
    public static property LAYERED:               FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8DA7); // 32-битное boolean (Int32, 0=False, остальное=True)
    public static property TEXTURE_LAYER:         FramebufferAttachmentInfoType read new FramebufferAttachmentInfoType($8CD4); // Int32
    
  end;
  
  //S
  FramebufferInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property WIDTH:                   FramebufferInfoType read new FramebufferInfoType($9310);
    public static property HEIGHT:                  FramebufferInfoType read new FramebufferInfoType($9311);
    public static property LAYERS:                  FramebufferInfoType read new FramebufferInfoType($9312);
    public static property SAMPLES:                 FramebufferInfoType read new FramebufferInfoType($9313);
    public static property FIXED_SAMPLE_LOCATIONS:  FramebufferInfoType read new FramebufferInfoType($9314);
    
  end;
  
  //S
  FramebufferBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_FRAMEBUFFER:  FramebufferBindTarget read new FramebufferBindTarget($8CA8);
    public static property DRAW_FRAMEBUFFER:  FramebufferBindTarget read new FramebufferBindTarget($8CA9);
    public static property FRAMEBUFFER:       FramebufferBindTarget read new FramebufferBindTarget($8D40);
    
  end;
  
  //S
  TextureCubeSide = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property POSITIVE_X:  TextureCubeSide read new TextureCubeSide($8515);
    public static property NEGATIVE_X:  TextureCubeSide read new TextureCubeSide($8516);
    public static property POSITIVE_Y:  TextureCubeSide read new TextureCubeSide($8517);
    public static property NEGATIVE_Y:  TextureCubeSide read new TextureCubeSide($8518);
    public static property POSITIVE_Z:  TextureCubeSide read new TextureCubeSide($8519);
    public static property NEGATIVE_Z:  TextureCubeSide read new TextureCubeSide($851A);
    
  end;
  
  //S
  RenderbufferBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RENDERBUFFER: RenderbufferBindTarget read new RenderbufferBindTarget($8D41);
    
  end;
  
  //S
  AccessType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_ONLY:   AccessType read new AccessType($88B8);
    public static property WRITE_ONLY:  AccessType read new AccessType($88B9);
    public static property READ_WRITE:  AccessType read new AccessType($88BA);
    
  end;
  
  //S
  TextureInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DEPTH_STENCIL_TEXTURE_MODE:  TextureInfoType read new TextureInfoType($90EA);
    public static property BASE_LEVEL:                  TextureInfoType read new TextureInfoType($813C);
    public static property BORDER_COLOR:                TextureInfoType read new TextureInfoType($1004);
    public static property COMPARE_MODE:                TextureInfoType read new TextureInfoType($884C);
    public static property COMPARE_FUNC:                TextureInfoType read new TextureInfoType($884D);
    public static property LOD_BIAS:                    TextureInfoType read new TextureInfoType($8501);
    public static property MAG_FILTER:                  TextureInfoType read new TextureInfoType($2800);
    public static property MAX_ANISOTROPY:              TextureInfoType read new TextureInfoType($84FE);
    public static property MAX_LEVEL:                   TextureInfoType read new TextureInfoType($813D);
    public static property MAX_LOD:                     TextureInfoType read new TextureInfoType($813B);
    public static property MIN_FILTER:                  TextureInfoType read new TextureInfoType($2801);
    public static property MIN_LOD:                     TextureInfoType read new TextureInfoType($813A);
    public static property SWIZZLE_R:                   TextureInfoType read new TextureInfoType($8E42);
    public static property SWIZZLE_G:                   TextureInfoType read new TextureInfoType($8E43);
    public static property SWIZZLE_B:                   TextureInfoType read new TextureInfoType($8E44);
    public static property SWIZZLE_A:                   TextureInfoType read new TextureInfoType($8E45);
    public static property SWIZZLE_RGBA:                TextureInfoType read new TextureInfoType($8E46);
    public static property WRAP_S:                      TextureInfoType read new TextureInfoType($2802);
    public static property WRAP_T:                      TextureInfoType read new TextureInfoType($2803);
    public static property WRAP_R:                      TextureInfoType read new TextureInfoType($8072);
    
  end;
  
  //S
  PixelInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNPACK_SWAP_BYTES:               PixelInfoType read new PixelInfoType($0CF0);
    public static property UNPACK_LSB_FIRST:                PixelInfoType read new PixelInfoType($0CF1);
    public static property UNPACK_ROW_LENGTH:               PixelInfoType read new PixelInfoType($0CF2);
    public static property UNPACK_SKIP_ROWS:                PixelInfoType read new PixelInfoType($0CF3);
    public static property UNPACK_SKIP_PIXELS:              PixelInfoType read new PixelInfoType($0CF4);
    public static property UNPACK_ALIGNMENT:                PixelInfoType read new PixelInfoType($0CF5);
    public static property UNPACK_IMAGE_HEIGHT:             PixelInfoType read new PixelInfoType($806E);
    public static property UNPACK_SKIP_IMAGES:              PixelInfoType read new PixelInfoType($806D);
    public static property UNPACK_COMPRESSED_BLOCK_WIDTH:   PixelInfoType read new PixelInfoType($9127);
    public static property UNPACK_COMPRESSED_BLOCK_HEIGHT:  PixelInfoType read new PixelInfoType($9128);
    public static property UNPACK_COMPRESSED_BLOCK_DEPTH:   PixelInfoType read new PixelInfoType($9129);
    public static property UNPACK_COMPRESSED_BLOCK_SIZE:    PixelInfoType read new PixelInfoType($912A);
    public static property PACK_SWAP_BYTES:                 PixelInfoType read new PixelInfoType($0D00);
    public static property PACK_LSB_FIRST:                  PixelInfoType read new PixelInfoType($0D01);
    public static property PACK_ROW_LENGTH:                 PixelInfoType read new PixelInfoType($0D02);
    public static property PACK_SKIP_ROWS:                  PixelInfoType read new PixelInfoType($0D03);
    public static property PACK_SKIP_PIXELS:                PixelInfoType read new PixelInfoType($0D04);
    public static property PACK_ALIGNMENT:                  PixelInfoType read new PixelInfoType($0D05);
    public static property PACK_IMAGE_HEIGHT:               PixelInfoType read new PixelInfoType($806C);
    public static property PACK_SKIP_IMAGES:                PixelInfoType read new PixelInfoType($806B);
    public static property PACK_COMPRESSED_BLOCK_WIDTH:     PixelInfoType read new PixelInfoType($912B);
    public static property PACK_COMPRESSED_BLOCK_HEIGHT:    PixelInfoType read new PixelInfoType($912C);
    public static property PACK_COMPRESSED_BLOCK_DEPTH:     PixelInfoType read new PixelInfoType($912D);
    public static property PACK_COMPRESSED_BLOCK_SIZE:      PixelInfoType read new PixelInfoType($912E);
    
  end;
  
  //S
  TextureUnitId = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property Texture[i: integer]: TextureUnitId read new TextureUnitId($84C0+i);
    
  end;
  
  //S
  FramebufferAttachmentPoint = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    // custom framebuffer
    public static property COLOR_ATTACHMENT[i: integer]:  FramebufferAttachmentPoint read new FramebufferAttachmentPoint($8CE0+i);
    public static property DEPTH_ATTACHMENT:              FramebufferAttachmentPoint read new FramebufferAttachmentPoint($8D00);
    public static property STENCIL_ATTACHMENT:            FramebufferAttachmentPoint read new FramebufferAttachmentPoint($8D20);
    public static property DEPTH_STENCIL_ATTACHMENT:      FramebufferAttachmentPoint read new FramebufferAttachmentPoint($821A);
    
    // default framebuffer
    public static property FRONT:                         FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0404);
    public static property FRONT_LEFT:                    FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0400);
    public static property FRONT_RIGHT:                   FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0401);
    public static property BACK:                          FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0405);
    public static property BACK_LEFT:                     FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0402);
    public static property BACK_RIGHT:                    FramebufferAttachmentPoint read new FramebufferAttachmentPoint($0403);
    public static property DEPTH:                         FramebufferAttachmentPoint read new FramebufferAttachmentPoint($1801);
    public static property STENCIL:                       FramebufferAttachmentPoint read new FramebufferAttachmentPoint($1802);
    
  end;
  
  //S
  TextureBindTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property T_1D:                          TextureBindTarget read new TextureBindTarget($0DE0);
    public static property T_2D:                          TextureBindTarget read new TextureBindTarget($0DE1);
    public static property T_3D:                          TextureBindTarget read new TextureBindTarget($806F);
    public static property T_1D_ARRAY:                    TextureBindTarget read new TextureBindTarget($8C18);
    public static property T_2D_ARRAY:                    TextureBindTarget read new TextureBindTarget($8C1A);
    public static property T_RECTANGLE:                   TextureBindTarget read new TextureBindTarget($84F5);
    public static property T_BUFFER:                      TextureBindTarget read new TextureBindTarget($8C2A);
    public static property T_CUBE_MAP:                    TextureBindTarget read new TextureBindTarget($8513);
    public static property T_CUBE_MAP_ARRAY:              TextureBindTarget read new TextureBindTarget($9009);
    public static property T_2D_MULTISAMPLE:              TextureBindTarget read new TextureBindTarget($9100);
    public static property PROXY_T_2D_MULTISAMPLE:        TextureBindTarget read new TextureBindTarget($9101);
    public static property T_2D_MULTISAMPLE_ARRAY:        TextureBindTarget read new TextureBindTarget($9102);
    public static property PROXY_T_2D_MULTISAMPLE_ARRAY:  TextureBindTarget read new TextureBindTarget($9103);
    
  end;
  
  //S
  ShaderPrecisionFormatType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LOW_FLOAT:     ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF0);
    public static property MEDIUM_FLOAT:  ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF1);
    public static property HIGH_FLOAT:    ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF2);
    public static property LOW_INT:       ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF3);
    public static property MEDIUM_INT:    ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF4);
    public static property HIGH_INT:      ShaderPrecisionFormatType read new ShaderPrecisionFormatType($8DF5);
    
  end;
  
  //S
  ProgramInterfaceProperty = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_VARIABLES:                      ProgramInterfaceProperty read new ProgramInterfaceProperty($9305);
    public static property BUFFER_BINDING:                        ProgramInterfaceProperty read new ProgramInterfaceProperty($9302);
    public static property NUM_ACTIVE_VARIABLES:                  ProgramInterfaceProperty read new ProgramInterfaceProperty($9304);
    public static property ARRAY_SIZE:                            ProgramInterfaceProperty read new ProgramInterfaceProperty($92FB);
    public static property ARRAY_STRIDE:                          ProgramInterfaceProperty read new ProgramInterfaceProperty($92FE);
    public static property BLOCK_INDEX:                           ProgramInterfaceProperty read new ProgramInterfaceProperty($92FD);
    public static property IS_ROW_MAJOR:                          ProgramInterfaceProperty read new ProgramInterfaceProperty($9300);
    public static property MATRIX_STRIDE:                         ProgramInterfaceProperty read new ProgramInterfaceProperty($92FF);
    public static property ATOMIC_COUNTER_BUFFER_INDEX:           ProgramInterfaceProperty read new ProgramInterfaceProperty($9301);
    public static property BUFFER_DATA_SIZE:                      ProgramInterfaceProperty read new ProgramInterfaceProperty($9303);
    public static property NUM_COMPATIBLE_SUBROUTINES:            ProgramInterfaceProperty read new ProgramInterfaceProperty($8E4A);
    public static property COMPATIBLE_SUBROUTINES:                ProgramInterfaceProperty read new ProgramInterfaceProperty($8E4B);
    public static property IS_PER_PATCH:                          ProgramInterfaceProperty read new ProgramInterfaceProperty($92E7);
    public static property LOCATION:                              ProgramInterfaceProperty read new ProgramInterfaceProperty($930E);
    public static property LOCATION_COMPONENT:                    ProgramInterfaceProperty read new ProgramInterfaceProperty($934A);
    public static property LOCATION_INDEX:                        ProgramInterfaceProperty read new ProgramInterfaceProperty($930F);
    public static property NAME_LENGTH:                           ProgramInterfaceProperty read new ProgramInterfaceProperty($92F9);
    public static property OFFSET:                                ProgramInterfaceProperty read new ProgramInterfaceProperty($92FC);
    public static property REFERENCED_BY_VERTEX_SHADER:           ProgramInterfaceProperty read new ProgramInterfaceProperty($9306);
    public static property REFERENCED_BY_TESS_CONTROL_SHADER:     ProgramInterfaceProperty read new ProgramInterfaceProperty($9307);
    public static property REFERENCED_BY_TESS_EVALUATION_SHADER:  ProgramInterfaceProperty read new ProgramInterfaceProperty($9308);
    public static property REFERENCED_BY_GEOMETRY_SHADER:         ProgramInterfaceProperty read new ProgramInterfaceProperty($9309);
    public static property REFERENCED_BY_FRAGMENT_SHADER:         ProgramInterfaceProperty read new ProgramInterfaceProperty($930A);
    public static property REFERENCED_BY_COMPUTE_SHADER:          ProgramInterfaceProperty read new ProgramInterfaceProperty($930B);
    public static property TRANSFORM_FEEDBACK_BUFFER_INDEX:       ProgramInterfaceProperty read new ProgramInterfaceProperty($934B);
    public static property TRANSFORM_FEEDBACK_BUFFER_STRIDE:      ProgramInterfaceProperty read new ProgramInterfaceProperty($934C);
    public static property TOP_LEVEL_ARRAY_SIZE:                  ProgramInterfaceProperty read new ProgramInterfaceProperty($930C);
    public static property TOP_LEVEL_ARRAY_STRIDE:                ProgramInterfaceProperty read new ProgramInterfaceProperty($930D);
    public static property &TYPE:                                 ProgramInterfaceProperty read new ProgramInterfaceProperty($92FA);
    
//    public static property TEXTURE_BUFFER:                         read new ProgramInterfaceProperty($8C2A); // типа существует, но это не точно
    
  end;
  
  //S
  ProgramInterfaceInfoType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_RESOURCES:                ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F5);
    public static property MAX_NAME_LENGTH:                 ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F6);
    public static property MAX_NUM_ACTIVE_VARIABLES:        ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F7);
    public static property MAX_NUM_COMPATIBLE_SUBROUTINES:  ProgramInterfaceInfoType read new ProgramInterfaceInfoType($92F8);
    
  end;
  
  //S
  ProgramInterfaceType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNIFORM:                             ProgramInterfaceType read new ProgramInterfaceType($92E1);
    public static property UNIFORM_BLOCK:                       ProgramInterfaceType read new ProgramInterfaceType($92E2);
    public static property ATOMIC_COUNTER_BUFFER:               ProgramInterfaceType read new ProgramInterfaceType($92C0);
    public static property PROGRAM_INPUT:                       ProgramInterfaceType read new ProgramInterfaceType($92E3);
    public static property PROGRAM_OUTPUT:                      ProgramInterfaceType read new ProgramInterfaceType($92E4);
    public static property VERTEX_SUBROUTINE:                   ProgramInterfaceType read new ProgramInterfaceType($92E8);
    public static property TESS_CONTROL_SUBROUTINE:             ProgramInterfaceType read new ProgramInterfaceType($92E9);
    public static property TESS_EVALUATION_SUBROUTINE:          ProgramInterfaceType read new ProgramInterfaceType($92EA);
    public static property GEOMETRY_SUBROUTINE:                 ProgramInterfaceType read new ProgramInterfaceType($92EB);
    public static property FRAGMENT_SUBROUTINE:                 ProgramInterfaceType read new ProgramInterfaceType($92EC);
    public static property COMPUTE_SUBROUTINE:                  ProgramInterfaceType read new ProgramInterfaceType($92ED);
    public static property VERTEX_SUBROUTINE_UNIFORM:           ProgramInterfaceType read new ProgramInterfaceType($92EE);
    public static property TESS_CONTROL_SUBROUTINE_UNIFORM:     ProgramInterfaceType read new ProgramInterfaceType($92EF);
    public static property TESS_EVALUATION_SUBROUTINE_UNIFORM:  ProgramInterfaceType read new ProgramInterfaceType($92F0);
    public static property GEOMETRY_SUBROUTINE_UNIFORM:         ProgramInterfaceType read new ProgramInterfaceType($92F1);
    public static property FRAGMENT_SUBROUTINE_UNIFORM:         ProgramInterfaceType read new ProgramInterfaceType($92F2);
    public static property COMPUTE_SUBROUTINE_UNIFORM:          ProgramInterfaceType read new ProgramInterfaceType($92F3);
    public static property TRANSFORM_FEEDBACK_VARYING:          ProgramInterfaceType read new ProgramInterfaceType($92F4);
    public static property BUFFER_VARIABLE:                     ProgramInterfaceType read new ProgramInterfaceType($92E5);
    public static property SHADER_STORAGE_BLOCK:                ProgramInterfaceType read new ProgramInterfaceType($92E6);
    public static property TRANSFORM_FEEDBACK_BUFFER:           ProgramInterfaceType read new ProgramInterfaceType($8C8E);
    
  end;
  
  //S
  ProgramParameterType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SEPARABLE:               ProgramParameterType read new ProgramParameterType($8258);
    public static property BINARY_RETRIEVABLE_HINT: ProgramParameterType read new ProgramParameterType($8257);
    
  end;
  
  //S
  ShaderType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_SHADER:           ShaderType read new ShaderType($8B31);
    public static property TESS_CONTROL_SHADER:     ShaderType read new ShaderType($8E88);
    public static property TESS_EVALUATION_SHADER:  ShaderType read new ShaderType($8E87);
    public static property GEOMETRY_SHADER:         ShaderType read new ShaderType($8DD9);
    public static property FRAGMENT_SHADER:         ShaderType read new ShaderType($8B30);
    public static property COMPUTE_SHADER:          ShaderType read new ShaderType($91B9);
    
  end;
  
  //S
  SyncObjectType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_SYNC_FENCE: SyncObjectType read new SyncObjectType($9116);
    
  end;
  
  //S
  FenceStatus = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property UNSIGNALED:  FenceStatus read new FenceStatus($9118);
    public static property SIGNALED:    FenceStatus read new FenceStatus($9119);
    
  end;
  
  //S
  FenceCondition = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property GL_SYNC_GPU_COMMANDS_COMPLETE: FenceCondition read new FenceCondition($9117);
    
  end;
  
  //S
  BufferBindType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ARRAY_BUFFER:              BufferBindType read new BufferBindType($8892);
    public static property ATOMIC_COUNTER_BUFFER:     BufferBindType read new BufferBindType($92C0);
    public static property COPY_READ_BUFFER:          BufferBindType read new BufferBindType($8F36);
    public static property COPY_WRITE_BUFFER:         BufferBindType read new BufferBindType($8F37);
    public static property DISPATCH_INDIRECT_BUFFER:  BufferBindType read new BufferBindType($90EE);
    public static property DRAW_INDIRECT_BUFFER:      BufferBindType read new BufferBindType($8F3F);
    public static property ELEMENT_ARRAY_BUFFER:      BufferBindType read new BufferBindType($8893);
    public static property PIXEL_PACK_BUFFER:         BufferBindType read new BufferBindType($88EB);
    public static property PIXEL_UNPACK_BUFFER:       BufferBindType read new BufferBindType($88EC);
    public static property QUERY_BUFFER:              BufferBindType read new BufferBindType($9192);
    public static property SHADER_STORAGE_BUFFER:     BufferBindType read new BufferBindType($90D2);
    public static property TEXTURE_BUFFER:            BufferBindType read new BufferBindType($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: BufferBindType read new BufferBindType($8C8E);
    public static property UNIFORM_BUFFER:            BufferBindType read new BufferBindType($8A11);
    
  end;
  
  //S
  CopyableImageType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ARRAY_BUFFER:              CopyableImageType read new CopyableImageType($8892);
    public static property ATOMIC_COUNTER_BUFFER:     CopyableImageType read new CopyableImageType($92C0);
    public static property COPY_READ_BUFFER:          CopyableImageType read new CopyableImageType($8F36);
    public static property COPY_WRITE_BUFFER:         CopyableImageType read new CopyableImageType($8F37);
    public static property DISPATCH_INDIRECT_BUFFER:  CopyableImageType read new CopyableImageType($90EE);
    public static property DRAW_INDIRECT_BUFFER:      CopyableImageType read new CopyableImageType($8F3F);
    public static property ELEMENT_ARRAY_BUFFER:      CopyableImageType read new CopyableImageType($8893);
    public static property PIXEL_PACK_BUFFER:         CopyableImageType read new CopyableImageType($88EB);
    public static property PIXEL_UNPACK_BUFFER:       CopyableImageType read new CopyableImageType($88EC);
    public static property QUERY_BUFFER:              CopyableImageType read new CopyableImageType($9192);
    public static property SHADER_STORAGE_BUFFER:     CopyableImageType read new CopyableImageType($90D2);
    public static property TEXTURE_BUFFER:            CopyableImageType read new CopyableImageType($8C2A);
    public static property TRANSFORM_FEEDBACK_BUFFER: CopyableImageType read new CopyableImageType($8C8E);
    public static property UNIFORM_BUFFER:            CopyableImageType read new CopyableImageType($8A11);
    
    public static property GL_RENDERBUFFER:           CopyableImageType read new CopyableImageType($8D41);
    
  end;
  
  //S
  BufferDataUsage = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property STREAM_DRAW:   BufferDataUsage read new BufferDataUsage($88E0);
    public static property STREAM_READ:   BufferDataUsage read new BufferDataUsage($88E1);
    public static property STREAM_COPY:   BufferDataUsage read new BufferDataUsage($88E2);
    public static property STATIC_DRAW:   BufferDataUsage read new BufferDataUsage($88E4);
    public static property STATIC_READ:   BufferDataUsage read new BufferDataUsage($88E5);
    public static property STATIC_COPY:   BufferDataUsage read new BufferDataUsage($88E6);
    public static property DYNAMIC_DRAW:  BufferDataUsage read new BufferDataUsage($88E8);
    public static property DYNAMIC_READ:  BufferDataUsage read new BufferDataUsage($88E9);
    public static property DYNAMIC_COPY:  BufferDataUsage read new BufferDataUsage($88EA);
    
  end;
  
  //S
  InternalDataFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property R8:        InternalDataFormat read new InternalDataFormat($8229);
    public static property R8I:       InternalDataFormat read new InternalDataFormat($8231);
    public static property R8UI:      InternalDataFormat read new InternalDataFormat($8232);
    public static property R16:       InternalDataFormat read new InternalDataFormat($822A);
    public static property R16I:      InternalDataFormat read new InternalDataFormat($8233);
    public static property R16UI:     InternalDataFormat read new InternalDataFormat($8234);
    public static property R16F:      InternalDataFormat read new InternalDataFormat($822D);
    public static property R32I:      InternalDataFormat read new InternalDataFormat($8235);
    public static property R32UI:     InternalDataFormat read new InternalDataFormat($8236);
    public static property R32F:      InternalDataFormat read new InternalDataFormat($822E);
    
    public static property RG8:       InternalDataFormat read new InternalDataFormat($822B);
    public static property RG8I:      InternalDataFormat read new InternalDataFormat($8237);
    public static property RG8UI:     InternalDataFormat read new InternalDataFormat($8238);
    public static property RG16:      InternalDataFormat read new InternalDataFormat($822C);
    public static property RG16I:     InternalDataFormat read new InternalDataFormat($8239);
    public static property RG16UI:    InternalDataFormat read new InternalDataFormat($823A);
    public static property RG16F:     InternalDataFormat read new InternalDataFormat($822F);
    public static property RG32I:     InternalDataFormat read new InternalDataFormat($823B);
    public static property RG32UI:    InternalDataFormat read new InternalDataFormat($823C);
    public static property RG32F:     InternalDataFormat read new InternalDataFormat($8230);
    
    public static property RGB8:      InternalDataFormat read new InternalDataFormat($8051);
    public static property RGB8I:     InternalDataFormat read new InternalDataFormat($8D8F);
    public static property RGB8UI:    InternalDataFormat read new InternalDataFormat($8D7D);
    public static property RGB16:     InternalDataFormat read new InternalDataFormat($8054);
    public static property RGB16I:    InternalDataFormat read new InternalDataFormat($8D89);
    public static property RGB16UI:   InternalDataFormat read new InternalDataFormat($8D77);
    public static property RGB16F:    InternalDataFormat read new InternalDataFormat($881B);
    public static property RGB32I:    InternalDataFormat read new InternalDataFormat($8D83);
    public static property RGB32UI:   InternalDataFormat read new InternalDataFormat($8D71);
    public static property RGB32F:    InternalDataFormat read new InternalDataFormat($8815);
    
    public static property RGBA8:     InternalDataFormat read new InternalDataFormat($8058);
    public static property RGBA16:    InternalDataFormat read new InternalDataFormat($805B);
    public static property RGBA16F:   InternalDataFormat read new InternalDataFormat($881A);
    public static property RGBA32F:   InternalDataFormat read new InternalDataFormat($8814);
    public static property RGBA8I:    InternalDataFormat read new InternalDataFormat($8D8E);
    public static property RGBA16I:   InternalDataFormat read new InternalDataFormat($8D88);
    public static property RGBA32I:   InternalDataFormat read new InternalDataFormat($8D82);
    public static property RGBA8UI:   InternalDataFormat read new InternalDataFormat($8D7C);
    public static property RGBA16UI:  InternalDataFormat read new InternalDataFormat($8D76);
    public static property RGBA32UI:  InternalDataFormat read new InternalDataFormat($8D70);
    
    public static property RGB4:      InternalDataFormat read new InternalDataFormat($804F);
    public static property RGB5:      InternalDataFormat read new InternalDataFormat($8050);
    public static property RGB10:     InternalDataFormat read new InternalDataFormat($8052);
    public static property RGB12:     InternalDataFormat read new InternalDataFormat($8053);
    public static property RGB5_A1:   InternalDataFormat read new InternalDataFormat($8057);
    public static property RGB10_A2:  InternalDataFormat read new InternalDataFormat($8059);
    
    public static property RGBA2:     InternalDataFormat read new InternalDataFormat($8055);
    public static property RGBA4:     InternalDataFormat read new InternalDataFormat($8056);
    public static property RGBA12:    InternalDataFormat read new InternalDataFormat($805A);
    
  end;
  
  //S
  DataFormat = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property RED:             DataFormat read new DataFormat($1903);
    public static property GREEN:           DataFormat read new DataFormat($1904);
    public static property BLUE:            DataFormat read new DataFormat($1905);
    public static property RG:              DataFormat read new DataFormat($8227);
    public static property RGB:             DataFormat read new DataFormat($1907);
    public static property BGR:             DataFormat read new DataFormat($80E0);
    public static property RGBA:            DataFormat read new DataFormat($1908);
    public static property BGRA:            DataFormat read new DataFormat($80E1);
    public static property RED_INTEGER:     DataFormat read new DataFormat($8D94);
    public static property GREEN_INTEGER:   DataFormat read new DataFormat($8D95);
    public static property BLUE_INTEGER:    DataFormat read new DataFormat($8D96);
    public static property RGB_INTEGER:     DataFormat read new DataFormat($8D98);
    public static property RGBA_INTEGER:    DataFormat read new DataFormat($8D99);
    public static property BGR_INTEGER:     DataFormat read new DataFormat($8D9A);
    public static property BGRA_INTEGER:    DataFormat read new DataFormat($8D9B);
    public static property RG_INTEGER:      DataFormat read new DataFormat($8228);
    public static property STENCIL_INDEX:   DataFormat read new DataFormat($1901);
    public static property DEPTH_COMPONENT: DataFormat read new DataFormat($1902);
    public static property DEPTH_STENCIL:   DataFormat read new DataFormat($84F9);
    
  end;
  
  //S
  GLGetQueries = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property ACTIVE_TEXTURE:                            GLGetQueries read new GLGetQueries($84E0);
    public static property ALIASED_LINE_WIDTH_RANGE:                  GLGetQueries read new GLGetQueries($846E);
    public static property ARRAY_BUFFER_BINDING:                      GLGetQueries read new GLGetQueries($8894);
    public static property BLEND_COLOR:                               GLGetQueries read new GLGetQueries($8005);
    public static property BLEND_DST_ALPHA:                           GLGetQueries read new GLGetQueries($80CA);
    public static property BLEND_DST_RGB:                             GLGetQueries read new GLGetQueries($80C8);
    public static property BLEND_EQUATION_RGB:                        GLGetQueries read new GLGetQueries($8009);
    public static property BLEND_EQUATION_ALPHA:                      GLGetQueries read new GLGetQueries($883D);
    public static property BLEND_SRC_ALPHA:                           GLGetQueries read new GLGetQueries($80CB);
    public static property BLEND_SRC_RGB:                             GLGetQueries read new GLGetQueries($80C9);
    public static property COLOR_CLEAR_VALUE:                         GLGetQueries read new GLGetQueries($0C22);
    public static property COLOR_WRITEMASK:                           GLGetQueries read new GLGetQueries($0C23);
    public static property COMPRESSED_TEXTURE_FORMATS:                GLGetQueries read new GLGetQueries($86A3);
    public static property MAX_COMPUTE_SHADER_STORAGE_BLOCKS:         GLGetQueries read new GLGetQueries($90DB);
    public static property MAX_COMBINED_SHADER_STORAGE_BLOCKS:        GLGetQueries read new GLGetQueries($90DC);
    public static property MAX_COMPUTE_UNIFORM_BLOCKS:                GLGetQueries read new GLGetQueries($91BB);
    public static property MAX_COMPUTE_TEXTURE_IMAGE_UNITS:           GLGetQueries read new GLGetQueries($91BC);
    public static property MAX_COMPUTE_UNIFORM_COMPONENTS:            GLGetQueries read new GLGetQueries($8263);
    public static property MAX_COMPUTE_ATOMIC_COUNTERS:               GLGetQueries read new GLGetQueries($8265);
    public static property MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS:        GLGetQueries read new GLGetQueries($8264);
    public static property MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS:   GLGetQueries read new GLGetQueries($8266);
    public static property MAX_COMPUTE_WORK_GROUP_INVOCATIONS:        GLGetQueries read new GLGetQueries($90EB);
    public static property MAX_COMPUTE_WORK_GROUP_COUNT:              GLGetQueries read new GLGetQueries($91BE);
    public static property MAX_COMPUTE_WORK_GROUP_SIZE:               GLGetQueries read new GLGetQueries($91BF);
    public static property DISPATCH_INDIRECT_BUFFER_BINDING:          GLGetQueries read new GLGetQueries($90EF);
    public static property MAX_DEBUG_GROUP_STACK_DEPTH:               GLGetQueries read new GLGetQueries($826C);
    public static property DEBUG_GROUP_STACK_DEPTH:                   GLGetQueries read new GLGetQueries($826D);
    public static property CONTEXT_FLAGS:                             GLGetQueries read new GLGetQueries($821E);
    public static property CULL_FACE_MODE:                            GLGetQueries read new GLGetQueries($0B45);
    public static property CURRENT_PROGRAM:                           GLGetQueries read new GLGetQueries($8B8D);
    public static property DEPTH_CLEAR_VALUE:                         GLGetQueries read new GLGetQueries($0B73);
    public static property DEPTH_FUNC:                                GLGetQueries read new GLGetQueries($0B74);
    public static property DEPTH_RANGE:                               GLGetQueries read new GLGetQueries($0B70);
    public static property DEPTH_WRITEMASK:                           GLGetQueries read new GLGetQueries($0B72);
    public static property DOUBLEBUFFER:                              GLGetQueries read new GLGetQueries($0C32);
    public static property DRAW_BUFFER:                               GLGetQueries read new GLGetQueries($0C01);
    public static property DRAW_FRAMEBUFFER_BINDING:                  GLGetQueries read new GLGetQueries($8CA6);
    public static property READ_FRAMEBUFFER_BINDING:                  GLGetQueries read new GLGetQueries($8CAA);
    public static property ELEMENT_ARRAY_BUFFER_BINDING:              GLGetQueries read new GLGetQueries($8895);
    public static property FRAGMENT_SHADER_DERIVATIVE_HINT:           GLGetQueries read new GLGetQueries($8B8B);
    public static property IMPLEMENTATION_COLOR_READ_FORMAT:          GLGetQueries read new GLGetQueries($8B9B);
    public static property IMPLEMENTATION_COLOR_READ_TYPE:            GLGetQueries read new GLGetQueries($8B9A);
    public static property LINE_SMOOTH_HINT:                          GLGetQueries read new GLGetQueries($0C52);
    public static property LINE_WIDTH:                                GLGetQueries read new GLGetQueries($0B21);
    public static property LAYER_PROVOKING_VERTEX:                    GLGetQueries read new GLGetQueries($825E);
    public static property LOGIC_OP_MODE:                             GLGetQueries read new GLGetQueries($0BF0);
    public static property MAJOR_VERSION:                             GLGetQueries read new GLGetQueries($821B);
    public static property MAX_3D_TEXTURE_SIZE:                       GLGetQueries read new GLGetQueries($8073);
    public static property MAX_ARRAY_TEXTURE_LAYERS:                  GLGetQueries read new GLGetQueries($88FF);
    public static property MAX_CLIP_DISTANCES:                        GLGetQueries read new GLGetQueries($0D32);
    public static property MAX_COLOR_TEXTURE_SAMPLES:                 GLGetQueries read new GLGetQueries($910E);
    public static property MAX_COMBINED_ATOMIC_COUNTERS:              GLGetQueries read new GLGetQueries($92D7);
    public static property MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS:  GLGetQueries read new GLGetQueries($8A33);
    public static property MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS:  GLGetQueries read new GLGetQueries($8A32);
    public static property MAX_COMBINED_TEXTURE_IMAGE_UNITS:          GLGetQueries read new GLGetQueries($8B4D);
    public static property MAX_COMBINED_UNIFORM_BLOCKS:               GLGetQueries read new GLGetQueries($8A2E);
    public static property MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS:    GLGetQueries read new GLGetQueries($8A31);
    public static property MAX_CUBE_MAP_TEXTURE_SIZE:                 GLGetQueries read new GLGetQueries($851C);
    public static property MAX_DEPTH_TEXTURE_SAMPLES:                 GLGetQueries read new GLGetQueries($910F);
    public static property MAX_DRAW_BUFFERS:                          GLGetQueries read new GLGetQueries($8824);
    public static property MAX_DUAL_SOURCE_DRAW_BUFFERS:              GLGetQueries read new GLGetQueries($88FC);
    public static property MAX_ELEMENTS_INDICES:                      GLGetQueries read new GLGetQueries($80E9);
    public static property MAX_ELEMENTS_VERTICES:                     GLGetQueries read new GLGetQueries($80E8);
    public static property MAX_FRAGMENT_ATOMIC_COUNTERS:              GLGetQueries read new GLGetQueries($92D6);
    public static property MAX_FRAGMENT_SHADER_STORAGE_BLOCKS:        GLGetQueries read new GLGetQueries($90DA);
    public static property MAX_FRAGMENT_INPUT_COMPONENTS:             GLGetQueries read new GLGetQueries($9125);
    public static property MAX_FRAGMENT_UNIFORM_COMPONENTS:           GLGetQueries read new GLGetQueries($8B49);
    public static property MAX_FRAGMENT_UNIFORM_VECTORS:              GLGetQueries read new GLGetQueries($8DFD);
    public static property MAX_FRAGMENT_UNIFORM_BLOCKS:               GLGetQueries read new GLGetQueries($8A2D);
    public static property MAX_FRAMEBUFFER_WIDTH:                     GLGetQueries read new GLGetQueries($9315);
    public static property MAX_FRAMEBUFFER_HEIGHT:                    GLGetQueries read new GLGetQueries($9316);
    public static property MAX_FRAMEBUFFER_LAYERS:                    GLGetQueries read new GLGetQueries($9317);
    public static property MAX_FRAMEBUFFER_SAMPLES:                   GLGetQueries read new GLGetQueries($9318);
    public static property MAX_GEOMETRY_ATOMIC_COUNTERS:              GLGetQueries read new GLGetQueries($92D5);
    public static property MAX_GEOMETRY_SHADER_STORAGE_BLOCKS:        GLGetQueries read new GLGetQueries($90D7);
    public static property MAX_GEOMETRY_INPUT_COMPONENTS:             GLGetQueries read new GLGetQueries($9123);
    public static property MAX_GEOMETRY_OUTPUT_COMPONENTS:            GLGetQueries read new GLGetQueries($9124);
    public static property MAX_GEOMETRY_TEXTURE_IMAGE_UNITS:          GLGetQueries read new GLGetQueries($8C29);
    public static property MAX_GEOMETRY_UNIFORM_BLOCKS:               GLGetQueries read new GLGetQueries($8A2C);
    public static property MAX_GEOMETRY_UNIFORM_COMPONENTS:           GLGetQueries read new GLGetQueries($8DDF);
    public static property MAX_INTEGER_SAMPLES:                       GLGetQueries read new GLGetQueries($9110);
    public static property MIN_MAP_BUFFER_ALIGNMENT:                  GLGetQueries read new GLGetQueries($90BC);
    public static property MAX_LABEL_LENGTH:                          GLGetQueries read new GLGetQueries($82E8);
    public static property MAX_PROGRAM_TEXEL_OFFSET:                  GLGetQueries read new GLGetQueries($8905);
    public static property MIN_PROGRAM_TEXEL_OFFSET:                  GLGetQueries read new GLGetQueries($8904);
    public static property MAX_RECTANGLE_TEXTURE_SIZE:                GLGetQueries read new GLGetQueries($84F8);
    public static property MAX_RENDERBUFFER_SIZE:                     GLGetQueries read new GLGetQueries($84E8);
    public static property MAX_SAMPLE_MASK_WORDS:                     GLGetQueries read new GLGetQueries($8E59);
    public static property MAX_SERVER_WAIT_TIMEOUT:                   GLGetQueries read new GLGetQueries($9111);
    public static property MAX_SHADER_STORAGE_BUFFER_BINDINGS:        GLGetQueries read new GLGetQueries($90DD);
    public static property MAX_TESS_CONTROL_ATOMIC_COUNTERS:          GLGetQueries read new GLGetQueries($92D3);
    public static property MAX_TESS_EVALUATION_ATOMIC_COUNTERS:       GLGetQueries read new GLGetQueries($92D4);
    public static property MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS:    GLGetQueries read new GLGetQueries($90D8);
    public static property MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS: GLGetQueries read new GLGetQueries($90D9);
    public static property MAX_TEXTURE_BUFFER_SIZE:                   GLGetQueries read new GLGetQueries($8C2B);
    public static property MAX_TEXTURE_IMAGE_UNITS:                   GLGetQueries read new GLGetQueries($8872);
    public static property MAX_TEXTURE_LOD_BIAS:                      GLGetQueries read new GLGetQueries($84FD);
    public static property MAX_TEXTURE_SIZE:                          GLGetQueries read new GLGetQueries($0D33);
    public static property MAX_UNIFORM_BUFFER_BINDINGS:               GLGetQueries read new GLGetQueries($8A2F);
    public static property MAX_UNIFORM_BLOCK_SIZE:                    GLGetQueries read new GLGetQueries($8A30);
    public static property MAX_UNIFORM_LOCATIONS:                     GLGetQueries read new GLGetQueries($826E);
    public static property MAX_VARYING_COMPONENTS:                    GLGetQueries read new GLGetQueries($8B4B);
    public static property MAX_VARYING_VECTORS:                       GLGetQueries read new GLGetQueries($8DFC);
    public static property MAX_VARYING_FLOATS:                        GLGetQueries read new GLGetQueries($8B4B);
    public static property MAX_VERTEX_ATOMIC_COUNTERS:                GLGetQueries read new GLGetQueries($92D2);
    public static property MAX_VERTEX_ATTRIBS:                        GLGetQueries read new GLGetQueries($8869);
    public static property MAX_VERTEX_SHADER_STORAGE_BLOCKS:          GLGetQueries read new GLGetQueries($90D6);
    public static property MAX_VERTEX_TEXTURE_IMAGE_UNITS:            GLGetQueries read new GLGetQueries($8B4C);
    public static property MAX_VERTEX_UNIFORM_COMPONENTS:             GLGetQueries read new GLGetQueries($8B4A);
    public static property MAX_VERTEX_UNIFORM_VECTORS:                GLGetQueries read new GLGetQueries($8DFB);
    public static property MAX_VERTEX_OUTPUT_COMPONENTS:              GLGetQueries read new GLGetQueries($9122);
    public static property MAX_VERTEX_UNIFORM_BLOCKS:                 GLGetQueries read new GLGetQueries($8A2B);
    public static property MAX_VIEWPORT_DIMS:                         GLGetQueries read new GLGetQueries($0D3A);
    public static property MAX_VIEWPORTS:                             GLGetQueries read new GLGetQueries($825B);
    public static property MINOR_VERSION:                             GLGetQueries read new GLGetQueries($821C);
    public static property NUM_COMPRESSED_TEXTURE_FORMATS:            GLGetQueries read new GLGetQueries($86A2);
    public static property NUM_EXTENSIONS:                            GLGetQueries read new GLGetQueries($821D);
    public static property NUM_PROGRAM_BINARY_FORMATS:                GLGetQueries read new GLGetQueries($87FE);
    public static property NUM_SHADER_BINARY_FORMATS:                 GLGetQueries read new GLGetQueries($8DF9);
    public static property PACK_ALIGNMENT:                            GLGetQueries read new GLGetQueries($0D05);
    public static property PACK_IMAGE_HEIGHT:                         GLGetQueries read new GLGetQueries($806C);
    public static property PACK_LSB_FIRST:                            GLGetQueries read new GLGetQueries($0D01);
    public static property PACK_ROW_LENGTH:                           GLGetQueries read new GLGetQueries($0D02);
    public static property PACK_SKIP_IMAGES:                          GLGetQueries read new GLGetQueries($806B);
    public static property PACK_SKIP_PIXELS:                          GLGetQueries read new GLGetQueries($0D04);
    public static property PACK_SKIP_ROWS:                            GLGetQueries read new GLGetQueries($0D03);
    public static property PACK_SWAP_BYTES:                           GLGetQueries read new GLGetQueries($0D00);
    public static property PIXEL_PACK_BUFFER_BINDING:                 GLGetQueries read new GLGetQueries($88ED);
    public static property PIXEL_UNPACK_BUFFER_BINDING:               GLGetQueries read new GLGetQueries($88EF);
    public static property POINT_FADE_THRESHOLD_SIZE:                 GLGetQueries read new GLGetQueries($8128);
    public static property PRIMITIVE_RESTART_INDEX:                   GLGetQueries read new GLGetQueries($8F9E);
    public static property PROGRAM_BINARY_FORMATS:                    GLGetQueries read new GLGetQueries($87FF);
    public static property PROGRAM_PIPELINE_BINDING:                  GLGetQueries read new GLGetQueries($825A);
    public static property PROGRAM_POINT_SIZE:                        GLGetQueries read new GLGetQueries($8642);
    public static property PROVOKING_VERTEX:                          GLGetQueries read new GLGetQueries($8E4F);
    public static property POINT_SIZE:                                GLGetQueries read new GLGetQueries($0B11);
    public static property POINT_SIZE_GRANULARITY:                    GLGetQueries read new GLGetQueries($0B13);
    public static property POINT_SIZE_RANGE:                          GLGetQueries read new GLGetQueries($0B12);
    public static property POLYGON_OFFSET_FACTOR:                     GLGetQueries read new GLGetQueries($8038);
    public static property POLYGON_OFFSET_UNITS:                      GLGetQueries read new GLGetQueries($2A00);
    public static property POLYGON_SMOOTH_HINT:                       GLGetQueries read new GLGetQueries($0C53);
    public static property READ_BUFFER:                               GLGetQueries read new GLGetQueries($0C02);
    public static property RENDERBUFFER_BINDING:                      GLGetQueries read new GLGetQueries($8CA7);
    public static property SAMPLE_BUFFERS:                            GLGetQueries read new GLGetQueries($80A8);
    public static property SAMPLE_COVERAGE_VALUE:                     GLGetQueries read new GLGetQueries($80AA);
    public static property SAMPLE_COVERAGE_INVERT:                    GLGetQueries read new GLGetQueries($80AB);
    public static property SAMPLER_BINDING:                           GLGetQueries read new GLGetQueries($8919);
    public static property SAMPLES:                                   GLGetQueries read new GLGetQueries($80A9);
    public static property SCISSOR_BOX:                               GLGetQueries read new GLGetQueries($0C10);
    public static property SHADER_COMPILER:                           GLGetQueries read new GLGetQueries($8DFA);
    public static property SHADER_STORAGE_BUFFER_BINDING:             GLGetQueries read new GLGetQueries($90D3);
    public static property SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT:    GLGetQueries read new GLGetQueries($90DF);
    public static property SHADER_STORAGE_BUFFER_START:               GLGetQueries read new GLGetQueries($90D4);
    public static property SHADER_STORAGE_BUFFER_SIZE:                GLGetQueries read new GLGetQueries($90D5);
    public static property SMOOTH_LINE_WIDTH_RANGE:                   GLGetQueries read new GLGetQueries($0B22);
    public static property SMOOTH_LINE_WIDTH_GRANULARITY:             GLGetQueries read new GLGetQueries($0B23);
    public static property STENCIL_BACK_FAIL:                         GLGetQueries read new GLGetQueries($8801);
    public static property STENCIL_BACK_FUNC:                         GLGetQueries read new GLGetQueries($8800);
    public static property STENCIL_BACK_PASS_DEPTH_FAIL:              GLGetQueries read new GLGetQueries($8802);
    public static property STENCIL_BACK_PASS_DEPTH_PASS:              GLGetQueries read new GLGetQueries($8803);
    public static property STENCIL_BACK_REF:                          GLGetQueries read new GLGetQueries($8CA3);
    public static property STENCIL_BACK_VALUE_MASK:                   GLGetQueries read new GLGetQueries($8CA4);
    public static property STENCIL_BACK_WRITEMASK:                    GLGetQueries read new GLGetQueries($8CA5);
    public static property STENCIL_CLEAR_VALUE:                       GLGetQueries read new GLGetQueries($0B91);
    public static property STENCIL_FAIL:                              GLGetQueries read new GLGetQueries($0B94);
    public static property STENCIL_FUNC:                              GLGetQueries read new GLGetQueries($0B92);
    public static property STENCIL_PASS_DEPTH_FAIL:                   GLGetQueries read new GLGetQueries($0B95);
    public static property STENCIL_PASS_DEPTH_PASS:                   GLGetQueries read new GLGetQueries($0B96);
    public static property STENCIL_REF:                               GLGetQueries read new GLGetQueries($0B97);
    public static property STENCIL_VALUE_MASK:                        GLGetQueries read new GLGetQueries($0B93);
    public static property STENCIL_WRITEMASK:                         GLGetQueries read new GLGetQueries($0B98);
    public static property STEREO:                                    GLGetQueries read new GLGetQueries($0C33);
    public static property SUBPIXEL_BITS:                             GLGetQueries read new GLGetQueries($0D50);
    public static property TEXTURE_BINDING_1D:                        GLGetQueries read new GLGetQueries($8068);
    public static property TEXTURE_BINDING_1D_ARRAY:                  GLGetQueries read new GLGetQueries($8C1C);
    public static property TEXTURE_BINDING_2D:                        GLGetQueries read new GLGetQueries($8069);
    public static property TEXTURE_BINDING_2D_ARRAY:                  GLGetQueries read new GLGetQueries($8C1D);
    public static property TEXTURE_BINDING_2D_MULTISAMPLE:            GLGetQueries read new GLGetQueries($9104);
    public static property TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY:      GLGetQueries read new GLGetQueries($9105);
    public static property TEXTURE_BINDING_3D:                        GLGetQueries read new GLGetQueries($806A);
    public static property TEXTURE_BINDING_BUFFER:                    GLGetQueries read new GLGetQueries($8C2C);
    public static property TEXTURE_BINDING_CUBE_MAP:                  GLGetQueries read new GLGetQueries($8514);
    public static property TEXTURE_BINDING_RECTANGLE:                 GLGetQueries read new GLGetQueries($84F6);
    public static property TEXTURE_COMPRESSION_HINT:                  GLGetQueries read new GLGetQueries($84EF);
    public static property TEXTURE_BUFFER_OFFSET_ALIGNMENT:           GLGetQueries read new GLGetQueries($919F);
    public static property TIMESTAMP:                                 GLGetQueries read new GLGetQueries($8E28);
    public static property TRANSFORM_FEEDBACK_BUFFER_BINDING:         GLGetQueries read new GLGetQueries($8C8F);
    public static property TRANSFORM_FEEDBACK_BUFFER_START:           GLGetQueries read new GLGetQueries($8C84);
    public static property TRANSFORM_FEEDBACK_BUFFER_SIZE:            GLGetQueries read new GLGetQueries($8C85);
    public static property UNIFORM_BUFFER_BINDING:                    GLGetQueries read new GLGetQueries($8A28);
    public static property UNIFORM_BUFFER_OFFSET_ALIGNMENT:           GLGetQueries read new GLGetQueries($8A34);
    public static property UNIFORM_BUFFER_SIZE:                       GLGetQueries read new GLGetQueries($8A2A);
    public static property UNIFORM_BUFFER_START:                      GLGetQueries read new GLGetQueries($8A29);
    public static property UNPACK_ALIGNMENT:                          GLGetQueries read new GLGetQueries($0CF5);
    public static property UNPACK_IMAGE_HEIGHT:                       GLGetQueries read new GLGetQueries($806E);
    public static property UNPACK_LSB_FIRST:                          GLGetQueries read new GLGetQueries($0CF1);
    public static property UNPACK_ROW_LENGTH:                         GLGetQueries read new GLGetQueries($0CF2);
    public static property UNPACK_SKIP_IMAGES:                        GLGetQueries read new GLGetQueries($806D);
    public static property UNPACK_SKIP_PIXELS:                        GLGetQueries read new GLGetQueries($0CF4);
    public static property UNPACK_SKIP_ROWS:                          GLGetQueries read new GLGetQueries($0CF3);
    public static property UNPACK_SWAP_BYTES:                         GLGetQueries read new GLGetQueries($0CF0);
    public static property VERTEX_ARRAY_BINDING:                      GLGetQueries read new GLGetQueries($85B5);
    public static property VERTEX_BINDING_DIVISOR:                    GLGetQueries read new GLGetQueries($82D6);
    public static property VERTEX_BINDING_OFFSET:                     GLGetQueries read new GLGetQueries($82D7);
    public static property VERTEX_BINDING_STRIDE:                     GLGetQueries read new GLGetQueries($82D8);
    public static property MAX_VERTEX_ATTRIB_RELATIVE_OFFSET:         GLGetQueries read new GLGetQueries($82D9);
    public static property MAX_VERTEX_ATTRIB_BINDINGS:                GLGetQueries read new GLGetQueries($82DA);
    public static property VIEWPORT:                                  GLGetQueries read new GLGetQueries($0BA2);
    public static property VIEWPORT_BOUNDS_RANGE:                     GLGetQueries read new GLGetQueries($825D);
    public static property VIEWPORT_INDEX_PROVOKING_VERTEX:           GLGetQueries read new GLGetQueries($825F);
    public static property VIEWPORT_SUBPIXEL_BITS:                    GLGetQueries read new GLGetQueries($825C);
    public static property MAX_ELEMENT_INDEX:                         GLGetQueries read new GLGetQueries($8D6B);
    
  end;
  
  //S
  EnablableName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BLEND:                         EnablableName read new EnablableName($0BE2);
    public static property CLIP_DISTANCE0:                EnablableName read new EnablableName($3000);
    public static property CLIP_DISTANCE1:                EnablableName read new EnablableName($3001);
    public static property CLIP_DISTANCE2:                EnablableName read new EnablableName($3002);
    public static property CLIP_DISTANCE3:                EnablableName read new EnablableName($3003);
    public static property CLIP_DISTANCE4:                EnablableName read new EnablableName($3004);
    public static property CLIP_DISTANCE5:                EnablableName read new EnablableName($3005);
    public static property CLIP_DISTANCE6:                EnablableName read new EnablableName($3006);
    public static property CLIP_DISTANCE7:                EnablableName read new EnablableName($3007);
    public static property COLOR_LOGIC_OP:                EnablableName read new EnablableName($0BF2);
    public static property CULL_FACE:                     EnablableName read new EnablableName($0B44);
    public static property DEBUG_OUTPUT:                  EnablableName read new EnablableName($92E0);
    public static property DEBUG_OUTPUT_SYNCHRONOUS:      EnablableName read new EnablableName($8242);
    public static property DEPTH_CLAMP:                   EnablableName read new EnablableName($864F);
    public static property DEPTH_TEST:                    EnablableName read new EnablableName($0B71);
    public static property DITHER:                        EnablableName read new EnablableName($0BD0);
    public static property FRAMEBUFFER_SRGB:              EnablableName read new EnablableName($8DB9);
    public static property LINE_SMOOTH:                   EnablableName read new EnablableName($0B20);
    public static property MULTISAMPLE:                   EnablableName read new EnablableName($809D);
    public static property POLYGON_OFFSET_FILL:           EnablableName read new EnablableName($8037);
    public static property POLYGON_OFFSET_LINE:           EnablableName read new EnablableName($2A02);
    public static property POLYGON_OFFSET_POINT:          EnablableName read new EnablableName($2A01);
    public static property POLYGON_SMOOTH:                EnablableName read new EnablableName($0B41);
    public static property PRIMITIVE_RESTART:             EnablableName read new EnablableName($8F9D);
    public static property PRIMITIVE_RESTART_FIXED_INDEX: EnablableName read new EnablableName($8D69);
    public static property RASTERIZER_DISCARD:            EnablableName read new EnablableName($8C89);
    public static property SAMPLE_ALPHA_TO_COVERAGE:      EnablableName read new EnablableName($809E);
    public static property SAMPLE_ALPHA_TO_ONE:           EnablableName read new EnablableName($809F);
    public static property SAMPLE_COVERAGE:               EnablableName read new EnablableName($80A0);
    public static property SAMPLE_SHADING:                EnablableName read new EnablableName($8C36);
    public static property SAMPLE_MASK:                   EnablableName read new EnablableName($8E51);
    public static property SCISSOR_TEST:                  EnablableName read new EnablableName($0C11);
    public static property STENCIL_TEST:                  EnablableName read new EnablableName($0B90);
    public static property TEXTURE_CUBE_MAP_SEAMLESS:     EnablableName read new EnablableName($884F);
    public static property PROGRAM_POINT_SIZE:            EnablableName read new EnablableName($8642);
    
    public static function operator implicit(v: EnablableName): GLGetQueries := new GLGetQueries(v.val);
    
  end;
  
  //S
  GLGetStringQueries = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VENDOR:                    GLGetStringQueries read new GLGetStringQueries($1F00);
    public static property RENDERER:                  GLGetStringQueries read new GLGetStringQueries($1F01);
    public static property VERSION:                   GLGetStringQueries read new GLGetStringQueries($1F02);
    public static property EXTENSIONS:                GLGetStringQueries read new GLGetStringQueries($1F03);
    public static property SHADING_LANGUAGE_VERSION:  GLGetStringQueries read new GLGetStringQueries($8B8C);
    
  end;
  
  //SR
  ColorEncodingMode = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property LINEAR:  ColorEncodingMode read new ColorEncodingMode($2601);
    public static property SRGB:    ColorEncodingMode read new ColorEncodingMode($8C40);
    
    public property IS_LINEAR:  boolean read self = ColorEncodingMode.LINEAR;
    public property IS_SRGB:    boolean read self = ColorEncodingMode.SRGB;
    
    public function ToString: string; override;
    begin
      var res := typeof(ColorEncodingMode).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'ColorEncodingMode[{self.val}]':
        res[0].Substring(3);
    end;
    
  end;
  
  //SR
  DataType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property BYTE:                        DataType read new DataType($1400);
    public static property UNSIGNED_BYTE:               DataType read new DataType($1401);
    public static property SHORT:                       DataType read new DataType($1402);
    public static property UNSIGNED_SHORT:              DataType read new DataType($1403);
    public static property INT:                         DataType read new DataType($1404);
    public static property UNSIGNED_INT:                DataType read new DataType($1405);
    public static property FLOAT:                       DataType read new DataType($1406);
    public static property HALF_FLOAT:                  DataType read new DataType($140B);
    public static property UNSIGNED_BYTE_3_3_2:         DataType read new DataType($8032);
    public static property UNSIGNED_SHORT_5_6_5:        DataType read new DataType($8363);
    public static property UNSIGNED_SHORT_4_4_4_4:      DataType read new DataType($8033);
    public static property UNSIGNED_SHORT_5_5_5_1:      DataType read new DataType($8034);
    public static property UNSIGNED_INT_8_8_8_8:        DataType read new DataType($8035);
    public static property UNSIGNED_INT_10_10_10_2:     DataType read new DataType($8036);
    public static property UNSIGNED_BYTE_2_3_3_REV:     DataType read new DataType($8362);
    public static property UNSIGNED_SHORT_5_6_5_REV:    DataType read new DataType($8364);
    public static property UNSIGNED_SHORT_4_4_4_4_REV:  DataType read new DataType($8365);
    public static property UNSIGNED_SHORT_1_5_5_5_REV:  DataType read new DataType($8366);
    public static property UNSIGNED_INT_8_8_8_8_REV:    DataType read new DataType($8367);
    public static property UNSIGNED_INT_2_10_10_10_REV: DataType read new DataType($8368);
    public static property SIGNED_NORMALIZED:           DataType read new DataType($8F9C);
    public static property UNSIGNED_NORMALIZED:         DataType read new DataType($8C17);
    
    public property IS_NONE:                        boolean read self.val = 0;
    public property IS_BYTE:                        boolean read self.val = BYTE.val;
    public property IS_UNSIGNED_BYTE:               boolean read self.val = UNSIGNED_BYTE.val;
    public property IS_SHORT:                       boolean read self.val = SHORT.val;
    public property IS_UNSIGNED_SHORT:              boolean read self.val = UNSIGNED_SHORT.val;
    public property IS_INT:                         boolean read self.val = INT.val;
    public property IS_UNSIGNED_INT:                boolean read self.val = UNSIGNED_INT.val;
    public property IS_FLOAT:                       boolean read self.val = FLOAT.val;
    public property IS_HALF_FLOAT:                  boolean read self.val = HALF_FLOAT.val;
    public property IS_UNSIGNED_BYTE_3_3_2:         boolean read self.val = UNSIGNED_BYTE_3_3_2.val;
    public property IS_UNSIGNED_SHORT_5_6_5:        boolean read self.val = UNSIGNED_SHORT_5_6_5.val;
    public property IS_UNSIGNED_SHORT_4_4_4_4:      boolean read self.val = UNSIGNED_SHORT_4_4_4_4.val;
    public property IS_UNSIGNED_SHORT_5_5_5_1:      boolean read self.val = UNSIGNED_SHORT_5_5_5_1.val;
    public property IS_UNSIGNED_INT_8_8_8_8:        boolean read self.val = UNSIGNED_INT_8_8_8_8.val;
    public property IS_UNSIGNED_INT_10_10_10_2:     boolean read self.val = UNSIGNED_INT_10_10_10_2.val;
    public property IS_UNSIGNED_BYTE_2_3_3_REV:     boolean read self.val = UNSIGNED_BYTE_2_3_3_REV.val;
    public property IS_UNSIGNED_SHORT_5_6_5_REV:    boolean read self.val = UNSIGNED_SHORT_5_6_5_REV.val;
    public property IS_UNSIGNED_SHORT_4_4_4_4_REV:  boolean read self.val = UNSIGNED_SHORT_4_4_4_4_REV.val;
    public property IS_UNSIGNED_SHORT_1_5_5_5_REV:  boolean read self.val = UNSIGNED_SHORT_1_5_5_5_REV.val;
    public property IS_UNSIGNED_INT_8_8_8_8_REV:    boolean read self.val = UNSIGNED_INT_8_8_8_8_REV.val;
    public property IS_UNSIGNED_INT_2_10_10_10_REV: boolean read self.val = UNSIGNED_INT_2_10_10_10_REV.val;
    public property IS_SIGNED_NORMALIZED:           boolean read self.val = SIGNED_NORMALIZED.val;
    public property IS_UNSIGNED_NORMALIZED:         boolean read self.val = UNSIGNED_NORMALIZED.val;
    
    public function ToString: string; override;
    begin
      var res := typeof(DataType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DataType[{self.val}]':
        res[0].Substring(3);
    end;
    
  end;
  
  //R
  ProgramVarType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property FLOAT:             boolean read self.val = $1406;
    public property FLOAT_VEC2:        boolean read self.val = $8B50;
    public property FLOAT_VEC3:        boolean read self.val = $8B51;
    public property FLOAT_VEC4:        boolean read self.val = $8B52;
    public property FLOAT_MAT2:        boolean read self.val = $8B5A;
    public property FLOAT_MAT3:        boolean read self.val = $8B5B;
    public property FLOAT_MAT4:        boolean read self.val = $8B5C;
    public property FLOAT_MAT2x3:      boolean read self.val = $8B65;
    public property FLOAT_MAT3x2:      boolean read self.val = $8B67;
    public property FLOAT_MAT2x4:      boolean read self.val = $8B66;
    public property FLOAT_MAT4x2:      boolean read self.val = $8B69;
    public property FLOAT_MAT3x4:      boolean read self.val = $8B68;
    public property FLOAT_MAT4x3:      boolean read self.val = $8B6A;
    public property INT:               boolean read self.val = $1404;
    public property INT_VEC2:          boolean read self.val = $8B53;
    public property INT_VEC3:          boolean read self.val = $8B54;
    public property INT_VEC4:          boolean read self.val = $8B55;
    public property UNSIGNED_INT:      boolean read self.val = $1405;
    public property UNSIGNED_INT_VEC2: boolean read self.val = $8DC6;
    public property UNSIGNED_INT_VEC3: boolean read self.val = $8DC7;
    public property UNSIGNED_INT_VEC4: boolean read self.val = $8DC8;
    public property DOUBLE:            boolean read self.val = $140A;
    public property DOUBLE_VEC2:       boolean read self.val = $8FFC;
    public property DOUBLE_VEC3:       boolean read self.val = $8FFD;
    public property DOUBLE_VEC4:       boolean read self.val = $8FFE;
    public property DOUBLE_MAT2:       boolean read self.val = $8F46;
    public property DOUBLE_MAT3:       boolean read self.val = $8F47;
    public property DOUBLE_MAT4:       boolean read self.val = $8F48;
    public property DOUBLE_MAT2x3:     boolean read self.val = $8F49;
    public property DOUBLE_MAT3x2:     boolean read self.val = $8F4B;
    public property DOUBLE_MAT2x4:     boolean read self.val = $8F4A;
    public property DOUBLE_MAT4x2:     boolean read self.val = $8F4D;
    public property DOUBLE_MAT3x4:     boolean read self.val = $8F4C;
    public property DOUBLE_MAT4x3:     boolean read self.val = $8F4E;
    
    public function ToString: string; override;
    begin
      var res := typeof(ProgramVarType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'ProgramVarType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  FramebufferAttachmentObjectType = record
    public val: UInt32;
    
    public property NONE:                boolean read self.val = 0;
    public property FRAMEBUFFER_DEFAULT: boolean read self.val = $8218;
    public property TEXTURE:             boolean read self.val = $1702;
    public property RENDERBUFFER:        boolean read self.val = $8D41;
    
    public function ToString: string; override;
    begin
      var res := typeof(FramebufferAttachmentObjectType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'FramebufferAttachmentObjectType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  ClientWaitSyncResult = record
    public val: UInt32;
    
    public property ALREADY_SIGNALED:    boolean read self.val = $911A;
    public property TIMEOUT_EXPIRED:     boolean read self.val = $911B;
    public property CONDITION_SATISFIED: boolean read self.val = $911C;
    public property WAIT_FAILED:         boolean read self.val = $911D;
    
    public function ToString: string; override;
    begin
      var res := typeof(ClientWaitSyncResult).GetProperties.Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'ClientWaitSyncResult[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  ShadingLanguageTypeToken = record
    public val: UInt32;
    
    public property FLOAT:                                     boolean read self.val = $1406;
    public property FLOAT_VEC2:                                boolean read self.val = $8B50;
    public property FLOAT_VEC3:                                boolean read self.val = $8B51;
    public property FLOAT_VEC4:                                boolean read self.val = $8B52;
    public property DOUBLE:                                    boolean read self.val = $140A;
    public property DOUBLE_VEC2:                               boolean read self.val = $8FFC;
    public property DOUBLE_VEC3:                               boolean read self.val = $8FFD;
    public property DOUBLE_VEC4:                               boolean read self.val = $8FFE;
    public property INT:                                       boolean read self.val = $1404;
    public property INT_VEC2:                                  boolean read self.val = $8B53;
    public property INT_VEC3:                                  boolean read self.val = $8B54;
    public property INT_VEC4:                                  boolean read self.val = $8B55;
    public property UNSIGNED_INT:                              boolean read self.val = $1405;
    public property UNSIGNED_INT_VEC2:                         boolean read self.val = $8DC6;
    public property UNSIGNED_INT_VEC3:                         boolean read self.val = $8DC7;
    public property UNSIGNED_INT_VEC4:                         boolean read self.val = $8DC8;
    public property BOOL:                                      boolean read self.val = $8B56;
    public property BOOL_VEC2:                                 boolean read self.val = $8B57;
    public property BOOL_VEC3:                                 boolean read self.val = $8B58;
    public property BOOL_VEC4:                                 boolean read self.val = $8B59;
    public property FLOAT_MAT2:                                boolean read self.val = $8B5A;
    public property FLOAT_MAT3:                                boolean read self.val = $8B5B;
    public property FLOAT_MAT4:                                boolean read self.val = $8B5C;
    public property FLOAT_MAT2x3:                              boolean read self.val = $8B65;
    public property FLOAT_MAT2x4:                              boolean read self.val = $8B66;
    public property FLOAT_MAT3x2:                              boolean read self.val = $8B67;
    public property FLOAT_MAT3x4:                              boolean read self.val = $8B68;
    public property FLOAT_MAT4x2:                              boolean read self.val = $8B69;
    public property FLOAT_MAT4x3:                              boolean read self.val = $8B6A;
    public property DOUBLE_MAT2:                               boolean read self.val = $8F46;
    public property DOUBLE_MAT3:                               boolean read self.val = $8F47;
    public property DOUBLE_MAT4:                               boolean read self.val = $8F48;
    public property DOUBLE_MAT2x3:                             boolean read self.val = $8F49;
    public property DOUBLE_MAT2x4:                             boolean read self.val = $8F4A;
    public property DOUBLE_MAT3x2:                             boolean read self.val = $8F4B;
    public property DOUBLE_MAT3x4:                             boolean read self.val = $8F4C;
    public property DOUBLE_MAT4x2:                             boolean read self.val = $8F4D;
    public property DOUBLE_MAT4x3:                             boolean read self.val = $8F4E;
    public property SAMPLER_1D:                                boolean read self.val = $8B5D;
    public property SAMPLER_2D:                                boolean read self.val = $8B5E;
    public property SAMPLER_3D:                                boolean read self.val = $8B5F;
    public property SAMPLER_CUBE:                              boolean read self.val = $8B60;
    public property SAMPLER_1D_SHADOW:                         boolean read self.val = $8B61;
    public property SAMPLER_2D_SHADOW:                         boolean read self.val = $8B62;
    public property SAMPLER_1D_ARRAY:                          boolean read self.val = $8DC0;
    public property SAMPLER_2D_ARRAY:                          boolean read self.val = $8DC1;
    public property SAMPLER_CUBE_MAP_ARRAY:                    boolean read self.val = $900C;
    public property SAMPLER_1D_ARRAY_SHADOW:                   boolean read self.val = $8DC3;
    public property SAMPLER_2D_ARRAY_SHADOW:                   boolean read self.val = $8DC4;
    public property SAMPLER_2D_MULTISAMPLE:                    boolean read self.val = $9108;
    public property SAMPLER_2D_MULTISAMPLE_ARRAY:              boolean read self.val = $910B;
    public property SAMPLER_CUBE_SHADOW:                       boolean read self.val = $8DC5;
    public property SAMPLER_CUBE_MAP_ARRAY_SHADOW:             boolean read self.val = $900D;
    public property SAMPLER_BUFFER:                            boolean read self.val = $8DC2;
    public property SAMPLER_2D_RECT:                           boolean read self.val = $8B63;
    public property SAMPLER_2D_RECT_SHADOW:                    boolean read self.val = $8B64;
    public property INT_SAMPLER_1D:                            boolean read self.val = $8DC9;
    public property INT_SAMPLER_2D:                            boolean read self.val = $8DCA;
    public property INT_SAMPLER_3D:                            boolean read self.val = $8DCB;
    public property INT_SAMPLER_CUBE:                          boolean read self.val = $8DCC;
    public property INT_SAMPLER_1D_ARRAY:                      boolean read self.val = $8DCE;
    public property INT_SAMPLER_2D_ARRAY:                      boolean read self.val = $8DCF;
    public property INT_SAMPLER_CUBE_MAP_ARRAY:                boolean read self.val = $900E;
    public property INT_SAMPLER_2D_MULTISAMPLE:                boolean read self.val = $9109;
    public property INT_SAMPLER_2D_MULTISAMPLE_ARRAY:          boolean read self.val = $910C;
    public property INT_SAMPLER_BUFFER:                        boolean read self.val = $8DD0;
    public property INT_SAMPLER_2D_RECT:                       boolean read self.val = $8DCD;
    public property UNSIGNED_INT_SAMPLER_1D:                   boolean read self.val = $8DD1;
    public property UNSIGNED_INT_SAMPLER_2D:                   boolean read self.val = $8DD2;
    public property UNSIGNED_INT_SAMPLER_3D:                   boolean read self.val = $8DD3;
    public property UNSIGNED_INT_SAMPLER_CUBE:                 boolean read self.val = $8DD4;
    public property UNSIGNED_INT_SAMPLER_1D_ARRAY:             boolean read self.val = $8DD6;
    public property UNSIGNED_INT_SAMPLER_2D_ARRAY:             boolean read self.val = $8DD7;
    public property UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY:       boolean read self.val = $900F;
    public property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE:       boolean read self.val = $910A;
    public property UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY: boolean read self.val = $910D;
    public property UNSIGNED_INT_SAMPLER_BUFFER:               boolean read self.val = $8DD8;
    public property UNSIGNED_INT_SAMPLER_2D_RECT:              boolean read self.val = $8DD5;
    public property IMAGE_1D:                                  boolean read self.val = $904C;
    public property IMAGE_2D:                                  boolean read self.val = $904D;
    public property IMAGE_3D:                                  boolean read self.val = $904E;
    public property IMAGE_2D_RECT:                             boolean read self.val = $904F;
    public property IMAGE_CUBE:                                boolean read self.val = $9050;
    public property IMAGE_BUFFER:                              boolean read self.val = $9051;
    public property IMAGE_1D_ARRAY:                            boolean read self.val = $9052;
    public property IMAGE_2D_ARRAY:                            boolean read self.val = $9053;
    public property IMAGE_CUBE_MAP_ARRAY:                      boolean read self.val = $9054;
    public property IMAGE_2D_MULTISAMPLE:                      boolean read self.val = $9055;
    public property IMAGE_2D_MULTISAMPLE_ARRAY:                boolean read self.val = $9056;
    public property INT_IMAGE_1D:                              boolean read self.val = $9057;
    public property INT_IMAGE_2D:                              boolean read self.val = $9058;
    public property INT_IMAGE_3D:                              boolean read self.val = $9059;
    public property INT_IMAGE_2D_RECT:                         boolean read self.val = $905A;
    public property INT_IMAGE_CUBE:                            boolean read self.val = $905B;
    public property INT_IMAGE_BUFFER:                          boolean read self.val = $905C;
    public property INT_IMAGE_1D_ARRAY:                        boolean read self.val = $905D;
    public property INT_IMAGE_2D_ARRAY:                        boolean read self.val = $905E;
    public property INT_IMAGE_CUBE_MAP_ARRAY:                  boolean read self.val = $905F;
    public property INT_IMAGE_2D_MULTISAMPLE:                  boolean read self.val = $9060;
    public property INT_IMAGE_2D_MULTISAMPLE_ARRAY:            boolean read self.val = $9061;
    public property UNSIGNED_INT_IMAGE_1D:                     boolean read self.val = $9062;
    public property UNSIGNED_INT_IMAGE_2D:                     boolean read self.val = $9063;
    public property UNSIGNED_INT_IMAGE_3D:                     boolean read self.val = $9064;
    public property UNSIGNED_INT_IMAGE_2D_RECT:                boolean read self.val = $9065;
    public property UNSIGNED_INT_IMAGE_CUBE:                   boolean read self.val = $9066;
    public property UNSIGNED_INT_IMAGE_BUFFER:                 boolean read self.val = $9067;
    public property UNSIGNED_INT_IMAGE_1D_ARRAY:               boolean read self.val = $9068;
    public property UNSIGNED_INT_IMAGE_2D_ARRAY:               boolean read self.val = $9069;
    public property UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY:         boolean read self.val = $906A;
    public property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE:         boolean read self.val = $906B;
    public property UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY:   boolean read self.val = $906C;
    public property UNSIGNED_INT_ATOMIC_COUNTER:               boolean read self.val = $92DB;
    
  end;
  
  //R
  DebugSourceType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property API:                 boolean read self.val = $8246;
    public property WINDOW_SYSTEM:       boolean read self.val = $8247;
    public property SHADER_COMPILER:     boolean read self.val = $8248;
    public property THIRD_PARTY:         boolean read self.val = $8249;
    public property APPLICATION:         boolean read self.val = $824A;
    public property OTHER:               boolean read self.val = $824B;
    public property API_ARB:             boolean read self.val = $8246;
    public property WINDOW_SYSTEM_ARB:   boolean read self.val = $8247;
    public property SHADER_COMPILER_ARB: boolean read self.val = $8248;
    public property THIRD_PARTY_ARB:     boolean read self.val = $8249;
    public property APPLICATION_ARB:     boolean read self.val = $824A;
    public property OTHER_ARB:           boolean read self.val = $824B;
    
    public function ToString: string; override;
    begin
      var res := typeof(DebugSourceType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DebugSourceType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  DebugMessageType = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property ERROR:               boolean read self.val = $824C;
    public property DEPRECATED_BEHAVIOR: boolean read self.val = $824D;
    public property UNDEFINED_BEHAVIOR:  boolean read self.val = $824E;
    public property PORTABILITY:         boolean read self.val = $824F;
    public property PERFORMANCE:         boolean read self.val = $8250;
    public property OTHER:               boolean read self.val = $8251;
    public property MARKER:              boolean read self.val = $8268;
    public property PUSH_GROUP:          boolean read self.val = $8269;
    public property POP_GROUP:           boolean read self.val = $826A;
    
    public function ToString: string; override;
    begin
      var res := typeof(DebugMessageType).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DebugMessageType[{self.val}]':
        res[0];
    end;
    
  end;
  
  //R
  DebugSeverityLevel = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public property HIGH:          boolean read self.val = $9146;
    public property MEDIUM:        boolean read self.val = $9147;
    public property LOW:           boolean read self.val = $9148;
    public property NOTIFICATION:  boolean read self.val = $826B;
    
    public function ToString: string; override;
    begin
      var res := typeof(DebugSeverityLevel).GetProperties.Where(prop->prop.PropertyType=typeof(boolean)).Select(prop->(prop.Name,boolean(prop.GetValue(self)))).FirstOrDefault(t->t[1]);
      Result := res=nil?
        $'DebugSeverityLevel[{self.val}]':
        res[0];
    end;
    
  end;
  
  {$endregion 1 значение}
  
  {$region Флаги}
  
  //S
  GDI_PixelFormatFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property DOUBLEBUFFER:          GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000001);
    public static property STEREO:                GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000002);
    public static property DRAW_TO_WINDOW:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000004);
    public static property DRAW_TO_BITMAP:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000008);
    public static property SUPPORT_GDI:           GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000010);
    public static property SUPPORT_OPENGL:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000020);
    public static property GENERIC_FORMAT:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000040);
    public static property NEED_PALETTE:          GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000080);
    public static property NEED_SYSTEM_PALETTE:   GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000100);
    public static property SWAP_EXCHANGE:         GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000200);
    public static property SWAP_COPY:             GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000400);
    public static property SWAP_LAYER_BUFFERS:    GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00000800);
    public static property GENERIC_ACCELERATED:   GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00001000);
    public static property SUPPORT_DIRECTDRAW:    GDI_PixelFormatFlags read new GDI_PixelFormatFlags($00002000);
    public static property DEPTH_DONTCARE:        GDI_PixelFormatFlags read new GDI_PixelFormatFlags($20000000);
    public static property DOUBLEBUFFER_DONTCARE: GDI_PixelFormatFlags read new GDI_PixelFormatFlags($40000000);
    public static property STEREO_DONTCARE:       GDI_PixelFormatFlags read new GDI_PixelFormatFlags($80000000);
    
    public static function operator or(v1,v2: GDI_PixelFormatFlags): GDI_PixelFormatFlags := new GDI_PixelFormatFlags(v1.val or v2.val);
    
  end;
  
  //S
  BufferTypeFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property COLOR_BUFFER_BIT:    BufferTypeFlags read new BufferTypeFlags($00004000);
    public static property DEPTH_BUFFER_BIT:    BufferTypeFlags read new BufferTypeFlags($00000100);
    public static property STENCIL_BUFFER_BIT:  BufferTypeFlags read new BufferTypeFlags($00000400);
    
    public static function operator or(f1,f2: BufferTypeFlags): BufferTypeFlags := new BufferTypeFlags(f1.val or f2.val);
    
  end;
  
  //S
  MemoryBarrierTypeFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_ATTRIB_ARRAY_BARRIER_BIT: MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000001);
    public static property ELEMENT_ARRAY_BARRIER_BIT:       MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000002);
    public static property UNIFORM_BARRIER_BIT:             MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000004);
    public static property TEXTURE_FETCH_BARRIER_BIT:       MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000008);
    public static property SHADER_IMAGE_ACCESS_BARRIER_BIT: MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000020);
    public static property COMMAND_BARRIER_BIT:             MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000040);
    public static property PIXEL_BUFFER_BARRIER_BIT:        MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000080);
    public static property TEXTURE_UPDATE_BARRIER_BIT:      MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000100);
    public static property BUFFER_UPDATE_BARRIER_BIT:       MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000200);
    public static property FRAMEBUFFER_BARRIER_BIT:         MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000400);
    public static property TRANSFORM_FEEDBACK_BARRIER_BIT:  MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00000800);
    public static property ATOMIC_COUNTER_BARRIER_BIT:      MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00001000);
    public static property SHADER_STORAGE_BARRIER_BIT:      MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00002000);
    public static property QUERY_BUFFER_BARRIER_BIT:        MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($00008000);
    public static property ALL_BARRIER_BITS:                MemoryBarrierTypeFlags read new MemoryBarrierTypeFlags($FFFFFFFF);
    
    public static function operator or(f1,f2: MemoryBarrierTypeFlags): MemoryBarrierTypeFlags := new MemoryBarrierTypeFlags(f1.val or f2.val);
    
  end;
  
  //S
  ProgramStagesFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property VERTEX_SHADER_BIT:           ProgramStagesFlags read new ProgramStagesFlags($00000001);
    public static property FRAGMENT_SHADER_BIT:         ProgramStagesFlags read new ProgramStagesFlags($00000002);
    public static property GEOMETRY_SHADER_BIT:         ProgramStagesFlags read new ProgramStagesFlags($00000004);
    public static property TESS_CONTROL_SHADER_BIT:     ProgramStagesFlags read new ProgramStagesFlags($00000008);
    public static property TESS_EVALUATION_SHADER_BIT:  ProgramStagesFlags read new ProgramStagesFlags($00000010);
    public static property COMPUTE_SHADER_BIT:          ProgramStagesFlags read new ProgramStagesFlags($00000020);
    public static property ALL_SHADER_BITS:             ProgramStagesFlags read new ProgramStagesFlags($FFFFFFFF);
    
    public static function operator or(f1,f2: ProgramStagesFlags): ProgramStagesFlags := new ProgramStagesFlags(f1.val or f2.val);
    
  end;
  
  //S
  ReservedFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property NONE: ReservedFlags read new ReservedFlags($0);
    
    public static function operator or(f1,f2: ReservedFlags): ReservedFlags := new ReservedFlags(f1.val or f2.val);
    
  end;
  
  //S
  CommandFlushingBehaviorFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property SYNC_FLUSH_COMMANDS:  CommandFlushingBehaviorFlags read new CommandFlushingBehaviorFlags($00000001);
    
    public static function operator or(f1,f2: CommandFlushingBehaviorFlags): CommandFlushingBehaviorFlags := new CommandFlushingBehaviorFlags(f1.val or f2.val);
    
  end;
  
  //S
  BufferMapFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    public static property READ_BIT:              BufferMapFlags read new BufferMapFlags($0001);
    public static property WRITE_BIT:             BufferMapFlags read new BufferMapFlags($0002);
    public static property INVALIDATE_RANGE_BIT:  BufferMapFlags read new BufferMapFlags($0004);
    public static property INVALIDATE_BUFFER_BIT: BufferMapFlags read new BufferMapFlags($0008);
    public static property FLUSH_EXPLICIT_BIT:    BufferMapFlags read new BufferMapFlags($0010);
    public static property UNSYNCHRONIZED_BIT:    BufferMapFlags read new BufferMapFlags($0020);
    public static property PERSISTENT_BIT:        BufferMapFlags read new BufferMapFlags($0040);
    public static property COHERENT_BIT:          BufferMapFlags read new BufferMapFlags($0080);
    
    public static function operator or(f1,f2: BufferMapFlags): BufferMapFlags := new BufferMapFlags(f1.val or f2.val);
    
  end;
  
  //S
  BufferStorageFlags = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
//    public static property NONE:                BufferStorageFlags read new BufferStorageFlags(0); //ToDo узнать надо ли
    public static property MAP_READ_BIT:        BufferStorageFlags read new BufferStorageFlags($0001);
    public static property MAP_WRITE_BIT:       BufferStorageFlags read new BufferStorageFlags($0002);
    public static property MAP_PERSISTENT_BIT:  BufferStorageFlags read new BufferStorageFlags($0040);
    public static property MAP_COHERENT_BIT:    BufferStorageFlags read new BufferStorageFlags($0080);
    public static property DYNAMIC_STORAGE_BIT: BufferStorageFlags read new BufferStorageFlags($0100);
    public static property CLIENT_STORAGE_BIT:  BufferStorageFlags read new BufferStorageFlags($0200);
    
    public static function operator or(f1,f2: BufferStorageFlags): BufferStorageFlags := new BufferStorageFlags(f1.val or f2.val);
    
  end;
  
  {$endregion Флаги}
  
{$endregion Энумы}

{$region Делегаты} type
  
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  GLDEBUGPROC = procedure(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; message_text: IntPtr; userParam: pointer);
  
  [UnmanagedFunctionPointer(CallingConvention.StdCall)]
  GLVULKANPROCNV = procedure;
  
{$endregion Делегаты}

{$region Записи} type
  
  {$region Vec}
  
  {$region Vec1}
  
  Vec1b = record
    public val0: SByte;
    
    public constructor(val0: SByte);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1b): Vec1b := new Vec1b(-v.val0);
    public static function operator*(v: Vec1b; k: SByte): Vec1b := new Vec1b(v.val0*k);
    public static function operator+(v1, v2: Vec1b): Vec1b := new Vec1b(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1b): Vec1b := new Vec1b(v1.val0-v2.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1ub = record
    public val0: Byte;
    
    public constructor(val0: Byte);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1ub; k: Byte): Vec1ub := new Vec1ub(v.val0*k);
    public static function operator+(v1, v2: Vec1ub): Vec1ub := new Vec1ub(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1ub): Vec1ub := new Vec1ub(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1ub := new Vec1ub(v.val0);
    public static function operator implicit(v: Vec1ub): Vec1b := new Vec1b(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1s = record
    public val0: Int16;
    
    public constructor(val0: Int16);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1s): Vec1s := new Vec1s(-v.val0);
    public static function operator*(v: Vec1s; k: Int16): Vec1s := new Vec1s(v.val0*k);
    public static function operator+(v1, v2: Vec1s): Vec1s := new Vec1s(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1s): Vec1s := new Vec1s(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1s := new Vec1s(v.val0);
    public static function operator implicit(v: Vec1s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1s := new Vec1s(v.val0);
    public static function operator implicit(v: Vec1s): Vec1ub := new Vec1ub(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1us = record
    public val0: UInt16;
    
    public constructor(val0: UInt16);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1us; k: UInt16): Vec1us := new Vec1us(v.val0*k);
    public static function operator+(v1, v2: Vec1us): Vec1us := new Vec1us(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1us): Vec1us := new Vec1us(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1us := new Vec1us(v.val0);
    public static function operator implicit(v: Vec1us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1us := new Vec1us(v.val0);
    public static function operator implicit(v: Vec1us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1us := new Vec1us(v.val0);
    public static function operator implicit(v: Vec1us): Vec1s := new Vec1s(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1i = record
    public val0: Int32;
    
    public constructor(val0: Int32);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1i): Vec1i := new Vec1i(-v.val0);
    public static function operator*(v: Vec1i; k: Int32): Vec1i := new Vec1i(v.val0*k);
    public static function operator+(v1, v2: Vec1i): Vec1i := new Vec1i(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1i): Vec1i := new Vec1i(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1i := new Vec1i(v.val0);
    public static function operator implicit(v: Vec1i): Vec1us := new Vec1us(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1ui = record
    public val0: UInt32;
    
    public constructor(val0: UInt32);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1ui; k: UInt32): Vec1ui := new Vec1ui(v.val0*k);
    public static function operator+(v1, v2: Vec1ui): Vec1ui := new Vec1ui(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1ui): Vec1ui := new Vec1ui(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec1ui := new Vec1ui(v.val0);
    public static function operator implicit(v: Vec1ui): Vec1i := new Vec1i(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1i64 = record
    public val0: Int64;
    
    public constructor(val0: Int64);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1i64): Vec1i64 := new Vec1i64(-v.val0);
    public static function operator*(v: Vec1i64; k: Int64): Vec1i64 := new Vec1i64(v.val0*k);
    public static function operator+(v1, v2: Vec1i64): Vec1i64 := new Vec1i64(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1i64): Vec1i64 := new Vec1i64(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec1i64 := new Vec1i64(v.val0);
    public static function operator implicit(v: Vec1i64): Vec1ui := new Vec1ui(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1ui64 = record
    public val0: UInt64;
    
    public constructor(val0: UInt64);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec1ui64; k: UInt64): Vec1ui64 := new Vec1ui64(v.val0*k);
    public static function operator+(v1, v2: Vec1ui64): Vec1ui64 := new Vec1ui64(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1ui64): Vec1ui64 := new Vec1ui64(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec1ui64 := new Vec1ui64(v.val0);
    public static function operator implicit(v: Vec1ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1f = record
    public val0: single;
    
    public constructor(val0: single);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1f): Vec1f := new Vec1f(-v.val0);
    public static function operator*(v: Vec1f; k: single): Vec1f := new Vec1f(v.val0*k);
    public static function operator/(v: Vec1f; k: single): Vec1f := new Vec1f(v.val0/k);
    public static function operator+(v1, v2: Vec1f): Vec1f := new Vec1f(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1f): Vec1f := new Vec1f(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec1f := new Vec1f(v.val0);
    public static function operator implicit(v: Vec1f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public function SqrLength := val0*val0;
    
    public function SqrLength_d: double := real(val0)*val0;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec1d = record
    public val0: double;
    
    public constructor(val0: double);
    begin
      self.val0 := val0;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 0 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..0');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec1d): Vec1d := new Vec1d(-v.val0);
    public static function operator*(v: Vec1d; k: double): Vec1d := new Vec1d(v.val0*k);
    public static function operator/(v: Vec1d; k: double): Vec1d := new Vec1d(v.val0/k);
    public static function operator+(v1, v2: Vec1d): Vec1d := new Vec1d(v1.val0+v2.val0);
    public static function operator-(v1, v2: Vec1d): Vec1d := new Vec1d(v1.val0-v2.val0);
    
    public static function operator implicit(v: Vec1b): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec1d := new Vec1d(v.val0);
    public static function operator implicit(v: Vec1d): Vec1f := new Vec1f(v.val0);
    
    public function SqrLength := val0*val0;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec1d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  {$endregion Vec1}
  
  {$region Vec2}
  
  Vec2b = record
    public val0: SByte;
    public val1: SByte;
    
    public constructor(val0, val1: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2b): Vec2b := new Vec2b(-v.val0, -v.val1);
    public static function operator*(v: Vec2b; k: SByte): Vec2b := new Vec2b(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2b): Vec2b := new Vec2b(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2b): Vec2b := new Vec2b(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2b := new Vec2b(v.val0, 0);
    public static function operator implicit(v: Vec2b): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), 0);
    public static function operator implicit(v: Vec2b): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), 0);
    public static function operator implicit(v: Vec2b): Vec1d := new Vec1d(v.val0);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2ub = record
    public val0: Byte;
    public val1: Byte;
    
    public constructor(val0, val1: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2ub; k: Byte): Vec2ub := new Vec2ub(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2ub): Vec2ub := new Vec2ub(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2ub): Vec2ub := new Vec2ub(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2ub := new Vec2ub(v.val0, 0);
    public static function operator implicit(v: Vec2ub): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), 0);
    public static function operator implicit(v: Vec2ub): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), 0);
    public static function operator implicit(v: Vec2ub): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2ub := new Vec2ub(v.val0, v.val1);
    public static function operator implicit(v: Vec2ub): Vec2b := new Vec2b(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2s = record
    public val0: Int16;
    public val1: Int16;
    
    public constructor(val0, val1: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2s): Vec2s := new Vec2s(-v.val0, -v.val1);
    public static function operator*(v: Vec2s; k: Int16): Vec2s := new Vec2s(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2s): Vec2s := new Vec2s(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2s): Vec2s := new Vec2s(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2s := new Vec2s(v.val0, 0);
    public static function operator implicit(v: Vec2s): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), 0);
    public static function operator implicit(v: Vec2s): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), 0);
    public static function operator implicit(v: Vec2s): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2s := new Vec2s(v.val0, v.val1);
    public static function operator implicit(v: Vec2s): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2s := new Vec2s(v.val0, v.val1);
    public static function operator implicit(v: Vec2s): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2us = record
    public val0: UInt16;
    public val1: UInt16;
    
    public constructor(val0, val1: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2us; k: UInt16): Vec2us := new Vec2us(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2us): Vec2us := new Vec2us(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2us): Vec2us := new Vec2us(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2us := new Vec2us(v.val0, 0);
    public static function operator implicit(v: Vec2us): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), 0);
    public static function operator implicit(v: Vec2us): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), 0);
    public static function operator implicit(v: Vec2us): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2us := new Vec2us(v.val0, v.val1);
    public static function operator implicit(v: Vec2us): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2us := new Vec2us(v.val0, v.val1);
    public static function operator implicit(v: Vec2us): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2us := new Vec2us(v.val0, v.val1);
    public static function operator implicit(v: Vec2us): Vec2s := new Vec2s(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2i = record
    public val0: Int32;
    public val1: Int32;
    
    public constructor(val0, val1: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2i): Vec2i := new Vec2i(-v.val0, -v.val1);
    public static function operator*(v: Vec2i; k: Int32): Vec2i := new Vec2i(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2i): Vec2i := new Vec2i(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2i): Vec2i := new Vec2i(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2i := new Vec2i(v.val0, 0);
    public static function operator implicit(v: Vec2i): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), 0);
    public static function operator implicit(v: Vec2i): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), 0);
    public static function operator implicit(v: Vec2i): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2i := new Vec2i(v.val0, v.val1);
    public static function operator implicit(v: Vec2i): Vec2us := new Vec2us(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2ui = record
    public val0: UInt32;
    public val1: UInt32;
    
    public constructor(val0, val1: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2ui; k: UInt32): Vec2ui := new Vec2ui(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2ui): Vec2ui := new Vec2ui(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2ui): Vec2ui := new Vec2ui(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2ui := new Vec2ui(v.val0, 0);
    public static function operator implicit(v: Vec2ui): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), 0);
    public static function operator implicit(v: Vec2ui): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), 0);
    public static function operator implicit(v: Vec2ui): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec2ui := new Vec2ui(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui): Vec2i := new Vec2i(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2i64 = record
    public val0: Int64;
    public val1: Int64;
    
    public constructor(val0, val1: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2i64): Vec2i64 := new Vec2i64(-v.val0, -v.val1);
    public static function operator*(v: Vec2i64; k: Int64): Vec2i64 := new Vec2i64(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2i64): Vec2i64 := new Vec2i64(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2i64): Vec2i64 := new Vec2i64(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2i64 := new Vec2i64(v.val0, 0);
    public static function operator implicit(v: Vec2i64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), 0);
    public static function operator implicit(v: Vec2i64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), 0);
    public static function operator implicit(v: Vec2i64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec2i64 := new Vec2i64(v.val0, v.val1);
    public static function operator implicit(v: Vec2i64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    
    public constructor(val0, val1: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec2ui64; k: UInt64): Vec2ui64 := new Vec2ui64(v.val0*k, v.val1*k);
    public static function operator+(v1, v2: Vec2ui64): Vec2ui64 := new Vec2ui64(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2ui64): Vec2ui64 := new Vec2ui64(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec2ui64 := new Vec2ui64(v.val0, 0);
    public static function operator implicit(v: Vec2ui64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), 0);
    public static function operator implicit(v: Vec2ui64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), 0);
    public static function operator implicit(v: Vec2ui64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    public static function operator implicit(v: Vec2ui64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2f = record
    public val0: single;
    public val1: single;
    
    public constructor(val0, val1: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2f): Vec2f := new Vec2f(-v.val0, -v.val1);
    public static function operator*(v: Vec2f; k: single): Vec2f := new Vec2f(v.val0*k, v.val1*k);
    public static function operator/(v: Vec2f; k: single): Vec2f := new Vec2f(v.val0/k, v.val1/k);
    public static function operator+(v1, v2: Vec2f): Vec2f := new Vec2f(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2f): Vec2f := new Vec2f(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2f := new Vec2f(v.val0, 0);
    public static function operator implicit(v: Vec2f): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec2f := new Vec2f(v.val0, v.val1);
    public static function operator implicit(v: Vec2f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec2d = record
    public val0: double;
    public val1: double;
    
    public constructor(val0, val1: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 1 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec2d): Vec2d := new Vec2d(-v.val0, -v.val1);
    public static function operator*(v: Vec2d; k: double): Vec2d := new Vec2d(v.val0*k, v.val1*k);
    public static function operator/(v: Vec2d; k: double): Vec2d := new Vec2d(v.val0/k, v.val1/k);
    public static function operator+(v1, v2: Vec2d): Vec2d := new Vec2d(v1.val0+v2.val0, v1.val1+v2.val1);
    public static function operator-(v1, v2: Vec2d): Vec2d := new Vec2d(v1.val0-v2.val0, v1.val1-v2.val1);
    
    public static function operator implicit(v: Vec1b): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec2d := new Vec2d(v.val0, 0);
    public static function operator implicit(v: Vec2d): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec2d := new Vec2d(v.val0, v.val1);
    public static function operator implicit(v: Vec2d): Vec2f := new Vec2f(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  {$endregion Vec2}
  
  {$region Vec3}
  
  Vec3b = record
    public val0: SByte;
    public val1: SByte;
    public val2: SByte;
    
    public constructor(val0, val1, val2: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3b): Vec3b := new Vec3b(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3b; k: SByte): Vec3b := new Vec3b(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3b): Vec3b := new Vec3b(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3b): Vec3b := new Vec3b(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3b := new Vec3b(v.val0, 0, 0);
    public static function operator implicit(v: Vec3b): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3b): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3b): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3b := new Vec3b(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3b): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0);
    public static function operator implicit(v: Vec3b): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0);
    public static function operator implicit(v: Vec3b): Vec2d := new Vec2d(v.val0, v.val1);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3ub = record
    public val0: Byte;
    public val1: Byte;
    public val2: Byte;
    
    public constructor(val0, val1, val2: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3ub; k: Byte): Vec3ub := new Vec3ub(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3ub): Vec3ub := new Vec3ub(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3ub): Vec3ub := new Vec3ub(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3ub := new Vec3ub(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ub): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3ub := new Vec3ub(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ub): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0);
    public static function operator implicit(v: Vec3ub): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0);
    public static function operator implicit(v: Vec3ub): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ub): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3s = record
    public val0: Int16;
    public val1: Int16;
    public val2: Int16;
    
    public constructor(val0, val1, val2: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3s): Vec3s := new Vec3s(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3s; k: Int16): Vec3s := new Vec3s(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3s): Vec3s := new Vec3s(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3s): Vec3s := new Vec3s(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3s := new Vec3s(v.val0, 0, 0);
    public static function operator implicit(v: Vec3s): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3s): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3s): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3s := new Vec3s(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3s): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0);
    public static function operator implicit(v: Vec3s): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0);
    public static function operator implicit(v: Vec3s): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3s): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3s): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3us = record
    public val0: UInt16;
    public val1: UInt16;
    public val2: UInt16;
    
    public constructor(val0, val1, val2: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3us; k: UInt16): Vec3us := new Vec3us(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3us): Vec3us := new Vec3us(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3us): Vec3us := new Vec3us(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3us := new Vec3us(v.val0, 0, 0);
    public static function operator implicit(v: Vec3us): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3us): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), 0, 0);
    public static function operator implicit(v: Vec3us): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3us := new Vec3us(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3us): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0);
    public static function operator implicit(v: Vec3us): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0);
    public static function operator implicit(v: Vec3us): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3us): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3us): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3us): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3i = record
    public val0: Int32;
    public val1: Int32;
    public val2: Int32;
    
    public constructor(val0, val1, val2: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3i): Vec3i := new Vec3i(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3i; k: Int32): Vec3i := new Vec3i(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3i): Vec3i := new Vec3i(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3i): Vec3i := new Vec3i(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3i := new Vec3i(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3i := new Vec3i(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0);
    public static function operator implicit(v: Vec3i): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0);
    public static function operator implicit(v: Vec3i): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3ui = record
    public val0: UInt32;
    public val1: UInt32;
    public val2: UInt32;
    
    public constructor(val0, val1, val2: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3ui; k: UInt32): Vec3ui := new Vec3ui(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3ui): Vec3ui := new Vec3ui(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3ui): Vec3ui := new Vec3ui(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3ui := new Vec3ui(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3ui := new Vec3ui(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0);
    public static function operator implicit(v: Vec3ui): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0);
    public static function operator implicit(v: Vec3ui): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3i64 = record
    public val0: Int64;
    public val1: Int64;
    public val2: Int64;
    
    public constructor(val0, val1, val2: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3i64): Vec3i64 := new Vec3i64(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3i64; k: Int64): Vec3i64 := new Vec3i64(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3i64): Vec3i64 := new Vec3i64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3i64): Vec3i64 := new Vec3i64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3i64 := new Vec3i64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3i64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3i64 := new Vec3i64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3i64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0);
    public static function operator implicit(v: Vec3i64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0);
    public static function operator implicit(v: Vec3i64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3i64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    public val2: UInt64;
    
    public constructor(val0, val1, val2: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec3ui64; k: UInt64): Vec3ui64 := new Vec3ui64(v.val0*k, v.val1*k, v.val2*k);
    public static function operator+(v1, v2: Vec3ui64): Vec3ui64 := new Vec3ui64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3ui64): Vec3ui64 := new Vec3ui64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec3ui64 := new Vec3ui64(v.val0, 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), 0, 0);
    public static function operator implicit(v: Vec3ui64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3ui64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0);
    public static function operator implicit(v: Vec3ui64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0);
    public static function operator implicit(v: Vec3ui64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3ui64): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3f = record
    public val0: single;
    public val1: single;
    public val2: single;
    
    public constructor(val0, val1, val2: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3f): Vec3f := new Vec3f(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3f; k: single): Vec3f := new Vec3f(v.val0*k, v.val1*k, v.val2*k);
    public static function operator/(v: Vec3f; k: single): Vec3f := new Vec3f(v.val0/k, v.val1/k, v.val2/k);
    public static function operator+(v1, v2: Vec3f): Vec3f := new Vec3f(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3f): Vec3f := new Vec3f(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3f := new Vec3f(v.val0, 0, 0);
    public static function operator implicit(v: Vec3f): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3f := new Vec3f(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3f): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec3d = record
    public val0: double;
    public val1: double;
    public val2: double;
    
    public constructor(val0, val1, val2: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 2 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec3d): Vec3d := new Vec3d(-v.val0, -v.val1, -v.val2);
    public static function operator*(v: Vec3d; k: double): Vec3d := new Vec3d(v.val0*k, v.val1*k, v.val2*k);
    public static function operator/(v: Vec3d; k: double): Vec3d := new Vec3d(v.val0/k, v.val1/k, v.val2/k);
    public static function operator+(v1, v2: Vec3d): Vec3d := new Vec3d(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2);
    public static function operator-(v1, v2: Vec3d): Vec3d := new Vec3d(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2);
    
    public static function operator implicit(v: Vec1b): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec3d := new Vec3d(v.val0, 0, 0);
    public static function operator implicit(v: Vec3d): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec3d := new Vec3d(v.val0, v.val1, 0);
    public static function operator implicit(v: Vec3d): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public static function operator implicit(v: Vec3f): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    public static function operator implicit(v: Vec3d): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  {$endregion Vec3}
  
  {$region Vec4}
  
  Vec4b = record
    public val0: SByte;
    public val1: SByte;
    public val2: SByte;
    public val3: SByte;
    
    public constructor(val0, val1, val2, val3: SByte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): SByte;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: SByte);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^SByte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: SByte read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4b): Vec4b := new Vec4b(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4b; k: SByte): Vec4b := new Vec4b(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4b): Vec4b := new Vec4b(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4b): Vec4b := new Vec4b(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4b := new Vec4b(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4b): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4b := new Vec4b(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4b): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4b): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4b): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4b): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), 0);
    public static function operator implicit(v: Vec4b): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), 0);
    public static function operator implicit(v: Vec4b): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4b;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4ub = record
    public val0: Byte;
    public val1: Byte;
    public val2: Byte;
    public val3: Byte;
    
    public constructor(val0, val1, val2, val3: Byte);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Byte;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Byte);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Byte := pointer(new IntPtr(@self) + i*1 );
      ptr^ := val;
    end;
    public property val[i: integer]: Byte read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4ub; k: Byte): Vec4ub := new Vec4ub(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4ub): Vec4ub := new Vec4ub(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4ub): Vec4ub := new Vec4ub(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4ub := new Vec4ub(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4ub := new Vec4ub(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ub): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ub): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), 0);
    public static function operator implicit(v: Vec4ub): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), 0);
    public static function operator implicit(v: Vec4ub): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ub): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4ub;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4s = record
    public val0: Int16;
    public val1: Int16;
    public val2: Int16;
    public val3: Int16;
    
    public constructor(val0, val1, val2, val3: Int16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Int16;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int16);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int16 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4s): Vec4s := new Vec4s(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4s; k: Int16): Vec4s := new Vec4s(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4s): Vec4s := new Vec4s(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4s): Vec4s := new Vec4s(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4s := new Vec4s(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4s): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4s := new Vec4s(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4s): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4s): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4s): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4s): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), 0);
    public static function operator implicit(v: Vec4s): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), 0);
    public static function operator implicit(v: Vec4s): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4s): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4s): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4s;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4us = record
    public val0: UInt16;
    public val1: UInt16;
    public val2: UInt16;
    public val3: UInt16;
    
    public constructor(val0, val1, val2, val3: UInt16);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): UInt16;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt16);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt16 := pointer(new IntPtr(@self) + i*2 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt16 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4us; k: UInt16): Vec4us := new Vec4us(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4us): Vec4us := new Vec4us(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4us): Vec4us := new Vec4us(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4us := new Vec4us(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4us): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4us := new Vec4us(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4us): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4us): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), 0, 0);
    public static function operator implicit(v: Vec4us): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4us): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), 0);
    public static function operator implicit(v: Vec4us): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), 0);
    public static function operator implicit(v: Vec4us): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4us): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4us): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4us): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4us;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4i = record
    public val0: Int32;
    public val1: Int32;
    public val2: Int32;
    public val3: Int32;
    
    public constructor(val0, val1, val2, val3: Int32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Int32;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int32);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int32 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4i): Vec4i := new Vec4i(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4i; k: Int32): Vec4i := new Vec4i(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4i): Vec4i := new Vec4i(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4i): Vec4i := new Vec4i(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4i := new Vec4i(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4i := new Vec4i(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), 0);
    public static function operator implicit(v: Vec4i): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), 0);
    public static function operator implicit(v: Vec4i): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4i;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4ui = record
    public val0: UInt32;
    public val1: UInt32;
    public val2: UInt32;
    public val3: UInt32;
    
    public constructor(val0, val1, val2, val3: UInt32);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): UInt32;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt32);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt32 := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt32 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4ui; k: UInt32): Vec4ui := new Vec4ui(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4ui): Vec4ui := new Vec4ui(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4ui): Vec4ui := new Vec4ui(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4ui := new Vec4ui(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4ui := new Vec4ui(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), 0);
    public static function operator implicit(v: Vec4ui): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), 0);
    public static function operator implicit(v: Vec4ui): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4ui;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4i64 = record
    public val0: Int64;
    public val1: Int64;
    public val2: Int64;
    public val3: Int64;
    
    public constructor(val0, val1, val2, val3: Int64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): Int64;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: Int64);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^Int64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: Int64 read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4i64): Vec4i64 := new Vec4i64(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4i64; k: Int64): Vec4i64 := new Vec4i64(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4i64): Vec4i64 := new Vec4i64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4i64): Vec4i64 := new Vec4i64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4i64 := new Vec4i64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4i64 := new Vec4i64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4i64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4i64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), 0);
    public static function operator implicit(v: Vec4i64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), 0);
    public static function operator implicit(v: Vec4i64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ui): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4i64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4i64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4ui64 = record
    public val0: UInt64;
    public val1: UInt64;
    public val2: UInt64;
    public val3: UInt64;
    
    public constructor(val0, val1, val2, val3: UInt64);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): UInt64;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: UInt64);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^UInt64 := pointer(new IntPtr(@self) + i*8 );
      ptr^ := val;
    end;
    public property val[i: integer]: UInt64 read GetValAt write SetValAt; default;
    
    public static function operator*(v: Vec4ui64; k: UInt64): Vec4ui64 := new Vec4ui64(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator+(v1, v2: Vec4ui64): Vec4ui64 := new Vec4ui64(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4ui64): Vec4ui64 := new Vec4ui64(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1b := new Vec1b(v.val0);
    
    public static function operator implicit(v: Vec1ub): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1ub := new Vec1ub(v.val0);
    
    public static function operator implicit(v: Vec1s): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1s := new Vec1s(v.val0);
    
    public static function operator implicit(v: Vec1us): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1us := new Vec1us(v.val0);
    
    public static function operator implicit(v: Vec1i): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1i := new Vec1i(v.val0);
    
    public static function operator implicit(v: Vec1ui): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1ui := new Vec1ui(v.val0);
    
    public static function operator implicit(v: Vec1i64): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1i64 := new Vec1i64(v.val0);
    
    public static function operator implicit(v: Vec1ui64): Vec4ui64 := new Vec4ui64(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1ui64 := new Vec1ui64(v.val0);
    
    public static function operator implicit(v: Vec1f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), 0, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2b := new Vec2b(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ub): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2ub := new Vec2ub(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2s): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2s := new Vec2s(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2us): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2us := new Vec2us(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2i := new Vec2i(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2ui := new Vec2ui(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2i64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2i64 := new Vec2i64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2ui64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2ui64 := new Vec2ui64(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), 0, 0);
    public static function operator implicit(v: Vec4ui64): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3b := new Vec3b(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ub): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3ub := new Vec3ub(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3s): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3s := new Vec3s(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3us): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3us := new Vec3us(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3i := new Vec3i(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3ui := new Vec3ui(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3i64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3i64 := new Vec3i64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3ui64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4ui64): Vec3ui64 := new Vec3ui64(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), 0);
    public static function operator implicit(v: Vec4ui64): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), 0);
    public static function operator implicit(v: Vec4ui64): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4b := new Vec4b(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ub): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4ub := new Vec4ub(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4s): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4s := new Vec4s(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4us): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4us := new Vec4us(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4i := new Vec4i(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4ui): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4ui := new Vec4ui(v.val0, v.val1, v.val2, v.val3);
    
    public static function operator implicit(v: Vec4i64): Vec4ui64 := new Vec4ui64(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4ui64): Vec4i64 := new Vec4i64(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4ui64;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4f = record
    public val0: single;
    public val1: single;
    public val2: single;
    public val3: single;
    
    public constructor(val0, val1, val2, val3: single);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): single;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: single);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: single read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4f): Vec4f := new Vec4f(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4f; k: single): Vec4f := new Vec4f(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator/(v: Vec4f; k: single): Vec4f := new Vec4f(v.val0/k, v.val1/k, v.val2/k, v.val3/k);
    public static function operator+(v1, v2: Vec4f): Vec4f := new Vec4f(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4f): Vec4f := new Vec4f(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4f := new Vec4f(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4f): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4f := new Vec4f(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4f): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public static function operator implicit(v: Vec3f): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4f := new Vec4f(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4f): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), Convert.ToSByte(v.val3));
    
    public static function operator implicit(v: Vec4ub): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), Convert.ToByte(v.val3));
    
    public static function operator implicit(v: Vec4s): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), Convert.ToInt16(v.val3));
    
    public static function operator implicit(v: Vec4us): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), Convert.ToUInt16(v.val3));
    
    public static function operator implicit(v: Vec4i): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), Convert.ToInt32(v.val3));
    
    public static function operator implicit(v: Vec4ui): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), Convert.ToUInt32(v.val3));
    
    public static function operator implicit(v: Vec4i64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), Convert.ToInt64(v.val3));
    
    public static function operator implicit(v: Vec4ui64): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4f): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), Convert.ToUInt64(v.val3));
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function SqrLength_d: double := real(val0)*val0 + real(val1)*val1 + real(val2)*val2 + real(val3)*val3;
    
    public function Normalized := self / single(Sqrt(self.SqrLength_d));
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  Vec4d = record
    public val0: double;
    public val1: double;
    public val2: double;
    public val3: double;
    
    public constructor(val0, val1, val2, val3: double);
    begin
      self.val0 := val0;
      self.val1 := val1;
      self.val2 := val2;
      self.val3 := val3;
    end;
    
    private function GetValAt(i: integer): double;
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      Result := ptr^;
    end;
    private procedure SetValAt(i: integer; val: double);
    begin
      if cardinal(i) > 3 then raise new IndexOutOfRangeException('Индекс должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + i*4 );
      ptr^ := val;
    end;
    public property val[i: integer]: double read GetValAt write SetValAt; default;
    
    public static function operator-(v: Vec4d): Vec4d := new Vec4d(-v.val0, -v.val1, -v.val2, -v.val3);
    public static function operator*(v: Vec4d; k: double): Vec4d := new Vec4d(v.val0*k, v.val1*k, v.val2*k, v.val3*k);
    public static function operator/(v: Vec4d; k: double): Vec4d := new Vec4d(v.val0/k, v.val1/k, v.val2/k, v.val3/k);
    public static function operator+(v1, v2: Vec4d): Vec4d := new Vec4d(v1.val0+v2.val0, v1.val1+v2.val1, v1.val2+v2.val2, v1.val3+v2.val3);
    public static function operator-(v1, v2: Vec4d): Vec4d := new Vec4d(v1.val0-v2.val0, v1.val1-v2.val1, v1.val2-v2.val2, v1.val3-v2.val3);
    
    public static function operator implicit(v: Vec1b): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1b := new Vec1b(Convert.ToSByte(v.val0));
    
    public static function operator implicit(v: Vec1ub): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1ub := new Vec1ub(Convert.ToByte(v.val0));
    
    public static function operator implicit(v: Vec1s): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1s := new Vec1s(Convert.ToInt16(v.val0));
    
    public static function operator implicit(v: Vec1us): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1us := new Vec1us(Convert.ToUInt16(v.val0));
    
    public static function operator implicit(v: Vec1i): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1i := new Vec1i(Convert.ToInt32(v.val0));
    
    public static function operator implicit(v: Vec1ui): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1ui := new Vec1ui(Convert.ToUInt32(v.val0));
    
    public static function operator implicit(v: Vec1i64): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1i64 := new Vec1i64(Convert.ToInt64(v.val0));
    
    public static function operator implicit(v: Vec1ui64): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1ui64 := new Vec1ui64(Convert.ToUInt64(v.val0));
    
    public static function operator implicit(v: Vec1f): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1f := new Vec1f(v.val0);
    
    public static function operator implicit(v: Vec1d): Vec4d := new Vec4d(v.val0, 0, 0, 0);
    public static function operator implicit(v: Vec4d): Vec1d := new Vec1d(v.val0);
    
    public static function operator implicit(v: Vec2b): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2b := new Vec2b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1));
    
    public static function operator implicit(v: Vec2ub): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2ub := new Vec2ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1));
    
    public static function operator implicit(v: Vec2s): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2s := new Vec2s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1));
    
    public static function operator implicit(v: Vec2us): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2us := new Vec2us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1));
    
    public static function operator implicit(v: Vec2i): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2i := new Vec2i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1));
    
    public static function operator implicit(v: Vec2ui): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2ui := new Vec2ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1));
    
    public static function operator implicit(v: Vec2i64): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2i64 := new Vec2i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1));
    
    public static function operator implicit(v: Vec2ui64): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2ui64 := new Vec2ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1));
    
    public static function operator implicit(v: Vec2f): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2f := new Vec2f(v.val0, v.val1);
    
    public static function operator implicit(v: Vec2d): Vec4d := new Vec4d(v.val0, v.val1, 0, 0);
    public static function operator implicit(v: Vec4d): Vec2d := new Vec2d(v.val0, v.val1);
    
    public static function operator implicit(v: Vec3b): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3b := new Vec3b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2));
    
    public static function operator implicit(v: Vec3ub): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3ub := new Vec3ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2));
    
    public static function operator implicit(v: Vec3s): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3s := new Vec3s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2));
    
    public static function operator implicit(v: Vec3us): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3us := new Vec3us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2));
    
    public static function operator implicit(v: Vec3i): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3i := new Vec3i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2));
    
    public static function operator implicit(v: Vec3ui): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3ui := new Vec3ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2));
    
    public static function operator implicit(v: Vec3i64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3i64 := new Vec3i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2));
    
    public static function operator implicit(v: Vec3ui64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3ui64 := new Vec3ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2));
    
    public static function operator implicit(v: Vec3f): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3f := new Vec3f(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec3d): Vec4d := new Vec4d(v.val0, v.val1, v.val2, 0);
    public static function operator implicit(v: Vec4d): Vec3d := new Vec3d(v.val0, v.val1, v.val2);
    
    public static function operator implicit(v: Vec4b): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4b := new Vec4b(Convert.ToSByte(v.val0), Convert.ToSByte(v.val1), Convert.ToSByte(v.val2), Convert.ToSByte(v.val3));
    
    public static function operator implicit(v: Vec4ub): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4ub := new Vec4ub(Convert.ToByte(v.val0), Convert.ToByte(v.val1), Convert.ToByte(v.val2), Convert.ToByte(v.val3));
    
    public static function operator implicit(v: Vec4s): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4s := new Vec4s(Convert.ToInt16(v.val0), Convert.ToInt16(v.val1), Convert.ToInt16(v.val2), Convert.ToInt16(v.val3));
    
    public static function operator implicit(v: Vec4us): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4us := new Vec4us(Convert.ToUInt16(v.val0), Convert.ToUInt16(v.val1), Convert.ToUInt16(v.val2), Convert.ToUInt16(v.val3));
    
    public static function operator implicit(v: Vec4i): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4i := new Vec4i(Convert.ToInt32(v.val0), Convert.ToInt32(v.val1), Convert.ToInt32(v.val2), Convert.ToInt32(v.val3));
    
    public static function operator implicit(v: Vec4ui): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4ui := new Vec4ui(Convert.ToUInt32(v.val0), Convert.ToUInt32(v.val1), Convert.ToUInt32(v.val2), Convert.ToUInt32(v.val3));
    
    public static function operator implicit(v: Vec4i64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4i64 := new Vec4i64(Convert.ToInt64(v.val0), Convert.ToInt64(v.val1), Convert.ToInt64(v.val2), Convert.ToInt64(v.val3));
    
    public static function operator implicit(v: Vec4ui64): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4ui64 := new Vec4ui64(Convert.ToUInt64(v.val0), Convert.ToUInt64(v.val1), Convert.ToUInt64(v.val2), Convert.ToUInt64(v.val3));
    
    public static function operator implicit(v: Vec4f): Vec4d := new Vec4d(v.val0, v.val1, v.val2, v.val3);
    public static function operator implicit(v: Vec4d): Vec4f := new Vec4f(v.val0, v.val1, v.val2, v.val3);
    
    public function SqrLength := val0*val0 + val1*val1 + val2*val2 + val3*val3;
    
    public function Normalized := self / Sqrt(self.SqrLength);
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      res += '[ ';
      res += val0.ToString('f2');
      res += ', ';
      res += val1.ToString('f2');
      res += ', ';
      res += val2.ToString('f2');
      res += ', ';
      res += val3.ToString('f2');
      res += ' ]';
      Result := res.ToString;
    end;
    
    public function Println: Vec4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
  end;
  
  {$endregion Vec4}
  
  {$endregion Vec}
  
  {$region Mtr}
  
  Mtr2x2f = record
    public val00, val10: single;
    public val01, val11: single;
    
    public constructor(val00, val01, val10, val11: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x2f read new Mtr2x2f(1.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec2f read new Vec2f(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2f read new Vec2f(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row[y: integer]: Vec2f read y=0?Row0:y=1?Row1:Arr&<Vec2f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2f read new Vec2f(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2f read new Vec2f(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col[x: integer]: Vec2f read x=0?Col0:x=1?Col1:Arr&<Vec2f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2f read pointer(IntPtr(pointer(@self)) + 8);
    public property ColPtr[x: integer]: ^Vec2f read pointer(IntPtr(pointer(@self)) + x*8);
    
    public static function Scale(k: double): Mtr2x2f := new Mtr2x2f(k, 0.0, 0.0, k);
    
    public static function Traslate(X: single): Mtr2x2f := new Mtr2x2f(1.0, X, 0.0, 1.0);
    public static function TraslateTransposed(X: single): Mtr2x2f := new Mtr2x2f(1.0, 0.0, X, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr2x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x2f(
         cr, +sr,
        -sr,  cr
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x2f(
         cr, -sr,
        +sr,  cr
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,2];
      for var y := 0 to 2-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x2f; v: Vec2f): Vec2f := new Vec2f(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1);
    public static function operator*(v: Vec2f; m: Mtr2x2f): Vec2f := new Vec2f(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1);
    
  end;
  Mtr2f = Mtr2x2f;
  
  Mtr3x3f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    public val02, val12, val22: single;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x3f read new Mtr3x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec3f read new Vec3f(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3f read new Vec3f(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3f read new Vec3f(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row[y: integer]: Vec3f read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec3f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3f read new Vec3f(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3f read new Vec3f(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3f read new Vec3f(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col[x: integer]: Vec3f read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec3f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3f read pointer(IntPtr(pointer(@self)) + 12);
    public property ColPtr2: ^Vec3f read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr[x: integer]: ^Vec3f read pointer(IntPtr(pointer(@self)) + x*12);
    
    public static function Scale(k: double): Mtr3x3f := new Mtr3x3f(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y: single): Mtr3x3f := new Mtr3x3f(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y: single): Mtr3x3f := new Mtr3x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x3f(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr3x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr3x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,3];
      for var y := 0 to 3-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x3f; v: Vec3f): Vec3f := new Vec3f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2);
    public static function operator*(v: Vec3f; m: Mtr3x3f): Vec3f := new Vec3f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
  end;
  Mtr3f = Mtr3x3f;
  
  Mtr4x4f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    public val02, val12, val22, val32: single;
    public val03, val13, val23, val33: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23, val30, val31, val32, val33: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
      self.val33 := val33;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x4f read new Mtr4x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec4f read new Vec4f(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4f read new Vec4f(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4f read new Vec4f(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row3: Vec4f read new Vec4f(self.val30, self.val31, self.val32, self.val33) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; self.val33 := value.val3; end;
    public property Row[y: integer]: Vec4f read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec4f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4f read new Vec4f(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4f read new Vec4f(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4f read new Vec4f(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col3: Vec4f read new Vec4f(self.val03, self.val13, self.val23, self.val33) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; self.val33 := value.val3; end;
    public property Col[x: integer]: Vec4f read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec4f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4f read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr2: ^Vec4f read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr3: ^Vec4f read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec4f read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr4x4f := new Mtr4x4f(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y, Z: single): Mtr4x4f := new Mtr4x4f(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z, 0.0, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y, Z: single): Mtr4x4f := new Mtr4x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, Z, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x4f(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr4x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr4x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,4];
      for var y := 0 to 4-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x4f; v: Vec4f): Vec4f := new Vec4f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2+m.val33*v.val3);
    public static function operator*(v: Vec4f; m: Mtr4x4f): Vec4f := new Vec4f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2+m.val33*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
  end;
  Mtr4f = Mtr4x4f;
  
  Mtr2x3f = record
    public val00, val10: single;
    public val01, val11: single;
    public val02, val12: single;
    
    public constructor(val00, val01, val02, val10, val11, val12: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x3f read new Mtr2x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec3f read new Vec3f(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3f read new Vec3f(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row[y: integer]: Vec3f read y=0?Row0:y=1?Row1:Arr&<Vec3f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2f read new Vec2f(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2f read new Vec2f(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2f read new Vec2f(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col[x: integer]: Vec2f read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec2f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3f read pointer(IntPtr(pointer(@self)) + 8);
    public property ColPtr[x: integer]: ^Vec3f read pointer(IntPtr(pointer(@self)) + x*8);
    
    public static function Scale(k: double): Mtr2x3f := new Mtr2x3f(k, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y: single): Mtr2x3f := new Mtr2x3f(1.0, 0.0, X, 0.0, 1.0, Y);
    public static function TraslateTransposed(X: single): Mtr2x3f := new Mtr2x3f(1.0, 0.0, 0.0, X, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x3f(
         cr, +sr, 0.0,
        -sr,  cr, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x3f(
         cr, -sr, 0.0,
        +sr,  cr, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,3];
      for var y := 0 to 2-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x3f; v: Vec3f): Vec2f := new Vec2f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2);
    public static function operator*(v: Vec2f; m: Mtr2x3f): Vec3f := new Vec3f(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
  end;
  
  Mtr3x2f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    
    public constructor(val00, val01, val10, val11, val20, val21: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x2f read new Mtr3x2f(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec2f read new Vec2f(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2f read new Vec2f(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2f read new Vec2f(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row[y: integer]: Vec2f read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec2f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3f read new Vec3f(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3f read new Vec3f(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col[x: integer]: Vec3f read x=0?Col0:x=1?Col1:Arr&<Vec3f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2f read pointer(IntPtr(pointer(@self)) + 12);
    public property ColPtr2: ^Vec2f read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr[x: integer]: ^Vec2f read pointer(IntPtr(pointer(@self)) + x*12);
    
    public static function Scale(k: double): Mtr3x2f := new Mtr3x2f(k, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X: single): Mtr3x2f := new Mtr3x2f(1.0, X, 0.0, 1.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: single): Mtr3x2f := new Mtr3x2f(1.0, 0.0, 0.0, 1.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr3x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x2f(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x2f(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,2];
      for var y := 0 to 3-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x2f; v: Vec2f): Vec3f := new Vec3f(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1);
    public static function operator*(v: Vec3f; m: Mtr3x2f): Vec2f := new Vec2f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
  end;
  
  Mtr2x4f = record
    public val00, val10: single;
    public val01, val11: single;
    public val02, val12: single;
    public val03, val13: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*2 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x4f read new Mtr2x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec4f read new Vec4f(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4f read new Vec4f(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row[y: integer]: Vec4f read y=0?Row0:y=1?Row1:Arr&<Vec4f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2f read new Vec2f(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2f read new Vec2f(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2f read new Vec2f(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col3: Vec2f read new Vec2f(self.val03, self.val13) write begin self.val03 := value.val0; self.val13 := value.val1; end;
    public property Col[x: integer]: Vec2f read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec2f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4f read pointer(IntPtr(pointer(@self)) + 8);
    public property ColPtr[x: integer]: ^Vec4f read pointer(IntPtr(pointer(@self)) + x*8);
    
    public static function Scale(k: double): Mtr2x4f := new Mtr2x4f(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X, Y: single): Mtr2x4f := new Mtr2x4f(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y);
    public static function TraslateTransposed(X: single): Mtr2x4f := new Mtr2x4f(1.0, 0.0, 0.0, 0.0, X, 1.0, 0.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x4f(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr2x4f(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,4];
      for var y := 0 to 2-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x4f; v: Vec4f): Vec2f := new Vec2f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3);
    public static function operator*(v: Vec2f; m: Mtr2x4f): Vec4f := new Vec4f(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1, m.val03*v.val0+m.val13*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr4x2f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    
    public constructor(val00, val01, val10, val11, val20, val21, val30, val31: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
      self.val30 := val30;
      self.val31 := val31;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x2f read new Mtr4x2f(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec2f read new Vec2f(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2f read new Vec2f(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2f read new Vec2f(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row3: Vec2f read new Vec2f(self.val30, self.val31) write begin self.val30 := value.val0; self.val31 := value.val1; end;
    public property Row[y: integer]: Vec2f read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec2f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4f read new Vec4f(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4f read new Vec4f(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col[x: integer]: Vec4f read x=0?Col0:x=1?Col1:Arr&<Vec4f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2f read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr2: ^Vec2f read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr3: ^Vec2f read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec2f read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr4x2f := new Mtr4x2f(k, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0);
    
    public static function Traslate(X: single): Mtr4x2f := new Mtr4x2f(1.0, X, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: single): Mtr4x2f := new Mtr4x2f(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr4x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x2f(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x2f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x2f(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,2];
      for var y := 0 to 4-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x2f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x2f; v: Vec2f): Vec4f := new Vec4f(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1, m.val30*v.val0+m.val31*v.val1);
    public static function operator*(v: Vec4f; m: Mtr4x2f): Vec2f := new Vec2f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr3x4f = record
    public val00, val10, val20: single;
    public val01, val11, val21: single;
    public val02, val12, val22: single;
    public val03, val13, val23: single;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*3 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x4f read new Mtr3x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec4f read new Vec4f(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4f read new Vec4f(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4f read new Vec4f(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row[y: integer]: Vec4f read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec4f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3f read new Vec3f(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3f read new Vec3f(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3f read new Vec3f(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col3: Vec3f read new Vec3f(self.val03, self.val13, self.val23) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; end;
    public property Col[x: integer]: Vec3f read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec3f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4f read pointer(IntPtr(pointer(@self)) + 12);
    public property ColPtr2: ^Vec4f read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr[x: integer]: ^Vec4f read pointer(IntPtr(pointer(@self)) + x*12);
    
    public static function Scale(k: double): Mtr3x4f := new Mtr3x4f(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y, Z: single): Mtr3x4f := new Mtr3x4f(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z);
    public static function TraslateTransposed(X, Y: single): Mtr3x4f := new Mtr3x4f(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x4f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr3x4f(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr3x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr3x4f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,4];
      for var y := 0 to 3-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x4f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x4f; v: Vec4f): Vec3f := new Vec3f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3);
    public static function operator*(v: Vec3f; m: Mtr3x4f): Vec4f := new Vec4f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
  end;
  
  Mtr4x3f = record
    public val00, val10, val20, val30: single;
    public val01, val11, val21, val31: single;
    public val02, val12, val22, val32: single;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22, val30, val31, val32: single);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
    end;
    
    private function GetValAt(y,x: integer): single;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: single);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^single := pointer(new IntPtr(@self) + (x*4 + y) * 4 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: single read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x3f read new Mtr4x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec3f read new Vec3f(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3f read new Vec3f(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3f read new Vec3f(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row3: Vec3f read new Vec3f(self.val30, self.val31, self.val32) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; end;
    public property Row[y: integer]: Vec3f read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec3f>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4f read new Vec4f(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4f read new Vec4f(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4f read new Vec4f(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col[x: integer]: Vec4f read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec4f>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3f read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3f read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr2: ^Vec3f read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr3: ^Vec3f read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec3f read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr4x3f := new Mtr4x3f(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0);
    
    public static function Traslate(X, Y: single): Mtr4x3f := new Mtr4x3f(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y, Z: single): Mtr4x3f := new Mtr4x3f(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, X, Y, Z);
    
    public static function RotateXYcw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x3f;
    begin
      var sr: single := Sin(rot);
      var cr: single := Cos(rot);
      Result := new Mtr4x3f(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3f; rot: double): Mtr4x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3f; rot: double): Mtr4x3f;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,3];
      for var y := 0 to 4-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x3f;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x3f; v: Vec3f): Vec4f := new Vec4f(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2);
    public static function operator*(v: Vec4f; m: Mtr4x3f): Vec3f := new Vec3f(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3f): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3f): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
  end;
  
  Mtr2x2d = record
    public val00, val10: double;
    public val01, val11: double;
    
    public constructor(val00, val01, val10, val11: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x2d read new Mtr2x2d(1.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec2d read new Vec2d(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2d read new Vec2d(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row[y: integer]: Vec2d read y=0?Row0:y=1?Row1:Arr&<Vec2d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2d read new Vec2d(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2d read new Vec2d(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col[x: integer]: Vec2d read x=0?Col0:x=1?Col1:Arr&<Vec2d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2d read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr[x: integer]: ^Vec2d read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr2x2d := new Mtr2x2d(k, 0.0, 0.0, k);
    
    public static function Traslate(X: double): Mtr2x2d := new Mtr2x2d(1.0, X, 0.0, 1.0);
    public static function TraslateTransposed(X: double): Mtr2x2d := new Mtr2x2d(1.0, 0.0, X, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr2x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x2d(
         cr, +sr,
        -sr,  cr
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x2d(
         cr, -sr,
        +sr,  cr
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,2];
      for var y := 0 to 2-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x2d; v: Vec2d): Vec2d := new Vec2d(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1);
    public static function operator*(v: Vec2d; m: Mtr2x2d): Vec2d := new Vec2d(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x4f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    public static function operator implicit(m: Mtr2x2d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
  end;
  Mtr2d = Mtr2x2d;
  
  Mtr3x3d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    public val02, val12, val22: double;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x3d read new Mtr3x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec3d read new Vec3d(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3d read new Vec3d(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3d read new Vec3d(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row[y: integer]: Vec3d read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec3d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3d read new Vec3d(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3d read new Vec3d(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3d read new Vec3d(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col[x: integer]: Vec3d read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec3d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3d read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr2: ^Vec3d read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec3d read pointer(IntPtr(pointer(@self)) + x*24);
    
    public static function Scale(k: double): Mtr3x3d := new Mtr3x3d(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y: double): Mtr3x3d := new Mtr3x3d(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y: double): Mtr3x3d := new Mtr3x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x3d(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr3x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr3x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,3];
      for var y := 0 to 3-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x3d; v: Vec3d): Vec3d := new Vec3d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2);
    public static function operator*(v: Vec3d; m: Mtr3x3d): Vec3d := new Vec3d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    public static function operator implicit(m: Mtr3x3d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x3d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
  end;
  Mtr3d = Mtr3x3d;
  
  Mtr4x4d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    public val02, val12, val22, val32: double;
    public val03, val13, val23, val33: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23, val30, val31, val32, val33: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
      self.val33 := val33;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x4d read new Mtr4x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
    
    public property Row0: Vec4d read new Vec4d(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4d read new Vec4d(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4d read new Vec4d(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row3: Vec4d read new Vec4d(self.val30, self.val31, self.val32, self.val33) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; self.val33 := value.val3; end;
    public property Row[y: integer]: Vec4d read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec4d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4d read new Vec4d(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4d read new Vec4d(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4d read new Vec4d(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col3: Vec4d read new Vec4d(self.val03, self.val13, self.val23, self.val33) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; self.val33 := value.val3; end;
    public property Col[x: integer]: Vec4d read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec4d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4d read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr2: ^Vec4d read pointer(IntPtr(pointer(@self)) + 64);
    public property ColPtr3: ^Vec4d read pointer(IntPtr(pointer(@self)) + 96);
    public property ColPtr[x: integer]: ^Vec4d read pointer(IntPtr(pointer(@self)) + x*32);
    
    public static function Scale(k: double): Mtr4x4d := new Mtr4x4d(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k);
    
    public static function Traslate(X, Y, Z: double): Mtr4x4d := new Mtr4x4d(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z, 0.0, 0.0, 0.0, 1.0);
    public static function TraslateTransposed(X, Y, Z: double): Mtr4x4d := new Mtr4x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, X, Y, Z, 1.0);
    
    public static function RotateXYcw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x4d(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0,
        0.0, 0.0, 0.0, 1.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr4x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr4x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
      Result.val33 := 1;
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,4];
      for var y := 0 to 4-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x4d; v: Vec4d): Vec4d := new Vec4d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2+m.val33*v.val3);
    public static function operator*(v: Vec4d; m: Mtr4x4d): Vec4d := new Vec4d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2+m.val33*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, m.val30, m.val31, m.val32, m.val33);
    public static function operator implicit(m: Mtr4x4d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, m.val30, m.val31, m.val32, m.val33);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    
    public static function operator implicit(m: Mtr4x3f): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    
    public static function operator implicit(m: Mtr2x2d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x4d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
  end;
  Mtr4d = Mtr4x4d;
  
  Mtr2x3d = record
    public val00, val10: double;
    public val01, val11: double;
    public val02, val12: double;
    
    public constructor(val00, val01, val02, val10, val11, val12: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x3d read new Mtr2x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec3d read new Vec3d(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3d read new Vec3d(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row[y: integer]: Vec3d read y=0?Row0:y=1?Row1:Arr&<Vec3d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2d read new Vec2d(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2d read new Vec2d(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2d read new Vec2d(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col[x: integer]: Vec2d read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec2d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3d read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr[x: integer]: ^Vec3d read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr2x3d := new Mtr2x3d(k, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y: double): Mtr2x3d := new Mtr2x3d(1.0, 0.0, X, 0.0, 1.0, Y);
    public static function TraslateTransposed(X: double): Mtr2x3d := new Mtr2x3d(1.0, 0.0, 0.0, X, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x3d(
         cr, +sr, 0.0,
        -sr,  cr, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x3d(
         cr, -sr, 0.0,
        +sr,  cr, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,3];
      for var y := 0 to 2-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x3d; v: Vec3d): Vec2d := new Vec2d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2);
    public static function operator*(v: Vec2d; m: Mtr2x3d): Vec3d := new Vec3d(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x4f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    public static function operator implicit(m: Mtr2x3d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    public static function operator implicit(m: Mtr2x3d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
  end;
  
  Mtr3x2d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    
    public constructor(val00, val01, val10, val11, val20, val21: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x2d read new Mtr3x2d(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec2d read new Vec2d(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2d read new Vec2d(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2d read new Vec2d(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row[y: integer]: Vec2d read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec2d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3d read new Vec3d(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3d read new Vec3d(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col[x: integer]: Vec3d read x=0?Col0:x=1?Col1:Arr&<Vec3d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2d read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr2: ^Vec2d read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec2d read pointer(IntPtr(pointer(@self)) + x*24);
    
    public static function Scale(k: double): Mtr3x2d := new Mtr3x2d(k, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X: double): Mtr3x2d := new Mtr3x2d(1.0, X, 0.0, 1.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: double): Mtr3x2d := new Mtr3x2d(1.0, 0.0, 0.0, 1.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr3x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x2d(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x2d(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,2];
      for var y := 0 to 3-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x2d; v: Vec2d): Vec3d := new Vec3d(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1);
    public static function operator*(v: Vec3d; m: Mtr3x2d): Vec2d := new Vec2d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    public static function operator implicit(m: Mtr3x2d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x2d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
  end;
  
  Mtr2x4d = record
    public val00, val10: double;
    public val01, val11: double;
    public val02, val12: double;
    public val03, val13: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 1 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..1');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*2 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr2x4d read new Mtr2x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0);
    
    public property Row0: Vec4d read new Vec4d(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4d read new Vec4d(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row[y: integer]: Vec4d read y=0?Row0:y=1?Row1:Arr&<Vec4d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..1');
    end;
    
    public property Col0: Vec2d read new Vec2d(self.val00, self.val10) write begin self.val00 := value.val0; self.val10 := value.val1; end;
    public property Col1: Vec2d read new Vec2d(self.val01, self.val11) write begin self.val01 := value.val0; self.val11 := value.val1; end;
    public property Col2: Vec2d read new Vec2d(self.val02, self.val12) write begin self.val02 := value.val0; self.val12 := value.val1; end;
    public property Col3: Vec2d read new Vec2d(self.val03, self.val13) write begin self.val03 := value.val0; self.val13 := value.val1; end;
    public property Col[x: integer]: Vec2d read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec2d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4d read pointer(IntPtr(pointer(@self)) + 16);
    public property ColPtr[x: integer]: ^Vec4d read pointer(IntPtr(pointer(@self)) + x*16);
    
    public static function Scale(k: double): Mtr2x4d := new Mtr2x4d(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0);
    
    public static function Traslate(X, Y: double): Mtr2x4d := new Mtr2x4d(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y);
    public static function TraslateTransposed(X: double): Mtr2x4d := new Mtr2x4d(1.0, 0.0, 0.0, 0.0, X, 1.0, 0.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr2x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x4d(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr2x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr2x4d(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[2,4];
      for var y := 0 to 2-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr2x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr2x4d; v: Vec4d): Vec2d := new Vec2d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3);
    public static function operator*(v: Vec2d; m: Mtr2x4d): Vec4d := new Vec4d(m.val00*v.val0+m.val10*v.val1, m.val01*v.val0+m.val11*v.val1, m.val02*v.val0+m.val12*v.val1, m.val03*v.val0+m.val13*v.val1);
    
    public static function operator implicit(m: Mtr2x2f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x4f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    public static function operator implicit(m: Mtr2x4d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    public static function operator implicit(m: Mtr2x4d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr4x2d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    
    public constructor(val00, val01, val10, val11, val20, val21, val30, val31: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val10 := val10;
      self.val11 := val11;
      self.val20 := val20;
      self.val21 := val21;
      self.val30 := val30;
      self.val31 := val31;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 1 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..1');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x2d read new Mtr4x2d(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec2d read new Vec2d(self.val00, self.val01) write begin self.val00 := value.val0; self.val01 := value.val1; end;
    public property Row1: Vec2d read new Vec2d(self.val10, self.val11) write begin self.val10 := value.val0; self.val11 := value.val1; end;
    public property Row2: Vec2d read new Vec2d(self.val20, self.val21) write begin self.val20 := value.val0; self.val21 := value.val1; end;
    public property Row3: Vec2d read new Vec2d(self.val30, self.val31) write begin self.val30 := value.val0; self.val31 := value.val1; end;
    public property Row[y: integer]: Vec2d read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec2d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4d read new Vec4d(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4d read new Vec4d(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col[x: integer]: Vec4d read x=0?Col0:x=1?Col1:Arr&<Vec4d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..1');
    end;
    
    public property ColPtr0: ^Vec2d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec2d read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr2: ^Vec2d read pointer(IntPtr(pointer(@self)) + 64);
    public property ColPtr3: ^Vec2d read pointer(IntPtr(pointer(@self)) + 96);
    public property ColPtr[x: integer]: ^Vec2d read pointer(IntPtr(pointer(@self)) + x*32);
    
    public static function Scale(k: double): Mtr4x2d := new Mtr4x2d(k, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0);
    
    public static function Traslate(X: double): Mtr4x2d := new Mtr4x2d(1.0, X, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y: double): Mtr4x2d := new Mtr4x2d(1.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y);
    
    public static function RotateXYcw(rot: double): Mtr4x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x2d(
         cr, +sr,
        -sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x2d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x2d(
         cr, -sr,
        +sr,  cr,
        0.0, 0.0,
        0.0, 0.0
      );
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,2];
      for var y := 0 to 4-1 do
        for var x := 0 to 2-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*2 + 4; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x2d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x2d; v: Vec2d): Vec4d := new Vec4d(m.val00*v.val0+m.val01*v.val1, m.val10*v.val0+m.val11*v.val1, m.val20*v.val0+m.val21*v.val1, m.val30*v.val0+m.val31*v.val1);
    public static function operator*(v: Vec4d; m: Mtr4x2d): Vec2d := new Vec2d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0);
    
    public static function operator implicit(m: Mtr4x4d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    public static function operator implicit(m: Mtr4x2d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0, m.val30, m.val31, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0);
    
    public static function operator implicit(m: Mtr3x2d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x2d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0);
    
  end;
  
  Mtr3x4d = record
    public val00, val10, val20: double;
    public val01, val11, val21: double;
    public val02, val12, val22: double;
    public val03, val13, val23: double;
    
    public constructor(val00, val01, val02, val03, val10, val11, val12, val13, val20, val21, val22, val23: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val03 := val03;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val13 := val13;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val23 := val23;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 3 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..3');
      if cardinal(y) > 2 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..2');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*3 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr3x4d read new Mtr3x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    
    public property Row0: Vec4d read new Vec4d(self.val00, self.val01, self.val02, self.val03) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; self.val03 := value.val3; end;
    public property Row1: Vec4d read new Vec4d(self.val10, self.val11, self.val12, self.val13) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; self.val13 := value.val3; end;
    public property Row2: Vec4d read new Vec4d(self.val20, self.val21, self.val22, self.val23) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; self.val23 := value.val3; end;
    public property Row[y: integer]: Vec4d read y=0?Row0:y=1?Row1:y=2?Row2:Arr&<Vec4d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..2');
    end;
    
    public property Col0: Vec3d read new Vec3d(self.val00, self.val10, self.val20) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; end;
    public property Col1: Vec3d read new Vec3d(self.val01, self.val11, self.val21) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; end;
    public property Col2: Vec3d read new Vec3d(self.val02, self.val12, self.val22) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; end;
    public property Col3: Vec3d read new Vec3d(self.val03, self.val13, self.val23) write begin self.val03 := value.val0; self.val13 := value.val1; self.val23 := value.val2; end;
    public property Col[x: integer]: Vec3d read x=0?Col0:x=1?Col1:x=2?Col2:x=3?Col3:Arr&<Vec3d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      3: Col3 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..3');
    end;
    
    public property ColPtr0: ^Vec4d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec4d read pointer(IntPtr(pointer(@self)) + 24);
    public property ColPtr2: ^Vec4d read pointer(IntPtr(pointer(@self)) + 48);
    public property ColPtr[x: integer]: ^Vec4d read pointer(IntPtr(pointer(@self)) + x*24);
    
    public static function Scale(k: double): Mtr3x4d := new Mtr3x4d(k, 0.0, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, 0.0, k, 0.0);
    
    public static function Traslate(X, Y, Z: double): Mtr3x4d := new Mtr3x4d(1.0, 0.0, 0.0, X, 0.0, 1.0, 0.0, Y, 0.0, 0.0, 1.0, Z);
    public static function TraslateTransposed(X, Y: double): Mtr3x4d := new Mtr3x4d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, X, Y, 1.0, 0.0);
    
    public static function RotateXYcw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, +sr, 0.0, 0.0,
        -sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, -sr, 0.0, 0.0,
        +sr,  cr, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, +sr, 0.0,
        0.0, -sr,  cr, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
        1.0, 0.0, 0.0, 0.0,
        0.0,  cr, -sr, 0.0,
        0.0, +sr,  cr, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, 0.0, -sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        +sr, 0.0,  cr, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr3x4d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr3x4d(
         cr, 0.0, +sr, 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sr, 0.0,  cr, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr3x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr3x4d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[3,4];
      for var y := 0 to 3-1 do
        for var x := 0 to 4-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*4 + 8; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,3].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr3x4d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr3x4d; v: Vec4d): Vec3d := new Vec3d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2+m.val03*v.val3, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2+m.val13*v.val3, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2+m.val23*v.val3);
    public static function operator*(v: Vec3d; m: Mtr3x4d): Vec4d := new Vec4d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2, m.val03*v.val0+m.val13*v.val1+m.val23*v.val2);
    
    public static function operator implicit(m: Mtr2x2f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr3x4f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    
    public static function operator implicit(m: Mtr4x3f): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x2d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23);
    public static function operator implicit(m: Mtr3x4d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, m.val20, m.val21, m.val22, m.val23, 0.0, 0.0, 0.0, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, m.val03, m.val10, m.val11, m.val12, m.val13);
    
    public static function operator implicit(m: Mtr4x2d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, 0.0, 0.0, m.val10, m.val11, 0.0, 0.0, m.val20, m.val21, 0.0, 0.0);
    public static function operator implicit(m: Mtr3x4d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, 0.0, 0.0);
    
  end;
  
  Mtr4x3d = record
    public val00, val10, val20, val30: double;
    public val01, val11, val21, val31: double;
    public val02, val12, val22, val32: double;
    
    public constructor(val00, val01, val02, val10, val11, val12, val20, val21, val22, val30, val31, val32: double);
    begin
      self.val00 := val00;
      self.val01 := val01;
      self.val02 := val02;
      self.val10 := val10;
      self.val11 := val11;
      self.val12 := val12;
      self.val20 := val20;
      self.val21 := val21;
      self.val22 := val22;
      self.val30 := val30;
      self.val31 := val31;
      self.val32 := val32;
    end;
    
    private function GetValAt(y,x: integer): double;
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      Result := ptr^;
    end;
    private procedure SetValAt(y,x: integer; val: double);
    begin
      if cardinal(x) > 2 then raise new IndexOutOfRangeException('Индекс "X" должен иметь значение 0..2');
      if cardinal(y) > 3 then raise new IndexOutOfRangeException('Индекс "Y" должен иметь значение 0..3');
      var ptr: ^double := pointer(new IntPtr(@self) + (x*4 + y) * 8 );
      ptr^ := val;
    end;
    public property val[y,x: integer]: double read GetValAt write SetValAt; default;
    
    public static property Identity: Mtr4x3d read new Mtr4x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    
    public property Row0: Vec3d read new Vec3d(self.val00, self.val01, self.val02) write begin self.val00 := value.val0; self.val01 := value.val1; self.val02 := value.val2; end;
    public property Row1: Vec3d read new Vec3d(self.val10, self.val11, self.val12) write begin self.val10 := value.val0; self.val11 := value.val1; self.val12 := value.val2; end;
    public property Row2: Vec3d read new Vec3d(self.val20, self.val21, self.val22) write begin self.val20 := value.val0; self.val21 := value.val1; self.val22 := value.val2; end;
    public property Row3: Vec3d read new Vec3d(self.val30, self.val31, self.val32) write begin self.val30 := value.val0; self.val31 := value.val1; self.val32 := value.val2; end;
    public property Row[y: integer]: Vec3d read y=0?Row0:y=1?Row1:y=2?Row2:y=3?Row3:Arr&<Vec3d>[y] write
    case y of
      0: Row0 := value;
      1: Row1 := value;
      2: Row2 := value;
      3: Row3 := value;
      else raise new IndexOutOfRangeException('Номер строчки должен иметь значение 0..3');
    end;
    
    public property Col0: Vec4d read new Vec4d(self.val00, self.val10, self.val20, self.val30) write begin self.val00 := value.val0; self.val10 := value.val1; self.val20 := value.val2; self.val30 := value.val3; end;
    public property Col1: Vec4d read new Vec4d(self.val01, self.val11, self.val21, self.val31) write begin self.val01 := value.val0; self.val11 := value.val1; self.val21 := value.val2; self.val31 := value.val3; end;
    public property Col2: Vec4d read new Vec4d(self.val02, self.val12, self.val22, self.val32) write begin self.val02 := value.val0; self.val12 := value.val1; self.val22 := value.val2; self.val32 := value.val3; end;
    public property Col[x: integer]: Vec4d read x=0?Col0:x=1?Col1:x=2?Col2:Arr&<Vec4d>[x] write
    case x of
      0: Col0 := value;
      1: Col1 := value;
      2: Col2 := value;
      else raise new IndexOutOfRangeException('Номер столбца должен иметь значение 0..2');
    end;
    
    public property ColPtr0: ^Vec3d read pointer(IntPtr(pointer(@self)) + 0);
    public property ColPtr1: ^Vec3d read pointer(IntPtr(pointer(@self)) + 32);
    public property ColPtr2: ^Vec3d read pointer(IntPtr(pointer(@self)) + 64);
    public property ColPtr3: ^Vec3d read pointer(IntPtr(pointer(@self)) + 96);
    public property ColPtr[x: integer]: ^Vec3d read pointer(IntPtr(pointer(@self)) + x*32);
    
    public static function Scale(k: double): Mtr4x3d := new Mtr4x3d(k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0, k, 0.0, 0.0, 0.0);
    
    public static function Traslate(X, Y: double): Mtr4x3d := new Mtr4x3d(1.0, 0.0, X, 0.0, 1.0, Y, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0);
    public static function TraslateTransposed(X, Y, Z: double): Mtr4x3d := new Mtr4x3d(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, X, Y, Z);
    
    public static function RotateXYcw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, +sr, 0.0,
        -sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateXYccw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, -sr, 0.0,
        +sr,  cr, 0.0,
        0.0, 0.0, 1.0,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateYZcw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, +sr,
        0.0, -sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateYZccw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
        1.0, 0.0, 0.0,
        0.0,  cr, -sr,
        0.0, +sr,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function RotateZXcw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, 0.0, -sr,
        0.0, 1.0, 0.0,
        +sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    public static function RotateZXccw(rot: double): Mtr4x3d;
    begin
      var sr: double := Sin(rot);
      var cr: double := Cos(rot);
      Result := new Mtr4x3d(
         cr, 0.0, +sr,
        0.0, 1.0, 0.0,
        -sr, 0.0,  cr,
        0.0, 0.0, 0.0
      );
    end;
    
    public static function Rotate3Dcw(u: Vec3d; rot: double): Mtr4x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := -k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := -k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := -k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public static function Rotate3Dccw(u: Vec3d; rot: double): Mtr4x3d;
    begin
      var k1 := Sin(rot);
      var k2 := 2*Sqr(Sin(rot/2));
      
      Result.val00 := 1 + k2*( -u.val2*u.val2 - u.val1*u.val1 );
      Result.val01 := -k1*u.val2 + k2*( u.val1*u.val0 );
      Result.val02 := k1*u.val1 + k2*( u.val2*u.val0 );
      Result.val10 := k1*u.val2 + k2*( u.val0*u.val1 );
      Result.val11 := 1 + k2*( -u.val2*u.val2 - u.val0*u.val0 );
      Result.val12 := -k1*u.val0 + k2*( u.val2*u.val1 );
      Result.val20 := -k1*u.val1 + k2*( u.val0*u.val2 );
      Result.val21 := k1*u.val0 + k2*( u.val1*u.val2 );
      Result.val22 := 1 + k2*( -u.val1*u.val1 - u.val0*u.val0 );
      
    end;
    
    public function ToString: string; override;
    begin
      var res := new StringBuilder;
      
      var ElStrs := new string[4,3];
      for var y := 0 to 4-1 do
        for var x := 0 to 3-1 do
          ElStrs[y,x] := (Sign(val[y,x])=-1?'-':'+') + Abs(val[y,x]).ToString('f2');
      var MtrElTextW := ElStrs.OfType&<string>.Max(s->s.Length);
      var PrintlnMtrW := MtrElTextW*3 + 6; // +2*(Width-1) + 2;
      
      res += '┌';
      res.Append(#32, PrintlnMtrW);
      res += '┐'#10;
      res += '│ ';
      res += ElStrs[0,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[0,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[1,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[1,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[2,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[2,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '│ ';
      res += ElStrs[3,0].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,1].PadLeft(MtrElTextW);
      res += ', ';
      res += ElStrs[3,2].PadLeft(MtrElTextW);
      res += ' │'#10;
      res += '└';
      res.Append(#32, PrintlnMtrW);
      res += '┘';
      
      Result := res.ToString;
    end;
    
    public function Println: Mtr4x3d;
    begin
      Writeln(self.ToString);
      Result := self;
    end;
    
    public static function operator*(m: Mtr4x3d; v: Vec3d): Vec4d := new Vec4d(m.val00*v.val0+m.val01*v.val1+m.val02*v.val2, m.val10*v.val0+m.val11*v.val1+m.val12*v.val2, m.val20*v.val0+m.val21*v.val1+m.val22*v.val2, m.val30*v.val0+m.val31*v.val1+m.val32*v.val2);
    public static function operator*(v: Vec4d; m: Mtr4x3d): Vec3d := new Vec3d(m.val00*v.val0+m.val10*v.val1+m.val20*v.val2+m.val30*v.val3, m.val01*v.val0+m.val11*v.val1+m.val21*v.val2+m.val31*v.val3, m.val02*v.val0+m.val12*v.val1+m.val22*v.val2+m.val32*v.val3);
    
    public static function operator implicit(m: Mtr2x2f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x2f := new Mtr2x2f(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x3f := new Mtr3x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3d): Mtr4x4f := new Mtr4x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    
    public static function operator implicit(m: Mtr2x3f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x3f := new Mtr2x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x2f := new Mtr3x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x4f := new Mtr2x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr4x2f := new Mtr4x2f(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x4f := new Mtr3x4f(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
    public static function operator implicit(m: Mtr4x3f): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3d): Mtr4x3f := new Mtr4x3f(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    
    public static function operator implicit(m: Mtr2x2d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x2d := new Mtr2x2d(m.val00, m.val01, m.val10, m.val11);
    
    public static function operator implicit(m: Mtr3x3d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x3d := new Mtr3x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22);
    
    public static function operator implicit(m: Mtr4x4d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, m.val30, m.val31, m.val32);
    public static function operator implicit(m: Mtr4x3d): Mtr4x4d := new Mtr4x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0, m.val30, m.val31, m.val32, 0.0);
    
    public static function operator implicit(m: Mtr2x3d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x3d := new Mtr2x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12);
    
    public static function operator implicit(m: Mtr3x2d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x2d := new Mtr3x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21);
    
    public static function operator implicit(m: Mtr2x4d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr2x4d := new Mtr2x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0);
    
    public static function operator implicit(m: Mtr4x2d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, 0.0, m.val10, m.val11, 0.0, m.val20, m.val21, 0.0, m.val30, m.val31, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr4x2d := new Mtr4x2d(m.val00, m.val01, m.val10, m.val11, m.val20, m.val21, m.val30, m.val31);
    
    public static function operator implicit(m: Mtr3x4d): Mtr4x3d := new Mtr4x3d(m.val00, m.val01, m.val02, m.val10, m.val11, m.val12, m.val20, m.val21, m.val22, 0.0, 0.0, 0.0);
    public static function operator implicit(m: Mtr4x3d): Mtr3x4d := new Mtr3x4d(m.val00, m.val01, m.val02, 0.0, m.val10, m.val11, m.val12, 0.0, m.val20, m.val21, m.val22, 0.0);
    
  end;
  
  {$endregion Mtr}
  
  {$region Misc}
  
  [StructLayout(LayoutKind.&Explicit)]
  IntFloatUnion = record
    public [FieldOffset(0)] i: integer;
    public [FieldOffset(0)] f: single;
    
    public constructor(i: integer) := self.i := i;
    public constructor(f: single) := self.f := f;
    
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GDI_COLORREF = record
    public [FieldOffset(1)] b: byte;
    public [FieldOffset(2)] g: byte;
    public [FieldOffset(3)] r: byte;
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GPU_Device_Affinity_Info = record
    
    public [FieldOffset(0)] cb: UInt32;
    
    public [FieldOffset(4)] DeviceName: byte;
    // ANSI строка на 32 символа (но конец сроки обозначается сиволом #0, поэтому помещается 31)
    
    public [FieldOffset(36)] DeviceString: byte;
    // ANSI строка на 128 символов (но конец сроки обозначается сиволом #0, поэтому помещается 127)
    
    public [FieldOffset(164)] Flags: UInt32;
    
    public [FieldOffset(168)] rcVirtualScreen_x1: Int32;
    public [FieldOffset(172)] rcVirtualScreen_y1: Int32;
    public [FieldOffset(176)] rcVirtualScreen_x2: Int32;
    public [FieldOffset(180)] rcVirtualScreen_y2: Int32;
    
    public property SDeviceName: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.DeviceName)))
    write
    begin
      if value.Length > 31 then raise new ArgumentException('Строка не может иметь больше 31 символа');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.DeviceName, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
    public property SDeviceString: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.DeviceString)))
    write
    begin
      if value.Length > 127 then raise new ArgumentException('Строка не может иметь больше 127 символов');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.DeviceString, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GLXHyperpipeNetworkSGIX = record
    
    public [FieldOffset(0)] pipeName: byte;
    // ANSI строка на 80 символа (но конец сроки обозначается сиволом #0, поэтому помещается 79)
    
    public [FieldOffset(80)] networkId: Int32;
    
    public property SPipeName: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.pipeName)))
    write
    begin
      if value.Length > 79 then raise new ArgumentException('Строка не может иметь больше 79 символов');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.pipeName, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GLXHyperpipeConfigDataSGIX = record
    
    public [FieldOffset(0)] pipeName: byte;
    // ANSI строка на 80 символа (но конец сроки обозначается сиволом #0, поэтому помещается 79)
    
    public [FieldOffset(80)] channel: Int32;
    public [FieldOffset(84)] participationType: UInt32;
    public [FieldOffset(88)] timeSlice: Int32;
    
    public property SPipeName: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.pipeName)))
    write
    begin
      if value.Length > 79 then raise new ArgumentException('Строка не может иметь больше 79 символов');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.pipeName, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GLXPipeRect = record
    
    public [FieldOffset(0)] pipeName: byte;
    // ANSI строка на 80 символа (но конец сроки обозначается сиволом #0, поэтому помещается 79)
    
    public [FieldOffset(80)] srcXOrigin: Int32;
    public [FieldOffset(84)] srcYOrigin: Int32;
    public [FieldOffset(88)] srcWidth: Int32;
    public [FieldOffset(92)] srcHeight: Int32;
    
    public [FieldOffset(96)] destXOrigin: Int32;
    public [FieldOffset(100)] destYOrigin: Int32;
    public [FieldOffset(104)] destWidth: Int32;
    public [FieldOffset(108)] destHeight: Int32;
    
    public property SPipeName: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.pipeName)))
    write
    begin
      if value.Length > 79 then raise new ArgumentException('Строка не может иметь больше 79 символов');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.pipeName, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
  end;
  
  [StructLayout(LayoutKind.&Explicit)]
  GLXPipeRectLimits = record
    
    public [FieldOffset(0)] pipeName: byte;
    // ANSI строка на 80 символа (но конец сроки обозначается сиволом #0, поэтому помещается 79)
    
    public [FieldOffset(80)] XOrigin: Int32;
    public [FieldOffset(84)] YOrigin: Int32;
    public [FieldOffset(88)] maxHeight: Int32;
    public [FieldOffset(92)] maxWidth: Int32;
    
    public property SPipeName: string
    read Marshal.PtrToStringAnsi(IntPtr(pointer(@self.pipeName)))
    write
    begin
      if value.Length > 79 then raise new ArgumentException('Строка не может иметь больше 79 символов');
      var HStr := Marshal.StringToHGlobalAnsi(value);
      var l: UInt32 := value.Length+1;
      Buffer.MemoryCopy(pointer(HStr), @self.pipeName, l,l);
      Marshal.FreeHGlobal(HStr);
    end;
    
  end;
  
  DrawArraysIndirectCommand = record
    public count:         UInt32;
    public instanceCount: UInt32;
    public first:         UInt32;
    public baseInstance:  UInt32;
    
    public constructor(count, instanceCount, first, baseInstance: UInt32);
    begin
      self.count := count;
      self.instanceCount := instanceCount;
      self.first := first;
      self.baseInstance := baseInstance;
    end;
    
  end;
  
  GDI_GlyphmetricsFloat = record
    public gmfBlackBoxX: single;
    public gmfBlackBoxY: single;
    public gmfptGlyphOriginX: single;
    public gmfptGlyphOriginY: single;
    public gmfCellIncX: single;
    public gmfCellIncY: single;
    
    public constructor(gmfBlackBoxX, gmfBlackBoxY, gmfptGlyphOriginX, gmfptGlyphOriginY, gmfCellIncX, gmfCellIncY: single);
    begin
      self.gmfBlackBoxX := gmfBlackBoxX;
      self.gmfBlackBoxY := gmfBlackBoxY;
      self.gmfptGlyphOriginX := gmfptGlyphOriginX;
      self.gmfptGlyphOriginY := gmfptGlyphOriginY;
      self.gmfCellIncX := gmfCellIncX;
      self.gmfCellIncY := gmfCellIncY;
    end;
    
  end;
  
  //ToDo функции принемающие single - бывает, принимают и fixed
  fixed = record
    {private} val: UInt32;
    
    //ToDo реализовать простейшие операции, с инкапсуляцией но разрешить обращатся к val через свойство
    
  end;
  
  half = record
    {private} val: UInt16;
    
    //ToDo реализовать простейшие операции, с инкапсуляцией но разрешить обращатся к val через свойство
    
  end;
  
  GDI_PixelFormatDescriptor = record
    nSize:            UInt16 := sizeof(GDI_PixelFormatDescriptor);
    nVersion:         UInt16 := 1;
    
    dwFlags:          GDI_PixelFormatFlags;
    iPixelType:       GDI_PixelDataType;
    
    cColorBits:       Byte; // кол-во битов для R+G+B
    
    cRedBits:         Byte; // похоже, если оставить нулями - их автоматом заполнит
    cRedShift:        Byte;
    cGreenBits:       Byte;
    cGreenShift:      Byte;
    cBlueBits:        Byte;
    cBlueShift:       Byte;
    cAlphaBits:       Byte; // последние 2 не работают на Windows
    cAlphaShift:      Byte;
    
    cAccumBits:       Byte;
    cAccumRedBits:    Byte;
    cAccumGreenBits:  Byte;
    cAccumBlueBits:   Byte;
    cAccumAlphaBits:  Byte;
    
    cDepthBits:       Byte;
    cStencilBits:     Byte;
    cAuxBuffers:      Byte; // устарело
    
    iLayerType:       GDI_LayerType; // устарело
    bLayersSize:      Byte; // разделено на 2 числа по 4 бита, и бесполезно без iLayerType, то есть оно тоже устарело
    
    // не смог найти нормального описания последних 3, но все присваивают им нолики
    dwLayerMask:      UInt32;
    dwVisibleMask:    UInt32;
    dwDamageMask:     UInt32;
    
  end;
  
  {$endregion Misc}
  
{$endregion Записи}

type
  
  /// Ядро OpenGL
  /// Все функции отсотированы по разрелу спецификации в исходниках
  gl = static class
    
    {$region 2.0 - OpenGL Fundamentals}
    
    {$region 2.3 - Command Execution}
    
    // 2.3.1
    
    public static function GetError: ErrorCode;
    external 'opengl32.dll' name 'glGetError';
    
    // 2.3.2
    
    public static function GetGraphicsResetStatus: ErrorCode;
    external 'opengl32.dll' name 'glGetGraphicsResetStatus';
    
    // 2.3.3
    
    public static procedure Finish;
    external 'opengl32.dll' name 'glFinish';
    
    public static procedure Flush;
    external 'opengl32.dll' name 'glFlush';
    
    {$endregion 2.3 - Command Execution}
    
    {$endregion 2.0 - OpenGL Fundamentals}
    
    {$region 4.0 - Event Model}
    
    {$region 4.1 - Sync Objects and Fences}
    
    public static function FenceSync(condition: FenceCondition; flags: ReservedFlags): GLsync;
    external 'opengl32.dll' name 'glFenceSync';
    
    public static procedure DeleteSync(sync: GLsync);
    external 'opengl32.dll' name 'glDeleteSync';
    
    // 4.1.1
    
    public static function ClientWaitSync(sync: GLsync; flags: CommandFlushingBehaviorFlags; timeout: TimeSpan): ClientWaitSyncResult;
    external 'opengl32.dll' name 'glClientWaitSync';
    public static function ClientWaitSync(sync: GLsync; flags: CommandFlushingBehaviorFlags; timeout: UInt64): ClientWaitSyncResult;
    external 'opengl32.dll' name 'glClientWaitSync';
    
    public static procedure WaitSync(sync: GLsync; flags: ReservedFlags; timeout: ReservedTimeoutMode);
    external 'opengl32.dll' name 'glWaitSync';
    
    // 4.1.3
    
    public static procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: SyncObjectType);
    external 'opengl32.dll' name 'glGetSynciv';
    public static procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: FenceStatus);
    external 'opengl32.dll' name 'glGetSynciv';
    public static procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: FenceCondition);
    external 'opengl32.dll' name 'glGetSynciv';
    public static procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; var length: Int32; var values: Int32);
    external 'opengl32.dll' name 'glGetSynciv';
    public static procedure GetSynciv(sync: GLsync; pname: SyncObjInfoType; bufSize: Int32; length: pointer; values: pointer);
    external 'opengl32.dll' name 'glGetSynciv';
    
    public static function IsSync(sync: GLsync): boolean;
    external 'opengl32.dll' name 'glIsSync';
    
    {$endregion 4.1 - Sync Objects and Fences}
    
    {$region 4.2 - Query Objects and Asynchronous Queries}
    
    // 4.2.2
    
    public static procedure GenQueries(n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of QueryName);
    external 'opengl32.dll' name 'glGenQueries';
    public static procedure GenQueries(n: Int32; var ids: QueryName);
    external 'opengl32.dll' name 'glGenQueries';
    public static procedure GenQueries(n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glGenQueries';
    
    public static procedure CreateQueries(target: QueryTargetType; n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of QueryName);
    external 'opengl32.dll' name 'glCreateQueries';
    public static procedure CreateQueries(target: QueryTargetType; n: Int32; var ids: QueryName);
    external 'opengl32.dll' name 'glCreateQueries';
    public static procedure CreateQueries(target: QueryTargetType; n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glCreateQueries';
    
    public static procedure DeleteQueries(n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of QueryName);
    external 'opengl32.dll' name 'glDeleteQueries';
    public static procedure DeleteQueries(n: Int32; var ids: QueryName);
    external 'opengl32.dll' name 'glDeleteQueries';
    public static procedure DeleteQueries(n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glDeleteQueries';
    
    public static procedure BeginQueryIndexed(target: QueryTargetType; index: UInt32; id: QueryName);
    external 'opengl32.dll' name 'glBeginQueryIndexed';
    public static procedure BeginQuery(target: QueryTargetType; id: QueryName);
    external 'opengl32.dll' name 'glBeginQuery';
    
    public static procedure EndQueryIndexed(target: QueryTargetType; index: UInt32);
    external 'opengl32.dll' name 'glEndQueryIndexed';
    public static procedure EndQuery(target: QueryTargetType);
    external 'opengl32.dll' name 'glEndQuery';
    
    // 4.2.3
    
    public static function IsQuery(id: QueryName): boolean;
    external 'opengl32.dll' name 'glIsQuery';
    
    public static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: QueryName);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    public static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: Int32);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    public static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: boolean);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    public static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: TimeSpan);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    public static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; var &params: DateTime);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    public static procedure GetQueryIndexediv(target: QueryTargetType; index: UInt32; pname: GetQueryInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryIndexediv';
    
    public static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: QueryName);
    external 'opengl32.dll' name 'glGetQueryiv';
    public static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: Int32);
    external 'opengl32.dll' name 'glGetQueryiv';
    public static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: boolean);
    external 'opengl32.dll' name 'glGetQueryiv';
    public static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: TimeSpan);
    external 'opengl32.dll' name 'glGetQueryiv';
    public static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; var &params: DateTime);
    external 'opengl32.dll' name 'glGetQueryiv';
    public static procedure GetQueryiv(target: QueryTargetType; pname: GetQueryInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryiv';
    
    public static procedure GetQueryObjectiv(id: QueryName; pname: GetQueryObjectInfoName; var &params: Int32);
    external 'opengl32.dll' name 'glGetQueryObjectiv';
    public static procedure GetQueryObjectiv(id: QueryName; pname: GetQueryObjectInfoName; var &params: boolean);
    external 'opengl32.dll' name 'glGetQueryObjectiv';
    public static procedure GetQueryObjectiv(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryObjectiv';
    
    public static procedure GetQueryObjectuiv(id: QueryName; pname: GetQueryObjectInfoName; var &params: UInt32); // QueryName=UInt32, поэтому его можно сюда же передавать
    external 'opengl32.dll' name 'glGetQueryObjectuiv';
    public static procedure GetQueryObjectuiv(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryObjectuiv';
    
    public static procedure GetQueryObjecti64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: Int64);
    external 'opengl32.dll' name 'glGetQueryObjecti64v';
    public static procedure GetQueryObjecti64v(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryObjecti64v';
    
    public static procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: TimeSpan);
    external 'opengl32.dll' name 'glGetQueryObjectui64v';
    public static procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: DateTime);
    external 'opengl32.dll' name 'glGetQueryObjectui64v';
    public static procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; var &params: UInt64);
    external 'opengl32.dll' name 'glGetQueryObjectui64v';
    public static procedure GetQueryObjectui64v(id: QueryName; pname: GetQueryObjectInfoName; &params: pointer);
    external 'opengl32.dll' name 'glGetQueryObjectui64v';
    
    public static procedure GetQueryBufferObjectiv(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr);
    external 'opengl32.dll' name 'glGetQueryBufferObjectiv';
    
    public static procedure GetQueryBufferObjectuiv(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr);
    external 'opengl32.dll' name 'glGetQueryBufferObjectuiv';
    
    public static procedure GetQueryBufferObjecti64v(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr);
    external 'opengl32.dll' name 'glGetQueryBufferObjecti64v';
    
    public static procedure GetQueryBufferObjectui64v(id: QueryName; buffer: BufferName; pname: GetQueryObjectInfoName; offset: IntPtr);
    external 'opengl32.dll' name 'glGetQueryBufferObjectui64v';
    
    {$endregion 4.2 - Query Objects and Asynchronous Queries}
    
    {$region 4.3 - Time Queries}
    
    public static procedure QueryCounter(id: QueryName; target: QueryTargetType);
    external 'opengl32.dll' name 'glQueryCounter';
    
    {$endregion 4.3 - Time Queries}
    
    {$endregion 4.0 - Event Model}
    
    {$region 6.0 - Buffer Objects}
    
    public static procedure GenBuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName);
    external 'opengl32.dll' name 'glGenBuffers';
    public static procedure GenBuffers(n: Int32; var buffers: BufferName);
    external 'opengl32.dll' name 'glGenBuffers';
    public static procedure GenBuffers(n: Int32; buffers: pointer);
    external 'opengl32.dll' name 'glGenBuffers';
    
    public static procedure CreateBuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName);
    external 'opengl32.dll' name 'glCreateBuffers';
    public static procedure CreateBuffers(n: Int32; var buffers: BufferName);
    external 'opengl32.dll' name 'glCreateBuffers';
    public static procedure CreateBuffers(n: Int32; buffers: pointer);
    external 'opengl32.dll' name 'glCreateBuffers';
    
    public static procedure DeleteBuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName);
    external 'opengl32.dll' name 'glDeleteBuffers';
    public static procedure DeleteBuffers(n: Int32; var buffers: BufferName);
    external 'opengl32.dll' name 'glDeleteBuffers';
    public static procedure DeleteBuffers(n: Int32; buffers: pointer);
    external 'opengl32.dll' name 'glDeleteBuffers';
    
    public static function IsBuffer(buffer: BufferName): boolean;
    external 'opengl32.dll' name 'glIsBuffer';
    
    {$region 6.1 - Creating and Binding Buffer Objects}
    
    public static procedure BindBuffer(target: BufferBindType; buffer: BufferName);
    external 'opengl32.dll' name 'glBindBuffer';
    
    // 6.1.1
    
    public static procedure BindBufferRange(target: BufferBindType; index: UInt32; buffer: BufferName; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glBindBufferRange';
    
    public static procedure BindBufferBase(target: BufferBindType; index: UInt32; buffer: BufferName);
    external 'opengl32.dll' name 'glBindBufferBase';
    
    public static procedure BindBuffersBase(target: BufferBindType; first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName);
    external 'opengl32.dll' name 'glBindBuffersBase';
    public static procedure BindBuffersBase(target: BufferBindType; first: UInt32; count: Int32; var buffers: BufferName);
    external 'opengl32.dll' name 'glBindBuffersBase';
    public static procedure BindBuffersBase(target: BufferBindType; first: UInt32; count: Int32; buffers: pointer);
    external 'opengl32.dll' name 'glBindBuffersBase';
    
    public static procedure BindBuffersRange(target: BufferBindType; first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName; [MarshalAs(UnmanagedType.LPArray)] offsets: array of IntPtr; [MarshalAs(UnmanagedType.LPArray)] sizes: array of UIntPtr);
    external 'opengl32.dll' name 'glBindBuffersRange';
    public static procedure BindBuffersRange(target: BufferBindType; first: UInt32; count: Int32; var buffers: BufferName; var offsets: IntPtr; var sizes: UIntPtr);
    external 'opengl32.dll' name 'glBindBuffersRange';
    public static procedure BindBuffersRange(target: BufferBindType; first: UInt32; count: Int32; buffers: pointer; offsets: pointer; sizes: pointer);
    external 'opengl32.dll' name 'glBindBuffersRange';
    
    {$endregion 6.1 - Creating and Binding Buffer Objects}
    
    {$region 6.2 - Creating and Modifying Buffer Object Data Stores}
    
    public static procedure BufferStorage(target: BufferBindType; size: UIntPtr; data: IntPtr; flags: BufferDataUsage);
    external 'opengl32.dll' name 'glBufferStorage';
    public static procedure BufferStorage(target: BufferBindType; size: UIntPtr; data: pointer; flags: BufferDataUsage);
    external 'opengl32.dll' name 'glBufferStorage';
    
    public static procedure NamedBufferStorage(buffer: BufferName; size: UIntPtr; data: IntPtr; flags: BufferDataUsage);
    external 'opengl32.dll' name 'glNamedBufferStorage';
    public static procedure NamedBufferStorage(buffer: BufferName; size: UIntPtr; data: pointer; flags: BufferDataUsage);
    external 'opengl32.dll' name 'glNamedBufferStorage';
    
    public static procedure BufferData(target: BufferBindType; size: UIntPtr; data: IntPtr; usage: BufferDataUsage);
    external 'opengl32.dll' name 'glBufferData';
    public static procedure BufferData(target: BufferBindType; size: UIntPtr; data: pointer; usage: BufferDataUsage);
    external 'opengl32.dll' name 'glBufferData';
    
    public static procedure NamedBufferData(buffer: BufferName; size: UIntPtr; data: IntPtr; usage: BufferDataUsage);
    external 'opengl32.dll' name 'glNamedBufferData';
    public static procedure NamedBufferData(buffer: BufferName; size: UIntPtr; data: pointer; usage: BufferDataUsage);
    external 'opengl32.dll' name 'glNamedBufferData';
    
    public static procedure BufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: IntPtr);
    external 'opengl32.dll' name 'glBufferSubData';
    public static procedure BufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glBufferSubData';
    
    public static procedure NamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: IntPtr);
    external 'opengl32.dll' name 'glNamedBufferSubData';
    public static procedure NamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glNamedBufferSubData';
    
    public static procedure ClearBufferSubData(target: BufferBindType; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearBufferSubData';
    public static procedure ClearBufferSubData(target: BufferBindType; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearBufferSubData';
    
    public static procedure ClearNamedBufferSubData(buffer: BufferName; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearNamedBufferSubData';
    public static procedure ClearNamedBufferSubData(buffer: BufferName; internalformat: InternalDataFormat; offset: IntPtr; size: UIntPtr; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearNamedBufferSubData';
    
    public static procedure ClearBufferData(target: BufferBindType; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearBufferData';
    public static procedure ClearBufferData(target: BufferBindType; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearBufferData';
    
    public static procedure ClearNamedBufferData(buffer: BufferName; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearNamedBufferData';
    public static procedure ClearNamedBufferData(buffer: BufferName; internalformat: InternalDataFormat; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearNamedBufferData';
    
    {$endregion 6.2 - Creating and Modifying Buffer Object Data Stores}
    
    {$region 6.3 - Mapping and Unmapping Buffer Data}
    
    public static function MapBufferRange(target: BufferBindType; offset: IntPtr; length: UIntPtr; access: BufferMapFlags): IntPtr;
    external 'opengl32.dll' name 'glMapBufferRange';
    public static function MapNamedBufferRange(buffer: BufferName; offset: IntPtr; length: UIntPtr; access: BufferMapFlags): IntPtr;
    external 'opengl32.dll' name 'glMapNamedBufferRange';
    
    public static function MapBuffer(target: BufferBindType; access: BufferMapFlags): IntPtr;
    external 'opengl32.dll' name 'glMapBuffer';
    public static function MapNamedBuffer(buffer: BufferName; access: BufferMapFlags): IntPtr;
    external 'opengl32.dll' name 'glMapNamedBuffer';
    
    public static procedure FlushMappedBufferRange(target: BufferBindType; offset: IntPtr; length: UIntPtr);
    external 'opengl32.dll' name 'glFlushMappedBufferRange';
    public static procedure FlushMappedNamedBufferRange(buffer: BufferName; offset: IntPtr; length: UIntPtr);
    external 'opengl32.dll' name 'glFlushMappedNamedBufferRange';
    
    // 6.3.1
    
    public static function UnmapBuffer(target: BufferBindType): boolean;
    external 'opengl32.dll' name 'glUnmapBuffer';
    public static function UnmapNamedBuffer(buffer: BufferName): boolean;
    external 'opengl32.dll' name 'glUnmapNamedBuffer';
    
    {$endregion 6.3 - Mapping and Unmapping Buffer Data}
    
    {$region 6.5 - Invalidating Buffer Data}
    
    public static procedure InvalidateBufferSubData(buffer: BufferName; offset: IntPtr; length: UIntPtr);
    external 'opengl32.dll' name 'glInvalidateBufferSubData';
    
    public static procedure InvalidateBufferData(buffer: BufferName);
    external 'opengl32.dll' name 'glInvalidateBufferData';
    
    {$endregion 6.5 - Invalidating Buffer Data}
    
    {$region 6.6 - Copying Between Buffers}
    
    public static procedure CopyBufferSubData(readTarget, writeTarget: BufferBindType; readOffset, writeOffset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glCopyBufferSubData';
    public static procedure CopyNamedBufferSubData(readBuffer, writeBuffer: BufferName; readOffset, writeOffset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glCopyNamedBufferSubData';
    
    {$endregion 6.6 - Copying Between Buffers}
    
    {$region 6.7 - Buffer Object Queries}
    
    public static procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: BufferDataUsage);
    external 'opengl32.dll' name 'glGetBufferParameteriv';
    public static procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: AccessType);
    external 'opengl32.dll' name 'glGetBufferParameteriv';
    public static procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetBufferParameteriv';
    public static procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetBufferParameteriv';
    public static procedure GetBufferParameteriv(target: BufferBindType; pname: BufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetBufferParameteriv';
    
    public static procedure GetBufferParameteri64v(target: BufferBindType; pname: BufferInfoType; var &params: Int64);
    external 'opengl32.dll' name 'glGetBufferParameteri64v';
    public static procedure GetBufferParameteri64v(target: BufferBindType; pname: BufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetBufferParameteri64v';
    
    public static procedure GetNamedBufferParameteriv(target: BufferName; pname: BufferInfoType; var &params: BufferDataUsage);
    external 'opengl32.dll' name 'glGetNamedBufferParameteriv';
    public static procedure GetNamedBufferParameteriv(target: BufferName; pname: BufferInfoType; var &params: AccessType);
    external 'opengl32.dll' name 'glGetNamedBufferParameteriv';
    public static procedure GetNamedBufferParameteriv(target: BufferName; pname: BufferInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetNamedBufferParameteriv';
    public static procedure GetNamedBufferParameteriv(target: BufferName; pname: BufferInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetNamedBufferParameteriv';
    public static procedure GetNamedBufferParameteriv(target: BufferName; pname: BufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetNamedBufferParameteriv';
    
    public static procedure GetNamedBufferParameteri64v(target: BufferName; pname: BufferInfoType; var &params: Int64);
    external 'opengl32.dll' name 'glGetNamedBufferParameteri64v';
    public static procedure GetNamedBufferParameteri64v(target: BufferName; pname: BufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetNamedBufferParameteri64v';
    
    public static procedure GetBufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: IntPtr);
    external 'opengl32.dll' name 'glGetBufferSubData';
    public static procedure GetBufferSubData(target: BufferBindType; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glGetBufferSubData';
    
    public static procedure GetNamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: IntPtr);
    external 'opengl32.dll' name 'glGetNamedBufferSubData';
    public static procedure GetNamedBufferSubData(buffer: BufferName; offset: IntPtr; size: UIntPtr; data: pointer);
    external 'opengl32.dll' name 'glGetNamedBufferSubData';
    
    public static procedure GetBufferPointerv(target: BufferBindType; pname: BufferInfoType; var &params: IntPtr);
    external 'opengl32.dll' name 'glGetBufferPointerv';
    public static procedure GetBufferPointerv(target: BufferBindType; pname: BufferInfoType; var &params: pointer);
    external 'opengl32.dll' name 'glGetBufferPointerv';
    public static procedure GetBufferPointerv(target: BufferBindType; pname: BufferInfoType; &params: ^IntPtr);
    external 'opengl32.dll' name 'glGetBufferPointerv';
    
    public static procedure GetNamedBufferPointerv(buffer: BufferName; pname: BufferInfoType; var &params: IntPtr);
    external 'opengl32.dll' name 'glGetNamedBufferPointerv';
    public static procedure GetNamedBufferPointerv(buffer: BufferName; pname: BufferInfoType; var &params: pointer);
    external 'opengl32.dll' name 'glGetNamedBufferPointerv';
    public static procedure GetNamedBufferPointerv(buffer: BufferName; pname: BufferInfoType; &params: ^IntPtr);
    external 'opengl32.dll' name 'glGetNamedBufferPointerv';
    
    {$endregion 6.7 - Buffer Object Queries}
    
    {$endregion 6.0 - Buffer Objects}
    
    {$region 7.0 - Programs and Shaders}
    
    {$region 7.1 - Shader Objects}
    
    public static function CreateShader(&type: ShaderType): ShaderName;
    external 'opengl32.dll' name 'glCreateShader';
    
    public static procedure ShaderSource(shader: ShaderName; count: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] strings: array of string; [MarshalAs(UnmanagedType.LPArray)] lengths: array of Int32);
    external 'opengl32.dll' name 'glShaderSource';
    public static procedure ShaderSource(shader: ShaderName; count: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var strings: string; var lengths: Int32);
    external 'opengl32.dll' name 'glShaderSource';
    public static procedure ShaderSource(shader: ShaderName; count: Int32; var strings: IntPtr; var lengths: Int32);
    external 'opengl32.dll' name 'glShaderSource';
    public static procedure ShaderSource(shader: ShaderName; count: Int32; strings: pointer; lengths: pointer);
    external 'opengl32.dll' name 'glShaderSource';
    
    public static procedure CompileShader(shader: ShaderName);
    external 'opengl32.dll' name 'glCompileShader';
    
    public static procedure ReleaseShaderCompiler;
    external 'opengl32.dll' name 'glReleaseShaderCompiler';
    
    public static procedure DeleteShader(shader: ShaderName);
    external 'opengl32.dll' name 'glDeleteShader';
    
    public static function IsShader(shader: ShaderName): boolean;
    external 'opengl32.dll' name 'glIsShader';
    
    {$endregion 7.1 - Shader Objects}
    
    {$region 7.2 - Shader Binaries}
    
    // для получения binaryformat
    // надо вызвать gl.Get... с параметрами:
    // GLGetQueries.NUM_SHADER_BINARY_FORMATS
    // GLGetQueries.SHADER_BINARY_FORMATS
    public static procedure ShaderBinary(count: Int32; [MarshalAs(UnmanagedType.LPArray)] shaders: array of ShaderName; binaryformat: ShaderBinaryFormat; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    public static procedure ShaderBinary(count: Int32; [MarshalAs(UnmanagedType.LPArray)] shaders: array of ShaderName; binaryformat: ShaderBinaryFormat; binary: IntPtr; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    public static procedure ShaderBinary(count: Int32; var shaders: ShaderName; binaryformat: ShaderBinaryFormat; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    public static procedure ShaderBinary(count: Int32; var shaders: ShaderName; binaryformat: ShaderBinaryFormat; binary: IntPtr; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    public static procedure ShaderBinary(count: Int32; shaders: pointer; binaryformat: ShaderBinaryFormat; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    public static procedure ShaderBinary(count: Int32; shaders: pointer; binaryformat: ShaderBinaryFormat; binary: IntPtr; length: Int32);
    external 'opengl32.dll' name 'glShaderBinary';
    
    // 7.2.1
    
    public static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of IntFloatUnion);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of Int32);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of single);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: IntFloatUnion);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: Int32);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: single);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; [MarshalAs(UnmanagedType.LPStr)] pEntryPoint: string; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: pointer);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of IntFloatUnion);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of Int32);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantIndex: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] pConstantValue: array of single);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: IntFloatUnion);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: Int32);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; var pConstantIndex: UInt32; var pConstantValue: single);
    external 'opengl32.dll' name 'glSpecializeShader';
    public static procedure SpecializeShader(shader: ShaderName; pEntryPoint: IntPtr; numSpecializationConstants: UInt32; pConstantIndex: pointer; pConstantValue: pointer);
    external 'opengl32.dll' name 'glSpecializeShader';
    
    {$endregion 7.2 - Shader Binaries}
    
    {$region 7.3 - Program Objects}
    
    public static function CreateProgram: ProgramName;
    external 'opengl32.dll' name 'glCreateProgram';
    
    public static procedure AttachShader(&program: ProgramName; shader: ShaderName);
    external 'opengl32.dll' name 'glAttachShader';
    
    public static procedure DetachShader(&program: ProgramName; shader: ShaderName);
    external 'opengl32.dll' name 'glDetachShader';
    
    public static procedure LinkProgram(&program: ProgramName);
    external 'opengl32.dll' name 'glLinkProgram';
    
    public static procedure UseProgram(&program: ProgramName);
    external 'opengl32.dll' name 'glUseProgram';
    
    public static procedure ProgramParameteri(&program: ProgramName; pname: ProgramParameterType; value: Int32);
    external 'opengl32.dll' name 'glProgramParameteri';
    
    public static procedure DeleteProgram(&program: ProgramName);
    external 'opengl32.dll' name 'glDeleteProgram';
    
    public static function IsProgram(&program: ProgramName): boolean;
    external 'opengl32.dll' name 'glIsProgram';
    
    public static function CreateShaderProgramv(&type: ShaderType; count: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] strings: array of string): ProgramName;
    external 'opengl32.dll' name 'glCreateShaderProgramv';
    public static function CreateShaderProgramv(&type: ShaderType; count: Int32; [MarshalAs(UnmanagedType.LPArray)] strings: array of IntPtr): ProgramName;
    external 'opengl32.dll' name 'glCreateShaderProgramv';
    public static function CreateShaderProgramv(&type: ShaderType; count: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var strings: string): ProgramName;
    external 'opengl32.dll' name 'glCreateShaderProgramv';
    public static function CreateShaderProgramv(&type: ShaderType; count: Int32; var strings: IntPtr): ProgramName;
    external 'opengl32.dll' name 'glCreateShaderProgramv';
    public static function CreateShaderProgramv(&type: ShaderType; count: Int32; strings: pointer): ProgramName;
    external 'opengl32.dll' name 'glCreateShaderProgramv';
    
    // 7.3.1
    
    // 7.3.1.1
    
    public static procedure GetProgramInterfaceiv(&program: ProgramName; programInterface: ProgramInterfaceType; pname: ProgramInterfaceInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetProgramInterfaceiv';
    public static procedure GetProgramInterfaceiv(&program: ProgramName; programInterface: ProgramInterfaceType; pname: ProgramInterfaceInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetProgramInterfaceiv';
    public static procedure GetProgramInterfaceiv(&program: ProgramName; programInterface: ProgramInterfaceType; pname: ProgramInterfaceInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetProgramInterfaceiv';
    
    public static function GetProgramResourceIndex(&program: ProgramName; programInterface: ProgramInterfaceType; [MarshalAs(UnmanagedType.LPStr)] name: string): ProgramResourceIndex;
    external 'opengl32.dll' name 'glGetProgramResourceIndex';
    public static function GetProgramResourceIndex(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): ProgramResourceIndex;
    external 'opengl32.dll' name 'glGetProgramResourceIndex';
    
    public static procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetProgramResourceName';
    public static procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; var length: Int32; name: IntPtr);
    external 'opengl32.dll' name 'glGetProgramResourceName';
    public static procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetProgramResourceName';
    public static procedure GetProgramResourceName(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; bufSize: Int32; length: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetProgramResourceName';
    
    public static procedure GetProgramResourceiv(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; propCount: Int32; [MarshalAs(UnmanagedType.LPArray)] props: array of ProgramInterfaceProperty; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetProgramResourceiv';
    public static procedure GetProgramResourceiv(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; propCount: Int32; var props: ProgramInterfaceProperty; bufSize: Int32; var length: Int32; var &params: ShadingLanguageTypeToken);
    external 'opengl32.dll' name 'glGetProgramResourceiv';
    public static procedure GetProgramResourceiv(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; propCount: Int32; var props: ProgramInterfaceProperty; bufSize: Int32; var length: Int32; var &params: Int32);
    external 'opengl32.dll' name 'glGetProgramResourceiv';
    public static procedure GetProgramResourceiv(&program: ProgramName; programInterface: ProgramInterfaceType; index: ProgramResourceIndex; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: pointer);
    external 'opengl32.dll' name 'glGetProgramResourceiv';
    
    public static function GetProgramResourceLocation(&program: ProgramName; programInterface: ProgramInterfaceType; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetProgramResourceLocation';
    public static function GetProgramResourceLocation(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetProgramResourceLocation';
    
    public static function GetProgramResourceLocationIndex(&program: ProgramName; programInterface: ProgramInterfaceType; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetProgramResourceLocationIndex';
    public static function GetProgramResourceLocationIndex(&program: ProgramName; programInterface: ProgramInterfaceType; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetProgramResourceLocationIndex';
    
    {$endregion 7.3 - Program Objects}
    
    {$region 7.4 - Program Pipeline Objects}
    
    public static procedure GenProgramPipelines(n: Int32; [MarshalAs(UnmanagedType.LPArray)] pipelines: array of ProgramPipelineName);
    external 'opengl32.dll' name 'glGenProgramPipelines';
    public static procedure GenProgramPipelines(n: Int32; var pipelines: ProgramPipelineName);
    external 'opengl32.dll' name 'glGenProgramPipelines';
    public static procedure GenProgramPipelines(n: Int32; pipelines: pointer);
    external 'opengl32.dll' name 'glGenProgramPipelines';
    
    public static procedure DeleteProgramPipelines(n: Int32; [MarshalAs(UnmanagedType.LPArray)] pipelines: array of ProgramPipelineName);
    external 'opengl32.dll' name 'glDeleteProgramPipelines';
    public static procedure DeleteProgramPipelines(n: Int32; var pipelines: ProgramPipelineName);
    external 'opengl32.dll' name 'glDeleteProgramPipelines';
    public static procedure DeleteProgramPipelines(n: Int32; pipelines: pointer);
    external 'opengl32.dll' name 'glDeleteProgramPipelines';
    
    public static function IsProgramPipeline(pipeline: ProgramPipelineName): boolean;
    external 'opengl32.dll' name 'glIsProgramPipeline';
    
    public static procedure BindProgramPipeline(pipeline: ProgramPipelineName);
    external 'opengl32.dll' name 'glBindProgramPipeline';
    
    public static procedure CreateProgramPipelines(n: Int32; [MarshalAs(UnmanagedType.LPArray)] pipelines: array of ProgramPipelineName);
    external 'opengl32.dll' name 'glCreateProgramPipelines';
    public static procedure CreateProgramPipelines(n: Int32; var pipelines: ProgramPipelineName);
    external 'opengl32.dll' name 'glCreateProgramPipelines';
    public static procedure CreateProgramPipelines(n: Int32; pipelines: pointer);
    external 'opengl32.dll' name 'glCreateProgramPipelines';
    
    public static procedure UseProgramStages(pipeline: ProgramPipelineName; stages: ProgramStagesFlags; &program: ProgramName);
    external 'opengl32.dll' name 'glUseProgramStages';
    
    public static procedure ActiveShaderProgram(pipeline: ProgramPipelineName; &program: ProgramName);
    external 'opengl32.dll' name 'glActiveShaderProgram';
    
    {$endregion 7.4 - Program Pipeline Objects}
    
    {$region 7.5 - Program Binaries}
    
    public static procedure GetProgramBinary(&program: ProgramName; bufSize: Int32; var length: Int32; var binaryFormat: ProgramBinaryFormat; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte);
    external 'opengl32.dll' name 'glGetProgramBinary';
    public static procedure GetProgramBinary(&program: ProgramName; bufSize: Int32; var length: Int32; var binaryFormat: ProgramBinaryFormat; binary: IntPtr);
    external 'opengl32.dll' name 'glGetProgramBinary';
    public static procedure GetProgramBinary(&program: ProgramName; bufSize: Int32; length: pointer; binaryFormat: pointer; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte);
    external 'opengl32.dll' name 'glGetProgramBinary';
    public static procedure GetProgramBinary(&program: ProgramName; bufSize: Int32; length: pointer; binaryFormat: pointer; binary: IntPtr);
    external 'opengl32.dll' name 'glGetProgramBinary';
    
    public static procedure ProgramBinary(&program: ProgramName; binaryFormat: ProgramBinaryFormat; [MarshalAs(UnmanagedType.LPArray)] binary: array of byte; length: Int32);
    external 'opengl32.dll' name 'glProgramBinary';
    public static procedure ProgramBinary(&program: ProgramName; binaryFormat: ProgramBinaryFormat; binary: IntPtr; length: Int32);
    external 'opengl32.dll' name 'glProgramBinary';
    
    {$endregion 7.5 - Program Binaries}
    
    {$region 7.6 - Uniform Variables}
    
    public static function GetUniformLocation(&program: ProgramName; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetUniformLocation';
    public static function GetUniformLocation(&program: ProgramName; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetUniformLocation';
    
    public static procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] uniformName: string);
    external 'opengl32.dll' name 'glGetActiveUniformName';
    public static procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; var length: Int32; uniformName: IntPtr);
    external 'opengl32.dll' name 'glGetActiveUniformName';
    public static procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] uniformName: string);
    external 'opengl32.dll' name 'glGetActiveUniformName';
    public static procedure GetActiveUniformName(&program: ProgramName; uniformIndex: UInt32; bufSize: Int32; length: pointer; uniformName: IntPtr);
    external 'opengl32.dll' name 'glGetActiveUniformName';
    
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] uniformNames: array of string; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] uniformNames: array of string; var uniformIndices: UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] uniformNames: array of string; uniformIndices: pointer);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray)] uniformNames: array of IntPtr; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray)] uniformNames: array of IntPtr; var uniformIndices: UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray)] uniformNames: array of IntPtr; uniformIndices: pointer);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var uniformNames: string; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var uniformNames: string; var uniformIndices: UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var uniformNames: string; uniformIndices: pointer);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; var uniformNames: IntPtr; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; var uniformNames: IntPtr; var uniformIndices: UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; var uniformNames: IntPtr; uniformIndices: pointer);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: pointer; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: pointer; var uniformIndices: UInt32);
    external 'opengl32.dll' name 'glGetUniformIndices';
    public static procedure GetUniformIndices(&program: ProgramName; uniformCount: Int32; uniformNames: pointer; uniformIndices: pointer);
    external 'opengl32.dll' name 'glGetUniformIndices';
    
    public static procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ShadingLanguageTypeToken; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveUniform';
    public static procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ShadingLanguageTypeToken; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveUniform';
    public static procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveUniform';
    public static procedure GetActiveUniform(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveUniform';
    
    public static procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; [MarshalAs(UnmanagedType.LPArray)] uniformIndices: array of UInt32; pname: ProgramInterfaceProperty; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetActiveUniformsiv';
    public static procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; var uniformIndices: UInt32; pname: ProgramInterfaceProperty; var &params: ShadingLanguageTypeToken);
    external 'opengl32.dll' name 'glGetActiveUniformsiv';
    public static procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; var uniformIndices: UInt32; pname: ProgramInterfaceProperty; var &params: Int32);
    external 'opengl32.dll' name 'glGetActiveUniformsiv';
    public static procedure GetActiveUniformsiv(&program: ProgramName; uniformCount: Int32; uniformIndices: pointer; pname: ProgramInterfaceProperty; &params: pointer);
    external 'opengl32.dll' name 'glGetActiveUniformsiv';
    
    public static function GetUniformBlockIndex(&program: ProgramName; [MarshalAs(UnmanagedType.LPStr)] uniformBlockName: string): UInt32;
    external 'opengl32.dll' name 'glGetUniformBlockIndex';
    public static function GetUniformBlockIndex(&program: ProgramName; uniformBlockName: IntPtr): UInt32;
    external 'opengl32.dll' name 'glGetUniformBlockIndex';
    
    public static procedure GetActiveUniformBlockName(&program: ProgramName; uniformBlockIndex: UInt32; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] uniformBlockName: string);
    external 'opengl32.dll' name 'glGetActiveUniformBlockName';
    public static procedure GetActiveUniformBlockName(&program: ProgramName; uniformBlockIndex: UInt32; bufSize: Int32; length: pointer; uniformBlockName: IntPtr);
    external 'opengl32.dll' name 'glGetActiveUniformBlockName';
    
    public static procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetActiveUniformBlockiv';
    public static procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; var &params: ShadingLanguageTypeToken);
    external 'opengl32.dll' name 'glGetActiveUniformBlockiv';
    public static procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; var &params: Int32);
    external 'opengl32.dll' name 'glGetActiveUniformBlockiv';
    public static procedure GetActiveUniformBlockiv(&program: ProgramName; uniformBlockIndex: UInt32; pname: ProgramInterfaceProperty; &params: pointer);
    external 'opengl32.dll' name 'glGetActiveUniformBlockiv';
    
    public static procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetActiveAtomicCounterBufferiv';
    public static procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; var &params: ShadingLanguageTypeToken);
    external 'opengl32.dll' name 'glGetActiveAtomicCounterBufferiv';
    public static procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; var &params: Int32);
    external 'opengl32.dll' name 'glGetActiveAtomicCounterBufferiv';
    public static procedure GetActiveAtomicCounterBufferiv(&program: ProgramName; bufferIndex: UInt32; pname: ProgramInterfaceProperty; &params: pointer);
    external 'opengl32.dll' name 'glGetActiveAtomicCounterBufferiv';
    
    // 7.6.1
    
    {$region Uniform[1,2,3,4][i,f,d,ui]}
    
    public static procedure Uniform1i(location: Int32; v0: Int32);
    external 'opengl32.dll' name 'glUniform1i';
    
    public static procedure Uniform2i(location: Int32; v0: Int32; v1: Int32);
    external 'opengl32.dll' name 'glUniform2i';
    
    public static procedure Uniform3i(location: Int32; v0: Int32; v1: Int32; v2: Int32);
    external 'opengl32.dll' name 'glUniform3i';
    
    public static procedure Uniform4i(location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32);
    external 'opengl32.dll' name 'glUniform4i';
    
    public static procedure Uniform1f(location: Int32; v0: single);
    external 'opengl32.dll' name 'glUniform1f';
    
    public static procedure Uniform2f(location: Int32; v0: single; v1: single);
    external 'opengl32.dll' name 'glUniform2f';
    
    public static procedure Uniform3f(location: Int32; v0: single; v1: single; v2: single);
    external 'opengl32.dll' name 'glUniform3f';
    
    public static procedure Uniform4f(location: Int32; v0: single; v1: single; v2: single; v3: single);
    external 'opengl32.dll' name 'glUniform4f';
    
    public static procedure Uniform1d(location: Int32; x: double);
    external 'opengl32.dll' name 'glUniform1d';
    
    public static procedure Uniform2d(location: Int32; x: double; y: double);
    external 'opengl32.dll' name 'glUniform2d';
    
    public static procedure Uniform3d(location: Int32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glUniform3d';
    
    public static procedure Uniform4d(location: Int32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glUniform4d';
    
    public static procedure Uniform1ui(location: Int32; v0: UInt32);
    external 'opengl32.dll' name 'glUniform1ui';
    
    public static procedure Uniform2ui(location: Int32; v0: UInt32; v1: UInt32);
    external 'opengl32.dll' name 'glUniform2ui';
    
    public static procedure Uniform3ui(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32);
    external 'opengl32.dll' name 'glUniform3ui';
    
    public static procedure Uniform4ui(location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32);
    external 'opengl32.dll' name 'glUniform4ui';
    
    {$endregion Uniform[1,2,3,4][i,f,d,ui]}
    
    {$region Uniform[1,2,3,4][i,f,d,ui]v}
    
    public static procedure Uniform1iv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glUniform1iv';
    public static procedure Uniform1iv(location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glUniform1iv';
    public static procedure Uniform1iv(location: Int32; count: Int32; var value: Vec1i);
    external 'opengl32.dll' name 'glUniform1iv';
    public static procedure Uniform1iv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform1iv';
    
    public static procedure Uniform2iv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glUniform2iv';
    public static procedure Uniform2iv(location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glUniform2iv';
    public static procedure Uniform2iv(location: Int32; count: Int32; var value: Vec2i);
    external 'opengl32.dll' name 'glUniform2iv';
    public static procedure Uniform2iv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform2iv';
    
    public static procedure Uniform3iv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glUniform3iv';
    public static procedure Uniform3iv(location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glUniform3iv';
    public static procedure Uniform3iv(location: Int32; count: Int32; var value: Vec3i);
    external 'opengl32.dll' name 'glUniform3iv';
    public static procedure Uniform3iv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform3iv';
    
    public static procedure Uniform4iv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glUniform4iv';
    public static procedure Uniform4iv(location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glUniform4iv';
    public static procedure Uniform4iv(location: Int32; count: Int32; var value: Vec4i);
    external 'opengl32.dll' name 'glUniform4iv';
    public static procedure Uniform4iv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform4iv';
    
    public static procedure Uniform1fv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniform1fv';
    public static procedure Uniform1fv(location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glUniform1fv';
    public static procedure Uniform1fv(location: Int32; count: Int32; var value: Vec1f);
    external 'opengl32.dll' name 'glUniform1fv';
    public static procedure Uniform1fv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform1fv';
    
    public static procedure Uniform2fv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniform2fv';
    public static procedure Uniform2fv(location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glUniform2fv';
    public static procedure Uniform2fv(location: Int32; count: Int32; var value: Vec2f);
    external 'opengl32.dll' name 'glUniform2fv';
    public static procedure Uniform2fv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform2fv';
    
    public static procedure Uniform3fv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniform3fv';
    public static procedure Uniform3fv(location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glUniform3fv';
    public static procedure Uniform3fv(location: Int32; count: Int32; var value: Vec3f);
    external 'opengl32.dll' name 'glUniform3fv';
    public static procedure Uniform3fv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform3fv';
    
    public static procedure Uniform4fv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniform4fv';
    public static procedure Uniform4fv(location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glUniform4fv';
    public static procedure Uniform4fv(location: Int32; count: Int32; var value: Vec4f);
    external 'opengl32.dll' name 'glUniform4fv';
    public static procedure Uniform4fv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform4fv';
    
    public static procedure Uniform1dv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniform1dv';
    public static procedure Uniform1dv(location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glUniform1dv';
    public static procedure Uniform1dv(location: Int32; count: Int32; var value: Vec1d);
    external 'opengl32.dll' name 'glUniform1dv';
    public static procedure Uniform1dv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform1dv';
    
    public static procedure Uniform2dv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniform2dv';
    public static procedure Uniform2dv(location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glUniform2dv';
    public static procedure Uniform2dv(location: Int32; count: Int32; var value: Vec2d);
    external 'opengl32.dll' name 'glUniform2dv';
    public static procedure Uniform2dv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform2dv';
    
    public static procedure Uniform3dv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniform3dv';
    public static procedure Uniform3dv(location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glUniform3dv';
    public static procedure Uniform3dv(location: Int32; count: Int32; var value: Vec3d);
    external 'opengl32.dll' name 'glUniform3dv';
    public static procedure Uniform3dv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform3dv';
    
    public static procedure Uniform4dv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniform4dv';
    public static procedure Uniform4dv(location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glUniform4dv';
    public static procedure Uniform4dv(location: Int32; count: Int32; var value: Vec4d);
    external 'opengl32.dll' name 'glUniform4dv';
    public static procedure Uniform4dv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform4dv';
    
    public static procedure Uniform1uiv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glUniform1uiv';
    public static procedure Uniform1uiv(location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glUniform1uiv';
    public static procedure Uniform1uiv(location: Int32; count: Int32; var value: Vec1ui);
    external 'opengl32.dll' name 'glUniform1uiv';
    public static procedure Uniform1uiv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform1uiv';
    
    public static procedure Uniform2uiv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glUniform2uiv';
    public static procedure Uniform2uiv(location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glUniform2uiv';
    public static procedure Uniform2uiv(location: Int32; count: Int32; var value: Vec2ui);
    external 'opengl32.dll' name 'glUniform2uiv';
    public static procedure Uniform2uiv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform2uiv';
    
    public static procedure Uniform3uiv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glUniform3uiv';
    public static procedure Uniform3uiv(location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glUniform3uiv';
    public static procedure Uniform3uiv(location: Int32; count: Int32; var value: Vec3ui);
    external 'opengl32.dll' name 'glUniform3uiv';
    public static procedure Uniform3uiv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform3uiv';
    
    public static procedure Uniform4uiv(location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glUniform4uiv';
    public static procedure Uniform4uiv(location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glUniform4uiv';
    public static procedure Uniform4uiv(location: Int32; count: Int32; var value: Vec4ui);
    external 'opengl32.dll' name 'glUniform4uiv';
    public static procedure Uniform4uiv(location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glUniform4uiv';
    
    {$endregion Uniform[1,2,3,4][i,f,d,ui]v}
    
    {$region UniformMatrix[2,3,4][f,d]v}
    
    public static procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix2fv';
    public static procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix2fv';
    public static procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2f);
    external 'opengl32.dll' name 'glUniformMatrix2fv';
    public static procedure UniformMatrix2fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2fv';
    
    public static procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix3fv';
    public static procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix3fv';
    public static procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3f);
    external 'opengl32.dll' name 'glUniformMatrix3fv';
    public static procedure UniformMatrix3fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3fv';
    
    public static procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix4fv';
    public static procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix4fv';
    public static procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4f);
    external 'opengl32.dll' name 'glUniformMatrix4fv';
    public static procedure UniformMatrix4fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4fv';
    
    public static procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix2dv';
    public static procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix2dv';
    public static procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2d);
    external 'opengl32.dll' name 'glUniformMatrix2dv';
    public static procedure UniformMatrix2dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2dv';
    
    public static procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix3dv';
    public static procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix3dv';
    public static procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3d);
    external 'opengl32.dll' name 'glUniformMatrix3dv';
    public static procedure UniformMatrix3dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3dv';
    
    public static procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix4dv';
    public static procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix4dv';
    public static procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4d);
    external 'opengl32.dll' name 'glUniformMatrix4dv';
    public static procedure UniformMatrix4dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4dv';
    
    {$endregion UniformMatrix[2,3,4][f,d]v}
    
    {$region UniformMatrix[2x3,3x2,2x4,4x2,3x4,4x3][f,d]v}
    
    public static procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix2x3fv';
    public static procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix2x3fv';
    public static procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3f);
    external 'opengl32.dll' name 'glUniformMatrix2x3fv';
    public static procedure UniformMatrix2x3fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2x3fv';
    
    public static procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix3x2fv';
    public static procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix3x2fv';
    public static procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2f);
    external 'opengl32.dll' name 'glUniformMatrix3x2fv';
    public static procedure UniformMatrix3x2fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3x2fv';
    
    public static procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix2x4fv';
    public static procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix2x4fv';
    public static procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4f);
    external 'opengl32.dll' name 'glUniformMatrix2x4fv';
    public static procedure UniformMatrix2x4fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2x4fv';
    
    public static procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix4x2fv';
    public static procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix4x2fv';
    public static procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2f);
    external 'opengl32.dll' name 'glUniformMatrix4x2fv';
    public static procedure UniformMatrix4x2fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4x2fv';
    
    public static procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix3x4fv';
    public static procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix3x4fv';
    public static procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4f);
    external 'opengl32.dll' name 'glUniformMatrix3x4fv';
    public static procedure UniformMatrix3x4fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3x4fv';
    
    public static procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glUniformMatrix4x3fv';
    public static procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glUniformMatrix4x3fv';
    public static procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3f);
    external 'opengl32.dll' name 'glUniformMatrix4x3fv';
    public static procedure UniformMatrix4x3fv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4x3fv';
    
    public static procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix2x3dv';
    public static procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix2x3dv';
    public static procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3d);
    external 'opengl32.dll' name 'glUniformMatrix2x3dv';
    public static procedure UniformMatrix2x3dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2x3dv';
    
    public static procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix3x2dv';
    public static procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix3x2dv';
    public static procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2d);
    external 'opengl32.dll' name 'glUniformMatrix3x2dv';
    public static procedure UniformMatrix3x2dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3x2dv';
    
    public static procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix2x4dv';
    public static procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix2x4dv';
    public static procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4d);
    external 'opengl32.dll' name 'glUniformMatrix2x4dv';
    public static procedure UniformMatrix2x4dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix2x4dv';
    
    public static procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix4x2dv';
    public static procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix4x2dv';
    public static procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2d);
    external 'opengl32.dll' name 'glUniformMatrix4x2dv';
    public static procedure UniformMatrix4x2dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4x2dv';
    
    public static procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix3x4dv';
    public static procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix3x4dv';
    public static procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4d);
    external 'opengl32.dll' name 'glUniformMatrix3x4dv';
    public static procedure UniformMatrix3x4dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix3x4dv';
    
    public static procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glUniformMatrix4x3dv';
    public static procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glUniformMatrix4x3dv';
    public static procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3d);
    external 'opengl32.dll' name 'glUniformMatrix4x3dv';
    public static procedure UniformMatrix4x3dv(location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glUniformMatrix4x3dv';
    
    {$endregion UniformMatrix[2x3,3x2,2x4,4x2,3x4,4x3][f,d]v}
    
    {$region ProgramUniform[1,2,3,4][i,f,d,ui]}
    
    public static procedure ProgramUniform1i(&program: ProgramName; location: Int32; v0: Int32);
    external 'opengl32.dll' name 'glProgramUniform1i';
    
    public static procedure ProgramUniform2i(&program: ProgramName; location: Int32; v0: Int32; v1: Int32);
    external 'opengl32.dll' name 'glProgramUniform2i';
    
    public static procedure ProgramUniform3i(&program: ProgramName; location: Int32; v0: Int32; v1: Int32; v2: Int32);
    external 'opengl32.dll' name 'glProgramUniform3i';
    
    public static procedure ProgramUniform4i(&program: ProgramName; location: Int32; v0: Int32; v1: Int32; v2: Int32; v3: Int32);
    external 'opengl32.dll' name 'glProgramUniform4i';
    
    public static procedure ProgramUniform1f(&program: ProgramName; location: Int32; v0: single);
    external 'opengl32.dll' name 'glProgramUniform1f';
    
    public static procedure ProgramUniform2f(&program: ProgramName; location: Int32; v0: single; v1: single);
    external 'opengl32.dll' name 'glProgramUniform2f';
    
    public static procedure ProgramUniform3f(&program: ProgramName; location: Int32; v0: single; v1: single; v2: single);
    external 'opengl32.dll' name 'glProgramUniform3f';
    
    public static procedure ProgramUniform4f(&program: ProgramName; location: Int32; v0: single; v1: single; v2: single; v3: single);
    external 'opengl32.dll' name 'glProgramUniform4f';
    
    public static procedure ProgramUniform1d(&program: ProgramName; location: Int32; x: double);
    external 'opengl32.dll' name 'glProgramUniform1d';
    
    public static procedure ProgramUniform2d(&program: ProgramName; location: Int32; x: double; y: double);
    external 'opengl32.dll' name 'glProgramUniform2d';
    
    public static procedure ProgramUniform3d(&program: ProgramName; location: Int32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glProgramUniform3d';
    
    public static procedure ProgramUniform4d(&program: ProgramName; location: Int32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glProgramUniform4d';
    
    public static procedure ProgramUniform1ui(&program: ProgramName; location: Int32; v0: UInt32);
    external 'opengl32.dll' name 'glProgramUniform1ui';
    
    public static procedure ProgramUniform2ui(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32);
    external 'opengl32.dll' name 'glProgramUniform2ui';
    
    public static procedure ProgramUniform3ui(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32);
    external 'opengl32.dll' name 'glProgramUniform3ui';
    
    public static procedure ProgramUniform4ui(&program: ProgramName; location: Int32; v0: UInt32; v1: UInt32; v2: UInt32; v3: UInt32);
    external 'opengl32.dll' name 'glProgramUniform4ui';
    
    {$endregion ProgramUniform[1,2,3,4][i,f,d,ui]}
    
    {$region ProgramUniform[1,2,3,4][i,f,d,ui]v}
    
    public static procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glProgramUniform1iv';
    public static procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glProgramUniform1iv';
    public static procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1i);
    external 'opengl32.dll' name 'glProgramUniform1iv';
    public static procedure ProgramUniform1iv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform1iv';
    
    public static procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glProgramUniform2iv';
    public static procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glProgramUniform2iv';
    public static procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2i);
    external 'opengl32.dll' name 'glProgramUniform2iv';
    public static procedure ProgramUniform2iv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform2iv';
    
    public static procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glProgramUniform3iv';
    public static procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glProgramUniform3iv';
    public static procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3i);
    external 'opengl32.dll' name 'glProgramUniform3iv';
    public static procedure ProgramUniform3iv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform3iv';
    
    public static procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glProgramUniform4iv';
    public static procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; var value: Int32);
    external 'opengl32.dll' name 'glProgramUniform4iv';
    public static procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4i);
    external 'opengl32.dll' name 'glProgramUniform4iv';
    public static procedure ProgramUniform4iv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform4iv';
    
    public static procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniform1fv';
    public static procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glProgramUniform1fv';
    public static procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1f);
    external 'opengl32.dll' name 'glProgramUniform1fv';
    public static procedure ProgramUniform1fv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform1fv';
    
    public static procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniform2fv';
    public static procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glProgramUniform2fv';
    public static procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2f);
    external 'opengl32.dll' name 'glProgramUniform2fv';
    public static procedure ProgramUniform2fv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform2fv';
    
    public static procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniform3fv';
    public static procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glProgramUniform3fv';
    public static procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3f);
    external 'opengl32.dll' name 'glProgramUniform3fv';
    public static procedure ProgramUniform3fv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform3fv';
    
    public static procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniform4fv';
    public static procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; var value: single);
    external 'opengl32.dll' name 'glProgramUniform4fv';
    public static procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4f);
    external 'opengl32.dll' name 'glProgramUniform4fv';
    public static procedure ProgramUniform4fv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform4fv';
    
    public static procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniform1dv';
    public static procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glProgramUniform1dv';
    public static procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1d);
    external 'opengl32.dll' name 'glProgramUniform1dv';
    public static procedure ProgramUniform1dv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform1dv';
    
    public static procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniform2dv';
    public static procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glProgramUniform2dv';
    public static procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2d);
    external 'opengl32.dll' name 'glProgramUniform2dv';
    public static procedure ProgramUniform2dv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform2dv';
    
    public static procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniform3dv';
    public static procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glProgramUniform3dv';
    public static procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3d);
    external 'opengl32.dll' name 'glProgramUniform3dv';
    public static procedure ProgramUniform3dv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform3dv';
    
    public static procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniform4dv';
    public static procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; var value: double);
    external 'opengl32.dll' name 'glProgramUniform4dv';
    public static procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4d);
    external 'opengl32.dll' name 'glProgramUniform4dv';
    public static procedure ProgramUniform4dv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform4dv';
    
    public static procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glProgramUniform1uiv';
    public static procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glProgramUniform1uiv';
    public static procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec1ui);
    external 'opengl32.dll' name 'glProgramUniform1uiv';
    public static procedure ProgramUniform1uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform1uiv';
    
    public static procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glProgramUniform2uiv';
    public static procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glProgramUniform2uiv';
    public static procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec2ui);
    external 'opengl32.dll' name 'glProgramUniform2uiv';
    public static procedure ProgramUniform2uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform2uiv';
    
    public static procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glProgramUniform3uiv';
    public static procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glProgramUniform3uiv';
    public static procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec3ui);
    external 'opengl32.dll' name 'glProgramUniform3uiv';
    public static procedure ProgramUniform3uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform3uiv';
    
    public static procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glProgramUniform4uiv';
    public static procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glProgramUniform4uiv';
    public static procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; var value: Vec4ui);
    external 'opengl32.dll' name 'glProgramUniform4uiv';
    public static procedure ProgramUniform4uiv(&program: ProgramName; location: Int32; count: Int32; value: pointer);
    external 'opengl32.dll' name 'glProgramUniform4uiv';
    
    {$endregion ProgramUniform[1,2,3,4][i,f,d,ui]v}
    
    {$region ProgramUniformMatrix[2,3,4][f,d]v}
    
    public static procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2fv';
    public static procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2fv';
    public static procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2f);
    external 'opengl32.dll' name 'glProgramUniformMatrix2fv';
    public static procedure ProgramUniformMatrix2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2fv';
    
    public static procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3fv';
    public static procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3fv';
    public static procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3f);
    external 'opengl32.dll' name 'glProgramUniformMatrix3fv';
    public static procedure ProgramUniformMatrix3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3fv';
    
    public static procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4fv';
    public static procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4fv';
    public static procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4f);
    external 'opengl32.dll' name 'glProgramUniformMatrix4fv';
    public static procedure ProgramUniformMatrix4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4fv';
    
    public static procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2dv';
    public static procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2dv';
    public static procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2d);
    external 'opengl32.dll' name 'glProgramUniformMatrix2dv';
    public static procedure ProgramUniformMatrix2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2dv';
    
    public static procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3dv';
    public static procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3dv';
    public static procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3d);
    external 'opengl32.dll' name 'glProgramUniformMatrix3dv';
    public static procedure ProgramUniformMatrix3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3dv';
    
    public static procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4dv';
    public static procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4dv';
    public static procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4d);
    external 'opengl32.dll' name 'glProgramUniformMatrix4dv';
    public static procedure ProgramUniformMatrix4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4dv';
    
    {$endregion ProgramUniformMatrix[2,3,4][f,d]v}
    
    {$region ProgramUniformMatrix[2x3,3x2,2x4,4x2,3x4,4x3][f,d]v}
    
    public static procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3fv';
    public static procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3fv';
    public static procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3f);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3fv';
    public static procedure ProgramUniformMatrix2x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3fv';
    
    public static procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2fv';
    public static procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2fv';
    public static procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2f);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2fv';
    public static procedure ProgramUniformMatrix3x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2fv';
    
    public static procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4fv';
    public static procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4fv';
    public static procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4f);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4fv';
    public static procedure ProgramUniformMatrix2x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4fv';
    
    public static procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2fv';
    public static procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2fv';
    public static procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2f);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2fv';
    public static procedure ProgramUniformMatrix4x2fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2fv';
    
    public static procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4fv';
    public static procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4fv';
    public static procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4f);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4fv';
    public static procedure ProgramUniformMatrix3x4fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4fv';
    
    public static procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3fv';
    public static procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: single);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3fv';
    public static procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3f);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3fv';
    public static procedure ProgramUniformMatrix4x3fv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3fv';
    
    public static procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3dv';
    public static procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3dv';
    public static procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x3d);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3dv';
    public static procedure ProgramUniformMatrix2x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x3dv';
    
    public static procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2dv';
    public static procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2dv';
    public static procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x2d);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2dv';
    public static procedure ProgramUniformMatrix3x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x2dv';
    
    public static procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4dv';
    public static procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4dv';
    public static procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr2x4d);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4dv';
    public static procedure ProgramUniformMatrix2x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix2x4dv';
    
    public static procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2dv';
    public static procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2dv';
    public static procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x2d);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2dv';
    public static procedure ProgramUniformMatrix4x2dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x2dv';
    
    public static procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4dv';
    public static procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4dv';
    public static procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr3x4d);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4dv';
    public static procedure ProgramUniformMatrix3x4dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix3x4dv';
    
    public static procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; [MarshalAs(UnmanagedType.LPArray)] value: array of double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3dv';
    public static procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: double);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3dv';
    public static procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; var value: Mtr4x3d);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3dv';
    public static procedure ProgramUniformMatrix4x3dv(&program: ProgramName; location: Int32; count: Int32; transpose: boolean; value: pointer);
    external 'opengl32.dll' name 'glProgramUniformMatrix4x3dv';
    
    {$endregion ProgramUniformMatrix[2x3,3x2,2x4,4x2,3x4,4x3][f,d]v}
    
    // 7.6.3
    
    public static procedure UniformBlockBinding(&program: ProgramName; uniformBlockIndex: UInt32; uniformBlockBinding: UInt32);
    external 'opengl32.dll' name 'glUniformBlockBinding';
    
    {$endregion 7.6 - Uniform Variables}
    
    {$region 7.8 - Shader Buffer Variables and Shader Storage Blocks}
    
    public static procedure ShaderStorageBlockBinding(&program: ProgramName; storageBlockIndex: UInt32; storageBlockBinding: UInt32);
    external 'opengl32.dll' name 'glShaderStorageBlockBinding';
    
    {$endregion 7.8 - Shader Buffer Variables and Shader Storage Blocks}
    
    {$region 7.10 - Subroutine Uniform Variables}
    
    public static function GetSubroutineIndex(&program: ProgramName; _shadertype: ShaderType; [MarshalAs(UnmanagedType.LPStr)] name: string): UInt32;
    external 'opengl32.dll' name 'glGetSubroutineIndex';
    public static function GetSubroutineIndex(&program: ProgramName; _shadertype: ShaderType; name: IntPtr): UInt32;
    external 'opengl32.dll' name 'glGetSubroutineIndex';
    
    public static procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveSubroutineName';
    public static procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveSubroutineName';
    public static procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveSubroutineName';
    public static procedure GetActiveSubroutineName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveSubroutineName';
    
    public static function GetSubroutineUniformLocation(&program: ProgramName; _shadertype: ShaderType; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetSubroutineUniformLocation';
    public static function GetSubroutineUniformLocation(&program: ProgramName; _shadertype: ShaderType; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetSubroutineUniformLocation';
    
    public static procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformName';
    public static procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; var length: Int32; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformName';
    public static procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformName';
    public static procedure GetActiveSubroutineUniformName(&program: ProgramName; _shadertype: ShaderType; index: UInt32; bufsize: Int32; length: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformName';
    
    public static procedure GetActiveSubroutineUniformiv(&program: ProgramName; _shadertype: ShaderType; index: UInt32; pname: ProgramInterfaceProperty; [MarshalAs(UnmanagedType.LPArray)] values: array of Int32);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformiv';
    public static procedure GetActiveSubroutineUniformiv(&program: ProgramName; _shadertype: ShaderType; index: UInt32; pname: ProgramInterfaceProperty; var values: Int32);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformiv';
    public static procedure GetActiveSubroutineUniformiv(&program: ProgramName; _shadertype: ShaderType; index: UInt32; pname: ProgramInterfaceProperty; values: pointer);
    external 'opengl32.dll' name 'glGetActiveSubroutineUniformiv';
    
    public static procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32);
    external 'opengl32.dll' name 'glUniformSubroutinesuiv';
    public static procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; var indices: UInt32);
    external 'opengl32.dll' name 'glUniformSubroutinesuiv';
    public static procedure UniformSubroutinesuiv(_shadertype: ShaderType; count: Int32; indices: pointer);
    external 'opengl32.dll' name 'glUniformSubroutinesuiv';
    
    {$endregion 7.10 - Subroutine Uniform Variables}
    
    {$region 7.13 - Shader Memory Access}
    
    //7.13.2
    
    public static procedure MemoryBarrier(barriers: MemoryBarrierTypeFlags);
    external 'opengl32.dll' name 'glMemoryBarrier';
    
    public static procedure MemoryBarrierByRegion(barriers: MemoryBarrierTypeFlags);
    external 'opengl32.dll' name 'glMemoryBarrierByRegion';
    
    {$endregion 7.13 - Shader Memory Access}
    
    {$region 7.14 - Shader, Program, and Program Pipeline Queries}
    
    public static procedure GetShaderiv(shader: ShaderName; pname: ShaderInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetShaderiv';
    public static procedure GetShaderiv(shader: ShaderName; pname: ShaderInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetShaderiv';
    public static procedure GetShaderiv(shader: ShaderName; pname: ShaderInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetShaderiv';
    
    public static procedure GetProgramiv(&program: ProgramName; pname: ProgramInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetProgramiv';
    public static procedure GetProgramiv(&program: ProgramName; pname: ProgramInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetProgramiv';
    public static procedure GetProgramiv(&program: ProgramName; pname: ProgramInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetProgramiv';
    
    public static procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; var &params: ProgramName);
    external 'opengl32.dll' name 'glGetProgramPipelineiv';
    public static procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; var &params: ErrorCode);
    external 'opengl32.dll' name 'glGetProgramPipelineiv';
    public static procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetProgramPipelineiv';
    public static procedure GetProgramPipelineiv(pipeline: ProgramPipelineName; pname: ProgramPipelineInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetProgramPipelineiv';
    
    public static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; var count: Int32; [MarshalAs(UnmanagedType.LPArray)] shaders: array of ShaderName);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    public static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; var count: Int32; var shaders: ShaderName);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    public static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; var count: Int32; shaders: pointer);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    public static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; count: pointer; [MarshalAs(UnmanagedType.LPArray)] shaders: array of ShaderName);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    public static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; count: pointer; var shaders: ShaderName);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    public static procedure GetAttachedShaders(&program: ProgramName; maxCount: Int32; count: pointer; shaders: pointer);
    external 'opengl32.dll' name 'glGetAttachedShaders';
    
    public static procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetShaderInfoLog';
    public static procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; var length: Int32; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetShaderInfoLog';
    public static procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetShaderInfoLog';
    public static procedure GetShaderInfoLog(shader: ShaderName; bufSize: Int32; length: pointer; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetShaderInfoLog';
    
    public static procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetProgramInfoLog';
    public static procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; var length: Int32; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetProgramInfoLog';
    public static procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetProgramInfoLog';
    public static procedure GetProgramInfoLog(&program: ProgramName; bufSize: Int32; length: pointer; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetProgramInfoLog';
    
    public static procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetProgramPipelineInfoLog';
    public static procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; var length: Int32; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetProgramPipelineInfoLog';
    public static procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] infoLog: string);
    external 'opengl32.dll' name 'glGetProgramPipelineInfoLog';
    public static procedure GetProgramPipelineInfoLog(pipeline: ProgramPipelineName; bufSize: Int32; length: pointer; infoLog: IntPtr);
    external 'opengl32.dll' name 'glGetProgramPipelineInfoLog';
    
    public static procedure GetShaderSource(shader: ShaderName; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] source: string);
    external 'opengl32.dll' name 'glGetShaderSource';
    public static procedure GetShaderSource(shader: ShaderName; bufSize: Int32; var length: Int32; source: IntPtr);
    external 'opengl32.dll' name 'glGetShaderSource';
    public static procedure GetShaderSource(shader: ShaderName; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] source: string);
    external 'opengl32.dll' name 'glGetShaderSource';
    public static procedure GetShaderSource(shader: ShaderName; bufSize: Int32; length: pointer; source: IntPtr);
    external 'opengl32.dll' name 'glGetShaderSource';
    
    public static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; [MarshalAs(UnmanagedType.LPArray)] range: array of Int32; var precision: Int32);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    public static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; [MarshalAs(UnmanagedType.LPArray)] range: array of Int32; precision: pointer);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    public static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; var range: Vec2i; var precision: Int32);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    public static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; var range: Vec2i; precision: pointer);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    public static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; range: pointer; var precision: Int32);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    public static procedure GetShaderPrecisionFormat(_shadertype: ShaderType; precisiontype: ShaderPrecisionFormatType; range: pointer; precision: pointer);
    external 'opengl32.dll' name 'glGetShaderPrecisionFormat';
    
    public static procedure GetUniformfv(&program: ProgramName; location: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of single);
    external 'opengl32.dll' name 'glGetUniformfv';
    public static procedure GetUniformfv(&program: ProgramName; location: Int32; var &params: single);
    external 'opengl32.dll' name 'glGetUniformfv';
    public static procedure GetUniformfv(&program: ProgramName; location: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetUniformfv';
    
    public static procedure GetUniformdv(&program: ProgramName; location: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of double);
    external 'opengl32.dll' name 'glGetUniformdv';
    public static procedure GetUniformdv(&program: ProgramName; location: Int32; var &params: double);
    external 'opengl32.dll' name 'glGetUniformdv';
    public static procedure GetUniformdv(&program: ProgramName; location: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetUniformdv';
    
    public static procedure GetUniformiv(&program: ProgramName; location: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetUniformiv';
    public static procedure GetUniformiv(&program: ProgramName; location: Int32; var &params: Int32);
    external 'opengl32.dll' name 'glGetUniformiv';
    public static procedure GetUniformiv(&program: ProgramName; location: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetUniformiv';
    
    public static procedure GetUniformuiv(&program: ProgramName; location: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformuiv';
    public static procedure GetUniformuiv(&program: ProgramName; location: Int32; var &params: UInt32);
    external 'opengl32.dll' name 'glGetUniformuiv';
    public static procedure GetUniformuiv(&program: ProgramName; location: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetUniformuiv';
    
    public static procedure GetnUniformfv(&program: ProgramName; location: Int32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of single);
    external 'opengl32.dll' name 'glGetnUniformfv';
    public static procedure GetnUniformfv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: single);
    external 'opengl32.dll' name 'glGetnUniformfv';
    public static procedure GetnUniformfv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetnUniformfv';
    
    public static procedure GetnUniformdv(&program: ProgramName; location: Int32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of double);
    external 'opengl32.dll' name 'glGetnUniformdv';
    public static procedure GetnUniformdv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: double);
    external 'opengl32.dll' name 'glGetnUniformdv';
    public static procedure GetnUniformdv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetnUniformdv';
    
    public static procedure GetnUniformiv(&program: ProgramName; location: Int32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetnUniformiv';
    public static procedure GetnUniformiv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: Int32);
    external 'opengl32.dll' name 'glGetnUniformiv';
    public static procedure GetnUniformiv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetnUniformiv';
    
    public static procedure GetnUniformuiv(&program: ProgramName; location: Int32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of UInt32);
    external 'opengl32.dll' name 'glGetnUniformuiv';
    public static procedure GetnUniformuiv(&program: ProgramName; location: Int32; bufSize: Int32; var &params: UInt32);
    external 'opengl32.dll' name 'glGetnUniformuiv';
    public static procedure GetnUniformuiv(&program: ProgramName; location: Int32; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetnUniformuiv';
    
    public static procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of UInt32);
    external 'opengl32.dll' name 'glGetUniformSubroutineuiv';
    public static procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; var &params: UInt32);
    external 'opengl32.dll' name 'glGetUniformSubroutineuiv';
    public static procedure GetUniformSubroutineuiv(_shadertype: ShaderType; location: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetUniformSubroutineuiv';
    
    public static procedure GetProgramStageiv(&program: ProgramName; _shadertype: ShaderType; pname: ActiveSubroutineInfoType; [MarshalAs(UnmanagedType.LPArray)] values: array of Int32);
    external 'opengl32.dll' name 'glGetProgramStageiv';
    public static procedure GetProgramStageiv(&program: ProgramName; _shadertype: ShaderType; pname: ActiveSubroutineInfoType; var values: Int32);
    external 'opengl32.dll' name 'glGetProgramStageiv';
    public static procedure GetProgramStageiv(&program: ProgramName; _shadertype: ShaderType; pname: ActiveSubroutineInfoType; values: pointer);
    external 'opengl32.dll' name 'glGetProgramStageiv';
    
    {$endregion 7.14 - Shader, Program, and Program Pipeline Queries}
    
    {$endregion 7.0 - Programs and Shaders}
    
    {$region 8.0 - Textures and Samplers}
    
    public static procedure ActiveTexture(texture: TextureUnitId);
    external 'opengl32.dll' name 'glActiveTexture';
    
    {$region 8.1 - Texture Objects}
    
    public static procedure GenTextures(n: Int32; [MarshalAs(UnmanagedType.LPArray)] textures: array of TextureName);
    external 'opengl32.dll' name 'glGenTextures';
    public static procedure GenTextures(n: Int32; var textures: TextureName);
    external 'opengl32.dll' name 'glGenTextures';
    public static procedure GenTextures(n: Int32; textures: pointer);
    external 'opengl32.dll' name 'glGenTextures';
    
    public static procedure BindTexture(target: TextureBindTarget; texture: TextureName);
    external 'opengl32.dll' name 'glBindTexture';
    
    public static procedure BindTextures(first: TextureUnitId; count: Int32; [MarshalAs(UnmanagedType.LPArray)] textures: array of TextureName);
    external 'opengl32.dll' name 'glBindTextures';
    public static procedure BindTextures(first: TextureUnitId; count: Int32; var textures: TextureName);
    external 'opengl32.dll' name 'glBindTextures';
    public static procedure BindTextures(first: TextureUnitId; count: Int32; textures: pointer);
    external 'opengl32.dll' name 'glBindTextures';
    
    public static procedure BindTextureUnit(&unit: TextureUnitId; texture: TextureName);
    external 'opengl32.dll' name 'glBindTextureUnit';
    
    public static procedure CreateTextures(target: TextureBindTarget; n: Int32; [MarshalAs(UnmanagedType.LPArray)] textures: array of TextureName);
    external 'opengl32.dll' name 'glCreateTextures';
    public static procedure CreateTextures(target: TextureBindTarget; n: Int32; var textures: TextureName);
    external 'opengl32.dll' name 'glCreateTextures';
    public static procedure CreateTextures(target: TextureBindTarget; n: Int32; textures: pointer);
    external 'opengl32.dll' name 'glCreateTextures';
    
    public static procedure DeleteTextures(n: Int32; [MarshalAs(UnmanagedType.LPArray)] textures: array of TextureName);
    external 'opengl32.dll' name 'glDeleteTextures';
    public static procedure DeleteTextures(n: Int32; var textures: TextureName);
    external 'opengl32.dll' name 'glDeleteTextures';
    public static procedure DeleteTextures(n: Int32; textures: pointer);
    external 'opengl32.dll' name 'glDeleteTextures';
    
    public static function IsTexture(texture: TextureName): boolean;
    external 'opengl32.dll' name 'glIsTexture';
    
    {$endregion 8.1 - Texture Objects}
    
    {$region 8.2 - Sampler Objects}
    
    public static procedure GenSamplers(count: Int32; [MarshalAs(UnmanagedType.LPArray)] samplers: array of SamplerName);
    external 'opengl32.dll' name 'glGenSamplers';
    public static procedure GenSamplers(count: Int32; var samplers: SamplerName);
    external 'opengl32.dll' name 'glGenSamplers';
    public static procedure GenSamplers(count: Int32; samplers: pointer);
    external 'opengl32.dll' name 'glGenSamplers';
    
    public static procedure CreateSamplers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] samplers: array of SamplerName);
    external 'opengl32.dll' name 'glCreateSamplers';
    public static procedure CreateSamplers(n: Int32; var samplers: SamplerName);
    external 'opengl32.dll' name 'glCreateSamplers';
    public static procedure CreateSamplers(n: Int32; samplers: pointer);
    external 'opengl32.dll' name 'glCreateSamplers';
    
    public static procedure BindSampler(&unit: Int32; sampler: SamplerName);
    external 'opengl32.dll' name 'glBindSampler';
    
    public static procedure BindSamplers(first: Int32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] samplers: array of SamplerName);
    external 'opengl32.dll' name 'glBindSamplers';
    public static procedure BindSamplers(first: Int32; count: Int32; var samplers: SamplerName);
    external 'opengl32.dll' name 'glBindSamplers';
    public static procedure BindSamplers(first: Int32; count: Int32; samplers: pointer);
    external 'opengl32.dll' name 'glBindSamplers';
    
    public static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: TextureCompareMode);
    external 'opengl32.dll' name 'glSamplerParameteri';
    public static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: ActivationFunc);
    external 'opengl32.dll' name 'glSamplerParameteri';
    public static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: PixelMagFilterMode);
    external 'opengl32.dll' name 'glSamplerParameteri';
    public static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: PixelMinFilterMode);
    external 'opengl32.dll' name 'glSamplerParameteri';
    public static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: PixelWrapMode);
    external 'opengl32.dll' name 'glSamplerParameteri';
    public static procedure SamplerParameteri(sampler: SamplerName; pname: TextureInfoType; param: Int32); // нигде не используется, существует только для совместимости с .val
    external 'opengl32.dll' name 'glSamplerParameteri';
    
    public static procedure SamplerParameterf(sampler: SamplerName; pname: TextureInfoType; param: single);
    external 'opengl32.dll' name 'glSamplerParameterf';
    
    public static procedure SamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var param: Int32);
    external 'opengl32.dll' name 'glSamplerParameteriv';
    public static procedure SamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glSamplerParameteriv';
    
    public static procedure SamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; var param: single);
    external 'opengl32.dll' name 'glSamplerParameterfv';
    public static procedure SamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glSamplerParameterfv';
    
    public static procedure SamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; var param: Int32); // нигде не используется, существует только для совместимости с .val
    external 'opengl32.dll' name 'glSamplerParameterIiv';
    public static procedure SamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glSamplerParameterIiv';
    
    public static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: TextureCompareMode);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    public static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: ActivationFunc);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    public static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: PixelMagFilterMode);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    public static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: PixelMinFilterMode);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    public static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: PixelWrapMode);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    public static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var param: UInt32); // нигде не используется, существует только для совместимости с .val
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    public static procedure SamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glSamplerParameterIuiv';
    
    public static procedure DeleteSamplers(count: Int32; [MarshalAs(UnmanagedType.LPArray)] samplers: array of SamplerName);
    external 'opengl32.dll' name 'glDeleteSamplers';
    public static procedure DeleteSamplers(count: Int32; var samplers: SamplerName);
    external 'opengl32.dll' name 'glDeleteSamplers';
    public static procedure DeleteSamplers(count: Int32; samplers: pointer);
    external 'opengl32.dll' name 'glDeleteSamplers';
    
    public static function IsSampler(sampler: SamplerName): boolean;
    external 'opengl32.dll' name 'glIsSampler';
    
    {$endregion 8.2 - Sampler Objects}
    
    {$region 8.3 - Sampler Object Queries}
    
    public static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    public static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    public static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    public static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    public static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    public static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    public static procedure GetSamplerParameteriv(sampler: SamplerName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetSamplerParameteriv';
    
    public static procedure GetSamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetSamplerParameterfv';
    public static procedure GetSamplerParameterfv(sampler: SamplerName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetSamplerParameterfv';
    
    public static procedure GetSamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetSamplerParameterIiv';
    public static procedure GetSamplerParameterIiv(sampler: SamplerName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetSamplerParameterIiv';
    
    public static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    public static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    public static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    public static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    public static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    public static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    public static procedure GetSamplerParameterIuiv(sampler: SamplerName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetSamplerParameterIuiv';
    
    {$endregion 8.3 - Sampler Object Queries}
    
    {$region 8.4 - Pixel Rectangles}
    
    // 8.4.1
    
    public static procedure PixelStorei(pname: PixelInfoType; param: Int32);
    external 'opengl32.dll' name 'glPixelStorei';
    
    public static procedure PixelStoref(pname: PixelInfoType; param: single);
    external 'opengl32.dll' name 'glPixelStoref';
    
    {$endregion 8.4 - Pixel Rectangles}
    
    {$region 8.5 - Texture Image Specification}
    
    public static procedure TexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexImage3D';
    public static procedure TexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexImage3D';
    
    public static procedure TexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexImage2D';
    public static procedure TexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexImage2D';
    
    public static procedure TexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexImage1D';
    public static procedure TexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexImage1D';
    
    {$endregion 8.5 - Texture Image Specification}
    
    {$region 8.6 - Alternate Texture Image Specification Commands}
    
    public static procedure CopyTexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32);
    external 'opengl32.dll' name 'glCopyTexImage2D';
    
    public static procedure CopyTexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; x: Int32; y: Int32; width: Int32; border: Int32);
    external 'opengl32.dll' name 'glCopyTexImage1D';
    
    public static procedure TexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexSubImage3D';
    public static procedure TexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexSubImage3D';
    
    public static procedure TexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexSubImage2D';
    public static procedure TexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexSubImage2D';
    
    public static procedure TexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTexSubImage1D';
    public static procedure TexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTexSubImage1D';
    
    public static procedure CopyTexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTexSubImage3D';
    
    public static procedure CopyTexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTexSubImage2D';
    
    public static procedure CopyTexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyTexSubImage1D';
    
    public static procedure TextureSubImage3D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTextureSubImage3D';
    public static procedure TextureSubImage3D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTextureSubImage3D';
    
    public static procedure TextureSubImage2D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTextureSubImage2D';
    public static procedure TextureSubImage2D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTextureSubImage2D';
    
    public static procedure TextureSubImage1D(texture: TextureName; level: Int32; xoffset: Int32; width: Int32; DataFormat: UInt32; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glTextureSubImage1D';
    public static procedure TextureSubImage1D(texture: TextureName; level: Int32; xoffset: Int32; width: Int32; DataFormat: UInt32; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glTextureSubImage1D';
    
    public static procedure CopyTextureSubImage3D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTextureSubImage3D';
    
    public static procedure CopyTextureSubImage2D(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glCopyTextureSubImage2D';
    
    public static procedure CopyTextureSubImage1D(texture: TextureName; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32);
    external 'opengl32.dll' name 'glCopyTextureSubImage1D';
    
    {$endregion 8.6 - Alternate Texture Image Specification Commands}
    
    {$region 8.7 - Compressed Texture Images}
    
    public static procedure CompressedTexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexImage1D';
    public static procedure CompressedTexImage1D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; border: Int32; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexImage1D';
    
    public static procedure CompressedTexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexImage2D';
    public static procedure CompressedTexImage2D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; border: Int32; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexImage2D';
    
    public static procedure CompressedTexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexImage3D';
    public static procedure CompressedTexImage3D(target: TextureBindTarget; level: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexImage3D';
    
    public static procedure CompressedTexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexSubImage1D';
    public static procedure CompressedTexSubImage1D(target: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexSubImage1D';
    
    public static procedure CompressedTexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexSubImage2D';
    public static procedure CompressedTexSubImage2D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexSubImage2D';
    
    public static procedure CompressedTexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTexSubImage3D';
    public static procedure CompressedTexSubImage3D(target: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTexSubImage3D';
    
    public static procedure CompressedTextureSubImage1D(texture: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTextureSubImage1D';
    public static procedure CompressedTextureSubImage1D(texture: TextureBindTarget; level: Int32; xoffset: Int32; width: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTextureSubImage1D';
    
    public static procedure CompressedTextureSubImage2D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTextureSubImage2D';
    public static procedure CompressedTextureSubImage2D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTextureSubImage2D';
    
    public static procedure CompressedTextureSubImage3D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glCompressedTextureSubImage3D';
    public static procedure CompressedTextureSubImage3D(texture: TextureBindTarget; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; imageSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glCompressedTextureSubImage3D';
    
    {$endregion 8.7 - Compressed Texture Images}
    
    {$region 8.8 - Multisample Textures}
    
    public static procedure TexImage2DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTexImage2DMultisample';
    
    public static procedure TexImage3DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTexImage3DMultisample';
    
    {$endregion 8.8 - Multisample Textures}
    
    {$region 8.9 - Buffer Textures}
    
    public static procedure TexBufferRange(target: TextureBindTarget; internalformat: InternalDataFormat; buffer: BufferName; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glTexBufferRange';
    
    public static procedure TextureBufferRange(texture: TextureName; internalformat: InternalDataFormat; buffer: BufferName; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glTextureBufferRange';
    
    public static procedure TexBuffer(target: TextureBindTarget; internalformat: InternalDataFormat; buffer: BufferName);
    external 'opengl32.dll' name 'glTexBuffer';
    
    public static procedure TextureBuffer(texture: TextureName; internalformat: InternalDataFormat; buffer: BufferName);
    external 'opengl32.dll' name 'glTextureBuffer';
    
    {$endregion 8.9 - Buffer Textures}
    
    {$region 8.10 - Texture Parameters}
    //ToDo передавать можно энумы и массивы (и энумов тоже)...
    // - в конце проверить чтоб все энумы существовали
    // - и возможно ещё сделать для них перегрузки
    // - это так же касается 8.11
    
    public static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: DepthStencilMode);
    external 'opengl32.dll' name 'glTexParameteri';
    public static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: Int32);
    external 'opengl32.dll' name 'glTexParameteri';
    public static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: TextureCompareMode);
    external 'opengl32.dll' name 'glTexParameteri';
    public static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: ActivationFunc);
    external 'opengl32.dll' name 'glTexParameteri';
    public static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTexParameteri';
    public static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTexParameteri';
    public static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: SwizzleMode);
    external 'opengl32.dll' name 'glTexParameteri';
    public static procedure TexParameteri(target: TextureBindTarget; pname: TextureInfoType; param: PixelWrapMode);
    external 'opengl32.dll' name 'glTexParameteri';
    
    public static procedure TexParameterf(target: TextureBindTarget; pname: TextureInfoType; param: single);
    external 'opengl32.dll' name 'glTexParameterf';
    
    public static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    public static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glTexParameteriv';
    public static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    public static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glTexParameteriv';
    public static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    public static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    public static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    public static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glTexParameteriv';
    public static procedure TexParameteriv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTexParameteriv';
    
    public static procedure TexParameterfv(target: TextureBindTarget; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glTexParameterfv';
    public static procedure TexParameterfv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTexParameterfv';
    
    public static procedure TexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glTexParameterIiv';
    public static procedure TexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTexParameterIiv';
    
    public static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    public static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    public static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    public static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    public static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    public static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    public static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    public static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    public static procedure TexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTexParameterIuiv';
    
    public static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: DepthStencilMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    public static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: Int32);
    external 'opengl32.dll' name 'glTextureParameteri';
    public static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: TextureCompareMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    public static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: ActivationFunc);
    external 'opengl32.dll' name 'glTextureParameteri';
    public static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    public static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    public static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: SwizzleMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    public static procedure TextureParameteri(texture: TextureName; pname: TextureInfoType; param: PixelWrapMode);
    external 'opengl32.dll' name 'glTextureParameteri';
    
    public static procedure TextureParameterf(texture: TextureName; pname: TextureInfoType; param: single);
    external 'opengl32.dll' name 'glTextureParameterf';
    
    public static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: DepthStencilMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    public static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: Int32);
    external 'opengl32.dll' name 'glTextureParameteriv';
    public static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: TextureCompareMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    public static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: ActivationFunc);
    external 'opengl32.dll' name 'glTextureParameteriv';
    public static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    public static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    public static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: SwizzleMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    public static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; var param: PixelWrapMode);
    external 'opengl32.dll' name 'glTextureParameteriv';
    public static procedure TextureParameteriv(texture: TextureName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glTextureParameteriv';
    
    public static procedure TextureParameterfv(texture: TextureName; pname: TextureInfoType; var param: single);
    external 'opengl32.dll' name 'glTextureParameterfv';
    public static procedure TextureParameterfv(texture: TextureName; pname: TextureInfoType; param: pointer);
    external 'opengl32.dll' name 'glTextureParameterfv';
    
    public static procedure TextureParameterIiv(texture: TextureName; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glTextureParameterIiv';
    public static procedure TextureParameterIiv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTextureParameterIiv';
    
    public static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    public static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    public static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    public static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    public static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    public static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    public static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    public static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    public static procedure TextureParameterIuiv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glTextureParameterIuiv';
    
    {$endregion 8.10 - Texture Parameters}
    
    {$region 8.11 - Texture Queries}
    
    // 8.11.2
    
    public static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    public static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    public static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    public static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    public static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    public static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    public static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    public static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    public static procedure GetTexParameteriv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexParameteriv';
    
    public static procedure GetTexParameterfv(target: TextureBindTarget; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetTexParameterfv';
    public static procedure GetTexParameterfv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexParameterfv';
    
    public static procedure GetTexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTexParameterIiv';
    public static procedure GetTexParameterIiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexParameterIiv';
    
    public static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    public static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    public static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    public static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    public static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    public static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    public static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    public static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    public static procedure GetTexParameterIuiv(target: TextureBindTarget; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexParameterIuiv';
    
    public static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    public static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    public static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    public static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    public static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    public static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    public static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    public static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    public static procedure GetTextureParameteriv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureParameteriv';
    
    public static procedure GetTextureParameterfv(texture: TextureName; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetTextureParameterfv';
    public static procedure GetTextureParameterfv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureParameterfv';
    
    public static procedure GetTextureParameterIiv(texture: TextureName; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTextureParameterIiv';
    public static procedure GetTextureParameterIiv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureParameterIiv';
    
    public static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: DepthStencilMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    public static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: TextureCompareMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    public static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: ActivationFunc);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    public static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelMagFilterMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    public static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelMinFilterMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    public static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: SwizzleMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    public static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: PixelWrapMode);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    public static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    public static procedure GetTextureParameterIuiv(texture: TextureName; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureParameterIuiv';
    
    // 8.11.3
    
    public static procedure GetTexLevelParameterfv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetTexLevelParameterfv';
    public static procedure GetTexLevelParameterfv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexLevelParameterfv';
    public static procedure GetTexLevelParameterfv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetTexLevelParameterfv';
    public static procedure GetTexLevelParameterfv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexLevelParameterfv';
    
    public static procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    public static procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    public static procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    public static procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; var &params: InternalDataFormat);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    public static procedure GetTexLevelParameteriv(target: TextureBindTarget; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    public static procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    public static procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    public static procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    public static procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; var &params: InternalDataFormat);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    public static procedure GetTexLevelParameteriv(target: TextureCubeSide; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTexLevelParameteriv';
    
    public static procedure GetTextureLevelParameterfv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetTextureLevelParameterfv';
    public static procedure GetTextureLevelParameterfv(texture: TextureName; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureLevelParameterfv';
    
    public static procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetTextureLevelParameteriv';
    public static procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetTextureLevelParameteriv';
    public static procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetTextureLevelParameteriv';
    public static procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; var &params: InternalDataFormat);
    external 'opengl32.dll' name 'glGetTextureLevelParameteriv';
    public static procedure GetTextureLevelParameteriv(texture: TextureName; level: Int32; pname: TextureInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetTextureLevelParameteriv';
    
    // 8.11.4
    
    public static procedure GetTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetTexImage';
    public static procedure GetTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glGetTexImage';
    
    public static procedure GetTextureImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetTextureImage';
    public static procedure GetTextureImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetTextureImage';
    
    public static procedure GetnTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetnTexImage';
    public static procedure GetnTexImage(target: TextureBindTarget; level: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetnTexImage';
    
    public static procedure GetTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetTextureSubImage';
    public static procedure GetTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetTextureSubImage';
    
    public static procedure GetCompressedTexImage(target: TextureBindTarget; level: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetCompressedTexImage';
    public static procedure GetCompressedTexImage(target: TextureBindTarget; level: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetCompressedTexImage';
    
    public static procedure GetCompressedTextureImage(texture: TextureName; level: Int32; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetCompressedTextureImage';
    public static procedure GetCompressedTextureImage(texture: TextureName; level: Int32; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetCompressedTextureImage';
    
    public static procedure GetnCompressedTexImage(target: TextureBindTarget; level: Int32; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetnCompressedTexImage';
    public static procedure GetnCompressedTexImage(target: TextureBindTarget; level: Int32; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetnCompressedTexImage';
    
    public static procedure GetCompressedTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: IntPtr);
    external 'opengl32.dll' name 'glGetCompressedTextureSubImage';
    public static procedure GetCompressedTextureSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; bufSize: Int32; pixels: pointer);
    external 'opengl32.dll' name 'glGetCompressedTextureSubImage';
    
    {$endregion 8.11 - Texture Queries}
    
    {$region 8.14 - Texture Minification}
    
    // 8.14.4
    
    public static procedure GenerateMipmap(target: TextureBindTarget);
    external 'opengl32.dll' name 'glGenerateMipmap';
    
    public static procedure GenerateTextureMipmap(texture: TextureName);
    external 'opengl32.dll' name 'glGenerateTextureMipmap';
    
    {$endregion 8.14 - Texture Minification}
    
    {$region 8.18 - Texture Views}
    
    public static procedure TextureView(texture: TextureName; target: TextureBindTarget; origtexture: TextureName; internalformat: InternalDataFormat; minlevel: UInt32; numlevels: UInt32; minlayer: UInt32; numlayers: UInt32);
    external 'opengl32.dll' name 'glTextureView';
    
    {$endregion 8.18 - Texture Views}
    
    {$region 8.19 - Immutable-Format Texture Images}
    
    public static procedure TexStorage1D(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32);
    external 'opengl32.dll' name 'glTexStorage1D';
    
    public static procedure TextureStorage1D(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32);
    external 'opengl32.dll' name 'glTextureStorage1D';
    
    public static procedure TexStorage2D(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glTexStorage2D';
    
    public static procedure TextureStorage2D(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glTextureStorage2D';
    
    public static procedure TexStorage3D(target: TextureBindTarget; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32);
    external 'opengl32.dll' name 'glTexStorage3D';
    
    public static procedure TextureStorage3D(texture: TextureName; levels: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32);
    external 'opengl32.dll' name 'glTextureStorage3D';
    
    public static procedure TexStorage2DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTexStorage2DMultisample';
    
    public static procedure TextureStorage2DMultisample(texture: TextureName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTextureStorage2DMultisample';
    
    public static procedure TexStorage3DMultisample(target: TextureBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTexStorage3DMultisample';
    
    public static procedure TextureStorage3DMultisample(texture: TextureName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32; depth: Int32; fixedsamplelocations: boolean);
    external 'opengl32.dll' name 'glTextureStorage3DMultisample';
    
    {$endregion 8.19 - Immutable-Format Texture Images}
    
    {$region 8.20 - Invalidating Texture Image Data}
    
    public static procedure InvalidateTexSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32);
    external 'opengl32.dll' name 'glInvalidateTexSubImage';
    
    public static procedure InvalidateTexImage(texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glInvalidateTexImage';
    
    {$endregion 8.20 - Invalidating Texture Image Data}
    
    {$region 8.21 - Clearing Texture Image Data}
    
    public static procedure ClearTexSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearTexSubImage';
    public static procedure ClearTexSubImage(texture: TextureName; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearTexSubImage';
    
    public static procedure ClearTexImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; data: IntPtr);
    external 'opengl32.dll' name 'glClearTexImage';
    public static procedure ClearTexImage(texture: TextureName; level: Int32; format: DataFormat; &type: DataType; data: pointer);
    external 'opengl32.dll' name 'glClearTexImage';
    
    {$endregion 8.21 - Clearing Texture Image Data}
    
    {$region 8.26 - Texture Image Loads and Stores}
    
    public static procedure BindImageTexture(&unit: TextureUnitId; texture: TextureName; level: Int32; layered: boolean; layer: Int32; access: AccessType; format: DataFormat);
    external 'opengl32.dll' name 'glBindImageTexture';
    
    public static procedure BindImageTextures(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] textures: array of TextureName);
    external 'opengl32.dll' name 'glBindImageTextures';
    public static procedure BindImageTextures(first: UInt32; count: Int32; var textures: TextureName);
    external 'opengl32.dll' name 'glBindImageTextures';
    public static procedure BindImageTextures(first: UInt32; count: Int32; textures: pointer);
    external 'opengl32.dll' name 'glBindImageTextures';
    
    {$endregion 8.26 - Texture Image Loads and Stores}
    
    {$endregion 8.0 - Textures and Samplers}
    
    {$region 9.0 - Framebuffers and Framebuffer Objects}
    
    {$region 9.2 - Binding and Managing Framebuffer Objects}
    
    public static procedure BindFramebuffer(target: FramebufferBindTarget; framebuffer: FramebufferName);
    external 'opengl32.dll' name 'glBindFramebuffer';
    
    public static procedure CreateFramebuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] framebuffers: array of FramebufferName);
    external 'opengl32.dll' name 'glCreateFramebuffers';
    public static procedure CreateFramebuffers(n: Int32; var framebuffers: FramebufferName);
    external 'opengl32.dll' name 'glCreateFramebuffers';
    public static procedure CreateFramebuffers(n: Int32; framebuffers: pointer);
    external 'opengl32.dll' name 'glCreateFramebuffers';
    
    public static procedure GenFramebuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] framebuffers: array of FramebufferName);
    external 'opengl32.dll' name 'glGenFramebuffers';
    public static procedure GenFramebuffers(n: Int32; var framebuffers: FramebufferName);
    external 'opengl32.dll' name 'glGenFramebuffers';
    public static procedure GenFramebuffers(n: Int32; framebuffers: pointer);
    external 'opengl32.dll' name 'glGenFramebuffers';
    
    public static procedure DeleteFramebuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] framebuffers: array of FramebufferName);
    external 'opengl32.dll' name 'glDeleteFramebuffers';
    public static procedure DeleteFramebuffers(n: Int32; var framebuffers: FramebufferName);
    external 'opengl32.dll' name 'glDeleteFramebuffers';
    public static procedure DeleteFramebuffers(n: Int32; framebuffers: pointer);
    external 'opengl32.dll' name 'glDeleteFramebuffers';
    
    public static function IsFramebuffer(framebuffer: FramebufferName): boolean;
    external 'opengl32.dll' name 'glIsFramebuffer';
    
    // 9.2.1
    
    public static procedure FramebufferParameteri(target: FramebufferBindTarget; pname: FramebufferInfoType; param: Int32);
    external 'opengl32.dll' name 'glFramebufferParameteri';
    
    public static procedure NamedFramebufferParameteri(framebuffer: FramebufferName; pname: FramebufferInfoType; param: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferParameteri';
    
    // 9.2.3
    
    public static procedure GetFramebufferParameteriv(target: FramebufferBindTarget; pname: FramebufferInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetFramebufferParameteriv';
    public static procedure GetFramebufferParameteriv(target: FramebufferBindTarget; pname: FramebufferInfoType; var &params: boolean);
    external 'opengl32.dll' name 'glGetFramebufferParameteriv';
    public static procedure GetFramebufferParameteriv(target: FramebufferBindTarget; pname: FramebufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetFramebufferParameteriv';
    
    public static procedure GetNamedFramebufferParameteriv(framebuffer: FramebufferName; pname: FramebufferInfoType; var param: Int32);
    external 'opengl32.dll' name 'glGetNamedFramebufferParameteriv';
    public static procedure GetNamedFramebufferParameteriv(framebuffer: FramebufferName; pname: FramebufferInfoType; var param: boolean);
    external 'opengl32.dll' name 'glGetNamedFramebufferParameteriv';
    public static procedure GetNamedFramebufferParameteriv(framebuffer: FramebufferName; pname: FramebufferInfoType; param: pointer);
    external 'opengl32.dll' name 'glGetNamedFramebufferParameteriv';
    
    public static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: FramebufferAttachmentObjectType);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    public static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    public static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    public static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: ColorEncodingMode);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    public static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    public static procedure GetFramebufferAttachmentParameteriv(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetFramebufferAttachmentParameteriv';
    
    public static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: FramebufferAttachmentObjectType);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    public static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    public static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    public static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: ColorEncodingMode);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    public static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    public static procedure GetNamedFramebufferAttachmentParameteriv(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; pname: FramebufferAttachmentInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetNamedFramebufferAttachmentParameteriv';
    
    // 9.2.4
    
    public static procedure BindRenderbuffer(target: RenderbufferBindTarget; renderbuffer: RenderbufferName);
    external 'opengl32.dll' name 'glBindRenderbuffer';
    
    public static procedure CreateRenderbuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] renderbuffers: array of RenderbufferName);
    external 'opengl32.dll' name 'glCreateRenderbuffers';
    public static procedure CreateRenderbuffers(n: Int32; var renderbuffers: RenderbufferName);
    external 'opengl32.dll' name 'glCreateRenderbuffers';
    public static procedure CreateRenderbuffers(n: Int32; renderbuffers: pointer);
    external 'opengl32.dll' name 'glCreateRenderbuffers';
    
    public static procedure GenRenderbuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] renderbuffers: array of RenderbufferName);
    external 'opengl32.dll' name 'glGenRenderbuffers';
    public static procedure GenRenderbuffers(n: Int32; var renderbuffers: RenderbufferName);
    external 'opengl32.dll' name 'glGenRenderbuffers';
    public static procedure GenRenderbuffers(n: Int32; renderbuffers: pointer);
    external 'opengl32.dll' name 'glGenRenderbuffers';
    
    public static procedure DeleteRenderbuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] renderbuffers: array of RenderbufferName);
    external 'opengl32.dll' name 'glDeleteRenderbuffers';
    public static procedure DeleteRenderbuffers(n: Int32; var renderbuffers: RenderbufferName);
    external 'opengl32.dll' name 'glDeleteRenderbuffers';
    public static procedure DeleteRenderbuffers(n: Int32; renderbuffers: pointer);
    external 'opengl32.dll' name 'glDeleteRenderbuffers';
    
    public static function IsRenderbuffer(renderbuffer: RenderbufferName): boolean;
    external 'opengl32.dll' name 'glIsRenderbuffer';
    
    public static procedure RenderbufferStorageMultisample(target: RenderbufferBindTarget; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glRenderbufferStorageMultisample';
    
    public static procedure NamedRenderbufferStorageMultisample(renderbuffer: RenderbufferName; samples: Int32; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glNamedRenderbufferStorageMultisample';
    
    public static procedure RenderbufferStorage(target: RenderbufferBindTarget; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glRenderbufferStorage';
    
    public static procedure NamedRenderbufferStorage(renderbuffer: RenderbufferName; internalformat: InternalDataFormat; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glNamedRenderbufferStorage';
    
    // 9.2.6
    
    public static procedure GetRenderbufferParameteriv(target: RenderbufferBindTarget; pname: RenderbufferInfoType; var &params: InternalDataFormat);
    external 'opengl32.dll' name 'glGetRenderbufferParameteriv';
    public static procedure GetRenderbufferParameteriv(target: RenderbufferBindTarget; pname: RenderbufferInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetRenderbufferParameteriv';
    public static procedure GetRenderbufferParameteriv(target: RenderbufferBindTarget; pname: RenderbufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetRenderbufferParameteriv';
    
    public static procedure GetNamedRenderbufferParameteriv(renderbuffer: RenderbufferName; pname: RenderbufferInfoType; var &params: InternalDataFormat);
    external 'opengl32.dll' name 'glGetNamedRenderbufferParameteriv';
    public static procedure GetNamedRenderbufferParameteriv(renderbuffer: RenderbufferName; pname: RenderbufferInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetNamedRenderbufferParameteriv';
    public static procedure GetNamedRenderbufferParameteriv(renderbuffer: RenderbufferName; pname: RenderbufferInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetNamedRenderbufferParameteriv';
    
    // 9.2.7
    
    public static procedure FramebufferRenderbuffer(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; renderbuffertarget: RenderbufferBindTarget; renderbuffer: RenderbufferName);
    external 'opengl32.dll' name 'glFramebufferRenderbuffer';
    
    public static procedure NamedFramebufferRenderbuffer(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; renderbuffertarget: RenderbufferBindTarget; renderbuffer: RenderbufferName);
    external 'opengl32.dll' name 'glNamedFramebufferRenderbuffer';
    
    // 9.2.8
    
    public static procedure FramebufferTexture(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture';
    
    public static procedure NamedFramebufferTexture(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferTexture';
    
    public static procedure FramebufferTexture1D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureBindTarget; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture1D';
    public static procedure FramebufferTexture1D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture1D';
    
    public static procedure FramebufferTexture2D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureBindTarget; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture2D';
    public static procedure FramebufferTexture2D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture2D';
    
    public static procedure FramebufferTexture3D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureBindTarget; texture: TextureName; level: Int32; zoffset: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture3D';
    public static procedure FramebufferTexture3D(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; textarget: TextureCubeSide; texture: TextureName; level: Int32; zoffset: Int32);
    external 'opengl32.dll' name 'glFramebufferTexture3D';
    
    public static procedure FramebufferTextureLayer(target: FramebufferBindTarget; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32; layer: Int32);
    external 'opengl32.dll' name 'glFramebufferTextureLayer';
    
    public static procedure NamedFramebufferTextureLayer(framebuffer: FramebufferName; attachment: FramebufferAttachmentPoint; texture: TextureName; level: Int32; layer: Int32);
    external 'opengl32.dll' name 'glNamedFramebufferTextureLayer';
    
    {$endregion 9.2 - Binding and Managing Framebuffer Objects}
    
    {$region 9.3 - Feedback Loops Between Textures and the Framebuffer}
    
    // 9.3.1
    
    public static procedure TextureBarrier;
    external 'opengl32.dll' name 'glTextureBarrier';
    
    {$endregion 9.3 - Feedback Loops Between Textures and the Framebuffer}
    
    {$region 9.4 - Framebuffer Completeness}
    
    // 9.4.2
    
    public static function CheckFramebufferStatus(target: FramebufferBindTarget): ErrorCode;
    external 'opengl32.dll' name 'glCheckFramebufferStatus';
    
    public static function CheckNamedFramebufferStatus(framebuffer: FramebufferName; target: FramebufferBindTarget): ErrorCode;
    external 'opengl32.dll' name 'glCheckNamedFramebufferStatus';
    
    {$endregion 9.4 - Framebuffer Completeness}
    
    {$endregion 9.0 - Framebuffers and Framebuffer Objects}
    
    {$region 10.0 - Vertex Specification and Drawing Commands}
    
    {$region 10.1 - Primitive Types}
    
    // 10.1.15
    
    public static procedure PatchParameteri(pname: PatchMode; value: Int32);
    external 'opengl32.dll' name 'glPatchParameteri';
    
    {$endregion 10.1 - Primitive Types}
    
    {$region 10.2 - Current Vertex Attribute Values}
    
    // 10.2.1
    
    {$region VertexAttrib[1,2,3,4][s,f,d]}
    
    public static procedure VertexAttrib1s(index: UInt32; x: Int16);
    external 'opengl32.dll' name 'glVertexAttrib1s';
    
    public static procedure VertexAttrib2s(index: UInt32; x: Int16; y: Int16);
    external 'opengl32.dll' name 'glVertexAttrib2s';
    
    public static procedure VertexAttrib3s(index: UInt32; x: Int16; y: Int16; z: Int16);
    external 'opengl32.dll' name 'glVertexAttrib3s';
    
    public static procedure VertexAttrib4s(index: UInt32; x: Int16; y: Int16; z: Int16; w: Int16);
    external 'opengl32.dll' name 'glVertexAttrib4s';
    
    public static procedure VertexAttrib1f(index: UInt32; x: single);
    external 'opengl32.dll' name 'glVertexAttrib1f';
    
    public static procedure VertexAttrib2f(index: UInt32; x: single; y: single);
    external 'opengl32.dll' name 'glVertexAttrib2f';
    
    public static procedure VertexAttrib3f(index: UInt32; x: single; y: single; z: single);
    external 'opengl32.dll' name 'glVertexAttrib3f';
    
    public static procedure VertexAttrib4f(index: UInt32; x: single; y: single; z: single; w: single);
    external 'opengl32.dll' name 'glVertexAttrib4f';
    
    public static procedure VertexAttrib1d(index: UInt32; x: double);
    external 'opengl32.dll' name 'glVertexAttrib1d';
    
    public static procedure VertexAttrib2d(index: UInt32; x: double; y: double);
    external 'opengl32.dll' name 'glVertexAttrib2d';
    
    public static procedure VertexAttrib3d(index: UInt32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glVertexAttrib3d';
    
    public static procedure VertexAttrib4d(index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glVertexAttrib4d';
    
    {$endregion VertexAttrib[1,2,3,4][s,f,d]}
    
    {$region VertexAttrib[1,2,3][s,f,d]v}
    
    public static procedure VertexAttrib1sv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttrib1sv';
    public static procedure VertexAttrib1sv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttrib1sv';
    public static procedure VertexAttrib1sv(index: UInt32; var v: Vec1s);
    external 'opengl32.dll' name 'glVertexAttrib1sv';
    public static procedure VertexAttrib1sv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib1sv';
    
    public static procedure VertexAttrib2sv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttrib2sv';
    public static procedure VertexAttrib2sv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttrib2sv';
    public static procedure VertexAttrib2sv(index: UInt32; var v: Vec2s);
    external 'opengl32.dll' name 'glVertexAttrib2sv';
    public static procedure VertexAttrib2sv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib2sv';
    
    public static procedure VertexAttrib3sv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttrib3sv';
    public static procedure VertexAttrib3sv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttrib3sv';
    public static procedure VertexAttrib3sv(index: UInt32; var v: Vec3s);
    external 'opengl32.dll' name 'glVertexAttrib3sv';
    public static procedure VertexAttrib3sv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib3sv';
    
    public static procedure VertexAttrib1fv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glVertexAttrib1fv';
    public static procedure VertexAttrib1fv(index: UInt32; var v: single);
    external 'opengl32.dll' name 'glVertexAttrib1fv';
    public static procedure VertexAttrib1fv(index: UInt32; var v: Vec1f);
    external 'opengl32.dll' name 'glVertexAttrib1fv';
    public static procedure VertexAttrib1fv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib1fv';
    
    public static procedure VertexAttrib2fv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glVertexAttrib2fv';
    public static procedure VertexAttrib2fv(index: UInt32; var v: single);
    external 'opengl32.dll' name 'glVertexAttrib2fv';
    public static procedure VertexAttrib2fv(index: UInt32; var v: Vec2f);
    external 'opengl32.dll' name 'glVertexAttrib2fv';
    public static procedure VertexAttrib2fv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib2fv';
    
    public static procedure VertexAttrib3fv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glVertexAttrib3fv';
    public static procedure VertexAttrib3fv(index: UInt32; var v: single);
    external 'opengl32.dll' name 'glVertexAttrib3fv';
    public static procedure VertexAttrib3fv(index: UInt32; var v: Vec3f);
    external 'opengl32.dll' name 'glVertexAttrib3fv';
    public static procedure VertexAttrib3fv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib3fv';
    
    public static procedure VertexAttrib1dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttrib1dv';
    public static procedure VertexAttrib1dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttrib1dv';
    public static procedure VertexAttrib1dv(index: UInt32; var v: Vec1d);
    external 'opengl32.dll' name 'glVertexAttrib1dv';
    public static procedure VertexAttrib1dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib1dv';
    
    public static procedure VertexAttrib2dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttrib2dv';
    public static procedure VertexAttrib2dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttrib2dv';
    public static procedure VertexAttrib2dv(index: UInt32; var v: Vec2d);
    external 'opengl32.dll' name 'glVertexAttrib2dv';
    public static procedure VertexAttrib2dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib2dv';
    
    public static procedure VertexAttrib3dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttrib3dv';
    public static procedure VertexAttrib3dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttrib3dv';
    public static procedure VertexAttrib3dv(index: UInt32; var v: Vec3d);
    external 'opengl32.dll' name 'glVertexAttrib3dv';
    public static procedure VertexAttrib3dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib3dv';
    
    {$endregion VertexAttrib[1,2,3][s,f,d]v}
    
    {$region VertexAttrib4[b,s,i,f,d,ub,us,ui]v}
    
    public static procedure VertexAttrib4bv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of SByte);
    external 'opengl32.dll' name 'glVertexAttrib4bv';
    public static procedure VertexAttrib4bv(index: UInt32; var v: SByte);
    external 'opengl32.dll' name 'glVertexAttrib4bv';
    public static procedure VertexAttrib4bv(index: UInt32; var v: Vec4b);
    external 'opengl32.dll' name 'glVertexAttrib4bv';
    public static procedure VertexAttrib4bv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4bv';
    
    public static procedure VertexAttrib4sv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttrib4sv';
    public static procedure VertexAttrib4sv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttrib4sv';
    public static procedure VertexAttrib4sv(index: UInt32; var v: Vec4s);
    external 'opengl32.dll' name 'glVertexAttrib4sv';
    public static procedure VertexAttrib4sv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4sv';
    
    public static procedure VertexAttrib4iv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttrib4iv';
    public static procedure VertexAttrib4iv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttrib4iv';
    public static procedure VertexAttrib4iv(index: UInt32; var v: Vec4i);
    external 'opengl32.dll' name 'glVertexAttrib4iv';
    public static procedure VertexAttrib4iv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4iv';
    
    public static procedure VertexAttrib4fv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glVertexAttrib4fv';
    public static procedure VertexAttrib4fv(index: UInt32; var v: single);
    external 'opengl32.dll' name 'glVertexAttrib4fv';
    public static procedure VertexAttrib4fv(index: UInt32; var v: Vec4f);
    external 'opengl32.dll' name 'glVertexAttrib4fv';
    public static procedure VertexAttrib4fv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4fv';
    
    public static procedure VertexAttrib4dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttrib4dv';
    public static procedure VertexAttrib4dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttrib4dv';
    public static procedure VertexAttrib4dv(index: UInt32; var v: Vec4d);
    external 'opengl32.dll' name 'glVertexAttrib4dv';
    public static procedure VertexAttrib4dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4dv';
    
    public static procedure VertexAttrib4ubv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Byte);
    external 'opengl32.dll' name 'glVertexAttrib4ubv';
    public static procedure VertexAttrib4ubv(index: UInt32; var v: Byte);
    external 'opengl32.dll' name 'glVertexAttrib4ubv';
    public static procedure VertexAttrib4ubv(index: UInt32; var v: Vec4ub);
    external 'opengl32.dll' name 'glVertexAttrib4ubv';
    public static procedure VertexAttrib4ubv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4ubv';
    
    public static procedure VertexAttrib4usv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt16);
    external 'opengl32.dll' name 'glVertexAttrib4usv';
    public static procedure VertexAttrib4usv(index: UInt32; var v: UInt16);
    external 'opengl32.dll' name 'glVertexAttrib4usv';
    public static procedure VertexAttrib4usv(index: UInt32; var v: Vec4us);
    external 'opengl32.dll' name 'glVertexAttrib4usv';
    public static procedure VertexAttrib4usv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4usv';
    
    public static procedure VertexAttrib4uiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttrib4uiv';
    public static procedure VertexAttrib4uiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttrib4uiv';
    public static procedure VertexAttrib4uiv(index: UInt32; var v: Vec4ui);
    external 'opengl32.dll' name 'glVertexAttrib4uiv';
    public static procedure VertexAttrib4uiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4uiv';
    
    {$endregion VertexAttrib4[b,s,i,f,d,ub,us,ui]v}
    
    {$region VertexAttrib4Nub}
    
    public static procedure VertexAttrib4Nub(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte);
    external 'opengl32.dll' name 'glVertexAttrib4Nub';
    
    {$endregion VertexAttrib4Nub}
    
    {$region VertexAttrib4N[b,s,i,ub,us,ui]v}
    
    public static procedure VertexAttrib4Nbv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of SByte);
    external 'opengl32.dll' name 'glVertexAttrib4Nbv';
    public static procedure VertexAttrib4Nbv(index: UInt32; var v: SByte);
    external 'opengl32.dll' name 'glVertexAttrib4Nbv';
    public static procedure VertexAttrib4Nbv(index: UInt32; var v: Vec4b);
    external 'opengl32.dll' name 'glVertexAttrib4Nbv';
    public static procedure VertexAttrib4Nbv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Nbv';
    
    public static procedure VertexAttrib4Nsv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttrib4Nsv';
    public static procedure VertexAttrib4Nsv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttrib4Nsv';
    public static procedure VertexAttrib4Nsv(index: UInt32; var v: Vec4s);
    external 'opengl32.dll' name 'glVertexAttrib4Nsv';
    public static procedure VertexAttrib4Nsv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Nsv';
    
    public static procedure VertexAttrib4Niv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttrib4Niv';
    public static procedure VertexAttrib4Niv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttrib4Niv';
    public static procedure VertexAttrib4Niv(index: UInt32; var v: Vec4i);
    external 'opengl32.dll' name 'glVertexAttrib4Niv';
    public static procedure VertexAttrib4Niv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Niv';
    
    public static procedure VertexAttrib4Nubv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Byte);
    external 'opengl32.dll' name 'glVertexAttrib4Nubv';
    public static procedure VertexAttrib4Nubv(index: UInt32; var v: Byte);
    external 'opengl32.dll' name 'glVertexAttrib4Nubv';
    public static procedure VertexAttrib4Nubv(index: UInt32; var v: Vec4ub);
    external 'opengl32.dll' name 'glVertexAttrib4Nubv';
    public static procedure VertexAttrib4Nubv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Nubv';
    
    public static procedure VertexAttrib4Nusv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt16);
    external 'opengl32.dll' name 'glVertexAttrib4Nusv';
    public static procedure VertexAttrib4Nusv(index: UInt32; var v: UInt16);
    external 'opengl32.dll' name 'glVertexAttrib4Nusv';
    public static procedure VertexAttrib4Nusv(index: UInt32; var v: Vec4us);
    external 'opengl32.dll' name 'glVertexAttrib4Nusv';
    public static procedure VertexAttrib4Nusv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Nusv';
    
    public static procedure VertexAttrib4Nuiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttrib4Nuiv';
    public static procedure VertexAttrib4Nuiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttrib4Nuiv';
    public static procedure VertexAttrib4Nuiv(index: UInt32; var v: Vec4ui);
    external 'opengl32.dll' name 'glVertexAttrib4Nuiv';
    public static procedure VertexAttrib4Nuiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttrib4Nuiv';
    
    {$endregion VertexAttrib4N[b,s,i,ub,us,ui]v}
    
    {$region VertexAttribI[1,2,3,4][i,ui]}
    
    public static procedure VertexAttribI1i(index: UInt32; x: Int32);
    external 'opengl32.dll' name 'glVertexAttribI1i';
    
    public static procedure VertexAttribI2i(index: UInt32; x: Int32; y: Int32);
    external 'opengl32.dll' name 'glVertexAttribI2i';
    
    public static procedure VertexAttribI3i(index: UInt32; x: Int32; y: Int32; z: Int32);
    external 'opengl32.dll' name 'glVertexAttribI3i';
    
    public static procedure VertexAttribI4i(index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32);
    external 'opengl32.dll' name 'glVertexAttribI4i';
    
    public static procedure VertexAttribI1ui(index: UInt32; x: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI1ui';
    
    public static procedure VertexAttribI2ui(index: UInt32; x: UInt32; y: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI2ui';
    
    public static procedure VertexAttribI3ui(index: UInt32; x: UInt32; y: UInt32; z: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI3ui';
    
    public static procedure VertexAttribI4ui(index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI4ui';
    
    {$endregion VertexAttribI[1,2,3,4][i,ui]}
    
    {$region VertexAttribI[1,2,3,4][i,ui]v}
    
    public static procedure VertexAttribI1iv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttribI1iv';
    public static procedure VertexAttribI1iv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttribI1iv';
    public static procedure VertexAttribI1iv(index: UInt32; var v: Vec1i);
    external 'opengl32.dll' name 'glVertexAttribI1iv';
    public static procedure VertexAttribI1iv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI1iv';
    
    public static procedure VertexAttribI2iv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttribI2iv';
    public static procedure VertexAttribI2iv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttribI2iv';
    public static procedure VertexAttribI2iv(index: UInt32; var v: Vec2i);
    external 'opengl32.dll' name 'glVertexAttribI2iv';
    public static procedure VertexAttribI2iv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI2iv';
    
    public static procedure VertexAttribI3iv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttribI3iv';
    public static procedure VertexAttribI3iv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttribI3iv';
    public static procedure VertexAttribI3iv(index: UInt32; var v: Vec3i);
    external 'opengl32.dll' name 'glVertexAttribI3iv';
    public static procedure VertexAttribI3iv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI3iv';
    
    public static procedure VertexAttribI4iv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glVertexAttribI4iv';
    public static procedure VertexAttribI4iv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glVertexAttribI4iv';
    public static procedure VertexAttribI4iv(index: UInt32; var v: Vec4i);
    external 'opengl32.dll' name 'glVertexAttribI4iv';
    public static procedure VertexAttribI4iv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4iv';
    
    public static procedure VertexAttribI1uiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttribI1uiv';
    public static procedure VertexAttribI1uiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI1uiv';
    public static procedure VertexAttribI1uiv(index: UInt32; var v: Vec1ui);
    external 'opengl32.dll' name 'glVertexAttribI1uiv';
    public static procedure VertexAttribI1uiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI1uiv';
    
    public static procedure VertexAttribI2uiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttribI2uiv';
    public static procedure VertexAttribI2uiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI2uiv';
    public static procedure VertexAttribI2uiv(index: UInt32; var v: Vec2ui);
    external 'opengl32.dll' name 'glVertexAttribI2uiv';
    public static procedure VertexAttribI2uiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI2uiv';
    
    public static procedure VertexAttribI3uiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttribI3uiv';
    public static procedure VertexAttribI3uiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI3uiv';
    public static procedure VertexAttribI3uiv(index: UInt32; var v: Vec3ui);
    external 'opengl32.dll' name 'glVertexAttribI3uiv';
    public static procedure VertexAttribI3uiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI3uiv';
    
    public static procedure VertexAttribI4uiv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt32);
    external 'opengl32.dll' name 'glVertexAttribI4uiv';
    public static procedure VertexAttribI4uiv(index: UInt32; var v: UInt32);
    external 'opengl32.dll' name 'glVertexAttribI4uiv';
    public static procedure VertexAttribI4uiv(index: UInt32; var v: Vec4ui);
    external 'opengl32.dll' name 'glVertexAttribI4uiv';
    public static procedure VertexAttribI4uiv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4uiv';
    
    {$endregion VertexAttribI[1,2,3,4][i,ui]v}
    
    {$region VertexAttribI4[b,s,ub,us]v}
    
    public static procedure VertexAttribI4bv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of SByte);
    external 'opengl32.dll' name 'glVertexAttribI4bv';
    public static procedure VertexAttribI4bv(index: UInt32; var v: SByte);
    external 'opengl32.dll' name 'glVertexAttribI4bv';
    public static procedure VertexAttribI4bv(index: UInt32; var v: Vec4b);
    external 'opengl32.dll' name 'glVertexAttribI4bv';
    public static procedure VertexAttribI4bv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4bv';
    
    public static procedure VertexAttribI4sv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int16);
    external 'opengl32.dll' name 'glVertexAttribI4sv';
    public static procedure VertexAttribI4sv(index: UInt32; var v: Int16);
    external 'opengl32.dll' name 'glVertexAttribI4sv';
    public static procedure VertexAttribI4sv(index: UInt32; var v: Vec4s);
    external 'opengl32.dll' name 'glVertexAttribI4sv';
    public static procedure VertexAttribI4sv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4sv';
    
    public static procedure VertexAttribI4ubv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Byte);
    external 'opengl32.dll' name 'glVertexAttribI4ubv';
    public static procedure VertexAttribI4ubv(index: UInt32; var v: Byte);
    external 'opengl32.dll' name 'glVertexAttribI4ubv';
    public static procedure VertexAttribI4ubv(index: UInt32; var v: Vec4ub);
    external 'opengl32.dll' name 'glVertexAttribI4ubv';
    public static procedure VertexAttribI4ubv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4ubv';
    
    public static procedure VertexAttribI4usv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of UInt16);
    external 'opengl32.dll' name 'glVertexAttribI4usv';
    public static procedure VertexAttribI4usv(index: UInt32; var v: UInt16);
    external 'opengl32.dll' name 'glVertexAttribI4usv';
    public static procedure VertexAttribI4usv(index: UInt32; var v: Vec4us);
    external 'opengl32.dll' name 'glVertexAttribI4usv';
    public static procedure VertexAttribI4usv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribI4usv';
    
    {$endregion VertexAttribI4[b,s,ub,us]v}
    
    {$region VertexAttribL[1,2,3,4]d}
    
    public static procedure VertexAttribL1d(index: UInt32; x: double);
    external 'opengl32.dll' name 'glVertexAttribL1d';
    
    public static procedure VertexAttribL2d(index: UInt32; x: double; y: double);
    external 'opengl32.dll' name 'glVertexAttribL2d';
    
    public static procedure VertexAttribL3d(index: UInt32; x: double; y: double; z: double);
    external 'opengl32.dll' name 'glVertexAttribL3d';
    
    public static procedure VertexAttribL4d(index: UInt32; x: double; y: double; z: double; w: double);
    external 'opengl32.dll' name 'glVertexAttribL4d';
    
    {$endregion VertexAttribL[1,2,3,4]d}
    
    {$region VertexAttribL[1,2,3,4]dv}
    
    public static procedure VertexAttribL1dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttribL1dv';
    public static procedure VertexAttribL1dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttribL1dv';
    public static procedure VertexAttribL1dv(index: UInt32; var v: Vec1d);
    external 'opengl32.dll' name 'glVertexAttribL1dv';
    public static procedure VertexAttribL1dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribL1dv';
    
    public static procedure VertexAttribL2dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttribL2dv';
    public static procedure VertexAttribL2dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttribL2dv';
    public static procedure VertexAttribL2dv(index: UInt32; var v: Vec2d);
    external 'opengl32.dll' name 'glVertexAttribL2dv';
    public static procedure VertexAttribL2dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribL2dv';
    
    public static procedure VertexAttribL3dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttribL3dv';
    public static procedure VertexAttribL3dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttribL3dv';
    public static procedure VertexAttribL3dv(index: UInt32; var v: Vec3d);
    external 'opengl32.dll' name 'glVertexAttribL3dv';
    public static procedure VertexAttribL3dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribL3dv';
    
    public static procedure VertexAttribL4dv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glVertexAttribL4dv';
    public static procedure VertexAttribL4dv(index: UInt32; var v: double);
    external 'opengl32.dll' name 'glVertexAttribL4dv';
    public static procedure VertexAttribL4dv(index: UInt32; var v: Vec4d);
    external 'opengl32.dll' name 'glVertexAttribL4dv';
    public static procedure VertexAttribL4dv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glVertexAttribL4dv';
    
    {$endregion VertexAttribL[1,2,3,4]dv}
    
    {$region VertexAttribP[1,2,3,4]ui}
    
    public static procedure VertexAttribP1ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP1ui';
    
    public static procedure VertexAttribP2ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP2ui';
    
    public static procedure VertexAttribP3ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP3ui';
    
    public static procedure VertexAttribP4ui(index: UInt32; &type: DataType; normalized: boolean; value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP4ui';
    
    {$endregion VertexAttribP[1,2,3,4]ui}
    
    {$region VertexAttribP[1,2,3,4]uiv}
    
    public static procedure VertexAttribP1uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP1uiv';
    public static procedure VertexAttribP1uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer);
    external 'opengl32.dll' name 'glVertexAttribP1uiv';
    
    public static procedure VertexAttribP2uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP2uiv';
    public static procedure VertexAttribP2uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer);
    external 'opengl32.dll' name 'glVertexAttribP2uiv';
    
    public static procedure VertexAttribP3uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP3uiv';
    public static procedure VertexAttribP3uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer);
    external 'opengl32.dll' name 'glVertexAttribP3uiv';
    
    public static procedure VertexAttribP4uiv(index: UInt32; &type: DataType; normalized: boolean; var value: UInt32);
    external 'opengl32.dll' name 'glVertexAttribP4uiv';
    public static procedure VertexAttribP4uiv(index: UInt32; &type: DataType; normalized: boolean; value: pointer);
    external 'opengl32.dll' name 'glVertexAttribP4uiv';
    
    {$endregion VertexAttribP[1,2,3,4]uiv}
    
    {$endregion 10.2 - Current Vertex Attribute Values}
    
    {$region 10.3 - Vertex Arrays}
    
    // 10.3.1
    
    public static procedure GenVertexArrays(n: Int32; [MarshalAs(UnmanagedType.LPArray)] arrays: array of VertexArrayName);
    external 'opengl32.dll' name 'glGenVertexArrays';
    public static procedure GenVertexArrays(n: Int32; var arrays: VertexArrayName);
    external 'opengl32.dll' name 'glGenVertexArrays';
    public static procedure GenVertexArrays(n: Int32; arrays: pointer);
    external 'opengl32.dll' name 'glGenVertexArrays';
    
    public static procedure DeleteVertexArrays(n: Int32; [MarshalAs(UnmanagedType.LPArray)] arrays: array of VertexArrayName);
    external 'opengl32.dll' name 'glDeleteVertexArrays';
    public static procedure DeleteVertexArrays(n: Int32; var arrays: VertexArrayName);
    external 'opengl32.dll' name 'glDeleteVertexArrays';
    public static procedure DeleteVertexArrays(n: Int32; arrays: pointer);
    external 'opengl32.dll' name 'glDeleteVertexArrays';
    
    public static procedure BindVertexArray(&array: VertexArrayName);
    external 'opengl32.dll' name 'glBindVertexArray';
    
    public static procedure CreateVertexArrays(n: Int32; [MarshalAs(UnmanagedType.LPArray)] arrays: array of VertexArrayName);
    external 'opengl32.dll' name 'glCreateVertexArrays';
    public static procedure CreateVertexArrays(n: Int32; var arrays: VertexArrayName);
    external 'opengl32.dll' name 'glCreateVertexArrays';
    public static procedure CreateVertexArrays(n: Int32; arrays: pointer);
    external 'opengl32.dll' name 'glCreateVertexArrays';
    
    public static function IsVertexArray(&array: VertexArrayName): boolean;
    external 'opengl32.dll' name 'glIsVertexArray';
    
    public static procedure VertexArrayElementBuffer(vaobj: VertexArrayName; buffer: BufferName);
    external 'opengl32.dll' name 'glVertexArrayElementBuffer';
    
    // 10.3.2
    
    public static procedure VertexAttribFormat(attribindex: UInt32; size: Int32; &type: DataType; normalized: boolean; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexAttribFormat';
    
    public static procedure VertexAttribIFormat(attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexAttribIFormat';
    
    public static procedure VertexAttribLFormat(attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexAttribLFormat';
    
    public static procedure VertexArrayAttribFormat(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; normalized: boolean; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexArrayAttribFormat';
    
    public static procedure VertexArrayAttribIFormat(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexArrayAttribIFormat';
    
    public static procedure VertexArrayAttribLFormat(vaobj: VertexArrayName; attribindex: UInt32; size: Int32; &type: DataType; relativeoffset: UInt32);
    external 'opengl32.dll' name 'glVertexArrayAttribLFormat';
    
    public static procedure BindVertexBuffer(bindingindex: UInt32; buffer: BufferName; offset: IntPtr; stride: Int32);
    external 'opengl32.dll' name 'glBindVertexBuffer';
    
    public static procedure VertexArrayVertexBuffer(vaobj: VertexArrayName; bindingindex: UInt32; buffer: BufferName; offset: IntPtr; stride: Int32);
    external 'opengl32.dll' name 'glVertexArrayVertexBuffer';
    
    public static procedure BindVertexBuffers(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName; [MarshalAs(UnmanagedType.LPArray)] offsets: array of IntPtr; [MarshalAs(UnmanagedType.LPArray)] strides: array of Int32);
    external 'opengl32.dll' name 'glBindVertexBuffers';
    public static procedure BindVertexBuffers(first: UInt32; count: Int32; var buffers: BufferName; var offsets: IntPtr; var strides: Int32);
    external 'opengl32.dll' name 'glBindVertexBuffers';
    public static procedure BindVertexBuffers(first: UInt32; count: Int32; buffers: pointer; offsets: pointer; strides: pointer);
    external 'opengl32.dll' name 'glBindVertexBuffers';
    
    public static procedure VertexArrayVertexBuffers(vaobj: VertexArrayName; first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] buffers: array of BufferName; [MarshalAs(UnmanagedType.LPArray)] offsets: array of IntPtr; [MarshalAs(UnmanagedType.LPArray)] strides: array of Int32);
    external 'opengl32.dll' name 'glVertexArrayVertexBuffers';
    public static procedure VertexArrayVertexBuffers(vaobj: VertexArrayName; first: UInt32; count: Int32; var buffers: BufferName; var offsets: IntPtr; var strides: Int32);
    external 'opengl32.dll' name 'glVertexArrayVertexBuffers';
    public static procedure VertexArrayVertexBuffers(vaobj: VertexArrayName; first: UInt32; count: Int32; buffers: pointer; offsets: pointer; strides: pointer);
    external 'opengl32.dll' name 'glVertexArrayVertexBuffers';
    
    public static procedure VertexAttribBinding(attribindex: UInt32; bindingindex: UInt32);
    external 'opengl32.dll' name 'glVertexAttribBinding';
    
    public static procedure VertexArrayAttribBinding(vaobj: VertexArrayName; attribindex: UInt32; bindingindex: UInt32);
    external 'opengl32.dll' name 'glVertexArrayAttribBinding';
    
    public static procedure VertexAttribPointer(index: UInt32; size: Int32; &type: DataType; normalized: boolean; stride: Int32; _pointer: IntPtr);
    external 'opengl32.dll' name 'glVertexAttribPointer';
    public static procedure VertexAttribPointer(index: UInt32; size: Int32; &type: DataType; normalized: boolean; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexAttribPointer';
    
    public static procedure VertexAttribIPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: IntPtr);
    external 'opengl32.dll' name 'glVertexAttribIPointer';
    public static procedure VertexAttribIPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexAttribIPointer';
    
    public static procedure VertexAttribLPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: IntPtr);
    external 'opengl32.dll' name 'glVertexAttribLPointer';
    public static procedure VertexAttribLPointer(index: UInt32; size: Int32; &type: DataType; stride: Int32; _pointer: pointer);
    external 'opengl32.dll' name 'glVertexAttribLPointer';
    
    public static procedure EnableVertexAttribArray(index: UInt32);
    external 'opengl32.dll' name 'glEnableVertexAttribArray';
    
    public static procedure EnableVertexArrayAttrib(vaobj: VertexArrayName; index: UInt32);
    external 'opengl32.dll' name 'glEnableVertexArrayAttrib';
    
    public static procedure DisableVertexAttribArray(index: UInt32);
    external 'opengl32.dll' name 'glDisableVertexAttribArray';
    
    public static procedure DisableVertexArrayAttrib(vaobj: VertexArrayName; index: UInt32);
    external 'opengl32.dll' name 'glDisableVertexArrayAttrib';
    
    public static procedure VertexBindingDivisor(bindingindex: UInt32; divisor: UInt32);
    external 'opengl32.dll' name 'glVertexBindingDivisor';
    
    public static procedure VertexArrayBindingDivisor(vaobj: VertexArrayName; bindingindex: UInt32; divisor: UInt32);
    external 'opengl32.dll' name 'glVertexArrayBindingDivisor';
    
    public static procedure VertexAttribDivisor(index: UInt32; divisor: UInt32);
    external 'opengl32.dll' name 'glVertexAttribDivisor';
    
    // 10.3.6
    
    public static procedure Disable(cap: EnablableName);
    external 'opengl32.dll' name 'glDisable';
    
    public static procedure Enable(cap: EnablableName);
    external 'opengl32.dll' name 'glEnable';
    
    public static procedure PrimitiveRestartIndex(index: UInt32);
    external 'opengl32.dll' name 'glPrimitiveRestartIndex';
    
    {$endregion 10.3 - Vertex Arrays}
    
    {$region 10.4 - Drawing Commands Using Vertex Arrays}
    
    public static procedure DrawArrays(mode: PrimitiveType; first: Int32; count: Int32);
    external 'opengl32.dll' name 'glDrawArrays';
    
    public static procedure DrawArraysInstancedBaseInstance(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawArraysInstancedBaseInstance';
    
    public static procedure DrawArraysInstanced(mode: PrimitiveType; first: Int32; count: Int32; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawArraysInstanced';
    
    public static procedure DrawArraysIndirect(mode: PrimitiveType; var indirect: DrawArraysIndirectCommand);
    external 'opengl32.dll' name 'glDrawArraysIndirect';
    public static procedure DrawArraysIndirect(mode: PrimitiveType; indirect: pointer);
    external 'opengl32.dll' name 'glDrawArraysIndirect';
    
    public static procedure MultiDrawArrays(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] first: array of Int32; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawArrays';
    public static procedure MultiDrawArrays(mode: PrimitiveType; var first: Int32; var count: Int32; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawArrays';
    public static procedure MultiDrawArrays(mode: PrimitiveType; first: pointer; count: pointer; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawArrays';
    
    public static procedure MultiDrawArraysIndirect(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] indirect: array of DrawArraysIndirectCommand; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirect';
    public static procedure MultiDrawArraysIndirect(mode: PrimitiveType; var indirect: DrawArraysIndirectCommand; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirect';
    public static procedure MultiDrawArraysIndirect(mode: PrimitiveType; indirect: pointer; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirect';
    
    public static procedure MultiDrawArraysIndirectCount(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] indirect: array of DrawArraysIndirectCommand; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirectCount';
    public static procedure MultiDrawArraysIndirectCount(mode: PrimitiveType; var indirect: DrawArraysIndirectCommand; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirectCount';
    public static procedure MultiDrawArraysIndirectCount(mode: PrimitiveType; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawArraysIndirectCount';
    
    public static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32);
    external 'opengl32.dll' name 'glDrawElements';
    public static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32);
    external 'opengl32.dll' name 'glDrawElements';
    public static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16);
    external 'opengl32.dll' name 'glDrawElements';
    public static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16);
    external 'opengl32.dll' name 'glDrawElements';
    public static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte);
    external 'opengl32.dll' name 'glDrawElements';
    public static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte);
    external 'opengl32.dll' name 'glDrawElements';
    public static procedure DrawElements(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer);
    external 'opengl32.dll' name 'glDrawElements';
    
    public static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    public static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    public static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    public static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    public static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    public static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    public static procedure DrawElementsInstancedBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseInstance';
    
    public static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    public static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    public static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    public static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    public static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    public static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    public static procedure DrawElementsInstanced(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstanced';
    
    public static procedure MultiDrawElements(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of UInt32; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    public static procedure MultiDrawElements(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of UInt16; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    public static procedure MultiDrawElements(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of Byte; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    public static procedure MultiDrawElements(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of IntPtr; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    public static procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of UInt32; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    public static procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of UInt16; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    public static procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of Byte; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    public static procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DataType; var indices: IntPtr; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    public static procedure MultiDrawElements(mode: PrimitiveType; var count: Int32; &type: DataType; var indices: pointer; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    public static procedure MultiDrawElements(mode: PrimitiveType; count: pointer; &type: DataType; indices: pointer; drawcount: Int32);
    external 'opengl32.dll' name 'glMultiDrawElements';
    
    public static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32);
    external 'opengl32.dll' name 'glDrawRangeElements';
    public static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt32);
    external 'opengl32.dll' name 'glDrawRangeElements';
    public static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16);
    external 'opengl32.dll' name 'glDrawRangeElements';
    public static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt16);
    external 'opengl32.dll' name 'glDrawRangeElements';
    public static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte);
    external 'opengl32.dll' name 'glDrawRangeElements';
    public static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: Byte);
    external 'opengl32.dll' name 'glDrawRangeElements';
    public static procedure DrawRangeElements(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: pointer);
    external 'opengl32.dll' name 'glDrawRangeElements';
    
    public static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    public static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    public static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    public static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    public static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    public static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    public static procedure DrawElementsBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsBaseVertex';
    
    public static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    public static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    public static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    public static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: UInt16; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    public static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    public static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; var indices: Byte; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    public static procedure DrawRangeElementsBaseVertex(mode: PrimitiveType; start: UInt32; &end: UInt32; count: Int32; &type: DataType; indices: pointer; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawRangeElementsBaseVertex';
    
    public static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    public static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    public static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    public static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    public static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    public static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    public static procedure DrawElementsInstancedBaseVertex(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; basevertex: Int32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertex';
    
    public static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt32; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    public static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt32; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    public static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of UInt16; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    public static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: UInt16; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    public static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of Byte; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    public static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; var indices: Byte; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    public static procedure DrawElementsInstancedBaseVertexBaseInstance(mode: PrimitiveType; count: Int32; &type: DataType; indices: pointer; instancecount: Int32; basevertex: Int32; baseinstance: UInt32);
    external 'opengl32.dll' name 'glDrawElementsInstancedBaseVertexBaseInstance';
    
    public static procedure DrawElementsIndirect(mode: PrimitiveType; &type: DataType; var indirect: DrawArraysIndirectCommand);
    external 'opengl32.dll' name 'glDrawElementsIndirect';
    public static procedure DrawElementsIndirect(mode: PrimitiveType; &type: DataType; indirect: pointer);
    external 'opengl32.dll' name 'glDrawElementsIndirect';
    
    public static procedure MultiDrawElementsIndirect(mode: PrimitiveType; &type: DataType; var indirect: DrawArraysIndirectCommand; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirect';
    public static procedure MultiDrawElementsIndirect(mode: PrimitiveType; &type: DataType; indirect: pointer; drawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirect';
    
    public static procedure MultiDrawElementsIndirectCount(mode: PrimitiveType; &type: DataType; var indirect: DrawArraysIndirectCommand; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirectCount';
    public static procedure MultiDrawElementsIndirectCount(mode: PrimitiveType; &type: DataType; indirect: pointer; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsIndirectCount';
    
    public static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of UInt32; drawcount: Int32; [MarshalAs(UnmanagedType.LPArray)] basevertex: array of Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    public static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of UInt16; drawcount: Int32; [MarshalAs(UnmanagedType.LPArray)] basevertex: array of Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    public static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPArray)] indices: array of array of Byte; drawcount: Int32; [MarshalAs(UnmanagedType.LPArray)] basevertex: array of Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    public static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; [MarshalAs(UnmanagedType.LPArray)] count: array of Int32; &type: DataType; [MarshalAs(UnmanagedType.LPArray)] indices: array of IntPtr; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    public static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of UInt32; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    public static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of UInt16; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    public static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DataType; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPArray)] var indices: array of Byte; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    public static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DataType; var indices: IntPtr; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    public static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; var count: Int32; &type: DataType; var indices: pointer; drawcount: Int32; var basevertex: Int32);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    public static procedure MultiDrawElementsBaseVertex(mode: PrimitiveType; count: pointer; &type: DataType; indices: pointer; drawcount: Int32; basevertex: pointer);
    external 'opengl32.dll' name 'glMultiDrawElementsBaseVertex';
    
    {$endregion 10.4 - Drawing Commands Using Vertex Arrays}
    
    {$region 10.5 - Vertex Array and Vertex Array Object Queries}
    
    public static procedure GetVertexArrayiv(vaobj: VertexArrayName; pname: VertexAttribInfoType; var param: BufferName);
    external 'opengl32.dll' name 'glGetVertexArrayiv';
    public static procedure GetVertexArrayiv(vaobj: VertexArrayName; pname: VertexAttribInfoType; var param: Int32);
    external 'opengl32.dll' name 'glGetVertexArrayiv';
    public static procedure GetVertexArrayiv(vaobj: VertexArrayName; pname: VertexAttribInfoType; param: pointer);
    external 'opengl32.dll' name 'glGetVertexArrayiv';
    
    public static procedure GetVertexArrayIndexediv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; var param: Int32);
    external 'opengl32.dll' name 'glGetVertexArrayIndexediv';
    public static procedure GetVertexArrayIndexediv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; var param: DataType);
    external 'opengl32.dll' name 'glGetVertexArrayIndexediv';
    public static procedure GetVertexArrayIndexediv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; param: pointer);
    external 'opengl32.dll' name 'glGetVertexArrayIndexediv';
    
    public static procedure GetVertexArrayIndexed64iv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; var param: Int64);
    external 'opengl32.dll' name 'glGetVertexArrayIndexed64iv';
    public static procedure GetVertexArrayIndexed64iv(vaobj: VertexArrayName; index: UInt32; pname: VertexAttribInfoType; param: pointer);
    external 'opengl32.dll' name 'glGetVertexArrayIndexed64iv';
    
    public static procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of double);
    external 'opengl32.dll' name 'glGetVertexAttribdv';
    public static procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; var &params: double);
    external 'opengl32.dll' name 'glGetVertexAttribdv';
    public static procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4d);
    external 'opengl32.dll' name 'glGetVertexAttribdv';
    public static procedure GetVertexAttribdv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribdv';
    
    public static procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of single);
    external 'opengl32.dll' name 'glGetVertexAttribfv';
    public static procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; var &params: single);
    external 'opengl32.dll' name 'glGetVertexAttribfv';
    public static procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4f);
    external 'opengl32.dll' name 'glGetVertexAttribfv';
    public static procedure GetVertexAttribfv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribfv';
    
    public static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: BufferName);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    public static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    public static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    public static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    public static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4i);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    public static procedure GetVertexAttribiv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribiv';
    
    public static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: BufferName);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    public static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    public static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    public static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    public static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4i);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    public static procedure GetVertexAttribIiv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribIiv';
    
    public static procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; var &params: DataType);
    external 'opengl32.dll' name 'glGetVertexAttribIuiv';
    public static procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of UInt32);
    external 'opengl32.dll' name 'glGetVertexAttribIuiv';
    public static procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; var &params: UInt32);
    external 'opengl32.dll' name 'glGetVertexAttribIuiv';
    public static procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4ui);
    external 'opengl32.dll' name 'glGetVertexAttribIuiv';
    public static procedure GetVertexAttribIuiv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribIuiv';
    
    public static procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; [MarshalAs(UnmanagedType.LPArray)] &params: array of double);
    external 'opengl32.dll' name 'glGetVertexAttribLdv';
    public static procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; var &params: double);
    external 'opengl32.dll' name 'glGetVertexAttribLdv';
    public static procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; var &params: Vec4d);
    external 'opengl32.dll' name 'glGetVertexAttribLdv';
    public static procedure GetVertexAttribLdv(index: UInt32; pname: VertexAttribInfoType; &params: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribLdv';
    
    public static procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; [MarshalAs(UnmanagedType.LPArray)] _pointer: array of IntPtr);
    external 'opengl32.dll' name 'glGetVertexAttribPointerv';
    public static procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; var _pointer: IntPtr);
    external 'opengl32.dll' name 'glGetVertexAttribPointerv';
    public static procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; var _pointer: pointer);
    external 'opengl32.dll' name 'glGetVertexAttribPointerv';
    public static procedure GetVertexAttribPointerv(index: UInt32; pname: UInt32; _pointer: ^IntPtr);
    external 'opengl32.dll' name 'glGetVertexAttribPointerv';
    
    {$endregion 10.5 - Vertex Array and Vertex Array Object Queries}
    
    {$region 10.9 - Conditional Rendering}
    
    public static procedure BeginConditionalRender(id: UInt32; mode: ConditionalRenderingMode);
    external 'opengl32.dll' name 'glBeginConditionalRender';
    
    public static procedure EndConditionalRender;
    external 'opengl32.dll' name 'glEndConditionalRender';
    
    {$endregion 10.9 - Conditional Rendering}
    
    {$endregion 10.0 - Vertex Specification and Drawing Commands}
    
    {$region 11.0 - Programmable Vertex Processing}
    
    {$region 11.1 - Vertex Shaders}
    
    // 11.1.1
    
    public static procedure BindAttribLocation(&program: ProgramName; index: UInt32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glBindAttribLocation';
    public static procedure BindAttribLocation(&program: ProgramName; index: UInt32; name: IntPtr);
    external 'opengl32.dll' name 'glBindAttribLocation';
    
    public static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    public static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    public static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    public static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    public static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    public static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    public static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    public static procedure GetActiveAttrib(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetActiveAttrib';
    
    public static function GetAttribLocation(&program: ProgramName; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetAttribLocation';
    public static function GetAttribLocation(&program: ProgramName; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetAttribLocation';
    
    //11.1.2
    
    //11.1.2.1
    
    public static procedure TransformFeedbackVaryings(&program: ProgramName; count: Int32; [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.LPStr)] varyings: array of string; bufferMode: TransformFeedbackBufferMode);
    external 'opengl32.dll' name 'glTransformFeedbackVaryings';
    public static procedure TransformFeedbackVaryings(&program: ProgramName; count: Int32; [MarshalAs(UnmanagedType.SysInt, ArraySubType = UnmanagedType.LPStr)] var varyings: string; bufferMode: TransformFeedbackBufferMode);
    external 'opengl32.dll' name 'glTransformFeedbackVaryings';
    public static procedure TransformFeedbackVaryings(&program: ProgramName; count: Int32; var varyings: IntPtr; bufferMode: TransformFeedbackBufferMode);
    external 'opengl32.dll' name 'glTransformFeedbackVaryings';
    public static procedure TransformFeedbackVaryings(&program: ProgramName; count: Int32; varyings: pointer; bufferMode: TransformFeedbackBufferMode);
    external 'opengl32.dll' name 'glTransformFeedbackVaryings';
    
    public static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    public static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: ProgramVarType; name: IntPtr);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    public static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    public static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    public static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    public static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: ProgramVarType; name: IntPtr);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    public static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    public static procedure GetTransformFeedbackVarying(&program: ProgramName; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr);
    external 'opengl32.dll' name 'glGetTransformFeedbackVarying';
    
    //11.1.3
    
    //11.1.3.11
    
    public static procedure ValidateProgram(&program: ProgramName);
    external 'opengl32.dll' name 'glValidateProgram';
    
    public static procedure ValidateProgramPipeline(pipeline: ProgramPipelineName);
    external 'opengl32.dll' name 'glValidateProgramPipeline';
    
    {$endregion 11.1 - Vertex Shaders}
    
    {$region 11.2 - Tessellation}
    
    // 11.2.2
    
    public static procedure PatchParameterfv(pname: PatchMode; var values: Vec2f);
    external 'opengl32.dll' name 'glPatchParameterfv';
    public static procedure PatchParameterfv(pname: PatchMode; var values: Vec4f);
    external 'opengl32.dll' name 'glPatchParameterfv';
    public static procedure PatchParameterfv(pname: PatchMode; [MarshalAs(UnmanagedType.LPArray)] values: array of single);
    external 'opengl32.dll' name 'glPatchParameterfv';
    public static procedure PatchParameterfv(pname: PatchMode; var values: single);
    external 'opengl32.dll' name 'glPatchParameterfv';
    public static procedure PatchParameterfv(pname: PatchMode; values: pointer);
    external 'opengl32.dll' name 'glPatchParameterfv';
    
    {$endregion 11.2 - Tessellation}
    
    {$endregion 11.0 - Programmable Vertex Processing}
    
    {$region 13.0 - Fixed-Function Vertex Post-Processing}
    
    {$region 13.3 - Transform Feedback}
    
    // 13.3.1
    
    public static procedure GenTransformFeedbacks(n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of TransformFeedbackName);
    external 'opengl32.dll' name 'glGenTransformFeedbacks';
    public static procedure GenTransformFeedbacks(n: Int32; var ids: TransformFeedbackName);
    external 'opengl32.dll' name 'glGenTransformFeedbacks';
    public static procedure GenTransformFeedbacks(n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glGenTransformFeedbacks';
    
    public static procedure DeleteTransformFeedbacks(n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of TransformFeedbackName);
    external 'opengl32.dll' name 'glDeleteTransformFeedbacks';
    public static procedure DeleteTransformFeedbacks(n: Int32; var ids: TransformFeedbackName);
    external 'opengl32.dll' name 'glDeleteTransformFeedbacks';
    public static procedure DeleteTransformFeedbacks(n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glDeleteTransformFeedbacks';
    
    public static function IsTransformFeedback(id: TransformFeedbackName): boolean;
    external 'opengl32.dll' name 'glIsTransformFeedback';
    
    public static procedure BindTransformFeedback(target: TransformFeedbackBindTarget; id: TransformFeedbackName);
    external 'opengl32.dll' name 'glBindTransformFeedback';
    
    public static procedure CreateTransformFeedbacks(n: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of TransformFeedbackName);
    external 'opengl32.dll' name 'glCreateTransformFeedbacks';
    public static procedure CreateTransformFeedbacks(n: Int32; var ids: TransformFeedbackName);
    external 'opengl32.dll' name 'glCreateTransformFeedbacks';
    public static procedure CreateTransformFeedbacks(n: Int32; ids: pointer);
    external 'opengl32.dll' name 'glCreateTransformFeedbacks';
    
    // 13.3.2
    
    public static procedure BeginTransformFeedback(primitiveMode: PrimitiveType);
    external 'opengl32.dll' name 'glBeginTransformFeedback';
    
    public static procedure EndTransformFeedback;
    external 'opengl32.dll' name 'glEndTransformFeedback';
    
    public static procedure PauseTransformFeedback;
    external 'opengl32.dll' name 'glPauseTransformFeedback';
    
    public static procedure ResumeTransformFeedback;
    external 'opengl32.dll' name 'glResumeTransformFeedback';
    
    public static procedure TransformFeedbackBufferRange(xfb: TransformFeedbackName; index: UInt32; buffer: BufferName; offset: IntPtr; size: UIntPtr);
    external 'opengl32.dll' name 'glTransformFeedbackBufferRange';
    
    public static procedure TransformFeedbackBufferBase(xfb: TransformFeedbackName; index: UInt32; buffer: BufferName);
    external 'opengl32.dll' name 'glTransformFeedbackBufferBase';
    
    // 13.3.3
    
    public static procedure DrawTransformFeedback(mode: PrimitiveType; id: TransformFeedbackName);
    external 'opengl32.dll' name 'glDrawTransformFeedback';
    
    public static procedure DrawTransformFeedbackInstanced(mode: PrimitiveType; id: TransformFeedbackName; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawTransformFeedbackInstanced';
    
    public static procedure DrawTransformFeedbackStream(mode: PrimitiveType; id: TransformFeedbackName; stream: UInt32);
    external 'opengl32.dll' name 'glDrawTransformFeedbackStream';
    
    public static procedure DrawTransformFeedbackStreamInstanced(mode: PrimitiveType; id: TransformFeedbackName; stream: UInt32; instancecount: Int32);
    external 'opengl32.dll' name 'glDrawTransformFeedbackStreamInstanced';
    
    {$endregion 13.3 - Transform Feedback}
    
    {$region 13.6 - Flatshading}
    
    public static procedure ProvokingVertex(mode: VertexProvokingMode);
    external 'opengl32.dll' name 'glProvokingVertex';
    
    {$endregion 13.6 - Flatshading}
    
    {$region 13.7 - Primitive Clipping}
    
    public static procedure ClipControl(origin: ClipOriginMode; depth: ClipDepthMode);
    external 'opengl32.dll' name 'glClipControl';
    
    {$endregion 13.7 - Primitive Clipping}
    
    {$region 13.8 - Coordinate Transformations}
    
    // 13.8.1
    
    public static procedure DepthRangeArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of Vec2d);
    external 'opengl32.dll' name 'glDepthRangeArrayv';
    public static procedure DepthRangeArrayv(first: UInt32; count: Int32; var v: Vec2d);
    external 'opengl32.dll' name 'glDepthRangeArrayv';
    public static procedure DepthRangeArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of double);
    external 'opengl32.dll' name 'glDepthRangeArrayv';
    public static procedure DepthRangeArrayv(first: UInt32; count: Int32; var v: double);
    external 'opengl32.dll' name 'glDepthRangeArrayv';
    public static procedure DepthRangeArrayv(first: UInt32; count: Int32; v: pointer);
    external 'opengl32.dll' name 'glDepthRangeArrayv';
    
    public static procedure DepthRangeIndexed(index: UInt32; nearVal: double; farVal: double);
    external 'opengl32.dll' name 'glDepthRangeIndexed';
    
    public static procedure DepthRange(nearVal: double; farVal: double);
    external 'opengl32.dll' name 'glDepthRange';
    
    public static procedure DepthRangef(nearVal: single; farVal: single);
    external 'opengl32.dll' name 'glDepthRangef';
    
    public static procedure ViewportArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of Vec4f);
    external 'opengl32.dll' name 'glViewportArrayv';
    public static procedure ViewportArrayv(first: UInt32; count: Int32; var v: Vec4f);
    external 'opengl32.dll' name 'glViewportArrayv';
    public static procedure ViewportArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glViewportArrayv';
    public static procedure ViewportArrayv(first: UInt32; count: Int32; var v: single);
    external 'opengl32.dll' name 'glViewportArrayv';
    public static procedure ViewportArrayv(first: UInt32; count: Int32; v: pointer);
    external 'opengl32.dll' name 'glViewportArrayv';
    
    public static procedure ViewportIndexedf(index: UInt32; x: single; y: single; w: single; h: single);
    external 'opengl32.dll' name 'glViewportIndexedf';
    
    public static procedure ViewportIndexedfv(index: UInt32; var v: Vec4f);
    external 'opengl32.dll' name 'glViewportIndexedfv';
    public static procedure ViewportIndexedfv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of single);
    external 'opengl32.dll' name 'glViewportIndexedfv';
    public static procedure ViewportIndexedfv(index: UInt32; var v: single);
    external 'opengl32.dll' name 'glViewportIndexedfv';
    public static procedure ViewportIndexedfv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glViewportIndexedfv';
    
    public static procedure Viewport(x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glViewport';
    
    {$endregion 13.8 - Coordinate Transformations}
    
    {$endregion 13.0 - Fixed-Function Vertex Post-Processing}
    
    {$region 14.0 - Fixed-Function Primitive Assembly and Rasterization}
    
    {$region 14.3 - Antialiasing}
    
    // 14.3.1
    
    public static procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; var val: Vec2f);
    external 'opengl32.dll' name 'glGetMultisamplefv';
    public static procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] val: array of single);
    external 'opengl32.dll' name 'glGetMultisamplefv';
    public static procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; var val: single);
    external 'opengl32.dll' name 'glGetMultisamplefv';
    public static procedure GetMultisamplefv(pname: MultisampleInfoType; index: UInt32; val: pointer);
    external 'opengl32.dll' name 'glGetMultisamplefv';
    
    // 14.3.1.1
    
    public static procedure MinSampleShading(value: single);
    external 'opengl32.dll' name 'glMinSampleShading';
    
    {$endregion 14.3 - Antialiasing}
    
    {$region 14.4 - Points}
    
    public static procedure PointSize(size: single);
    external 'opengl32.dll' name 'glPointSize';
    
    public static procedure PointParameteri(pname: PointInfoType; param: Int32);
    external 'opengl32.dll' name 'glPointParameteri';
    public static procedure PointParameteri(pname: PointInfoType; param: ClipOriginMode);
    external 'opengl32.dll' name 'glPointParameteri';
    
    public static procedure PointParameterf(pname: PointInfoType; param: single);
    external 'opengl32.dll' name 'glPointParameterf';
    
    public static procedure PointParameteriv(pname: PointInfoType; var &params: Int32);
    external 'opengl32.dll' name 'glPointParameteriv';
    public static procedure PointParameteriv(pname: PointInfoType; &params: pointer);
    external 'opengl32.dll' name 'glPointParameteriv';
    
    public static procedure PointParameterfv(pname: PointInfoType; var &params: single);
    external 'opengl32.dll' name 'glPointParameterfv';
    public static procedure PointParameterfv(pname: PointInfoType; &params: pointer);
    external 'opengl32.dll' name 'glPointParameterfv';
    
    {$endregion 14.4 - Points}
    
    {$region 14.5 - Line Segments}
    
    public static procedure LineWidth(width: single);
    external 'opengl32.dll' name 'glLineWidth';
    
    {$endregion 14.5 - Line Segments}
    
    {$region 14.6 - Polygons}
    
    // 14.6.1
    
    public static procedure FrontFace(mode: FrontFaceDirection);
    external 'opengl32.dll' name 'glFrontFace';
    
    public static procedure CullFace(mode: PolygonFace);
    external 'opengl32.dll' name 'glCullFace';
    
    // 14.6.4
    
    public static procedure PolygonMode(face: PolygonFace; mode: PolygonRasterizationMode);
    external 'opengl32.dll' name 'glPolygonMode';
    
    // 14.6.5
    
    public static procedure PolygonOffsetClamp(factor: single; units: single; clamp: single);
    external 'opengl32.dll' name 'glPolygonOffsetClamp';
    
    public static procedure PolygonOffset(factor: single; units: single);
    external 'opengl32.dll' name 'glPolygonOffset';
    
    {$endregion 14.6 - Polygons}
    
    {$region 14.9 - Early Per-Fragment Tests}
    
    // 14.9.2
    
    public static procedure ScissorArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of Vec4i);
    external 'opengl32.dll' name 'glScissorArrayv';
    public static procedure ScissorArrayv(first: UInt32; count: Int32; var v: Vec4i);
    external 'opengl32.dll' name 'glScissorArrayv';
    public static procedure ScissorArrayv(first: UInt32; count: Int32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glScissorArrayv';
    public static procedure ScissorArrayv(first: UInt32; count: Int32; var v: Int32);
    external 'opengl32.dll' name 'glScissorArrayv';
    public static procedure ScissorArrayv(first: UInt32; count: Int32; v: pointer);
    external 'opengl32.dll' name 'glScissorArrayv';
    
    public static procedure ScissorIndexed(index: UInt32; left: Int32; bottom: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glScissorIndexed';
    
    public static procedure ScissorIndexedv(index: UInt32; var v: Vec4i);
    external 'opengl32.dll' name 'glScissorIndexedv';
    public static procedure ScissorIndexedv(index: UInt32; [MarshalAs(UnmanagedType.LPArray)] v: array of Int32);
    external 'opengl32.dll' name 'glScissorIndexedv';
    public static procedure ScissorIndexedv(index: UInt32; var v: Int32);
    external 'opengl32.dll' name 'glScissorIndexedv';
    public static procedure ScissorIndexedv(index: UInt32; v: pointer);
    external 'opengl32.dll' name 'glScissorIndexedv';
    
    public static procedure Scissor(x: Int32; y: Int32; width: Int32; height: Int32);
    external 'opengl32.dll' name 'glScissor';
    
    // 14.9.3
    
    public static procedure SampleCoverage(value: single; invert: boolean);
    external 'opengl32.dll' name 'glSampleCoverage';
    
    public static procedure SampleMaski(maskNumber: UInt32; mask: UInt32);
    external 'opengl32.dll' name 'glSampleMaski';
    
    {$endregion 14.9 - Early Per-Fragment Tests}
    
    {$endregion 14.0 - Fixed-Function Primitive Assembly and Rasterization}
    
    {$region 15.0 - Programmable Fragment Processing}
    
    {$region 15.2 - Shader Execution}
    
    // 15.2.3
    
    public static procedure BindFragDataLocationIndexed(&program: ProgramName; colorNumber: UInt32; index: UInt32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glBindFragDataLocationIndexed';
    public static procedure BindFragDataLocationIndexed(&program: ProgramName; colorNumber: UInt32; index: UInt32; name: IntPtr);
    external 'opengl32.dll' name 'glBindFragDataLocationIndexed';
    
    public static procedure BindFragDataLocation(&program: ProgramName; colorNumber: UInt32; [MarshalAs(UnmanagedType.LPStr)] name: string);
    external 'opengl32.dll' name 'glBindFragDataLocation';
    public static procedure BindFragDataLocation(&program: ProgramName; colorNumber: UInt32; name: IntPtr);
    external 'opengl32.dll' name 'glBindFragDataLocation';
    
    public static function GetFragDataLocation(&program: ProgramName; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetFragDataLocation';
    public static function GetFragDataLocation(&program: ProgramName; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetFragDataLocation';
    
    public static function GetFragDataIndex(&program: ProgramName; [MarshalAs(UnmanagedType.LPStr)] name: string): Int32;
    external 'opengl32.dll' name 'glGetFragDataIndex';
    public static function GetFragDataIndex(&program: ProgramName; name: IntPtr): Int32;
    external 'opengl32.dll' name 'glGetFragDataIndex';
    
    {$endregion 15.2 - Shader Execution}
    
    {$endregion 15.0 - Programmable Fragment Processing}
    
    {$region 17.0 - Writing Fragments and Samples to the Framebuffer}
    
    {$region 17.3 - Per-Fragment Operations}
    
    // 17.3.3
    
    public static procedure StencilFunc(func: ActivationFunc; ref: Int32; mask: UInt32);
    external 'opengl32.dll' name 'glStencilFunc';
    
    public static procedure StencilFuncSeparate(face: PolygonFace; func: ActivationFunc; ref: Int32; mask: UInt32);
    external 'opengl32.dll' name 'glStencilFuncSeparate';
    
    public static procedure StencilOp(fail: StencilOpFailMode; zfail: StencilOpFailMode; zpass: StencilOpFailMode);
    external 'opengl32.dll' name 'glStencilOp';
    
    public static procedure StencilOpSeparate(face: PolygonFace; sfail: StencilOpFailMode; dpfail: StencilOpFailMode; dppass: StencilOpFailMode);
    external 'opengl32.dll' name 'glStencilOpSeparate';
    
    // 17.3.4
    
    public static procedure DepthFunc(func: ActivationFunc);
    external 'opengl32.dll' name 'glDepthFunc';
    
    // 17.3.6
    
    public static procedure Enablei(target: EnablableName; index: UInt32);
    external 'opengl32.dll' name 'glEnablei';
    
    public static procedure Disablei(target: EnablableName; index: UInt32);
    external 'opengl32.dll' name 'glDisablei';
    
    // 17.3.6.1
    
    public static procedure BlendEquation(mode: BlendEquationMode);
    external 'opengl32.dll' name 'glBlendEquation';
    
    public static procedure BlendEquationSeparate(modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode);
    external 'opengl32.dll' name 'glBlendEquationSeparate';
    
    public static procedure BlendEquationi(buf: UInt32; mode: BlendEquationMode);
    external 'opengl32.dll' name 'glBlendEquationi';
    
    public static procedure BlendEquationSeparatei(buf: UInt32; modeRGB: BlendEquationMode; modeAlpha: BlendEquationMode);
    external 'opengl32.dll' name 'glBlendEquationSeparatei';
    
    // 17.3.6.2
    
    public static procedure BlendFunc(sfactor: BlendFuncMode; dfactor: BlendFuncMode);
    external 'opengl32.dll' name 'glBlendFunc';
    
    public static procedure BlendFuncSeparate(sfactorRGB: BlendFuncMode; dfactorRGB: BlendFuncMode; sfactorAlpha: BlendFuncMode; dfactorAlpha: BlendFuncMode);
    external 'opengl32.dll' name 'glBlendFuncSeparate';
    
    public static procedure BlendFunci(buf: UInt32; src: BlendFuncMode; dst: BlendFuncMode);
    external 'opengl32.dll' name 'glBlendFunci';
    
    public static procedure BlendFuncSeparatei(buf: UInt32; srcRGB: BlendFuncMode; dstRGB: BlendFuncMode; srcAlpha: BlendFuncMode; dstAlpha: BlendFuncMode);
    external 'opengl32.dll' name 'glBlendFuncSeparatei';
    
    // 17.3.6.5
    
    public static procedure BlendColor(red: single; green: single; blue: single; alpha: single);
    external 'opengl32.dll' name 'glBlendColor';
    
    // 17.3.9
    
    public static procedure LogicOp(opcode: LogicOpCode);
    external 'opengl32.dll' name 'glLogicOp';
    
    {$endregion 17.3 - Per-Fragment Operations}
    
    {$region 17.4 - Whole Framebuffer Operations}
    
    // 17.4.1
    
    public static procedure DrawBuffer(buf: FrameBufferPart);
    external 'opengl32.dll' name 'glDrawBuffer';
    
    public static procedure NamedFramebufferDrawBuffer(framebuffer: FramebufferName; buf: FrameBufferPart);
    external 'opengl32.dll' name 'glNamedFramebufferDrawBuffer';
    
    public static procedure DrawBuffers(n: Int32; [MarshalAs(UnmanagedType.LPArray)] bufs: array of FrameBufferPart);
    external 'opengl32.dll' name 'glDrawBuffers';
    public static procedure DrawBuffers(n: Int32; var bufs: FrameBufferPart);
    external 'opengl32.dll' name 'glDrawBuffers';
    public static procedure DrawBuffers(n: Int32; bufs: pointer);
    external 'opengl32.dll' name 'glDrawBuffers';
    
    public static procedure NamedFramebufferDrawBuffers(framebuffer: FramebufferName; n: Int32; [MarshalAs(UnmanagedType.LPArray)] bufs: array of FrameBufferPart);
    external 'opengl32.dll' name 'glNamedFramebufferDrawBuffers';
    public static procedure NamedFramebufferDrawBuffers(framebuffer: FramebufferName; n: Int32; var bufs: FrameBufferPart);
    external 'opengl32.dll' name 'glNamedFramebufferDrawBuffers';
    public static procedure NamedFramebufferDrawBuffers(framebuffer: FramebufferName; n: Int32; bufs: pointer);
    external 'opengl32.dll' name 'glNamedFramebufferDrawBuffers';
    
    // 17.4.2
    
    public static procedure ColorMask(red: boolean; green: boolean; blue: boolean; alpha: boolean);
    external 'opengl32.dll' name 'glColorMask';
    
    public static procedure ColorMaski(index: UInt32; r: boolean; g: boolean; b: boolean; a: boolean);
    external 'opengl32.dll' name 'glColorMaski';
    
    public static procedure DepthMask(flag: boolean);
    external 'opengl32.dll' name 'glDepthMask';
    
    public static procedure StencilMask(mask: UInt32);
    external 'opengl32.dll' name 'glStencilMask';
    
    public static procedure StencilMaskSeparate(face: PolygonFace; mask: UInt32);
    external 'opengl32.dll' name 'glStencilMaskSeparate';
    
    // 17.4.3
    
    public static procedure Clear(mask: BufferTypeFlags);
    external 'opengl32.dll' name 'glClear';
    
    public static procedure ClearColor(red: single; green: single; blue: single; alpha: single);
    external 'opengl32.dll' name 'glClearColor';
    
    public static procedure ClearDepth(depth: double);
    external 'opengl32.dll' name 'glClearDepth';
    
    public static procedure ClearDepthf(depth: single);
    external 'opengl32.dll' name 'glClearDepthf';
    
    public static procedure ClearStencil(s: Int32);
    external 'opengl32.dll' name 'glClearStencil';
    
    // 17.4.3.1
    
    public static procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4i);
    external 'opengl32.dll' name 'glClearBufferiv';
    public static procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4i);
    external 'opengl32.dll' name 'glClearBufferiv';
    public static procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glClearBufferiv';
    public static procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Int32);
    external 'opengl32.dll' name 'glClearBufferiv';
    public static procedure ClearBufferiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearBufferiv';
    
    public static procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4f);
    external 'opengl32.dll' name 'glClearBufferfv';
    public static procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4f);
    external 'opengl32.dll' name 'glClearBufferfv';
    public static procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glClearBufferfv';
    public static procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: single);
    external 'opengl32.dll' name 'glClearBufferfv';
    public static procedure ClearBufferfv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearBufferfv';
    
    public static procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4ui);
    external 'opengl32.dll' name 'glClearBufferuiv';
    public static procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4ui);
    external 'opengl32.dll' name 'glClearBufferuiv';
    public static procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glClearBufferuiv';
    public static procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glClearBufferuiv';
    public static procedure ClearBufferuiv(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearBufferuiv';
    
    public static procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4i);
    external 'opengl32.dll' name 'glClearNamedFramebufferiv';
    public static procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4i);
    external 'opengl32.dll' name 'glClearNamedFramebufferiv';
    public static procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Int32);
    external 'opengl32.dll' name 'glClearNamedFramebufferiv';
    public static procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Int32);
    external 'opengl32.dll' name 'glClearNamedFramebufferiv';
    public static procedure ClearNamedFramebufferiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearNamedFramebufferiv';
    
    public static procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4f);
    external 'opengl32.dll' name 'glClearNamedFramebufferfv';
    public static procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4f);
    external 'opengl32.dll' name 'glClearNamedFramebufferfv';
    public static procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of single);
    external 'opengl32.dll' name 'glClearNamedFramebufferfv';
    public static procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: single);
    external 'opengl32.dll' name 'glClearNamedFramebufferfv';
    public static procedure ClearNamedFramebufferfv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearNamedFramebufferfv';
    
    public static procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of Vec4ui);
    external 'opengl32.dll' name 'glClearNamedFramebufferuiv';
    public static procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: Vec4ui);
    external 'opengl32.dll' name 'glClearNamedFramebufferuiv';
    public static procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; [MarshalAs(UnmanagedType.LPArray)] value: array of UInt32);
    external 'opengl32.dll' name 'glClearNamedFramebufferuiv';
    public static procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; var value: UInt32);
    external 'opengl32.dll' name 'glClearNamedFramebufferuiv';
    public static procedure ClearNamedFramebufferuiv(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; value: pointer);
    external 'opengl32.dll' name 'glClearNamedFramebufferuiv';
    
    public static procedure ClearBufferfi(buffer: FramebufferAttachmentPoint; drawbuffer: Int32; depth: single; stencil: Int32);
    external 'opengl32.dll' name 'glClearBufferfi';
    
    public static procedure ClearNamedFramebufferfi(framebuffer: FramebufferName; buffer: FramebufferAttachmentPoint; drawbuffer: Int32; depth: single; stencil: Int32);
    external 'opengl32.dll' name 'glClearNamedFramebufferfi';
    
    // 17.4.4
    
    public static procedure InvalidateSubFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; [MarshalAs(UnmanagedType.LPArray)] attachments: array of FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateSubFramebuffer';
    public static procedure InvalidateSubFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; var attachments: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateSubFramebuffer';
    public static procedure InvalidateSubFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; attachments: pointer);
    external 'opengl32.dll' name 'glInvalidateSubFramebuffer';
    
    public static procedure InvalidateNamedFramebufferSubData(framebuffer: FramebufferName; numAttachments: Int32; [MarshalAs(UnmanagedType.LPArray)] attachments: array of FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferSubData';
    public static procedure InvalidateNamedFramebufferSubData(framebuffer: FramebufferName; numAttachments: Int32; var attachments: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferSubData';
    public static procedure InvalidateNamedFramebufferSubData(framebuffer: FramebufferName; numAttachments: Int32; attachments: pointer);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferSubData';
    
    public static procedure InvalidateFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; [MarshalAs(UnmanagedType.LPArray)] attachments: array of FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateFramebuffer';
    public static procedure InvalidateFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; var attachments: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateFramebuffer';
    public static procedure InvalidateFramebuffer(target: FramebufferBindTarget; numAttachments: Int32; attachments: pointer);
    external 'opengl32.dll' name 'glInvalidateFramebuffer';
    
    public static procedure InvalidateNamedFramebufferData(framebuffer: FramebufferName; numAttachments: Int32; [MarshalAs(UnmanagedType.LPArray)] attachments: array of FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferData';
    public static procedure InvalidateNamedFramebufferData(framebuffer: FramebufferName; numAttachments: Int32; var attachments: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferData';
    public static procedure InvalidateNamedFramebufferData(framebuffer: FramebufferName; numAttachments: Int32; attachments: pointer);
    external 'opengl32.dll' name 'glInvalidateNamedFramebufferData';
    
    {$endregion 17.4 - Whole Framebuffer Operations}
    
    {$endregion 17.0 - Writing Fragments and Samples to the Framebuffer}
    
    {$region 18.0 - Reading and Copying Pixels}
    
    {$region 18.2 - Reading Pixels}
    
    // 18.2.1
    
    public static procedure ReadBuffer(src: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glReadBuffer';
    
    public static procedure NamedFramebufferReadBuffer(framebuffer: FramebufferName; src: FramebufferAttachmentPoint);
    external 'opengl32.dll' name 'glNamedFramebufferReadBuffer';
    
    // 18.2.2
    
    public static procedure ReadPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: IntPtr);
    external 'opengl32.dll' name 'glReadPixels';
    public static procedure ReadPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; pixels: pointer);
    external 'opengl32.dll' name 'glReadPixels';
    
    public static procedure ReadnPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; bufSize: Int32; data: IntPtr);
    external 'opengl32.dll' name 'glReadnPixels';
    public static procedure ReadnPixels(x: Int32; y: Int32; width: Int32; height: Int32; format: DataFormat; &type: DataType; bufSize: Int32; data: pointer);
    external 'opengl32.dll' name 'glReadnPixels';
    
    // 18.2.8
    
    public static procedure ClampColor(target: ColorClampTarget; clamp: UInt32);
    external 'opengl32.dll' name 'glClampColor';
    
    {$endregion 18.2 - Reading Pixels}
    
    {$region 18.3 - Copying Pixels}
    
    // 18.3.1
    
    public static procedure BlitFramebuffer(srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: BufferTypeFlags; filter: PixelMagFilterMode);
    external 'opengl32.dll' name 'glBlitFramebuffer';
    
    public static procedure BlitNamedFramebuffer(readFramebuffer: FramebufferName; drawFramebuffer: FramebufferName; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: BufferTypeFlags; filter: PixelMagFilterMode);
    external 'opengl32.dll' name 'glBlitNamedFramebuffer';
    
    // 18.3.2
    
    // BufferBindType автоматически конвертируется в CopyableImageType
    public static procedure CopyImageSubData(srcName: UInt32; srcTarget: CopyableImageType; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: CopyableImageType; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32);
    external 'opengl32.dll' name 'glCopyImageSubData';
    
    {$endregion 18.3 - Copying Pixels}
    
    {$endregion 18.0 - Reading and Copying Pixels}
    
    {$region 19.0 - Compute Shaders}
    
    public static procedure DispatchCompute(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32);
    external 'opengl32.dll' name 'glDispatchCompute';
    
    public static procedure DispatchComputeIndirect(indirect: IntPtr);
    external 'opengl32.dll' name 'glDispatchComputeIndirect';
    
    {$endregion 19.0 - Compute Shaders}
    
    {$region 20.0 - Debug Output}
    
    {$region 20.2 - Debug Message Callback}
    
    public static procedure DebugMessageCallback(callback: GLDEBUGPROC; userParam: IntPtr);
    external 'opengl32.dll' name 'glDebugMessageCallback';
    public static procedure DebugMessageCallback(callback: GLDEBUGPROC; userParam: pointer);
    external 'opengl32.dll' name 'glDebugMessageCallback';
    
    {$endregion 20.2 - Debug Message Callback}
    
    {$region 20.4 - Controlling Debug Messages}
    
    public static procedure DebugMessageControl(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; [MarshalAs(UnmanagedType.LPArray)] ids: array of UInt32; enabled: boolean);
    external 'opengl32.dll' name 'glDebugMessageControl';
    public static procedure DebugMessageControl(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; var ids: UInt32; enabled: boolean);
    external 'opengl32.dll' name 'glDebugMessageControl';
    public static procedure DebugMessageControl(source: DebugSourceType; &type: DebugMessageType; severity: DebugSeverityLevel; count: Int32; ids: IntPtr; enabled: boolean);
    external 'opengl32.dll' name 'glDebugMessageControl';
    
    {$endregion 20.4 - Controlling Debug Messages}
    
    {$region 20.5 - Externally Generated Messages}
    
    public static procedure DebugMessageInsert(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; [MarshalAs(UnmanagedType.LPStr)] buf: string);
    external 'opengl32.dll' name 'glDebugMessageInsert';
    public static procedure DebugMessageInsert(source: DebugSourceType; &type: DebugMessageType; id: UInt32; severity: DebugSeverityLevel; length: Int32; buf: IntPtr);
    external 'opengl32.dll' name 'glDebugMessageInsert';
    
    {$endregion 20.5 - Externally Generated Messages}
    
    {$region 20.6 - Debug Groups}
    
    public static procedure PushDebugGroup(source: DebugSourceType; id: UInt32; length: Int32; [MarshalAs(UnmanagedType.LPStr)] message: string);
    external 'opengl32.dll' name 'glPushDebugGroup';
    public static procedure PushDebugGroup(source: DebugSourceType; id: UInt32; length: Int32; message: IntPtr);
    external 'opengl32.dll' name 'glPushDebugGroup';
    
    public static procedure PopDebugGroup;
    external 'opengl32.dll' name 'glPopDebugGroup';
    
    {$endregion 20.6 - Debug Groups}
    
    {$region 20.7 - Debug Labels}
    
    public static procedure ObjectLabel(identifier: ObjectType; name: UInt32; length: Int32; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glObjectLabel';
    public static procedure ObjectLabel(identifier: ObjectType; name: UInt32; length: Int32; &label: IntPtr);
    external 'opengl32.dll' name 'glObjectLabel';
    
    public static procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glObjectPtrLabel';
    public static procedure ObjectPtrLabel(ptr: IntPtr; length: Int32; &label: IntPtr);
    external 'opengl32.dll' name 'glObjectPtrLabel';
    public static procedure ObjectPtrLabel(ptr: pointer; length: Int32; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glObjectPtrLabel';
    public static procedure ObjectPtrLabel(ptr: pointer; length: Int32; &label: IntPtr);
    external 'opengl32.dll' name 'glObjectPtrLabel';
    
    {$endregion 20.7 - Debug Labels}
    
    {$region 20.9 - Debug Output Queries}
    
    // ВНИМАНИЕ! messageLog является суммой count нуль-терминированных строк, то есть символ 0 будет после каждого сообщения. Обычные методы перевода тут не будут работать, надо ручками
    public static function GetDebugMessageLog(count: UInt32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] sources: array of DebugSourceType; [MarshalAs(UnmanagedType.LPArray)] types: array of DebugMessageType; [MarshalAs(UnmanagedType.LPArray)] ids: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] severities: array of DebugSeverityLevel; [MarshalAs(UnmanagedType.LPArray)] lengths: array of Int32; [MarshalAs(UnmanagedType.HString)] &messageLog: string): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    public static function GetDebugMessageLog(count: UInt32; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] sources: array of DebugSourceType; [MarshalAs(UnmanagedType.LPArray)] types: array of DebugMessageType; [MarshalAs(UnmanagedType.LPArray)] ids: array of UInt32; [MarshalAs(UnmanagedType.LPArray)] severities: array of DebugSeverityLevel; [MarshalAs(UnmanagedType.LPArray)] lengths: array of Int32; messageLog: IntPtr): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    public static function GetDebugMessageLog(count: UInt32; bufSize: Int32; var sources: DebugSourceType; var types: DebugMessageType; var ids: UInt32; var severities: DebugSeverityLevel; var lengths: Int32; [MarshalAs(UnmanagedType.HString)] &messageLog: string): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    public static function GetDebugMessageLog(count: UInt32; bufSize: Int32; var sources: DebugSourceType; var types: DebugMessageType; var ids: UInt32; var severities: DebugSeverityLevel; var lengths: Int32; messageLog: IntPtr): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    public static function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; [MarshalAs(UnmanagedType.HString)] &messageLog: string): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    public static function GetDebugMessageLog(count: UInt32; bufSize: Int32; sources: IntPtr; types: IntPtr; ids: IntPtr; severities: IntPtr; lengths: IntPtr; messageLog: IntPtr): UInt32;
    external 'opengl32.dll' name 'glGetDebugMessageLog';
    
    public static procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glGetObjectLabel';
    public static procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; var length: Int32; &label: IntPtr);
    external 'opengl32.dll' name 'glGetObjectLabel';
    public static procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glGetObjectLabel';
    public static procedure GetObjectLabel(identifier: ObjectType; name: UInt32; bufSize: Int32; length: pointer; &label: IntPtr);
    external 'opengl32.dll' name 'glGetObjectLabel';
    
    public static procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; var length: Int32; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glGetObjectPtrLabel';
    public static procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; var length: Int32; &label: IntPtr);
    external 'opengl32.dll' name 'glGetObjectPtrLabel';
    public static procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; length: pointer; [MarshalAs(UnmanagedType.LPStr)] &label: string);
    external 'opengl32.dll' name 'glGetObjectPtrLabel';
    public static procedure GetObjectPtrLabel(ptr: pointer; bufSize: Int32; length: pointer; &label: IntPtr);
    external 'opengl32.dll' name 'glGetObjectPtrLabel';
    
    {$endregion 20.9 - Debug Output Queries}
    
    {$endregion 20.0 - Debug Output}
    
    {$region 21.0 - Special Functions}
    
    {$region 21.5 - Hints}
    
    public static procedure Hint(target: HintType; mode: HintValue);
    external 'opengl32.dll' name 'glHint';
    
    {$endregion 21.5 - Hints}
    
    {$endregion 21.0 - Special Functions}
    
    {$region 22.0 - Context State Queries}
    
    {$region 22.1 - Simple Queries}
    
    public static procedure GetBooleanv(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] data: array of boolean);
    external 'opengl32.dll' name 'glGetBooleanv';
    public static procedure GetBooleanv(pname: GLGetQueries; var data: boolean);
    external 'opengl32.dll' name 'glGetBooleanv';
    public static procedure GetBooleanv(pname: GLGetQueries; data: pointer);
    external 'opengl32.dll' name 'glGetBooleanv';
    
    public static procedure GetIntegerv(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] data: array of Int32);
    external 'opengl32.dll' name 'glGetIntegerv';
    public static procedure GetIntegerv(pname: GLGetQueries; var data: Int32);
    external 'opengl32.dll' name 'glGetIntegerv';
    public static procedure GetIntegerv(pname: GLGetQueries; data: pointer);
    external 'opengl32.dll' name 'glGetIntegerv';
    
    public static procedure GetInteger64v(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] data: array of Int64);
    external 'opengl32.dll' name 'glGetInteger64v';
    public static procedure GetInteger64v(pname: GLGetQueries; var data: Int64);
    external 'opengl32.dll' name 'glGetInteger64v';
    public static procedure GetInteger64v(pname: GLGetQueries; data: pointer);
    external 'opengl32.dll' name 'glGetInteger64v';
    
    public static procedure GetFloatv(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] data: array of single);
    external 'opengl32.dll' name 'glGetFloatv';
    public static procedure GetFloatv(pname: GLGetQueries; var data: single);
    external 'opengl32.dll' name 'glGetFloatv';
    public static procedure GetFloatv(pname: GLGetQueries; data: pointer);
    external 'opengl32.dll' name 'glGetFloatv';
    
    public static procedure GetDoublev(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] data: array of double);
    external 'opengl32.dll' name 'glGetDoublev';
    public static procedure GetDoublev(pname: GLGetQueries; var data: double);
    external 'opengl32.dll' name 'glGetDoublev';
    public static procedure GetDoublev(pname: GLGetQueries; data: pointer);
    external 'opengl32.dll' name 'glGetDoublev';
    
    public static procedure GetBooleani_v(target: GLGetQueries; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] data: array of boolean);
    external 'opengl32.dll' name 'glGetBooleani_v';
    public static procedure GetBooleani_v(target: GLGetQueries; index: UInt32; var data: boolean);
    external 'opengl32.dll' name 'glGetBooleani_v';
    public static procedure GetBooleani_v(target: GLGetQueries; index: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetBooleani_v';
    
    public static procedure GetFloati_v(target: GLGetQueries; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] data: array of single);
    external 'opengl32.dll' name 'glGetFloati_v';
    public static procedure GetFloati_v(target: GLGetQueries; index: UInt32; var data: single);
    external 'opengl32.dll' name 'glGetFloati_v';
    public static procedure GetFloati_v(target: GLGetQueries; index: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetFloati_v';
    
    public static procedure GetIntegeri_v(target: GLGetQueries; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] data: array of Int32);
    external 'opengl32.dll' name 'glGetIntegeri_v';
    public static procedure GetIntegeri_v(target: GLGetQueries; index: UInt32; var data: Int32);
    external 'opengl32.dll' name 'glGetIntegeri_v';
    public static procedure GetIntegeri_v(target: BufferBindType; index: UInt32; var data: BufferName);
    external 'opengl32.dll' name 'glGetIntegeri_v';
    public static procedure GetIntegeri_v(target: GLGetQueries; index: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetIntegeri_v';
    
    public static procedure GetInteger64i_v(target: GLGetQueries; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] data: array of Int64);
    external 'opengl32.dll' name 'glGetInteger64i_v';
    public static procedure GetInteger64i_v(target: GLGetQueries; index: UInt32; var data: Int64);
    external 'opengl32.dll' name 'glGetInteger64i_v';
    public static procedure GetInteger64i_v(target: BufferBindType; index: UInt32; var data: Vec2i64);
    external 'opengl32.dll' name 'glGetInteger64i_v';
    public static procedure GetInteger64i_v(target: GLGetQueries; index: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetInteger64i_v';
	  
    public static procedure GetDoublei_v(target: GLGetQueries; index: UInt32; [MarshalAs(UnmanagedType.LPArray)] data: array of double);
    external 'opengl32.dll' name 'glGetDoublei_v';
    public static procedure GetDoublei_v(target: GLGetQueries; index: UInt32; var data: double);
    external 'opengl32.dll' name 'glGetDoublei_v';
    public static procedure GetDoublei_v(target: GLGetQueries; index: UInt32; data: pointer);
    external 'opengl32.dll' name 'glGetDoublei_v';
    
    public static function IsEnabled(cap: EnablableName): boolean;
    external 'opengl32.dll' name 'glIsEnabled';
    
    public static function IsEnabledi(target: EnablableName; index: UInt32): boolean;
    external 'opengl32.dll' name 'glIsEnabledi';
    
    {$endregion 22.1 - Simple Queries}
    
    {$region 22.2 - Pointer, String, and Related Context Queries}
    
    public static procedure GetPointerv(pname: GLGetQueries; [MarshalAs(UnmanagedType.LPArray)] &params: array of IntPtr);
    external 'opengl32.dll' name 'glGetPointerv';
    public static procedure GetPointerv(pname: GLGetQueries; var &params: IntPtr);
    external 'opengl32.dll' name 'glGetPointerv';
    public static procedure GetPointerv(pname: GLGetQueries; var &params: pointer);
    external 'opengl32.dll' name 'glGetPointerv';
    public static procedure GetPointerv(pname: GLGetQueries; &params: ^IntPtr);
    external 'opengl32.dll' name 'glGetPointerv';
    
    public [Result: MarshalAs(UnmanagedType.LPStr)] static function GetString(name: GLGetStringQueries): string;
    external 'opengl32.dll' name 'glGetString';
    public static function GetStringPtr(name: GLGetStringQueries): IntPtr;
    external 'opengl32.dll' name 'glGetString';
    
    public [Result: MarshalAs(UnmanagedType.LPStr)] static function GetStringi(name: GLGetStringQueries; index: UInt32): string;
    external 'opengl32.dll' name 'glGetStringi';
    public static function GetStringiPtr(name: GLGetStringQueries; index: UInt32): IntPtr;
    external 'opengl32.dll' name 'glGetStringi';
    
    {$endregion 22.2 - Pointer, String, and Related Context Queries}
    
    {$region 22.3 - Internal Format Queries}
    
    public static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: Int32);
    external 'opengl32.dll' name 'glGetInternalformativ';
    public static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int32);
    external 'opengl32.dll' name 'glGetInternalformativ';
    public static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: SupportLevel);
    external 'opengl32.dll' name 'glGetInternalformativ';
    public static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: DataFormat);
    external 'opengl32.dll' name 'glGetInternalformativ';
    public static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: DataType);
    external 'opengl32.dll' name 'glGetInternalformativ';
    public static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: CompatibilityImageClassType);
    external 'opengl32.dll' name 'glGetInternalformativ';
    public static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: ImageFormatCompatibilityMode);
    external 'opengl32.dll' name 'glGetInternalformativ';
    public static procedure GetInternalformativ(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetInternalformativ';
    
    public static procedure GetInternalformati64v(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; [MarshalAs(UnmanagedType.LPArray)] &params: array of Int64);
    external 'opengl32.dll' name 'glGetInternalformati64v';
    public static procedure GetInternalformati64v(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; var &params: Int64);
    external 'opengl32.dll' name 'glGetInternalformati64v';
    public static procedure GetInternalformati64v(target: TextureBindTarget; internalformat: InternalDataFormat; pname: InternalFormatInfoType; bufSize: Int32; &params: pointer);
    external 'opengl32.dll' name 'glGetInternalformati64v';
    
    {$endregion 22.3 - Internal Format Queries}
    
    {$region 22.4 - Transform Feedback State Queries}
    
    public static procedure GetTransformFeedbackiv(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; var param: BufferName);
    external 'opengl32.dll' name 'glGetTransformFeedbackiv';
    public static procedure GetTransformFeedbackiv(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; var param: Int32);
    external 'opengl32.dll' name 'glGetTransformFeedbackiv';
    public static procedure GetTransformFeedbackiv(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; param: pointer);
    external 'opengl32.dll' name 'glGetTransformFeedbackiv';
    
    public static procedure GetTransformFeedbacki_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; var param: BufferName);
    external 'opengl32.dll' name 'glGetTransformFeedbacki_v';
    public static procedure GetTransformFeedbacki_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; var param: Int32);
    external 'opengl32.dll' name 'glGetTransformFeedbacki_v';
    public static procedure GetTransformFeedbacki_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; param: pointer);
    external 'opengl32.dll' name 'glGetTransformFeedbacki_v';
    
    public static procedure GetTransformFeedbacki64_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; var param: Int64);
    external 'opengl32.dll' name 'glGetTransformFeedbacki64_v';
    public static procedure GetTransformFeedbacki64_v(xfb: TransformFeedbackName; pname: TransformFeedbackInfoType; index: UInt32; param: pointer);
    external 'opengl32.dll' name 'glGetTransformFeedbacki64_v';
    
    {$endregion 22.4 - Transform Feedback State Queries}
    
    {$endregion 22.0 - Context State Queries}
    
  end;
  
  {$region Auto translated}
  
  gl_Deprecated = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region Unsorted}
    
    public z_Begin: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glBegin'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure &Begin(mode: DummyEnum) := z_Begin(mode);
    
    public z_Bitmap: procedure(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; _bitmap: pointer) := FuncPtrOrNil&<procedure(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; _bitmap: pointer)>(GetGLProcAdr('glBitmap'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; _bitmap: array of Byte) := Bitmap(width, height, xorig, yorig, xmove, ymove, _bitmap[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; var _bitmap: Byte) := Bitmap(width, height, xorig, yorig, xmove, ymove, @_bitmap);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Bitmap(width: Int32; height: Int32; xorig: single; yorig: single; xmove: single; ymove: single; _bitmap: pointer) := z_Bitmap(width, height, xorig, yorig, xmove, ymove, _bitmap);
    
    public z_CallLists: procedure(n: Int32; &type: DummyEnum; lists: pointer) := FuncPtrOrNil&<procedure(n: Int32; &type: DummyEnum; lists: pointer)>(GetGLProcAdr('glCallLists'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallLists(n: Int32; &type: DummyEnum; lists: pointer) := z_CallLists(n, &type, lists);
    
    public z_ClientActiveTexture: procedure(texture: DummyEnum) := FuncPtrOrNil&<procedure(texture: DummyEnum)>(GetGLProcAdr('glClientActiveTexture'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveTexture(texture: DummyEnum) := z_ClientActiveTexture(texture);
    
    public z_Color4f: procedure(red: single; green: single; blue: single; alpha: single) := FuncPtrOrNil&<procedure(red: single; green: single; blue: single; alpha: single)>(GetGLProcAdr('glColor4f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4f(red: single; green: single; blue: single; alpha: single) := z_Color4f(red, green, blue, alpha);
    
    public z_Color4fv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glColor4fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(v: array of single) := Color4fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(var v: single) := Color4fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fv(v: pointer) := z_Color4fv(v);
    
    public z_Color4ub: procedure(red: Byte; green: Byte; blue: Byte; alpha: Byte) := FuncPtrOrNil&<procedure(red: Byte; green: Byte; blue: Byte; alpha: Byte)>(GetGLProcAdr('glColor4ub'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ub(red: Byte; green: Byte; blue: Byte; alpha: Byte) := z_Color4ub(red, green, blue, alpha);
    
    public z_CopyPixels: procedure(x: Int32; y: Int32; width: Int32; height: Int32; &type: DummyEnum) := FuncPtrOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32; &type: DummyEnum)>(GetGLProcAdr('glCopyPixels'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyPixels(x: Int32; y: Int32; width: Int32; height: Int32; &type: DummyEnum) := z_CopyPixels(x, y, width, height, &type);
    
    public z_DisableClientState: procedure(&array: DummyEnum) := FuncPtrOrNil&<procedure(&array: DummyEnum)>(GetGLProcAdr('glDisableClientState'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientState(&array: DummyEnum) := z_DisableClientState(&array);
    
    public z_DrawPixels: procedure(width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glDrawPixels'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawPixels(width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_DrawPixels(width, height, format, &type, pixels);
    
    public z_EnableClientState: procedure(&array: DummyEnum) := FuncPtrOrNil&<procedure(&array: DummyEnum)>(GetGLProcAdr('glEnableClientState'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientState(&array: DummyEnum) := z_EnableClientState(&array);
    
    public z_End: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glEnd'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure &End := z_End();
    
    public z_EndList: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glEndList'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndList := z_EndList();
    
    public z_Fogf: procedure(pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: single)>(GetGLProcAdr('glFogf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogf(pname: DummyEnum; param: single) := z_Fogf(pname, param);
    
    public z_Fogfv: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glFogfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: DummyEnum; &params: array of single) := Fogfv(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: DummyEnum; var &params: single) := Fogfv(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Fogfv(pname: DummyEnum; &params: pointer) := z_Fogfv(pname, &params);
    
    public z_GenLists: function(range: Int32): UInt32 := FuncPtrOrNil&<function(range: Int32): UInt32>(GetGLProcAdr('glGenLists'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenLists(range: Int32): UInt32 := z_GenLists(range);
    
    public z_GetLightfv: procedure(light: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetLightfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightfv(light: DummyEnum; pname: DummyEnum; &params: array of single) := GetLightfv(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightfv(light: DummyEnum; pname: DummyEnum; var &params: single) := GetLightfv(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightfv(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetLightfv(light, pname, &params);
    
    public z_GetLightxv: procedure(light: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetLightxv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxv(light: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetLightxv(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxv(light: DummyEnum; pname: DummyEnum; var &params: fixed) := GetLightxv(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxv(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetLightxv(light, pname, &params);
    
    public z_GetMaterialfv: procedure(face: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMaterialfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialfv(face: DummyEnum; pname: DummyEnum; &params: array of single) := GetMaterialfv(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialfv(face: DummyEnum; pname: DummyEnum; var &params: single) := GetMaterialfv(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialfv(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMaterialfv(face, pname, &params);
    
    public z_GetMaterialxv: procedure(face: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMaterialxv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialxv(face: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetMaterialxv(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialxv(face: DummyEnum; pname: DummyEnum; var &params: fixed) := GetMaterialxv(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialxv(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMaterialxv(face, pname, &params);
    
    public z_GetnColorTable: procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; bufSize: Int32; table: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; bufSize: Int32; table: pointer)>(GetGLProcAdr('glGetnColorTable'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnColorTable(target: DummyEnum; format: DummyEnum; &type: DummyEnum; bufSize: Int32; table: pointer) := z_GetnColorTable(target, format, &type, bufSize, table);
    
    public z_GetnConvolutionFilter: procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; bufSize: Int32; image: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; bufSize: Int32; image: pointer)>(GetGLProcAdr('glGetnConvolutionFilter'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnConvolutionFilter(target: DummyEnum; format: DummyEnum; &type: DummyEnum; bufSize: Int32; image: pointer) := z_GetnConvolutionFilter(target, format, &type, bufSize, image);
    
    public z_GetnHistogram: procedure(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; bufSize: Int32; values: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; bufSize: Int32; values: pointer)>(GetGLProcAdr('glGetnHistogram'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnHistogram(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; bufSize: Int32; values: pointer) := z_GetnHistogram(target, reset, format, &type, bufSize, values);
    
    public z_GetnMapdv: procedure(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer)>(GetGLProcAdr('glGetnMapdv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdv(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: array of double) := GetnMapdv(target, query, bufSize, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdv(target: DummyEnum; query: DummyEnum; bufSize: Int32; var v: double) := GetnMapdv(target, query, bufSize, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapdv(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer) := z_GetnMapdv(target, query, bufSize, v);
    
    public z_GetnMapfv: procedure(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer)>(GetGLProcAdr('glGetnMapfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfv(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: array of single) := GetnMapfv(target, query, bufSize, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfv(target: DummyEnum; query: DummyEnum; bufSize: Int32; var v: single) := GetnMapfv(target, query, bufSize, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapfv(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer) := z_GetnMapfv(target, query, bufSize, v);
    
    public z_GetnMapiv: procedure(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer)>(GetGLProcAdr('glGetnMapiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapiv(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: array of Int32) := GetnMapiv(target, query, bufSize, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapiv(target: DummyEnum; query: DummyEnum; bufSize: Int32; var v: Int32) := GetnMapiv(target, query, bufSize, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMapiv(target: DummyEnum; query: DummyEnum; bufSize: Int32; v: pointer) := z_GetnMapiv(target, query, bufSize, v);
    
    public z_GetnMinmax: procedure(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; bufSize: Int32; values: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; bufSize: Int32; values: pointer)>(GetGLProcAdr('glGetnMinmax'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnMinmax(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; bufSize: Int32; values: pointer) := z_GetnMinmax(target, reset, format, &type, bufSize, values);
    
    public z_GetnPixelMapfv: procedure(map: DummyEnum; bufSize: Int32; values: pointer) := FuncPtrOrNil&<procedure(map: DummyEnum; bufSize: Int32; values: pointer)>(GetGLProcAdr('glGetnPixelMapfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfv(map: DummyEnum; bufSize: Int32; values: array of single) := GetnPixelMapfv(map, bufSize, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfv(map: DummyEnum; bufSize: Int32; var values: single) := GetnPixelMapfv(map, bufSize, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapfv(map: DummyEnum; bufSize: Int32; values: pointer) := z_GetnPixelMapfv(map, bufSize, values);
    
    public z_GetnPixelMapuiv: procedure(map: DummyEnum; bufSize: Int32; values: pointer) := FuncPtrOrNil&<procedure(map: DummyEnum; bufSize: Int32; values: pointer)>(GetGLProcAdr('glGetnPixelMapuiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuiv(map: DummyEnum; bufSize: Int32; values: array of UInt32) := GetnPixelMapuiv(map, bufSize, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuiv(map: DummyEnum; bufSize: Int32; var values: UInt32) := GetnPixelMapuiv(map, bufSize, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapuiv(map: DummyEnum; bufSize: Int32; values: pointer) := z_GetnPixelMapuiv(map, bufSize, values);
    
    public z_GetnPixelMapusv: procedure(map: DummyEnum; bufSize: Int32; values: pointer) := FuncPtrOrNil&<procedure(map: DummyEnum; bufSize: Int32; values: pointer)>(GetGLProcAdr('glGetnPixelMapusv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusv(map: DummyEnum; bufSize: Int32; values: array of UInt16) := GetnPixelMapusv(map, bufSize, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusv(map: DummyEnum; bufSize: Int32; var values: UInt16) := GetnPixelMapusv(map, bufSize, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPixelMapusv(map: DummyEnum; bufSize: Int32; values: pointer) := z_GetnPixelMapusv(map, bufSize, values);
    
    public z_GetnPolygonStipple: procedure(bufSize: Int32; pattern: pointer) := FuncPtrOrNil&<procedure(bufSize: Int32; pattern: pointer)>(GetGLProcAdr('glGetnPolygonStipple'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStipple(bufSize: Int32; pattern: array of Byte) := GetnPolygonStipple(bufSize, pattern[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStipple(bufSize: Int32; var pattern: Byte) := GetnPolygonStipple(bufSize, @pattern);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnPolygonStipple(bufSize: Int32; pattern: pointer) := z_GetnPolygonStipple(bufSize, pattern);
    
    public z_GetnSeparableFilter: procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; rowBufSize: Int32; row: pointer; columnBufSize: Int32; column: pointer; span: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; rowBufSize: Int32; row: pointer; columnBufSize: Int32; column: pointer; span: pointer)>(GetGLProcAdr('glGetnSeparableFilter'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnSeparableFilter(target: DummyEnum; format: DummyEnum; &type: DummyEnum; rowBufSize: Int32; row: pointer; columnBufSize: Int32; column: pointer; span: pointer) := z_GetnSeparableFilter(target, format, &type, rowBufSize, row, columnBufSize, column, span);
    
    public z_GetPixelMapxv: procedure(map: DummyEnum; size: Int32; values: pointer) := FuncPtrOrNil&<procedure(map: DummyEnum; size: Int32; values: pointer)>(GetGLProcAdr('glGetPixelMapxv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapxv(map: DummyEnum; size: Int32; values: array of fixed) := GetPixelMapxv(map, size, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapxv(map: DummyEnum; size: Int32; var values: fixed) := GetPixelMapxv(map, size, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelMapxv(map: DummyEnum; size: Int32; values: pointer) := z_GetPixelMapxv(map, size, values);
    
    public z_GetPolygonStipple: procedure(mask: pointer) := FuncPtrOrNil&<procedure(mask: pointer)>(GetGLProcAdr('glGetPolygonStipple'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPolygonStipple(mask: array of Byte) := GetPolygonStipple(mask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPolygonStipple(var mask: Byte) := GetPolygonStipple(@mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPolygonStipple(mask: pointer) := z_GetPolygonStipple(mask);
    
    public z_GetTexEnvfv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetTexEnvfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetTexEnvfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvfv(target: DummyEnum; pname: DummyEnum; var &params: single) := GetTexEnvfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexEnvfv(target, pname, &params);
    
    public z_GetTexEnviv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetTexEnviv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnviv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetTexEnviv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnviv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetTexEnviv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnviv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexEnviv(target, pname, &params);
    
    public z_Lightf: procedure(light: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glLightf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightf(light: DummyEnum; pname: DummyEnum; param: single) := z_Lightf(light, pname, param);
    
    public z_Lightfv: procedure(light: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glLightfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: DummyEnum; pname: DummyEnum; &params: array of single) := Lightfv(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: DummyEnum; pname: DummyEnum; var &params: single) := Lightfv(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Lightfv(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_Lightfv(light, pname, &params);
    
    public z_LightModelf: procedure(pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: single)>(GetGLProcAdr('glLightModelf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelf(pname: DummyEnum; param: single) := z_LightModelf(pname, param);
    
    public z_LightModelfv: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glLightModelfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: DummyEnum; &params: array of single) := LightModelfv(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: DummyEnum; var &params: single) := LightModelfv(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelfv(pname: DummyEnum; &params: pointer) := z_LightModelfv(pname, &params);
    
    public z_LineStipple: procedure(factor: Int32; pattern: UInt16) := FuncPtrOrNil&<procedure(factor: Int32; pattern: UInt16)>(GetGLProcAdr('glLineStipple'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineStipple(factor: Int32; pattern: UInt16) := z_LineStipple(factor, pattern);
    
    public z_ListBase: procedure(base: UInt32) := FuncPtrOrNil&<procedure(base: UInt32)>(GetGLProcAdr('glListBase'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListBase(base: UInt32) := z_ListBase(base);
    
    public z_LoadIdentity: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glLoadIdentity'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadIdentity := z_LoadIdentity();
    
    public z_LoadMatrixf: procedure(m: pointer) := FuncPtrOrNil&<procedure(m: pointer)>(GetGLProcAdr('glLoadMatrixf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(m: array of single) := LoadMatrixf(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(var m: single) := LoadMatrixf(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixf(m: pointer) := z_LoadMatrixf(m);
    
    public z_Materialf: procedure(face: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glMaterialf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialf(face: DummyEnum; pname: DummyEnum; param: single) := z_Materialf(face, pname, param);
    
    public z_Materialfv: procedure(face: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMaterialfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: DummyEnum; pname: DummyEnum; &params: array of single) := Materialfv(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: DummyEnum; pname: DummyEnum; var &params: single) := Materialfv(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Materialfv(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_Materialfv(face, pname, &params);
    
    public z_MatrixMode: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glMatrixMode'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMode(mode: DummyEnum) := z_MatrixMode(mode);
    
    public z_MultMatrixf: procedure(m: pointer) := FuncPtrOrNil&<procedure(m: pointer)>(GetGLProcAdr('glMultMatrixf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(m: array of single) := MultMatrixf(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(var m: single) := MultMatrixf(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixf(m: pointer) := z_MultMatrixf(m);
    
    public z_NewList: procedure(list: UInt32; mode: DummyEnum) := FuncPtrOrNil&<procedure(list: UInt32; mode: DummyEnum)>(GetGLProcAdr('glNewList'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NewList(list: UInt32; mode: DummyEnum) := z_NewList(list, mode);
    
    public z_Normal3f: procedure(nx: single; ny: single; nz: single) := FuncPtrOrNil&<procedure(nx: single; ny: single; nz: single)>(GetGLProcAdr('glNormal3f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3f(nx: single; ny: single; nz: single) := z_Normal3f(nx, ny, nz);
    
    public z_Normal3fv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glNormal3fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(v: array of single) := Normal3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(var v: single) := Normal3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fv(v: pointer) := z_Normal3fv(v);
    
    public z_PixelMapx: procedure(map: DummyEnum; size: Int32; values: pointer) := FuncPtrOrNil&<procedure(map: DummyEnum; size: Int32; values: pointer)>(GetGLProcAdr('glPixelMapx'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapx(map: DummyEnum; size: Int32; values: array of fixed) := PixelMapx(map, size, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapx(map: DummyEnum; size: Int32; var values: fixed) := PixelMapx(map, size, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelMapx(map: DummyEnum; size: Int32; values: pointer) := z_PixelMapx(map, size, values);
    
    public z_PixelStorex: procedure(pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: fixed)>(GetGLProcAdr('glPixelStorex'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelStorex(pname: DummyEnum; param: fixed) := z_PixelStorex(pname, param);
    
    public z_PointParameterx: procedure(pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: fixed)>(GetGLProcAdr('glPointParameterx'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterx(pname: DummyEnum; param: fixed) := z_PointParameterx(pname, param);
    
    public z_PolygonStipple: procedure(mask: pointer) := FuncPtrOrNil&<procedure(mask: pointer)>(GetGLProcAdr('glPolygonStipple'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(mask: array of Byte) := PolygonStipple(mask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(var mask: Byte) := PolygonStipple(@mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonStipple(mask: pointer) := z_PolygonStipple(mask);
    
    public z_PopMatrix: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glPopMatrix'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopMatrix := z_PopMatrix();
    
    public z_PushMatrix: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glPushMatrix'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushMatrix := z_PushMatrix();
    
    public z_RasterPos3f: procedure(x: single; y: single; z: single) := FuncPtrOrNil&<procedure(x: single; y: single; z: single)>(GetGLProcAdr('glRasterPos3f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3f(x: single; y: single; z: single) := z_RasterPos3f(x, y, z);
    
    public z_Rotatef: procedure(angle: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(angle: single; x: single; y: single; z: single)>(GetGLProcAdr('glRotatef'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Rotatef(angle: single; x: single; y: single; z: single) := z_Rotatef(angle, x, y, z);
    
    public z_Scalef: procedure(x: single; y: single; z: single) := FuncPtrOrNil&<procedure(x: single; y: single; z: single)>(GetGLProcAdr('glScalef'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Scalef(x: single; y: single; z: single) := z_Scalef(x, y, z);
    
    public z_ShadeModel: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glShadeModel'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadeModel(mode: DummyEnum) := z_ShadeModel(mode);
    
    public z_TexEnvf: procedure(target: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glTexEnvf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvf(target: DummyEnum; pname: DummyEnum; param: single) := z_TexEnvf(target, pname, param);
    
    public z_TexEnvfv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glTexEnvfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := TexEnvfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: DummyEnum; pname: DummyEnum; var &params: single) := TexEnvfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexEnvfv(target, pname, &params);
    
    public z_TexEnvi: procedure(target: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glTexEnvi'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvi(target: DummyEnum; pname: DummyEnum; param: Int32) := z_TexEnvi(target, pname, param);
    
    public z_TexEnviv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glTexEnviv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := TexEnviv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := TexEnviv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnviv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexEnviv(target, pname, &params);
    
    public z_Translatef: procedure(x: single; y: single; z: single) := FuncPtrOrNil&<procedure(x: single; y: single; z: single)>(GetGLProcAdr('glTranslatef'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Translatef(x: single; y: single; z: single) := z_Translatef(x, y, z);
    
    public z_Vertex2f: procedure(x: single; y: single) := FuncPtrOrNil&<procedure(x: single; y: single)>(GetGLProcAdr('glVertex2f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2f(x: single; y: single) := z_Vertex2f(x, y);
    
    public z_Vertex2fv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glVertex2fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(v: array of single) := Vertex2fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(var v: single) := Vertex2fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2fv(v: pointer) := z_Vertex2fv(v);
    
    public z_Vertex3f: procedure(x: single; y: single; z: single) := FuncPtrOrNil&<procedure(x: single; y: single; z: single)>(GetGLProcAdr('glVertex3f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3f(x: single; y: single; z: single) := z_Vertex3f(x, y, z);
    
    public z_Vertex3fv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glVertex3fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(v: array of single) := Vertex3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(var v: single) := Vertex3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3fv(v: pointer) := z_Vertex3fv(v);
    
    {$endregion Unsorted}
    
    {$region 3DFX_tbuffer}
    
    public z_TbufferMask3DFX: procedure(mask: UInt32) := FuncPtrOrNil&<procedure(mask: UInt32)>(GetGLProcAdr('glTbufferMask3DFX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TbufferMask3DFX(mask: UInt32) := z_TbufferMask3DFX(mask);
    
    {$endregion 3DFX_tbuffer}
    
    {$region ARB_transpose_matrix}
    
    public z_LoadTransposeMatrixf: procedure(m: pointer) := FuncPtrOrNil&<procedure(m: pointer)>(GetGLProcAdr('glLoadTransposeMatrixf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(m: array of single) := LoadTransposeMatrixf(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(var m: single) := LoadTransposeMatrixf(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixf(m: pointer) := z_LoadTransposeMatrixf(m);
    
    public z_LoadTransposeMatrixd: procedure(m: pointer) := FuncPtrOrNil&<procedure(m: pointer)>(GetGLProcAdr('glLoadTransposeMatrixd'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(m: array of double) := LoadTransposeMatrixd(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(var m: double) := LoadTransposeMatrixd(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixd(m: pointer) := z_LoadTransposeMatrixd(m);
    
    public z_MultTransposeMatrixf: procedure(m: pointer) := FuncPtrOrNil&<procedure(m: pointer)>(GetGLProcAdr('glMultTransposeMatrixf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(m: array of single) := MultTransposeMatrixf(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(var m: single) := MultTransposeMatrixf(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixf(m: pointer) := z_MultTransposeMatrixf(m);
    
    public z_MultTransposeMatrixd: procedure(m: pointer) := FuncPtrOrNil&<procedure(m: pointer)>(GetGLProcAdr('glMultTransposeMatrixd'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(m: array of double) := MultTransposeMatrixd(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(var m: double) := MultTransposeMatrixd(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixd(m: pointer) := z_MultTransposeMatrixd(m);
    
    {$endregion ARB_transpose_matrix}
    
    {$region ARB_vertex_type_2_10_10_10_rev}
    
    public z_VertexP2ui: procedure(&type: DummyEnum; value: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; value: UInt32)>(GetGLProcAdr('glVertexP2ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2ui(&type: DummyEnum; value: UInt32) := z_VertexP2ui(&type, value);
    
    public z_VertexP3ui: procedure(&type: DummyEnum; value: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; value: UInt32)>(GetGLProcAdr('glVertexP3ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3ui(&type: DummyEnum; value: UInt32) := z_VertexP3ui(&type, value);
    
    public z_VertexP4ui: procedure(&type: DummyEnum; value: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; value: UInt32)>(GetGLProcAdr('glVertexP4ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4ui(&type: DummyEnum; value: UInt32) := z_VertexP4ui(&type, value);
    
    public z_VertexP2uiv: procedure(&type: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; value: pointer)>(GetGLProcAdr('glVertexP2uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: DummyEnum; value: array of UInt32) := VertexP2uiv(&type, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: DummyEnum; var value: UInt32) := VertexP2uiv(&type, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP2uiv(&type: DummyEnum; value: pointer) := z_VertexP2uiv(&type, value);
    
    public z_VertexP3uiv: procedure(&type: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; value: pointer)>(GetGLProcAdr('glVertexP3uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: DummyEnum; value: array of UInt32) := VertexP3uiv(&type, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: DummyEnum; var value: UInt32) := VertexP3uiv(&type, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP3uiv(&type: DummyEnum; value: pointer) := z_VertexP3uiv(&type, value);
    
    public z_VertexP4uiv: procedure(&type: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; value: pointer)>(GetGLProcAdr('glVertexP4uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: DummyEnum; value: array of UInt32) := VertexP4uiv(&type, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: DummyEnum; var value: UInt32) := VertexP4uiv(&type, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexP4uiv(&type: DummyEnum; value: pointer) := z_VertexP4uiv(&type, value);
    
    public z_TexCoordP1ui: procedure(&type: DummyEnum; coords: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; coords: UInt32)>(GetGLProcAdr('glTexCoordP1ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1ui(&type: DummyEnum; coords: UInt32) := z_TexCoordP1ui(&type, coords);
    
    public z_TexCoordP2ui: procedure(&type: DummyEnum; coords: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; coords: UInt32)>(GetGLProcAdr('glTexCoordP2ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2ui(&type: DummyEnum; coords: UInt32) := z_TexCoordP2ui(&type, coords);
    
    public z_TexCoordP3ui: procedure(&type: DummyEnum; coords: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; coords: UInt32)>(GetGLProcAdr('glTexCoordP3ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3ui(&type: DummyEnum; coords: UInt32) := z_TexCoordP3ui(&type, coords);
    
    public z_TexCoordP4ui: procedure(&type: DummyEnum; coords: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; coords: UInt32)>(GetGLProcAdr('glTexCoordP4ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4ui(&type: DummyEnum; coords: UInt32) := z_TexCoordP4ui(&type, coords);
    
    public z_TexCoordP1uiv: procedure(&type: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; coords: pointer)>(GetGLProcAdr('glTexCoordP1uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: DummyEnum; coords: array of UInt32) := TexCoordP1uiv(&type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: DummyEnum; var coords: UInt32) := TexCoordP1uiv(&type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP1uiv(&type: DummyEnum; coords: pointer) := z_TexCoordP1uiv(&type, coords);
    
    public z_TexCoordP2uiv: procedure(&type: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; coords: pointer)>(GetGLProcAdr('glTexCoordP2uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: DummyEnum; coords: array of UInt32) := TexCoordP2uiv(&type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: DummyEnum; var coords: UInt32) := TexCoordP2uiv(&type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP2uiv(&type: DummyEnum; coords: pointer) := z_TexCoordP2uiv(&type, coords);
    
    public z_TexCoordP3uiv: procedure(&type: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; coords: pointer)>(GetGLProcAdr('glTexCoordP3uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: DummyEnum; coords: array of UInt32) := TexCoordP3uiv(&type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: DummyEnum; var coords: UInt32) := TexCoordP3uiv(&type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP3uiv(&type: DummyEnum; coords: pointer) := z_TexCoordP3uiv(&type, coords);
    
    public z_TexCoordP4uiv: procedure(&type: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; coords: pointer)>(GetGLProcAdr('glTexCoordP4uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: DummyEnum; coords: array of UInt32) := TexCoordP4uiv(&type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: DummyEnum; var coords: UInt32) := TexCoordP4uiv(&type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordP4uiv(&type: DummyEnum; coords: pointer) := z_TexCoordP4uiv(&type, coords);
    
    public z_MultiTexCoordP1ui: procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := FuncPtrOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32)>(GetGLProcAdr('glMultiTexCoordP1ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1ui(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := z_MultiTexCoordP1ui(texture, &type, coords);
    
    public z_MultiTexCoordP2ui: procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := FuncPtrOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32)>(GetGLProcAdr('glMultiTexCoordP2ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2ui(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := z_MultiTexCoordP2ui(texture, &type, coords);
    
    public z_MultiTexCoordP3ui: procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := FuncPtrOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32)>(GetGLProcAdr('glMultiTexCoordP3ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3ui(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := z_MultiTexCoordP3ui(texture, &type, coords);
    
    public z_MultiTexCoordP4ui: procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := FuncPtrOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: UInt32)>(GetGLProcAdr('glMultiTexCoordP4ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4ui(texture: DummyEnum; &type: DummyEnum; coords: UInt32) := z_MultiTexCoordP4ui(texture, &type, coords);
    
    public z_MultiTexCoordP1uiv: procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoordP1uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: DummyEnum; &type: DummyEnum; coords: array of UInt32) := MultiTexCoordP1uiv(texture, &type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: DummyEnum; &type: DummyEnum; var coords: UInt32) := MultiTexCoordP1uiv(texture, &type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP1uiv(texture: DummyEnum; &type: DummyEnum; coords: pointer) := z_MultiTexCoordP1uiv(texture, &type, coords);
    
    public z_MultiTexCoordP2uiv: procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoordP2uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: DummyEnum; &type: DummyEnum; coords: array of UInt32) := MultiTexCoordP2uiv(texture, &type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: DummyEnum; &type: DummyEnum; var coords: UInt32) := MultiTexCoordP2uiv(texture, &type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP2uiv(texture: DummyEnum; &type: DummyEnum; coords: pointer) := z_MultiTexCoordP2uiv(texture, &type, coords);
    
    public z_MultiTexCoordP3uiv: procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoordP3uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: DummyEnum; &type: DummyEnum; coords: array of UInt32) := MultiTexCoordP3uiv(texture, &type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: DummyEnum; &type: DummyEnum; var coords: UInt32) := MultiTexCoordP3uiv(texture, &type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP3uiv(texture: DummyEnum; &type: DummyEnum; coords: pointer) := z_MultiTexCoordP3uiv(texture, &type, coords);
    
    public z_MultiTexCoordP4uiv: procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; &type: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoordP4uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: DummyEnum; &type: DummyEnum; coords: array of UInt32) := MultiTexCoordP4uiv(texture, &type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: DummyEnum; &type: DummyEnum; var coords: UInt32) := MultiTexCoordP4uiv(texture, &type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordP4uiv(texture: DummyEnum; &type: DummyEnum; coords: pointer) := z_MultiTexCoordP4uiv(texture, &type, coords);
    
    public z_NormalP3ui: procedure(&type: DummyEnum; coords: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; coords: UInt32)>(GetGLProcAdr('glNormalP3ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3ui(&type: DummyEnum; coords: UInt32) := z_NormalP3ui(&type, coords);
    
    public z_NormalP3uiv: procedure(&type: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; coords: pointer)>(GetGLProcAdr('glNormalP3uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: DummyEnum; coords: array of UInt32) := NormalP3uiv(&type, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: DummyEnum; var coords: UInt32) := NormalP3uiv(&type, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalP3uiv(&type: DummyEnum; coords: pointer) := z_NormalP3uiv(&type, coords);
    
    public z_ColorP3ui: procedure(&type: DummyEnum; color: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; color: UInt32)>(GetGLProcAdr('glColorP3ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3ui(&type: DummyEnum; color: UInt32) := z_ColorP3ui(&type, color);
    
    public z_ColorP4ui: procedure(&type: DummyEnum; color: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; color: UInt32)>(GetGLProcAdr('glColorP4ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4ui(&type: DummyEnum; color: UInt32) := z_ColorP4ui(&type, color);
    
    public z_ColorP3uiv: procedure(&type: DummyEnum; color: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; color: pointer)>(GetGLProcAdr('glColorP3uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: DummyEnum; color: array of UInt32) := ColorP3uiv(&type, color[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: DummyEnum; var color: UInt32) := ColorP3uiv(&type, @color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP3uiv(&type: DummyEnum; color: pointer) := z_ColorP3uiv(&type, color);
    
    public z_ColorP4uiv: procedure(&type: DummyEnum; color: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; color: pointer)>(GetGLProcAdr('glColorP4uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: DummyEnum; color: array of UInt32) := ColorP4uiv(&type, color[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: DummyEnum; var color: UInt32) := ColorP4uiv(&type, @color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorP4uiv(&type: DummyEnum; color: pointer) := z_ColorP4uiv(&type, color);
    
    public z_SecondaryColorP3ui: procedure(&type: DummyEnum; color: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; color: UInt32)>(GetGLProcAdr('glSecondaryColorP3ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3ui(&type: DummyEnum; color: UInt32) := z_SecondaryColorP3ui(&type, color);
    
    public z_SecondaryColorP3uiv: procedure(&type: DummyEnum; color: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; color: pointer)>(GetGLProcAdr('glSecondaryColorP3uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: DummyEnum; color: array of UInt32) := SecondaryColorP3uiv(&type, color[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: DummyEnum; var color: UInt32) := SecondaryColorP3uiv(&type, @color);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorP3uiv(&type: DummyEnum; color: pointer) := z_SecondaryColorP3uiv(&type, color);
    
    {$endregion ARB_vertex_type_2_10_10_10_rev}
    
    {$region EXT_color_subtable}
    
    public z_CopyColorSubTable: procedure(target: DummyEnum; start: Int32; x: Int32; y: Int32; width: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; start: Int32; x: Int32; y: Int32; width: Int32)>(GetGLProcAdr('glCopyColorSubTable'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorSubTable(target: DummyEnum; start: Int32; x: Int32; y: Int32; width: Int32) := z_CopyColorSubTable(target, start, x, y, width);
    
    {$endregion EXT_color_subtable}
    
    {$region EXT_convolution}
    
    public z_ConvolutionFilter1D: procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; image: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; image: pointer)>(GetGLProcAdr('glConvolutionFilter1D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter1D(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; image: pointer) := z_ConvolutionFilter1D(target, internalformat, width, format, &type, image);
    
    public z_ConvolutionFilter2D: procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; image: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; image: pointer)>(GetGLProcAdr('glConvolutionFilter2D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionFilter2D(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; image: pointer) := z_ConvolutionFilter2D(target, internalformat, width, height, format, &type, image);
    
    public z_CopyConvolutionFilter1D: procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32)>(GetGLProcAdr('glCopyConvolutionFilter1D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter1D(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32) := z_CopyConvolutionFilter1D(target, internalformat, x, y, width);
    
    public z_CopyConvolutionFilter2D: procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32)>(GetGLProcAdr('glCopyConvolutionFilter2D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyConvolutionFilter2D(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyConvolutionFilter2D(target, internalformat, x, y, width, height);
    
    public z_GetConvolutionFilter: procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; image: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; image: pointer)>(GetGLProcAdr('glGetConvolutionFilter'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionFilter(target: DummyEnum; format: DummyEnum; &type: DummyEnum; image: pointer) := z_GetConvolutionFilter(target, format, &type, image);
    
    public z_SeparableFilter2D: procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer)>(GetGLProcAdr('glSeparableFilter2D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SeparableFilter2D(target: DummyEnum; internalformat: DummyEnum; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer) := z_SeparableFilter2D(target, internalformat, width, height, format, &type, row, column);
    
    public z_GetSeparableFilter: procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer; span: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer; span: pointer)>(GetGLProcAdr('glGetSeparableFilter'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSeparableFilter(target: DummyEnum; format: DummyEnum; &type: DummyEnum; row: pointer; column: pointer; span: pointer) := z_GetSeparableFilter(target, format, &type, row, column, span);
    
    public z_ConvolutionParameteri: procedure(target: DummyEnum; pname: DummyEnum; &params: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: Int32)>(GetGLProcAdr('glConvolutionParameteri'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteri(target: DummyEnum; pname: DummyEnum; &params: Int32) := z_ConvolutionParameteri(target, pname, &params);
    
    public z_ConvolutionParameteriv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glConvolutionParameteriv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := ConvolutionParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := ConvolutionParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ConvolutionParameteriv(target, pname, &params);
    
    public z_ConvolutionParameterf: procedure(target: DummyEnum; pname: DummyEnum; &params: single) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: single)>(GetGLProcAdr('glConvolutionParameterf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterf(target: DummyEnum; pname: DummyEnum; &params: single) := z_ConvolutionParameterf(target, pname, &params);
    
    public z_ConvolutionParameterfv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glConvolutionParameterfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := ConvolutionParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := ConvolutionParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ConvolutionParameterfv(target, pname, &params);
    
    public z_GetConvolutionParameteriv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetConvolutionParameteriv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetConvolutionParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetConvolutionParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetConvolutionParameteriv(target, pname, &params);
    
    public z_GetConvolutionParameterfv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetConvolutionParameterfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetConvolutionParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := GetConvolutionParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetConvolutionParameterfv(target, pname, &params);
    
    {$endregion EXT_convolution}
    
    {$region EXT_fog_coord}
    
    public z_FogCoordf: procedure(coord: single) := FuncPtrOrNil&<procedure(coord: single)>(GetGLProcAdr('glFogCoordf'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordf(coord: single) := z_FogCoordf(coord);
    
    public z_FogCoordd: procedure(coord: double) := FuncPtrOrNil&<procedure(coord: double)>(GetGLProcAdr('glFogCoordd'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordd(coord: double) := z_FogCoordd(coord);
    
    public z_FogCoordfv: procedure(coord: pointer) := FuncPtrOrNil&<procedure(coord: pointer)>(GetGLProcAdr('glFogCoordfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(coord: array of single) := FogCoordfv(coord[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(var coord: single) := FogCoordfv(@coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordfv(coord: pointer) := z_FogCoordfv(coord);
    
    public z_FogCoorddv: procedure(coord: pointer) := FuncPtrOrNil&<procedure(coord: pointer)>(GetGLProcAdr('glFogCoorddv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(coord: array of double) := FogCoorddv(coord[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(var coord: double) := FogCoorddv(@coord);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoorddv(coord: pointer) := z_FogCoorddv(coord);
    
    public z_FogCoordPointer: procedure(&type: DummyEnum; stride: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>(GetGLProcAdr('glFogCoordPointer'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointer(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_FogCoordPointer(&type, stride, _pointer);
    
    {$endregion EXT_fog_coord}
    
    {$region EXT_histogram}
    
    public z_Histogram: procedure(target: DummyEnum; width: Int32; internalformat: DummyEnum; sink: Byte) := FuncPtrOrNil&<procedure(target: DummyEnum; width: Int32; internalformat: DummyEnum; sink: Byte)>(GetGLProcAdr('glHistogram'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Histogram(target: DummyEnum; width: Int32; internalformat: DummyEnum; sink: Byte) := z_Histogram(target, width, internalformat, sink);
    
    public z_ResetHistogram: procedure(target: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum)>(GetGLProcAdr('glResetHistogram'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetHistogram(target: DummyEnum) := z_ResetHistogram(target);
    
    public z_GetHistogram: procedure(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; values: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; values: pointer)>(GetGLProcAdr('glGetHistogram'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogram(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; values: pointer) := z_GetHistogram(target, reset, format, &type, values);
    
    public z_GetHistogramParameteriv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetHistogramParameteriv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetHistogramParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetHistogramParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetHistogramParameteriv(target, pname, &params);
    
    public z_GetHistogramParameterfv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetHistogramParameterfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetHistogramParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := GetHistogramParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetHistogramParameterfv(target, pname, &params);
    
    public z_Minmax: procedure(target: DummyEnum; internalformat: DummyEnum; sink: Byte) := FuncPtrOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; sink: Byte)>(GetGLProcAdr('glMinmax'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Minmax(target: DummyEnum; internalformat: DummyEnum; sink: Byte) := z_Minmax(target, internalformat, sink);
    
    public z_ResetMinmax: procedure(target: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum)>(GetGLProcAdr('glResetMinmax'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMinmax(target: DummyEnum) := z_ResetMinmax(target);
    
    public z_GetMinmax: procedure(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; values: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; values: pointer)>(GetGLProcAdr('glGetMinmax'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmax(target: DummyEnum; reset: Byte; format: DummyEnum; &type: DummyEnum; values: pointer) := z_GetMinmax(target, reset, format, &type, values);
    
    public z_GetMinmaxParameteriv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMinmaxParameteriv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMinmaxParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMinmaxParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMinmaxParameteriv(target, pname, &params);
    
    public z_GetMinmaxParameterfv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMinmaxParameterfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetMinmaxParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := GetMinmaxParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMinmaxParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMinmaxParameterfv(target, pname, &params);
    
    {$endregion EXT_histogram}
    
    {$region EXT_secondary_color}
    
    public z_SecondaryColor3b: procedure(red: SByte; green: SByte; blue: SByte) := FuncPtrOrNil&<procedure(red: SByte; green: SByte; blue: SByte)>(GetGLProcAdr('glSecondaryColor3b'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3b(red: SByte; green: SByte; blue: SByte) := z_SecondaryColor3b(red, green, blue);
    
    public z_SecondaryColor3s: procedure(red: Int16; green: Int16; blue: Int16) := FuncPtrOrNil&<procedure(red: Int16; green: Int16; blue: Int16)>(GetGLProcAdr('glSecondaryColor3s'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3s(red: Int16; green: Int16; blue: Int16) := z_SecondaryColor3s(red, green, blue);
    
    public z_SecondaryColor3i: procedure(red: Int32; green: Int32; blue: Int32) := FuncPtrOrNil&<procedure(red: Int32; green: Int32; blue: Int32)>(GetGLProcAdr('glSecondaryColor3i'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3i(red: Int32; green: Int32; blue: Int32) := z_SecondaryColor3i(red, green, blue);
    
    public z_SecondaryColor3f: procedure(red: single; green: single; blue: single) := FuncPtrOrNil&<procedure(red: single; green: single; blue: single)>(GetGLProcAdr('glSecondaryColor3f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3f(red: single; green: single; blue: single) := z_SecondaryColor3f(red, green, blue);
    
    public z_SecondaryColor3d: procedure(red: double; green: double; blue: double) := FuncPtrOrNil&<procedure(red: double; green: double; blue: double)>(GetGLProcAdr('glSecondaryColor3d'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3d(red: double; green: double; blue: double) := z_SecondaryColor3d(red, green, blue);
    
    public z_SecondaryColor3ub: procedure(red: Byte; green: Byte; blue: Byte) := FuncPtrOrNil&<procedure(red: Byte; green: Byte; blue: Byte)>(GetGLProcAdr('glSecondaryColor3ub'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ub(red: Byte; green: Byte; blue: Byte) := z_SecondaryColor3ub(red, green, blue);
    
    public z_SecondaryColor3us: procedure(red: UInt16; green: UInt16; blue: UInt16) := FuncPtrOrNil&<procedure(red: UInt16; green: UInt16; blue: UInt16)>(GetGLProcAdr('glSecondaryColor3us'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3us(red: UInt16; green: UInt16; blue: UInt16) := z_SecondaryColor3us(red, green, blue);
    
    public z_SecondaryColor3ui: procedure(red: UInt32; green: UInt32; blue: UInt32) := FuncPtrOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32)>(GetGLProcAdr('glSecondaryColor3ui'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ui(red: UInt32; green: UInt32; blue: UInt32) := z_SecondaryColor3ui(red, green, blue);
    
    public z_SecondaryColor3bv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glSecondaryColor3bv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(v: array of SByte) := SecondaryColor3bv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(var v: SByte) := SecondaryColor3bv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3bv(v: pointer) := z_SecondaryColor3bv(v);
    
    public z_SecondaryColor3sv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glSecondaryColor3sv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(v: array of Int16) := SecondaryColor3sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(var v: Int16) := SecondaryColor3sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3sv(v: pointer) := z_SecondaryColor3sv(v);
    
    public z_SecondaryColor3iv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glSecondaryColor3iv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(v: array of Int32) := SecondaryColor3iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(var v: Int32) := SecondaryColor3iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3iv(v: pointer) := z_SecondaryColor3iv(v);
    
    public z_SecondaryColor3fv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glSecondaryColor3fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(v: array of single) := SecondaryColor3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(var v: single) := SecondaryColor3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3fv(v: pointer) := z_SecondaryColor3fv(v);
    
    public z_SecondaryColor3dv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glSecondaryColor3dv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(v: array of double) := SecondaryColor3dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(var v: double) := SecondaryColor3dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3dv(v: pointer) := z_SecondaryColor3dv(v);
    
    public z_SecondaryColor3ubv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glSecondaryColor3ubv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(v: array of Byte) := SecondaryColor3ubv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(var v: Byte) := SecondaryColor3ubv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3ubv(v: pointer) := z_SecondaryColor3ubv(v);
    
    public z_SecondaryColor3usv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glSecondaryColor3usv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(v: array of UInt16) := SecondaryColor3usv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(var v: UInt16) := SecondaryColor3usv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3usv(v: pointer) := z_SecondaryColor3usv(v);
    
    public z_SecondaryColor3uiv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glSecondaryColor3uiv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(v: array of UInt32) := SecondaryColor3uiv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(var v: UInt32) := SecondaryColor3uiv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3uiv(v: pointer) := z_SecondaryColor3uiv(v);
    
    public z_SecondaryColorPointer: procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>(GetGLProcAdr('glSecondaryColorPointer'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointer(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_SecondaryColorPointer(size, &type, stride, _pointer);
    
    {$endregion EXT_secondary_color}
    
    {$region QCOM_alpha_test}
    
    public z_AlphaFunc: procedure(func: DummyEnum; ref: single) := FuncPtrOrNil&<procedure(func: DummyEnum; ref: single)>(GetGLProcAdr('glAlphaFunc'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFunc(func: DummyEnum; ref: single) := z_AlphaFunc(func, ref);
    
    {$endregion QCOM_alpha_test}
    
    {$region SGI_color_table}
    
    public z_CopyColorTable: procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32)>(GetGLProcAdr('glCopyColorTable'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyColorTable(target: DummyEnum; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32) := z_CopyColorTable(target, internalformat, x, y, width);
    
    public z_ColorTableParameteriv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glColorTableParameteriv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := ColorTableParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := ColorTableParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ColorTableParameteriv(target, pname, &params);
    
    public z_ColorTableParameterfv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glColorTableParameterfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := ColorTableParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := ColorTableParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTableParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ColorTableParameterfv(target, pname, &params);
    
    {$endregion SGI_color_table}
    
    {$region ARB_window_pos, MESA_window_pos}
    
    public z_WindowPos2d: procedure(x: double; y: double) := FuncPtrOrNil&<procedure(x: double; y: double)>(GetGLProcAdr('glWindowPos2d'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2d(x: double; y: double) := z_WindowPos2d(x, y);
    
    public z_WindowPos2f: procedure(x: single; y: single) := FuncPtrOrNil&<procedure(x: single; y: single)>(GetGLProcAdr('glWindowPos2f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2f(x: single; y: single) := z_WindowPos2f(x, y);
    
    public z_WindowPos2i: procedure(x: Int32; y: Int32) := FuncPtrOrNil&<procedure(x: Int32; y: Int32)>(GetGLProcAdr('glWindowPos2i'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2i(x: Int32; y: Int32) := z_WindowPos2i(x, y);
    
    public z_WindowPos2s: procedure(x: Int16; y: Int16) := FuncPtrOrNil&<procedure(x: Int16; y: Int16)>(GetGLProcAdr('glWindowPos2s'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2s(x: Int16; y: Int16) := z_WindowPos2s(x, y);
    
    public z_WindowPos2dv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos2dv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(v: array of double) := WindowPos2dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(var v: double) := WindowPos2dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2dv(v: pointer) := z_WindowPos2dv(v);
    
    public z_WindowPos2fv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos2fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(v: array of single) := WindowPos2fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(var v: single) := WindowPos2fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2fv(v: pointer) := z_WindowPos2fv(v);
    
    public z_WindowPos2iv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos2iv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(v: array of Int32) := WindowPos2iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(var v: Int32) := WindowPos2iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2iv(v: pointer) := z_WindowPos2iv(v);
    
    public z_WindowPos2sv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos2sv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(v: array of Int16) := WindowPos2sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(var v: Int16) := WindowPos2sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos2sv(v: pointer) := z_WindowPos2sv(v);
    
    public z_WindowPos3d: procedure(x: double; y: double; z: double) := FuncPtrOrNil&<procedure(x: double; y: double; z: double)>(GetGLProcAdr('glWindowPos3d'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3d(x: double; y: double; z: double) := z_WindowPos3d(x, y, z);
    
    public z_WindowPos3f: procedure(x: single; y: single; z: single) := FuncPtrOrNil&<procedure(x: single; y: single; z: single)>(GetGLProcAdr('glWindowPos3f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3f(x: single; y: single; z: single) := z_WindowPos3f(x, y, z);
    
    public z_WindowPos3i: procedure(x: Int32; y: Int32; z: Int32) := FuncPtrOrNil&<procedure(x: Int32; y: Int32; z: Int32)>(GetGLProcAdr('glWindowPos3i'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3i(x: Int32; y: Int32; z: Int32) := z_WindowPos3i(x, y, z);
    
    public z_WindowPos3s: procedure(x: Int16; y: Int16; z: Int16) := FuncPtrOrNil&<procedure(x: Int16; y: Int16; z: Int16)>(GetGLProcAdr('glWindowPos3s'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3s(x: Int16; y: Int16; z: Int16) := z_WindowPos3s(x, y, z);
    
    public z_WindowPos3dv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos3dv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(v: array of double) := WindowPos3dv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(var v: double) := WindowPos3dv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3dv(v: pointer) := z_WindowPos3dv(v);
    
    public z_WindowPos3fv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos3fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(v: array of single) := WindowPos3fv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(var v: single) := WindowPos3fv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3fv(v: pointer) := z_WindowPos3fv(v);
    
    public z_WindowPos3iv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos3iv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(v: array of Int32) := WindowPos3iv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(var v: Int32) := WindowPos3iv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3iv(v: pointer) := z_WindowPos3iv(v);
    
    public z_WindowPos3sv: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos3sv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(v: array of Int16) := WindowPos3sv(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(var v: Int16) := WindowPos3sv(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos3sv(v: pointer) := z_WindowPos3sv(v);
    
    {$endregion ARB_window_pos, MESA_window_pos}
    
    {$region EXT_color_subtable, EXT_paletted_texture}
    
    public z_ColorSubTable: procedure(target: DummyEnum; start: Int32; count: Int32; format: DummyEnum; &type: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; start: Int32; count: Int32; format: DummyEnum; &type: DummyEnum; data: pointer)>(GetGLProcAdr('glColorSubTable'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorSubTable(target: DummyEnum; start: Int32; count: Int32; format: DummyEnum; &type: DummyEnum; data: pointer) := z_ColorSubTable(target, start, count, format, &type, data);
    
    {$endregion EXT_color_subtable, EXT_paletted_texture}
    
    {$region EXT_paletted_texture, SGI_color_table}
    
    public z_ColorTable: procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; table: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; table: pointer)>(GetGLProcAdr('glColorTable'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorTable(target: DummyEnum; internalformat: DummyEnum; width: Int32; format: DummyEnum; &type: DummyEnum; table: pointer) := z_ColorTable(target, internalformat, width, format, &type, table);
    
    public z_GetColorTable: procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; table: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; format: DummyEnum; &type: DummyEnum; table: pointer)>(GetGLProcAdr('glGetColorTable'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTable(target: DummyEnum; format: DummyEnum; &type: DummyEnum; table: pointer) := z_GetColorTable(target, format, &type, table);
    
    public z_GetColorTableParameteriv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetColorTableParameteriv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameteriv(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetColorTableParameteriv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameteriv(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetColorTableParameteriv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameteriv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetColorTableParameteriv(target, pname, &params);
    
    public z_GetColorTableParameterfv: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetColorTableParameterfv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfv(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetColorTableParameterfv(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfv(target: DummyEnum; pname: DummyEnum; var &params: single) := GetColorTableParameterfv(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetColorTableParameterfv(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetColorTableParameterfv(target, pname, &params);
    
    {$endregion EXT_paletted_texture, SGI_color_table}
    
  end;
  
  wgl = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    public static function CreateContext(hDc: GDI_DC): GLContext;
    external 'opengl32.dll' name 'wglCreateContext';
    public static function MakeCurrent(hDc: GDI_DC; newContext: GLContext): UInt32;
    external 'opengl32.dll' name 'wglMakeCurrent';
    
    {$region Unsorted}
    
    public z_AllocateMemoryNV: function(size: Int32; readfreq: single; writefreq: single; priority: single): pointer := FuncPtrOrNil&<function(size: Int32; readfreq: single; writefreq: single; priority: single): pointer>(GetGLProcAdr('wglAllocateMemoryNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AllocateMemoryNV(size: Int32; readfreq: single; writefreq: single; priority: single): pointer := z_AllocateMemoryNV(size, readfreq, writefreq, priority);
    
    public z_BindDisplayColorTableEXT: function(id: UInt16): Byte := FuncPtrOrNil&<function(id: UInt16): Byte>(GetGLProcAdr('wglBindDisplayColorTableEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindDisplayColorTableEXT(id: UInt16): Byte := z_BindDisplayColorTableEXT(id);
    
    public z_CopyContext: function(hglrcSrc: GLContext; hglrcDst: GLContext; mask: UInt32): UInt32 := FuncPtrOrNil&<function(hglrcSrc: GLContext; hglrcDst: GLContext; mask: UInt32): UInt32>(GetGLProcAdr('wglCopyContext'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CopyContext(hglrcSrc: GLContext; hglrcDst: GLContext; mask: UInt32): UInt32 := z_CopyContext(hglrcSrc, hglrcDst, mask);
    
    public z_CopyImageSubDataNV: function(hSrcRC: GLContext; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; hDstRC: GLContext; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32): UInt32 := FuncPtrOrNil&<function(hSrcRC: GLContext; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; hDstRC: GLContext; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32): UInt32>(GetGLProcAdr('wglCopyImageSubDataNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CopyImageSubDataNV(hSrcRC: GLContext; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; hDstRC: GLContext; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32): UInt32 := z_CopyImageSubDataNV(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
    public z_CreateDisplayColorTableEXT: function(id: UInt16): Byte := FuncPtrOrNil&<function(id: UInt16): Byte>(GetGLProcAdr('wglCreateDisplayColorTableEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateDisplayColorTableEXT(id: UInt16): Byte := z_CreateDisplayColorTableEXT(id);
    
    public z_CreateLayerContext: function(hDc: GDI_DC; level: Int32): GLContext := FuncPtrOrNil&<function(hDc: GDI_DC; level: Int32): GLContext>(GetGLProcAdr('wglCreateLayerContext'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateLayerContext(hDc: GDI_DC; level: Int32): GLContext := z_CreateLayerContext(hDc, level);
    
    public z_DeleteContext: function(oldContext: GLContext): UInt32 := FuncPtrOrNil&<function(oldContext: GLContext): UInt32>(GetGLProcAdr('wglDeleteContext'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteContext(oldContext: GLContext): UInt32 := z_DeleteContext(oldContext);
    
    public z_DescribeLayerPlane: function(hDc: GDI_DC; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: pointer): UInt32 := FuncPtrOrNil&<function(hDc: GDI_DC; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: pointer): UInt32>(GetGLProcAdr('wglDescribeLayerPlane'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DescribeLayerPlane(hDc: GDI_DC; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: array of GDI_LayerPlaneDescriptor): UInt32 := DescribeLayerPlane(hDc, pixelFormat, layerPlane, nBytes, plpd[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DescribeLayerPlane(hDc: GDI_DC; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; var plpd: GDI_LayerPlaneDescriptor): UInt32 := DescribeLayerPlane(hDc, pixelFormat, layerPlane, nBytes, @plpd);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DescribeLayerPlane(hDc: GDI_DC; pixelFormat: Int32; layerPlane: Int32; nBytes: UInt32; plpd: pointer): UInt32 := z_DescribeLayerPlane(hDc, pixelFormat, layerPlane, nBytes, plpd);
    
    public z_DestroyDisplayColorTableEXT: procedure(id: UInt16) := FuncPtrOrNil&<procedure(id: UInt16)>(GetGLProcAdr('wglDestroyDisplayColorTableEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyDisplayColorTableEXT(id: UInt16) := z_DestroyDisplayColorTableEXT(id);
    
    public z_FreeMemoryNV: procedure(_pointer: pointer) := FuncPtrOrNil&<procedure(_pointer: pointer)>(GetGLProcAdr('wglFreeMemoryNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeMemoryNV(_pointer: pointer) := z_FreeMemoryNV(_pointer);
    
    public z_GetCurrentContext: function: GLContext := FuncPtrOrNil&<function: GLContext>(GetGLProcAdr('wglGetCurrentContext'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentContext: GLContext := z_GetCurrentContext();
    
    public z_GetCurrentDC: function: GDI_DC := FuncPtrOrNil&<function: GDI_DC>(GetGLProcAdr('wglGetCurrentDC'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentDC: GDI_DC := z_GetCurrentDC();
    
    public z_GetLayerPaletteEntries: function(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: pointer): Int32 := FuncPtrOrNil&<function(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: pointer): Int32>(GetGLProcAdr('wglGetLayerPaletteEntries'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: array of GDI_COLORREF): Int32 := GetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, pcr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: GDI_COLORREF): Int32 := GetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, @pcr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: pointer): Int32 := z_GetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, pcr);
    
    public z_GetProcAddress: function(lpszProc: IntPtr): IntPtr := FuncPtrOrNil&<function(lpszProc: IntPtr): IntPtr>(GetGLProcAdr('wglGetProcAddress'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddress(lpszProc: string): IntPtr; begin var ptr1 := Marshal.StringToHGlobalAnsi(lpszProc); Result := GetProcAddress(ptr1); lpszProc := Marshal.PtrToStringAnsi(ptr1); Marshal.FreeHGlobal(ptr1); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddress(lpszProc: IntPtr): IntPtr := z_GetProcAddress(lpszProc);
    
    public z_LoadDisplayColorTableEXT: function(table: pointer; length: UInt32): Byte := FuncPtrOrNil&<function(table: pointer; length: UInt32): Byte>(GetGLProcAdr('wglLoadDisplayColorTableEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LoadDisplayColorTableEXT(table: array of UInt16; length: UInt32): Byte := LoadDisplayColorTableEXT(table[0], length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LoadDisplayColorTableEXT(var table: UInt16; length: UInt32): Byte := LoadDisplayColorTableEXT(@table, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function LoadDisplayColorTableEXT(table: pointer; length: UInt32): Byte := z_LoadDisplayColorTableEXT(table, length);
    
    public z_RealizeLayerPalette: function(hdc: GDI_DC; iLayerPlane: Int32; bRealize: UInt32): UInt32 := FuncPtrOrNil&<function(hdc: GDI_DC; iLayerPlane: Int32; bRealize: UInt32): UInt32>(GetGLProcAdr('wglRealizeLayerPalette'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RealizeLayerPalette(hdc: GDI_DC; iLayerPlane: Int32; bRealize: UInt32): UInt32 := z_RealizeLayerPalette(hdc, iLayerPlane, bRealize);
    
    public z_SetLayerPaletteEntries: function(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: pointer): Int32 := FuncPtrOrNil&<function(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: pointer): Int32>(GetGLProcAdr('wglSetLayerPaletteEntries'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: array of GDI_COLORREF): Int32 := SetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, pcr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; var pcr: GDI_COLORREF): Int32 := SetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, @pcr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetLayerPaletteEntries(hdc: GDI_DC; iLayerPlane: Int32; iStart: Int32; cEntries: Int32; pcr: pointer): Int32 := z_SetLayerPaletteEntries(hdc, iLayerPlane, iStart, cEntries, pcr);
    
    public z_ShareLists: function(hrcSrvShare: GLContext; hrcSrvSource: GLContext): UInt32 := FuncPtrOrNil&<function(hrcSrvShare: GLContext; hrcSrvSource: GLContext): UInt32>(GetGLProcAdr('wglShareLists'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ShareLists(hrcSrvShare: GLContext; hrcSrvSource: GLContext): UInt32 := z_ShareLists(hrcSrvShare, hrcSrvSource);
    
    public z_SwapLayerBuffers: function(hdc: GDI_DC; fuFlags: UInt32): UInt32 := FuncPtrOrNil&<function(hdc: GDI_DC; fuFlags: UInt32): UInt32>(GetGLProcAdr('wglSwapLayerBuffers'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapLayerBuffers(hdc: GDI_DC; fuFlags: UInt32): UInt32 := z_SwapLayerBuffers(hdc, fuFlags);
    
    public z_UseFontBitmaps: function(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32): UInt32>(GetGLProcAdr('wglUseFontBitmaps'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontBitmaps(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32): UInt32 := z_UseFontBitmaps(hDC, first, count, listBase);
    
    public z_UseFontOutlines: function(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: pointer): UInt32>(GetGLProcAdr('wglUseFontOutlines'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlines(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: array of GDI_GlyphmetricsFloat): UInt32 := UseFontOutlines(hDC, first, count, listBase, deviation, extrusion, format, lpgmf[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlines(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; var lpgmf: GDI_GlyphmetricsFloat): UInt32 := UseFontOutlines(hDC, first, count, listBase, deviation, extrusion, format, @lpgmf);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function UseFontOutlines(hDC: GDI_DC; first: UInt32; count: UInt32; listBase: UInt32; deviation: single; extrusion: single; format: Int32; lpgmf: pointer): UInt32 := z_UseFontOutlines(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
    
    {$endregion Unsorted}
    
    {$region ARB_render_texture}
    
    public z_BindTexImageARB: function(hPbuffer: PBufferName; iBuffer: Int32): UInt32 := FuncPtrOrNil&<function(hPbuffer: PBufferName; iBuffer: Int32): UInt32>(GetGLProcAdr('wglBindTexImageARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTexImageARB(hPbuffer: PBufferName; iBuffer: Int32): UInt32 := z_BindTexImageARB(hPbuffer, iBuffer);
    
    public z_ReleaseTexImageARB: function(hPbuffer: PBufferName; iBuffer: Int32): UInt32 := FuncPtrOrNil&<function(hPbuffer: PBufferName; iBuffer: Int32): UInt32>(GetGLProcAdr('wglReleaseTexImageARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseTexImageARB(hPbuffer: PBufferName; iBuffer: Int32): UInt32 := z_ReleaseTexImageARB(hPbuffer, iBuffer);
    
    public z_SetPbufferAttribARB: function(hPbuffer: PBufferName; piAttribList: pointer): UInt32 := FuncPtrOrNil&<function(hPbuffer: PBufferName; piAttribList: pointer): UInt32>(GetGLProcAdr('wglSetPbufferAttribARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: PBufferName; piAttribList: array of Int32): UInt32 := SetPbufferAttribARB(hPbuffer, piAttribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: PBufferName; var piAttribList: Int32): UInt32 := SetPbufferAttribARB(hPbuffer, @piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetPbufferAttribARB(hPbuffer: PBufferName; piAttribList: pointer): UInt32 := z_SetPbufferAttribARB(hPbuffer, piAttribList);
    
    {$endregion ARB_render_texture}
    
    {$region EXT_swap_control}
    
    public z_SwapIntervalEXT: function(interval: Int32): UInt32 := FuncPtrOrNil&<function(interval: Int32): UInt32>(GetGLProcAdr('wglSwapIntervalEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SwapIntervalEXT(interval: Int32): UInt32 := z_SwapIntervalEXT(interval);
    
    public z_GetSwapIntervalEXT: function: Int32 := FuncPtrOrNil&<function: Int32>(GetGLProcAdr('wglGetSwapIntervalEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSwapIntervalEXT: Int32 := z_GetSwapIntervalEXT();
    
    {$endregion EXT_swap_control}
    
    {$region NV_DX_interop}
    
    public z_DXSetResourceShareHandleNV: function(dxObject: pointer; shareHandle: IntPtr): UInt32 := FuncPtrOrNil&<function(dxObject: pointer; shareHandle: IntPtr): UInt32>(GetGLProcAdr('wglDXSetResourceShareHandleNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXSetResourceShareHandleNV(dxObject: pointer; shareHandle: IntPtr): UInt32 := z_DXSetResourceShareHandleNV(dxObject, shareHandle);
    
    public z_DXOpenDeviceNV: function(dxDevice: pointer): IntPtr := FuncPtrOrNil&<function(dxDevice: pointer): IntPtr>(GetGLProcAdr('wglDXOpenDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXOpenDeviceNV(dxDevice: pointer): IntPtr := z_DXOpenDeviceNV(dxDevice);
    
    public z_DXCloseDeviceNV: function(hDevice: IntPtr): UInt32 := FuncPtrOrNil&<function(hDevice: IntPtr): UInt32>(GetGLProcAdr('wglDXCloseDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXCloseDeviceNV(hDevice: IntPtr): UInt32 := z_DXCloseDeviceNV(hDevice);
    
    public z_DXRegisterObjectNV: function(hDevice: IntPtr; dxObject: pointer; name: UInt32; &type: DummyEnum; access: DummyEnum): IntPtr := FuncPtrOrNil&<function(hDevice: IntPtr; dxObject: pointer; name: UInt32; &type: DummyEnum; access: DummyEnum): IntPtr>(GetGLProcAdr('wglDXRegisterObjectNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXRegisterObjectNV(hDevice: IntPtr; dxObject: pointer; name: UInt32; &type: DummyEnum; access: DummyEnum): IntPtr := z_DXRegisterObjectNV(hDevice, dxObject, name, &type, access);
    
    public z_DXUnregisterObjectNV: function(hDevice: IntPtr; hObject: IntPtr): UInt32 := FuncPtrOrNil&<function(hDevice: IntPtr; hObject: IntPtr): UInt32>(GetGLProcAdr('wglDXUnregisterObjectNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnregisterObjectNV(hDevice: IntPtr; hObject: IntPtr): UInt32 := z_DXUnregisterObjectNV(hDevice, hObject);
    
    public z_DXObjectAccessNV: function(hObject: IntPtr; access: DummyEnum): UInt32 := FuncPtrOrNil&<function(hObject: IntPtr; access: DummyEnum): UInt32>(GetGLProcAdr('wglDXObjectAccessNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXObjectAccessNV(hObject: IntPtr; access: DummyEnum): UInt32 := z_DXObjectAccessNV(hObject, access);
    
    public z_DXLockObjectsNV: function(hDevice: IntPtr; count: Int32; hObjects: pointer): UInt32 := FuncPtrOrNil&<function(hDevice: IntPtr; count: Int32; hObjects: pointer): UInt32>(GetGLProcAdr('wglDXLockObjectsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: array of IntPtr): UInt32 := DXLockObjectsNV(hDevice, count, hObjects[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): UInt32 := DXLockObjectsNV(hDevice, count, @hObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXLockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: pointer): UInt32 := z_DXLockObjectsNV(hDevice, count, hObjects);
    
    public z_DXUnlockObjectsNV: function(hDevice: IntPtr; count: Int32; hObjects: pointer): UInt32 := FuncPtrOrNil&<function(hDevice: IntPtr; count: Int32; hObjects: pointer): UInt32>(GetGLProcAdr('wglDXUnlockObjectsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: array of IntPtr): UInt32 := DXUnlockObjectsNV(hDevice, count, hObjects[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; var hObjects: IntPtr): UInt32 := DXUnlockObjectsNV(hDevice, count, @hObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DXUnlockObjectsNV(hDevice: IntPtr; count: Int32; hObjects: pointer): UInt32 := z_DXUnlockObjectsNV(hDevice, count, hObjects);
    
    {$endregion NV_DX_interop}
    
    {$region WGL_3DL_stereo_control}
    
    public z_SetStereoEmitterState3DL: function(hDC: GDI_DC; uState: UInt32): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; uState: UInt32): UInt32>(GetGLProcAdr('wglSetStereoEmitterState3DL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetStereoEmitterState3DL(hDC: GDI_DC; uState: UInt32): UInt32 := z_SetStereoEmitterState3DL(hDC, uState);
    
    {$endregion WGL_3DL_stereo_control}
    
    {$region WGL_ARB_buffer_region}
    
    public z_CreateBufferRegionARB: function(hDC: GDI_DC; iLayerPlane: Int32; uType: UInt32): IntPtr := FuncPtrOrNil&<function(hDC: GDI_DC; iLayerPlane: Int32; uType: UInt32): IntPtr>(GetGLProcAdr('wglCreateBufferRegionARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateBufferRegionARB(hDC: GDI_DC; iLayerPlane: Int32; uType: UInt32): IntPtr := z_CreateBufferRegionARB(hDC, iLayerPlane, uType);
    
    public z_DeleteBufferRegionARB: procedure(hRegion: IntPtr) := FuncPtrOrNil&<procedure(hRegion: IntPtr)>(GetGLProcAdr('wglDeleteBufferRegionARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteBufferRegionARB(hRegion: IntPtr) := z_DeleteBufferRegionARB(hRegion);
    
    public z_SaveBufferRegionARB: function(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32): UInt32 := FuncPtrOrNil&<function(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32): UInt32>(GetGLProcAdr('wglSaveBufferRegionARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SaveBufferRegionARB(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32): UInt32 := z_SaveBufferRegionARB(hRegion, x, y, width, height);
    
    public z_RestoreBufferRegionARB: function(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32; xSrc: Int32; ySrc: Int32): UInt32 := FuncPtrOrNil&<function(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32; xSrc: Int32; ySrc: Int32): UInt32>(GetGLProcAdr('wglRestoreBufferRegionARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function RestoreBufferRegionARB(hRegion: IntPtr; x: Int32; y: Int32; width: Int32; height: Int32; xSrc: Int32; ySrc: Int32): UInt32 := z_RestoreBufferRegionARB(hRegion, x, y, width, height, xSrc, ySrc);
    
    {$endregion WGL_ARB_buffer_region}
    
    {$region WGL_I3D_digital_video_control}
    
    public z_GetDigitalVideoParametersI3D: function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32>(GetGLProcAdr('wglGetDigitalVideoParametersI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: array of Int32): UInt32 := GetDigitalVideoParametersI3D(hDC, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; var piValue: Int32): UInt32 := GetDigitalVideoParametersI3D(hDC, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := z_GetDigitalVideoParametersI3D(hDC, iAttribute, piValue);
    
    public z_SetDigitalVideoParametersI3D: function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32>(GetGLProcAdr('wglSetDigitalVideoParametersI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: array of Int32): UInt32 := SetDigitalVideoParametersI3D(hDC, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; var piValue: Int32): UInt32 := SetDigitalVideoParametersI3D(hDC, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetDigitalVideoParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := z_SetDigitalVideoParametersI3D(hDC, iAttribute, piValue);
    
    {$endregion WGL_I3D_digital_video_control}
    
    {$region WGL_I3D_gamma}
    
    public z_GetGammaTableParametersI3D: function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32>(GetGLProcAdr('wglGetGammaTableParametersI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: array of Int32): UInt32 := GetGammaTableParametersI3D(hDC, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; var piValue: Int32): UInt32 := GetGammaTableParametersI3D(hDC, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := z_GetGammaTableParametersI3D(hDC, iAttribute, piValue);
    
    public z_SetGammaTableParametersI3D: function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32>(GetGLProcAdr('wglSetGammaTableParametersI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: array of Int32): UInt32 := SetGammaTableParametersI3D(hDC, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; var piValue: Int32): UInt32 := SetGammaTableParametersI3D(hDC, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableParametersI3D(hDC: GDI_DC; iAttribute: Int32; piValue: pointer): UInt32 := z_SetGammaTableParametersI3D(hDC, iAttribute, piValue);
    
    public z_GetGammaTableI3D: function(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: pointer): UInt32>(GetGLProcAdr('wglGetGammaTableI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, @puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; puBlue: pointer): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: array of UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; var puBlue: UInt16): UInt32 := GetGammaTableI3D(hDC, iEntries, puRed, puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: pointer): UInt32 := z_GetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue);
    
    public z_SetGammaTableI3D: function(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: pointer): UInt32>(GetGLProcAdr('wglSetGammaTableI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: array of UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; var puGreen: UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: array of UInt16; puGreen: pointer; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed[0], puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: array of UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; var puGreen: UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; var puRed: UInt16; puGreen: pointer; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, @puRed, puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: array of UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, puGreen[0], puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, @puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, @puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; var puGreen: UInt16; puBlue: pointer): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, @puGreen, puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: array of UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; var puBlue: UInt16): UInt32 := SetGammaTableI3D(hDC, iEntries, puRed, puGreen, @puBlue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function SetGammaTableI3D(hDC: GDI_DC; iEntries: Int32; puRed: pointer; puGreen: pointer; puBlue: pointer): UInt32 := z_SetGammaTableI3D(hDC, iEntries, puRed, puGreen, puBlue);
    
    {$endregion WGL_I3D_gamma}
    
    {$region WGL_I3D_genlock}
    
    public z_EnableGenlockI3D: function(hDC: GDI_DC): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC): UInt32>(GetGLProcAdr('wglEnableGenlockI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnableGenlockI3D(hDC: GDI_DC): UInt32 := z_EnableGenlockI3D(hDC);
    
    public z_DisableGenlockI3D: function(hDC: GDI_DC): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC): UInt32>(GetGLProcAdr('wglDisableGenlockI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DisableGenlockI3D(hDC: GDI_DC): UInt32 := z_DisableGenlockI3D(hDC);
    
    public z_IsEnabledGenlockI3D: function(hDC: GDI_DC; pFlag: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; pFlag: pointer): UInt32>(GetGLProcAdr('wglIsEnabledGenlockI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: GDI_DC; pFlag: array of UInt32): UInt32 := IsEnabledGenlockI3D(hDC, pFlag[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: GDI_DC; var pFlag: UInt32): UInt32 := IsEnabledGenlockI3D(hDC, @pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledGenlockI3D(hDC: GDI_DC; pFlag: pointer): UInt32 := z_IsEnabledGenlockI3D(hDC, pFlag);
    
    public z_GenlockSourceI3D: function(hDC: GDI_DC; uSource: UInt32): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; uSource: UInt32): UInt32>(GetGLProcAdr('wglGenlockSourceI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceI3D(hDC: GDI_DC; uSource: UInt32): UInt32 := z_GenlockSourceI3D(hDC, uSource);
    
    public z_GetGenlockSourceI3D: function(hDC: GDI_DC; uSource: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; uSource: pointer): UInt32>(GetGLProcAdr('wglGetGenlockSourceI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceI3D(hDC: GDI_DC; uSource: array of UInt32): UInt32 := GetGenlockSourceI3D(hDC, uSource[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceI3D(hDC: GDI_DC; var uSource: UInt32): UInt32 := GetGenlockSourceI3D(hDC, @uSource);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceI3D(hDC: GDI_DC; uSource: pointer): UInt32 := z_GetGenlockSourceI3D(hDC, uSource);
    
    public z_GenlockSourceEdgeI3D: function(hDC: GDI_DC; uEdge: UInt32): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; uEdge: UInt32): UInt32>(GetGLProcAdr('wglGenlockSourceEdgeI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceEdgeI3D(hDC: GDI_DC; uEdge: UInt32): UInt32 := z_GenlockSourceEdgeI3D(hDC, uEdge);
    
    public z_GetGenlockSourceEdgeI3D: function(hDC: GDI_DC; uEdge: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; uEdge: pointer): UInt32>(GetGLProcAdr('wglGetGenlockSourceEdgeI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceEdgeI3D(hDC: GDI_DC; uEdge: array of UInt32): UInt32 := GetGenlockSourceEdgeI3D(hDC, uEdge[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceEdgeI3D(hDC: GDI_DC; var uEdge: UInt32): UInt32 := GetGenlockSourceEdgeI3D(hDC, @uEdge);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceEdgeI3D(hDC: GDI_DC; uEdge: pointer): UInt32 := z_GetGenlockSourceEdgeI3D(hDC, uEdge);
    
    public z_GenlockSampleRateI3D: function(hDC: GDI_DC; uRate: UInt32): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; uRate: UInt32): UInt32>(GetGLProcAdr('wglGenlockSampleRateI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSampleRateI3D(hDC: GDI_DC; uRate: UInt32): UInt32 := z_GenlockSampleRateI3D(hDC, uRate);
    
    public z_GetGenlockSampleRateI3D: function(hDC: GDI_DC; uRate: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; uRate: pointer): UInt32>(GetGLProcAdr('wglGetGenlockSampleRateI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSampleRateI3D(hDC: GDI_DC; uRate: array of UInt32): UInt32 := GetGenlockSampleRateI3D(hDC, uRate[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSampleRateI3D(hDC: GDI_DC; var uRate: UInt32): UInt32 := GetGenlockSampleRateI3D(hDC, @uRate);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSampleRateI3D(hDC: GDI_DC; uRate: pointer): UInt32 := z_GetGenlockSampleRateI3D(hDC, uRate);
    
    public z_GenlockSourceDelayI3D: function(hDC: GDI_DC; uDelay: UInt32): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; uDelay: UInt32): UInt32>(GetGLProcAdr('wglGenlockSourceDelayI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenlockSourceDelayI3D(hDC: GDI_DC; uDelay: UInt32): UInt32 := z_GenlockSourceDelayI3D(hDC, uDelay);
    
    public z_GetGenlockSourceDelayI3D: function(hDC: GDI_DC; uDelay: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; uDelay: pointer): UInt32>(GetGLProcAdr('wglGetGenlockSourceDelayI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceDelayI3D(hDC: GDI_DC; uDelay: array of UInt32): UInt32 := GetGenlockSourceDelayI3D(hDC, uDelay[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceDelayI3D(hDC: GDI_DC; var uDelay: UInt32): UInt32 := GetGenlockSourceDelayI3D(hDC, @uDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetGenlockSourceDelayI3D(hDC: GDI_DC; uDelay: pointer): UInt32 := z_GetGenlockSourceDelayI3D(hDC, uDelay);
    
    public z_QueryGenlockMaxSourceDelayI3D: function(hDC: GDI_DC; uMaxLineDelay: pointer; uMaxPixelDelay: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; uMaxLineDelay: pointer; uMaxPixelDelay: pointer): UInt32>(GetGLProcAdr('wglQueryGenlockMaxSourceDelayI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: array of UInt32; uMaxPixelDelay: array of UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay[0], uMaxPixelDelay[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: array of UInt32; var uMaxPixelDelay: UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay[0], @uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: array of UInt32; uMaxPixelDelay: pointer): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay[0], uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; var uMaxLineDelay: UInt32; uMaxPixelDelay: array of UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, @uMaxLineDelay, uMaxPixelDelay[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; var uMaxLineDelay: UInt32; var uMaxPixelDelay: UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, @uMaxLineDelay, @uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; var uMaxLineDelay: UInt32; uMaxPixelDelay: pointer): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, @uMaxLineDelay, uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: pointer; uMaxPixelDelay: array of UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay, uMaxPixelDelay[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: pointer; var uMaxPixelDelay: UInt32): UInt32 := QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay, @uMaxPixelDelay);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryGenlockMaxSourceDelayI3D(hDC: GDI_DC; uMaxLineDelay: pointer; uMaxPixelDelay: pointer): UInt32 := z_QueryGenlockMaxSourceDelayI3D(hDC, uMaxLineDelay, uMaxPixelDelay);
    
    {$endregion WGL_I3D_genlock}
    
    {$region WGL_I3D_image_buffer}
    
    public z_CreateImageBufferI3D: function(hDC: GDI_DC; dwSize: UInt32; uFlags: UInt32): IntPtr := FuncPtrOrNil&<function(hDC: GDI_DC; dwSize: UInt32; uFlags: UInt32): IntPtr>(GetGLProcAdr('wglCreateImageBufferI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateImageBufferI3D(hDC: GDI_DC; dwSize: UInt32; uFlags: UInt32): IntPtr := z_CreateImageBufferI3D(hDC, dwSize, uFlags);
    
    public z_DestroyImageBufferI3D: function(hDC: GDI_DC; pAddress: IntPtr): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; pAddress: IntPtr): UInt32>(GetGLProcAdr('wglDestroyImageBufferI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyImageBufferI3D(hDC: GDI_DC; pAddress: IntPtr): UInt32 := z_DestroyImageBufferI3D(hDC, pAddress);
    
    public z_AssociateImageBufferEventsI3D: function(hDC: GDI_DC; pEvent: pointer; pAddress: pointer; pSize: pointer; count: UInt32): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; pEvent: pointer; pAddress: pointer; pSize: pointer; count: UInt32): UInt32>(GetGLProcAdr('wglAssociateImageBufferEventsI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: array of IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress[0], pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: array of IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress[0], @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: array of IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress[0], pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; var pAddress: IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], @pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], @pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; var pAddress: IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], @pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: pointer; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: pointer; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: array of IntPtr; pAddress: pointer; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent[0], pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: array of IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress[0], pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: array of IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress[0], @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: array of IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress[0], pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; var pAddress: IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, @pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, @pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; var pAddress: IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, @pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: pointer; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: pointer; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; var pEvent: IntPtr; pAddress: pointer; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, @pEvent, pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: array of IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, pAddress[0], pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: array of IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, pAddress[0], @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: array of IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, pAddress[0], pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; var pAddress: IntPtr; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, @pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; var pAddress: IntPtr; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, @pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; var pAddress: IntPtr; pSize: pointer; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, @pAddress, pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: pointer; pSize: array of UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, pAddress, pSize[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: pointer; var pSize: UInt32; count: UInt32): UInt32 := AssociateImageBufferEventsI3D(hDC, pEvent, pAddress, @pSize, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateImageBufferEventsI3D(hDC: GDI_DC; pEvent: pointer; pAddress: pointer; pSize: pointer; count: UInt32): UInt32 := z_AssociateImageBufferEventsI3D(hDC, pEvent, pAddress, pSize, count);
    
    public z_ReleaseImageBufferEventsI3D: function(hDC: GDI_DC; pAddress: pointer; count: UInt32): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; pAddress: pointer; count: UInt32): UInt32>(GetGLProcAdr('wglReleaseImageBufferEventsI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: GDI_DC; pAddress: array of IntPtr; count: UInt32): UInt32 := ReleaseImageBufferEventsI3D(hDC, pAddress[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: GDI_DC; var pAddress: IntPtr; count: UInt32): UInt32 := ReleaseImageBufferEventsI3D(hDC, @pAddress, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseImageBufferEventsI3D(hDC: GDI_DC; pAddress: pointer; count: UInt32): UInt32 := z_ReleaseImageBufferEventsI3D(hDC, pAddress, count);
    
    {$endregion WGL_I3D_image_buffer}
    
    {$region WGL_I3D_swap_frame_lock}
    
    public z_EnableFrameLockI3D: function: UInt32 := FuncPtrOrNil&<function: UInt32>(GetGLProcAdr('wglEnableFrameLockI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnableFrameLockI3D: UInt32 := z_EnableFrameLockI3D();
    
    public z_DisableFrameLockI3D: function: UInt32 := FuncPtrOrNil&<function: UInt32>(GetGLProcAdr('wglDisableFrameLockI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DisableFrameLockI3D: UInt32 := z_DisableFrameLockI3D();
    
    public z_IsEnabledFrameLockI3D: function(pFlag: pointer): UInt32 := FuncPtrOrNil&<function(pFlag: pointer): UInt32>(GetGLProcAdr('wglIsEnabledFrameLockI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(pFlag: array of UInt32): UInt32 := IsEnabledFrameLockI3D(pFlag[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(var pFlag: UInt32): UInt32 := IsEnabledFrameLockI3D(@pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledFrameLockI3D(pFlag: pointer): UInt32 := z_IsEnabledFrameLockI3D(pFlag);
    
    public z_QueryFrameLockMasterI3D: function(pFlag: pointer): UInt32 := FuncPtrOrNil&<function(pFlag: pointer): UInt32>(GetGLProcAdr('wglQueryFrameLockMasterI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(pFlag: array of UInt32): UInt32 := QueryFrameLockMasterI3D(pFlag[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(var pFlag: UInt32): UInt32 := QueryFrameLockMasterI3D(@pFlag);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameLockMasterI3D(pFlag: pointer): UInt32 := z_QueryFrameLockMasterI3D(pFlag);
    
    {$endregion WGL_I3D_swap_frame_lock}
    
    {$region WGL_I3D_swap_frame_usage}
    
    public z_GetFrameUsageI3D: function(pUsage: pointer): UInt32 := FuncPtrOrNil&<function(pUsage: pointer): UInt32>(GetGLProcAdr('wglGetFrameUsageI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFrameUsageI3D(pUsage: array of single): UInt32 := GetFrameUsageI3D(pUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFrameUsageI3D(var pUsage: single): UInt32 := GetFrameUsageI3D(@pUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFrameUsageI3D(pUsage: pointer): UInt32 := z_GetFrameUsageI3D(pUsage);
    
    public z_BeginFrameTrackingI3D: function: UInt32 := FuncPtrOrNil&<function: UInt32>(GetGLProcAdr('wglBeginFrameTrackingI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BeginFrameTrackingI3D: UInt32 := z_BeginFrameTrackingI3D();
    
    public z_EndFrameTrackingI3D: function: UInt32 := FuncPtrOrNil&<function: UInt32>(GetGLProcAdr('wglEndFrameTrackingI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EndFrameTrackingI3D: UInt32 := z_EndFrameTrackingI3D();
    
    public z_QueryFrameTrackingI3D: function(pFrameCount: pointer; pMissedFrames: pointer; pLastMissedUsage: pointer): UInt32 := FuncPtrOrNil&<function(pFrameCount: pointer; pMissedFrames: pointer; pLastMissedUsage: pointer): UInt32>(GetGLProcAdr('wglQueryFrameTrackingI3D'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: array of UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames[0], pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: array of UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames[0], @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: array of UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames[0], pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; var pMissedFrames: UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], @pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; var pMissedFrames: UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], @pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; var pMissedFrames: UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], @pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: pointer; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: pointer; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: array of UInt32; pMissedFrames: pointer; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(pFrameCount[0], pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: array of UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames[0], pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: array of UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames[0], @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: array of UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames[0], pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; var pMissedFrames: UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, @pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; var pMissedFrames: UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, @pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; var pMissedFrames: UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(@pFrameCount, @pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: pointer; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: pointer; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(var pFrameCount: UInt32; pMissedFrames: pointer; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(@pFrameCount, pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: array of UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount, pMissedFrames[0], pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: array of UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount, pMissedFrames[0], @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: array of UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(pFrameCount, pMissedFrames[0], pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; var pMissedFrames: UInt32; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount, @pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; var pMissedFrames: UInt32; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount, @pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; var pMissedFrames: UInt32; pLastMissedUsage: pointer): UInt32 := QueryFrameTrackingI3D(pFrameCount, @pMissedFrames, pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: pointer; pLastMissedUsage: array of single): UInt32 := QueryFrameTrackingI3D(pFrameCount, pMissedFrames, pLastMissedUsage[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: pointer; var pLastMissedUsage: single): UInt32 := QueryFrameTrackingI3D(pFrameCount, pMissedFrames, @pLastMissedUsage);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryFrameTrackingI3D(pFrameCount: pointer; pMissedFrames: pointer; pLastMissedUsage: pointer): UInt32 := z_QueryFrameTrackingI3D(pFrameCount, pMissedFrames, pLastMissedUsage);
    
    {$endregion WGL_I3D_swap_frame_usage}
    
    {$region WGL_NV_gpu_affinity}
    
    public z_EnumGpusNV: function(iGpuIndex: UInt32; phGpu: pointer): UInt32 := FuncPtrOrNil&<function(iGpuIndex: UInt32; phGpu: pointer): UInt32>(GetGLProcAdr('wglEnumGpusNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; phGpu: array of GPUAffinityHandle): UInt32 := EnumGpusNV(iGpuIndex, phGpu[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; var phGpu: GPUAffinityHandle): UInt32 := EnumGpusNV(iGpuIndex, @phGpu);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusNV(iGpuIndex: UInt32; phGpu: pointer): UInt32 := z_EnumGpusNV(iGpuIndex, phGpu);
    
    public z_EnumGpuDevicesNV: function(hGpu: GPUAffinityHandle; iDeviceIndex: UInt32; lpGpuDevice: pointer): UInt32 := FuncPtrOrNil&<function(hGpu: GPUAffinityHandle; iDeviceIndex: UInt32; lpGpuDevice: pointer): UInt32>(GetGLProcAdr('wglEnumGpuDevicesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: GPUAffinityHandle; iDeviceIndex: UInt32; lpGpuDevice: array of GPU_Device_Affinity_Info): UInt32 := EnumGpuDevicesNV(hGpu, iDeviceIndex, lpGpuDevice[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: GPUAffinityHandle; iDeviceIndex: UInt32; var lpGpuDevice: GPU_Device_Affinity_Info): UInt32 := EnumGpuDevicesNV(hGpu, iDeviceIndex, @lpGpuDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpuDevicesNV(hGpu: GPUAffinityHandle; iDeviceIndex: UInt32; lpGpuDevice: pointer): UInt32 := z_EnumGpuDevicesNV(hGpu, iDeviceIndex, lpGpuDevice);
    
    public z_CreateAffinityDCNV: function(phGpuList: pointer): GDI_DC := FuncPtrOrNil&<function(phGpuList: pointer): GDI_DC>(GetGLProcAdr('wglCreateAffinityDCNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(phGpuList: array of GPUAffinityHandle): GDI_DC := CreateAffinityDCNV(phGpuList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(var phGpuList: GPUAffinityHandle): GDI_DC := CreateAffinityDCNV(@phGpuList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateAffinityDCNV(phGpuList: pointer): GDI_DC := z_CreateAffinityDCNV(phGpuList);
    
    public z_EnumGpusFromAffinityDCNV: function(hAffinityDC: GDI_DC; iGpuIndex: UInt32; hGpu: pointer): UInt32 := FuncPtrOrNil&<function(hAffinityDC: GDI_DC; iGpuIndex: UInt32; hGpu: pointer): UInt32>(GetGLProcAdr('wglEnumGpusFromAffinityDCNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: GDI_DC; iGpuIndex: UInt32; hGpu: array of GPUAffinityHandle): UInt32 := EnumGpusFromAffinityDCNV(hAffinityDC, iGpuIndex, hGpu[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: GDI_DC; iGpuIndex: UInt32; var hGpu: GPUAffinityHandle): UInt32 := EnumGpusFromAffinityDCNV(hAffinityDC, iGpuIndex, @hGpu);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function EnumGpusFromAffinityDCNV(hAffinityDC: GDI_DC; iGpuIndex: UInt32; hGpu: pointer): UInt32 := z_EnumGpusFromAffinityDCNV(hAffinityDC, iGpuIndex, hGpu);
    
    public z_DeleteDCNV: function(hdc: GDI_DC): UInt32 := FuncPtrOrNil&<function(hdc: GDI_DC): UInt32>(GetGLProcAdr('wglDeleteDCNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DeleteDCNV(hdc: GDI_DC): UInt32 := z_DeleteDCNV(hdc);
    
    {$endregion WGL_NV_gpu_affinity}
    
    {$region WGL_ARB_create_context, WGL_ARB_create_context_profile}
    
    public z_CreateContextAttribsARB: function(hDC: GDI_DC; hShareContext: GLContext; attribList: pointer): GLContext := FuncPtrOrNil&<function(hDC: GDI_DC; hShareContext: GLContext; attribList: pointer): GLContext>(GetGLProcAdr('wglCreateContextAttribsARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: GDI_DC; hShareContext: GLContext; attribList: array of Int32): GLContext := CreateContextAttribsARB(hDC, hShareContext, attribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: GDI_DC; hShareContext: GLContext; var attribList: Int32): GLContext := CreateContextAttribsARB(hDC, hShareContext, @attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(hDC: GDI_DC; hShareContext: GLContext; attribList: pointer): GLContext := z_CreateContextAttribsARB(hDC, hShareContext, attribList);
    
    {$endregion WGL_ARB_create_context, WGL_ARB_create_context_profile}
    
    {$region WGL_ARB_extensions_string, EXT_extensions_string}
    
    public z_GetExtensionsStringARB: function(hdc: GDI_DC): IntPtr := FuncPtrOrNil&<function(hdc: GDI_DC): IntPtr>(GetGLProcAdr('wglGetExtensionsStringARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetExtensionsStringARB_Str(hdc: GDI_DC): string := Marshal.PtrToStringAnsi(z_GetExtensionsStringARB(hdc));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetExtensionsStringARB(hdc: GDI_DC): IntPtr := z_GetExtensionsStringARB(hdc);
    
    {$endregion WGL_ARB_extensions_string, EXT_extensions_string}
    
    {$region WGL_ARB_make_current_read, EXT_make_current_read}
    
    public z_MakeContextCurrentARB: function(hDrawDC: GDI_DC; hReadDC: GDI_DC; hglrc: GLContext): UInt32 := FuncPtrOrNil&<function(hDrawDC: GDI_DC; hReadDC: GDI_DC; hglrc: GLContext): UInt32>(GetGLProcAdr('wglMakeContextCurrentARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeContextCurrentARB(hDrawDC: GDI_DC; hReadDC: GDI_DC; hglrc: GLContext): UInt32 := z_MakeContextCurrentARB(hDrawDC, hReadDC, hglrc);
    
    public z_GetCurrentReadDCARB: function: GDI_DC := FuncPtrOrNil&<function: GDI_DC>(GetGLProcAdr('wglGetCurrentReadDCARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDCARB: GDI_DC := z_GetCurrentReadDCARB();
    
    {$endregion WGL_ARB_make_current_read, EXT_make_current_read}
    
    {$region WGL_ARB_pbuffer, EXT_pbuffer}
    
    public z_CreatePbufferARB: function(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: pointer): PBufferName := FuncPtrOrNil&<function(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: pointer): PBufferName>(GetGLProcAdr('wglCreatePbufferARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: array of Int32): PBufferName := CreatePbufferARB(hDC, iPixelFormat, iWidth, iHeight, piAttribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; var piAttribList: Int32): PBufferName := CreatePbufferARB(hDC, iPixelFormat, iWidth, iHeight, @piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbufferARB(hDC: GDI_DC; iPixelFormat: Int32; iWidth: Int32; iHeight: Int32; piAttribList: pointer): PBufferName := z_CreatePbufferARB(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
    
    public z_GetPbufferDCARB: function(hPbuffer: PBufferName): GDI_DC := FuncPtrOrNil&<function(hPbuffer: PBufferName): GDI_DC>(GetGLProcAdr('wglGetPbufferDCARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPbufferDCARB(hPbuffer: PBufferName): GDI_DC := z_GetPbufferDCARB(hPbuffer);
    
    public z_ReleasePbufferDCARB: function(hPbuffer: PBufferName; hDC: GDI_DC): Int32 := FuncPtrOrNil&<function(hPbuffer: PBufferName; hDC: GDI_DC): Int32>(GetGLProcAdr('wglReleasePbufferDCARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleasePbufferDCARB(hPbuffer: PBufferName; hDC: GDI_DC): Int32 := z_ReleasePbufferDCARB(hPbuffer, hDC);
    
    public z_DestroyPbufferARB: function(hPbuffer: PBufferName): UInt32 := FuncPtrOrNil&<function(hPbuffer: PBufferName): UInt32>(GetGLProcAdr('wglDestroyPbufferARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyPbufferARB(hPbuffer: PBufferName): UInt32 := z_DestroyPbufferARB(hPbuffer);
    
    public z_QueryPbufferARB: function(hPbuffer: PBufferName; iAttribute: Int32; piValue: pointer): UInt32 := FuncPtrOrNil&<function(hPbuffer: PBufferName; iAttribute: Int32; piValue: pointer): UInt32>(GetGLProcAdr('wglQueryPbufferARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: PBufferName; iAttribute: Int32; piValue: array of Int32): UInt32 := QueryPbufferARB(hPbuffer, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: PBufferName; iAttribute: Int32; var piValue: Int32): UInt32 := QueryPbufferARB(hPbuffer, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryPbufferARB(hPbuffer: PBufferName; iAttribute: Int32; piValue: pointer): UInt32 := z_QueryPbufferARB(hPbuffer, iAttribute, piValue);
    
    {$endregion WGL_ARB_pbuffer, EXT_pbuffer}
    
    {$region WGL_ARB_pixel_format, EXT_pixel_format}
    
    public z_GetPixelFormatAttribivARB: function(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; piValues: pointer): UInt32 := FuncPtrOrNil&<function(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; piValues: pointer): UInt32>(GetGLProcAdr('wglGetPixelFormatAttribivARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; piValues: array of Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], piValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; var piValues: Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], @piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; piValues: pointer): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; piValues: array of Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, piValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var piValues: Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, @piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; piValues: pointer): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; piValues: array of Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; var piValues: Int32): UInt32 := GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, @piValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribivARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; piValues: pointer): UInt32 := z_GetPixelFormatAttribivARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
    
    public z_GetPixelFormatAttribfvARB: function(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; pfValues: pointer): UInt32 := FuncPtrOrNil&<function(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; pfValues: pointer): UInt32>(GetGLProcAdr('wglGetPixelFormatAttribfvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; pfValues: array of single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], pfValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; var pfValues: single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], @pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: array of Int32; pfValues: pointer): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes[0], pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; pfValues: array of single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, pfValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; var pfValues: single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, @pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; var piAttributes: Int32; pfValues: pointer): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, @piAttributes, pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; pfValues: array of single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; var pfValues: single): UInt32 := GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, @pfValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPixelFormatAttribfvARB(hdc: GDI_DC; iPixelFormat: Int32; iLayerPlane: Int32; nAttributes: UInt32; piAttributes: pointer; pfValues: pointer): UInt32 := z_GetPixelFormatAttribfvARB(hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
    
    public z_ChoosePixelFormatARB: function(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := FuncPtrOrNil&<function(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32>(GetGLProcAdr('wglChoosePixelFormatARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList[0], nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], @pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: array of Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList[0], pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; var piAttribIList: Int32; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, @piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: array of single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList[0], nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; var pfAttribFList: single; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, @pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: array of Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats[0], nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, @piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; var piFormats: Int32; nNumFormats: pointer): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, @piFormats, nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: array of UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; var nNumFormats: UInt32): UInt32 := ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, @nNumFormats);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChoosePixelFormatARB(hdc: GDI_DC; piAttribIList: pointer; pfAttribFList: pointer; nMaxFormats: UInt32; piFormats: pointer; nNumFormats: pointer): UInt32 := z_ChoosePixelFormatARB(hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
    
    {$endregion WGL_ARB_pixel_format, EXT_pixel_format}
    
  end;
  
  egl = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region KHR_fence_sync}
    
    public z_CreateSyncKHR: function(dpy: EGLDisplay; &type: DummyEnum; attrib_list: pointer): EGLsync := FuncPtrOrNil&<function(dpy: EGLDisplay; &type: DummyEnum; attrib_list: pointer): EGLsync>(GetGLProcAdr('eglCreateSyncKHR'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncKHR(dpy: EGLDisplay; &type: DummyEnum; attrib_list: array of Int32): EGLsync := CreateSyncKHR(dpy, &type, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncKHR(dpy: EGLDisplay; &type: DummyEnum; var attrib_list: Int32): EGLsync := CreateSyncKHR(dpy, &type, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncKHR(dpy: EGLDisplay; &type: DummyEnum; attrib_list: pointer): EGLsync := z_CreateSyncKHR(dpy, &type, attrib_list);
    
    public z_DestroySyncKHR: function(dpy: EGLDisplay; sync: EGLsync): UInt32 := FuncPtrOrNil&<function(dpy: EGLDisplay; sync: EGLsync): UInt32>(GetGLProcAdr('eglDestroySyncKHR'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroySyncKHR(dpy: EGLDisplay; sync: EGLsync): UInt32 := z_DestroySyncKHR(dpy, sync);
    
    public z_ClientWaitSyncKHR: function(dpy: EGLDisplay; sync: EGLsync; flags: Int32; timeout: TimeSpan): Int32 := FuncPtrOrNil&<function(dpy: EGLDisplay; sync: EGLsync; flags: Int32; timeout: TimeSpan): Int32>(GetGLProcAdr('eglClientWaitSyncKHR'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ClientWaitSyncKHR(dpy: EGLDisplay; sync: EGLsync; flags: Int32; timeout: TimeSpan): Int32 := z_ClientWaitSyncKHR(dpy, sync, flags, timeout);
    
    public z_GetSyncAttribKHR: function(dpy: EGLDisplay; sync: EGLsync; attribute: Int32; value: pointer): UInt32 := FuncPtrOrNil&<function(dpy: EGLDisplay; sync: EGLsync; attribute: Int32; value: pointer): UInt32>(GetGLProcAdr('eglGetSyncAttribKHR'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncAttribKHR(dpy: EGLDisplay; sync: EGLsync; attribute: Int32; value: array of Int32): UInt32 := GetSyncAttribKHR(dpy, sync, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncAttribKHR(dpy: EGLDisplay; sync: EGLsync; attribute: Int32; var value: Int32): UInt32 := GetSyncAttribKHR(dpy, sync, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSyncAttribKHR(dpy: EGLDisplay; sync: EGLsync; attribute: Int32; value: pointer): UInt32 := z_GetSyncAttribKHR(dpy, sync, attribute, value);
    
    {$endregion KHR_fence_sync}
    
  end;
  
  glu = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region EXT_nurbs_tessellator}
    
    public z_NurbsCallbackDataEXT: procedure(theNurb: pointer; userData: pointer) := FuncPtrOrNil&<procedure(theNurb: pointer; userData: pointer)>(GetGLProcAdr('gluNurbsCallbackDataEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NurbsCallbackDataEXT(theNurb: array of GLUnurbs; userData: pointer) := NurbsCallbackDataEXT(theNurb[0], userData);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NurbsCallbackDataEXT(var theNurb: GLUnurbs; userData: pointer) := NurbsCallbackDataEXT(@theNurb, userData);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NurbsCallbackDataEXT(theNurb: pointer; userData: pointer) := z_NurbsCallbackDataEXT(theNurb, userData);
    
    {$endregion EXT_nurbs_tessellator}
    
  end;
  
  glX = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region Unsorted}
    
    public z_AssociateDMPbufferSGIX: function(dpy: PDisplay; pbuffer: GLXPbuffer; &params: pointer; dmbuffer: GLXDMbuffer): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; pbuffer: GLXPbuffer; &params: pointer; dmbuffer: GLXDMbuffer): UInt32>(GetGLProcAdr('glXAssociateDMPbufferSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateDMPbufferSGIX(dpy: PDisplay; pbuffer: GLXPbuffer; &params: array of GLXDMparams; dmbuffer: GLXDMbuffer): UInt32 := AssociateDMPbufferSGIX(dpy, pbuffer, &params[0], dmbuffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateDMPbufferSGIX(dpy: PDisplay; pbuffer: GLXPbuffer; var &params: GLXDMparams; dmbuffer: GLXDMbuffer): UInt32 := AssociateDMPbufferSGIX(dpy, pbuffer, @&params, dmbuffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AssociateDMPbufferSGIX(dpy: PDisplay; pbuffer: GLXPbuffer; &params: pointer; dmbuffer: GLXDMbuffer): UInt32 := z_AssociateDMPbufferSGIX(dpy, pbuffer, &params, dmbuffer);
    
    public z_CopyImageSubDataNV: procedure(dpy: PDisplay; srcCtx: GLXContext; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstCtx: GLXContext; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) := FuncPtrOrNil&<procedure(dpy: PDisplay; srcCtx: GLXContext; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstCtx: GLXContext; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>(GetGLProcAdr('glXCopyImageSubDataNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyImageSubDataNV(dpy: PDisplay; srcCtx: GLXContext; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstCtx: GLXContext; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) := z_CopyImageSubDataNV(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
    public z_CreateGLXVideoSourceSGIX: function(display: PDisplay; screen: Int32; server: GLXVLServer; path: GLXVLPath; nodeClass: Int32; drainNode: GLXVLNode): GLXVideoSourceSGIX := FuncPtrOrNil&<function(display: PDisplay; screen: Int32; server: GLXVLServer; path: GLXVLPath; nodeClass: Int32; drainNode: GLXVLNode): GLXVideoSourceSGIX>(GetGLProcAdr('glXCreateGLXVideoSourceSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXVideoSourceSGIX(display: PDisplay; screen: Int32; server: GLXVLServer; path: GLXVLPath; nodeClass: Int32; drainNode: GLXVLNode): GLXVideoSourceSGIX := z_CreateGLXVideoSourceSGIX(display, screen, server, path, nodeClass, drainNode);
    
    public z_CreateNewContext: function(dpy: PDisplay; config: GLXFBConfig; render_type: Int32; share_list: GLXContext; direct: UInt32): GLXContext := FuncPtrOrNil&<function(dpy: PDisplay; config: GLXFBConfig; render_type: Int32; share_list: GLXContext; direct: UInt32): GLXContext>(GetGLProcAdr('glXCreateNewContext'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateNewContext(dpy: PDisplay; config: GLXFBConfig; render_type: Int32; share_list: GLXContext; direct: UInt32): GLXContext := z_CreateNewContext(dpy, config, render_type, share_list, direct);
    
    public z_CreatePbuffer: function(dpy: PDisplay; config: GLXFBConfig; attrib_list: pointer): GLXPbuffer := FuncPtrOrNil&<function(dpy: PDisplay; config: GLXFBConfig; attrib_list: pointer): GLXPbuffer>(GetGLProcAdr('glXCreatePbuffer'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbuffer(dpy: PDisplay; config: GLXFBConfig; attrib_list: array of Int32): GLXPbuffer := CreatePbuffer(dpy, config, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbuffer(dpy: PDisplay; config: GLXFBConfig; var attrib_list: Int32): GLXPbuffer := CreatePbuffer(dpy, config, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePbuffer(dpy: PDisplay; config: GLXFBConfig; attrib_list: pointer): GLXPbuffer := z_CreatePbuffer(dpy, config, attrib_list);
    
    public z_CreatePixmap: function(dpy: PDisplay; config: GLXFBConfig; pixmap: GLXPixmap; attrib_list: pointer): GLXPixmap := FuncPtrOrNil&<function(dpy: PDisplay; config: GLXFBConfig; pixmap: GLXPixmap; attrib_list: pointer): GLXPixmap>(GetGLProcAdr('glXCreatePixmap'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePixmap(dpy: PDisplay; config: GLXFBConfig; pixmap: GLXPixmap; attrib_list: array of Int32): GLXPixmap := CreatePixmap(dpy, config, pixmap, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePixmap(dpy: PDisplay; config: GLXFBConfig; pixmap: GLXPixmap; var attrib_list: Int32): GLXPixmap := CreatePixmap(dpy, config, pixmap, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreatePixmap(dpy: PDisplay; config: GLXFBConfig; pixmap: GLXPixmap; attrib_list: pointer): GLXPixmap := z_CreatePixmap(dpy, config, pixmap, attrib_list);
    
    public z_CreateWindow: function(dpy: PDisplay; config: GLXFBConfig; win: GLXWindow; attrib_list: pointer): GLXWindow := FuncPtrOrNil&<function(dpy: PDisplay; config: GLXFBConfig; win: GLXWindow; attrib_list: pointer): GLXWindow>(GetGLProcAdr('glXCreateWindow'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateWindow(dpy: PDisplay; config: GLXFBConfig; win: GLXWindow; attrib_list: array of Int32): GLXWindow := CreateWindow(dpy, config, win, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateWindow(dpy: PDisplay; config: GLXFBConfig; win: GLXWindow; var attrib_list: Int32): GLXWindow := CreateWindow(dpy, config, win, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateWindow(dpy: PDisplay; config: GLXFBConfig; win: GLXWindow; attrib_list: pointer): GLXWindow := z_CreateWindow(dpy, config, win, attrib_list);
    
    public z_CushionSGI: procedure(dpy: PDisplay; window: GLXWindow; cushion: single) := FuncPtrOrNil&<procedure(dpy: PDisplay; window: GLXWindow; cushion: single)>(GetGLProcAdr('glXCushionSGI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CushionSGI(dpy: PDisplay; window: GLXWindow; cushion: single) := z_CushionSGI(dpy, window, cushion);
    
    public z_DestroyGLXVideoSourceSGIX: procedure(dpy: PDisplay; glxvideosource: GLXVideoSourceSGIX) := FuncPtrOrNil&<procedure(dpy: PDisplay; glxvideosource: GLXVideoSourceSGIX)>(GetGLProcAdr('glXDestroyGLXVideoSourceSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyGLXVideoSourceSGIX(dpy: PDisplay; glxvideosource: GLXVideoSourceSGIX) := z_DestroyGLXVideoSourceSGIX(dpy, glxvideosource);
    
    public z_DestroyPbuffer: procedure(dpy: PDisplay; pbuf: GLXPbuffer) := FuncPtrOrNil&<procedure(dpy: PDisplay; pbuf: GLXPbuffer)>(GetGLProcAdr('glXDestroyPbuffer'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyPbuffer(dpy: PDisplay; pbuf: GLXPbuffer) := z_DestroyPbuffer(dpy, pbuf);
    
    public z_DestroyPixmap: procedure(dpy: PDisplay; pixmap: GLXPixmap) := FuncPtrOrNil&<procedure(dpy: PDisplay; pixmap: GLXPixmap)>(GetGLProcAdr('glXDestroyPixmap'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyPixmap(dpy: PDisplay; pixmap: GLXPixmap) := z_DestroyPixmap(dpy, pixmap);
    
    public z_DestroyWindow: procedure(dpy: PDisplay; win: GLXWindow) := FuncPtrOrNil&<procedure(dpy: PDisplay; win: GLXWindow)>(GetGLProcAdr('glXDestroyWindow'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyWindow(dpy: PDisplay; win: GLXWindow) := z_DestroyWindow(dpy, win);
    
    public z_GetFBConfigs: function(dpy: PDisplay; screen: Int32; nelements: pointer): pointer := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; nelements: pointer): pointer>(GetGLProcAdr('glXGetFBConfigs'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigs(dpy: PDisplay; screen: Int32; nelements: array of Int32): pointer := GetFBConfigs(dpy, screen, nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigs(dpy: PDisplay; screen: Int32; var nelements: Int32): pointer := GetFBConfigs(dpy, screen, @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigs(dpy: PDisplay; screen: Int32; nelements: pointer): pointer := z_GetFBConfigs(dpy, screen, nelements);
    
    public z_GetProcAddress: function(procName: pointer): GLXFuncPtr := FuncPtrOrNil&<function(procName: pointer): GLXFuncPtr>(GetGLProcAdr('glXGetProcAddress'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddress(procName: array of Byte): GLXFuncPtr := GetProcAddress(procName[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddress(var procName: Byte): GLXFuncPtr := GetProcAddress(@procName);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetProcAddress(procName: pointer): GLXFuncPtr := z_GetProcAddress(procName);
    
    public z_MakeContextCurrent: function(dpy: PDisplay; draw: GLXDrawable; read: GLXDrawable; ctx: GLXContext): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; draw: GLXDrawable; read: GLXDrawable; ctx: GLXContext): UInt32>(GetGLProcAdr('glXMakeContextCurrent'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeContextCurrent(dpy: PDisplay; draw: GLXDrawable; read: GLXDrawable; ctx: GLXContext): UInt32 := z_MakeContextCurrent(dpy, draw, read, ctx);
    
    public z_QueryContext: function(dpy: PDisplay; ctx: GLXContext; attribute: Int32; value: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; ctx: GLXContext; attribute: Int32; value: pointer): Int32>(GetGLProcAdr('glXQueryContext'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContext(dpy: PDisplay; ctx: GLXContext; attribute: Int32; value: array of Int32): Int32 := QueryContext(dpy, ctx, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContext(dpy: PDisplay; ctx: GLXContext; attribute: Int32; var value: Int32): Int32 := QueryContext(dpy, ctx, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContext(dpy: PDisplay; ctx: GLXContext; attribute: Int32; value: pointer): Int32 := z_QueryContext(dpy, ctx, attribute, value);
    
    public z_QueryDrawable: procedure(dpy: PDisplay; draw: GLXDrawable; attribute: Int32; value: pointer) := FuncPtrOrNil&<procedure(dpy: PDisplay; draw: GLXDrawable; attribute: Int32; value: pointer)>(GetGLProcAdr('glXQueryDrawable'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryDrawable(dpy: PDisplay; draw: GLXDrawable; attribute: Int32; value: array of UInt32) := QueryDrawable(dpy, draw, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryDrawable(dpy: PDisplay; draw: GLXDrawable; attribute: Int32; var value: UInt32) := QueryDrawable(dpy, draw, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryDrawable(dpy: PDisplay; draw: GLXDrawable; attribute: Int32; value: pointer) := z_QueryDrawable(dpy, draw, attribute, value);
    
    {$endregion Unsorted}
    
    {$region EXT_import_context}
    
    public z_GetCurrentDisplayEXT: function: PDisplay := FuncPtrOrNil&<function: PDisplay>(GetGLProcAdr('glXGetCurrentDisplayEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentDisplayEXT: PDisplay := z_GetCurrentDisplayEXT();
    
    public z_QueryContextInfoEXT: function(dpy: PDisplay; context: GLXContext; attribute: Int32; value: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; context: GLXContext; attribute: Int32; value: pointer): Int32>(GetGLProcAdr('glXQueryContextInfoEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: PDisplay; context: GLXContext; attribute: Int32; value: array of Int32): Int32 := QueryContextInfoEXT(dpy, context, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: PDisplay; context: GLXContext; attribute: Int32; var value: Int32): Int32 := QueryContextInfoEXT(dpy, context, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryContextInfoEXT(dpy: PDisplay; context: GLXContext; attribute: Int32; value: pointer): Int32 := z_QueryContextInfoEXT(dpy, context, attribute, value);
    
    public z_ImportContextEXT: function(dpy: PDisplay; contextID: GLXContextID): GLXContext := FuncPtrOrNil&<function(dpy: PDisplay; contextID: GLXContextID): GLXContext>(GetGLProcAdr('glXImportContextEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportContextEXT(dpy: PDisplay; contextID: GLXContextID): GLXContext := z_ImportContextEXT(dpy, contextID);
    
    public z_FreeContextEXT: procedure(dpy: PDisplay; context: GLXContext) := FuncPtrOrNil&<procedure(dpy: PDisplay; context: GLXContext)>(GetGLProcAdr('glXFreeContextEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeContextEXT(dpy: PDisplay; context: GLXContext) := z_FreeContextEXT(dpy, context);
    
    {$endregion EXT_import_context}
    
    {$region EXT_texture_from_pixmap}
    
    public z_BindTexImageEXT: procedure(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32; attrib_list: pointer) := FuncPtrOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32; attrib_list: pointer)>(GetGLProcAdr('glXBindTexImageEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32; attrib_list: array of Int32) := BindTexImageEXT(dpy, drawable, buffer, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32; var attrib_list: Int32) := BindTexImageEXT(dpy, drawable, buffer, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindTexImageEXT(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32; attrib_list: pointer) := z_BindTexImageEXT(dpy, drawable, buffer, attrib_list);
    
    public z_ReleaseTexImageEXT: procedure(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32) := FuncPtrOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32)>(GetGLProcAdr('glXReleaseTexImageEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReleaseTexImageEXT(dpy: PDisplay; drawable: GLXDrawable; buffer: Int32) := z_ReleaseTexImageEXT(dpy, drawable, buffer);
    
    {$endregion EXT_texture_from_pixmap}
    
    {$region GLX_NV_copy_buffer}
    
    public z_CopyBufferSubDataNV: procedure(dpy: PDisplay; readCtx: GLXContext; writeCtx: GLXContext; readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := FuncPtrOrNil&<procedure(dpy: PDisplay; readCtx: GLXContext; writeCtx: GLXContext; readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(GetGLProcAdr('glXCopyBufferSubDataNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyBufferSubDataNV(dpy: PDisplay; readCtx: GLXContext; writeCtx: GLXContext; readTarget: DummyEnum; writeTarget: DummyEnum; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_CopyBufferSubDataNV(dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size);
    
    public z_NamedCopyBufferSubDataNV: procedure(dpy: PDisplay; readCtx: GLXContext; writeCtx: GLXContext; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := FuncPtrOrNil&<procedure(dpy: PDisplay; readCtx: GLXContext; writeCtx: GLXContext; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(GetGLProcAdr('glXNamedCopyBufferSubDataNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedCopyBufferSubDataNV(dpy: PDisplay; readCtx: GLXContext; writeCtx: GLXContext; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_NamedCopyBufferSubDataNV(dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    {$endregion GLX_NV_copy_buffer}
    
    {$region MESA_agp_offset}
    
    public z_GetAGPOffsetMESA: function(_pointer: pointer): UInt32 := FuncPtrOrNil&<function(_pointer: pointer): UInt32>(GetGLProcAdr('glXGetAGPOffsetMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetAGPOffsetMESA(_pointer: pointer): UInt32 := z_GetAGPOffsetMESA(_pointer);
    
    {$endregion MESA_agp_offset}
    
    {$region MESA_copy_sub_buffer}
    
    public z_CopySubBufferMESA: procedure(dpy: PDisplay; drawable: GLXDrawable; x: Int32; y: Int32; width: Int32; height: Int32) := FuncPtrOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; x: Int32; y: Int32; width: Int32; height: Int32)>(GetGLProcAdr('glXCopySubBufferMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopySubBufferMESA(dpy: PDisplay; drawable: GLXDrawable; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopySubBufferMESA(dpy, drawable, x, y, width, height);
    
    {$endregion MESA_copy_sub_buffer}
    
    {$region MESA_pixmap_colormap}
    
    public z_CreateGLXPixmapMESA: function(dpy: PDisplay; visual: PXVisualInfo; pixmap: GLXPixmap; cmap: GLXColormap): GLXPixmap := FuncPtrOrNil&<function(dpy: PDisplay; visual: PXVisualInfo; pixmap: GLXPixmap; cmap: GLXColormap): GLXPixmap>(GetGLProcAdr('glXCreateGLXPixmapMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPixmapMESA(dpy: PDisplay; visual: PXVisualInfo; pixmap: GLXPixmap; cmap: GLXColormap): GLXPixmap := z_CreateGLXPixmapMESA(dpy, visual, pixmap, cmap);
    
    {$endregion MESA_pixmap_colormap}
    
    {$region MESA_query_renderer}
    
    public z_QueryRendererIntegerMESA: function(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32; value: pointer): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32; value: pointer): UInt32>(GetGLProcAdr('glXQueryRendererIntegerMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32; value: array of UInt32): UInt32 := QueryRendererIntegerMESA(dpy, screen, renderer, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32; var value: UInt32): UInt32 := QueryRendererIntegerMESA(dpy, screen, renderer, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererIntegerMESA(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32; value: pointer): UInt32 := z_QueryRendererIntegerMESA(dpy, screen, renderer, attribute, value);
    
    public z_QueryCurrentRendererIntegerMESA: function(attribute: Int32; value: pointer): UInt32 := FuncPtrOrNil&<function(attribute: Int32; value: pointer): UInt32>(GetGLProcAdr('glXQueryCurrentRendererIntegerMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; value: array of UInt32): UInt32 := QueryCurrentRendererIntegerMESA(attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; var value: UInt32): UInt32 := QueryCurrentRendererIntegerMESA(attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererIntegerMESA(attribute: Int32; value: pointer): UInt32 := z_QueryCurrentRendererIntegerMESA(attribute, value);
    
    public z_QueryRendererStringMESA: function(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32): IntPtr := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32): IntPtr>(GetGLProcAdr('glXQueryRendererStringMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererStringMESA_Str(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32): string := Marshal.PtrToStringAnsi(z_QueryRendererStringMESA(dpy, screen, renderer, attribute));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryRendererStringMESA(dpy: PDisplay; screen: Int32; renderer: Int32; attribute: Int32): IntPtr := z_QueryRendererStringMESA(dpy, screen, renderer, attribute);
    
    public z_QueryCurrentRendererStringMESA: function(attribute: Int32): IntPtr := FuncPtrOrNil&<function(attribute: Int32): IntPtr>(GetGLProcAdr('glXQueryCurrentRendererStringMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererStringMESA_Str(attribute: Int32): string := Marshal.PtrToStringAnsi(z_QueryCurrentRendererStringMESA(attribute));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryCurrentRendererStringMESA(attribute: Int32): IntPtr := z_QueryCurrentRendererStringMESA(attribute);
    
    {$endregion MESA_query_renderer}
    
    {$region MESA_release_buffers}
    
    public z_ReleaseBuffersMESA: function(dpy: PDisplay; drawable: GLXDrawable): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; drawable: GLXDrawable): UInt32>(GetGLProcAdr('glXReleaseBuffersMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseBuffersMESA(dpy: PDisplay; drawable: GLXDrawable): UInt32 := z_ReleaseBuffersMESA(dpy, drawable);
    
    {$endregion MESA_release_buffers}
    
    {$region MESA_set_3dfx_mode}
    
    public z_Set3DfxModeMESA: function(mode: Int32): Byte := FuncPtrOrNil&<function(mode: Int32): Byte>(GetGLProcAdr('glXSet3DfxModeMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function Set3DfxModeMESA(mode: Int32): Byte := z_Set3DfxModeMESA(mode);
    
    {$endregion MESA_set_3dfx_mode}
    
    {$region MESA_swap_control}
    
    public z_GetSwapIntervalMESA: function: Int32 := FuncPtrOrNil&<function: Int32>(GetGLProcAdr('glXGetSwapIntervalMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetSwapIntervalMESA: Int32 := z_GetSwapIntervalMESA();
    
    {$endregion MESA_swap_control}
    
    {$region SGI_make_current_read}
    
    public z_MakeCurrentReadSGI: function(dpy: PDisplay; draw: GLXDrawable; read: GLXDrawable; ctx: GLXContext): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; draw: GLXDrawable; read: GLXDrawable; ctx: GLXContext): UInt32>(GetGLProcAdr('glXMakeCurrentReadSGI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MakeCurrentReadSGI(dpy: PDisplay; draw: GLXDrawable; read: GLXDrawable; ctx: GLXContext): UInt32 := z_MakeCurrentReadSGI(dpy, draw, read, ctx);
    
    public z_GetCurrentReadDrawable: function: GLXDrawable := FuncPtrOrNil&<function: GLXDrawable>(GetGLProcAdr('glXGetCurrentReadDrawable'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCurrentReadDrawable: GLXDrawable := z_GetCurrentReadDrawable();
    
    {$endregion SGI_make_current_read}
    
    {$region SGI_video_sync}
    
    public z_GetVideoSyncSGI: function(count: pointer): Int32 := FuncPtrOrNil&<function(count: pointer): Int32>(GetGLProcAdr('glXGetVideoSyncSGI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoSyncSGI(count: array of UInt32): Int32 := GetVideoSyncSGI(count[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoSyncSGI(var count: UInt32): Int32 := GetVideoSyncSGI(@count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVideoSyncSGI(count: pointer): Int32 := z_GetVideoSyncSGI(count);
    
    public z_WaitVideoSyncSGI: function(divisor: Int32; remainder: Int32; count: pointer): Int32 := FuncPtrOrNil&<function(divisor: Int32; remainder: Int32; count: pointer): Int32>(GetGLProcAdr('glXWaitVideoSyncSGI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; count: array of UInt32): Int32 := WaitVideoSyncSGI(divisor, remainder, count[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; var count: UInt32): Int32 := WaitVideoSyncSGI(divisor, remainder, @count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function WaitVideoSyncSGI(divisor: Int32; remainder: Int32; count: pointer): Int32 := z_WaitVideoSyncSGI(divisor, remainder, count);
    
    {$endregion SGI_video_sync}
    
    {$region SGIX_fbconfig}
    
    public z_GetFBConfigAttrib: function(dpy: PDisplay; config: GLXFBConfig; attribute: Int32; value: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; config: GLXFBConfig; attribute: Int32; value: pointer): Int32>(GetGLProcAdr('glXGetFBConfigAttrib'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigAttrib(dpy: PDisplay; config: GLXFBConfig; attribute: Int32; value: array of Int32): Int32 := GetFBConfigAttrib(dpy, config, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigAttrib(dpy: PDisplay; config: GLXFBConfig; attribute: Int32; var value: Int32): Int32 := GetFBConfigAttrib(dpy, config, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigAttrib(dpy: PDisplay; config: GLXFBConfig; attribute: Int32; value: pointer): Int32 := z_GetFBConfigAttrib(dpy, config, attribute, value);
    
    public z_ChooseFBConfig: function(dpy: PDisplay; screen: Int32; attrib_list: pointer; nelements: pointer): pointer := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; attrib_list: pointer; nelements: pointer): pointer>(GetGLProcAdr('glXChooseFBConfig'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfig(dpy: PDisplay; screen: Int32; attrib_list: array of Int32; nelements: array of Int32): pointer := ChooseFBConfig(dpy, screen, attrib_list[0], nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfig(dpy: PDisplay; screen: Int32; attrib_list: array of Int32; var nelements: Int32): pointer := ChooseFBConfig(dpy, screen, attrib_list[0], @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfig(dpy: PDisplay; screen: Int32; attrib_list: array of Int32; nelements: pointer): pointer := ChooseFBConfig(dpy, screen, attrib_list[0], nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfig(dpy: PDisplay; screen: Int32; var attrib_list: Int32; nelements: array of Int32): pointer := ChooseFBConfig(dpy, screen, @attrib_list, nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfig(dpy: PDisplay; screen: Int32; var attrib_list: Int32; var nelements: Int32): pointer := ChooseFBConfig(dpy, screen, @attrib_list, @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfig(dpy: PDisplay; screen: Int32; var attrib_list: Int32; nelements: pointer): pointer := ChooseFBConfig(dpy, screen, @attrib_list, nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfig(dpy: PDisplay; screen: Int32; attrib_list: pointer; nelements: array of Int32): pointer := ChooseFBConfig(dpy, screen, attrib_list, nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfig(dpy: PDisplay; screen: Int32; attrib_list: pointer; var nelements: Int32): pointer := ChooseFBConfig(dpy, screen, attrib_list, @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChooseFBConfig(dpy: PDisplay; screen: Int32; attrib_list: pointer; nelements: pointer): pointer := z_ChooseFBConfig(dpy, screen, attrib_list, nelements);
    
    public z_CreateGLXPixmapWithConfigSGIX: function(dpy: PDisplay; config: GLXFBConfig; pixmap: GLXPixmap): GLXPixmap := FuncPtrOrNil&<function(dpy: PDisplay; config: GLXFBConfig; pixmap: GLXPixmap): GLXPixmap>(GetGLProcAdr('glXCreateGLXPixmapWithConfigSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPixmapWithConfigSGIX(dpy: PDisplay; config: GLXFBConfig; pixmap: GLXPixmap): GLXPixmap := z_CreateGLXPixmapWithConfigSGIX(dpy, config, pixmap);
    
    public z_CreateContextWithConfigSGIX: function(dpy: PDisplay; config: GLXFBConfig; render_type: Int32; share_list: GLXContext; direct: UInt32): GLXContext := FuncPtrOrNil&<function(dpy: PDisplay; config: GLXFBConfig; render_type: Int32; share_list: GLXContext; direct: UInt32): GLXContext>(GetGLProcAdr('glXCreateContextWithConfigSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextWithConfigSGIX(dpy: PDisplay; config: GLXFBConfig; render_type: Int32; share_list: GLXContext; direct: UInt32): GLXContext := z_CreateContextWithConfigSGIX(dpy, config, render_type, share_list, direct);
    
    public z_GetVisualFromFBConfig: function(dpy: PDisplay; config: GLXFBConfig): PXVisualInfo := FuncPtrOrNil&<function(dpy: PDisplay; config: GLXFBConfig): PXVisualInfo>(GetGLProcAdr('glXGetVisualFromFBConfig'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVisualFromFBConfig(dpy: PDisplay; config: GLXFBConfig): PXVisualInfo := z_GetVisualFromFBConfig(dpy, config);
    
    public z_GetFBConfigFromVisualSGIX: function(dpy: PDisplay; vis: PXVisualInfo): GLXFBConfig := FuncPtrOrNil&<function(dpy: PDisplay; vis: PXVisualInfo): GLXFBConfig>(GetGLProcAdr('glXGetFBConfigFromVisualSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFBConfigFromVisualSGIX(dpy: PDisplay; vis: PXVisualInfo): GLXFBConfig := z_GetFBConfigFromVisualSGIX(dpy, vis);
    
    {$endregion SGIX_fbconfig}
    
    {$region SGIX_hyperpipe}
    
    public z_QueryHyperpipeNetworkSGIX: function(dpy: PDisplay; npipes: pointer): pointer := FuncPtrOrNil&<function(dpy: PDisplay; npipes: pointer): pointer>(GetGLProcAdr('glXQueryHyperpipeNetworkSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeNetworkSGIX(dpy: PDisplay; npipes: array of Int32): pointer := QueryHyperpipeNetworkSGIX(dpy, npipes[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeNetworkSGIX(dpy: PDisplay; var npipes: Int32): pointer := QueryHyperpipeNetworkSGIX(dpy, @npipes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeNetworkSGIX(dpy: PDisplay; npipes: pointer): pointer := z_QueryHyperpipeNetworkSGIX(dpy, npipes);
    
    public z_HyperpipeConfigSGIX: function(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: pointer; hpId: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: pointer; hpId: pointer): Int32>(GetGLProcAdr('glXHyperpipeConfigSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: array of GLXHyperpipeConfigDataSGIX; hpId: array of Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, cfg[0], hpId[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: array of GLXHyperpipeConfigDataSGIX; var hpId: Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, cfg[0], @hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: array of GLXHyperpipeConfigDataSGIX; hpId: pointer): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, cfg[0], hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; var cfg: GLXHyperpipeConfigDataSGIX; hpId: array of Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, @cfg, hpId[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; var cfg: GLXHyperpipeConfigDataSGIX; var hpId: Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, @cfg, @hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; var cfg: GLXHyperpipeConfigDataSGIX; hpId: pointer): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, @cfg, hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: pointer; hpId: array of Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, cfg, hpId[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: pointer; var hpId: Int32): Int32 := HyperpipeConfigSGIX(dpy, networkId, npipes, cfg, @hpId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeConfigSGIX(dpy: PDisplay; networkId: Int32; npipes: Int32; cfg: pointer; hpId: pointer): Int32 := z_HyperpipeConfigSGIX(dpy, networkId, npipes, cfg, hpId);
    
    public z_QueryHyperpipeConfigSGIX: function(dpy: PDisplay; hpId: Int32; npipes: pointer): pointer := FuncPtrOrNil&<function(dpy: PDisplay; hpId: Int32; npipes: pointer): pointer>(GetGLProcAdr('glXQueryHyperpipeConfigSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeConfigSGIX(dpy: PDisplay; hpId: Int32; npipes: array of Int32): pointer := QueryHyperpipeConfigSGIX(dpy, hpId, npipes[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeConfigSGIX(dpy: PDisplay; hpId: Int32; var npipes: Int32): pointer := QueryHyperpipeConfigSGIX(dpy, hpId, @npipes);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeConfigSGIX(dpy: PDisplay; hpId: Int32; npipes: pointer): pointer := z_QueryHyperpipeConfigSGIX(dpy, hpId, npipes);
    
    public z_DestroyHyperpipeConfigSGIX: function(dpy: PDisplay; hpId: Int32): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; hpId: Int32): Int32>(GetGLProcAdr('glXDestroyHyperpipeConfigSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function DestroyHyperpipeConfigSGIX(dpy: PDisplay; hpId: Int32): Int32 := z_DestroyHyperpipeConfigSGIX(dpy, hpId);
    
    public z_BindHyperpipeSGIX: function(dpy: PDisplay; hpId: Int32): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; hpId: Int32): Int32>(GetGLProcAdr('glXBindHyperpipeSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindHyperpipeSGIX(dpy: PDisplay; hpId: Int32): Int32 := z_BindHyperpipeSGIX(dpy, hpId);
    
    public z_QueryHyperpipeBestAttribSGIX: function(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; attribList: pointer; returnAttribList: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; attribList: pointer; returnAttribList: pointer): Int32>(GetGLProcAdr('glXQueryHyperpipeBestAttribSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeBestAttribSGIX(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; attribList: pointer; returnAttribList: pointer): Int32 := z_QueryHyperpipeBestAttribSGIX(dpy, timeSlice, attrib, size, attribList, returnAttribList);
    
    public z_HyperpipeAttribSGIX: function(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; attribList: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; attribList: pointer): Int32>(GetGLProcAdr('glXHyperpipeAttribSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function HyperpipeAttribSGIX(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; attribList: pointer): Int32 := z_HyperpipeAttribSGIX(dpy, timeSlice, attrib, size, attribList);
    
    public z_QueryHyperpipeAttribSGIX: function(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: pointer): Int32>(GetGLProcAdr('glXQueryHyperpipeAttribSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryHyperpipeAttribSGIX(dpy: PDisplay; timeSlice: Int32; attrib: Int32; size: Int32; returnAttribList: pointer): Int32 := z_QueryHyperpipeAttribSGIX(dpy, timeSlice, attrib, size, returnAttribList);
    
    {$endregion SGIX_hyperpipe}
    
    {$region SGIX_pbuffer}
    
    public z_CreateGLXPbufferSGIX: function(dpy: PDisplay; config: GLXFBConfig; width: UInt32; height: UInt32; attrib_list: pointer): GLXPbuffer := FuncPtrOrNil&<function(dpy: PDisplay; config: GLXFBConfig; width: UInt32; height: UInt32; attrib_list: pointer): GLXPbuffer>(GetGLProcAdr('glXCreateGLXPbufferSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: PDisplay; config: GLXFBConfig; width: UInt32; height: UInt32; attrib_list: array of Int32): GLXPbuffer := CreateGLXPbufferSGIX(dpy, config, width, height, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: PDisplay; config: GLXFBConfig; width: UInt32; height: UInt32; var attrib_list: Int32): GLXPbuffer := CreateGLXPbufferSGIX(dpy, config, width, height, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateGLXPbufferSGIX(dpy: PDisplay; config: GLXFBConfig; width: UInt32; height: UInt32; attrib_list: pointer): GLXPbuffer := z_CreateGLXPbufferSGIX(dpy, config, width, height, attrib_list);
    
    public z_DestroyGLXPbufferSGIX: procedure(dpy: PDisplay; pbuf: GLXPbuffer) := FuncPtrOrNil&<procedure(dpy: PDisplay; pbuf: GLXPbuffer)>(GetGLProcAdr('glXDestroyGLXPbufferSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DestroyGLXPbufferSGIX(dpy: PDisplay; pbuf: GLXPbuffer) := z_DestroyGLXPbufferSGIX(dpy, pbuf);
    
    public z_QueryGLXPbufferSGIX: procedure(dpy: PDisplay; pbuf: GLXPbuffer; attribute: Int32; value: pointer) := FuncPtrOrNil&<procedure(dpy: PDisplay; pbuf: GLXPbuffer; attribute: Int32; value: pointer)>(GetGLProcAdr('glXQueryGLXPbufferSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: PDisplay; pbuf: GLXPbuffer; attribute: Int32; value: array of UInt32) := QueryGLXPbufferSGIX(dpy, pbuf, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: PDisplay; pbuf: GLXPbuffer; attribute: Int32; var value: UInt32) := QueryGLXPbufferSGIX(dpy, pbuf, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryGLXPbufferSGIX(dpy: PDisplay; pbuf: GLXPbuffer; attribute: Int32; value: pointer) := z_QueryGLXPbufferSGIX(dpy, pbuf, attribute, value);
    
    public z_SelectEvent: procedure(dpy: PDisplay; draw: GLXDrawable; event_mask: UInt64) := FuncPtrOrNil&<procedure(dpy: PDisplay; draw: GLXDrawable; event_mask: UInt64)>(GetGLProcAdr('glXSelectEvent'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectEvent(dpy: PDisplay; draw: GLXDrawable; event_mask: UInt64) := z_SelectEvent(dpy, draw, event_mask);
    
    public z_GetSelectedEvent: procedure(dpy: PDisplay; draw: GLXDrawable; event_mask: pointer) := FuncPtrOrNil&<procedure(dpy: PDisplay; draw: GLXDrawable; event_mask: pointer)>(GetGLProcAdr('glXGetSelectedEvent'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEvent(dpy: PDisplay; draw: GLXDrawable; event_mask: array of UInt64) := GetSelectedEvent(dpy, draw, event_mask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEvent(dpy: PDisplay; draw: GLXDrawable; var event_mask: UInt64) := GetSelectedEvent(dpy, draw, @event_mask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSelectedEvent(dpy: PDisplay; draw: GLXDrawable; event_mask: pointer) := z_GetSelectedEvent(dpy, draw, event_mask);
    
    {$endregion SGIX_pbuffer}
    
    {$region SGIX_swap_barrier}
    
    public z_QueryMaxSwapBarriersSGIX: function(dpy: PDisplay; screen: Int32; max: pointer): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; max: pointer): UInt32>(GetGLProcAdr('glXQueryMaxSwapBarriersSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: PDisplay; screen: Int32; max: array of Int32): UInt32 := QueryMaxSwapBarriersSGIX(dpy, screen, max[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: PDisplay; screen: Int32; var max: Int32): UInt32 := QueryMaxSwapBarriersSGIX(dpy, screen, @max);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMaxSwapBarriersSGIX(dpy: PDisplay; screen: Int32; max: pointer): UInt32 := z_QueryMaxSwapBarriersSGIX(dpy, screen, max);
    
    {$endregion SGIX_swap_barrier}
    
    {$region SGIX_video_resize}
    
    public z_BindChannelToWindowSGIX: function(display: PDisplay; screen: Int32; channel: Int32; window: GLXWindow): Int32 := FuncPtrOrNil&<function(display: PDisplay; screen: Int32; channel: Int32; window: GLXWindow): Int32>(GetGLProcAdr('glXBindChannelToWindowSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindChannelToWindowSGIX(display: PDisplay; screen: Int32; channel: Int32; window: GLXWindow): Int32 := z_BindChannelToWindowSGIX(display, screen, channel, window);
    
    public z_ChannelRectSGIX: function(display: PDisplay; screen: Int32; channel: Int32; x: Int32; y: Int32; w: Int32; h: Int32): Int32 := FuncPtrOrNil&<function(display: PDisplay; screen: Int32; channel: Int32; x: Int32; y: Int32; w: Int32; h: Int32): Int32>(GetGLProcAdr('glXChannelRectSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; x: Int32; y: Int32; w: Int32; h: Int32): Int32 := z_ChannelRectSGIX(display, screen, channel, x, y, w, h);
    
    public z_QueryChannelRectSGIX: function(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: pointer; dh: pointer): Int32 := FuncPtrOrNil&<function(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: pointer; dh: pointer): Int32>(GetGLProcAdr('glXQueryChannelRectSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: array of Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy[0], dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; var dy: Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], @dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: array of Int32; dy: pointer; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx[0], dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: array of Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy[0], dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; var dy: Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, @dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; var dx: Int32; dy: pointer; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, @dx, dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: array of Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy[0], dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; var dy: Int32; dw: pointer; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, @dy, dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: array of Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, dw[0], dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: array of Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, dw[0], @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: array of Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, dw[0], dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; var dw: Int32; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, @dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; var dw: Int32; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, @dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; var dw: Int32; dh: pointer): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, @dw, dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: pointer; dh: array of Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, dw, dh[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: pointer; var dh: Int32): Int32 := QueryChannelRectSGIX(display, screen, channel, dx, dy, dw, @dh);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelRectSGIX(display: PDisplay; screen: Int32; channel: Int32; dx: pointer; dy: pointer; dw: pointer; dh: pointer): Int32 := z_QueryChannelRectSGIX(display, screen, channel, dx, dy, dw, dh);
    
    public z_QueryChannelDeltasSGIX: function(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: pointer; h: pointer): Int32 := FuncPtrOrNil&<function(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: pointer; h: pointer): Int32>(GetGLProcAdr('glXQueryChannelDeltasSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: array of Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y[0], w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; var y: Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], @y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: array of Int32; y: pointer; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x[0], y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: array of Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y[0], w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; var y: Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, @y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; var x: Int32; y: pointer; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, @x, y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: array of Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y[0], w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; var y: Int32; w: pointer; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, @y, w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: array of Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, w[0], h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: array of Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, w[0], @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: array of Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, w[0], h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; var w: Int32; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, @w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; var w: Int32; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, @w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; var w: Int32; h: pointer): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, @w, h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: pointer; h: array of Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, w, h[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: pointer; var h: Int32): Int32 := QueryChannelDeltasSGIX(display, screen, channel, x, y, w, @h);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryChannelDeltasSGIX(display: PDisplay; screen: Int32; channel: Int32; x: pointer; y: pointer; w: pointer; h: pointer): Int32 := z_QueryChannelDeltasSGIX(display, screen, channel, x, y, w, h);
    
    public z_ChannelRectSyncSGIX: function(display: PDisplay; screen: Int32; channel: Int32; synctype: DummyEnum): Int32 := FuncPtrOrNil&<function(display: PDisplay; screen: Int32; channel: Int32; synctype: DummyEnum): Int32>(GetGLProcAdr('glXChannelRectSyncSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ChannelRectSyncSGIX(display: PDisplay; screen: Int32; channel: Int32; synctype: DummyEnum): Int32 := z_ChannelRectSyncSGIX(display, screen, channel, synctype);
    
    {$endregion SGIX_video_resize}
    
    {$region SUN_get_transparent_index}
    
    public z_GetTransparentIndexSUN: function(dpy: PDisplay; overlay: GLXWindow; underlay: GLXWindow; pTransparentIndex: pointer): GLXStatus := FuncPtrOrNil&<function(dpy: PDisplay; overlay: GLXWindow; underlay: GLXWindow; pTransparentIndex: pointer): GLXStatus>(GetGLProcAdr('glXGetTransparentIndexSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTransparentIndexSUN(dpy: PDisplay; overlay: GLXWindow; underlay: GLXWindow; pTransparentIndex: array of UInt64): GLXStatus := GetTransparentIndexSUN(dpy, overlay, underlay, pTransparentIndex[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTransparentIndexSUN(dpy: PDisplay; overlay: GLXWindow; underlay: GLXWindow; var pTransparentIndex: UInt64): GLXStatus := GetTransparentIndexSUN(dpy, overlay, underlay, @pTransparentIndex);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTransparentIndexSUN(dpy: PDisplay; overlay: GLXWindow; underlay: GLXWindow; pTransparentIndex: pointer): GLXStatus := z_GetTransparentIndexSUN(dpy, overlay, underlay, pTransparentIndex);
    
    {$endregion SUN_get_transparent_index}
    
    {$region AMD_gpu_association, EXT_import_context}
    
    public z_GetContextGPUIDAMD: function(ctx: GLXContext): UInt32 := FuncPtrOrNil&<function(ctx: GLXContext): UInt32>(GetGLProcAdr('glXGetContextGPUIDAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetContextGPUIDAMD(ctx: GLXContext): UInt32 := z_GetContextGPUIDAMD(ctx);
    
    {$endregion AMD_gpu_association, EXT_import_context}
    
    {$region ARB_create_context, ARB_create_context_profile}
    
    public z_CreateContextAttribsARB: function(dpy: PDisplay; config: GLXFBConfig; share_context: GLXContext; direct: UInt32; attrib_list: pointer): GLXContext := FuncPtrOrNil&<function(dpy: PDisplay; config: GLXFBConfig; share_context: GLXContext; direct: UInt32; attrib_list: pointer): GLXContext>(GetGLProcAdr('glXCreateContextAttribsARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: PDisplay; config: GLXFBConfig; share_context: GLXContext; direct: UInt32; attrib_list: array of Int32): GLXContext := CreateContextAttribsARB(dpy, config, share_context, direct, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: PDisplay; config: GLXFBConfig; share_context: GLXContext; direct: UInt32; var attrib_list: Int32): GLXContext := CreateContextAttribsARB(dpy, config, share_context, direct, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateContextAttribsARB(dpy: PDisplay; config: GLXFBConfig; share_context: GLXContext; direct: UInt32; attrib_list: pointer): GLXContext := z_CreateContextAttribsARB(dpy, config, share_context, direct, attrib_list);
    
    {$endregion ARB_create_context, ARB_create_context_profile}
    
    {$region NV_swap_group, SGIX_swap_barrier}
    
    public z_BindSwapBarrierNV: function(dpy: PDisplay; group: UInt32; barrier: UInt32): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; group: UInt32; barrier: UInt32): UInt32>(GetGLProcAdr('glXBindSwapBarrierNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindSwapBarrierNV(dpy: PDisplay; group: UInt32; barrier: UInt32): UInt32 := z_BindSwapBarrierNV(dpy, group, barrier);
    
    {$endregion NV_swap_group, SGIX_swap_barrier}
    
    {$region NV_swap_group, SGIX_swap_group}
    
    public z_JoinSwapGroupNV: function(dpy: PDisplay; drawable: GLXDrawable; group: UInt32): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; group: UInt32): UInt32>(GetGLProcAdr('glXJoinSwapGroupNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function JoinSwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: UInt32): UInt32 := z_JoinSwapGroupNV(dpy, drawable, group);
    
    {$endregion NV_swap_group, SGIX_swap_group}
    
    {$region EXT_swap_control, MESA_swap_control, SGI_swap_control}
    
    public z_SwapIntervalEXT: procedure(dpy: PDisplay; drawable: GLXDrawable; interval: Int32) := FuncPtrOrNil&<procedure(dpy: PDisplay; drawable: GLXDrawable; interval: Int32)>(GetGLProcAdr('glXSwapIntervalEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SwapIntervalEXT(dpy: PDisplay; drawable: GLXDrawable; interval: Int32) := z_SwapIntervalEXT(dpy, drawable, interval);
    
    {$endregion EXT_swap_control, MESA_swap_control, SGI_swap_control}
    
  end;
  
  gl_ARB = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region ARB_cl_event}
    
    public z_CreateSyncFromCLeventARB: function(context: pointer; &event: pointer; flags: DummyFlags): GLsync := FuncPtrOrNil&<function(context: pointer; &event: pointer; flags: DummyFlags): GLsync>(GetGLProcAdr('glCreateSyncFromCLeventARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: array of cl_context; &event: array of cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(context[0], &event[0], flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: array of cl_context; var &event: cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(context[0], @&event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: array of cl_context; &event: pointer; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(context[0], &event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(var context: cl_context; &event: array of cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(@context, &event[0], flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(var context: cl_context; var &event: cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(@context, @&event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(var context: cl_context; &event: pointer; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(@context, &event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: pointer; &event: array of cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(context, &event[0], flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: pointer; var &event: cl_event; flags: DummyFlags): GLsync := CreateSyncFromCLeventARB(context, @&event, flags);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateSyncFromCLeventARB(context: pointer; &event: pointer; flags: DummyFlags): GLsync := z_CreateSyncFromCLeventARB(context, &event, flags);
    
    {$endregion ARB_cl_event}
    
    {$region ARB_compute_variable_group_size}
    
    public z_DispatchComputeGroupSizeARB: procedure(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32; group_size_x: UInt32; group_size_y: UInt32; group_size_z: UInt32) := FuncPtrOrNil&<procedure(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32; group_size_x: UInt32; group_size_y: UInt32; group_size_z: UInt32)>(GetGLProcAdr('glDispatchComputeGroupSizeARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DispatchComputeGroupSizeARB(num_groups_x: UInt32; num_groups_y: UInt32; num_groups_z: UInt32; group_size_x: UInt32; group_size_y: UInt32; group_size_z: UInt32) := z_DispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
    
    {$endregion ARB_compute_variable_group_size}
    
    {$region ARB_gpu_shader_int64}
    
    public z_GetnUniformi64vARB: procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>(GetGLProcAdr('glGetnUniformi64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformi64vARB(&program: UInt32; location: Int32; bufSize: Int32; &params: array of Int64) := GetnUniformi64vARB(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformi64vARB(&program: UInt32; location: Int32; bufSize: Int32; var &params: Int64) := GetnUniformi64vARB(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformi64vARB(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformi64vARB(&program, location, bufSize, &params);
    
    public z_GetnUniformui64vARB: procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer)>(GetGLProcAdr('glGetnUniformui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformui64vARB(&program: UInt32; location: Int32; bufSize: Int32; &params: array of UInt64) := GetnUniformui64vARB(&program, location, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformui64vARB(&program: UInt32; location: Int32; bufSize: Int32; var &params: UInt64) := GetnUniformui64vARB(&program, location, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetnUniformui64vARB(&program: UInt32; location: Int32; bufSize: Int32; &params: pointer) := z_GetnUniformui64vARB(&program, location, bufSize, &params);
    
    {$endregion ARB_gpu_shader_int64}
    
    {$region ARB_matrix_palette}
    
    public z_MatrixIndexubvARB: procedure(size: Int32; indices: pointer) := FuncPtrOrNil&<procedure(size: Int32; indices: pointer)>(GetGLProcAdr('glMatrixIndexubvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; indices: array of Byte) := MatrixIndexubvARB(size, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; var indices: Byte) := MatrixIndexubvARB(size, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexubvARB(size: Int32; indices: pointer) := z_MatrixIndexubvARB(size, indices);
    
    public z_MatrixIndexusvARB: procedure(size: Int32; indices: pointer) := FuncPtrOrNil&<procedure(size: Int32; indices: pointer)>(GetGLProcAdr('glMatrixIndexusvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; indices: array of UInt16) := MatrixIndexusvARB(size, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; var indices: UInt16) := MatrixIndexusvARB(size, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexusvARB(size: Int32; indices: pointer) := z_MatrixIndexusvARB(size, indices);
    
    public z_MatrixIndexuivARB: procedure(size: Int32; indices: pointer) := FuncPtrOrNil&<procedure(size: Int32; indices: pointer)>(GetGLProcAdr('glMatrixIndexuivARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; indices: array of UInt32) := MatrixIndexuivARB(size, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; var indices: UInt32) := MatrixIndexuivARB(size, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexuivARB(size: Int32; indices: pointer) := z_MatrixIndexuivARB(size, indices);
    
    {$endregion ARB_matrix_palette}
    
    {$region ARB_sample_locations}
    
    public z_EvaluateDepthValuesARB: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glEvaluateDepthValuesARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvaluateDepthValuesARB := z_EvaluateDepthValuesARB();
    
    {$endregion ARB_sample_locations}
    
    {$region ARB_shader_objects}
    
    public z_DeleteObjectARB: procedure(obj: GLhandleARB) := FuncPtrOrNil&<procedure(obj: GLhandleARB)>(GetGLProcAdr('glDeleteObjectARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteObjectARB(obj: GLhandleARB) := z_DeleteObjectARB(obj);
    
    public z_GetHandleARB: function(pname: DummyEnum): GLhandleARB := FuncPtrOrNil&<function(pname: DummyEnum): GLhandleARB>(GetGLProcAdr('glGetHandleARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetHandleARB(pname: DummyEnum): GLhandleARB := z_GetHandleARB(pname);
    
    public z_DetachObjectARB: procedure(containerObj: GLhandleARB; attachedObj: GLhandleARB) := FuncPtrOrNil&<procedure(containerObj: GLhandleARB; attachedObj: GLhandleARB)>(GetGLProcAdr('glDetachObjectARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetachObjectARB(containerObj: GLhandleARB; attachedObj: GLhandleARB) := z_DetachObjectARB(containerObj, attachedObj);
    
    public z_CreateShaderObjectARB: function(shaderType: DummyEnum): GLhandleARB := FuncPtrOrNil&<function(shaderType: DummyEnum): GLhandleARB>(GetGLProcAdr('glCreateShaderObjectARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderObjectARB(shaderType: DummyEnum): GLhandleARB := z_CreateShaderObjectARB(shaderType);
    
    public z_CreateProgramObjectARB: function: GLhandleARB := FuncPtrOrNil&<function: GLhandleARB>(GetGLProcAdr('glCreateProgramObjectARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgramObjectARB: GLhandleARB := z_CreateProgramObjectARB();
    
    public z_AttachObjectARB: procedure(containerObj: GLhandleARB; obj: GLhandleARB) := FuncPtrOrNil&<procedure(containerObj: GLhandleARB; obj: GLhandleARB)>(GetGLProcAdr('glAttachObjectARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AttachObjectARB(containerObj: GLhandleARB; obj: GLhandleARB) := z_AttachObjectARB(containerObj, obj);
    
    public z_UseProgramObjectARB: procedure(programObj: GLhandleARB) := FuncPtrOrNil&<procedure(programObj: GLhandleARB)>(GetGLProcAdr('glUseProgramObjectARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseProgramObjectARB(programObj: GLhandleARB) := z_UseProgramObjectARB(programObj);
    
    public z_GetObjectParameterfvARB: procedure(obj: GLhandleARB; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(obj: GLhandleARB; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetObjectParameterfvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterfvARB(obj: GLhandleARB; pname: DummyEnum; &params: array of single) := GetObjectParameterfvARB(obj, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterfvARB(obj: GLhandleARB; pname: DummyEnum; var &params: single) := GetObjectParameterfvARB(obj, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterfvARB(obj: GLhandleARB; pname: DummyEnum; &params: pointer) := z_GetObjectParameterfvARB(obj, pname, &params);
    
    public z_GetInfoLogARB: procedure(obj: GLhandleARB; maxLength: Int32; length: pointer; infoLog: pointer) := FuncPtrOrNil&<procedure(obj: GLhandleARB; maxLength: Int32; length: pointer; infoLog: pointer)>(GetGLProcAdr('glGetInfoLogARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: array of Int32; infoLog: array of Byte) := GetInfoLogARB(obj, maxLength, length[0], infoLog[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: array of Int32; var infoLog: Byte) := GetInfoLogARB(obj, maxLength, length[0], @infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: array of Int32; infoLog: pointer) := GetInfoLogARB(obj, maxLength, length[0], infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; var length: Int32; infoLog: array of Byte) := GetInfoLogARB(obj, maxLength, @length, infoLog[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; var length: Int32; var infoLog: Byte) := GetInfoLogARB(obj, maxLength, @length, @infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; var length: Int32; infoLog: pointer) := GetInfoLogARB(obj, maxLength, @length, infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: pointer; infoLog: array of Byte) := GetInfoLogARB(obj, maxLength, length, infoLog[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: pointer; var infoLog: Byte) := GetInfoLogARB(obj, maxLength, length, @infoLog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInfoLogARB(obj: GLhandleARB; maxLength: Int32; length: pointer; infoLog: pointer) := z_GetInfoLogARB(obj, maxLength, length, infoLog);
    
    public z_GetAttachedObjectsARB: procedure(containerObj: GLhandleARB; maxCount: Int32; count: pointer; obj: pointer) := FuncPtrOrNil&<procedure(containerObj: GLhandleARB; maxCount: Int32; count: pointer; obj: pointer)>(GetGLProcAdr('glGetAttachedObjectsARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: array of Int32; obj: array of GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, count[0], obj[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: array of Int32; var obj: GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, count[0], @obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: array of Int32; obj: pointer) := GetAttachedObjectsARB(containerObj, maxCount, count[0], obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; var count: Int32; obj: array of GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, @count, obj[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; var count: Int32; var obj: GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, @count, @obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; var count: Int32; obj: pointer) := GetAttachedObjectsARB(containerObj, maxCount, @count, obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: pointer; obj: array of GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, count, obj[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: pointer; var obj: GLhandleARB) := GetAttachedObjectsARB(containerObj, maxCount, count, @obj);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetAttachedObjectsARB(containerObj: GLhandleARB; maxCount: Int32; count: pointer; obj: pointer) := z_GetAttachedObjectsARB(containerObj, maxCount, count, obj);
    
    {$endregion ARB_shader_objects}
    
    {$region ARB_shading_language_include}
    
    public z_NamedStringARB: procedure(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; string: IntPtr) := FuncPtrOrNil&<procedure(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; string: IntPtr)>(GetGLProcAdr('glNamedStringARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: string; stringlen: Int32; _string: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(_string); var ptr3 := Marshal.StringToHGlobalAnsi(name); NamedStringARB(&type, namelen, ptr3, stringlen, ptr5); name := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); _string := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: string; stringlen: Int32; string: IntPtr); begin var ptr3 := Marshal.StringToHGlobalAnsi(name); NamedStringARB(&type, namelen, ptr3, stringlen, string); name := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; _string: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(_string); NamedStringARB(&type, namelen, name, stringlen, ptr5); _string := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedStringARB(&type: DummyEnum; namelen: Int32; name: IntPtr; stringlen: Int32; string: IntPtr) := z_NamedStringARB(&type, namelen, name, stringlen, string);
    
    public z_DeleteNamedStringARB: procedure(namelen: Int32; name: IntPtr) := FuncPtrOrNil&<procedure(namelen: Int32; name: IntPtr)>(GetGLProcAdr('glDeleteNamedStringARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamedStringARB(namelen: Int32; name: string); begin var ptr2 := Marshal.StringToHGlobalAnsi(name); DeleteNamedStringARB(namelen, ptr2); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamedStringARB(namelen: Int32; name: IntPtr) := z_DeleteNamedStringARB(namelen, name);
    
    public z_CompileShaderIncludeARB: procedure(shader: UInt32; count: Int32; path: pointer; length: pointer) := FuncPtrOrNil&<procedure(shader: UInt32; count: Int32; path: pointer; length: pointer)>(GetGLProcAdr('glCompileShaderIncludeARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: array of string; length: array of Int32) := CompileShaderIncludeARB(shader, count, path[0], length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: array of string; var length: Int32) := CompileShaderIncludeARB(shader, count, path[0], @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: array of string; length: pointer) := CompileShaderIncludeARB(shader, count, path[0], length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; var path: string; length: array of Int32) := CompileShaderIncludeARB(shader, count, @path, length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; var path: string; var length: Int32) := CompileShaderIncludeARB(shader, count, @path, @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; var path: string; length: pointer) := CompileShaderIncludeARB(shader, count, @path, length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: pointer; length: array of Int32) := CompileShaderIncludeARB(shader, count, path, length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: pointer; var length: Int32) := CompileShaderIncludeARB(shader, count, path, @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileShaderIncludeARB(shader: UInt32; count: Int32; path: pointer; length: pointer) := z_CompileShaderIncludeARB(shader, count, path, length);
    
    public z_IsNamedStringARB: function(namelen: Int32; name: IntPtr): Byte := FuncPtrOrNil&<function(namelen: Int32; name: IntPtr): Byte>(GetGLProcAdr('glIsNamedStringARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedStringARB(namelen: Int32; name: string): Byte; begin var ptr2 := Marshal.StringToHGlobalAnsi(name); Result := IsNamedStringARB(namelen, ptr2); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedStringARB(namelen: Int32; name: IntPtr): Byte := z_IsNamedStringARB(namelen, name);
    
    public z_GetNamedStringARB: procedure(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: pointer; string: IntPtr) := FuncPtrOrNil&<procedure(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: pointer; string: IntPtr)>(GetGLProcAdr('glGetNamedStringARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; stringlen: array of Int32; _string: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(_string); var ptr2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr2, bufSize, stringlen[0], ptr5); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); _string := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; stringlen: array of Int32; string: IntPtr); begin var ptr2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr2, bufSize, stringlen[0], string); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; var stringlen: Int32; _string: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(_string); var ptr2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr2, bufSize, @stringlen, ptr5); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); _string := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; var stringlen: Int32; string: IntPtr); begin var ptr2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr2, bufSize, @stringlen, string); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; stringlen: pointer; _string: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(_string); var ptr2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr2, bufSize, stringlen, ptr5); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); _string := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: string; bufSize: Int32; stringlen: pointer; string: IntPtr); begin var ptr2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringARB(namelen, ptr2, bufSize, stringlen, string); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: array of Int32; _string: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(_string); GetNamedStringARB(namelen, name, bufSize, stringlen[0], ptr5); _string := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: array of Int32; string: IntPtr) := GetNamedStringARB(namelen, name, bufSize, stringlen[0], string);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; var stringlen: Int32; _string: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(_string); GetNamedStringARB(namelen, name, bufSize, @stringlen, ptr5); _string := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; var stringlen: Int32; string: IntPtr) := GetNamedStringARB(namelen, name, bufSize, @stringlen, string);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: pointer; _string: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(_string); GetNamedStringARB(namelen, name, bufSize, stringlen, ptr5); _string := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringARB(namelen: Int32; name: IntPtr; bufSize: Int32; stringlen: pointer; string: IntPtr) := z_GetNamedStringARB(namelen, name, bufSize, stringlen, string);
    
    public z_GetNamedStringivARB: procedure(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetNamedStringivARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: string; pname: DummyEnum; &params: array of Int32); begin var ptr2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringivARB(namelen, ptr2, pname, &params[0]); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: string; pname: DummyEnum; var &params: Int32); begin var ptr2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringivARB(namelen, ptr2, pname, @&params); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: string; pname: DummyEnum; &params: pointer); begin var ptr2 := Marshal.StringToHGlobalAnsi(name); GetNamedStringivARB(namelen, ptr2, pname, &params); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: array of Int32) := GetNamedStringivARB(namelen, name, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: IntPtr; pname: DummyEnum; var &params: Int32) := GetNamedStringivARB(namelen, name, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedStringivARB(namelen: Int32; name: IntPtr; pname: DummyEnum; &params: pointer) := z_GetNamedStringivARB(namelen, name, pname, &params);
    
    {$endregion ARB_shading_language_include}
    
    {$region ARB_sparse_buffer}
    
    public z_BufferPageCommitmentARB: procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; commit: Byte) := FuncPtrOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; commit: Byte)>(GetGLProcAdr('glBufferPageCommitmentARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferPageCommitmentARB(target: DummyEnum; offset: IntPtr; size: UIntPtr; commit: Byte) := z_BufferPageCommitmentARB(target, offset, size, commit);
    
    {$endregion ARB_sparse_buffer}
    
    {$region ARB_vertex_blend}
    
    public z_WeightbvARB: procedure(size: Int32; weights: pointer) := FuncPtrOrNil&<procedure(size: Int32; weights: pointer)>(GetGLProcAdr('glWeightbvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; weights: array of SByte) := WeightbvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; var weights: SByte) := WeightbvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightbvARB(size: Int32; weights: pointer) := z_WeightbvARB(size, weights);
    
    public z_WeightsvARB: procedure(size: Int32; weights: pointer) := FuncPtrOrNil&<procedure(size: Int32; weights: pointer)>(GetGLProcAdr('glWeightsvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; weights: array of Int16) := WeightsvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; var weights: Int16) := WeightsvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightsvARB(size: Int32; weights: pointer) := z_WeightsvARB(size, weights);
    
    public z_WeightivARB: procedure(size: Int32; weights: pointer) := FuncPtrOrNil&<procedure(size: Int32; weights: pointer)>(GetGLProcAdr('glWeightivARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; weights: array of Int32) := WeightivARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; var weights: Int32) := WeightivARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightivARB(size: Int32; weights: pointer) := z_WeightivARB(size, weights);
    
    public z_WeightfvARB: procedure(size: Int32; weights: pointer) := FuncPtrOrNil&<procedure(size: Int32; weights: pointer)>(GetGLProcAdr('glWeightfvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; weights: array of single) := WeightfvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; var weights: single) := WeightfvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightfvARB(size: Int32; weights: pointer) := z_WeightfvARB(size, weights);
    
    public z_WeightdvARB: procedure(size: Int32; weights: pointer) := FuncPtrOrNil&<procedure(size: Int32; weights: pointer)>(GetGLProcAdr('glWeightdvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; weights: array of double) := WeightdvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; var weights: double) := WeightdvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightdvARB(size: Int32; weights: pointer) := z_WeightdvARB(size, weights);
    
    public z_WeightubvARB: procedure(size: Int32; weights: pointer) := FuncPtrOrNil&<procedure(size: Int32; weights: pointer)>(GetGLProcAdr('glWeightubvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; weights: array of Byte) := WeightubvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; var weights: Byte) := WeightubvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightubvARB(size: Int32; weights: pointer) := z_WeightubvARB(size, weights);
    
    public z_WeightusvARB: procedure(size: Int32; weights: pointer) := FuncPtrOrNil&<procedure(size: Int32; weights: pointer)>(GetGLProcAdr('glWeightusvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; weights: array of UInt16) := WeightusvARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; var weights: UInt16) := WeightusvARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightusvARB(size: Int32; weights: pointer) := z_WeightusvARB(size, weights);
    
    public z_WeightuivARB: procedure(size: Int32; weights: pointer) := FuncPtrOrNil&<procedure(size: Int32; weights: pointer)>(GetGLProcAdr('glWeightuivARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; weights: array of UInt32) := WeightuivARB(size, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; var weights: UInt32) := WeightuivARB(size, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightuivARB(size: Int32; weights: pointer) := z_WeightuivARB(size, weights);
    
    public z_VertexBlendARB: procedure(count: Int32) := FuncPtrOrNil&<procedure(count: Int32)>(GetGLProcAdr('glVertexBlendARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendARB(count: Int32) := z_VertexBlendARB(count);
    
    {$endregion ARB_vertex_blend}
    
    {$region APPLE_object_purgeable, ARB_shader_objects}
    
    public z_GetObjectParameterivARB: procedure(obj: GLhandleARB; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(obj: GLhandleARB; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetObjectParameterivARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivARB(obj: GLhandleARB; pname: DummyEnum; &params: array of Int32) := GetObjectParameterivARB(obj, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivARB(obj: GLhandleARB; pname: DummyEnum; var &params: Int32) := GetObjectParameterivARB(obj, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectParameterivARB(obj: GLhandleARB; pname: DummyEnum; &params: pointer) := z_GetObjectParameterivARB(obj, pname, &params);
    
    {$endregion APPLE_object_purgeable, ARB_shader_objects}
    
    {$region ARB_bindless_texture, NV_bindless_texture}
    
    public z_MakeTextureHandleResidentARB: procedure(handle: UInt64) := FuncPtrOrNil&<procedure(handle: UInt64)>(GetGLProcAdr('glMakeTextureHandleResidentARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleResidentARB(handle: UInt64) := z_MakeTextureHandleResidentARB(handle);
    
    public z_MakeTextureHandleNonResidentARB: procedure(handle: UInt64) := FuncPtrOrNil&<procedure(handle: UInt64)>(GetGLProcAdr('glMakeTextureHandleNonResidentARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeTextureHandleNonResidentARB(handle: UInt64) := z_MakeTextureHandleNonResidentARB(handle);
    
    public z_GetImageHandleARB: function(texture: UInt32; level: Int32; layered: Byte; layer: Int32; format: DummyEnum): UInt64 := FuncPtrOrNil&<function(texture: UInt32; level: Int32; layered: Byte; layer: Int32; format: DummyEnum): UInt64>(GetGLProcAdr('glGetImageHandleARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetImageHandleARB(texture: UInt32; level: Int32; layered: Byte; layer: Int32; format: DummyEnum): UInt64 := z_GetImageHandleARB(texture, level, layered, layer, format);
    
    public z_MakeImageHandleResidentARB: procedure(handle: UInt64; access: DummyEnum) := FuncPtrOrNil&<procedure(handle: UInt64; access: DummyEnum)>(GetGLProcAdr('glMakeImageHandleResidentARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleResidentARB(handle: UInt64; access: DummyEnum) := z_MakeImageHandleResidentARB(handle, access);
    
    public z_MakeImageHandleNonResidentARB: procedure(handle: UInt64) := FuncPtrOrNil&<procedure(handle: UInt64)>(GetGLProcAdr('glMakeImageHandleNonResidentARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeImageHandleNonResidentARB(handle: UInt64) := z_MakeImageHandleNonResidentARB(handle);
    
    public z_IsTextureHandleResidentARB: function(handle: UInt64): Byte := FuncPtrOrNil&<function(handle: UInt64): Byte>(GetGLProcAdr('glIsTextureHandleResidentARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsTextureHandleResidentARB(handle: UInt64): Byte := z_IsTextureHandleResidentARB(handle);
    
    public z_IsImageHandleResidentARB: function(handle: UInt64): Byte := FuncPtrOrNil&<function(handle: UInt64): Byte>(GetGLProcAdr('glIsImageHandleResidentARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsImageHandleResidentARB(handle: UInt64): Byte := z_IsImageHandleResidentARB(handle);
    
    {$endregion ARB_bindless_texture, NV_bindless_texture}
    
    {$region ARB_bindless_texture, NV_vertex_attrib_integer_64bit}
    
    public z_VertexAttribL1ui64ARB: procedure(index: UInt32; x: UInt64) := FuncPtrOrNil&<procedure(index: UInt32; x: UInt64)>(GetGLProcAdr('glVertexAttribL1ui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64ARB(index: UInt32; x: UInt64) := z_VertexAttribL1ui64ARB(index, x);
    
    public z_VertexAttribL1ui64vARB: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttribL1ui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; v: array of UInt64) := VertexAttribL1ui64vARB(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; var v: UInt64) := VertexAttribL1ui64vARB(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1ui64vARB(index: UInt32; v: pointer) := z_VertexAttribL1ui64vARB(index, v);
    
    public z_GetVertexAttribLui64vARB: procedure(index: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVertexAttribLui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vARB(index: UInt32; pname: DummyEnum; &params: array of UInt64) := GetVertexAttribLui64vARB(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vARB(index: UInt32; pname: DummyEnum; var &params: UInt64) := GetVertexAttribLui64vARB(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLui64vARB(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribLui64vARB(index, pname, &params);
    
    {$endregion ARB_bindless_texture, NV_vertex_attrib_integer_64bit}
    
    {$region ARB_fragment_program, ARB_vertex_program}
    
    public z_ProgramStringARB: procedure(target: DummyEnum; format: DummyEnum; len: Int32; string: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; format: DummyEnum; len: Int32; string: pointer)>(GetGLProcAdr('glProgramStringARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramStringARB(target: DummyEnum; format: DummyEnum; len: Int32; string: pointer) := z_ProgramStringARB(target, format, len, string);
    
    public z_ProgramEnvParameter4dARB: procedure(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double)>(GetGLProcAdr('glProgramEnvParameter4dARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dARB(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := z_ProgramEnvParameter4dARB(target, index, x, y, z, w);
    
    public z_ProgramEnvParameter4dvARB: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glProgramEnvParameter4dvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: DummyEnum; index: UInt32; &params: array of double) := ProgramEnvParameter4dvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: DummyEnum; index: UInt32; var &params: double) := ProgramEnvParameter4dvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4dvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramEnvParameter4dvARB(target, index, &params);
    
    public z_ProgramEnvParameter4fARB: procedure(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single)>(GetGLProcAdr('glProgramEnvParameter4fARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fARB(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := z_ProgramEnvParameter4fARB(target, index, x, y, z, w);
    
    public z_ProgramEnvParameter4fvARB: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glProgramEnvParameter4fvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: DummyEnum; index: UInt32; &params: array of single) := ProgramEnvParameter4fvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: DummyEnum; index: UInt32; var &params: single) := ProgramEnvParameter4fvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameter4fvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramEnvParameter4fvARB(target, index, &params);
    
    public z_GetProgramEnvParameterdvARB: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetProgramEnvParameterdvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: DummyEnum; index: UInt32; &params: array of double) := GetProgramEnvParameterdvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: DummyEnum; index: UInt32; var &params: double) := GetProgramEnvParameterdvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterdvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramEnvParameterdvARB(target, index, &params);
    
    public z_GetProgramEnvParameterfvARB: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetProgramEnvParameterfvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: DummyEnum; index: UInt32; &params: array of single) := GetProgramEnvParameterfvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: DummyEnum; index: UInt32; var &params: single) := GetProgramEnvParameterfvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterfvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramEnvParameterfvARB(target, index, &params);
    
    {$endregion ARB_fragment_program, ARB_vertex_program}
    
    {$region ARB_matrix_palette, OES_matrix_palette}
    
    public z_CurrentPaletteMatrixARB: procedure(index: Int32) := FuncPtrOrNil&<procedure(index: Int32)>(GetGLProcAdr('glCurrentPaletteMatrixARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CurrentPaletteMatrixARB(index: Int32) := z_CurrentPaletteMatrixARB(index);
    
    public z_MatrixIndexPointerARB: procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>(GetGLProcAdr('glMatrixIndexPointerARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixIndexPointerARB(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_MatrixIndexPointerARB(size, &type, stride, _pointer);
    
    {$endregion ARB_matrix_palette, OES_matrix_palette}
    
    {$region ARB_parallel_shader_compile, KHR_parallel_shader_compile}
    
    public z_MaxShaderCompilerThreadsARB: procedure(count: UInt32) := FuncPtrOrNil&<procedure(count: UInt32)>(GetGLProcAdr('glMaxShaderCompilerThreadsARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaxShaderCompilerThreadsARB(count: UInt32) := z_MaxShaderCompilerThreadsARB(count);
    
    {$endregion ARB_parallel_shader_compile, KHR_parallel_shader_compile}
    
    {$region ARB_sample_locations, NV_sample_locations}
    
    public z_FramebufferSampleLocationsfvARB: procedure(target: DummyEnum; start: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; start: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glFramebufferSampleLocationsfvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: DummyEnum; start: UInt32; count: Int32; v: array of single) := FramebufferSampleLocationsfvARB(target, start, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: DummyEnum; start: UInt32; count: Int32; var v: single) := FramebufferSampleLocationsfvARB(target, start, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSampleLocationsfvARB(target: DummyEnum; start: UInt32; count: Int32; v: pointer) := z_FramebufferSampleLocationsfvARB(target, start, count, v);
    
    public z_NamedFramebufferSampleLocationsfvARB: procedure(framebuffer: UInt32; start: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(framebuffer: UInt32; start: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glNamedFramebufferSampleLocationsfvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: UInt32; start: UInt32; count: Int32; v: array of single) := NamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: UInt32; start: UInt32; count: Int32; var v: single) := NamedFramebufferSampleLocationsfvARB(framebuffer, start, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSampleLocationsfvARB(framebuffer: UInt32; start: UInt32; count: Int32; v: pointer) := z_NamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v);
    
    {$endregion ARB_sample_locations, NV_sample_locations}
    
    {$region ARB_sparse_texture, EXT_sparse_texture}
    
    public z_TexPageCommitmentARB: procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: Byte) := FuncPtrOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: Byte)>(GetGLProcAdr('glTexPageCommitmentARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexPageCommitmentARB(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: Byte) := z_TexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    
    public z_TexturePageCommitmentEXT: procedure(texture: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: Byte) := FuncPtrOrNil&<procedure(texture: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: Byte)>(GetGLProcAdr('glTexturePageCommitmentEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexturePageCommitmentEXT(texture: UInt32; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; commit: Byte) := z_TexturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
    
    {$endregion ARB_sparse_texture, EXT_sparse_texture}
    
    {$region ARB_vertex_blend, OES_matrix_palette}
    
    public z_WeightPointerARB: procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>(GetGLProcAdr('glWeightPointerARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPointerARB(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_WeightPointerARB(size, &type, stride, _pointer);
    
    {$endregion ARB_vertex_blend, OES_matrix_palette}
    
    {$region AMD_gpu_shader_int64, ARB_gpu_shader_int64, NV_gpu_shader5}
    
    public z_Uniform1i64ARB: procedure(location: Int32; x: Int64) := FuncPtrOrNil&<procedure(location: Int32; x: Int64)>(GetGLProcAdr('glUniform1i64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64ARB(location: Int32; x: Int64) := z_Uniform1i64ARB(location, x);
    
    public z_Uniform2i64ARB: procedure(location: Int32; x: Int64; y: Int64) := FuncPtrOrNil&<procedure(location: Int32; x: Int64; y: Int64)>(GetGLProcAdr('glUniform2i64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64ARB(location: Int32; x: Int64; y: Int64) := z_Uniform2i64ARB(location, x, y);
    
    public z_Uniform3i64ARB: procedure(location: Int32; x: Int64; y: Int64; z: Int64) := FuncPtrOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64)>(GetGLProcAdr('glUniform3i64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64ARB(location: Int32; x: Int64; y: Int64; z: Int64) := z_Uniform3i64ARB(location, x, y, z);
    
    public z_Uniform4i64ARB: procedure(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) := FuncPtrOrNil&<procedure(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(GetGLProcAdr('glUniform4i64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64ARB(location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) := z_Uniform4i64ARB(location, x, y, z, w);
    
    public z_Uniform1i64vARB: procedure(location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glUniform1i64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; value: array of Int64) := Uniform1i64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; var value: Int64) := Uniform1i64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1i64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform1i64vARB(location, count, value);
    
    public z_Uniform2i64vARB: procedure(location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glUniform2i64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; value: array of Int64) := Uniform2i64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; var value: Int64) := Uniform2i64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2i64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform2i64vARB(location, count, value);
    
    public z_Uniform3i64vARB: procedure(location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glUniform3i64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; value: array of Int64) := Uniform3i64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; var value: Int64) := Uniform3i64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3i64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform3i64vARB(location, count, value);
    
    public z_Uniform4i64vARB: procedure(location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glUniform4i64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; value: array of Int64) := Uniform4i64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; var value: Int64) := Uniform4i64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4i64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform4i64vARB(location, count, value);
    
    public z_Uniform1ui64ARB: procedure(location: Int32; x: UInt64) := FuncPtrOrNil&<procedure(location: Int32; x: UInt64)>(GetGLProcAdr('glUniform1ui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64ARB(location: Int32; x: UInt64) := z_Uniform1ui64ARB(location, x);
    
    public z_Uniform2ui64ARB: procedure(location: Int32; x: UInt64; y: UInt64) := FuncPtrOrNil&<procedure(location: Int32; x: UInt64; y: UInt64)>(GetGLProcAdr('glUniform2ui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64ARB(location: Int32; x: UInt64; y: UInt64) := z_Uniform2ui64ARB(location, x, y);
    
    public z_Uniform3ui64ARB: procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64) := FuncPtrOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64)>(GetGLProcAdr('glUniform3ui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64ARB(location: Int32; x: UInt64; y: UInt64; z: UInt64) := z_Uniform3ui64ARB(location, x, y, z);
    
    public z_Uniform4ui64ARB: procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := FuncPtrOrNil&<procedure(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(GetGLProcAdr('glUniform4ui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64ARB(location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := z_Uniform4ui64ARB(location, x, y, z, w);
    
    public z_Uniform1ui64vARB: procedure(location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glUniform1ui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; value: array of UInt64) := Uniform1ui64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; var value: UInt64) := Uniform1ui64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform1ui64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform1ui64vARB(location, count, value);
    
    public z_Uniform2ui64vARB: procedure(location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glUniform2ui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; value: array of UInt64) := Uniform2ui64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; var value: UInt64) := Uniform2ui64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform2ui64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform2ui64vARB(location, count, value);
    
    public z_Uniform3ui64vARB: procedure(location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glUniform3ui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; value: array of UInt64) := Uniform3ui64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; var value: UInt64) := Uniform3ui64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform3ui64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform3ui64vARB(location, count, value);
    
    public z_Uniform4ui64vARB: procedure(location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glUniform4ui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; value: array of UInt64) := Uniform4ui64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; var value: UInt64) := Uniform4ui64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniform4ui64vARB(location: Int32; count: Int32; value: pointer) := z_Uniform4ui64vARB(location, count, value);
    
    public z_GetUniformi64vARB: procedure(&program: UInt32; location: Int32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; &params: pointer)>(GetGLProcAdr('glGetUniformi64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vARB(&program: UInt32; location: Int32; &params: array of Int64) := GetUniformi64vARB(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vARB(&program: UInt32; location: Int32; var &params: Int64) := GetUniformi64vARB(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformi64vARB(&program: UInt32; location: Int32; &params: pointer) := z_GetUniformi64vARB(&program, location, &params);
    
    public z_ProgramUniform1i64ARB: procedure(&program: UInt32; location: Int32; x: Int64) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; x: Int64)>(GetGLProcAdr('glProgramUniform1i64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64ARB(&program: UInt32; location: Int32; x: Int64) := z_ProgramUniform1i64ARB(&program, location, x);
    
    public z_ProgramUniform2i64ARB: procedure(&program: UInt32; location: Int32; x: Int64; y: Int64) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; x: Int64; y: Int64)>(GetGLProcAdr('glProgramUniform2i64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64ARB(&program: UInt32; location: Int32; x: Int64; y: Int64) := z_ProgramUniform2i64ARB(&program, location, x, y);
    
    public z_ProgramUniform3i64ARB: procedure(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64)>(GetGLProcAdr('glProgramUniform3i64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64ARB(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64) := z_ProgramUniform3i64ARB(&program, location, x, y, z);
    
    public z_ProgramUniform4i64ARB: procedure(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64)>(GetGLProcAdr('glProgramUniform4i64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64ARB(&program: UInt32; location: Int32; x: Int64; y: Int64; z: Int64; w: Int64) := z_ProgramUniform4i64ARB(&program, location, x, y, z, w);
    
    public z_ProgramUniform1i64vARB: procedure(&program: UInt32; location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glProgramUniform1i64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform1i64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform1i64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1i64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1i64vARB(&program, location, count, value);
    
    public z_ProgramUniform2i64vARB: procedure(&program: UInt32; location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glProgramUniform2i64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform2i64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform2i64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2i64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2i64vARB(&program, location, count, value);
    
    public z_ProgramUniform3i64vARB: procedure(&program: UInt32; location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glProgramUniform3i64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform3i64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform3i64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3i64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3i64vARB(&program, location, count, value);
    
    public z_ProgramUniform4i64vARB: procedure(&program: UInt32; location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glProgramUniform4i64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: UInt32; location: Int32; count: Int32; value: array of Int64) := ProgramUniform4i64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: UInt32; location: Int32; count: Int32; var value: Int64) := ProgramUniform4i64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4i64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4i64vARB(&program, location, count, value);
    
    public z_ProgramUniform1ui64ARB: procedure(&program: UInt32; location: Int32; x: UInt64) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64)>(GetGLProcAdr('glProgramUniform1ui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64ARB(&program: UInt32; location: Int32; x: UInt64) := z_ProgramUniform1ui64ARB(&program, location, x);
    
    public z_ProgramUniform2ui64ARB: procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64)>(GetGLProcAdr('glProgramUniform2ui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64ARB(&program: UInt32; location: Int32; x: UInt64; y: UInt64) := z_ProgramUniform2ui64ARB(&program, location, x, y);
    
    public z_ProgramUniform3ui64ARB: procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64)>(GetGLProcAdr('glProgramUniform3ui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64ARB(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64) := z_ProgramUniform3ui64ARB(&program, location, x, y, z);
    
    public z_ProgramUniform4ui64ARB: procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(GetGLProcAdr('glProgramUniform4ui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64ARB(&program: UInt32; location: Int32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := z_ProgramUniform4ui64ARB(&program, location, x, y, z, w);
    
    public z_ProgramUniform1ui64vARB: procedure(&program: UInt32; location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glProgramUniform1ui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform1ui64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform1ui64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform1ui64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform1ui64vARB(&program, location, count, value);
    
    public z_ProgramUniform2ui64vARB: procedure(&program: UInt32; location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glProgramUniform2ui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform2ui64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform2ui64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform2ui64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform2ui64vARB(&program, location, count, value);
    
    public z_ProgramUniform3ui64vARB: procedure(&program: UInt32; location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glProgramUniform3ui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform3ui64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform3ui64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform3ui64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform3ui64vARB(&program, location, count, value);
    
    public z_ProgramUniform4ui64vARB: procedure(&program: UInt32; location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glProgramUniform4ui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniform4ui64vARB(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniform4ui64vARB(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniform4ui64vARB(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniform4ui64vARB(&program, location, count, value);
    
    {$endregion AMD_gpu_shader_int64, ARB_gpu_shader_int64, NV_gpu_shader5}
    
    {$region ARB_bindless_texture, IMG_bindless_texture, NV_bindless_texture}
    
    public z_GetTextureHandleARB: function(texture: UInt32): UInt64 := FuncPtrOrNil&<function(texture: UInt32): UInt64>(GetGLProcAdr('glGetTextureHandleARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureHandleARB(texture: UInt32): UInt64 := z_GetTextureHandleARB(texture);
    
    public z_GetTextureSamplerHandleARB: function(texture: UInt32; sampler: UInt32): UInt64 := FuncPtrOrNil&<function(texture: UInt32; sampler: UInt32): UInt64>(GetGLProcAdr('glGetTextureSamplerHandleARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetTextureSamplerHandleARB(texture: UInt32; sampler: UInt32): UInt64 := z_GetTextureSamplerHandleARB(texture, sampler);
    
    public z_UniformHandleui64ARB: procedure(location: Int32; value: UInt64) := FuncPtrOrNil&<procedure(location: Int32; value: UInt64)>(GetGLProcAdr('glUniformHandleui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64ARB(location: Int32; value: UInt64) := z_UniformHandleui64ARB(location, value);
    
    public z_UniformHandleui64vARB: procedure(location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glUniformHandleui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; value: array of UInt64) := UniformHandleui64vARB(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; var value: UInt64) := UniformHandleui64vARB(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformHandleui64vARB(location: Int32; count: Int32; value: pointer) := z_UniformHandleui64vARB(location, count, value);
    
    public z_ProgramUniformHandleui64ARB: procedure(&program: UInt32; location: Int32; value: UInt64) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; value: UInt64)>(GetGLProcAdr('glProgramUniformHandleui64ARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64ARB(&program: UInt32; location: Int32; value: UInt64) := z_ProgramUniformHandleui64ARB(&program, location, value);
    
    public z_ProgramUniformHandleui64vARB: procedure(&program: UInt32; location: Int32; count: Int32; values: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; values: pointer)>(GetGLProcAdr('glProgramUniformHandleui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: UInt32; location: Int32; count: Int32; values: array of UInt64) := ProgramUniformHandleui64vARB(&program, location, count, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: UInt32; location: Int32; count: Int32; var values: UInt64) := ProgramUniformHandleui64vARB(&program, location, count, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformHandleui64vARB(&program: UInt32; location: Int32; count: Int32; values: pointer) := z_ProgramUniformHandleui64vARB(&program, location, count, values);
    
    {$endregion ARB_bindless_texture, IMG_bindless_texture, NV_bindless_texture}
    
    {$region ARB_ES3_2_compatibility, EXT_primitive_bounding_box, OES_primitive_bounding_box}
    
    public z_PrimitiveBoundingBoxARB: procedure(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single) := FuncPtrOrNil&<procedure(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single)>(GetGLProcAdr('glPrimitiveBoundingBoxARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveBoundingBoxARB(minX: single; minY: single; minZ: single; minW: single; maxX: single; maxY: single; maxZ: single; maxW: single) := z_PrimitiveBoundingBoxARB(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
    
    {$endregion ARB_ES3_2_compatibility, EXT_primitive_bounding_box, OES_primitive_bounding_box}
    
    {$region ARB_fragment_program, ARB_vertex_program, NV_vertex_program}
    
    public z_BindProgramARB: procedure(target: DummyEnum; &program: UInt32) := FuncPtrOrNil&<procedure(target: DummyEnum; &program: UInt32)>(GetGLProcAdr('glBindProgramARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindProgramARB(target: DummyEnum; &program: UInt32) := z_BindProgramARB(target, &program);
    
    public z_DeleteProgramsARB: procedure(n: Int32; programs: pointer) := FuncPtrOrNil&<procedure(n: Int32; programs: pointer)>(GetGLProcAdr('glDeleteProgramsARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: array of UInt32) := DeleteProgramsARB(n, programs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; var programs: UInt32) := DeleteProgramsARB(n, @programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteProgramsARB(n: Int32; programs: pointer) := z_DeleteProgramsARB(n, programs);
    
    public z_GenProgramsARB: procedure(n: Int32; programs: pointer) := FuncPtrOrNil&<procedure(n: Int32; programs: pointer)>(GetGLProcAdr('glGenProgramsARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: array of UInt32) := GenProgramsARB(n, programs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; var programs: UInt32) := GenProgramsARB(n, @programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenProgramsARB(n: Int32; programs: pointer) := z_GenProgramsARB(n, programs);
    
    public z_GetProgramStringARB: procedure(target: DummyEnum; pname: DummyEnum; string: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; string: pointer)>(GetGLProcAdr('glGetProgramStringARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramStringARB(target: DummyEnum; pname: DummyEnum; string: pointer) := z_GetProgramStringARB(target, pname, string);
    
    {$endregion ARB_fragment_program, ARB_vertex_program, NV_vertex_program}
    
    {$region ARB_fragment_program, ARB_vertex_program, NV_fragment_program}
    
    public z_ProgramLocalParameter4dARB: procedure(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double)>(GetGLProcAdr('glProgramLocalParameter4dARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dARB(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := z_ProgramLocalParameter4dARB(target, index, x, y, z, w);
    
    public z_ProgramLocalParameter4dvARB: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glProgramLocalParameter4dvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: DummyEnum; index: UInt32; &params: array of double) := ProgramLocalParameter4dvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: DummyEnum; index: UInt32; var &params: double) := ProgramLocalParameter4dvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4dvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramLocalParameter4dvARB(target, index, &params);
    
    public z_ProgramLocalParameter4fARB: procedure(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single)>(GetGLProcAdr('glProgramLocalParameter4fARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fARB(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := z_ProgramLocalParameter4fARB(target, index, x, y, z, w);
    
    public z_ProgramLocalParameter4fvARB: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glProgramLocalParameter4fvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: DummyEnum; index: UInt32; &params: array of single) := ProgramLocalParameter4fvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: DummyEnum; index: UInt32; var &params: single) := ProgramLocalParameter4fvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameter4fvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramLocalParameter4fvARB(target, index, &params);
    
    public z_GetProgramLocalParameterdvARB: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetProgramLocalParameterdvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: DummyEnum; index: UInt32; &params: array of double) := GetProgramLocalParameterdvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: DummyEnum; index: UInt32; var &params: double) := GetProgramLocalParameterdvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterdvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramLocalParameterdvARB(target, index, &params);
    
    public z_GetProgramLocalParameterfvARB: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetProgramLocalParameterfvARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: DummyEnum; index: UInt32; &params: array of single) := GetProgramLocalParameterfvARB(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: DummyEnum; index: UInt32; var &params: single) := GetProgramLocalParameterfvARB(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterfvARB(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramLocalParameterfvARB(target, index, &params);
    
    {$endregion ARB_fragment_program, ARB_vertex_program, NV_fragment_program}
    
    {$region ARB_geometry_shader4, EXT_geometry_shader4, NV_geometry_program4}
    
    public z_FramebufferTextureFaceARB: procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum)>(GetGLProcAdr('glFramebufferTextureFaceARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureFaceARB(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum) := z_FramebufferTextureFaceARB(target, attachment, texture, level, face);
    
    {$endregion ARB_geometry_shader4, EXT_geometry_shader4, NV_geometry_program4}
    
    {$region AMD_gpu_shader_int64, ARB_gpu_shader_int64, NV_gpu_shader5, NV_shader_buffer_load}
    
    public z_GetUniformui64vARB: procedure(&program: UInt32; location: Int32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; &params: pointer)>(GetGLProcAdr('glGetUniformui64vARB'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vARB(&program: UInt32; location: Int32; &params: array of UInt64) := GetUniformui64vARB(&program, location, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vARB(&program: UInt32; location: Int32; var &params: UInt64) := GetUniformui64vARB(&program, location, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUniformui64vARB(&program: UInt32; location: Int32; &params: pointer) := z_GetUniformui64vARB(&program, location, &params);
    
    {$endregion AMD_gpu_shader_int64, ARB_gpu_shader_int64, NV_gpu_shader5, NV_shader_buffer_load}
    
  end;
  
  gl_EXT = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region Unsorted}
    
    public z_BindMultiTextureEXT: procedure(texunit: DummyEnum; target: DummyEnum; texture: UInt32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; texture: UInt32)>(GetGLProcAdr('glBindMultiTextureEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindMultiTextureEXT(texunit: DummyEnum; target: DummyEnum; texture: UInt32) := z_BindMultiTextureEXT(texunit, target, texture);
    
    public z_ClientAttribDefaultEXT: procedure(mask: DummyFlags) := FuncPtrOrNil&<procedure(mask: DummyFlags)>(GetGLProcAdr('glClientAttribDefaultEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientAttribDefaultEXT(mask: DummyFlags) := z_ClientAttribDefaultEXT(mask);
    
    public z_CompressedMultiTexImage1DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; bits: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; bits: pointer)>(GetGLProcAdr('glCompressedMultiTexImage1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits);
    
    public z_CompressedMultiTexImage2DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer)>(GetGLProcAdr('glCompressedMultiTexImage2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);
    
    public z_CompressedMultiTexImage3DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer)>(GetGLProcAdr('glCompressedMultiTexImage3DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexImage3DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
    
    public z_CompressedMultiTexSubImage1DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; imageSize: Int32; bits: pointer)>(GetGLProcAdr('glCompressedMultiTexSubImage1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := z_CompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits);
    
    public z_CompressedMultiTexSubImage2DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; imageSize: Int32; bits: pointer)>(GetGLProcAdr('glCompressedMultiTexSubImage2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := z_CompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
    
    public z_CompressedMultiTexSubImage3DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; bits: pointer)>(GetGLProcAdr('glCompressedMultiTexSubImage3DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedMultiTexSubImage3DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; imageSize: Int32; bits: pointer) := z_CompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
    
    public z_CompressedTextureImage1DEXT: procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; bits: pointer) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; bits: pointer)>(GetGLProcAdr('glCompressedTextureImage1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage1DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);
    
    public z_CompressedTextureImage2DEXT: procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer)>(GetGLProcAdr('glCompressedTextureImage2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage2DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);
    
    public z_CompressedTextureImage3DEXT: procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer)>(GetGLProcAdr('glCompressedTextureImage3DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompressedTextureImage3DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; border: Int32; imageSize: Int32; bits: pointer) := z_CompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
    
    public z_CopyMultiTexImage1DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32)>(GetGLProcAdr('glCopyMultiTexImage1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32) := z_CopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);
    
    public z_CopyMultiTexImage2DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>(GetGLProcAdr('glCopyMultiTexImage2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) := z_CopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);
    
    public z_CopyMultiTexSubImage1DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32)>(GetGLProcAdr('glCopyMultiTexSubImage1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; x: Int32; y: Int32; width: Int32) := z_CopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
    
    public z_CopyMultiTexSubImage2DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(GetGLProcAdr('glCopyMultiTexSubImage2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
    
    public z_CopyMultiTexSubImage3DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32)>(GetGLProcAdr('glCopyMultiTexSubImage3DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyMultiTexSubImage3DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; x: Int32; y: Int32; width: Int32; height: Int32) := z_CopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
    
    public z_CopyTextureImage1DEXT: procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32)>(GetGLProcAdr('glCopyTextureImage1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureImage1DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; border: Int32) := z_CopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);
    
    public z_CopyTextureImage2DEXT: procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32)>(GetGLProcAdr('glCopyTextureImage2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureImage2DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: DummyEnum; x: Int32; y: Int32; width: Int32; height: Int32; border: Int32) := z_CopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);
    
    public z_CullParameterdvEXT: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glCullParameterdvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterdvEXT(pname: DummyEnum; &params: array of double) := CullParameterdvEXT(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterdvEXT(pname: DummyEnum; var &params: double) := CullParameterdvEXT(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterdvEXT(pname: DummyEnum; &params: pointer) := z_CullParameterdvEXT(pname, &params);
    
    public z_CullParameterfvEXT: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glCullParameterfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterfvEXT(pname: DummyEnum; &params: array of single) := CullParameterfvEXT(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterfvEXT(pname: DummyEnum; var &params: single) := CullParameterfvEXT(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CullParameterfvEXT(pname: DummyEnum; &params: pointer) := z_CullParameterfvEXT(pname, &params);
    
    public z_DisableClientStateiEXT: procedure(&array: DummyEnum; index: UInt32) := FuncPtrOrNil&<procedure(&array: DummyEnum; index: UInt32)>(GetGLProcAdr('glDisableClientStateiEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientStateiEXT(&array: DummyEnum; index: UInt32) := z_DisableClientStateiEXT(&array, index);
    
    public z_DisableClientStateIndexedEXT: procedure(&array: DummyEnum; index: UInt32) := FuncPtrOrNil&<procedure(&array: DummyEnum; index: UInt32)>(GetGLProcAdr('glDisableClientStateIndexedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableClientStateIndexedEXT(&array: DummyEnum; index: UInt32) := z_DisableClientStateIndexedEXT(&array, index);
    
    public z_DisableVertexArrayEXT: procedure(vaobj: UInt32; &array: DummyEnum) := FuncPtrOrNil&<procedure(vaobj: UInt32; &array: DummyEnum)>(GetGLProcAdr('glDisableVertexArrayEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexArrayEXT(vaobj: UInt32; &array: DummyEnum) := z_DisableVertexArrayEXT(vaobj, &array);
    
    public z_EnableClientStateiEXT: procedure(&array: DummyEnum; index: UInt32) := FuncPtrOrNil&<procedure(&array: DummyEnum; index: UInt32)>(GetGLProcAdr('glEnableClientStateiEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientStateiEXT(&array: DummyEnum; index: UInt32) := z_EnableClientStateiEXT(&array, index);
    
    public z_EnableClientStateIndexedEXT: procedure(&array: DummyEnum; index: UInt32) := FuncPtrOrNil&<procedure(&array: DummyEnum; index: UInt32)>(GetGLProcAdr('glEnableClientStateIndexedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableClientStateIndexedEXT(&array: DummyEnum; index: UInt32) := z_EnableClientStateIndexedEXT(&array, index);
    
    public z_EnableVertexArrayEXT: procedure(vaobj: UInt32; &array: DummyEnum) := FuncPtrOrNil&<procedure(vaobj: UInt32; &array: DummyEnum)>(GetGLProcAdr('glEnableVertexArrayEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexArrayEXT(vaobj: UInt32; &array: DummyEnum) := z_EnableVertexArrayEXT(vaobj, &array);
    
    public z_FramebufferDrawBufferEXT: procedure(framebuffer: UInt32; mode: DummyEnum) := FuncPtrOrNil&<procedure(framebuffer: UInt32; mode: DummyEnum)>(GetGLProcAdr('glFramebufferDrawBufferEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBufferEXT(framebuffer: UInt32; mode: DummyEnum) := z_FramebufferDrawBufferEXT(framebuffer, mode);
    
    public z_FramebufferDrawBuffersEXT: procedure(framebuffer: UInt32; n: Int32; bufs: pointer) := FuncPtrOrNil&<procedure(framebuffer: UInt32; n: Int32; bufs: pointer)>(GetGLProcAdr('glFramebufferDrawBuffersEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: UInt32; n: Int32; bufs: array of DummyEnum) := FramebufferDrawBuffersEXT(framebuffer, n, bufs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: UInt32; n: Int32; var bufs: DummyEnum) := FramebufferDrawBuffersEXT(framebuffer, n, @bufs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferDrawBuffersEXT(framebuffer: UInt32; n: Int32; bufs: pointer) := z_FramebufferDrawBuffersEXT(framebuffer, n, bufs);
    
    public z_FramebufferReadBufferEXT: procedure(framebuffer: UInt32; mode: DummyEnum) := FuncPtrOrNil&<procedure(framebuffer: UInt32; mode: DummyEnum)>(GetGLProcAdr('glFramebufferReadBufferEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferReadBufferEXT(framebuffer: UInt32; mode: DummyEnum) := z_FramebufferReadBufferEXT(framebuffer, mode);
    
    public z_GenerateMultiTexMipmapEXT: procedure(texunit: DummyEnum; target: DummyEnum) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum)>(GetGLProcAdr('glGenerateMultiTexMipmapEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenerateMultiTexMipmapEXT(texunit: DummyEnum; target: DummyEnum) := z_GenerateMultiTexMipmapEXT(texunit, target);
    
    public z_GetCompressedMultiTexImageEXT: procedure(texunit: DummyEnum; target: DummyEnum; lod: Int32; img: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; lod: Int32; img: pointer)>(GetGLProcAdr('glGetCompressedMultiTexImageEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCompressedMultiTexImageEXT(texunit: DummyEnum; target: DummyEnum; lod: Int32; img: pointer) := z_GetCompressedMultiTexImageEXT(texunit, target, lod, img);
    
    public z_GetDoubleIndexedvEXT: procedure(target: DummyEnum; index: UInt32; data: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; data: pointer)>(GetGLProcAdr('glGetDoubleIndexedvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoubleIndexedvEXT(target: DummyEnum; index: UInt32; data: array of double) := GetDoubleIndexedvEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoubleIndexedvEXT(target: DummyEnum; index: UInt32; var data: double) := GetDoubleIndexedvEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDoubleIndexedvEXT(target: DummyEnum; index: UInt32; data: pointer) := z_GetDoubleIndexedvEXT(target, index, data);
    
    public z_GetFloatIndexedvEXT: procedure(target: DummyEnum; index: UInt32; data: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; data: pointer)>(GetGLProcAdr('glGetFloatIndexedvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatIndexedvEXT(target: DummyEnum; index: UInt32; data: array of single) := GetFloatIndexedvEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatIndexedvEXT(target: DummyEnum; index: UInt32; var data: single) := GetFloatIndexedvEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFloatIndexedvEXT(target: DummyEnum; index: UInt32; data: pointer) := z_GetFloatIndexedvEXT(target, index, data);
    
    public z_GetMultiTexEnvfvEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexEnvfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of single) := GetMultiTexEnvfvEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: single) := GetMultiTexEnvfvEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexEnvfvEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexEnvivEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexEnvivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMultiTexEnvivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMultiTexEnvivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexEnvivEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexGendvEXT: procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexGendvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of double) := GetMultiTexGendvEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: double) := GetMultiTexGendvEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexGendvEXT(texunit, coord, pname, &params);
    
    public z_GetMultiTexGenfvEXT: procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexGenfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of single) := GetMultiTexGenfvEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: single) := GetMultiTexGenfvEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexGenfvEXT(texunit, coord, pname, &params);
    
    public z_GetMultiTexGenivEXT: procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexGenivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMultiTexGenivEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMultiTexGenivEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexGenivEXT(texunit, coord, pname, &params);
    
    public z_GetMultiTexImageEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glGetMultiTexImageEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexImageEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_GetMultiTexImageEXT(texunit, target, level, format, &type, pixels);
    
    public z_GetMultiTexLevelParameterfvEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexLevelParameterfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterfvEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: array of single) := GetMultiTexLevelParameterfvEXT(texunit, target, level, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterfvEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; var &params: single) := GetMultiTexLevelParameterfvEXT(texunit, target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterfvEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := z_GetMultiTexLevelParameterfvEXT(texunit, target, level, pname, &params);
    
    public z_GetMultiTexLevelParameterivEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexLevelParameterivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterivEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: array of Int32) := GetMultiTexLevelParameterivEXT(texunit, target, level, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterivEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; var &params: Int32) := GetMultiTexLevelParameterivEXT(texunit, target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexLevelParameterivEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := z_GetMultiTexLevelParameterivEXT(texunit, target, level, pname, &params);
    
    public z_GetMultiTexParameterfvEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexParameterfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of single) := GetMultiTexParameterfvEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: single) := GetMultiTexParameterfvEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexParameterfvEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexParameterIivEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexParameterIivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMultiTexParameterIivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMultiTexParameterIivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexParameterIivEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexParameterIuivEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexParameterIuivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of UInt32) := GetMultiTexParameterIuivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: UInt32) := GetMultiTexParameterIuivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexParameterIuivEXT(texunit, target, pname, &params);
    
    public z_GetMultiTexParameterivEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMultiTexParameterivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMultiTexParameterivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMultiTexParameterivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMultiTexParameterivEXT(texunit, target, pname, &params);
    
    public z_GetNamedProgramivEXT: procedure(&program: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetNamedProgramivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramivEXT(&program: UInt32; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetNamedProgramivEXT(&program, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramivEXT(&program: UInt32; target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetNamedProgramivEXT(&program, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramivEXT(&program: UInt32; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetNamedProgramivEXT(&program, target, pname, &params);
    
    public z_GetNamedProgramLocalParameterdvEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetNamedProgramLocalParameterdvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterdvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of double) := GetNamedProgramLocalParameterdvEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterdvEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: double) := GetNamedProgramLocalParameterdvEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterdvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_GetNamedProgramLocalParameterdvEXT(&program, target, index, &params);
    
    public z_GetNamedProgramLocalParameterfvEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetNamedProgramLocalParameterfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterfvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of single) := GetNamedProgramLocalParameterfvEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterfvEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: single) := GetNamedProgramLocalParameterfvEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterfvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_GetNamedProgramLocalParameterfvEXT(&program, target, index, &params);
    
    public z_GetNamedProgramLocalParameterIivEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetNamedProgramLocalParameterIivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of Int32) := GetNamedProgramLocalParameterIivEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIivEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: Int32) := GetNamedProgramLocalParameterIivEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_GetNamedProgramLocalParameterIivEXT(&program, target, index, &params);
    
    public z_GetNamedProgramLocalParameterIuivEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetNamedProgramLocalParameterIuivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIuivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of UInt32) := GetNamedProgramLocalParameterIuivEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIuivEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: UInt32) := GetNamedProgramLocalParameterIuivEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramLocalParameterIuivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_GetNamedProgramLocalParameterIuivEXT(&program, target, index, &params);
    
    public z_GetNamedProgramStringEXT: procedure(&program: UInt32; target: DummyEnum; pname: DummyEnum; string: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; pname: DummyEnum; string: pointer)>(GetGLProcAdr('glGetNamedProgramStringEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedProgramStringEXT(&program: UInt32; target: DummyEnum; pname: DummyEnum; string: pointer) := z_GetNamedProgramStringEXT(&program, target, pname, string);
    
    public z_GetPointeri_vEXT: procedure(pname: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetPointeri_vEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointeri_vEXT(pname: DummyEnum; index: UInt32; &params: array of IntPtr) := GetPointeri_vEXT(pname, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointeri_vEXT(pname: DummyEnum; index: UInt32; var &params: IntPtr) := GetPointeri_vEXT(pname, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointeri_vEXT(pname: DummyEnum; index: UInt32; &params: pointer) := z_GetPointeri_vEXT(pname, index, &params);
    
    public z_GetPointerIndexedvEXT: procedure(target: DummyEnum; index: UInt32; data: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; data: pointer)>(GetGLProcAdr('glGetPointerIndexedvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerIndexedvEXT(target: DummyEnum; index: UInt32; data: array of IntPtr) := GetPointerIndexedvEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerIndexedvEXT(target: DummyEnum; index: UInt32; var data: IntPtr) := GetPointerIndexedvEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPointerIndexedvEXT(target: DummyEnum; index: UInt32; data: pointer) := z_GetPointerIndexedvEXT(target, index, data);
    
    public z_GetVertexArrayIntegeri_vEXT: procedure(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: pointer)>(GetGLProcAdr('glGetVertexArrayIntegeri_vEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: array of Int32) := GetVertexArrayIntegeri_vEXT(vaobj, index, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; var param: Int32) := GetVertexArrayIntegeri_vEXT(vaobj, index, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: pointer) := z_GetVertexArrayIntegeri_vEXT(vaobj, index, pname, param);
    
    public z_GetVertexArrayIntegervEXT: procedure(vaobj: UInt32; pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(vaobj: UInt32; pname: DummyEnum; param: pointer)>(GetGLProcAdr('glGetVertexArrayIntegervEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegervEXT(vaobj: UInt32; pname: DummyEnum; param: array of Int32) := GetVertexArrayIntegervEXT(vaobj, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegervEXT(vaobj: UInt32; pname: DummyEnum; var param: Int32) := GetVertexArrayIntegervEXT(vaobj, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayIntegervEXT(vaobj: UInt32; pname: DummyEnum; param: pointer) := z_GetVertexArrayIntegervEXT(vaobj, pname, param);
    
    public z_GetVertexArrayPointeri_vEXT: procedure(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: pointer)>(GetGLProcAdr('glGetVertexArrayPointeri_vEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: array of IntPtr) := GetVertexArrayPointeri_vEXT(vaobj, index, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; var param: IntPtr) := GetVertexArrayPointeri_vEXT(vaobj, index, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointeri_vEXT(vaobj: UInt32; index: UInt32; pname: DummyEnum; param: pointer) := z_GetVertexArrayPointeri_vEXT(vaobj, index, pname, param);
    
    public z_GetVertexArrayPointervEXT: procedure(vaobj: UInt32; pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(vaobj: UInt32; pname: DummyEnum; param: pointer)>(GetGLProcAdr('glGetVertexArrayPointervEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointervEXT(vaobj: UInt32; pname: DummyEnum; param: array of IntPtr) := GetVertexArrayPointervEXT(vaobj, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointervEXT(vaobj: UInt32; pname: DummyEnum; var param: IntPtr) := GetVertexArrayPointervEXT(vaobj, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexArrayPointervEXT(vaobj: UInt32; pname: DummyEnum; param: pointer) := z_GetVertexArrayPointervEXT(vaobj, pname, param);
    
    public z_IndexFuncEXT: procedure(func: DummyEnum; ref: single) := FuncPtrOrNil&<procedure(func: DummyEnum; ref: single)>(GetGLProcAdr('glIndexFuncEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexFuncEXT(func: DummyEnum; ref: single) := z_IndexFuncEXT(func, ref);
    
    public z_IndexMaterialEXT: procedure(face: DummyEnum; mode: DummyEnum) := FuncPtrOrNil&<procedure(face: DummyEnum; mode: DummyEnum)>(GetGLProcAdr('glIndexMaterialEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexMaterialEXT(face: DummyEnum; mode: DummyEnum) := z_IndexMaterialEXT(face, mode);
    
    public z_MatrixFrustumEXT: procedure(mode: DummyEnum; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) := FuncPtrOrNil&<procedure(mode: DummyEnum; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double)>(GetGLProcAdr('glMatrixFrustumEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixFrustumEXT(mode: DummyEnum; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) := z_MatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
    
    public z_MatrixLoaddEXT: procedure(mode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(mode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixLoaddEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: DummyEnum; m: array of double) := MatrixLoaddEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: DummyEnum; var m: double) := MatrixLoaddEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoaddEXT(mode: DummyEnum; m: pointer) := z_MatrixLoaddEXT(mode, m);
    
    public z_MatrixLoadfEXT: procedure(mode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(mode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixLoadfEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: DummyEnum; m: array of single) := MatrixLoadfEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: DummyEnum; var m: single) := MatrixLoadfEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadfEXT(mode: DummyEnum; m: pointer) := z_MatrixLoadfEXT(mode, m);
    
    public z_MatrixLoadIdentityEXT: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glMatrixLoadIdentityEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadIdentityEXT(mode: DummyEnum) := z_MatrixLoadIdentityEXT(mode);
    
    public z_MatrixLoadTransposedEXT: procedure(mode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(mode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixLoadTransposedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: DummyEnum; m: array of double) := MatrixLoadTransposedEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: DummyEnum; var m: double) := MatrixLoadTransposedEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposedEXT(mode: DummyEnum; m: pointer) := z_MatrixLoadTransposedEXT(mode, m);
    
    public z_MatrixLoadTransposefEXT: procedure(mode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(mode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixLoadTransposefEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: DummyEnum; m: array of single) := MatrixLoadTransposefEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: DummyEnum; var m: single) := MatrixLoadTransposefEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTransposefEXT(mode: DummyEnum; m: pointer) := z_MatrixLoadTransposefEXT(mode, m);
    
    public z_MatrixMultdEXT: procedure(mode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(mode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixMultdEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: DummyEnum; m: array of double) := MatrixMultdEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: DummyEnum; var m: double) := MatrixMultdEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultdEXT(mode: DummyEnum; m: pointer) := z_MatrixMultdEXT(mode, m);
    
    public z_MatrixMultfEXT: procedure(mode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(mode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixMultfEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: DummyEnum; m: array of single) := MatrixMultfEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: DummyEnum; var m: single) := MatrixMultfEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultfEXT(mode: DummyEnum; m: pointer) := z_MatrixMultfEXT(mode, m);
    
    public z_MatrixMultTransposedEXT: procedure(mode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(mode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixMultTransposedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: DummyEnum; m: array of double) := MatrixMultTransposedEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: DummyEnum; var m: double) := MatrixMultTransposedEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposedEXT(mode: DummyEnum; m: pointer) := z_MatrixMultTransposedEXT(mode, m);
    
    public z_MatrixMultTransposefEXT: procedure(mode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(mode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixMultTransposefEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: DummyEnum; m: array of single) := MatrixMultTransposefEXT(mode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: DummyEnum; var m: single) := MatrixMultTransposefEXT(mode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTransposefEXT(mode: DummyEnum; m: pointer) := z_MatrixMultTransposefEXT(mode, m);
    
    public z_MatrixOrthoEXT: procedure(mode: DummyEnum; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) := FuncPtrOrNil&<procedure(mode: DummyEnum; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double)>(GetGLProcAdr('glMatrixOrthoEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixOrthoEXT(mode: DummyEnum; left: double; right: double; bottom: double; top: double; zNear: double; zFar: double) := z_MatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
    
    public z_MatrixPopEXT: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glMatrixPopEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPopEXT(mode: DummyEnum) := z_MatrixPopEXT(mode);
    
    public z_MatrixPushEXT: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glMatrixPushEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixPushEXT(mode: DummyEnum) := z_MatrixPushEXT(mode);
    
    public z_MatrixRotatedEXT: procedure(mode: DummyEnum; angle: double; x: double; y: double; z: double) := FuncPtrOrNil&<procedure(mode: DummyEnum; angle: double; x: double; y: double; z: double)>(GetGLProcAdr('glMatrixRotatedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatedEXT(mode: DummyEnum; angle: double; x: double; y: double; z: double) := z_MatrixRotatedEXT(mode, angle, x, y, z);
    
    public z_MatrixRotatefEXT: procedure(mode: DummyEnum; angle: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(mode: DummyEnum; angle: single; x: single; y: single; z: single)>(GetGLProcAdr('glMatrixRotatefEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixRotatefEXT(mode: DummyEnum; angle: single; x: single; y: single; z: single) := z_MatrixRotatefEXT(mode, angle, x, y, z);
    
    public z_MatrixScaledEXT: procedure(mode: DummyEnum; x: double; y: double; z: double) := FuncPtrOrNil&<procedure(mode: DummyEnum; x: double; y: double; z: double)>(GetGLProcAdr('glMatrixScaledEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScaledEXT(mode: DummyEnum; x: double; y: double; z: double) := z_MatrixScaledEXT(mode, x, y, z);
    
    public z_MatrixScalefEXT: procedure(mode: DummyEnum; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(mode: DummyEnum; x: single; y: single; z: single)>(GetGLProcAdr('glMatrixScalefEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixScalefEXT(mode: DummyEnum; x: single; y: single; z: single) := z_MatrixScalefEXT(mode, x, y, z);
    
    public z_MatrixTranslatedEXT: procedure(mode: DummyEnum; x: double; y: double; z: double) := FuncPtrOrNil&<procedure(mode: DummyEnum; x: double; y: double; z: double)>(GetGLProcAdr('glMatrixTranslatedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatedEXT(mode: DummyEnum; x: double; y: double; z: double) := z_MatrixTranslatedEXT(mode, x, y, z);
    
    public z_MatrixTranslatefEXT: procedure(mode: DummyEnum; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(mode: DummyEnum; x: single; y: single; z: single)>(GetGLProcAdr('glMatrixTranslatefEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixTranslatefEXT(mode: DummyEnum; x: single; y: single; z: single) := z_MatrixTranslatefEXT(mode, x, y, z);
    
    public z_MultiTexBufferEXT: procedure(texunit: DummyEnum; target: DummyEnum; internalformat: DummyEnum; buffer: UInt32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; internalformat: DummyEnum; buffer: UInt32)>(GetGLProcAdr('glMultiTexBufferEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexBufferEXT(texunit: DummyEnum; target: DummyEnum; internalformat: DummyEnum; buffer: UInt32) := z_MultiTexBufferEXT(texunit, target, internalformat, buffer);
    
    public z_MultiTexCoordPointerEXT: procedure(texunit: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>(GetGLProcAdr('glMultiTexCoordPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoordPointerEXT(texunit: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_MultiTexCoordPointerEXT(texunit, size, &type, stride, _pointer);
    
    public z_MultiTexEnvfEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glMultiTexEnvfEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: single) := z_MultiTexEnvfEXT(texunit, target, pname, param);
    
    public z_MultiTexEnvfvEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMultiTexEnvfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of single) := MultiTexEnvfvEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: single) := MultiTexEnvfvEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexEnvfvEXT(texunit, target, pname, &params);
    
    public z_MultiTexEnviEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glMultiTexEnviEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnviEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: Int32) := z_MultiTexEnviEXT(texunit, target, pname, param);
    
    public z_MultiTexEnvivEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMultiTexEnvivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := MultiTexEnvivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := MultiTexEnvivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexEnvivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexEnvivEXT(texunit, target, pname, &params);
    
    public z_MultiTexGendEXT: procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: double) := FuncPtrOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: double)>(GetGLProcAdr('glMultiTexGendEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: double) := z_MultiTexGendEXT(texunit, coord, pname, param);
    
    public z_MultiTexGendvEXT: procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMultiTexGendvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of double) := MultiTexGendvEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: double) := MultiTexGendvEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGendvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexGendvEXT(texunit, coord, pname, &params);
    
    public z_MultiTexGenfEXT: procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glMultiTexGenfEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: single) := z_MultiTexGenfEXT(texunit, coord, pname, param);
    
    public z_MultiTexGenfvEXT: procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMultiTexGenfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of single) := MultiTexGenfvEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: single) := MultiTexGenfvEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenfvEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexGenfvEXT(texunit, coord, pname, &params);
    
    public z_MultiTexGeniEXT: procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glMultiTexGeniEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGeniEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; param: Int32) := z_MultiTexGeniEXT(texunit, coord, pname, param);
    
    public z_MultiTexGenivEXT: procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMultiTexGenivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: array of Int32) := MultiTexGenivEXT(texunit, coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; var &params: Int32) := MultiTexGenivEXT(texunit, coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexGenivEXT(texunit: DummyEnum; coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexGenivEXT(texunit, coord, pname, &params);
    
    public z_MultiTexImage1DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glMultiTexImage1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, &type, pixels);
    
    public z_MultiTexImage2DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glMultiTexImage2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, &type, pixels);
    
    public z_MultiTexImage3DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glMultiTexImage3DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexImage3DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    public z_MultiTexParameterfEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glMultiTexParameterfEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: single) := z_MultiTexParameterfEXT(texunit, target, pname, param);
    
    public z_MultiTexParameterfvEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMultiTexParameterfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of single) := MultiTexParameterfvEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: single) := MultiTexParameterfvEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterfvEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexParameterfvEXT(texunit, target, pname, &params);
    
    public z_MultiTexParameteriEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glMultiTexParameteriEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameteriEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; param: Int32) := z_MultiTexParameteriEXT(texunit, target, pname, param);
    
    public z_MultiTexParameterIivEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMultiTexParameterIivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := MultiTexParameterIivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := MultiTexParameterIivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexParameterIivEXT(texunit, target, pname, &params);
    
    public z_MultiTexParameterIuivEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMultiTexParameterIuivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of UInt32) := MultiTexParameterIuivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: UInt32) := MultiTexParameterIuivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterIuivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexParameterIuivEXT(texunit, target, pname, &params);
    
    public z_MultiTexParameterivEXT: procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMultiTexParameterivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: array of Int32) := MultiTexParameterivEXT(texunit, target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; var &params: Int32) := MultiTexParameterivEXT(texunit, target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexParameterivEXT(texunit: DummyEnum; target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MultiTexParameterivEXT(texunit, target, pname, &params);
    
    public z_MultiTexRenderbufferEXT: procedure(texunit: DummyEnum; target: DummyEnum; renderbuffer: UInt32) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; renderbuffer: UInt32)>(GetGLProcAdr('glMultiTexRenderbufferEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexRenderbufferEXT(texunit: DummyEnum; target: DummyEnum; renderbuffer: UInt32) := z_MultiTexRenderbufferEXT(texunit, target, renderbuffer);
    
    public z_MultiTexSubImage1DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glMultiTexSubImage1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage1DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; width: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, &type, pixels);
    
    public z_MultiTexSubImage2DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glMultiTexSubImage2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage2DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; width: Int32; height: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, &type, pixels);
    
    public z_MultiTexSubImage3DEXT: procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glMultiTexSubImage3DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexSubImage3DEXT(texunit: DummyEnum; target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_MultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, pixels);
    
    public z_NamedBufferPageCommitmentEXT: procedure(buffer: UInt32; offset: IntPtr; size: UIntPtr; commit: Byte) := FuncPtrOrNil&<procedure(buffer: UInt32; offset: IntPtr; size: UIntPtr; commit: Byte)>(GetGLProcAdr('glNamedBufferPageCommitmentEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferPageCommitmentEXT(buffer: UInt32; offset: IntPtr; size: UIntPtr; commit: Byte) := z_NamedBufferPageCommitmentEXT(buffer, offset, size, commit);
    
    public z_NamedCopyBufferSubDataEXT: procedure(readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := FuncPtrOrNil&<procedure(readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(GetGLProcAdr('glNamedCopyBufferSubDataEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedCopyBufferSubDataEXT(readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_NamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    public z_NamedFramebufferTexture1DEXT: procedure(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32) := FuncPtrOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32)>(GetGLProcAdr('glNamedFramebufferTexture1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture1DEXT(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32) := z_NamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
    
    public z_NamedFramebufferTexture2DEXT: procedure(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32) := FuncPtrOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32)>(GetGLProcAdr('glNamedFramebufferTexture2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture2DEXT(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32) := z_NamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
    
    public z_NamedFramebufferTexture3DEXT: procedure(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; zoffset: Int32) := FuncPtrOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; zoffset: Int32)>(GetGLProcAdr('glNamedFramebufferTexture3DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTexture3DEXT(framebuffer: UInt32; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; zoffset: Int32) := z_NamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
    
    public z_NamedFramebufferTextureFaceEXT: procedure(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum) := FuncPtrOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum)>(GetGLProcAdr('glNamedFramebufferTextureFaceEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureFaceEXT(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; face: DummyEnum) := z_NamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
    
    public z_NamedProgramLocalParameter4dEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double)>(GetGLProcAdr('glNamedProgramLocalParameter4dEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dEXT(&program: UInt32; target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := z_NamedProgramLocalParameter4dEXT(&program, target, index, x, y, z, w);
    
    public z_NamedProgramLocalParameter4dvEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glNamedProgramLocalParameter4dvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of double) := NamedProgramLocalParameter4dvEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: double) := NamedProgramLocalParameter4dvEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4dvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_NamedProgramLocalParameter4dvEXT(&program, target, index, &params);
    
    public z_NamedProgramLocalParameter4fEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single)>(GetGLProcAdr('glNamedProgramLocalParameter4fEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fEXT(&program: UInt32; target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := z_NamedProgramLocalParameter4fEXT(&program, target, index, x, y, z, w);
    
    public z_NamedProgramLocalParameter4fvEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glNamedProgramLocalParameter4fvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of single) := NamedProgramLocalParameter4fvEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: single) := NamedProgramLocalParameter4fvEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameter4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_NamedProgramLocalParameter4fvEXT(&program, target, index, &params);
    
    public z_NamedProgramLocalParameterI4iEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(GetGLProcAdr('glNamedProgramLocalParameterI4iEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4iEXT(&program: UInt32; target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := z_NamedProgramLocalParameterI4iEXT(&program, target, index, x, y, z, w);
    
    public z_NamedProgramLocalParameterI4ivEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glNamedProgramLocalParameterI4ivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of Int32) := NamedProgramLocalParameterI4ivEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: Int32) := NamedProgramLocalParameterI4ivEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_NamedProgramLocalParameterI4ivEXT(&program, target, index, &params);
    
    public z_NamedProgramLocalParameterI4uiEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(GetGLProcAdr('glNamedProgramLocalParameterI4uiEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uiEXT(&program: UInt32; target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := z_NamedProgramLocalParameterI4uiEXT(&program, target, index, x, y, z, w);
    
    public z_NamedProgramLocalParameterI4uivEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glNamedProgramLocalParameterI4uivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: array of UInt32) := NamedProgramLocalParameterI4uivEXT(&program, target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; var &params: UInt32) := NamedProgramLocalParameterI4uivEXT(&program, target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameterI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; &params: pointer) := z_NamedProgramLocalParameterI4uivEXT(&program, target, index, &params);
    
    public z_NamedProgramLocalParameters4fvEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glNamedProgramLocalParameters4fvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: array of single) := NamedProgramLocalParameters4fvEXT(&program, target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; var &params: single) := NamedProgramLocalParameters4fvEXT(&program, target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParameters4fvEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_NamedProgramLocalParameters4fvEXT(&program, target, index, count, &params);
    
    public z_NamedProgramLocalParametersI4ivEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glNamedProgramLocalParametersI4ivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: array of Int32) := NamedProgramLocalParametersI4ivEXT(&program, target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; var &params: Int32) := NamedProgramLocalParametersI4ivEXT(&program, target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4ivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_NamedProgramLocalParametersI4ivEXT(&program, target, index, count, &params);
    
    public z_NamedProgramLocalParametersI4uivEXT: procedure(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glNamedProgramLocalParametersI4uivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: array of UInt32) := NamedProgramLocalParametersI4uivEXT(&program, target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; var &params: UInt32) := NamedProgramLocalParametersI4uivEXT(&program, target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramLocalParametersI4uivEXT(&program: UInt32; target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_NamedProgramLocalParametersI4uivEXT(&program, target, index, count, &params);
    
    public z_NamedProgramStringEXT: procedure(&program: UInt32; target: DummyEnum; format: DummyEnum; len: Int32; string: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; target: DummyEnum; format: DummyEnum; len: Int32; string: pointer)>(GetGLProcAdr('glNamedProgramStringEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedProgramStringEXT(&program: UInt32; target: DummyEnum; format: DummyEnum; len: Int32; string: pointer) := z_NamedProgramStringEXT(&program, target, format, len, string);
    
    public z_NamedRenderbufferStorageMultisampleCoverageEXT: procedure(renderbuffer: UInt32; coverageSamples: Int32; colorSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := FuncPtrOrNil&<procedure(renderbuffer: UInt32; coverageSamples: Int32; colorSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>(GetGLProcAdr('glNamedRenderbufferStorageMultisampleCoverageEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer: UInt32; coverageSamples: Int32; colorSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_NamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
    
    public z_PushClientAttribDefaultEXT: procedure(mask: DummyFlags) := FuncPtrOrNil&<procedure(mask: DummyFlags)>(GetGLProcAdr('glPushClientAttribDefaultEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushClientAttribDefaultEXT(mask: DummyFlags) := z_PushClientAttribDefaultEXT(mask);
    
    public z_TextureImage1DEXT: procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glTextureImage1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage1DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TextureImage1DEXT(texture, target, level, internalformat, width, border, format, &type, pixels);
    
    public z_TextureImage2DEXT: procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glTextureImage2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, &type, pixels);
    
    public z_TextureImage3DEXT: procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glTextureImage3DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DEXT(texture: UInt32; target: DummyEnum; level: Int32; internalformat: Int32; width: Int32; height: Int32; depth: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, &type, pixels);
    
    public z_TextureRenderbufferEXT: procedure(texture: UInt32; target: DummyEnum; renderbuffer: UInt32) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; renderbuffer: UInt32)>(GetGLProcAdr('glTextureRenderbufferEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureRenderbufferEXT(texture: UInt32; target: DummyEnum; renderbuffer: UInt32) := z_TextureRenderbufferEXT(texture, target, renderbuffer);
    
    public z_VertexArrayColorOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayColorOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayColorOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayColorOffsetEXT(vaobj, buffer, size, &type, stride, offset);
    
    public z_VertexArrayEdgeFlagOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayEdgeFlagOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayEdgeFlagOffsetEXT(vaobj: UInt32; buffer: UInt32; stride: Int32; offset: IntPtr) := z_VertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
    
    public z_VertexArrayFogCoordOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayFogCoordOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayFogCoordOffsetEXT(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayFogCoordOffsetEXT(vaobj, buffer, &type, stride, offset);
    
    public z_VertexArrayIndexOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayIndexOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayIndexOffsetEXT(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayIndexOffsetEXT(vaobj, buffer, &type, stride, offset);
    
    public z_VertexArrayMultiTexCoordOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; texunit: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; texunit: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayMultiTexCoordOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayMultiTexCoordOffsetEXT(vaobj: UInt32; buffer: UInt32; texunit: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, &type, stride, offset);
    
    public z_VertexArrayNormalOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayNormalOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayNormalOffsetEXT(vaobj: UInt32; buffer: UInt32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayNormalOffsetEXT(vaobj, buffer, &type, stride, offset);
    
    public z_VertexArraySecondaryColorOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArraySecondaryColorOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArraySecondaryColorOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, &type, stride, offset);
    
    public z_VertexArrayTexCoordOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayTexCoordOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayTexCoordOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayTexCoordOffsetEXT(vaobj, buffer, size, &type, stride, offset);
    
    public z_VertexArrayVertexAttribIOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayVertexAttribIOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribIOffsetEXT(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, &type, stride, offset);
    
    public z_VertexArrayVertexAttribOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; normalized: Byte; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; normalized: Byte; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayVertexAttribOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribOffsetEXT(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; normalized: Byte; stride: Int32; offset: IntPtr) := z_VertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, &type, normalized, stride, offset);
    
    public z_VertexArrayVertexOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayVertexOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexOffsetEXT(vaobj: UInt32; buffer: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayVertexOffsetEXT(vaobj, buffer, size, &type, stride, offset);
    
    {$endregion Unsorted}
    
    {$region ARB_instanced_arrays}
    
    public z_VertexArrayVertexAttribDivisorEXT: procedure(vaobj: UInt32; index: UInt32; divisor: UInt32) := FuncPtrOrNil&<procedure(vaobj: UInt32; index: UInt32; divisor: UInt32)>(GetGLProcAdr('glVertexArrayVertexAttribDivisorEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribDivisorEXT(vaobj: UInt32; index: UInt32; divisor: UInt32) := z_VertexArrayVertexAttribDivisorEXT(vaobj, index, divisor);
    
    {$endregion ARB_instanced_arrays}
    
    {$region ARB_vertex_attrib_binding}
    
    public z_VertexArrayBindVertexBufferEXT: procedure(vaobj: UInt32; bindingindex: UInt32; buffer: UInt32; offset: IntPtr; stride: Int32) := FuncPtrOrNil&<procedure(vaobj: UInt32; bindingindex: UInt32; buffer: UInt32; offset: IntPtr; stride: Int32)>(GetGLProcAdr('glVertexArrayBindVertexBufferEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayBindVertexBufferEXT(vaobj: UInt32; bindingindex: UInt32; buffer: UInt32; offset: IntPtr; stride: Int32) := z_VertexArrayBindVertexBufferEXT(vaobj, bindingindex, buffer, offset, stride);
    
    public z_VertexArrayVertexAttribFormatEXT: procedure(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; normalized: Byte; relativeoffset: UInt32) := FuncPtrOrNil&<procedure(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; normalized: Byte; relativeoffset: UInt32)>(GetGLProcAdr('glVertexArrayVertexAttribFormatEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribFormatEXT(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; normalized: Byte; relativeoffset: UInt32) := z_VertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, &type, normalized, relativeoffset);
    
    public z_VertexArrayVertexAttribIFormatEXT: procedure(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; relativeoffset: UInt32) := FuncPtrOrNil&<procedure(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; relativeoffset: UInt32)>(GetGLProcAdr('glVertexArrayVertexAttribIFormatEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribIFormatEXT(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; relativeoffset: UInt32) := z_VertexArrayVertexAttribIFormatEXT(vaobj, attribindex, size, &type, relativeoffset);
    
    public z_VertexArrayVertexAttribLFormatEXT: procedure(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; relativeoffset: UInt32) := FuncPtrOrNil&<procedure(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; relativeoffset: UInt32)>(GetGLProcAdr('glVertexArrayVertexAttribLFormatEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribLFormatEXT(vaobj: UInt32; attribindex: UInt32; size: Int32; &type: DummyEnum; relativeoffset: UInt32) := z_VertexArrayVertexAttribLFormatEXT(vaobj, attribindex, size, &type, relativeoffset);
    
    public z_VertexArrayVertexAttribBindingEXT: procedure(vaobj: UInt32; attribindex: UInt32; bindingindex: UInt32) := FuncPtrOrNil&<procedure(vaobj: UInt32; attribindex: UInt32; bindingindex: UInt32)>(GetGLProcAdr('glVertexArrayVertexAttribBindingEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribBindingEXT(vaobj: UInt32; attribindex: UInt32; bindingindex: UInt32) := z_VertexArrayVertexAttribBindingEXT(vaobj, attribindex, bindingindex);
    
    public z_VertexArrayVertexBindingDivisorEXT: procedure(vaobj: UInt32; bindingindex: UInt32; divisor: UInt32) := FuncPtrOrNil&<procedure(vaobj: UInt32; bindingindex: UInt32; divisor: UInt32)>(GetGLProcAdr('glVertexArrayVertexBindingDivisorEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexBindingDivisorEXT(vaobj: UInt32; bindingindex: UInt32; divisor: UInt32) := z_VertexArrayVertexBindingDivisorEXT(vaobj, bindingindex, divisor);
    
    {$endregion ARB_vertex_attrib_binding}
    
    {$region EXT_bindable_uniform}
    
    public z_UniformBufferEXT: procedure(&program: UInt32; location: Int32; buffer: UInt32) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; buffer: UInt32)>(GetGLProcAdr('glUniformBufferEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UniformBufferEXT(&program: UInt32; location: Int32; buffer: UInt32) := z_UniformBufferEXT(&program, location, buffer);
    
    public z_GetUniformBufferSizeEXT: function(&program: UInt32; location: Int32): Int32 := FuncPtrOrNil&<function(&program: UInt32; location: Int32): Int32>(GetGLProcAdr('glGetUniformBufferSizeEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformBufferSizeEXT(&program: UInt32; location: Int32): Int32 := z_GetUniformBufferSizeEXT(&program, location);
    
    public z_GetUniformOffsetEXT: function(&program: UInt32; location: Int32): IntPtr := FuncPtrOrNil&<function(&program: UInt32; location: Int32): IntPtr>(GetGLProcAdr('glGetUniformOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetUniformOffsetEXT(&program: UInt32; location: Int32): IntPtr := z_GetUniformOffsetEXT(&program, location);
    
    {$endregion EXT_bindable_uniform}
    
    {$region EXT_coordinate_frame}
    
    public z_Tangent3bEXT: procedure(tx: SByte; ty: SByte; tz: SByte) := FuncPtrOrNil&<procedure(tx: SByte; ty: SByte; tz: SByte)>(GetGLProcAdr('glTangent3bEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bEXT(tx: SByte; ty: SByte; tz: SByte) := z_Tangent3bEXT(tx, ty, tz);
    
    public z_Tangent3sEXT: procedure(tx: Int16; ty: Int16; tz: Int16) := FuncPtrOrNil&<procedure(tx: Int16; ty: Int16; tz: Int16)>(GetGLProcAdr('glTangent3sEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3sEXT(tx: Int16; ty: Int16; tz: Int16) := z_Tangent3sEXT(tx, ty, tz);
    
    public z_Tangent3iEXT: procedure(tx: Int32; ty: Int32; tz: Int32) := FuncPtrOrNil&<procedure(tx: Int32; ty: Int32; tz: Int32)>(GetGLProcAdr('glTangent3iEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3iEXT(tx: Int32; ty: Int32; tz: Int32) := z_Tangent3iEXT(tx, ty, tz);
    
    public z_Tangent3fEXT: procedure(tx: single; ty: single; tz: single) := FuncPtrOrNil&<procedure(tx: single; ty: single; tz: single)>(GetGLProcAdr('glTangent3fEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fEXT(tx: single; ty: single; tz: single) := z_Tangent3fEXT(tx, ty, tz);
    
    public z_Tangent3dEXT: procedure(tx: double; ty: double; tz: double) := FuncPtrOrNil&<procedure(tx: double; ty: double; tz: double)>(GetGLProcAdr('glTangent3dEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dEXT(tx: double; ty: double; tz: double) := z_Tangent3dEXT(tx, ty, tz);
    
    public z_Tangent3bvEXT: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glTangent3bvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(v: array of SByte) := Tangent3bvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(var v: SByte) := Tangent3bvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3bvEXT(v: pointer) := z_Tangent3bvEXT(v);
    
    public z_Tangent3svEXT: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glTangent3svEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(v: array of Int16) := Tangent3svEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(var v: Int16) := Tangent3svEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3svEXT(v: pointer) := z_Tangent3svEXT(v);
    
    public z_Tangent3ivEXT: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glTangent3ivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(v: array of Int32) := Tangent3ivEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(var v: Int32) := Tangent3ivEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3ivEXT(v: pointer) := z_Tangent3ivEXT(v);
    
    public z_Tangent3fvEXT: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glTangent3fvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(v: array of single) := Tangent3fvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(var v: single) := Tangent3fvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3fvEXT(v: pointer) := z_Tangent3fvEXT(v);
    
    public z_Tangent3dvEXT: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glTangent3dvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(v: array of double) := Tangent3dvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(var v: double) := Tangent3dvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Tangent3dvEXT(v: pointer) := z_Tangent3dvEXT(v);
    
    public z_Binormal3bEXT: procedure(bx: SByte; by: SByte; bz: SByte) := FuncPtrOrNil&<procedure(bx: SByte; by: SByte; bz: SByte)>(GetGLProcAdr('glBinormal3bEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bEXT(bx: SByte; by: SByte; bz: SByte) := z_Binormal3bEXT(bx, by, bz);
    
    public z_Binormal3sEXT: procedure(bx: Int16; by: Int16; bz: Int16) := FuncPtrOrNil&<procedure(bx: Int16; by: Int16; bz: Int16)>(GetGLProcAdr('glBinormal3sEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3sEXT(bx: Int16; by: Int16; bz: Int16) := z_Binormal3sEXT(bx, by, bz);
    
    public z_Binormal3iEXT: procedure(bx: Int32; by: Int32; bz: Int32) := FuncPtrOrNil&<procedure(bx: Int32; by: Int32; bz: Int32)>(GetGLProcAdr('glBinormal3iEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3iEXT(bx: Int32; by: Int32; bz: Int32) := z_Binormal3iEXT(bx, by, bz);
    
    public z_Binormal3fEXT: procedure(bx: single; by: single; bz: single) := FuncPtrOrNil&<procedure(bx: single; by: single; bz: single)>(GetGLProcAdr('glBinormal3fEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fEXT(bx: single; by: single; bz: single) := z_Binormal3fEXT(bx, by, bz);
    
    public z_Binormal3dEXT: procedure(bx: double; by: double; bz: double) := FuncPtrOrNil&<procedure(bx: double; by: double; bz: double)>(GetGLProcAdr('glBinormal3dEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dEXT(bx: double; by: double; bz: double) := z_Binormal3dEXT(bx, by, bz);
    
    public z_Binormal3bvEXT: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glBinormal3bvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(v: array of SByte) := Binormal3bvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(var v: SByte) := Binormal3bvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3bvEXT(v: pointer) := z_Binormal3bvEXT(v);
    
    public z_Binormal3svEXT: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glBinormal3svEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(v: array of Int16) := Binormal3svEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(var v: Int16) := Binormal3svEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3svEXT(v: pointer) := z_Binormal3svEXT(v);
    
    public z_Binormal3ivEXT: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glBinormal3ivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(v: array of Int32) := Binormal3ivEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(var v: Int32) := Binormal3ivEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3ivEXT(v: pointer) := z_Binormal3ivEXT(v);
    
    public z_Binormal3fvEXT: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glBinormal3fvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(v: array of single) := Binormal3fvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(var v: single) := Binormal3fvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3fvEXT(v: pointer) := z_Binormal3fvEXT(v);
    
    public z_Binormal3dvEXT: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glBinormal3dvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(v: array of double) := Binormal3dvEXT(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(var v: double) := Binormal3dvEXT(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Binormal3dvEXT(v: pointer) := z_Binormal3dvEXT(v);
    
    public z_TangentPointerEXT: procedure(&type: DummyEnum; stride: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>(GetGLProcAdr('glTangentPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TangentPointerEXT(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_TangentPointerEXT(&type, stride, _pointer);
    
    public z_BinormalPointerEXT: procedure(&type: DummyEnum; stride: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>(GetGLProcAdr('glBinormalPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BinormalPointerEXT(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_BinormalPointerEXT(&type, stride, _pointer);
    
    {$endregion EXT_coordinate_frame}
    
    {$region EXT_debug_label}
    
    public z_LabelObjectEXT: procedure(&type: DummyEnum; object: UInt32; length: Int32; &label: IntPtr) := FuncPtrOrNil&<procedure(&type: DummyEnum; object: UInt32; length: Int32; &label: IntPtr)>(GetGLProcAdr('glLabelObjectEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LabelObjectEXT(&type: DummyEnum; object: UInt32; length: Int32; &label: string); begin var ptr4 := Marshal.StringToHGlobalAnsi(&label); LabelObjectEXT(&type, object, length, ptr4); &label := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LabelObjectEXT(&type: DummyEnum; object: UInt32; length: Int32; &label: IntPtr) := z_LabelObjectEXT(&type, object, length, &label);
    
    {$endregion EXT_debug_label}
    
    {$region EXT_debug_marker}
    
    public z_InsertEventMarkerEXT: procedure(length: Int32; marker: IntPtr) := FuncPtrOrNil&<procedure(length: Int32; marker: IntPtr)>(GetGLProcAdr('glInsertEventMarkerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertEventMarkerEXT(length: Int32; marker: string); begin var ptr2 := Marshal.StringToHGlobalAnsi(marker); InsertEventMarkerEXT(length, ptr2); marker := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertEventMarkerEXT(length: Int32; marker: IntPtr) := z_InsertEventMarkerEXT(length, marker);
    
    public z_PushGroupMarkerEXT: procedure(length: Int32; marker: IntPtr) := FuncPtrOrNil&<procedure(length: Int32; marker: IntPtr)>(GetGLProcAdr('glPushGroupMarkerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushGroupMarkerEXT(length: Int32; marker: string); begin var ptr2 := Marshal.StringToHGlobalAnsi(marker); PushGroupMarkerEXT(length, ptr2); marker := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PushGroupMarkerEXT(length: Int32; marker: IntPtr) := z_PushGroupMarkerEXT(length, marker);
    
    public z_PopGroupMarkerEXT: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glPopGroupMarkerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PopGroupMarkerEXT := z_PopGroupMarkerEXT();
    
    {$endregion EXT_debug_marker}
    
    {$region EXT_depth_bounds_test}
    
    public z_DepthBoundsEXT: procedure(zmin: double; zmax: double) := FuncPtrOrNil&<procedure(zmin: double; zmax: double)>(GetGLProcAdr('glDepthBoundsEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthBoundsEXT(zmin: double; zmax: double) := z_DepthBoundsEXT(zmin, zmax);
    
    {$endregion EXT_depth_bounds_test}
    
    {$region EXT_discard_framebuffer}
    
    public z_DiscardFramebufferEXT: procedure(target: DummyEnum; numAttachments: Int32; attachments: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; numAttachments: Int32; attachments: pointer)>(GetGLProcAdr('glDiscardFramebufferEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DiscardFramebufferEXT(target: DummyEnum; numAttachments: Int32; attachments: array of DummyEnum) := DiscardFramebufferEXT(target, numAttachments, attachments[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DiscardFramebufferEXT(target: DummyEnum; numAttachments: Int32; var attachments: DummyEnum) := DiscardFramebufferEXT(target, numAttachments, @attachments);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DiscardFramebufferEXT(target: DummyEnum; numAttachments: Int32; attachments: pointer) := z_DiscardFramebufferEXT(target, numAttachments, attachments);
    
    {$endregion EXT_discard_framebuffer}
    
    {$region EXT_draw_buffers2}
    
    public z_ColorMaskIndexedEXT: procedure(index: UInt32; r: Byte; g: Byte; b: Byte; a: Byte) := FuncPtrOrNil&<procedure(index: UInt32; r: Byte; g: Byte; b: Byte; a: Byte)>(GetGLProcAdr('glColorMaskIndexedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorMaskIndexedEXT(index: UInt32; r: Byte; g: Byte; b: Byte; a: Byte) := z_ColorMaskIndexedEXT(index, r, g, b, a);
    
    {$endregion EXT_draw_buffers2}
    
    {$region EXT_EGL_image_storage}
    
    public z_EGLImageTargetTexStorageEXT: procedure(target: DummyEnum; image: GLeglImageOES; attrib_list: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; image: GLeglImageOES; attrib_list: pointer)>(GetGLProcAdr('glEGLImageTargetTexStorageEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: GLeglImageOES; attrib_list: array of Int32) := EGLImageTargetTexStorageEXT(target, image, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: GLeglImageOES; var attrib_list: Int32) := EGLImageTargetTexStorageEXT(target, image, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexStorageEXT(target: DummyEnum; image: GLeglImageOES; attrib_list: pointer) := z_EGLImageTargetTexStorageEXT(target, image, attrib_list);
    
    public z_EGLImageTargetTextureStorageEXT: procedure(texture: UInt32; image: GLeglImageOES; attrib_list: pointer) := FuncPtrOrNil&<procedure(texture: UInt32; image: GLeglImageOES; attrib_list: pointer)>(GetGLProcAdr('glEGLImageTargetTextureStorageEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: UInt32; image: GLeglImageOES; attrib_list: array of Int32) := EGLImageTargetTextureStorageEXT(texture, image, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: UInt32; image: GLeglImageOES; var attrib_list: Int32) := EGLImageTargetTextureStorageEXT(texture, image, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTextureStorageEXT(texture: UInt32; image: GLeglImageOES; attrib_list: pointer) := z_EGLImageTargetTextureStorageEXT(texture, image, attrib_list);
    
    {$endregion EXT_EGL_image_storage}
    
    {$region EXT_external_buffer}
    
    public z_BufferStorageExternalEXT: procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: DummyFlags) := FuncPtrOrNil&<procedure(target: DummyEnum; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: DummyFlags)>(GetGLProcAdr('glBufferStorageExternalEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorageExternalEXT(target: DummyEnum; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: DummyFlags) := z_BufferStorageExternalEXT(target, offset, size, clientBuffer, flags);
    
    public z_NamedBufferStorageExternalEXT: procedure(buffer: UInt32; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: DummyFlags) := FuncPtrOrNil&<procedure(buffer: UInt32; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: DummyFlags)>(GetGLProcAdr('glNamedBufferStorageExternalEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageExternalEXT(buffer: UInt32; offset: IntPtr; size: UIntPtr; clientBuffer: GLeglClientBufferEXT; flags: DummyFlags) := z_NamedBufferStorageExternalEXT(buffer, offset, size, clientBuffer, flags);
    
    {$endregion EXT_external_buffer}
    
    {$region EXT_external_objects}
    
    public z_GetUnsignedBytevEXT: procedure(pname: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; data: pointer)>(GetGLProcAdr('glGetUnsignedBytevEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: DummyEnum; data: array of Byte) := GetUnsignedBytevEXT(pname, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: DummyEnum; var data: Byte) := GetUnsignedBytevEXT(pname, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytevEXT(pname: DummyEnum; data: pointer) := z_GetUnsignedBytevEXT(pname, data);
    
    public z_GetUnsignedBytei_vEXT: procedure(target: DummyEnum; index: UInt32; data: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; data: pointer)>(GetGLProcAdr('glGetUnsignedBytei_vEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; data: array of Byte) := GetUnsignedBytei_vEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; var data: Byte) := GetUnsignedBytei_vEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetUnsignedBytei_vEXT(target: DummyEnum; index: UInt32; data: pointer) := z_GetUnsignedBytei_vEXT(target, index, data);
    
    public z_DeleteMemoryObjectsEXT: procedure(n: Int32; memoryObjects: pointer) := FuncPtrOrNil&<procedure(n: Int32; memoryObjects: pointer)>(GetGLProcAdr('glDeleteMemoryObjectsEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; memoryObjects: array of UInt32) := DeleteMemoryObjectsEXT(n, memoryObjects[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; var memoryObjects: UInt32) := DeleteMemoryObjectsEXT(n, @memoryObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteMemoryObjectsEXT(n: Int32; memoryObjects: pointer) := z_DeleteMemoryObjectsEXT(n, memoryObjects);
    
    public z_IsMemoryObjectEXT: function(memoryObject: UInt32): Byte := FuncPtrOrNil&<function(memoryObject: UInt32): Byte>(GetGLProcAdr('glIsMemoryObjectEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsMemoryObjectEXT(memoryObject: UInt32): Byte := z_IsMemoryObjectEXT(memoryObject);
    
    public z_CreateMemoryObjectsEXT: procedure(n: Int32; memoryObjects: pointer) := FuncPtrOrNil&<procedure(n: Int32; memoryObjects: pointer)>(GetGLProcAdr('glCreateMemoryObjectsEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; memoryObjects: array of UInt32) := CreateMemoryObjectsEXT(n, memoryObjects[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; var memoryObjects: UInt32) := CreateMemoryObjectsEXT(n, @memoryObjects);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateMemoryObjectsEXT(n: Int32; memoryObjects: pointer) := z_CreateMemoryObjectsEXT(n, memoryObjects);
    
    public z_MemoryObjectParameterivEXT: procedure(memoryObject: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(memoryObject: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMemoryObjectParameterivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; &params: array of Int32) := MemoryObjectParameterivEXT(memoryObject, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; var &params: Int32) := MemoryObjectParameterivEXT(memoryObject, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; &params: pointer) := z_MemoryObjectParameterivEXT(memoryObject, pname, &params);
    
    public z_GetMemoryObjectParameterivEXT: procedure(memoryObject: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(memoryObject: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMemoryObjectParameterivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; &params: array of Int32) := GetMemoryObjectParameterivEXT(memoryObject, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; var &params: Int32) := GetMemoryObjectParameterivEXT(memoryObject, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectParameterivEXT(memoryObject: UInt32; pname: DummyEnum; &params: pointer) := z_GetMemoryObjectParameterivEXT(memoryObject, pname, &params);
    
    public z_TexStorageMem2DEXT: procedure(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTexStorageMem2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem2DEXT(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; memory: UInt32; offset: UInt64) := z_TexStorageMem2DEXT(target, levels, internalFormat, width, height, memory, offset);
    
    public z_TexStorageMem2DMultisampleEXT: procedure(target: DummyEnum; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(target: DummyEnum; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTexStorageMem2DMultisampleEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem2DMultisampleEXT(target: DummyEnum; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64) := z_TexStorageMem2DMultisampleEXT(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
    
    public z_TexStorageMem3DEXT: procedure(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTexStorageMem3DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem3DEXT(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64) := z_TexStorageMem3DEXT(target, levels, internalFormat, width, height, depth, memory, offset);
    
    public z_TexStorageMem3DMultisampleEXT: procedure(target: DummyEnum; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(target: DummyEnum; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTexStorageMem3DMultisampleEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem3DMultisampleEXT(target: DummyEnum; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64) := z_TexStorageMem3DMultisampleEXT(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    
    public z_BufferStorageMemEXT: procedure(target: DummyEnum; size: UIntPtr; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(target: DummyEnum; size: UIntPtr; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glBufferStorageMemEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferStorageMemEXT(target: DummyEnum; size: UIntPtr; memory: UInt32; offset: UInt64) := z_BufferStorageMemEXT(target, size, memory, offset);
    
    public z_TextureStorageMem2DEXT: procedure(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTextureStorageMem2DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem2DEXT(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; memory: UInt32; offset: UInt64) := z_TextureStorageMem2DEXT(texture, levels, internalFormat, width, height, memory, offset);
    
    public z_TextureStorageMem2DMultisampleEXT: procedure(texture: UInt32; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(texture: UInt32; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTextureStorageMem2DMultisampleEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem2DMultisampleEXT(texture: UInt32; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64) := z_TextureStorageMem2DMultisampleEXT(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
    
    public z_TextureStorageMem3DEXT: procedure(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTextureStorageMem3DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem3DEXT(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; memory: UInt32; offset: UInt64) := z_TextureStorageMem3DEXT(texture, levels, internalFormat, width, height, depth, memory, offset);
    
    public z_TextureStorageMem3DMultisampleEXT: procedure(texture: UInt32; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(texture: UInt32; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTextureStorageMem3DMultisampleEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem3DMultisampleEXT(texture: UInt32; samples: Int32; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte; memory: UInt32; offset: UInt64) := z_TextureStorageMem3DMultisampleEXT(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
    
    public z_NamedBufferStorageMemEXT: procedure(buffer: UInt32; size: UIntPtr; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(buffer: UInt32; size: UIntPtr; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glNamedBufferStorageMemEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferStorageMemEXT(buffer: UInt32; size: UIntPtr; memory: UInt32; offset: UInt64) := z_NamedBufferStorageMemEXT(buffer, size, memory, offset);
    
    public z_TexStorageMem1DEXT: procedure(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTexStorageMem1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageMem1DEXT(target: DummyEnum; levels: Int32; internalFormat: DummyEnum; width: Int32; memory: UInt32; offset: UInt64) := z_TexStorageMem1DEXT(target, levels, internalFormat, width, memory, offset);
    
    public z_TextureStorageMem1DEXT: procedure(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTextureStorageMem1DEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageMem1DEXT(texture: UInt32; levels: Int32; internalFormat: DummyEnum; width: Int32; memory: UInt32; offset: UInt64) := z_TextureStorageMem1DEXT(texture, levels, internalFormat, width, memory, offset);
    
    public z_GenSemaphoresEXT: procedure(n: Int32; semaphores: pointer) := FuncPtrOrNil&<procedure(n: Int32; semaphores: pointer)>(GetGLProcAdr('glGenSemaphoresEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; semaphores: array of UInt32) := GenSemaphoresEXT(n, semaphores[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; var semaphores: UInt32) := GenSemaphoresEXT(n, @semaphores);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenSemaphoresEXT(n: Int32; semaphores: pointer) := z_GenSemaphoresEXT(n, semaphores);
    
    public z_DeleteSemaphoresEXT: procedure(n: Int32; semaphores: pointer) := FuncPtrOrNil&<procedure(n: Int32; semaphores: pointer)>(GetGLProcAdr('glDeleteSemaphoresEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; semaphores: array of UInt32) := DeleteSemaphoresEXT(n, semaphores[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; var semaphores: UInt32) := DeleteSemaphoresEXT(n, @semaphores);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteSemaphoresEXT(n: Int32; semaphores: pointer) := z_DeleteSemaphoresEXT(n, semaphores);
    
    public z_IsSemaphoreEXT: function(semaphore: UInt32): Byte := FuncPtrOrNil&<function(semaphore: UInt32): Byte>(GetGLProcAdr('glIsSemaphoreEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsSemaphoreEXT(semaphore: UInt32): Byte := z_IsSemaphoreEXT(semaphore);
    
    public z_SemaphoreParameterui64vEXT: procedure(semaphore: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(semaphore: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glSemaphoreParameterui64vEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; &params: array of UInt64) := SemaphoreParameterui64vEXT(semaphore, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; var &params: UInt64) := SemaphoreParameterui64vEXT(semaphore, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; &params: pointer) := z_SemaphoreParameterui64vEXT(semaphore, pname, &params);
    
    public z_GetSemaphoreParameterui64vEXT: procedure(semaphore: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(semaphore: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetSemaphoreParameterui64vEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; &params: array of UInt64) := GetSemaphoreParameterui64vEXT(semaphore, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; var &params: UInt64) := GetSemaphoreParameterui64vEXT(semaphore, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSemaphoreParameterui64vEXT(semaphore: UInt32; pname: DummyEnum; &params: pointer) := z_GetSemaphoreParameterui64vEXT(semaphore, pname, &params);
    
    public z_WaitSemaphoreEXT: procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; srcLayouts: pointer) := FuncPtrOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; srcLayouts: pointer)>(GetGLProcAdr('glWaitSemaphoreEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; srcLayouts: pointer) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; srcLayouts: array of DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; var srcLayouts: DummyEnum) := WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, @srcLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; srcLayouts: pointer) := z_WaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
    
    public z_SignalSemaphoreEXT: procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; dstLayouts: pointer) := FuncPtrOrNil&<procedure(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; dstLayouts: pointer)>(GetGLProcAdr('glSignalSemaphoreEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures[0], dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, @textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: array of UInt32; numTextureBarriers: UInt32; textures: pointer; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers[0], numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures[0], dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, @textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; var buffers: UInt32; numTextureBarriers: UInt32; textures: pointer; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, @buffers, numTextureBarriers, textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: array of UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures[0], dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; var textures: UInt32; dstLayouts: pointer) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, @textures, dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; dstLayouts: array of DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; var dstLayouts: DummyEnum) := SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, @dstLayouts);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreEXT(semaphore: UInt32; numBufferBarriers: UInt32; buffers: pointer; numTextureBarriers: UInt32; textures: pointer; dstLayouts: pointer) := z_SignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
    
    {$endregion EXT_external_objects}
    
    {$region EXT_external_objects_fd}
    
    public z_ImportMemoryFdEXT: procedure(memory: UInt32; size: UInt64; handleType: DummyEnum; fd: Int32) := FuncPtrOrNil&<procedure(memory: UInt32; size: UInt64; handleType: DummyEnum; fd: Int32)>(GetGLProcAdr('glImportMemoryFdEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryFdEXT(memory: UInt32; size: UInt64; handleType: DummyEnum; fd: Int32) := z_ImportMemoryFdEXT(memory, size, handleType, fd);
    
    public z_ImportSemaphoreFdEXT: procedure(semaphore: UInt32; handleType: DummyEnum; fd: Int32) := FuncPtrOrNil&<procedure(semaphore: UInt32; handleType: DummyEnum; fd: Int32)>(GetGLProcAdr('glImportSemaphoreFdEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreFdEXT(semaphore: UInt32; handleType: DummyEnum; fd: Int32) := z_ImportSemaphoreFdEXT(semaphore, handleType, fd);
    
    {$endregion EXT_external_objects_fd}
    
    {$region EXT_external_objects_win32}
    
    public z_ImportMemoryWin32HandleEXT: procedure(memory: UInt32; size: UInt64; handleType: DummyEnum; handle: pointer) := FuncPtrOrNil&<procedure(memory: UInt32; size: UInt64; handleType: DummyEnum; handle: pointer)>(GetGLProcAdr('glImportMemoryWin32HandleEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryWin32HandleEXT(memory: UInt32; size: UInt64; handleType: DummyEnum; handle: pointer) := z_ImportMemoryWin32HandleEXT(memory, size, handleType, handle);
    
    public z_ImportMemoryWin32NameEXT: procedure(memory: UInt32; size: UInt64; handleType: DummyEnum; name: pointer) := FuncPtrOrNil&<procedure(memory: UInt32; size: UInt64; handleType: DummyEnum; name: pointer)>(GetGLProcAdr('glImportMemoryWin32NameEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportMemoryWin32NameEXT(memory: UInt32; size: UInt64; handleType: DummyEnum; name: pointer) := z_ImportMemoryWin32NameEXT(memory, size, handleType, name);
    
    public z_ImportSemaphoreWin32HandleEXT: procedure(semaphore: UInt32; handleType: DummyEnum; handle: pointer) := FuncPtrOrNil&<procedure(semaphore: UInt32; handleType: DummyEnum; handle: pointer)>(GetGLProcAdr('glImportSemaphoreWin32HandleEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreWin32HandleEXT(semaphore: UInt32; handleType: DummyEnum; handle: pointer) := z_ImportSemaphoreWin32HandleEXT(semaphore, handleType, handle);
    
    public z_ImportSemaphoreWin32NameEXT: procedure(semaphore: UInt32; handleType: DummyEnum; name: pointer) := FuncPtrOrNil&<procedure(semaphore: UInt32; handleType: DummyEnum; name: pointer)>(GetGLProcAdr('glImportSemaphoreWin32NameEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImportSemaphoreWin32NameEXT(semaphore: UInt32; handleType: DummyEnum; name: pointer) := z_ImportSemaphoreWin32NameEXT(semaphore, handleType, name);
    
    {$endregion EXT_external_objects_win32}
    
    {$region EXT_gpu_program_parameters}
    
    public z_ProgramEnvParameters4fvEXT: procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glProgramEnvParameters4fvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; &params: array of single) := ProgramEnvParameters4fvEXT(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; var &params: single) := ProgramEnvParameters4fvEXT(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramEnvParameters4fvEXT(target, index, count, &params);
    
    public z_ProgramLocalParameters4fvEXT: procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glProgramLocalParameters4fvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; &params: array of single) := ProgramLocalParameters4fvEXT(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; var &params: single) := ProgramLocalParameters4fvEXT(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameters4fvEXT(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramLocalParameters4fvEXT(target, index, count, &params);
    
    {$endregion EXT_gpu_program_parameters}
    
    {$region EXT_light_texture}
    
    public z_ApplyTextureEXT: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glApplyTextureEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ApplyTextureEXT(mode: DummyEnum) := z_ApplyTextureEXT(mode);
    
    public z_TextureLightEXT: procedure(pname: DummyEnum) := FuncPtrOrNil&<procedure(pname: DummyEnum)>(GetGLProcAdr('glTextureLightEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureLightEXT(pname: DummyEnum) := z_TextureLightEXT(pname);
    
    public z_TextureMaterialEXT: procedure(face: DummyEnum; mode: DummyEnum) := FuncPtrOrNil&<procedure(face: DummyEnum; mode: DummyEnum)>(GetGLProcAdr('glTextureMaterialEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureMaterialEXT(face: DummyEnum; mode: DummyEnum) := z_TextureMaterialEXT(face, mode);
    
    {$endregion EXT_light_texture}
    
    {$region EXT_multiview_draw_buffers}
    
    public z_ReadBufferIndexedEXT: procedure(src: DummyEnum; index: Int32) := FuncPtrOrNil&<procedure(src: DummyEnum; index: Int32)>(GetGLProcAdr('glReadBufferIndexedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadBufferIndexedEXT(src: DummyEnum; index: Int32) := z_ReadBufferIndexedEXT(src, index);
    
    public z_DrawBuffersIndexedEXT: procedure(n: Int32; location: pointer; indices: pointer) := FuncPtrOrNil&<procedure(n: Int32; location: pointer; indices: pointer)>(GetGLProcAdr('glDrawBuffersIndexedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: array of DummyEnum; indices: array of Int32) := DrawBuffersIndexedEXT(n, location[0], indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: array of DummyEnum; var indices: Int32) := DrawBuffersIndexedEXT(n, location[0], @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: array of DummyEnum; indices: pointer) := DrawBuffersIndexedEXT(n, location[0], indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; var location: DummyEnum; indices: array of Int32) := DrawBuffersIndexedEXT(n, @location, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; var location: DummyEnum; var indices: Int32) := DrawBuffersIndexedEXT(n, @location, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; var location: DummyEnum; indices: pointer) := DrawBuffersIndexedEXT(n, @location, indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: pointer; indices: array of Int32) := DrawBuffersIndexedEXT(n, location, indices[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: pointer; var indices: Int32) := DrawBuffersIndexedEXT(n, location, @indices);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawBuffersIndexedEXT(n: Int32; location: pointer; indices: pointer) := z_DrawBuffersIndexedEXT(n, location, indices);
    
    {$endregion EXT_multiview_draw_buffers}
    
    {$region EXT_scene_marker}
    
    public z_BeginSceneEXT: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glBeginSceneEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginSceneEXT := z_BeginSceneEXT();
    
    public z_EndSceneEXT: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glEndSceneEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndSceneEXT := z_EndSceneEXT();
    
    {$endregion EXT_scene_marker}
    
    {$region EXT_separate_shader_objects}
    
    public z_UseShaderProgramEXT: procedure(&type: DummyEnum; &program: UInt32) := FuncPtrOrNil&<procedure(&type: DummyEnum; &program: UInt32)>(GetGLProcAdr('glUseShaderProgramEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UseShaderProgramEXT(&type: DummyEnum; &program: UInt32) := z_UseShaderProgramEXT(&type, &program);
    
    public z_ActiveProgramEXT: procedure(&program: UInt32) := FuncPtrOrNil&<procedure(&program: UInt32)>(GetGLProcAdr('glActiveProgramEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveProgramEXT(&program: UInt32) := z_ActiveProgramEXT(&program);
    
    public z_CreateShaderProgramEXT: function(&type: DummyEnum; string: IntPtr): UInt32 := FuncPtrOrNil&<function(&type: DummyEnum; string: IntPtr): UInt32>(GetGLProcAdr('glCreateShaderProgramEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramEXT(&type: DummyEnum; _string: string): UInt32; begin var ptr2 := Marshal.StringToHGlobalAnsi(_string); Result := CreateShaderProgramEXT(&type, ptr2); _string := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateShaderProgramEXT(&type: DummyEnum; string: IntPtr): UInt32 := z_CreateShaderProgramEXT(&type, string);
    
    {$endregion EXT_separate_shader_objects}
    
    {$region EXT_shader_pixel_local_storage2}
    
    public z_FramebufferPixelLocalStorageSizeEXT: procedure(target: UInt32; size: Int32) := FuncPtrOrNil&<procedure(target: UInt32; size: Int32)>(GetGLProcAdr('glFramebufferPixelLocalStorageSizeEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferPixelLocalStorageSizeEXT(target: UInt32; size: Int32) := z_FramebufferPixelLocalStorageSizeEXT(target, size);
    
    public z_GetFramebufferPixelLocalStorageSizeEXT: function(target: UInt32): Int32 := FuncPtrOrNil&<function(target: UInt32): Int32>(GetGLProcAdr('glGetFramebufferPixelLocalStorageSizeEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetFramebufferPixelLocalStorageSizeEXT(target: UInt32): Int32 := z_GetFramebufferPixelLocalStorageSizeEXT(target);
    
    public z_ClearPixelLocalStorageuiEXT: procedure(offset: Int32; n: Int32; values: pointer) := FuncPtrOrNil&<procedure(offset: Int32; n: Int32; values: pointer)>(GetGLProcAdr('glClearPixelLocalStorageuiEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearPixelLocalStorageuiEXT(offset: Int32; n: Int32; values: array of UInt32) := ClearPixelLocalStorageuiEXT(offset, n, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearPixelLocalStorageuiEXT(offset: Int32; n: Int32; var values: UInt32) := ClearPixelLocalStorageuiEXT(offset, n, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearPixelLocalStorageuiEXT(offset: Int32; n: Int32; values: pointer) := z_ClearPixelLocalStorageuiEXT(offset, n, values);
    
    {$endregion EXT_shader_pixel_local_storage2}
    
    {$region EXT_static_vertex_array}
    
    public z_LockArraysEXT: procedure(first: Int32; count: Int32) := FuncPtrOrNil&<procedure(first: Int32; count: Int32)>(GetGLProcAdr('glLockArraysEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LockArraysEXT(first: Int32; count: Int32) := z_LockArraysEXT(first, count);
    
    public z_UnlockArraysEXT: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glUnlockArraysEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnlockArraysEXT := z_UnlockArraysEXT();
    
    {$endregion EXT_static_vertex_array}
    
    {$region EXT_stencil_clear_tag}
    
    public z_StencilClearTagEXT: procedure(stencilTagBits: Int32; stencilClearTag: UInt32) := FuncPtrOrNil&<procedure(stencilTagBits: Int32; stencilClearTag: UInt32)>(GetGLProcAdr('glStencilClearTagEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilClearTagEXT(stencilTagBits: Int32; stencilClearTag: UInt32) := z_StencilClearTagEXT(stencilTagBits, stencilClearTag);
    
    {$endregion EXT_stencil_clear_tag}
    
    {$region EXT_stencil_two_side}
    
    public z_ActiveStencilFaceEXT: procedure(face: DummyEnum) := FuncPtrOrNil&<procedure(face: DummyEnum)>(GetGLProcAdr('glActiveStencilFaceEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveStencilFaceEXT(face: DummyEnum) := z_ActiveStencilFaceEXT(face);
    
    {$endregion EXT_stencil_two_side}
    
    {$region EXT_texture_integer}
    
    public z_ClearColorIiEXT: procedure(red: Int32; green: Int32; blue: Int32; alpha: Int32) := FuncPtrOrNil&<procedure(red: Int32; green: Int32; blue: Int32; alpha: Int32)>(GetGLProcAdr('glClearColorIiEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorIiEXT(red: Int32; green: Int32; blue: Int32; alpha: Int32) := z_ClearColorIiEXT(red, green, blue, alpha);
    
    public z_ClearColorIuiEXT: procedure(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32) := FuncPtrOrNil&<procedure(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32)>(GetGLProcAdr('glClearColorIuiEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorIuiEXT(red: UInt32; green: UInt32; blue: UInt32; alpha: UInt32) := z_ClearColorIuiEXT(red, green, blue, alpha);
    
    {$endregion EXT_texture_integer}
    
    {$region EXT_texture_object}
    
    public z_PrioritizeTexturesEXT: procedure(n: Int32; textures: pointer; priorities: pointer) := FuncPtrOrNil&<procedure(n: Int32; textures: pointer; priorities: pointer)>(GetGLProcAdr('glPrioritizeTexturesEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: array of UInt32; priorities: array of single) := PrioritizeTexturesEXT(n, textures[0], priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: array of UInt32; var priorities: single) := PrioritizeTexturesEXT(n, textures[0], @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: array of UInt32; priorities: pointer) := PrioritizeTexturesEXT(n, textures[0], priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; var textures: UInt32; priorities: array of single) := PrioritizeTexturesEXT(n, @textures, priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; var textures: UInt32; var priorities: single) := PrioritizeTexturesEXT(n, @textures, @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; var textures: UInt32; priorities: pointer) := PrioritizeTexturesEXT(n, @textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: pointer; priorities: array of single) := PrioritizeTexturesEXT(n, textures, priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: pointer; var priorities: single) := PrioritizeTexturesEXT(n, textures, @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesEXT(n: Int32; textures: pointer; priorities: pointer) := z_PrioritizeTexturesEXT(n, textures, priorities);
    
    public z_AreTexturesResidentEXT: function(n: Int32; textures: pointer; residences: pointer): Byte := FuncPtrOrNil&<function(n: Int32; textures: pointer; residences: pointer): Byte>(GetGLProcAdr('glAreTexturesResidentEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: array of UInt32; residences: array of Byte): Byte := AreTexturesResidentEXT(n, textures[0], residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: array of UInt32; var residences: Byte): Byte := AreTexturesResidentEXT(n, textures[0], @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: array of UInt32; residences: pointer): Byte := AreTexturesResidentEXT(n, textures[0], residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; var textures: UInt32; residences: array of Byte): Byte := AreTexturesResidentEXT(n, @textures, residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; var textures: UInt32; var residences: Byte): Byte := AreTexturesResidentEXT(n, @textures, @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; var textures: UInt32; residences: pointer): Byte := AreTexturesResidentEXT(n, @textures, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: pointer; residences: array of Byte): Byte := AreTexturesResidentEXT(n, textures, residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: pointer; var residences: Byte): Byte := AreTexturesResidentEXT(n, textures, @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreTexturesResidentEXT(n: Int32; textures: pointer; residences: pointer): Byte := z_AreTexturesResidentEXT(n, textures, residences);
    
    {$endregion EXT_texture_object}
    
    {$region EXT_texture_perturb_normal}
    
    public z_TextureNormalEXT: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glTextureNormalEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureNormalEXT(mode: DummyEnum) := z_TextureNormalEXT(mode);
    
    {$endregion EXT_texture_perturb_normal}
    
    {$region EXT_vertex_array}
    
    public z_ArrayElementEXT: procedure(i: Int32) := FuncPtrOrNil&<procedure(i: Int32)>(GetGLProcAdr('glArrayElementEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayElementEXT(i: Int32) := z_ArrayElementEXT(i);
    
    public z_VertexPointerEXT: procedure(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer)>(GetGLProcAdr('glVertexPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerEXT(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := z_VertexPointerEXT(size, &type, stride, count, _pointer);
    
    public z_NormalPointerEXT: procedure(&type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer)>(GetGLProcAdr('glNormalPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerEXT(&type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := z_NormalPointerEXT(&type, stride, count, _pointer);
    
    public z_ColorPointerEXT: procedure(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer)>(GetGLProcAdr('glColorPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerEXT(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := z_ColorPointerEXT(size, &type, stride, count, _pointer);
    
    public z_IndexPointerEXT: procedure(&type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer)>(GetGLProcAdr('glIndexPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerEXT(&type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := z_IndexPointerEXT(&type, stride, count, _pointer);
    
    public z_TexCoordPointerEXT: procedure(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer)>(GetGLProcAdr('glTexCoordPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerEXT(size: Int32; &type: DummyEnum; stride: Int32; count: Int32; _pointer: pointer) := z_TexCoordPointerEXT(size, &type, stride, count, _pointer);
    
    public z_EdgeFlagPointerEXT: procedure(stride: Int32; count: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(stride: Int32; count: Int32; _pointer: pointer)>(GetGLProcAdr('glEdgeFlagPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; _pointer: array of Byte) := EdgeFlagPointerEXT(stride, count, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; var _pointer: Byte) := EdgeFlagPointerEXT(stride, count, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerEXT(stride: Int32; count: Int32; _pointer: pointer) := z_EdgeFlagPointerEXT(stride, count, _pointer);
    
    {$endregion EXT_vertex_array}
    
    {$region EXT_vertex_array_set / GenName version}
    
    public z_GenArraySetsEXT: procedure(n: Int32; arrayset: pointer) := FuncPtrOrNil&<procedure(n: Int32; arrayset: pointer)>(GetGLProcAdr('glGenArraySetsEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenArraySetsEXT(n: Int32; arrayset: array of UInt32) := GenArraySetsEXT(n, arrayset[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenArraySetsEXT(n: Int32; var arrayset: UInt32) := GenArraySetsEXT(n, @arrayset);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenArraySetsEXT(n: Int32; arrayset: pointer) := z_GenArraySetsEXT(n, arrayset);
    
    public z_BindArraySetEXT: procedure(arrayset: UInt32) := FuncPtrOrNil&<procedure(arrayset: UInt32)>(GetGLProcAdr('glBindArraySetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindArraySetEXT(arrayset: UInt32) := z_BindArraySetEXT(arrayset);
    
    public z_DeleteArraySetsEXT: procedure(n: Int32; arrayset: pointer) := FuncPtrOrNil&<procedure(n: Int32; arrayset: pointer)>(GetGLProcAdr('glDeleteArraySetsEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteArraySetsEXT(n: Int32; arrayset: array of UInt32) := DeleteArraySetsEXT(n, arrayset[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteArraySetsEXT(n: Int32; var arrayset: UInt32) := DeleteArraySetsEXT(n, @arrayset);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteArraySetsEXT(n: Int32; arrayset: pointer) := z_DeleteArraySetsEXT(n, arrayset);
    
    public z_IsArraySetEXT: function(arrayset: UInt32): UInt32 := FuncPtrOrNil&<function(arrayset: UInt32): UInt32>(GetGLProcAdr('glIsArraySetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsArraySetEXT(arrayset: UInt32): UInt32 := z_IsArraySetEXT(arrayset);
    
    {$endregion EXT_vertex_array_set / GenName version}
    
    {$region EXT_vertex_shader}
    
    public z_BeginVertexShaderEXT: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glBeginVertexShaderEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginVertexShaderEXT := z_BeginVertexShaderEXT();
    
    public z_EndVertexShaderEXT: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glEndVertexShaderEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndVertexShaderEXT := z_EndVertexShaderEXT();
    
    public z_BindVertexShaderEXT: procedure(id: UInt32) := FuncPtrOrNil&<procedure(id: UInt32)>(GetGLProcAdr('glBindVertexShaderEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindVertexShaderEXT(id: UInt32) := z_BindVertexShaderEXT(id);
    
    public z_GenVertexShadersEXT: function(range: UInt32): UInt32 := FuncPtrOrNil&<function(range: UInt32): UInt32>(GetGLProcAdr('glGenVertexShadersEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenVertexShadersEXT(range: UInt32): UInt32 := z_GenVertexShadersEXT(range);
    
    public z_DeleteVertexShaderEXT: procedure(id: UInt32) := FuncPtrOrNil&<procedure(id: UInt32)>(GetGLProcAdr('glDeleteVertexShaderEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteVertexShaderEXT(id: UInt32) := z_DeleteVertexShaderEXT(id);
    
    public z_ShaderOp1EXT: procedure(op: DummyEnum; res: UInt32; arg1: UInt32) := FuncPtrOrNil&<procedure(op: DummyEnum; res: UInt32; arg1: UInt32)>(GetGLProcAdr('glShaderOp1EXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp1EXT(op: DummyEnum; res: UInt32; arg1: UInt32) := z_ShaderOp1EXT(op, res, arg1);
    
    public z_ShaderOp2EXT: procedure(op: DummyEnum; res: UInt32; arg1: UInt32; arg2: UInt32) := FuncPtrOrNil&<procedure(op: DummyEnum; res: UInt32; arg1: UInt32; arg2: UInt32)>(GetGLProcAdr('glShaderOp2EXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp2EXT(op: DummyEnum; res: UInt32; arg1: UInt32; arg2: UInt32) := z_ShaderOp2EXT(op, res, arg1, arg2);
    
    public z_ShaderOp3EXT: procedure(op: DummyEnum; res: UInt32; arg1: UInt32; arg2: UInt32; arg3: UInt32) := FuncPtrOrNil&<procedure(op: DummyEnum; res: UInt32; arg1: UInt32; arg2: UInt32; arg3: UInt32)>(GetGLProcAdr('glShaderOp3EXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShaderOp3EXT(op: DummyEnum; res: UInt32; arg1: UInt32; arg2: UInt32; arg3: UInt32) := z_ShaderOp3EXT(op, res, arg1, arg2, arg3);
    
    public z_SwizzleEXT: procedure(res: UInt32; &in: UInt32; outX: DummyEnum; outY: DummyEnum; outZ: DummyEnum; outW: DummyEnum) := FuncPtrOrNil&<procedure(res: UInt32; &in: UInt32; outX: DummyEnum; outY: DummyEnum; outZ: DummyEnum; outW: DummyEnum)>(GetGLProcAdr('glSwizzleEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SwizzleEXT(res: UInt32; &in: UInt32; outX: DummyEnum; outY: DummyEnum; outZ: DummyEnum; outW: DummyEnum) := z_SwizzleEXT(res, &in, outX, outY, outZ, outW);
    
    public z_WriteMaskEXT: procedure(res: UInt32; &in: UInt32; outX: DummyEnum; outY: DummyEnum; outZ: DummyEnum; outW: DummyEnum) := FuncPtrOrNil&<procedure(res: UInt32; &in: UInt32; outX: DummyEnum; outY: DummyEnum; outZ: DummyEnum; outW: DummyEnum)>(GetGLProcAdr('glWriteMaskEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WriteMaskEXT(res: UInt32; &in: UInt32; outX: DummyEnum; outY: DummyEnum; outZ: DummyEnum; outW: DummyEnum) := z_WriteMaskEXT(res, &in, outX, outY, outZ, outW);
    
    public z_InsertComponentEXT: procedure(res: UInt32; src: UInt32; num: UInt32) := FuncPtrOrNil&<procedure(res: UInt32; src: UInt32; num: UInt32)>(GetGLProcAdr('glInsertComponentEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InsertComponentEXT(res: UInt32; src: UInt32; num: UInt32) := z_InsertComponentEXT(res, src, num);
    
    public z_ExtractComponentEXT: procedure(res: UInt32; src: UInt32; num: UInt32) := FuncPtrOrNil&<procedure(res: UInt32; src: UInt32; num: UInt32)>(GetGLProcAdr('glExtractComponentEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtractComponentEXT(res: UInt32; src: UInt32; num: UInt32) := z_ExtractComponentEXT(res, src, num);
    
    public z_GenSymbolsEXT: function(datatype: DummyEnum; storagetype: DummyEnum; range: DummyEnum; components: UInt32): UInt32 := FuncPtrOrNil&<function(datatype: DummyEnum; storagetype: DummyEnum; range: DummyEnum; components: UInt32): UInt32>(GetGLProcAdr('glGenSymbolsEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenSymbolsEXT(datatype: DummyEnum; storagetype: DummyEnum; range: DummyEnum; components: UInt32): UInt32 := z_GenSymbolsEXT(datatype, storagetype, range, components);
    
    public z_SetInvariantEXT: procedure(id: UInt32; &type: DummyEnum; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; &type: DummyEnum; addr: pointer)>(GetGLProcAdr('glSetInvariantEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetInvariantEXT(id: UInt32; &type: DummyEnum; addr: pointer) := z_SetInvariantEXT(id, &type, addr);
    
    public z_SetLocalConstantEXT: procedure(id: UInt32; &type: DummyEnum; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; &type: DummyEnum; addr: pointer)>(GetGLProcAdr('glSetLocalConstantEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetLocalConstantEXT(id: UInt32; &type: DummyEnum; addr: pointer) := z_SetLocalConstantEXT(id, &type, addr);
    
    public z_VariantbvEXT: procedure(id: UInt32; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; addr: pointer)>(GetGLProcAdr('glVariantbvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; addr: array of SByte) := VariantbvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; var addr: SByte) := VariantbvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantbvEXT(id: UInt32; addr: pointer) := z_VariantbvEXT(id, addr);
    
    public z_VariantsvEXT: procedure(id: UInt32; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; addr: pointer)>(GetGLProcAdr('glVariantsvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; addr: array of Int16) := VariantsvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; var addr: Int16) := VariantsvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantsvEXT(id: UInt32; addr: pointer) := z_VariantsvEXT(id, addr);
    
    public z_VariantivEXT: procedure(id: UInt32; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; addr: pointer)>(GetGLProcAdr('glVariantivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; addr: array of Int32) := VariantivEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; var addr: Int32) := VariantivEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantivEXT(id: UInt32; addr: pointer) := z_VariantivEXT(id, addr);
    
    public z_VariantfvEXT: procedure(id: UInt32; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; addr: pointer)>(GetGLProcAdr('glVariantfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; addr: array of single) := VariantfvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; var addr: single) := VariantfvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantfvEXT(id: UInt32; addr: pointer) := z_VariantfvEXT(id, addr);
    
    public z_VariantdvEXT: procedure(id: UInt32; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; addr: pointer)>(GetGLProcAdr('glVariantdvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; addr: array of double) := VariantdvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; var addr: double) := VariantdvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantdvEXT(id: UInt32; addr: pointer) := z_VariantdvEXT(id, addr);
    
    public z_VariantubvEXT: procedure(id: UInt32; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; addr: pointer)>(GetGLProcAdr('glVariantubvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; addr: array of Byte) := VariantubvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; var addr: Byte) := VariantubvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantubvEXT(id: UInt32; addr: pointer) := z_VariantubvEXT(id, addr);
    
    public z_VariantusvEXT: procedure(id: UInt32; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; addr: pointer)>(GetGLProcAdr('glVariantusvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; addr: array of UInt16) := VariantusvEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; var addr: UInt16) := VariantusvEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantusvEXT(id: UInt32; addr: pointer) := z_VariantusvEXT(id, addr);
    
    public z_VariantuivEXT: procedure(id: UInt32; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; addr: pointer)>(GetGLProcAdr('glVariantuivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; addr: array of UInt32) := VariantuivEXT(id, addr[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; var addr: UInt32) := VariantuivEXT(id, @addr);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantuivEXT(id: UInt32; addr: pointer) := z_VariantuivEXT(id, addr);
    
    public z_VariantPointerEXT: procedure(id: UInt32; &type: DummyEnum; stride: UInt32; addr: pointer) := FuncPtrOrNil&<procedure(id: UInt32; &type: DummyEnum; stride: UInt32; addr: pointer)>(GetGLProcAdr('glVariantPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantPointerEXT(id: UInt32; &type: DummyEnum; stride: UInt32; addr: pointer) := z_VariantPointerEXT(id, &type, stride, addr);
    
    public z_EnableVariantClientStateEXT: procedure(id: UInt32) := FuncPtrOrNil&<procedure(id: UInt32)>(GetGLProcAdr('glEnableVariantClientStateEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVariantClientStateEXT(id: UInt32) := z_EnableVariantClientStateEXT(id);
    
    public z_DisableVariantClientStateEXT: procedure(id: UInt32) := FuncPtrOrNil&<procedure(id: UInt32)>(GetGLProcAdr('glDisableVariantClientStateEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVariantClientStateEXT(id: UInt32) := z_DisableVariantClientStateEXT(id);
    
    public z_BindLightParameterEXT: function(light: DummyEnum; value: DummyEnum): UInt32 := FuncPtrOrNil&<function(light: DummyEnum; value: DummyEnum): UInt32>(GetGLProcAdr('glBindLightParameterEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindLightParameterEXT(light: DummyEnum; value: DummyEnum): UInt32 := z_BindLightParameterEXT(light, value);
    
    public z_BindMaterialParameterEXT: function(face: DummyEnum; value: DummyEnum): UInt32 := FuncPtrOrNil&<function(face: DummyEnum; value: DummyEnum): UInt32>(GetGLProcAdr('glBindMaterialParameterEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindMaterialParameterEXT(face: DummyEnum; value: DummyEnum): UInt32 := z_BindMaterialParameterEXT(face, value);
    
    public z_BindTexGenParameterEXT: function(&unit: DummyEnum; coord: DummyEnum; value: DummyEnum): UInt32 := FuncPtrOrNil&<function(&unit: DummyEnum; coord: DummyEnum; value: DummyEnum): UInt32>(GetGLProcAdr('glBindTexGenParameterEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTexGenParameterEXT(&unit: DummyEnum; coord: DummyEnum; value: DummyEnum): UInt32 := z_BindTexGenParameterEXT(&unit, coord, value);
    
    public z_BindTextureUnitParameterEXT: function(&unit: DummyEnum; value: DummyEnum): UInt32 := FuncPtrOrNil&<function(&unit: DummyEnum; value: DummyEnum): UInt32>(GetGLProcAdr('glBindTextureUnitParameterEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindTextureUnitParameterEXT(&unit: DummyEnum; value: DummyEnum): UInt32 := z_BindTextureUnitParameterEXT(&unit, value);
    
    public z_BindParameterEXT: function(value: DummyEnum): UInt32 := FuncPtrOrNil&<function(value: DummyEnum): UInt32>(GetGLProcAdr('glBindParameterEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function BindParameterEXT(value: DummyEnum): UInt32 := z_BindParameterEXT(value);
    
    public z_IsVariantEnabledEXT: function(id: UInt32; cap: DummyEnum): Byte := FuncPtrOrNil&<function(id: UInt32; cap: DummyEnum): Byte>(GetGLProcAdr('glIsVariantEnabledEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVariantEnabledEXT(id: UInt32; cap: DummyEnum): Byte := z_IsVariantEnabledEXT(id, cap);
    
    public z_GetVariantBooleanvEXT: procedure(id: UInt32; value: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>(GetGLProcAdr('glGetVariantBooleanvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantBooleanvEXT(id: UInt32; value: DummyEnum; data: array of Byte) := GetVariantBooleanvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantBooleanvEXT(id: UInt32; value: DummyEnum; var data: Byte) := GetVariantBooleanvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantBooleanvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetVariantBooleanvEXT(id, value, data);
    
    public z_GetVariantIntegervEXT: procedure(id: UInt32; value: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>(GetGLProcAdr('glGetVariantIntegervEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantIntegervEXT(id: UInt32; value: DummyEnum; data: array of Int32) := GetVariantIntegervEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantIntegervEXT(id: UInt32; value: DummyEnum; var data: Int32) := GetVariantIntegervEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantIntegervEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetVariantIntegervEXT(id, value, data);
    
    public z_GetVariantFloatvEXT: procedure(id: UInt32; value: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>(GetGLProcAdr('glGetVariantFloatvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantFloatvEXT(id: UInt32; value: DummyEnum; data: array of single) := GetVariantFloatvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantFloatvEXT(id: UInt32; value: DummyEnum; var data: single) := GetVariantFloatvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantFloatvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetVariantFloatvEXT(id, value, data);
    
    public z_GetVariantPointervEXT: procedure(id: UInt32; value: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>(GetGLProcAdr('glGetVariantPointervEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantPointervEXT(id: UInt32; value: DummyEnum; data: array of IntPtr) := GetVariantPointervEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantPointervEXT(id: UInt32; value: DummyEnum; var data: IntPtr) := GetVariantPointervEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantPointervEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetVariantPointervEXT(id, value, data);
    
    public z_GetInvariantBooleanvEXT: procedure(id: UInt32; value: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>(GetGLProcAdr('glGetInvariantBooleanvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantBooleanvEXT(id: UInt32; value: DummyEnum; data: array of Byte) := GetInvariantBooleanvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantBooleanvEXT(id: UInt32; value: DummyEnum; var data: Byte) := GetInvariantBooleanvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantBooleanvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetInvariantBooleanvEXT(id, value, data);
    
    public z_GetInvariantIntegervEXT: procedure(id: UInt32; value: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>(GetGLProcAdr('glGetInvariantIntegervEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantIntegervEXT(id: UInt32; value: DummyEnum; data: array of Int32) := GetInvariantIntegervEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantIntegervEXT(id: UInt32; value: DummyEnum; var data: Int32) := GetInvariantIntegervEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantIntegervEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetInvariantIntegervEXT(id, value, data);
    
    public z_GetInvariantFloatvEXT: procedure(id: UInt32; value: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>(GetGLProcAdr('glGetInvariantFloatvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantFloatvEXT(id: UInt32; value: DummyEnum; data: array of single) := GetInvariantFloatvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantFloatvEXT(id: UInt32; value: DummyEnum; var data: single) := GetInvariantFloatvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInvariantFloatvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetInvariantFloatvEXT(id, value, data);
    
    public z_GetLocalConstantBooleanvEXT: procedure(id: UInt32; value: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>(GetGLProcAdr('glGetLocalConstantBooleanvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantBooleanvEXT(id: UInt32; value: DummyEnum; data: array of Byte) := GetLocalConstantBooleanvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantBooleanvEXT(id: UInt32; value: DummyEnum; var data: Byte) := GetLocalConstantBooleanvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantBooleanvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetLocalConstantBooleanvEXT(id, value, data);
    
    public z_GetLocalConstantIntegervEXT: procedure(id: UInt32; value: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>(GetGLProcAdr('glGetLocalConstantIntegervEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantIntegervEXT(id: UInt32; value: DummyEnum; data: array of Int32) := GetLocalConstantIntegervEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantIntegervEXT(id: UInt32; value: DummyEnum; var data: Int32) := GetLocalConstantIntegervEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantIntegervEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetLocalConstantIntegervEXT(id, value, data);
    
    public z_GetLocalConstantFloatvEXT: procedure(id: UInt32; value: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(id: UInt32; value: DummyEnum; data: pointer)>(GetGLProcAdr('glGetLocalConstantFloatvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantFloatvEXT(id: UInt32; value: DummyEnum; data: array of single) := GetLocalConstantFloatvEXT(id, value, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantFloatvEXT(id: UInt32; value: DummyEnum; var data: single) := GetLocalConstantFloatvEXT(id, value, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLocalConstantFloatvEXT(id: UInt32; value: DummyEnum; data: pointer) := z_GetLocalConstantFloatvEXT(id, value, data);
    
    {$endregion EXT_vertex_shader}
    
    {$region EXT_vertex_weighting}
    
    public z_VertexWeightfEXT: procedure(weight: single) := FuncPtrOrNil&<procedure(weight: single)>(GetGLProcAdr('glVertexWeightfEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfEXT(weight: single) := z_VertexWeightfEXT(weight);
    
    public z_VertexWeightfvEXT: procedure(weight: pointer) := FuncPtrOrNil&<procedure(weight: pointer)>(GetGLProcAdr('glVertexWeightfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(weight: array of single) := VertexWeightfvEXT(weight[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(var weight: single) := VertexWeightfvEXT(@weight);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightfvEXT(weight: pointer) := z_VertexWeightfvEXT(weight);
    
    public z_VertexWeightPointerEXT: procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer)>(GetGLProcAdr('glVertexWeightPointerEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeightPointerEXT(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer) := z_VertexWeightPointerEXT(size, &type, stride, _pointer);
    
    {$endregion EXT_vertex_weighting}
    
    {$region EXT_win32_keyed_mutex}
    
    public z_AcquireKeyedMutexWin32EXT: function(memory: UInt32; key: UInt64; timeout: UInt32): Byte := FuncPtrOrNil&<function(memory: UInt32; key: UInt64; timeout: UInt32): Byte>(GetGLProcAdr('glAcquireKeyedMutexWin32EXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AcquireKeyedMutexWin32EXT(memory: UInt32; key: UInt64; timeout: UInt32): Byte := z_AcquireKeyedMutexWin32EXT(memory, key, timeout);
    
    public z_ReleaseKeyedMutexWin32EXT: function(memory: UInt32; key: UInt64): Byte := FuncPtrOrNil&<function(memory: UInt32; key: UInt64): Byte>(GetGLProcAdr('glReleaseKeyedMutexWin32EXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ReleaseKeyedMutexWin32EXT(memory: UInt32; key: UInt64): Byte := z_ReleaseKeyedMutexWin32EXT(memory, key);
    
    {$endregion EXT_win32_keyed_mutex}
    
    {$region EXT_window_rectangles}
    
    public z_WindowRectanglesEXT: procedure(mode: DummyEnum; count: Int32; box: pointer) := FuncPtrOrNil&<procedure(mode: DummyEnum; count: Int32; box: pointer)>(GetGLProcAdr('glWindowRectanglesEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; box: array of Int32) := WindowRectanglesEXT(mode, count, box[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; var box: Int32) := WindowRectanglesEXT(mode, count, @box);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowRectanglesEXT(mode: DummyEnum; count: Int32; box: pointer) := z_WindowRectanglesEXT(mode, count, box);
    
    {$endregion EXT_window_rectangles}
    
    {$region EXT_x11_sync_object}
    
    public z_ImportSyncEXT: function(external_sync_type: DummyEnum; external_sync: IntPtr; flags: DummyFlags): GLsync := FuncPtrOrNil&<function(external_sync_type: DummyEnum; external_sync: IntPtr; flags: DummyFlags): GLsync>(GetGLProcAdr('glImportSyncEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ImportSyncEXT(external_sync_type: DummyEnum; external_sync: IntPtr; flags: DummyFlags): GLsync := z_ImportSyncEXT(external_sync_type, external_sync, flags);
    
    {$endregion EXT_x11_sync_object}
    
    {$region ARB_vertex_attrib_64bit, EXT_vertex_attrib_64bit}
    
    public z_VertexArrayVertexAttribLOffsetEXT: procedure(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := FuncPtrOrNil&<procedure(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr)>(GetGLProcAdr('glVertexArrayVertexAttribLOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayVertexAttribLOffsetEXT(vaobj: UInt32; buffer: UInt32; index: UInt32; size: Int32; &type: DummyEnum; stride: Int32; offset: IntPtr) := z_VertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, &type, stride, offset);
    
    {$endregion ARB_vertex_attrib_64bit, EXT_vertex_attrib_64bit}
    
    {$region ARB_viewport_array, EXT_draw_buffers2}
    
    public z_EnableIndexedEXT: procedure(target: DummyEnum; index: UInt32) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32)>(GetGLProcAdr('glEnableIndexedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableIndexedEXT(target: DummyEnum; index: UInt32) := z_EnableIndexedEXT(target, index);
    
    public z_DisableIndexedEXT: procedure(target: DummyEnum; index: UInt32) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32)>(GetGLProcAdr('glDisableIndexedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableIndexedEXT(target: DummyEnum; index: UInt32) := z_DisableIndexedEXT(target, index);
    
    public z_IsEnabledIndexedEXT: function(target: DummyEnum; index: UInt32): Byte := FuncPtrOrNil&<function(target: DummyEnum; index: UInt32): Byte>(GetGLProcAdr('glIsEnabledIndexedEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsEnabledIndexedEXT(target: DummyEnum; index: UInt32): Byte := z_IsEnabledIndexedEXT(target, index);
    
    {$endregion ARB_viewport_array, EXT_draw_buffers2}
    
    {$region EXT_multisample, SGIS_multisample}
    
    public z_SampleMaskEXT: procedure(value: single; invert: Byte) := FuncPtrOrNil&<procedure(value: single; invert: Byte)>(GetGLProcAdr('glSampleMaskEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskEXT(value: single; invert: Byte) := z_SampleMaskEXT(value, invert);
    
    public z_SamplePatternEXT: procedure(pattern: DummyEnum) := FuncPtrOrNil&<procedure(pattern: DummyEnum)>(GetGLProcAdr('glSamplePatternEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SamplePatternEXT(pattern: DummyEnum) := z_SamplePatternEXT(pattern);
    
    {$endregion EXT_multisample, SGIS_multisample}
    
    {$region EXT_multisampled_render_to_texture, IMG_multisampled_render_to_texture}
    
    public z_FramebufferTexture2DMultisampleEXT: procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; samples: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; samples: Int32)>(GetGLProcAdr('glFramebufferTexture2DMultisampleEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2DMultisampleEXT(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; samples: Int32) := z_FramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);
    
    {$endregion EXT_multisampled_render_to_texture, IMG_multisampled_render_to_texture}
    
    {$region EXT_pixel_transform, SGI_fft}
    
    public z_PixelTransformParameteriEXT: procedure(target: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glPixelTransformParameteriEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameteriEXT(target: DummyEnum; pname: DummyEnum; param: Int32) := z_PixelTransformParameteriEXT(target, pname, param);
    
    public z_PixelTransformParameterfEXT: procedure(target: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glPixelTransformParameterfEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfEXT(target: DummyEnum; pname: DummyEnum; param: single) := z_PixelTransformParameterfEXT(target, pname, param);
    
    public z_PixelTransformParameterivEXT: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glPixelTransformParameterivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := PixelTransformParameterivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := PixelTransformParameterivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_PixelTransformParameterivEXT(target, pname, &params);
    
    public z_PixelTransformParameterfvEXT: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glPixelTransformParameterfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: array of single) := PixelTransformParameterfvEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) := PixelTransformParameterfvEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_PixelTransformParameterfvEXT(target, pname, &params);
    
    public z_GetPixelTransformParameterivEXT: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetPixelTransformParameterivEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetPixelTransformParameterivEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetPixelTransformParameterivEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterivEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetPixelTransformParameterivEXT(target, pname, &params);
    
    public z_GetPixelTransformParameterfvEXT: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetPixelTransformParameterfvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetPixelTransformParameterfvEXT(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; var &params: single) := GetPixelTransformParameterfvEXT(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTransformParameterfvEXT(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetPixelTransformParameterfvEXT(target, pname, &params);
    
    {$endregion EXT_pixel_transform, SGI_fft}
    
    {$region EXT_raster_multisample, NV_framebuffer_mixed_samples}
    
    public z_RasterSamplesEXT: procedure(samples: UInt32; fixedsamplelocations: Byte) := FuncPtrOrNil&<procedure(samples: UInt32; fixedsamplelocations: Byte)>(GetGLProcAdr('glRasterSamplesEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterSamplesEXT(samples: UInt32; fixedsamplelocations: Byte) := z_RasterSamplesEXT(samples, fixedsamplelocations);
    
    {$endregion EXT_raster_multisample, NV_framebuffer_mixed_samples}
    
    {$region EXT_shader_framebuffer_fetch, QCOM_shader_framebuffer_fetch_noncoherent}
    
    public z_FramebufferFetchBarrierEXT: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glFramebufferFetchBarrierEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFetchBarrierEXT := z_FramebufferFetchBarrierEXT();
    
    {$endregion EXT_shader_framebuffer_fetch, QCOM_shader_framebuffer_fetch_noncoherent}
    
    {$region EXT_transform_feedback, NV_parameter_buffer_object, NV_transform_feedback}
    
    public z_BindBufferOffsetEXT: procedure(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr)>(GetGLProcAdr('glBindBufferOffsetEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindBufferOffsetEXT(target: DummyEnum; index: UInt32; buffer: UInt32; offset: IntPtr) := z_BindBufferOffsetEXT(target, index, buffer, offset);
    
    {$endregion EXT_transform_feedback, NV_parameter_buffer_object, NV_transform_feedback}
    
    {$region EXT_draw_buffers2, EXT_transform_feedback, NV_explicit_multisample, NV_transform_feedback}
    
    public z_GetBooleanIndexedvEXT: procedure(target: DummyEnum; index: UInt32; data: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; data: pointer)>(GetGLProcAdr('glGetBooleanIndexedvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: DummyEnum; index: UInt32; data: array of Byte) := GetBooleanIndexedvEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: DummyEnum; index: UInt32; var data: Byte) := GetBooleanIndexedvEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBooleanIndexedvEXT(target: DummyEnum; index: UInt32; data: pointer) := z_GetBooleanIndexedvEXT(target, index, data);
    
    {$endregion EXT_draw_buffers2, EXT_transform_feedback, NV_explicit_multisample, NV_transform_feedback}
    
    {$region ARB_viewport_array, EXT_draw_buffers2, EXT_transform_feedback, NV_explicit_multisample, NV_parameter_buffer_object, NV_transform_feedback}
    
    public z_GetIntegerIndexedvEXT: procedure(target: DummyEnum; index: UInt32; data: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; data: pointer)>(GetGLProcAdr('glGetIntegerIndexedvEXT'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: DummyEnum; index: UInt32; data: array of Int32) := GetIntegerIndexedvEXT(target, index, data[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: DummyEnum; index: UInt32; var data: Int32) := GetIntegerIndexedvEXT(target, index, @data);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerIndexedvEXT(target: DummyEnum; index: UInt32; data: pointer) := z_GetIntegerIndexedvEXT(target, index, data);
    
    {$endregion ARB_viewport_array, EXT_draw_buffers2, EXT_transform_feedback, NV_explicit_multisample, NV_parameter_buffer_object, NV_transform_feedback}
    
  end;
  
  gl_Misc = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region AMD_gpu_association}
    
    public z_glXGetGPUIDsAMD: function(maxCount: UInt32; ids: pointer): UInt32 := FuncPtrOrNil&<function(maxCount: UInt32; ids: pointer): UInt32>(GetGLProcAdr('glXGetGPUIDsAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetGPUIDsAMD(maxCount: UInt32; ids: array of UInt32): UInt32 := glXGetGPUIDsAMD(maxCount, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetGPUIDsAMD(maxCount: UInt32; var ids: UInt32): UInt32 := glXGetGPUIDsAMD(maxCount, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetGPUIDsAMD(maxCount: UInt32; ids: pointer): UInt32 := z_glXGetGPUIDsAMD(maxCount, ids);
    
    public z_glXGetGPUInfoAMD: function(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: pointer): Int32 := FuncPtrOrNil&<function(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: pointer): Int32>(GetGLProcAdr('glXGetGPUInfoAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetGPUInfoAMD(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: pointer): Int32 := z_glXGetGPUInfoAMD(id, &property, dataType, size, data);
    
    public z_glXCreateAssociatedContextAMD: function(id: UInt32; share_list: GLXContext): GLXContext := FuncPtrOrNil&<function(id: UInt32; share_list: GLXContext): GLXContext>(GetGLProcAdr('glXCreateAssociatedContextAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXCreateAssociatedContextAMD(id: UInt32; share_list: GLXContext): GLXContext := z_glXCreateAssociatedContextAMD(id, share_list);
    
    public z_glXCreateAssociatedContextAttribsAMD: function(id: UInt32; share_context: GLXContext; attribList: pointer): GLXContext := FuncPtrOrNil&<function(id: UInt32; share_context: GLXContext; attribList: pointer): GLXContext>(GetGLProcAdr('glXCreateAssociatedContextAttribsAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXCreateAssociatedContextAttribsAMD(id: UInt32; share_context: GLXContext; attribList: array of Int32): GLXContext := glXCreateAssociatedContextAttribsAMD(id, share_context, attribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXCreateAssociatedContextAttribsAMD(id: UInt32; share_context: GLXContext; var attribList: Int32): GLXContext := glXCreateAssociatedContextAttribsAMD(id, share_context, @attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXCreateAssociatedContextAttribsAMD(id: UInt32; share_context: GLXContext; attribList: pointer): GLXContext := z_glXCreateAssociatedContextAttribsAMD(id, share_context, attribList);
    
    public z_glXDeleteAssociatedContextAMD: function(ctx: GLXContext): UInt32 := FuncPtrOrNil&<function(ctx: GLXContext): UInt32>(GetGLProcAdr('glXDeleteAssociatedContextAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXDeleteAssociatedContextAMD(ctx: GLXContext): UInt32 := z_glXDeleteAssociatedContextAMD(ctx);
    
    public z_glXMakeAssociatedContextCurrentAMD: function(ctx: GLXContext): UInt32 := FuncPtrOrNil&<function(ctx: GLXContext): UInt32>(GetGLProcAdr('glXMakeAssociatedContextCurrentAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXMakeAssociatedContextCurrentAMD(ctx: GLXContext): UInt32 := z_glXMakeAssociatedContextCurrentAMD(ctx);
    
    public z_glXGetCurrentAssociatedContextAMD: function: GLXContext := FuncPtrOrNil&<function: GLXContext>(GetGLProcAdr('glXGetCurrentAssociatedContextAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetCurrentAssociatedContextAMD: GLXContext := z_glXGetCurrentAssociatedContextAMD();
    
    public z_glXBlitContextFramebufferAMD: procedure(dstCtx: GLXContext; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := FuncPtrOrNil&<procedure(dstCtx: GLXContext; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>(GetGLProcAdr('glXBlitContextFramebufferAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glXBlitContextFramebufferAMD(dstCtx: GLXContext; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := z_glXBlitContextFramebufferAMD(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    public z_wglGetGPUIDsAMD: function(maxCount: UInt32; ids: pointer): UInt32 := FuncPtrOrNil&<function(maxCount: UInt32; ids: pointer): UInt32>(GetGLProcAdr('wglGetGPUIDsAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetGPUIDsAMD(maxCount: UInt32; ids: array of UInt32): UInt32 := wglGetGPUIDsAMD(maxCount, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetGPUIDsAMD(maxCount: UInt32; var ids: UInt32): UInt32 := wglGetGPUIDsAMD(maxCount, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetGPUIDsAMD(maxCount: UInt32; ids: pointer): UInt32 := z_wglGetGPUIDsAMD(maxCount, ids);
    
    public z_wglGetGPUInfoAMD: function(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: pointer): Int32 := FuncPtrOrNil&<function(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: pointer): Int32>(GetGLProcAdr('wglGetGPUInfoAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetGPUInfoAMD(id: UInt32; &property: Int32; dataType: DummyEnum; size: UInt32; data: pointer): Int32 := z_wglGetGPUInfoAMD(id, &property, dataType, size, data);
    
    public z_wglGetContextGPUIDAMD: function(hglrc: GLContext): UInt32 := FuncPtrOrNil&<function(hglrc: GLContext): UInt32>(GetGLProcAdr('wglGetContextGPUIDAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetContextGPUIDAMD(hglrc: GLContext): UInt32 := z_wglGetContextGPUIDAMD(hglrc);
    
    public z_wglCreateAssociatedContextAMD: function(id: UInt32): GLContext := FuncPtrOrNil&<function(id: UInt32): GLContext>(GetGLProcAdr('wglCreateAssociatedContextAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglCreateAssociatedContextAMD(id: UInt32): GLContext := z_wglCreateAssociatedContextAMD(id);
    
    public z_wglCreateAssociatedContextAttribsAMD: function(id: UInt32; hShareContext: GLContext; attribList: pointer): GLContext := FuncPtrOrNil&<function(id: UInt32; hShareContext: GLContext; attribList: pointer): GLContext>(GetGLProcAdr('wglCreateAssociatedContextAttribsAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglCreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: GLContext; attribList: array of Int32): GLContext := wglCreateAssociatedContextAttribsAMD(id, hShareContext, attribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglCreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: GLContext; var attribList: Int32): GLContext := wglCreateAssociatedContextAttribsAMD(id, hShareContext, @attribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglCreateAssociatedContextAttribsAMD(id: UInt32; hShareContext: GLContext; attribList: pointer): GLContext := z_wglCreateAssociatedContextAttribsAMD(id, hShareContext, attribList);
    
    public z_wglDeleteAssociatedContextAMD: function(hglrc: GLContext): UInt32 := FuncPtrOrNil&<function(hglrc: GLContext): UInt32>(GetGLProcAdr('wglDeleteAssociatedContextAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglDeleteAssociatedContextAMD(hglrc: GLContext): UInt32 := z_wglDeleteAssociatedContextAMD(hglrc);
    
    public z_wglMakeAssociatedContextCurrentAMD: function(hglrc: GLContext): UInt32 := FuncPtrOrNil&<function(hglrc: GLContext): UInt32>(GetGLProcAdr('wglMakeAssociatedContextCurrentAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglMakeAssociatedContextCurrentAMD(hglrc: GLContext): UInt32 := z_wglMakeAssociatedContextCurrentAMD(hglrc);
    
    public z_wglGetCurrentAssociatedContextAMD: function: GLContext := FuncPtrOrNil&<function: GLContext>(GetGLProcAdr('wglGetCurrentAssociatedContextAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetCurrentAssociatedContextAMD: GLContext := z_wglGetCurrentAssociatedContextAMD();
    
    public z_wglBlitContextFramebufferAMD: procedure(dstCtx: GLContext; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := FuncPtrOrNil&<procedure(dstCtx: GLContext; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>(GetGLProcAdr('wglBlitContextFramebufferAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure wglBlitContextFramebufferAMD(dstCtx: GLContext; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := z_wglBlitContextFramebufferAMD(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    {$endregion AMD_gpu_association}
    
    {$region NV_delay_before_swap}
    
    public z_glXDelayBeforeSwapNV: function(dpy: PDisplay; drawable: GLXDrawable; seconds: single): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; seconds: single): UInt32>(GetGLProcAdr('glXDelayBeforeSwapNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXDelayBeforeSwapNV(dpy: PDisplay; drawable: GLXDrawable; seconds: single): UInt32 := z_glXDelayBeforeSwapNV(dpy, drawable, seconds);
    
    public z_wglDelayBeforeSwapNV: function(hDC: GDI_DC; seconds: single): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; seconds: single): UInt32>(GetGLProcAdr('wglDelayBeforeSwapNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglDelayBeforeSwapNV(hDC: GDI_DC; seconds: single): UInt32 := z_wglDelayBeforeSwapNV(hDC, seconds);
    
    {$endregion NV_delay_before_swap}
    
    {$region NV_present_video}
    
    public z_glPresentFrameKeyedNV: procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32) := FuncPtrOrNil&<procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32)>(GetGLProcAdr('glPresentFrameKeyedNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glPresentFrameKeyedNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; key0: UInt32; target1: DummyEnum; fill1: UInt32; key1: UInt32) := z_glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, &type, target0, fill0, key0, target1, fill1, key1);
    
    public z_glPresentFrameDualFillNV: procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32) := FuncPtrOrNil&<procedure(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32)>(GetGLProcAdr('glPresentFrameDualFillNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glPresentFrameDualFillNV(video_slot: UInt32; minPresentTime: UInt64; beginPresentTimeId: UInt32; presentDurationId: UInt32; &type: DummyEnum; target0: DummyEnum; fill0: UInt32; target1: DummyEnum; fill1: UInt32; target2: DummyEnum; fill2: UInt32; target3: DummyEnum; fill3: UInt32) := z_glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, &type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
    
    public z_glGetVideoivNV: procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVideoivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoivNV(video_slot: UInt32; pname: DummyEnum; &params: array of Int32) := glGetVideoivNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoivNV(video_slot: UInt32; pname: DummyEnum; var &params: Int32) := glGetVideoivNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoivNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_glGetVideoivNV(video_slot, pname, &params);
    
    public z_glGetVideouivNV: procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVideouivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideouivNV(video_slot: UInt32; pname: DummyEnum; &params: array of UInt32) := glGetVideouivNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideouivNV(video_slot: UInt32; pname: DummyEnum; var &params: UInt32) := glGetVideouivNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideouivNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_glGetVideouivNV(video_slot, pname, &params);
    
    public z_glGetVideoi64vNV: procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVideoi64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; &params: array of Int64) := glGetVideoi64vNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; var &params: Int64) := glGetVideoi64vNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoi64vNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_glGetVideoi64vNV(video_slot, pname, &params);
    
    public z_glGetVideoui64vNV: procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_slot: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVideoui64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; &params: array of UInt64) := glGetVideoui64vNV(video_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; var &params: UInt64) := glGetVideoui64vNV(video_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoui64vNV(video_slot: UInt32; pname: DummyEnum; &params: pointer) := z_glGetVideoui64vNV(video_slot, pname, &params);
    
    public z_glXEnumerateVideoDevicesNV: function(dpy: PDisplay; screen: Int32; nelements: pointer): pointer := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; nelements: pointer): pointer>(GetGLProcAdr('glXEnumerateVideoDevicesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXEnumerateVideoDevicesNV(dpy: PDisplay; screen: Int32; nelements: array of Int32): pointer := glXEnumerateVideoDevicesNV(dpy, screen, nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXEnumerateVideoDevicesNV(dpy: PDisplay; screen: Int32; var nelements: Int32): pointer := glXEnumerateVideoDevicesNV(dpy, screen, @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXEnumerateVideoDevicesNV(dpy: PDisplay; screen: Int32; nelements: pointer): pointer := z_glXEnumerateVideoDevicesNV(dpy, screen, nelements);
    
    public z_glXBindVideoDeviceNV: function(dpy: PDisplay; video_slot: UInt32; video_device: UInt32; attrib_list: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; video_slot: UInt32; video_device: UInt32; attrib_list: pointer): Int32>(GetGLProcAdr('glXBindVideoDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXBindVideoDeviceNV(dpy: PDisplay; video_slot: UInt32; video_device: UInt32; attrib_list: array of Int32): Int32 := glXBindVideoDeviceNV(dpy, video_slot, video_device, attrib_list[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXBindVideoDeviceNV(dpy: PDisplay; video_slot: UInt32; video_device: UInt32; var attrib_list: Int32): Int32 := glXBindVideoDeviceNV(dpy, video_slot, video_device, @attrib_list);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXBindVideoDeviceNV(dpy: PDisplay; video_slot: UInt32; video_device: UInt32; attrib_list: pointer): Int32 := z_glXBindVideoDeviceNV(dpy, video_slot, video_device, attrib_list);
    
    public z_wglEnumerateVideoDevicesNV: function(hDc: GDI_DC; phDeviceList: pointer): Int32 := FuncPtrOrNil&<function(hDc: GDI_DC; phDeviceList: pointer): Int32>(GetGLProcAdr('wglEnumerateVideoDevicesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglEnumerateVideoDevicesNV(hDc: GDI_DC; phDeviceList: array of VideoOutputDeviceHandleNV): Int32 := wglEnumerateVideoDevicesNV(hDc, phDeviceList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglEnumerateVideoDevicesNV(hDc: GDI_DC; var phDeviceList: VideoOutputDeviceHandleNV): Int32 := wglEnumerateVideoDevicesNV(hDc, @phDeviceList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglEnumerateVideoDevicesNV(hDc: GDI_DC; phDeviceList: pointer): Int32 := z_wglEnumerateVideoDevicesNV(hDc, phDeviceList);
    
    public z_wglBindVideoDeviceNV: function(hDc: GDI_DC; uVideoSlot: UInt32; hVideoDevice: VideoOutputDeviceHandleNV; piAttribList: pointer): UInt32 := FuncPtrOrNil&<function(hDc: GDI_DC; uVideoSlot: UInt32; hVideoDevice: VideoOutputDeviceHandleNV; piAttribList: pointer): UInt32>(GetGLProcAdr('wglBindVideoDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglBindVideoDeviceNV(hDc: GDI_DC; uVideoSlot: UInt32; hVideoDevice: VideoOutputDeviceHandleNV; piAttribList: array of Int32): UInt32 := wglBindVideoDeviceNV(hDc, uVideoSlot, hVideoDevice, piAttribList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglBindVideoDeviceNV(hDc: GDI_DC; uVideoSlot: UInt32; hVideoDevice: VideoOutputDeviceHandleNV; var piAttribList: Int32): UInt32 := wglBindVideoDeviceNV(hDc, uVideoSlot, hVideoDevice, @piAttribList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglBindVideoDeviceNV(hDc: GDI_DC; uVideoSlot: UInt32; hVideoDevice: VideoOutputDeviceHandleNV; piAttribList: pointer): UInt32 := z_wglBindVideoDeviceNV(hDc, uVideoSlot, hVideoDevice, piAttribList);
    
    public z_wglQueryCurrentContextNV: function(iAttribute: Int32; piValue: pointer): UInt32 := FuncPtrOrNil&<function(iAttribute: Int32; piValue: pointer): UInt32>(GetGLProcAdr('wglQueryCurrentContextNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryCurrentContextNV(iAttribute: Int32; piValue: array of Int32): UInt32 := wglQueryCurrentContextNV(iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryCurrentContextNV(iAttribute: Int32; var piValue: Int32): UInt32 := wglQueryCurrentContextNV(iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryCurrentContextNV(iAttribute: Int32; piValue: pointer): UInt32 := z_wglQueryCurrentContextNV(iAttribute, piValue);
    
    {$endregion NV_present_video}
    
    {$region NV_swap_group}
    
    public z_glXQuerySwapGroupNV: function(dpy: PDisplay; drawable: GLXDrawable; group: pointer; barrier: pointer): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; group: pointer; barrier: pointer): UInt32>(GetGLProcAdr('glXQuerySwapGroupNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: array of UInt32; barrier: array of UInt32): UInt32 := glXQuerySwapGroupNV(dpy, drawable, group[0], barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: array of UInt32; var barrier: UInt32): UInt32 := glXQuerySwapGroupNV(dpy, drawable, group[0], @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: array of UInt32; barrier: pointer): UInt32 := glXQuerySwapGroupNV(dpy, drawable, group[0], barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; var group: UInt32; barrier: array of UInt32): UInt32 := glXQuerySwapGroupNV(dpy, drawable, @group, barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; var group: UInt32; var barrier: UInt32): UInt32 := glXQuerySwapGroupNV(dpy, drawable, @group, @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; var group: UInt32; barrier: pointer): UInt32 := glXQuerySwapGroupNV(dpy, drawable, @group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: pointer; barrier: array of UInt32): UInt32 := glXQuerySwapGroupNV(dpy, drawable, group, barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: pointer; var barrier: UInt32): UInt32 := glXQuerySwapGroupNV(dpy, drawable, group, @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQuerySwapGroupNV(dpy: PDisplay; drawable: GLXDrawable; group: pointer; barrier: pointer): UInt32 := z_glXQuerySwapGroupNV(dpy, drawable, group, barrier);
    
    public z_glXQueryMaxSwapGroupsNV: function(dpy: PDisplay; screen: Int32; maxGroups: pointer; maxBarriers: pointer): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; maxGroups: pointer; maxBarriers: pointer): UInt32>(GetGLProcAdr('glXQueryMaxSwapGroupsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: array of UInt32; maxBarriers: array of UInt32): UInt32 := glXQueryMaxSwapGroupsNV(dpy, screen, maxGroups[0], maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: array of UInt32; var maxBarriers: UInt32): UInt32 := glXQueryMaxSwapGroupsNV(dpy, screen, maxGroups[0], @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: array of UInt32; maxBarriers: pointer): UInt32 := glXQueryMaxSwapGroupsNV(dpy, screen, maxGroups[0], maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; var maxGroups: UInt32; maxBarriers: array of UInt32): UInt32 := glXQueryMaxSwapGroupsNV(dpy, screen, @maxGroups, maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; var maxGroups: UInt32; var maxBarriers: UInt32): UInt32 := glXQueryMaxSwapGroupsNV(dpy, screen, @maxGroups, @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; var maxGroups: UInt32; maxBarriers: pointer): UInt32 := glXQueryMaxSwapGroupsNV(dpy, screen, @maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: pointer; maxBarriers: array of UInt32): UInt32 := glXQueryMaxSwapGroupsNV(dpy, screen, maxGroups, maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: pointer; var maxBarriers: UInt32): UInt32 := glXQueryMaxSwapGroupsNV(dpy, screen, maxGroups, @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryMaxSwapGroupsNV(dpy: PDisplay; screen: Int32; maxGroups: pointer; maxBarriers: pointer): UInt32 := z_glXQueryMaxSwapGroupsNV(dpy, screen, maxGroups, maxBarriers);
    
    public z_glXQueryFrameCountNV: function(dpy: PDisplay; screen: Int32; count: pointer): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; count: pointer): UInt32>(GetGLProcAdr('glXQueryFrameCountNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryFrameCountNV(dpy: PDisplay; screen: Int32; count: array of UInt32): UInt32 := glXQueryFrameCountNV(dpy, screen, count[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryFrameCountNV(dpy: PDisplay; screen: Int32; var count: UInt32): UInt32 := glXQueryFrameCountNV(dpy, screen, @count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryFrameCountNV(dpy: PDisplay; screen: Int32; count: pointer): UInt32 := z_glXQueryFrameCountNV(dpy, screen, count);
    
    public z_glXResetFrameCountNV: function(dpy: PDisplay; screen: Int32): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32): UInt32>(GetGLProcAdr('glXResetFrameCountNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXResetFrameCountNV(dpy: PDisplay; screen: Int32): UInt32 := z_glXResetFrameCountNV(dpy, screen);
    
    public z_wglJoinSwapGroupNV: function(hDC: GDI_DC; group: UInt32): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; group: UInt32): UInt32>(GetGLProcAdr('wglJoinSwapGroupNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglJoinSwapGroupNV(hDC: GDI_DC; group: UInt32): UInt32 := z_wglJoinSwapGroupNV(hDC, group);
    
    public z_wglBindSwapBarrierNV: function(group: UInt32; barrier: UInt32): UInt32 := FuncPtrOrNil&<function(group: UInt32; barrier: UInt32): UInt32>(GetGLProcAdr('wglBindSwapBarrierNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglBindSwapBarrierNV(group: UInt32; barrier: UInt32): UInt32 := z_wglBindSwapBarrierNV(group, barrier);
    
    public z_wglQuerySwapGroupNV: function(hDC: GDI_DC; group: pointer; barrier: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; group: pointer; barrier: pointer): UInt32>(GetGLProcAdr('wglQuerySwapGroupNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQuerySwapGroupNV(hDC: GDI_DC; group: array of UInt32; barrier: array of UInt32): UInt32 := wglQuerySwapGroupNV(hDC, group[0], barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQuerySwapGroupNV(hDC: GDI_DC; group: array of UInt32; var barrier: UInt32): UInt32 := wglQuerySwapGroupNV(hDC, group[0], @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQuerySwapGroupNV(hDC: GDI_DC; group: array of UInt32; barrier: pointer): UInt32 := wglQuerySwapGroupNV(hDC, group[0], barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQuerySwapGroupNV(hDC: GDI_DC; var group: UInt32; barrier: array of UInt32): UInt32 := wglQuerySwapGroupNV(hDC, @group, barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQuerySwapGroupNV(hDC: GDI_DC; var group: UInt32; var barrier: UInt32): UInt32 := wglQuerySwapGroupNV(hDC, @group, @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQuerySwapGroupNV(hDC: GDI_DC; var group: UInt32; barrier: pointer): UInt32 := wglQuerySwapGroupNV(hDC, @group, barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQuerySwapGroupNV(hDC: GDI_DC; group: pointer; barrier: array of UInt32): UInt32 := wglQuerySwapGroupNV(hDC, group, barrier[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQuerySwapGroupNV(hDC: GDI_DC; group: pointer; var barrier: UInt32): UInt32 := wglQuerySwapGroupNV(hDC, group, @barrier);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQuerySwapGroupNV(hDC: GDI_DC; group: pointer; barrier: pointer): UInt32 := z_wglQuerySwapGroupNV(hDC, group, barrier);
    
    public z_wglQueryMaxSwapGroupsNV: function(hDC: GDI_DC; maxGroups: pointer; maxBarriers: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; maxGroups: pointer; maxBarriers: pointer): UInt32>(GetGLProcAdr('wglQueryMaxSwapGroupsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: array of UInt32; maxBarriers: array of UInt32): UInt32 := wglQueryMaxSwapGroupsNV(hDC, maxGroups[0], maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: array of UInt32; var maxBarriers: UInt32): UInt32 := wglQueryMaxSwapGroupsNV(hDC, maxGroups[0], @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: array of UInt32; maxBarriers: pointer): UInt32 := wglQueryMaxSwapGroupsNV(hDC, maxGroups[0], maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryMaxSwapGroupsNV(hDC: GDI_DC; var maxGroups: UInt32; maxBarriers: array of UInt32): UInt32 := wglQueryMaxSwapGroupsNV(hDC, @maxGroups, maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryMaxSwapGroupsNV(hDC: GDI_DC; var maxGroups: UInt32; var maxBarriers: UInt32): UInt32 := wglQueryMaxSwapGroupsNV(hDC, @maxGroups, @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryMaxSwapGroupsNV(hDC: GDI_DC; var maxGroups: UInt32; maxBarriers: pointer): UInt32 := wglQueryMaxSwapGroupsNV(hDC, @maxGroups, maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: pointer; maxBarriers: array of UInt32): UInt32 := wglQueryMaxSwapGroupsNV(hDC, maxGroups, maxBarriers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: pointer; var maxBarriers: UInt32): UInt32 := wglQueryMaxSwapGroupsNV(hDC, maxGroups, @maxBarriers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryMaxSwapGroupsNV(hDC: GDI_DC; maxGroups: pointer; maxBarriers: pointer): UInt32 := z_wglQueryMaxSwapGroupsNV(hDC, maxGroups, maxBarriers);
    
    public z_wglQueryFrameCountNV: function(hDC: GDI_DC; count: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; count: pointer): UInt32>(GetGLProcAdr('wglQueryFrameCountNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryFrameCountNV(hDC: GDI_DC; count: array of UInt32): UInt32 := wglQueryFrameCountNV(hDC, count[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryFrameCountNV(hDC: GDI_DC; var count: UInt32): UInt32 := wglQueryFrameCountNV(hDC, @count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryFrameCountNV(hDC: GDI_DC; count: pointer): UInt32 := z_wglQueryFrameCountNV(hDC, count);
    
    public z_wglResetFrameCountNV: function(hDC: GDI_DC): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC): UInt32>(GetGLProcAdr('wglResetFrameCountNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglResetFrameCountNV(hDC: GDI_DC): UInt32 := z_wglResetFrameCountNV(hDC);
    
    {$endregion NV_swap_group}
    
    {$region NV_video_capture}
    
    public z_glBeginVideoCaptureNV: procedure(video_capture_slot: UInt32) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32)>(GetGLProcAdr('glBeginVideoCaptureNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glBeginVideoCaptureNV(video_capture_slot: UInt32) := z_glBeginVideoCaptureNV(video_capture_slot);
    
    public z_glBindVideoCaptureStreamBufferNV: procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr)>(GetGLProcAdr('glBindVideoCaptureStreamBufferNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glBindVideoCaptureStreamBufferNV(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; offset: IntPtr) := z_glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
    
    public z_glBindVideoCaptureStreamTextureNV: procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: UInt32) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: UInt32)>(GetGLProcAdr('glBindVideoCaptureStreamTextureNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glBindVideoCaptureStreamTextureNV(video_capture_slot: UInt32; stream: UInt32; frame_region: DummyEnum; target: DummyEnum; texture: UInt32) := z_glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
    
    public z_glEndVideoCaptureNV: procedure(video_capture_slot: UInt32) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32)>(GetGLProcAdr('glEndVideoCaptureNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glEndVideoCaptureNV(video_capture_slot: UInt32) := z_glEndVideoCaptureNV(video_capture_slot);
    
    public z_glGetVideoCaptureivNV: procedure(video_capture_slot: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVideoCaptureivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; &params: array of Int32) := glGetVideoCaptureivNV(video_capture_slot, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; var &params: Int32) := glGetVideoCaptureivNV(video_capture_slot, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureivNV(video_capture_slot: UInt32; pname: DummyEnum; &params: pointer) := z_glGetVideoCaptureivNV(video_capture_slot, pname, &params);
    
    public z_glGetVideoCaptureStreamivNV: procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVideoCaptureStreamivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of Int32) := glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32) := glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureStreamivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, &params);
    
    public z_glGetVideoCaptureStreamfvNV: procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVideoCaptureStreamfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of single) := glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single) := glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureStreamfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, &params);
    
    public z_glGetVideoCaptureStreamdvNV: procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVideoCaptureStreamdvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of double) := glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: double) := glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glGetVideoCaptureStreamdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, &params);
    
    public z_glVideoCaptureNV: function(video_capture_slot: UInt32; sequence_num: pointer; capture_time: pointer): DummyEnum := FuncPtrOrNil&<function(video_capture_slot: UInt32; sequence_num: pointer; capture_time: pointer): DummyEnum>(GetGLProcAdr('glVideoCaptureNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glVideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; capture_time: array of UInt64): DummyEnum := glVideoCaptureNV(video_capture_slot, sequence_num[0], capture_time[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glVideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; var capture_time: UInt64): DummyEnum := glVideoCaptureNV(video_capture_slot, sequence_num[0], @capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glVideoCaptureNV(video_capture_slot: UInt32; sequence_num: array of UInt32; capture_time: pointer): DummyEnum := glVideoCaptureNV(video_capture_slot, sequence_num[0], capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glVideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; capture_time: array of UInt64): DummyEnum := glVideoCaptureNV(video_capture_slot, @sequence_num, capture_time[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glVideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; var capture_time: UInt64): DummyEnum := glVideoCaptureNV(video_capture_slot, @sequence_num, @capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glVideoCaptureNV(video_capture_slot: UInt32; var sequence_num: UInt32; capture_time: pointer): DummyEnum := glVideoCaptureNV(video_capture_slot, @sequence_num, capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glVideoCaptureNV(video_capture_slot: UInt32; sequence_num: pointer; capture_time: array of UInt64): DummyEnum := glVideoCaptureNV(video_capture_slot, sequence_num, capture_time[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glVideoCaptureNV(video_capture_slot: UInt32; sequence_num: pointer; var capture_time: UInt64): DummyEnum := glVideoCaptureNV(video_capture_slot, sequence_num, @capture_time);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glVideoCaptureNV(video_capture_slot: UInt32; sequence_num: pointer; capture_time: pointer): DummyEnum := z_glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
    
    public z_glVideoCaptureStreamParameterivNV: procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glVideoCaptureStreamParameterivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glVideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of Int32) := glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glVideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: Int32) := glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glVideoCaptureStreamParameterivNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, &params);
    
    public z_glVideoCaptureStreamParameterfvNV: procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glVideoCaptureStreamParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glVideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of single) := glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glVideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: single) := glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glVideoCaptureStreamParameterfvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, &params);
    
    public z_glVideoCaptureStreamParameterdvNV: procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glVideoCaptureStreamParameterdvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glVideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: array of double) := glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glVideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; var &params: double) := glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glVideoCaptureStreamParameterdvNV(video_capture_slot: UInt32; stream: UInt32; pname: DummyEnum; &params: pointer) := z_glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, &params);
    
    public z_glXBindVideoCaptureDeviceNV: function(dpy: PDisplay; video_capture_slot: UInt32; device: GLXVideoCaptureDeviceNV): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; video_capture_slot: UInt32; device: GLXVideoCaptureDeviceNV): Int32>(GetGLProcAdr('glXBindVideoCaptureDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXBindVideoCaptureDeviceNV(dpy: PDisplay; video_capture_slot: UInt32; device: GLXVideoCaptureDeviceNV): Int32 := z_glXBindVideoCaptureDeviceNV(dpy, video_capture_slot, device);
    
    public z_glXEnumerateVideoCaptureDevicesNV: function(dpy: PDisplay; screen: Int32; nelements: pointer): pointer := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; nelements: pointer): pointer>(GetGLProcAdr('glXEnumerateVideoCaptureDevicesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXEnumerateVideoCaptureDevicesNV(dpy: PDisplay; screen: Int32; nelements: array of Int32): pointer := glXEnumerateVideoCaptureDevicesNV(dpy, screen, nelements[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXEnumerateVideoCaptureDevicesNV(dpy: PDisplay; screen: Int32; var nelements: Int32): pointer := glXEnumerateVideoCaptureDevicesNV(dpy, screen, @nelements);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXEnumerateVideoCaptureDevicesNV(dpy: PDisplay; screen: Int32; nelements: pointer): pointer := z_glXEnumerateVideoCaptureDevicesNV(dpy, screen, nelements);
    
    public z_glXLockVideoCaptureDeviceNV: procedure(dpy: PDisplay; device: GLXVideoCaptureDeviceNV) := FuncPtrOrNil&<procedure(dpy: PDisplay; device: GLXVideoCaptureDeviceNV)>(GetGLProcAdr('glXLockVideoCaptureDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glXLockVideoCaptureDeviceNV(dpy: PDisplay; device: GLXVideoCaptureDeviceNV) := z_glXLockVideoCaptureDeviceNV(dpy, device);
    
    public z_glXQueryVideoCaptureDeviceNV: function(dpy: PDisplay; device: GLXVideoCaptureDeviceNV; attribute: Int32; value: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; device: GLXVideoCaptureDeviceNV; attribute: Int32; value: pointer): Int32>(GetGLProcAdr('glXQueryVideoCaptureDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryVideoCaptureDeviceNV(dpy: PDisplay; device: GLXVideoCaptureDeviceNV; attribute: Int32; value: array of Int32): Int32 := glXQueryVideoCaptureDeviceNV(dpy, device, attribute, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryVideoCaptureDeviceNV(dpy: PDisplay; device: GLXVideoCaptureDeviceNV; attribute: Int32; var value: Int32): Int32 := glXQueryVideoCaptureDeviceNV(dpy, device, attribute, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXQueryVideoCaptureDeviceNV(dpy: PDisplay; device: GLXVideoCaptureDeviceNV; attribute: Int32; value: pointer): Int32 := z_glXQueryVideoCaptureDeviceNV(dpy, device, attribute, value);
    
    public z_glXReleaseVideoCaptureDeviceNV: procedure(dpy: PDisplay; device: GLXVideoCaptureDeviceNV) := FuncPtrOrNil&<procedure(dpy: PDisplay; device: GLXVideoCaptureDeviceNV)>(GetGLProcAdr('glXReleaseVideoCaptureDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure glXReleaseVideoCaptureDeviceNV(dpy: PDisplay; device: GLXVideoCaptureDeviceNV) := z_glXReleaseVideoCaptureDeviceNV(dpy, device);
    
    public z_wglBindVideoCaptureDeviceNV: function(uVideoSlot: UInt32; hDevice: VideoInputDeviceHandleNV): UInt32 := FuncPtrOrNil&<function(uVideoSlot: UInt32; hDevice: VideoInputDeviceHandleNV): UInt32>(GetGLProcAdr('wglBindVideoCaptureDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglBindVideoCaptureDeviceNV(uVideoSlot: UInt32; hDevice: VideoInputDeviceHandleNV): UInt32 := z_wglBindVideoCaptureDeviceNV(uVideoSlot, hDevice);
    
    public z_wglEnumerateVideoCaptureDevicesNV: function(hDc: GDI_DC; phDeviceList: pointer): UInt32 := FuncPtrOrNil&<function(hDc: GDI_DC; phDeviceList: pointer): UInt32>(GetGLProcAdr('wglEnumerateVideoCaptureDevicesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglEnumerateVideoCaptureDevicesNV(hDc: GDI_DC; phDeviceList: array of VideoInputDeviceHandleNV): UInt32 := wglEnumerateVideoCaptureDevicesNV(hDc, phDeviceList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglEnumerateVideoCaptureDevicesNV(hDc: GDI_DC; var phDeviceList: VideoInputDeviceHandleNV): UInt32 := wglEnumerateVideoCaptureDevicesNV(hDc, @phDeviceList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglEnumerateVideoCaptureDevicesNV(hDc: GDI_DC; phDeviceList: pointer): UInt32 := z_wglEnumerateVideoCaptureDevicesNV(hDc, phDeviceList);
    
    public z_wglLockVideoCaptureDeviceNV: function(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV): UInt32 := FuncPtrOrNil&<function(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV): UInt32>(GetGLProcAdr('wglLockVideoCaptureDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglLockVideoCaptureDeviceNV(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV): UInt32 := z_wglLockVideoCaptureDeviceNV(hDc, hDevice);
    
    public z_wglQueryVideoCaptureDeviceNV: function(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV; iAttribute: Int32; piValue: pointer): UInt32 := FuncPtrOrNil&<function(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV; iAttribute: Int32; piValue: pointer): UInt32>(GetGLProcAdr('wglQueryVideoCaptureDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryVideoCaptureDeviceNV(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV; iAttribute: Int32; piValue: array of Int32): UInt32 := wglQueryVideoCaptureDeviceNV(hDc, hDevice, iAttribute, piValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryVideoCaptureDeviceNV(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV; iAttribute: Int32; var piValue: Int32): UInt32 := wglQueryVideoCaptureDeviceNV(hDc, hDevice, iAttribute, @piValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglQueryVideoCaptureDeviceNV(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV; iAttribute: Int32; piValue: pointer): UInt32 := z_wglQueryVideoCaptureDeviceNV(hDc, hDevice, iAttribute, piValue);
    
    public z_wglReleaseVideoCaptureDeviceNV: function(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV): UInt32 := FuncPtrOrNil&<function(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV): UInt32>(GetGLProcAdr('wglReleaseVideoCaptureDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglReleaseVideoCaptureDeviceNV(hDc: GDI_DC; hDevice: VideoInputDeviceHandleNV): UInt32 := z_wglReleaseVideoCaptureDeviceNV(hDc, hDevice);
    
    {$endregion NV_video_capture}
    
    {$region NV_video_output}
    
    public z_glXGetVideoDeviceNV: function(dpy: PDisplay; screen: Int32; numVideoDevices: Int32; pVideoDevice: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; numVideoDevices: Int32; pVideoDevice: pointer): Int32>(GetGLProcAdr('glXGetVideoDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoDeviceNV(dpy: PDisplay; screen: Int32; numVideoDevices: Int32; pVideoDevice: array of GLXVideoDeviceNV): Int32 := glXGetVideoDeviceNV(dpy, screen, numVideoDevices, pVideoDevice[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoDeviceNV(dpy: PDisplay; screen: Int32; numVideoDevices: Int32; var pVideoDevice: GLXVideoDeviceNV): Int32 := glXGetVideoDeviceNV(dpy, screen, numVideoDevices, @pVideoDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoDeviceNV(dpy: PDisplay; screen: Int32; numVideoDevices: Int32; pVideoDevice: pointer): Int32 := z_glXGetVideoDeviceNV(dpy, screen, numVideoDevices, pVideoDevice);
    
    public z_glXReleaseVideoDeviceNV: function(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV): Int32>(GetGLProcAdr('glXReleaseVideoDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXReleaseVideoDeviceNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV): Int32 := z_glXReleaseVideoDeviceNV(dpy, screen, VideoDevice);
    
    public z_glXBindVideoImageNV: function(dpy: PDisplay; VideoDevice: GLXVideoDeviceNV; pbuf: GLXPbuffer; iVideoBuffer: Int32): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; VideoDevice: GLXVideoDeviceNV; pbuf: GLXPbuffer; iVideoBuffer: Int32): Int32>(GetGLProcAdr('glXBindVideoImageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXBindVideoImageNV(dpy: PDisplay; VideoDevice: GLXVideoDeviceNV; pbuf: GLXPbuffer; iVideoBuffer: Int32): Int32 := z_glXBindVideoImageNV(dpy, VideoDevice, pbuf, iVideoBuffer);
    
    public z_glXReleaseVideoImageNV: function(dpy: PDisplay; pbuf: GLXPbuffer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; pbuf: GLXPbuffer): Int32>(GetGLProcAdr('glXReleaseVideoImageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXReleaseVideoImageNV(dpy: PDisplay; pbuf: GLXPbuffer): Int32 := z_glXReleaseVideoImageNV(dpy, pbuf);
    
    public z_glXSendPbufferToVideoNV: function(dpy: PDisplay; pbuf: GLXPbuffer; iBufferType: Int32; pulCounterPbuffer: pointer; bBlock: Byte): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; pbuf: GLXPbuffer; iBufferType: Int32; pulCounterPbuffer: pointer; bBlock: Byte): Int32>(GetGLProcAdr('glXSendPbufferToVideoNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXSendPbufferToVideoNV(dpy: PDisplay; pbuf: GLXPbuffer; iBufferType: Int32; pulCounterPbuffer: array of UInt64; bBlock: Byte): Int32 := glXSendPbufferToVideoNV(dpy, pbuf, iBufferType, pulCounterPbuffer[0], bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXSendPbufferToVideoNV(dpy: PDisplay; pbuf: GLXPbuffer; iBufferType: Int32; var pulCounterPbuffer: UInt64; bBlock: Byte): Int32 := glXSendPbufferToVideoNV(dpy, pbuf, iBufferType, @pulCounterPbuffer, bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXSendPbufferToVideoNV(dpy: PDisplay; pbuf: GLXPbuffer; iBufferType: Int32; pulCounterPbuffer: pointer; bBlock: Byte): Int32 := z_glXSendPbufferToVideoNV(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
    
    public z_glXGetVideoInfoNV: function(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: pointer): Int32 := FuncPtrOrNil&<function(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: pointer): Int32>(GetGLProcAdr('glXGetVideoInfoNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: array of UInt64; pulCounterOutputVideo: array of UInt64): Int32 := glXGetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer[0], pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: array of UInt64; var pulCounterOutputVideo: UInt64): Int32 := glXGetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer[0], @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: array of UInt64; pulCounterOutputVideo: pointer): Int32 := glXGetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer[0], pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: array of UInt64): Int32 := glXGetVideoInfoNV(dpy, screen, VideoDevice, @pulCounterOutputPbuffer, pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; var pulCounterOutputPbuffer: UInt64; var pulCounterOutputVideo: UInt64): Int32 := glXGetVideoInfoNV(dpy, screen, VideoDevice, @pulCounterOutputPbuffer, @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: pointer): Int32 := glXGetVideoInfoNV(dpy, screen, VideoDevice, @pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: array of UInt64): Int32 := glXGetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: pointer; var pulCounterOutputVideo: UInt64): Int32 := glXGetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer, @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetVideoInfoNV(dpy: PDisplay; screen: Int32; VideoDevice: GLXVideoDeviceNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: pointer): Int32 := z_glXGetVideoInfoNV(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    
    public z_wglGetVideoDeviceNV: function(hDC: GDI_DC; numDevices: Int32; hVideoDevice: pointer): UInt32 := FuncPtrOrNil&<function(hDC: GDI_DC; numDevices: Int32; hVideoDevice: pointer): UInt32>(GetGLProcAdr('wglGetVideoDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoDeviceNV(hDC: GDI_DC; numDevices: Int32; hVideoDevice: array of VideoDeviceHandleNV): UInt32 := wglGetVideoDeviceNV(hDC, numDevices, hVideoDevice[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoDeviceNV(hDC: GDI_DC; numDevices: Int32; var hVideoDevice: VideoDeviceHandleNV): UInt32 := wglGetVideoDeviceNV(hDC, numDevices, @hVideoDevice);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoDeviceNV(hDC: GDI_DC; numDevices: Int32; hVideoDevice: pointer): UInt32 := z_wglGetVideoDeviceNV(hDC, numDevices, hVideoDevice);
    
    public z_wglReleaseVideoDeviceNV: function(hVideoDevice: VideoDeviceHandleNV): UInt32 := FuncPtrOrNil&<function(hVideoDevice: VideoDeviceHandleNV): UInt32>(GetGLProcAdr('wglReleaseVideoDeviceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglReleaseVideoDeviceNV(hVideoDevice: VideoDeviceHandleNV): UInt32 := z_wglReleaseVideoDeviceNV(hVideoDevice);
    
    public z_wglBindVideoImageNV: function(hVideoDevice: VideoDeviceHandleNV; hPbuffer: PBufferName; iVideoBuffer: Int32): UInt32 := FuncPtrOrNil&<function(hVideoDevice: VideoDeviceHandleNV; hPbuffer: PBufferName; iVideoBuffer: Int32): UInt32>(GetGLProcAdr('wglBindVideoImageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglBindVideoImageNV(hVideoDevice: VideoDeviceHandleNV; hPbuffer: PBufferName; iVideoBuffer: Int32): UInt32 := z_wglBindVideoImageNV(hVideoDevice, hPbuffer, iVideoBuffer);
    
    public z_wglReleaseVideoImageNV: function(hPbuffer: PBufferName; iVideoBuffer: Int32): UInt32 := FuncPtrOrNil&<function(hPbuffer: PBufferName; iVideoBuffer: Int32): UInt32>(GetGLProcAdr('wglReleaseVideoImageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglReleaseVideoImageNV(hPbuffer: PBufferName; iVideoBuffer: Int32): UInt32 := z_wglReleaseVideoImageNV(hPbuffer, iVideoBuffer);
    
    public z_wglSendPbufferToVideoNV: function(hPbuffer: PBufferName; iBufferType: Int32; pulCounterPbuffer: pointer; bBlock: UInt32): UInt32 := FuncPtrOrNil&<function(hPbuffer: PBufferName; iBufferType: Int32; pulCounterPbuffer: pointer; bBlock: UInt32): UInt32>(GetGLProcAdr('wglSendPbufferToVideoNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglSendPbufferToVideoNV(hPbuffer: PBufferName; iBufferType: Int32; pulCounterPbuffer: array of UInt64; bBlock: UInt32): UInt32 := wglSendPbufferToVideoNV(hPbuffer, iBufferType, pulCounterPbuffer[0], bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglSendPbufferToVideoNV(hPbuffer: PBufferName; iBufferType: Int32; var pulCounterPbuffer: UInt64; bBlock: UInt32): UInt32 := wglSendPbufferToVideoNV(hPbuffer, iBufferType, @pulCounterPbuffer, bBlock);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglSendPbufferToVideoNV(hPbuffer: PBufferName; iBufferType: Int32; pulCounterPbuffer: pointer; bBlock: UInt32): UInt32 := z_wglSendPbufferToVideoNV(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
    
    public z_wglGetVideoInfoNV: function(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: pointer): UInt32 := FuncPtrOrNil&<function(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: pointer): UInt32>(GetGLProcAdr('wglGetVideoInfoNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: array of UInt64; pulCounterOutputVideo: array of UInt64): UInt32 := wglGetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer[0], pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: array of UInt64; var pulCounterOutputVideo: UInt64): UInt32 := wglGetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer[0], @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: array of UInt64; pulCounterOutputVideo: pointer): UInt32 := wglGetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer[0], pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: array of UInt64): UInt32 := wglGetVideoInfoNV(hpVideoDevice, @pulCounterOutputPbuffer, pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; var pulCounterOutputPbuffer: UInt64; var pulCounterOutputVideo: UInt64): UInt32 := wglGetVideoInfoNV(hpVideoDevice, @pulCounterOutputPbuffer, @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; var pulCounterOutputPbuffer: UInt64; pulCounterOutputVideo: pointer): UInt32 := wglGetVideoInfoNV(hpVideoDevice, @pulCounterOutputPbuffer, pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: array of UInt64): UInt32 := wglGetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: pointer; var pulCounterOutputVideo: UInt64): UInt32 := wglGetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer, @pulCounterOutputVideo);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetVideoInfoNV(hpVideoDevice: VideoDeviceHandleNV; pulCounterOutputPbuffer: pointer; pulCounterOutputVideo: pointer): UInt32 := z_wglGetVideoInfoNV(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
    
    {$endregion NV_video_output}
    
    {$region OML_sync_control}
    
    public z_glXGetSyncValuesOML: function(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: pointer; sbc: pointer): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: pointer; sbc: pointer): UInt32>(GetGLProcAdr('glXGetSyncValuesOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := glXGetSyncValuesOML(dpy, drawable, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := glXGetSyncValuesOML(dpy, drawable, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := glXGetSyncValuesOML(dpy, drawable, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := glXGetSyncValuesOML(dpy, drawable, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetSyncValuesOML(dpy: PDisplay; drawable: GLXDrawable; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_glXGetSyncValuesOML(dpy, drawable, ust, msc, sbc);
    
    public z_glXGetMscRateOML: function(dpy: PDisplay; drawable: GLXDrawable; numerator: pointer; denominator: pointer): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; numerator: pointer; denominator: pointer): UInt32>(GetGLProcAdr('glXGetMscRateOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: array of Int32; denominator: array of Int32): UInt32 := glXGetMscRateOML(dpy, drawable, numerator[0], denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: array of Int32; var denominator: Int32): UInt32 := glXGetMscRateOML(dpy, drawable, numerator[0], @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: array of Int32; denominator: pointer): UInt32 := glXGetMscRateOML(dpy, drawable, numerator[0], denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; var numerator: Int32; denominator: array of Int32): UInt32 := glXGetMscRateOML(dpy, drawable, @numerator, denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; var numerator: Int32; var denominator: Int32): UInt32 := glXGetMscRateOML(dpy, drawable, @numerator, @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; var numerator: Int32; denominator: pointer): UInt32 := glXGetMscRateOML(dpy, drawable, @numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: pointer; denominator: array of Int32): UInt32 := glXGetMscRateOML(dpy, drawable, numerator, denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: pointer; var denominator: Int32): UInt32 := glXGetMscRateOML(dpy, drawable, numerator, @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXGetMscRateOML(dpy: PDisplay; drawable: GLXDrawable; numerator: pointer; denominator: pointer): UInt32 := z_glXGetMscRateOML(dpy, drawable, numerator, denominator);
    
    public z_glXSwapBuffersMscOML: function(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 := FuncPtrOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>(GetGLProcAdr('glXSwapBuffersMscOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXSwapBuffersMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 := z_glXSwapBuffersMscOML(dpy, drawable, target_msc, divisor, remainder);
    
    public z_glXWaitForMscOML: function(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32>(GetGLProcAdr('glXWaitForMscOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForMscOML(dpy: PDisplay; drawable: GLXDrawable; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_glXWaitForMscOML(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
    
    public z_glXWaitForSbcOML: function(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := FuncPtrOrNil&<function(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32>(GetGLProcAdr('glXWaitForSbcOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := glXWaitForSbcOML(dpy, drawable, target_sbc, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function glXWaitForSbcOML(dpy: PDisplay; drawable: GLXDrawable; target_sbc: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_glXWaitForSbcOML(dpy, drawable, target_sbc, ust, msc, sbc);
    
    public z_wglGetSyncValuesOML: function(hdc: GDI_DC; ust: pointer; msc: pointer; sbc: pointer): UInt32 := FuncPtrOrNil&<function(hdc: GDI_DC; ust: pointer; msc: pointer; sbc: pointer): UInt32>(GetGLProcAdr('wglGetSyncValuesOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := wglGetSyncValuesOML(hdc, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := wglGetSyncValuesOML(hdc, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := wglGetSyncValuesOML(hdc, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := wglGetSyncValuesOML(hdc, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := wglGetSyncValuesOML(hdc, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := wglGetSyncValuesOML(hdc, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := wglGetSyncValuesOML(hdc, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := wglGetSyncValuesOML(hdc, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := wglGetSyncValuesOML(hdc, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := wglGetSyncValuesOML(hdc, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := wglGetSyncValuesOML(hdc, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := wglGetSyncValuesOML(hdc, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := wglGetSyncValuesOML(hdc, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := wglGetSyncValuesOML(hdc, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := wglGetSyncValuesOML(hdc, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := wglGetSyncValuesOML(hdc, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := wglGetSyncValuesOML(hdc, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := wglGetSyncValuesOML(hdc, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := wglGetSyncValuesOML(hdc, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := wglGetSyncValuesOML(hdc, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := wglGetSyncValuesOML(hdc, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := wglGetSyncValuesOML(hdc, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := wglGetSyncValuesOML(hdc, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := wglGetSyncValuesOML(hdc, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := wglGetSyncValuesOML(hdc, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := wglGetSyncValuesOML(hdc, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetSyncValuesOML(hdc: GDI_DC; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_wglGetSyncValuesOML(hdc, ust, msc, sbc);
    
    public z_wglGetMscRateOML: function(hdc: GDI_DC; numerator: pointer; denominator: pointer): UInt32 := FuncPtrOrNil&<function(hdc: GDI_DC; numerator: pointer; denominator: pointer): UInt32>(GetGLProcAdr('wglGetMscRateOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetMscRateOML(hdc: GDI_DC; numerator: array of Int32; denominator: array of Int32): UInt32 := wglGetMscRateOML(hdc, numerator[0], denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetMscRateOML(hdc: GDI_DC; numerator: array of Int32; var denominator: Int32): UInt32 := wglGetMscRateOML(hdc, numerator[0], @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetMscRateOML(hdc: GDI_DC; numerator: array of Int32; denominator: pointer): UInt32 := wglGetMscRateOML(hdc, numerator[0], denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetMscRateOML(hdc: GDI_DC; var numerator: Int32; denominator: array of Int32): UInt32 := wglGetMscRateOML(hdc, @numerator, denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetMscRateOML(hdc: GDI_DC; var numerator: Int32; var denominator: Int32): UInt32 := wglGetMscRateOML(hdc, @numerator, @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetMscRateOML(hdc: GDI_DC; var numerator: Int32; denominator: pointer): UInt32 := wglGetMscRateOML(hdc, @numerator, denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetMscRateOML(hdc: GDI_DC; numerator: pointer; denominator: array of Int32): UInt32 := wglGetMscRateOML(hdc, numerator, denominator[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetMscRateOML(hdc: GDI_DC; numerator: pointer; var denominator: Int32): UInt32 := wglGetMscRateOML(hdc, numerator, @denominator);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglGetMscRateOML(hdc: GDI_DC; numerator: pointer; denominator: pointer): UInt32 := z_wglGetMscRateOML(hdc, numerator, denominator);
    
    public z_wglSwapBuffersMscOML: function(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 := FuncPtrOrNil&<function(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>(GetGLProcAdr('wglSwapBuffersMscOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglSwapBuffersMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 := z_wglSwapBuffersMscOML(hdc, target_msc, divisor, remainder);
    
    public z_wglSwapLayerBuffersMscOML: function(hdc: GDI_DC; fuPlanes: Int32; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 := FuncPtrOrNil&<function(hdc: GDI_DC; fuPlanes: Int32; target_msc: Int64; divisor: Int64; remainder: Int64): Int64>(GetGLProcAdr('wglSwapLayerBuffersMscOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglSwapLayerBuffersMscOML(hdc: GDI_DC; fuPlanes: Int32; target_msc: Int64; divisor: Int64; remainder: Int64): Int64 := z_wglSwapLayerBuffersMscOML(hdc, fuPlanes, target_msc, divisor, remainder);
    
    public z_wglWaitForMscOML: function(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := FuncPtrOrNil&<function(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32>(GetGLProcAdr('wglWaitForMscOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForMscOML(hdc: GDI_DC; target_msc: Int64; divisor: Int64; remainder: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_wglWaitForMscOML(hdc, target_msc, divisor, remainder, ust, msc, sbc);
    
    public z_wglWaitForSbcOML: function(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := FuncPtrOrNil&<function(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32>(GetGLProcAdr('wglWaitForSbcOML'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: array of Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust[0], msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: array of Int64; var sbc: Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust[0], msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: array of Int64; sbc: pointer): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust[0], msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; var msc: Int64; sbc: array of Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust[0], @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; var msc: Int64; var sbc: Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust[0], @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; var msc: Int64; sbc: pointer): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust[0], @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: pointer; sbc: array of Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust[0], msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: pointer; var sbc: Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust[0], msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: array of Int64; msc: pointer; sbc: pointer): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust[0], msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: array of Int64; sbc: array of Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, @ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: array of Int64; var sbc: Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, @ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: array of Int64; sbc: pointer): UInt32 := wglWaitForSbcOML(hdc, target_sbc, @ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: array of Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, @ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; var msc: Int64; var sbc: Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, @ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; var msc: Int64; sbc: pointer): UInt32 := wglWaitForSbcOML(hdc, target_sbc, @ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: pointer; sbc: array of Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, @ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: pointer; var sbc: Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, @ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; var ust: Int64; msc: pointer; sbc: pointer): UInt32 := wglWaitForSbcOML(hdc, target_sbc, @ust, msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: array of Int64; sbc: array of Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust, msc[0], sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: array of Int64; var sbc: Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust, msc[0], @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: array of Int64; sbc: pointer): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust, msc[0], sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; var msc: Int64; sbc: array of Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust, @msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; var msc: Int64; var sbc: Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust, @msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; var msc: Int64; sbc: pointer): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust, @msc, sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: pointer; sbc: array of Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust, msc, sbc[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: pointer; var sbc: Int64): UInt32 := wglWaitForSbcOML(hdc, target_sbc, ust, msc, @sbc);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function wglWaitForSbcOML(hdc: GDI_DC; target_sbc: Int64; ust: pointer; msc: pointer; sbc: pointer): UInt32 := z_wglWaitForSbcOML(hdc, target_sbc, ust, msc, sbc);
    
    {$endregion OML_sync_control}
    
  end;
  
  gl_AMD = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region Unsorted}
    
    public z_TexStorageSparseAMD: procedure(target: DummyEnum; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: DummyFlags) := FuncPtrOrNil&<procedure(target: DummyEnum; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: DummyFlags)>(GetGLProcAdr('glTexStorageSparseAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexStorageSparseAMD(target: DummyEnum; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: DummyFlags) := z_TexStorageSparseAMD(target, internalFormat, width, height, depth, layers, flags);
    
    public z_TextureStorageSparseAMD: procedure(texture: UInt32; target: DummyEnum; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: DummyFlags) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: DummyFlags)>(GetGLProcAdr('glTextureStorageSparseAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureStorageSparseAMD(texture: UInt32; target: DummyEnum; internalFormat: DummyEnum; width: Int32; height: Int32; depth: Int32; layers: Int32; flags: DummyFlags) := z_TextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, flags);
    
    {$endregion Unsorted}
    
    {$region AMD_debug_output}
    
    public z_DebugMessageEnableAMD: procedure(category: DummyEnum; severity: DummyEnum; count: Int32; ids: pointer; enabled: Byte) := FuncPtrOrNil&<procedure(category: DummyEnum; severity: DummyEnum; count: Int32; ids: pointer; enabled: Byte)>(GetGLProcAdr('glDebugMessageEnableAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DummyEnum; severity: DummyEnum; count: Int32; ids: array of UInt32; enabled: Byte) := DebugMessageEnableAMD(category, severity, count, ids[0], enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DummyEnum; severity: DummyEnum; count: Int32; var ids: UInt32; enabled: Byte) := DebugMessageEnableAMD(category, severity, count, @ids, enabled);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DebugMessageEnableAMD(category: DummyEnum; severity: DummyEnum; count: Int32; ids: pointer; enabled: Byte) := z_DebugMessageEnableAMD(category, severity, count, ids, enabled);
    
    {$endregion AMD_debug_output}
    
    {$region AMD_draw_buffers_blend}
    
    public z_BlendFuncIndexedAMD: procedure(buf: UInt32; src: DummyEnum; dst: DummyEnum) := FuncPtrOrNil&<procedure(buf: UInt32; src: DummyEnum; dst: DummyEnum)>(GetGLProcAdr('glBlendFuncIndexedAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncIndexedAMD(buf: UInt32; src: DummyEnum; dst: DummyEnum) := z_BlendFuncIndexedAMD(buf, src, dst);
    
    public z_BlendFuncSeparateIndexedAMD: procedure(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum) := FuncPtrOrNil&<procedure(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum)>(GetGLProcAdr('glBlendFuncSeparateIndexedAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendFuncSeparateIndexedAMD(buf: UInt32; srcRGB: DummyEnum; dstRGB: DummyEnum; srcAlpha: DummyEnum; dstAlpha: DummyEnum) := z_BlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
    
    public z_BlendEquationIndexedAMD: procedure(buf: UInt32; mode: DummyEnum) := FuncPtrOrNil&<procedure(buf: UInt32; mode: DummyEnum)>(GetGLProcAdr('glBlendEquationIndexedAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationIndexedAMD(buf: UInt32; mode: DummyEnum) := z_BlendEquationIndexedAMD(buf, mode);
    
    public z_BlendEquationSeparateIndexedAMD: procedure(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum) := FuncPtrOrNil&<procedure(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum)>(GetGLProcAdr('glBlendEquationSeparateIndexedAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendEquationSeparateIndexedAMD(buf: UInt32; modeRGB: DummyEnum; modeAlpha: DummyEnum) := z_BlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
    
    {$endregion AMD_draw_buffers_blend}
    
    {$region AMD_framebuffer_multisample_advanced}
    
    public z_RenderbufferStorageMultisampleAdvancedAMD: procedure(target: DummyEnum; samples: Int32; storageSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; samples: Int32; storageSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>(GetGLProcAdr('glRenderbufferStorageMultisampleAdvancedAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleAdvancedAMD(target: DummyEnum; samples: Int32; storageSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageMultisampleAdvancedAMD(target, samples, storageSamples, internalformat, width, height);
    
    public z_NamedRenderbufferStorageMultisampleAdvancedAMD: procedure(renderbuffer: UInt32; samples: Int32; storageSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := FuncPtrOrNil&<procedure(renderbuffer: UInt32; samples: Int32; storageSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>(GetGLProcAdr('glNamedRenderbufferStorageMultisampleAdvancedAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer: UInt32; samples: Int32; storageSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_NamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer, samples, storageSamples, internalformat, width, height);
    
    {$endregion AMD_framebuffer_multisample_advanced}
    
    {$region AMD_framebuffer_sample_positions}
    
    public z_FramebufferSamplePositionsfvAMD: procedure(target: DummyEnum; numsamples: UInt32; pixelindex: UInt32; values: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; numsamples: UInt32; pixelindex: UInt32; values: pointer)>(GetGLProcAdr('glFramebufferSamplePositionsfvAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: DummyEnum; numsamples: UInt32; pixelindex: UInt32; values: array of single) := FramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: DummyEnum; numsamples: UInt32; pixelindex: UInt32; var values: single) := FramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferSamplePositionsfvAMD(target: DummyEnum; numsamples: UInt32; pixelindex: UInt32; values: pointer) := z_FramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, values);
    
    public z_NamedFramebufferSamplePositionsfvAMD: procedure(framebuffer: UInt32; numsamples: UInt32; pixelindex: UInt32; values: pointer) := FuncPtrOrNil&<procedure(framebuffer: UInt32; numsamples: UInt32; pixelindex: UInt32; values: pointer)>(GetGLProcAdr('glNamedFramebufferSamplePositionsfvAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: UInt32; numsamples: UInt32; pixelindex: UInt32; values: array of single) := NamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: UInt32; numsamples: UInt32; pixelindex: UInt32; var values: single) := NamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferSamplePositionsfvAMD(framebuffer: UInt32; numsamples: UInt32; pixelindex: UInt32; values: pointer) := z_NamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, values);
    
    public z_GetFramebufferParameterfvAMD: procedure(target: DummyEnum; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: pointer)>(GetGLProcAdr('glGetFramebufferParameterfvAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterfvAMD(target: DummyEnum; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: array of single) := GetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterfvAMD(target: DummyEnum; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single) := GetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFramebufferParameterfvAMD(target: DummyEnum; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: pointer) := z_GetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, values);
    
    public z_GetNamedFramebufferParameterfvAMD: procedure(framebuffer: UInt32; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: pointer) := FuncPtrOrNil&<procedure(framebuffer: UInt32; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: pointer)>(GetGLProcAdr('glGetNamedFramebufferParameterfvAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterfvAMD(framebuffer: UInt32; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: array of single) := GetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterfvAMD(framebuffer: UInt32; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; var values: single) := GetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedFramebufferParameterfvAMD(framebuffer: UInt32; pname: DummyEnum; numsamples: UInt32; pixelindex: UInt32; size: Int32; values: pointer) := z_GetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, values);
    
    {$endregion AMD_framebuffer_sample_positions}
    
    {$region AMD_interleaved_elements}
    
    public z_VertexAttribParameteriAMD: procedure(index: UInt32; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(index: UInt32; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glVertexAttribParameteriAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribParameteriAMD(index: UInt32; pname: DummyEnum; param: Int32) := z_VertexAttribParameteriAMD(index, pname, param);
    
    {$endregion AMD_interleaved_elements}
    
    {$region AMD_name_gen_delete}
    
    public z_GenNamesAMD: procedure(identifier: DummyEnum; num: UInt32; names: pointer) := FuncPtrOrNil&<procedure(identifier: DummyEnum; num: UInt32; names: pointer)>(GetGLProcAdr('glGenNamesAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; names: array of UInt32) := GenNamesAMD(identifier, num, names[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; var names: UInt32) := GenNamesAMD(identifier, num, @names);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenNamesAMD(identifier: DummyEnum; num: UInt32; names: pointer) := z_GenNamesAMD(identifier, num, names);
    
    public z_DeleteNamesAMD: procedure(identifier: DummyEnum; num: UInt32; names: pointer) := FuncPtrOrNil&<procedure(identifier: DummyEnum; num: UInt32; names: pointer)>(GetGLProcAdr('glDeleteNamesAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; names: array of UInt32) := DeleteNamesAMD(identifier, num, names[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; var names: UInt32) := DeleteNamesAMD(identifier, num, @names);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteNamesAMD(identifier: DummyEnum; num: UInt32; names: pointer) := z_DeleteNamesAMD(identifier, num, names);
    
    public z_IsNameAMD: function(identifier: DummyEnum; name: UInt32): Byte := FuncPtrOrNil&<function(identifier: DummyEnum; name: UInt32): Byte>(GetGLProcAdr('glIsNameAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNameAMD(identifier: DummyEnum; name: UInt32): Byte := z_IsNameAMD(identifier, name);
    
    {$endregion AMD_name_gen_delete}
    
    {$region AMD_occlusion_query_event}
    
    public z_QueryObjectParameteruiAMD: procedure(target: DummyEnum; id: UInt32; pname: DummyEnum; param: UInt32) := FuncPtrOrNil&<procedure(target: DummyEnum; id: UInt32; pname: DummyEnum; param: UInt32)>(GetGLProcAdr('glQueryObjectParameteruiAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryObjectParameteruiAMD(target: DummyEnum; id: UInt32; pname: DummyEnum; param: UInt32) := z_QueryObjectParameteruiAMD(target, id, pname, param);
    
    {$endregion AMD_occlusion_query_event}
    
    {$region AMD_performance_monitor}
    
    public z_GetPerfMonitorGroupsAMD: procedure(numGroups: pointer; groupsSize: Int32; groups: pointer) := FuncPtrOrNil&<procedure(numGroups: pointer; groupsSize: Int32; groups: pointer)>(GetGLProcAdr('glGetPerfMonitorGroupsAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: array of Int32; groupsSize: Int32; groups: array of UInt32) := GetPerfMonitorGroupsAMD(numGroups[0], groupsSize, groups[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: array of Int32; groupsSize: Int32; var groups: UInt32) := GetPerfMonitorGroupsAMD(numGroups[0], groupsSize, @groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: array of Int32; groupsSize: Int32; groups: pointer) := GetPerfMonitorGroupsAMD(numGroups[0], groupsSize, groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(var numGroups: Int32; groupsSize: Int32; groups: array of UInt32) := GetPerfMonitorGroupsAMD(@numGroups, groupsSize, groups[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(var numGroups: Int32; groupsSize: Int32; var groups: UInt32) := GetPerfMonitorGroupsAMD(@numGroups, groupsSize, @groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(var numGroups: Int32; groupsSize: Int32; groups: pointer) := GetPerfMonitorGroupsAMD(@numGroups, groupsSize, groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: pointer; groupsSize: Int32; groups: array of UInt32) := GetPerfMonitorGroupsAMD(numGroups, groupsSize, groups[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: pointer; groupsSize: Int32; var groups: UInt32) := GetPerfMonitorGroupsAMD(numGroups, groupsSize, @groups);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupsAMD(numGroups: pointer; groupsSize: Int32; groups: pointer) := z_GetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
    
    public z_GetPerfMonitorCountersAMD: procedure(group: UInt32; numCounters: pointer; maxActiveCounters: pointer; counterSize: Int32; counters: pointer) := FuncPtrOrNil&<procedure(group: UInt32; numCounters: pointer; maxActiveCounters: pointer; counterSize: Int32; counters: pointer)>(GetGLProcAdr('glGetPerfMonitorCountersAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: array of Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters[0], counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: array of Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters[0], counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: array of Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters[0], counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], @maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], @maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, numCounters[0], @maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: pointer; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: pointer; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: array of Int32; maxActiveCounters: pointer; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, numCounters[0], maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: array of Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters[0], counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: array of Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters[0], counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: array of Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters[0], counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, @maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, @maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; var maxActiveCounters: Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, @numCounters, @maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: pointer; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: pointer; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; var numCounters: Int32; maxActiveCounters: pointer; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, @numCounters, maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: array of Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters[0], counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: array of Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters[0], counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: array of Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters[0], counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; var maxActiveCounters: Int32; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters, @maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; var maxActiveCounters: Int32; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters, @maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; var maxActiveCounters: Int32; counterSize: Int32; counters: pointer) := GetPerfMonitorCountersAMD(group, numCounters, @maxActiveCounters, counterSize, counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: pointer; counterSize: Int32; counters: array of UInt32) := GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: pointer; counterSize: Int32; var counters: UInt32) := GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, @counters);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCountersAMD(group: UInt32; numCounters: pointer; maxActiveCounters: pointer; counterSize: Int32; counters: pointer) := z_GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
    
    public z_GetPerfMonitorGroupStringAMD: procedure(group: UInt32; bufSize: Int32; length: pointer; groupString: IntPtr) := FuncPtrOrNil&<procedure(group: UInt32; bufSize: Int32; length: pointer; groupString: IntPtr)>(GetGLProcAdr('glGetPerfMonitorGroupStringAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: array of Int32; groupString: string); begin var ptr4 := Marshal.StringToHGlobalAnsi(groupString); GetPerfMonitorGroupStringAMD(group, bufSize, length[0], ptr4); groupString := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: array of Int32; groupString: IntPtr) := GetPerfMonitorGroupStringAMD(group, bufSize, length[0], groupString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; var length: Int32; groupString: string); begin var ptr4 := Marshal.StringToHGlobalAnsi(groupString); GetPerfMonitorGroupStringAMD(group, bufSize, @length, ptr4); groupString := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; var length: Int32; groupString: IntPtr) := GetPerfMonitorGroupStringAMD(group, bufSize, @length, groupString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: pointer; groupString: string); begin var ptr4 := Marshal.StringToHGlobalAnsi(groupString); GetPerfMonitorGroupStringAMD(group, bufSize, length, ptr4); groupString := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorGroupStringAMD(group: UInt32; bufSize: Int32; length: pointer; groupString: IntPtr) := z_GetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
    
    public z_GetPerfMonitorCounterStringAMD: procedure(group: UInt32; counter: UInt32; bufSize: Int32; length: pointer; counterString: IntPtr) := FuncPtrOrNil&<procedure(group: UInt32; counter: UInt32; bufSize: Int32; length: pointer; counterString: IntPtr)>(GetGLProcAdr('glGetPerfMonitorCounterStringAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: array of Int32; counterString: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(counterString); GetPerfMonitorCounterStringAMD(group, counter, bufSize, length[0], ptr5); counterString := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: array of Int32; counterString: IntPtr) := GetPerfMonitorCounterStringAMD(group, counter, bufSize, length[0], counterString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; var length: Int32; counterString: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(counterString); GetPerfMonitorCounterStringAMD(group, counter, bufSize, @length, ptr5); counterString := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; var length: Int32; counterString: IntPtr) := GetPerfMonitorCounterStringAMD(group, counter, bufSize, @length, counterString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: pointer; counterString: string); begin var ptr5 := Marshal.StringToHGlobalAnsi(counterString); GetPerfMonitorCounterStringAMD(group, counter, bufSize, length, ptr5); counterString := Marshal.PtrToStringAnsi(ptr5); Marshal.FreeHGlobal(ptr5); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterStringAMD(group: UInt32; counter: UInt32; bufSize: Int32; length: pointer; counterString: IntPtr) := z_GetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
    
    public z_GetPerfMonitorCounterInfoAMD: procedure(group: UInt32; counter: UInt32; pname: DummyEnum; data: pointer) := FuncPtrOrNil&<procedure(group: UInt32; counter: UInt32; pname: DummyEnum; data: pointer)>(GetGLProcAdr('glGetPerfMonitorCounterInfoAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterInfoAMD(group: UInt32; counter: UInt32; pname: DummyEnum; data: pointer) := z_GetPerfMonitorCounterInfoAMD(group, counter, pname, data);
    
    public z_GenPerfMonitorsAMD: procedure(n: Int32; monitors: pointer) := FuncPtrOrNil&<procedure(n: Int32; monitors: pointer)>(GetGLProcAdr('glGenPerfMonitorsAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; monitors: array of UInt32) := GenPerfMonitorsAMD(n, monitors[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; var monitors: UInt32) := GenPerfMonitorsAMD(n, @monitors);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenPerfMonitorsAMD(n: Int32; monitors: pointer) := z_GenPerfMonitorsAMD(n, monitors);
    
    public z_DeletePerfMonitorsAMD: procedure(n: Int32; monitors: pointer) := FuncPtrOrNil&<procedure(n: Int32; monitors: pointer)>(GetGLProcAdr('glDeletePerfMonitorsAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; monitors: array of UInt32) := DeletePerfMonitorsAMD(n, monitors[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; var monitors: UInt32) := DeletePerfMonitorsAMD(n, @monitors);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfMonitorsAMD(n: Int32; monitors: pointer) := z_DeletePerfMonitorsAMD(n, monitors);
    
    public z_SelectPerfMonitorCountersAMD: procedure(monitor: UInt32; enable: Byte; group: UInt32; numCounters: Int32; counterList: pointer) := FuncPtrOrNil&<procedure(monitor: UInt32; enable: Byte; group: UInt32; numCounters: Int32; counterList: pointer)>(GetGLProcAdr('glSelectPerfMonitorCountersAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: Byte; group: UInt32; numCounters: Int32; counterList: array of UInt32) := SelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: Byte; group: UInt32; numCounters: Int32; var counterList: UInt32) := SelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, @counterList);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectPerfMonitorCountersAMD(monitor: UInt32; enable: Byte; group: UInt32; numCounters: Int32; counterList: pointer) := z_SelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
    
    public z_BeginPerfMonitorAMD: procedure(monitor: UInt32) := FuncPtrOrNil&<procedure(monitor: UInt32)>(GetGLProcAdr('glBeginPerfMonitorAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginPerfMonitorAMD(monitor: UInt32) := z_BeginPerfMonitorAMD(monitor);
    
    public z_EndPerfMonitorAMD: procedure(monitor: UInt32) := FuncPtrOrNil&<procedure(monitor: UInt32)>(GetGLProcAdr('glEndPerfMonitorAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndPerfMonitorAMD(monitor: UInt32) := z_EndPerfMonitorAMD(monitor);
    
    public z_GetPerfMonitorCounterDataAMD: procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: pointer; bytesWritten: pointer) := FuncPtrOrNil&<procedure(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: pointer; bytesWritten: pointer)>(GetGLProcAdr('glGetPerfMonitorCounterDataAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: array of UInt32; bytesWritten: array of Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data[0], bytesWritten[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: array of UInt32; var bytesWritten: Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data[0], @bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: array of UInt32; bytesWritten: pointer) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data[0], bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; bytesWritten: array of Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, @data, bytesWritten[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; var bytesWritten: Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, @data, @bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; var data: UInt32; bytesWritten: pointer) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, @data, bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: pointer; bytesWritten: array of Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: pointer; var bytesWritten: Int32) := GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, @bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfMonitorCounterDataAMD(monitor: UInt32; pname: DummyEnum; dataSize: Int32; data: pointer; bytesWritten: pointer) := z_GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
    
    {$endregion AMD_performance_monitor}
    
    {$region AMD_sample_positions}
    
    public z_SetMultisamplefvAMD: procedure(pname: DummyEnum; index: UInt32; val: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; index: UInt32; val: pointer)>(GetGLProcAdr('glSetMultisamplefvAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; val: array of single) := SetMultisamplefvAMD(pname, index, val[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; var val: single) := SetMultisamplefvAMD(pname, index, @val);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetMultisamplefvAMD(pname: DummyEnum; index: UInt32; val: pointer) := z_SetMultisamplefvAMD(pname, index, val);
    
    {$endregion AMD_sample_positions}
    
    {$region AMD_stencil_operation_extended}
    
    public z_StencilOpValueAMD: procedure(face: DummyEnum; value: UInt32) := FuncPtrOrNil&<procedure(face: DummyEnum; value: UInt32)>(GetGLProcAdr('glStencilOpValueAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilOpValueAMD(face: DummyEnum; value: UInt32) := z_StencilOpValueAMD(face, value);
    
    {$endregion AMD_stencil_operation_extended}
    
    {$region AMD_vertex_shader_tessellator}
    
    public z_TessellationFactorAMD: procedure(factor: single) := FuncPtrOrNil&<procedure(factor: single)>(GetGLProcAdr('glTessellationFactorAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TessellationFactorAMD(factor: single) := z_TessellationFactorAMD(factor);
    
    public z_TessellationModeAMD: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glTessellationModeAMD'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TessellationModeAMD(mode: DummyEnum) := z_TessellationModeAMD(mode);
    
    {$endregion AMD_vertex_shader_tessellator}
    
  end;
  
  gl_ANGLE = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region ANGLE_translated_shader_source}
    
    public z_GetTranslatedShaderSourceANGLE: procedure(shader: UInt32; bufsize: Int32; length: pointer; source: IntPtr) := FuncPtrOrNil&<procedure(shader: UInt32; bufsize: Int32; length: pointer; source: IntPtr)>(GetGLProcAdr('glGetTranslatedShaderSourceANGLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; length: array of Int32; source: string); begin var ptr4 := Marshal.StringToHGlobalAnsi(source); GetTranslatedShaderSourceANGLE(shader, bufsize, length[0], ptr4); source := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; length: array of Int32; source: IntPtr) := GetTranslatedShaderSourceANGLE(shader, bufsize, length[0], source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; var length: Int32; source: string); begin var ptr4 := Marshal.StringToHGlobalAnsi(source); GetTranslatedShaderSourceANGLE(shader, bufsize, @length, ptr4); source := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; var length: Int32; source: IntPtr) := GetTranslatedShaderSourceANGLE(shader, bufsize, @length, source);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; length: pointer; source: string); begin var ptr4 := Marshal.StringToHGlobalAnsi(source); GetTranslatedShaderSourceANGLE(shader, bufsize, length, ptr4); source := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTranslatedShaderSourceANGLE(shader: UInt32; bufsize: Int32; length: pointer; source: IntPtr) := z_GetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
    
    {$endregion ANGLE_translated_shader_source}
    
  end;
  
  gl_APPLE = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region APPLE_copy_texture_levels}
    
    public z_CopyTextureLevelsAPPLE: procedure(destinationTexture: UInt32; sourceTexture: UInt32; sourceBaseLevel: Int32; sourceLevelCount: Int32) := FuncPtrOrNil&<procedure(destinationTexture: UInt32; sourceTexture: UInt32; sourceBaseLevel: Int32; sourceLevelCount: Int32)>(GetGLProcAdr('glCopyTextureLevelsAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyTextureLevelsAPPLE(destinationTexture: UInt32; sourceTexture: UInt32; sourceBaseLevel: Int32; sourceLevelCount: Int32) := z_CopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
    
    {$endregion APPLE_copy_texture_levels}
    
    {$region APPLE_element_array}
    
    public z_MultiDrawElementArrayAPPLE: procedure(mode: DummyEnum; first: pointer; count: pointer; primcount: Int32) := FuncPtrOrNil&<procedure(mode: DummyEnum; first: pointer; count: pointer; primcount: Int32)>(GetGLProcAdr('glMultiDrawElementArrayAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: array of Int32; count: array of Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, first[0], count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: array of Int32; var count: Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, first[0], @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: array of Int32; count: pointer; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, first[0], count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; var first: Int32; count: array of Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, @first, count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; var first: Int32; var count: Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, @first, @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; var first: Int32; count: pointer; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, @first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: pointer; count: array of Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, first, count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: pointer; var count: Int32; primcount: Int32) := MultiDrawElementArrayAPPLE(mode, first, @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementArrayAPPLE(mode: DummyEnum; first: pointer; count: pointer; primcount: Int32) := z_MultiDrawElementArrayAPPLE(mode, first, count, primcount);
    
    public z_MultiDrawRangeElementArrayAPPLE: procedure(mode: DummyEnum; start: UInt32; &end: UInt32; first: pointer; count: pointer; primcount: Int32) := FuncPtrOrNil&<procedure(mode: DummyEnum; start: UInt32; &end: UInt32; first: pointer; count: pointer; primcount: Int32)>(GetGLProcAdr('glMultiDrawRangeElementArrayAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: array of Int32; count: array of Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, first[0], count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: array of Int32; var count: Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, first[0], @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: array of Int32; count: pointer; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, first[0], count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; var first: Int32; count: array of Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, @first, count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; var first: Int32; var count: Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, @first, @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; var first: Int32; count: pointer; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, @first, count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: pointer; count: array of Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, first, count[0], primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: pointer; var count: Int32; primcount: Int32) := MultiDrawRangeElementArrayAPPLE(mode, start, &end, first, @count, primcount);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: pointer; count: pointer; primcount: Int32) := z_MultiDrawRangeElementArrayAPPLE(mode, start, &end, first, count, primcount);
    
    {$endregion APPLE_element_array}
    
    {$region APPLE_fence}
    
    public z_TestObjectAPPLE: function(object: DummyEnum; name: UInt32): Byte := FuncPtrOrNil&<function(object: DummyEnum; name: UInt32): Byte>(GetGLProcAdr('glTestObjectAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestObjectAPPLE(object: DummyEnum; name: UInt32): Byte := z_TestObjectAPPLE(object, name);
    
    public z_FinishObjectAPPLE: procedure(object: DummyEnum; name: Int32) := FuncPtrOrNil&<procedure(object: DummyEnum; name: Int32)>(GetGLProcAdr('glFinishObjectAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishObjectAPPLE(object: DummyEnum; name: Int32) := z_FinishObjectAPPLE(object, name);
    
    {$endregion APPLE_fence}
    
    {$region APPLE_flush_buffer_range}
    
    public z_BufferParameteriAPPLE: procedure(target: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glBufferParameteriAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferParameteriAPPLE(target: DummyEnum; pname: DummyEnum; param: Int32) := z_BufferParameteriAPPLE(target, pname, param);
    
    {$endregion APPLE_flush_buffer_range}
    
    {$region APPLE_framebuffer_multisample}
    
    public z_ResolveMultisampleFramebufferAPPLE: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glResolveMultisampleFramebufferAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResolveMultisampleFramebufferAPPLE := z_ResolveMultisampleFramebufferAPPLE();
    
    {$endregion APPLE_framebuffer_multisample}
    
    {$region APPLE_object_purgeable}
    
    public z_ObjectPurgeableAPPLE: function(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum := FuncPtrOrNil&<function(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum>(GetGLProcAdr('glObjectPurgeableAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ObjectPurgeableAPPLE(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum := z_ObjectPurgeableAPPLE(objectType, name, option);
    
    public z_ObjectUnpurgeableAPPLE: function(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum := FuncPtrOrNil&<function(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum>(GetGLProcAdr('glObjectUnpurgeableAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ObjectUnpurgeableAPPLE(objectType: DummyEnum; name: UInt32; option: DummyEnum): DummyEnum := z_ObjectUnpurgeableAPPLE(objectType, name, option);
    
    {$endregion APPLE_object_purgeable}
    
    {$region APPLE_texture_range}
    
    public z_TextureRangeAPPLE: procedure(target: DummyEnum; length: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; length: Int32; _pointer: pointer)>(GetGLProcAdr('glTextureRangeAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureRangeAPPLE(target: DummyEnum; length: Int32; _pointer: pointer) := z_TextureRangeAPPLE(target, length, _pointer);
    
    public z_GetTexParameterPointervAPPLE: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetTexParameterPointervAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterPointervAPPLE(target: DummyEnum; pname: DummyEnum; &params: array of IntPtr) := GetTexParameterPointervAPPLE(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterPointervAPPLE(target: DummyEnum; pname: DummyEnum; var &params: IntPtr) := GetTexParameterPointervAPPLE(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterPointervAPPLE(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexParameterPointervAPPLE(target, pname, &params);
    
    {$endregion APPLE_texture_range}
    
    {$region APPLE_vertex_array_range}
    
    public z_VertexArrayParameteriAPPLE: procedure(pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: Int32)>(GetGLProcAdr('glVertexArrayParameteriAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayParameteriAPPLE(pname: DummyEnum; param: Int32) := z_VertexArrayParameteriAPPLE(pname, param);
    
    {$endregion APPLE_vertex_array_range}
    
    {$region APPLE_vertex_program_evaluators}
    
    public z_EnableVertexAttribAPPLE: procedure(index: UInt32; pname: DummyEnum) := FuncPtrOrNil&<procedure(index: UInt32; pname: DummyEnum)>(GetGLProcAdr('glEnableVertexAttribAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableVertexAttribAPPLE(index: UInt32; pname: DummyEnum) := z_EnableVertexAttribAPPLE(index, pname);
    
    public z_DisableVertexAttribAPPLE: procedure(index: UInt32; pname: DummyEnum) := FuncPtrOrNil&<procedure(index: UInt32; pname: DummyEnum)>(GetGLProcAdr('glDisableVertexAttribAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableVertexAttribAPPLE(index: UInt32; pname: DummyEnum) := z_DisableVertexAttribAPPLE(index, pname);
    
    public z_IsVertexAttribEnabledAPPLE: function(index: UInt32; pname: DummyEnum): Byte := FuncPtrOrNil&<function(index: UInt32; pname: DummyEnum): Byte>(GetGLProcAdr('glIsVertexAttribEnabledAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsVertexAttribEnabledAPPLE(index: UInt32; pname: DummyEnum): Byte := z_IsVertexAttribEnabledAPPLE(index, pname);
    
    public z_MapVertexAttrib1dAPPLE: procedure(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: pointer) := FuncPtrOrNil&<procedure(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: pointer)>(GetGLProcAdr('glMapVertexAttrib1dAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: array of double) := MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; var points: double) := MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; stride: Int32; order: Int32; points: pointer) := z_MapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
    
    public z_MapVertexAttrib1fAPPLE: procedure(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: pointer) := FuncPtrOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: pointer)>(GetGLProcAdr('glMapVertexAttrib1fAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: array of single) := MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; var points: single) := MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib1fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; stride: Int32; order: Int32; points: pointer) := z_MapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
    
    public z_MapVertexAttrib2dAPPLE: procedure(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: pointer) := FuncPtrOrNil&<procedure(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: pointer)>(GetGLProcAdr('glMapVertexAttrib2dAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: array of double) := MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; var points: double) := MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2dAPPLE(index: UInt32; size: UInt32; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; points: pointer) := z_MapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    public z_MapVertexAttrib2fAPPLE: procedure(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: pointer) := FuncPtrOrNil&<procedure(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: pointer)>(GetGLProcAdr('glMapVertexAttrib2fAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: array of single) := MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; var points: single) := MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapVertexAttrib2fAPPLE(index: UInt32; size: UInt32; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; points: pointer) := z_MapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    {$endregion APPLE_vertex_program_evaluators}
    
    {$region APPLE_element_array, ATI_element_array}
    
    public z_ElementPointerAPPLE: procedure(&type: DummyEnum; _pointer: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; _pointer: pointer)>(GetGLProcAdr('glElementPointerAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ElementPointerAPPLE(&type: DummyEnum; _pointer: pointer) := z_ElementPointerAPPLE(&type, _pointer);
    
    public z_DrawElementArrayAPPLE: procedure(mode: DummyEnum; first: Int32; count: Int32) := FuncPtrOrNil&<procedure(mode: DummyEnum; first: Int32; count: Int32)>(GetGLProcAdr('glDrawElementArrayAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawElementArrayAPPLE(mode: DummyEnum; first: Int32; count: Int32) := z_DrawElementArrayAPPLE(mode, first, count);
    
    public z_DrawRangeElementArrayAPPLE: procedure(mode: DummyEnum; start: UInt32; &end: UInt32; first: Int32; count: Int32) := FuncPtrOrNil&<procedure(mode: DummyEnum; start: UInt32; &end: UInt32; first: Int32; count: Int32)>(GetGLProcAdr('glDrawRangeElementArrayAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawRangeElementArrayAPPLE(mode: DummyEnum; start: UInt32; &end: UInt32; first: Int32; count: Int32) := z_DrawRangeElementArrayAPPLE(mode, start, &end, first, count);
    
    {$endregion APPLE_element_array, ATI_element_array}
    
    {$region APPLE_fence, NV_fence}
    
    public z_GenFencesAPPLE: procedure(n: Int32; fences: pointer) := FuncPtrOrNil&<procedure(n: Int32; fences: pointer)>(GetGLProcAdr('glGenFencesAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; fences: array of UInt32) := GenFencesAPPLE(n, fences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; var fences: UInt32) := GenFencesAPPLE(n, @fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenFencesAPPLE(n: Int32; fences: pointer) := z_GenFencesAPPLE(n, fences);
    
    public z_DeleteFencesAPPLE: procedure(n: Int32; fences: pointer) := FuncPtrOrNil&<procedure(n: Int32; fences: pointer)>(GetGLProcAdr('glDeleteFencesAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; fences: array of UInt32) := DeleteFencesAPPLE(n, fences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; var fences: UInt32) := DeleteFencesAPPLE(n, @fences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFencesAPPLE(n: Int32; fences: pointer) := z_DeleteFencesAPPLE(n, fences);
    
    public z_SetFenceAPPLE: procedure(fence: UInt32) := FuncPtrOrNil&<procedure(fence: UInt32)>(GetGLProcAdr('glSetFenceAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFenceAPPLE(fence: UInt32) := z_SetFenceAPPLE(fence);
    
    public z_IsFenceAPPLE: function(fence: UInt32): Byte := FuncPtrOrNil&<function(fence: UInt32): Byte>(GetGLProcAdr('glIsFenceAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsFenceAPPLE(fence: UInt32): Byte := z_IsFenceAPPLE(fence);
    
    public z_TestFenceAPPLE: function(fence: UInt32): Byte := FuncPtrOrNil&<function(fence: UInt32): Byte>(GetGLProcAdr('glTestFenceAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function TestFenceAPPLE(fence: UInt32): Byte := z_TestFenceAPPLE(fence);
    
    public z_FinishFenceAPPLE: procedure(fence: UInt32) := FuncPtrOrNil&<procedure(fence: UInt32)>(GetGLProcAdr('glFinishFenceAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishFenceAPPLE(fence: UInt32) := z_FinishFenceAPPLE(fence);
    
    {$endregion APPLE_fence, NV_fence}
    
    {$region APPLE_vertex_array_range, NV_vertex_array_range}
    
    public z_VertexArrayRangeAPPLE: procedure(length: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(length: Int32; _pointer: pointer)>(GetGLProcAdr('glVertexArrayRangeAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexArrayRangeAPPLE(length: Int32; _pointer: pointer) := z_VertexArrayRangeAPPLE(length, _pointer);
    
    public z_FlushVertexArrayRangeAPPLE: procedure(length: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(length: Int32; _pointer: pointer)>(GetGLProcAdr('glFlushVertexArrayRangeAPPLE'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushVertexArrayRangeAPPLE(length: Int32; _pointer: pointer) := z_FlushVertexArrayRangeAPPLE(length, _pointer);
    
    {$endregion APPLE_vertex_array_range, NV_vertex_array_range}
    
  end;
  
  gl_ATI = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region ATI_envmap_bumpmap}
    
    public z_TexBumpParameterivATI: procedure(pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: pointer)>(GetGLProcAdr('glTexBumpParameterivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: DummyEnum; param: array of Int32) := TexBumpParameterivATI(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: DummyEnum; var param: Int32) := TexBumpParameterivATI(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterivATI(pname: DummyEnum; param: pointer) := z_TexBumpParameterivATI(pname, param);
    
    public z_TexBumpParameterfvATI: procedure(pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: pointer)>(GetGLProcAdr('glTexBumpParameterfvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: DummyEnum; param: array of single) := TexBumpParameterfvATI(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: DummyEnum; var param: single) := TexBumpParameterfvATI(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexBumpParameterfvATI(pname: DummyEnum; param: pointer) := z_TexBumpParameterfvATI(pname, param);
    
    public z_GetTexBumpParameterivATI: procedure(pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: pointer)>(GetGLProcAdr('glGetTexBumpParameterivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterivATI(pname: DummyEnum; param: array of Int32) := GetTexBumpParameterivATI(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterivATI(pname: DummyEnum; var param: Int32) := GetTexBumpParameterivATI(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterivATI(pname: DummyEnum; param: pointer) := z_GetTexBumpParameterivATI(pname, param);
    
    public z_GetTexBumpParameterfvATI: procedure(pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: pointer)>(GetGLProcAdr('glGetTexBumpParameterfvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterfvATI(pname: DummyEnum; param: array of single) := GetTexBumpParameterfvATI(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterfvATI(pname: DummyEnum; var param: single) := GetTexBumpParameterfvATI(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexBumpParameterfvATI(pname: DummyEnum; param: pointer) := z_GetTexBumpParameterfvATI(pname, param);
    
    {$endregion ATI_envmap_bumpmap}
    
    {$region ATI_fragment_shader}
    
    public z_GenFragmentShadersATI: function(range: UInt32): UInt32 := FuncPtrOrNil&<function(range: UInt32): UInt32>(GetGLProcAdr('glGenFragmentShadersATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenFragmentShadersATI(range: UInt32): UInt32 := z_GenFragmentShadersATI(range);
    
    public z_BindFragmentShaderATI: procedure(id: UInt32) := FuncPtrOrNil&<procedure(id: UInt32)>(GetGLProcAdr('glBindFragmentShaderATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindFragmentShaderATI(id: UInt32) := z_BindFragmentShaderATI(id);
    
    public z_DeleteFragmentShaderATI: procedure(id: UInt32) := FuncPtrOrNil&<procedure(id: UInt32)>(GetGLProcAdr('glDeleteFragmentShaderATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteFragmentShaderATI(id: UInt32) := z_DeleteFragmentShaderATI(id);
    
    public z_BeginFragmentShaderATI: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glBeginFragmentShaderATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginFragmentShaderATI := z_BeginFragmentShaderATI();
    
    public z_EndFragmentShaderATI: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glEndFragmentShaderATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndFragmentShaderATI := z_EndFragmentShaderATI();
    
    public z_PassTexCoordATI: procedure(dst: UInt32; coord: UInt32; swizzle: DummyEnum) := FuncPtrOrNil&<procedure(dst: UInt32; coord: UInt32; swizzle: DummyEnum)>(GetGLProcAdr('glPassTexCoordATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassTexCoordATI(dst: UInt32; coord: UInt32; swizzle: DummyEnum) := z_PassTexCoordATI(dst, coord, swizzle);
    
    public z_SampleMapATI: procedure(dst: UInt32; interp: UInt32; swizzle: DummyEnum) := FuncPtrOrNil&<procedure(dst: UInt32; interp: UInt32; swizzle: DummyEnum)>(GetGLProcAdr('glSampleMapATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMapATI(dst: UInt32; interp: UInt32; swizzle: DummyEnum) := z_SampleMapATI(dst, interp, swizzle);
    
    public z_ColorFragmentOp1ATI: procedure(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32) := FuncPtrOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32)>(GetGLProcAdr('glColorFragmentOp1ATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp1ATI(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32) := z_ColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
    
    public z_ColorFragmentOp2ATI: procedure(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32) := FuncPtrOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32)>(GetGLProcAdr('glColorFragmentOp2ATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp2ATI(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32) := z_ColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    
    public z_ColorFragmentOp3ATI: procedure(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32) := FuncPtrOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32)>(GetGLProcAdr('glColorFragmentOp3ATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFragmentOp3ATI(op: DummyEnum; dst: UInt32; dstMask: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32) := z_ColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    
    public z_AlphaFragmentOp1ATI: procedure(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32) := FuncPtrOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32)>(GetGLProcAdr('glAlphaFragmentOp1ATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp1ATI(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32) := z_AlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
    
    public z_AlphaFragmentOp2ATI: procedure(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32) := FuncPtrOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32)>(GetGLProcAdr('glAlphaFragmentOp2ATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp2ATI(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32) := z_AlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
    
    public z_AlphaFragmentOp3ATI: procedure(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32) := FuncPtrOrNil&<procedure(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32)>(GetGLProcAdr('glAlphaFragmentOp3ATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFragmentOp3ATI(op: DummyEnum; dst: UInt32; dstMod: UInt32; arg1: UInt32; arg1Rep: UInt32; arg1Mod: UInt32; arg2: UInt32; arg2Rep: UInt32; arg2Mod: UInt32; arg3: UInt32; arg3Rep: UInt32; arg3Mod: UInt32) := z_AlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
    
    public z_SetFragmentShaderConstantATI: procedure(dst: UInt32; value: pointer) := FuncPtrOrNil&<procedure(dst: UInt32; value: pointer)>(GetGLProcAdr('glSetFragmentShaderConstantATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: UInt32; value: array of single) := SetFragmentShaderConstantATI(dst, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: UInt32; var value: single) := SetFragmentShaderConstantATI(dst, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SetFragmentShaderConstantATI(dst: UInt32; value: pointer) := z_SetFragmentShaderConstantATI(dst, value);
    
    {$endregion ATI_fragment_shader}
    
    {$region ATI_map_object_buffer}
    
    public z_MapObjectBufferATI: function(buffer: UInt32): pointer := FuncPtrOrNil&<function(buffer: UInt32): pointer>(GetGLProcAdr('glMapObjectBufferATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapObjectBufferATI(buffer: UInt32): pointer := z_MapObjectBufferATI(buffer);
    
    public z_UnmapObjectBufferATI: procedure(buffer: UInt32) := FuncPtrOrNil&<procedure(buffer: UInt32)>(GetGLProcAdr('glUnmapObjectBufferATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnmapObjectBufferATI(buffer: UInt32) := z_UnmapObjectBufferATI(buffer);
    
    {$endregion ATI_map_object_buffer}
    
    {$region ATI_pn_triangles}
    
    public z_PNTrianglesiATI: procedure(pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: Int32)>(GetGLProcAdr('glPNTrianglesiATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PNTrianglesiATI(pname: DummyEnum; param: Int32) := z_PNTrianglesiATI(pname, param);
    
    public z_PNTrianglesfATI: procedure(pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: single)>(GetGLProcAdr('glPNTrianglesfATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PNTrianglesfATI(pname: DummyEnum; param: single) := z_PNTrianglesfATI(pname, param);
    
    {$endregion ATI_pn_triangles}
    
    {$region ATI_vertex_array_object}
    
    public z_NewObjectBufferATI: function(size: Int32; _pointer: pointer; usage: DummyEnum): UInt32 := FuncPtrOrNil&<function(size: Int32; _pointer: pointer; usage: DummyEnum): UInt32>(GetGLProcAdr('glNewObjectBufferATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function NewObjectBufferATI(size: Int32; _pointer: pointer; usage: DummyEnum): UInt32 := z_NewObjectBufferATI(size, _pointer, usage);
    
    public z_IsObjectBufferATI: function(buffer: UInt32): Byte := FuncPtrOrNil&<function(buffer: UInt32): Byte>(GetGLProcAdr('glIsObjectBufferATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsObjectBufferATI(buffer: UInt32): Byte := z_IsObjectBufferATI(buffer);
    
    public z_UpdateObjectBufferATI: procedure(buffer: UInt32; offset: UInt32; size: Int32; _pointer: pointer; preserve: DummyEnum) := FuncPtrOrNil&<procedure(buffer: UInt32; offset: UInt32; size: Int32; _pointer: pointer; preserve: DummyEnum)>(GetGLProcAdr('glUpdateObjectBufferATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UpdateObjectBufferATI(buffer: UInt32; offset: UInt32; size: Int32; _pointer: pointer; preserve: DummyEnum) := z_UpdateObjectBufferATI(buffer, offset, size, _pointer, preserve);
    
    public z_GetObjectBufferfvATI: procedure(buffer: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(buffer: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetObjectBufferfvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferfvATI(buffer: UInt32; pname: DummyEnum; &params: array of single) := GetObjectBufferfvATI(buffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferfvATI(buffer: UInt32; pname: DummyEnum; var &params: single) := GetObjectBufferfvATI(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferfvATI(buffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetObjectBufferfvATI(buffer, pname, &params);
    
    public z_GetObjectBufferivATI: procedure(buffer: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(buffer: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetObjectBufferivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferivATI(buffer: UInt32; pname: DummyEnum; &params: array of Int32) := GetObjectBufferivATI(buffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferivATI(buffer: UInt32; pname: DummyEnum; var &params: Int32) := GetObjectBufferivATI(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetObjectBufferivATI(buffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetObjectBufferivATI(buffer, pname, &params);
    
    public z_FreeObjectBufferATI: procedure(buffer: UInt32) := FuncPtrOrNil&<procedure(buffer: UInt32)>(GetGLProcAdr('glFreeObjectBufferATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FreeObjectBufferATI(buffer: UInt32) := z_FreeObjectBufferATI(buffer);
    
    public z_ArrayObjectATI: procedure(&array: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; buffer: UInt32; offset: UInt32) := FuncPtrOrNil&<procedure(&array: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; buffer: UInt32; offset: UInt32)>(GetGLProcAdr('glArrayObjectATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ArrayObjectATI(&array: DummyEnum; size: Int32; &type: DummyEnum; stride: Int32; buffer: UInt32; offset: UInt32) := z_ArrayObjectATI(&array, size, &type, stride, buffer, offset);
    
    public z_GetArrayObjectfvATI: procedure(&array: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(&array: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetArrayObjectfvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectfvATI(&array: DummyEnum; pname: DummyEnum; &params: array of single) := GetArrayObjectfvATI(&array, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectfvATI(&array: DummyEnum; pname: DummyEnum; var &params: single) := GetArrayObjectfvATI(&array, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectfvATI(&array: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetArrayObjectfvATI(&array, pname, &params);
    
    public z_GetArrayObjectivATI: procedure(&array: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(&array: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetArrayObjectivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectivATI(&array: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetArrayObjectivATI(&array, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectivATI(&array: DummyEnum; pname: DummyEnum; var &params: Int32) := GetArrayObjectivATI(&array, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetArrayObjectivATI(&array: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetArrayObjectivATI(&array, pname, &params);
    
    public z_VariantArrayObjectATI: procedure(id: UInt32; &type: DummyEnum; stride: Int32; buffer: UInt32; offset: UInt32) := FuncPtrOrNil&<procedure(id: UInt32; &type: DummyEnum; stride: Int32; buffer: UInt32; offset: UInt32)>(GetGLProcAdr('glVariantArrayObjectATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VariantArrayObjectATI(id: UInt32; &type: DummyEnum; stride: Int32; buffer: UInt32; offset: UInt32) := z_VariantArrayObjectATI(id, &type, stride, buffer, offset);
    
    public z_GetVariantArrayObjectfvATI: procedure(id: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVariantArrayObjectfvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectfvATI(id: UInt32; pname: DummyEnum; &params: array of single) := GetVariantArrayObjectfvATI(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectfvATI(id: UInt32; pname: DummyEnum; var &params: single) := GetVariantArrayObjectfvATI(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectfvATI(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetVariantArrayObjectfvATI(id, pname, &params);
    
    public z_GetVariantArrayObjectivATI: procedure(id: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVariantArrayObjectivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectivATI(id: UInt32; pname: DummyEnum; &params: array of Int32) := GetVariantArrayObjectivATI(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectivATI(id: UInt32; pname: DummyEnum; var &params: Int32) := GetVariantArrayObjectivATI(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVariantArrayObjectivATI(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetVariantArrayObjectivATI(id, pname, &params);
    
    {$endregion ATI_vertex_array_object}
    
    {$region ATI_vertex_attrib_array_object}
    
    public z_VertexAttribArrayObjectATI: procedure(index: UInt32; size: Int32; &type: DummyEnum; normalized: Byte; stride: Int32; buffer: UInt32; offset: UInt32) := FuncPtrOrNil&<procedure(index: UInt32; size: Int32; &type: DummyEnum; normalized: Byte; stride: Int32; buffer: UInt32; offset: UInt32)>(GetGLProcAdr('glVertexAttribArrayObjectATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribArrayObjectATI(index: UInt32; size: Int32; &type: DummyEnum; normalized: Byte; stride: Int32; buffer: UInt32; offset: UInt32) := z_VertexAttribArrayObjectATI(index, size, &type, normalized, stride, buffer, offset);
    
    public z_GetVertexAttribArrayObjectfvATI: procedure(index: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVertexAttribArrayObjectfvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: DummyEnum; &params: array of single) := GetVertexAttribArrayObjectfvATI(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: DummyEnum; var &params: single) := GetVertexAttribArrayObjectfvATI(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectfvATI(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribArrayObjectfvATI(index, pname, &params);
    
    public z_GetVertexAttribArrayObjectivATI: procedure(index: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVertexAttribArrayObjectivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: DummyEnum; &params: array of Int32) := GetVertexAttribArrayObjectivATI(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: DummyEnum; var &params: Int32) := GetVertexAttribArrayObjectivATI(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribArrayObjectivATI(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribArrayObjectivATI(index, pname, &params);
    
    {$endregion ATI_vertex_attrib_array_object}
    
    {$region ATI_vertex_streams}
    
    public z_VertexStream1sATI: procedure(stream: DummyEnum; x: Int16) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: Int16)>(GetGLProcAdr('glVertexStream1sATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1sATI(stream: DummyEnum; x: Int16) := z_VertexStream1sATI(stream, x);
    
    public z_VertexStream1iATI: procedure(stream: DummyEnum; x: Int32) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: Int32)>(GetGLProcAdr('glVertexStream1iATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1iATI(stream: DummyEnum; x: Int32) := z_VertexStream1iATI(stream, x);
    
    public z_VertexStream1fATI: procedure(stream: DummyEnum; x: single) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: single)>(GetGLProcAdr('glVertexStream1fATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fATI(stream: DummyEnum; x: single) := z_VertexStream1fATI(stream, x);
    
    public z_VertexStream1dATI: procedure(stream: DummyEnum; x: double) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: double)>(GetGLProcAdr('glVertexStream1dATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dATI(stream: DummyEnum; x: double) := z_VertexStream1dATI(stream, x);
    
    public z_VertexStream2sATI: procedure(stream: DummyEnum; x: Int16; y: Int16) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: Int16; y: Int16)>(GetGLProcAdr('glVertexStream2sATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2sATI(stream: DummyEnum; x: Int16; y: Int16) := z_VertexStream2sATI(stream, x, y);
    
    public z_VertexStream2iATI: procedure(stream: DummyEnum; x: Int32; y: Int32) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: Int32; y: Int32)>(GetGLProcAdr('glVertexStream2iATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2iATI(stream: DummyEnum; x: Int32; y: Int32) := z_VertexStream2iATI(stream, x, y);
    
    public z_VertexStream2fATI: procedure(stream: DummyEnum; x: single; y: single) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: single; y: single)>(GetGLProcAdr('glVertexStream2fATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fATI(stream: DummyEnum; x: single; y: single) := z_VertexStream2fATI(stream, x, y);
    
    public z_VertexStream2dATI: procedure(stream: DummyEnum; x: double; y: double) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: double; y: double)>(GetGLProcAdr('glVertexStream2dATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dATI(stream: DummyEnum; x: double; y: double) := z_VertexStream2dATI(stream, x, y);
    
    public z_VertexStream3sATI: procedure(stream: DummyEnum; x: Int16; y: Int16; z: Int16) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: Int16; y: Int16; z: Int16)>(GetGLProcAdr('glVertexStream3sATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3sATI(stream: DummyEnum; x: Int16; y: Int16; z: Int16) := z_VertexStream3sATI(stream, x, y, z);
    
    public z_VertexStream3iATI: procedure(stream: DummyEnum; x: Int32; y: Int32; z: Int32) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: Int32; y: Int32; z: Int32)>(GetGLProcAdr('glVertexStream3iATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3iATI(stream: DummyEnum; x: Int32; y: Int32; z: Int32) := z_VertexStream3iATI(stream, x, y, z);
    
    public z_VertexStream3fATI: procedure(stream: DummyEnum; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: single; y: single; z: single)>(GetGLProcAdr('glVertexStream3fATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fATI(stream: DummyEnum; x: single; y: single; z: single) := z_VertexStream3fATI(stream, x, y, z);
    
    public z_VertexStream3dATI: procedure(stream: DummyEnum; x: double; y: double; z: double) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: double; y: double; z: double)>(GetGLProcAdr('glVertexStream3dATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dATI(stream: DummyEnum; x: double; y: double; z: double) := z_VertexStream3dATI(stream, x, y, z);
    
    public z_VertexStream4sATI: procedure(stream: DummyEnum; x: Int16; y: Int16; z: Int16; w: Int16) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: Int16; y: Int16; z: Int16; w: Int16)>(GetGLProcAdr('glVertexStream4sATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4sATI(stream: DummyEnum; x: Int16; y: Int16; z: Int16; w: Int16) := z_VertexStream4sATI(stream, x, y, z, w);
    
    public z_VertexStream4iATI: procedure(stream: DummyEnum; x: Int32; y: Int32; z: Int32; w: Int32) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: Int32; y: Int32; z: Int32; w: Int32)>(GetGLProcAdr('glVertexStream4iATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4iATI(stream: DummyEnum; x: Int32; y: Int32; z: Int32; w: Int32) := z_VertexStream4iATI(stream, x, y, z, w);
    
    public z_VertexStream4fATI: procedure(stream: DummyEnum; x: single; y: single; z: single; w: single) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: single; y: single; z: single; w: single)>(GetGLProcAdr('glVertexStream4fATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fATI(stream: DummyEnum; x: single; y: single; z: single; w: single) := z_VertexStream4fATI(stream, x, y, z, w);
    
    public z_VertexStream4dATI: procedure(stream: DummyEnum; x: double; y: double; z: double; w: double) := FuncPtrOrNil&<procedure(stream: DummyEnum; x: double; y: double; z: double; w: double)>(GetGLProcAdr('glVertexStream4dATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dATI(stream: DummyEnum; x: double; y: double; z: double; w: double) := z_VertexStream4dATI(stream, x, y, z, w);
    
    public z_VertexStream1svATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream1svATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: DummyEnum; coords: array of Int16) := VertexStream1svATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: DummyEnum; var coords: Int16) := VertexStream1svATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1svATI(stream: DummyEnum; coords: pointer) := z_VertexStream1svATI(stream, coords);
    
    public z_VertexStream1ivATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream1ivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: DummyEnum; coords: array of Int32) := VertexStream1ivATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: DummyEnum; var coords: Int32) := VertexStream1ivATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1ivATI(stream: DummyEnum; coords: pointer) := z_VertexStream1ivATI(stream, coords);
    
    public z_VertexStream1fvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream1fvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: DummyEnum; coords: array of single) := VertexStream1fvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: DummyEnum; var coords: single) := VertexStream1fvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1fvATI(stream: DummyEnum; coords: pointer) := z_VertexStream1fvATI(stream, coords);
    
    public z_VertexStream1dvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream1dvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: DummyEnum; coords: array of double) := VertexStream1dvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: DummyEnum; var coords: double) := VertexStream1dvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream1dvATI(stream: DummyEnum; coords: pointer) := z_VertexStream1dvATI(stream, coords);
    
    public z_VertexStream2svATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream2svATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: DummyEnum; coords: array of Int16) := VertexStream2svATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: DummyEnum; var coords: Int16) := VertexStream2svATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2svATI(stream: DummyEnum; coords: pointer) := z_VertexStream2svATI(stream, coords);
    
    public z_VertexStream2ivATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream2ivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: DummyEnum; coords: array of Int32) := VertexStream2ivATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: DummyEnum; var coords: Int32) := VertexStream2ivATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2ivATI(stream: DummyEnum; coords: pointer) := z_VertexStream2ivATI(stream, coords);
    
    public z_VertexStream2fvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream2fvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: DummyEnum; coords: array of single) := VertexStream2fvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: DummyEnum; var coords: single) := VertexStream2fvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2fvATI(stream: DummyEnum; coords: pointer) := z_VertexStream2fvATI(stream, coords);
    
    public z_VertexStream2dvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream2dvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: DummyEnum; coords: array of double) := VertexStream2dvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: DummyEnum; var coords: double) := VertexStream2dvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream2dvATI(stream: DummyEnum; coords: pointer) := z_VertexStream2dvATI(stream, coords);
    
    public z_VertexStream3svATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream3svATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: DummyEnum; coords: array of Int16) := VertexStream3svATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: DummyEnum; var coords: Int16) := VertexStream3svATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3svATI(stream: DummyEnum; coords: pointer) := z_VertexStream3svATI(stream, coords);
    
    public z_VertexStream3ivATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream3ivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: DummyEnum; coords: array of Int32) := VertexStream3ivATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: DummyEnum; var coords: Int32) := VertexStream3ivATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3ivATI(stream: DummyEnum; coords: pointer) := z_VertexStream3ivATI(stream, coords);
    
    public z_VertexStream3fvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream3fvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: DummyEnum; coords: array of single) := VertexStream3fvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: DummyEnum; var coords: single) := VertexStream3fvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3fvATI(stream: DummyEnum; coords: pointer) := z_VertexStream3fvATI(stream, coords);
    
    public z_VertexStream3dvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream3dvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: DummyEnum; coords: array of double) := VertexStream3dvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: DummyEnum; var coords: double) := VertexStream3dvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream3dvATI(stream: DummyEnum; coords: pointer) := z_VertexStream3dvATI(stream, coords);
    
    public z_VertexStream4svATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream4svATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: DummyEnum; coords: array of Int16) := VertexStream4svATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: DummyEnum; var coords: Int16) := VertexStream4svATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4svATI(stream: DummyEnum; coords: pointer) := z_VertexStream4svATI(stream, coords);
    
    public z_VertexStream4ivATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream4ivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: DummyEnum; coords: array of Int32) := VertexStream4ivATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: DummyEnum; var coords: Int32) := VertexStream4ivATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4ivATI(stream: DummyEnum; coords: pointer) := z_VertexStream4ivATI(stream, coords);
    
    public z_VertexStream4fvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream4fvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: DummyEnum; coords: array of single) := VertexStream4fvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: DummyEnum; var coords: single) := VertexStream4fvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4fvATI(stream: DummyEnum; coords: pointer) := z_VertexStream4fvATI(stream, coords);
    
    public z_VertexStream4dvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glVertexStream4dvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: DummyEnum; coords: array of double) := VertexStream4dvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: DummyEnum; var coords: double) := VertexStream4dvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexStream4dvATI(stream: DummyEnum; coords: pointer) := z_VertexStream4dvATI(stream, coords);
    
    public z_NormalStream3bATI: procedure(stream: DummyEnum; nx: SByte; ny: SByte; nz: SByte) := FuncPtrOrNil&<procedure(stream: DummyEnum; nx: SByte; ny: SByte; nz: SByte)>(GetGLProcAdr('glNormalStream3bATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bATI(stream: DummyEnum; nx: SByte; ny: SByte; nz: SByte) := z_NormalStream3bATI(stream, nx, ny, nz);
    
    public z_NormalStream3sATI: procedure(stream: DummyEnum; nx: Int16; ny: Int16; nz: Int16) := FuncPtrOrNil&<procedure(stream: DummyEnum; nx: Int16; ny: Int16; nz: Int16)>(GetGLProcAdr('glNormalStream3sATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3sATI(stream: DummyEnum; nx: Int16; ny: Int16; nz: Int16) := z_NormalStream3sATI(stream, nx, ny, nz);
    
    public z_NormalStream3iATI: procedure(stream: DummyEnum; nx: Int32; ny: Int32; nz: Int32) := FuncPtrOrNil&<procedure(stream: DummyEnum; nx: Int32; ny: Int32; nz: Int32)>(GetGLProcAdr('glNormalStream3iATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3iATI(stream: DummyEnum; nx: Int32; ny: Int32; nz: Int32) := z_NormalStream3iATI(stream, nx, ny, nz);
    
    public z_NormalStream3fATI: procedure(stream: DummyEnum; nx: single; ny: single; nz: single) := FuncPtrOrNil&<procedure(stream: DummyEnum; nx: single; ny: single; nz: single)>(GetGLProcAdr('glNormalStream3fATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fATI(stream: DummyEnum; nx: single; ny: single; nz: single) := z_NormalStream3fATI(stream, nx, ny, nz);
    
    public z_NormalStream3dATI: procedure(stream: DummyEnum; nx: double; ny: double; nz: double) := FuncPtrOrNil&<procedure(stream: DummyEnum; nx: double; ny: double; nz: double)>(GetGLProcAdr('glNormalStream3dATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dATI(stream: DummyEnum; nx: double; ny: double; nz: double) := z_NormalStream3dATI(stream, nx, ny, nz);
    
    public z_NormalStream3bvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glNormalStream3bvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: DummyEnum; coords: array of SByte) := NormalStream3bvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: DummyEnum; var coords: SByte) := NormalStream3bvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3bvATI(stream: DummyEnum; coords: pointer) := z_NormalStream3bvATI(stream, coords);
    
    public z_NormalStream3svATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glNormalStream3svATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: DummyEnum; coords: array of Int16) := NormalStream3svATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: DummyEnum; var coords: Int16) := NormalStream3svATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3svATI(stream: DummyEnum; coords: pointer) := z_NormalStream3svATI(stream, coords);
    
    public z_NormalStream3ivATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glNormalStream3ivATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: DummyEnum; coords: array of Int32) := NormalStream3ivATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: DummyEnum; var coords: Int32) := NormalStream3ivATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3ivATI(stream: DummyEnum; coords: pointer) := z_NormalStream3ivATI(stream, coords);
    
    public z_NormalStream3fvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glNormalStream3fvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: DummyEnum; coords: array of single) := NormalStream3fvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: DummyEnum; var coords: single) := NormalStream3fvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3fvATI(stream: DummyEnum; coords: pointer) := z_NormalStream3fvATI(stream, coords);
    
    public z_NormalStream3dvATI: procedure(stream: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(stream: DummyEnum; coords: pointer)>(GetGLProcAdr('glNormalStream3dvATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: DummyEnum; coords: array of double) := NormalStream3dvATI(stream, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: DummyEnum; var coords: double) := NormalStream3dvATI(stream, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalStream3dvATI(stream: DummyEnum; coords: pointer) := z_NormalStream3dvATI(stream, coords);
    
    public z_ClientActiveVertexStreamATI: procedure(stream: DummyEnum) := FuncPtrOrNil&<procedure(stream: DummyEnum)>(GetGLProcAdr('glClientActiveVertexStreamATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientActiveVertexStreamATI(stream: DummyEnum) := z_ClientActiveVertexStreamATI(stream);
    
    public z_VertexBlendEnviATI: procedure(pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: Int32)>(GetGLProcAdr('glVertexBlendEnviATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendEnviATI(pname: DummyEnum; param: Int32) := z_VertexBlendEnviATI(pname, param);
    
    public z_VertexBlendEnvfATI: procedure(pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: single)>(GetGLProcAdr('glVertexBlendEnvfATI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexBlendEnvfATI(pname: DummyEnum; param: single) := z_VertexBlendEnvfATI(pname, param);
    
    {$endregion ATI_vertex_streams}
    
  end;
  
  gl_GREMEDY = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region GREMEDY_frame_terminator}
    
    public z_FrameTerminatorGREMEDY: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glFrameTerminatorGREMEDY'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrameTerminatorGREMEDY := z_FrameTerminatorGREMEDY();
    
    {$endregion GREMEDY_frame_terminator}
    
    {$region GREMEDY_string_marker}
    
    public z_StringMarkerGREMEDY: procedure(len: Int32; string: pointer) := FuncPtrOrNil&<procedure(len: Int32; string: pointer)>(GetGLProcAdr('glStringMarkerGREMEDY'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StringMarkerGREMEDY(len: Int32; string: pointer) := z_StringMarkerGREMEDY(len, string);
    
    {$endregion GREMEDY_string_marker}
    
  end;
  
  gl_HP = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region HP_image_transform}
    
    public z_ImageTransformParameteriHP: procedure(target: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glImageTransformParameteriHP'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameteriHP(target: DummyEnum; pname: DummyEnum; param: Int32) := z_ImageTransformParameteriHP(target, pname, param);
    
    public z_ImageTransformParameterfHP: procedure(target: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glImageTransformParameterfHP'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfHP(target: DummyEnum; pname: DummyEnum; param: single) := z_ImageTransformParameterfHP(target, pname, param);
    
    public z_ImageTransformParameterivHP: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glImageTransformParameterivHP'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := ImageTransformParameterivHP(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; var &params: Int32) := ImageTransformParameterivHP(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ImageTransformParameterivHP(target, pname, &params);
    
    public z_ImageTransformParameterfvHP: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glImageTransformParameterfvHP'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; &params: array of single) := ImageTransformParameterfvHP(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; var &params: single) := ImageTransformParameterfvHP(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ImageTransformParameterfvHP(target, pname, &params);
    
    public z_GetImageTransformParameterivHP: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetImageTransformParameterivHP'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetImageTransformParameterivHP(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetImageTransformParameterivHP(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterivHP(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetImageTransformParameterivHP(target, pname, &params);
    
    public z_GetImageTransformParameterfvHP: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetImageTransformParameterfvHP'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetImageTransformParameterfvHP(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; var &params: single) := GetImageTransformParameterfvHP(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetImageTransformParameterfvHP(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetImageTransformParameterfvHP(target, pname, &params);
    
    {$endregion HP_image_transform}
    
  end;
  
  gl_IBM = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region IBM_multimode_draw_arrays}
    
    public z_MultiModeDrawArraysIBM: procedure(mode: pointer; first: pointer; count: pointer; primcount: Int32; modestride: Int32) := FuncPtrOrNil&<procedure(mode: pointer; first: pointer; count: pointer; primcount: Int32; modestride: Int32)>(GetGLProcAdr('glMultiModeDrawArraysIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: array of Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first[0], count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: array of Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first[0], @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: array of Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first[0], count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; var first: Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], @first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], @first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; var first: Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], @first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: pointer; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: pointer; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: array of DummyEnum; first: pointer; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode[0], first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: array of Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first[0], count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: array of Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first[0], @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: array of Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first[0], count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; var first: Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, @first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, @first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; var first: Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, @first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: pointer; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: pointer; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(var mode: DummyEnum; first: pointer; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(@mode, first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: array of Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, first[0], count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: array of Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, first[0], @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: array of Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, first[0], count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; var first: Int32; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, @first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; var first: Int32; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, @first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; var first: Int32; count: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, @first, count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: pointer; count: array of Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, first, count[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: pointer; var count: Int32; primcount: Int32; modestride: Int32) := MultiModeDrawArraysIBM(mode, first, @count, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawArraysIBM(mode: pointer; first: pointer; count: pointer; primcount: Int32; modestride: Int32) := z_MultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
    
    public z_MultiModeDrawElementsIBM: procedure(mode: pointer; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := FuncPtrOrNil&<procedure(mode: pointer; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32)>(GetGLProcAdr('glMultiModeDrawElementsIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count[0], &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count[0], &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count[0], &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], @count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], @count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], @count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: array of DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode[0], count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count[0], &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: array of Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count[0], &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: array of Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count[0], &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, @count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; var count: Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, @count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; var count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, @count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: pointer; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: pointer; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(var mode: DummyEnum; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(@mode, count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: array of Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, count[0], &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: array of Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, count[0], &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: array of Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, count[0], &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; var count: Int32; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, @count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; var count: Int32; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, @count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; var count: Int32; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, @count, &type, indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: pointer; &type: DummyEnum; indices: array of IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, count, &type, indices[0], primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: pointer; &type: DummyEnum; var indices: IntPtr; primcount: Int32; modestride: Int32) := MultiModeDrawElementsIBM(mode, count, &type, @indices, primcount, modestride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiModeDrawElementsIBM(mode: pointer; count: pointer; &type: DummyEnum; indices: pointer; primcount: Int32; modestride: Int32) := z_MultiModeDrawElementsIBM(mode, count, &type, indices, primcount, modestride);
    
    {$endregion IBM_multimode_draw_arrays}
    
    {$region IBM_static_data}
    
    public z_FlushStaticDataIBM: procedure(target: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum)>(GetGLProcAdr('glFlushStaticDataIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushStaticDataIBM(target: DummyEnum) := z_FlushStaticDataIBM(target);
    
    {$endregion IBM_static_data}
    
    {$region IBM_vertex_array_lists}
    
    public z_ColorPointerListIBM: procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>(GetGLProcAdr('glColorPointerListIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := ColorPointerListIBM(size, &type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := ColorPointerListIBM(size, &type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_ColorPointerListIBM(size, &type, stride, _pointer, ptrstride);
    
    public z_SecondaryColorPointerListIBM: procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>(GetGLProcAdr('glSecondaryColorPointerListIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := SecondaryColorPointerListIBM(size, &type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := SecondaryColorPointerListIBM(size, &type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_SecondaryColorPointerListIBM(size, &type, stride, _pointer, ptrstride);
    
    public z_EdgeFlagPointerListIBM: procedure(stride: Int32; _pointer: pointer; ptrstride: Int32) := FuncPtrOrNil&<procedure(stride: Int32; _pointer: pointer; ptrstride: Int32)>(GetGLProcAdr('glEdgeFlagPointerListIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagPointerListIBM(stride: Int32; _pointer: ^^Byte; ptrstride: Int32) := z_EdgeFlagPointerListIBM(stride, _pointer, ptrstride);
    
    public z_FogCoordPointerListIBM: procedure(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>(GetGLProcAdr('glFogCoordPointerListIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := FogCoordPointerListIBM(&type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := FogCoordPointerListIBM(&type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_FogCoordPointerListIBM(&type, stride, _pointer, ptrstride);
    
    public z_IndexPointerListIBM: procedure(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>(GetGLProcAdr('glIndexPointerListIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := IndexPointerListIBM(&type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := IndexPointerListIBM(&type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_IndexPointerListIBM(&type, stride, _pointer, ptrstride);
    
    public z_NormalPointerListIBM: procedure(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>(GetGLProcAdr('glNormalPointerListIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := NormalPointerListIBM(&type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := NormalPointerListIBM(&type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointerListIBM(&type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_NormalPointerListIBM(&type, stride, _pointer, ptrstride);
    
    public z_TexCoordPointerListIBM: procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>(GetGLProcAdr('glTexCoordPointerListIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := TexCoordPointerListIBM(size, &type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := TexCoordPointerListIBM(size, &type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_TexCoordPointerListIBM(size, &type, stride, _pointer, ptrstride);
    
    public z_VertexPointerListIBM: procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32)>(GetGLProcAdr('glVertexPointerListIBM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: array of IntPtr; ptrstride: Int32) := VertexPointerListIBM(size, &type, stride, _pointer[0], ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; var _pointer: IntPtr; ptrstride: Int32) := VertexPointerListIBM(size, &type, stride, @_pointer, ptrstride);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointerListIBM(size: Int32; &type: DummyEnum; stride: Int32; _pointer: pointer; ptrstride: Int32) := z_VertexPointerListIBM(size, &type, stride, _pointer, ptrstride);
    
    {$endregion IBM_vertex_array_lists}
    
  end;
  
  gl_IMG = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region IMG_framebuffer_downsample}
    
    public z_FramebufferTexture2DDownsampleIMG: procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; xscale: Int32; yscale: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; xscale: Int32; yscale: Int32)>(GetGLProcAdr('glFramebufferTexture2DDownsampleIMG'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTexture2DDownsampleIMG(target: DummyEnum; attachment: DummyEnum; textarget: DummyEnum; texture: UInt32; level: Int32; xscale: Int32; yscale: Int32) := z_FramebufferTexture2DDownsampleIMG(target, attachment, textarget, texture, level, xscale, yscale);
    
    public z_FramebufferTextureLayerDownsampleIMG: procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32; xscale: Int32; yscale: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32; xscale: Int32; yscale: Int32)>(GetGLProcAdr('glFramebufferTextureLayerDownsampleIMG'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureLayerDownsampleIMG(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; layer: Int32; xscale: Int32; yscale: Int32) := z_FramebufferTextureLayerDownsampleIMG(target, attachment, texture, level, layer, xscale, yscale);
    
    {$endregion IMG_framebuffer_downsample}
    
  end;
  
  gl_INTEL = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region INTEL_framebuffer_CMAA}
    
    public z_ApplyFramebufferAttachmentCMAAINTEL: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glApplyFramebufferAttachmentCMAAINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ApplyFramebufferAttachmentCMAAINTEL := z_ApplyFramebufferAttachmentCMAAINTEL();
    
    {$endregion INTEL_framebuffer_CMAA}
    
    {$region INTEL_map_texture}
    
    public z_MapTexture2DINTEL: function(texture: UInt32; level: Int32; access: DummyFlags; stride: pointer; layout: pointer): pointer := FuncPtrOrNil&<function(texture: UInt32; level: Int32; access: DummyFlags; stride: pointer; layout: pointer): pointer>(GetGLProcAdr('glMapTexture2DINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: array of Int32; layout: array of DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, stride[0], layout[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: array of Int32; var layout: DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, stride[0], @layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: array of Int32; layout: pointer): pointer := MapTexture2DINTEL(texture, level, access, stride[0], layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; var stride: Int32; layout: array of DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, @stride, layout[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; var stride: Int32; var layout: DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, @stride, @layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; var stride: Int32; layout: pointer): pointer := MapTexture2DINTEL(texture, level, access, @stride, layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: pointer; layout: array of DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, stride, layout[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: pointer; var layout: DummyEnum): pointer := MapTexture2DINTEL(texture, level, access, stride, @layout);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function MapTexture2DINTEL(texture: UInt32; level: Int32; access: DummyFlags; stride: pointer; layout: pointer): pointer := z_MapTexture2DINTEL(texture, level, access, stride, layout);
    
    public z_UnmapTexture2DINTEL: procedure(texture: UInt32; level: Int32) := FuncPtrOrNil&<procedure(texture: UInt32; level: Int32)>(GetGLProcAdr('glUnmapTexture2DINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UnmapTexture2DINTEL(texture: UInt32; level: Int32) := z_UnmapTexture2DINTEL(texture, level);
    
    public z_SyncTextureINTEL: procedure(texture: UInt32) := FuncPtrOrNil&<procedure(texture: UInt32)>(GetGLProcAdr('glSyncTextureINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SyncTextureINTEL(texture: UInt32) := z_SyncTextureINTEL(texture);
    
    {$endregion INTEL_map_texture}
    
    {$region INTEL_parallel_arrays}
    
    public z_VertexPointervINTEL: procedure(size: Int32; &type: DummyEnum; _pointer: pointer) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; _pointer: pointer)>(GetGLProcAdr('glVertexPointervINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: DummyEnum; _pointer: array of IntPtr) := VertexPointervINTEL(size, &type, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: DummyEnum; var _pointer: IntPtr) := VertexPointervINTEL(size, &type, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexPointervINTEL(size: Int32; &type: DummyEnum; _pointer: pointer) := z_VertexPointervINTEL(size, &type, _pointer);
    
    public z_NormalPointervINTEL: procedure(&type: DummyEnum; _pointer: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; _pointer: pointer)>(GetGLProcAdr('glNormalPointervINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: DummyEnum; _pointer: array of IntPtr) := NormalPointervINTEL(&type, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: DummyEnum; var _pointer: IntPtr) := NormalPointervINTEL(&type, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalPointervINTEL(&type: DummyEnum; _pointer: pointer) := z_NormalPointervINTEL(&type, _pointer);
    
    public z_ColorPointervINTEL: procedure(size: Int32; &type: DummyEnum; _pointer: pointer) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; _pointer: pointer)>(GetGLProcAdr('glColorPointervINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: DummyEnum; _pointer: array of IntPtr) := ColorPointervINTEL(size, &type, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: DummyEnum; var _pointer: IntPtr) := ColorPointervINTEL(size, &type, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorPointervINTEL(size: Int32; &type: DummyEnum; _pointer: pointer) := z_ColorPointervINTEL(size, &type, _pointer);
    
    public z_TexCoordPointervINTEL: procedure(size: Int32; &type: DummyEnum; _pointer: pointer) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; _pointer: pointer)>(GetGLProcAdr('glTexCoordPointervINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: DummyEnum; _pointer: array of IntPtr) := TexCoordPointervINTEL(size, &type, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: DummyEnum; var _pointer: IntPtr) := TexCoordPointervINTEL(size, &type, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordPointervINTEL(size: Int32; &type: DummyEnum; _pointer: pointer) := z_TexCoordPointervINTEL(size, &type, _pointer);
    
    {$endregion INTEL_parallel_arrays}
    
    {$region INTEL_performance_query}
    
    public z_GetFirstPerfQueryIdINTEL: procedure(queryId: pointer) := FuncPtrOrNil&<procedure(queryId: pointer)>(GetGLProcAdr('glGetFirstPerfQueryIdINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFirstPerfQueryIdINTEL(queryId: array of UInt32) := GetFirstPerfQueryIdINTEL(queryId[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFirstPerfQueryIdINTEL(var queryId: UInt32) := GetFirstPerfQueryIdINTEL(@queryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFirstPerfQueryIdINTEL(queryId: pointer) := z_GetFirstPerfQueryIdINTEL(queryId);
    
    public z_GetNextPerfQueryIdINTEL: procedure(queryId: UInt32; nextQueryId: pointer) := FuncPtrOrNil&<procedure(queryId: UInt32; nextQueryId: pointer)>(GetGLProcAdr('glGetNextPerfQueryIdINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNextPerfQueryIdINTEL(queryId: UInt32; nextQueryId: array of UInt32) := GetNextPerfQueryIdINTEL(queryId, nextQueryId[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNextPerfQueryIdINTEL(queryId: UInt32; var nextQueryId: UInt32) := GetNextPerfQueryIdINTEL(queryId, @nextQueryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNextPerfQueryIdINTEL(queryId: UInt32; nextQueryId: pointer) := z_GetNextPerfQueryIdINTEL(queryId, nextQueryId);
    
    public z_GetPerfQueryIdByNameINTEL: procedure(queryName: IntPtr; queryId: pointer) := FuncPtrOrNil&<procedure(queryName: IntPtr; queryId: pointer)>(GetGLProcAdr('glGetPerfQueryIdByNameINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: string; queryId: array of UInt32); begin var ptr1 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryIdByNameINTEL(ptr1, queryId[0]); queryName := Marshal.PtrToStringAnsi(ptr1); Marshal.FreeHGlobal(ptr1); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: string; var queryId: UInt32); begin var ptr1 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryIdByNameINTEL(ptr1, @queryId); queryName := Marshal.PtrToStringAnsi(ptr1); Marshal.FreeHGlobal(ptr1); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: string; queryId: pointer); begin var ptr1 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryIdByNameINTEL(ptr1, queryId); queryName := Marshal.PtrToStringAnsi(ptr1); Marshal.FreeHGlobal(ptr1); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: IntPtr; queryId: array of UInt32) := GetPerfQueryIdByNameINTEL(queryName, queryId[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: IntPtr; var queryId: UInt32) := GetPerfQueryIdByNameINTEL(queryName, @queryId);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryIdByNameINTEL(queryName: IntPtr; queryId: pointer) := z_GetPerfQueryIdByNameINTEL(queryName, queryId);
    
    public z_GetPerfQueryInfoINTEL: procedure(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; noInstances: pointer; capsMask: pointer) := FuncPtrOrNil&<procedure(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; noInstances: pointer; capsMask: pointer)>(GetGLProcAdr('glGetPerfQueryInfoINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters[0], noInstances[0], capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: array of UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters[0], noInstances[0], @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters[0], noInstances[0], capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: array of UInt32; var noInstances: UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters[0], @noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: array of UInt32; var noInstances: UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters[0], @noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: array of UInt32; var noInstances: UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters[0], @noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: pointer; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters[0], noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: pointer; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters[0], noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: pointer; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters[0], noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; var noCounters: UInt32; noInstances: array of UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], @noCounters, noInstances[0], capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; var noCounters: UInt32; noInstances: array of UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], @noCounters, noInstances[0], @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; var noCounters: UInt32; noInstances: array of UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], @noCounters, noInstances[0], capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; var noCounters: UInt32; var noInstances: UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], @noCounters, @noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; var noCounters: UInt32; var noInstances: UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], @noCounters, @noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; var noCounters: UInt32; var noInstances: UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], @noCounters, @noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; var noCounters: UInt32; noInstances: pointer; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], @noCounters, noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; var noCounters: UInt32; noInstances: pointer; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], @noCounters, noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; var noCounters: UInt32; noInstances: pointer; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], @noCounters, noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: pointer; noInstances: array of UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters, noInstances[0], capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: pointer; noInstances: array of UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters, noInstances[0], @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: pointer; noInstances: array of UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters, noInstances[0], capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: pointer; var noInstances: UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters, @noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: pointer; var noInstances: UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters, @noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: pointer; var noInstances: UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters, @noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: pointer; noInstances: pointer; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters, noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: pointer; noInstances: pointer; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters, noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: array of UInt32; noCounters: pointer; noInstances: pointer; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize[0], noCounters, noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters[0], noInstances[0], capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: array of UInt32; noInstances: array of UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters[0], noInstances[0], @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters[0], noInstances[0], capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: array of UInt32; var noInstances: UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters[0], @noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: array of UInt32; var noInstances: UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters[0], @noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: array of UInt32; var noInstances: UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters[0], @noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: array of UInt32; noInstances: pointer; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters[0], noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: array of UInt32; noInstances: pointer; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters[0], noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: array of UInt32; noInstances: pointer; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters[0], noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; var noCounters: UInt32; noInstances: array of UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, @noCounters, noInstances[0], capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; var noCounters: UInt32; noInstances: array of UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, @noCounters, noInstances[0], @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; var noCounters: UInt32; noInstances: array of UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, @noCounters, noInstances[0], capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, @noCounters, @noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, @noCounters, @noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, @noCounters, @noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; var noCounters: UInt32; noInstances: pointer; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, @noCounters, noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; var noCounters: UInt32; noInstances: pointer; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, @noCounters, noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; var noCounters: UInt32; noInstances: pointer; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, @noCounters, noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: pointer; noInstances: array of UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters, noInstances[0], capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: pointer; noInstances: array of UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters, noInstances[0], @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: pointer; noInstances: array of UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters, noInstances[0], capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: pointer; var noInstances: UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters, @noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: pointer; var noInstances: UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters, @noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: pointer; var noInstances: UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters, @noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: pointer; noInstances: pointer; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters, noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: pointer; noInstances: pointer; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters, noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; var dataSize: UInt32; noCounters: pointer; noInstances: pointer; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, @dataSize, noCounters, noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters[0], noInstances[0], capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: array of UInt32; noInstances: array of UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters[0], noInstances[0], @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters[0], noInstances[0], capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: array of UInt32; var noInstances: UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters[0], @noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: array of UInt32; var noInstances: UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters[0], @noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: array of UInt32; var noInstances: UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters[0], @noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: array of UInt32; noInstances: pointer; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters[0], noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: array of UInt32; noInstances: pointer; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters[0], noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: array of UInt32; noInstances: pointer; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters[0], noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; var noCounters: UInt32; noInstances: array of UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, @noCounters, noInstances[0], capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; var noCounters: UInt32; noInstances: array of UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, @noCounters, noInstances[0], @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; var noCounters: UInt32; noInstances: array of UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, @noCounters, noInstances[0], capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; var noCounters: UInt32; var noInstances: UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, @noCounters, @noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; var noCounters: UInt32; var noInstances: UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, @noCounters, @noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; var noCounters: UInt32; var noInstances: UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, @noCounters, @noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; var noCounters: UInt32; noInstances: pointer; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, @noCounters, noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; var noCounters: UInt32; noInstances: pointer; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, @noCounters, noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; var noCounters: UInt32; noInstances: pointer; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, @noCounters, noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: pointer; noInstances: array of UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters, noInstances[0], capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: pointer; noInstances: array of UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters, noInstances[0], @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: pointer; noInstances: array of UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters, noInstances[0], capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: pointer; var noInstances: UInt32; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters, @noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: pointer; var noInstances: UInt32; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters, @noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: pointer; var noInstances: UInt32; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters, @noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: pointer; noInstances: pointer; capsMask: array of UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters, noInstances, capsMask[0]); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: pointer; noInstances: pointer; var capsMask: UInt32); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters, noInstances, @capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: string; dataSize: pointer; noCounters: pointer; noInstances: pointer; capsMask: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(queryName); GetPerfQueryInfoINTEL(queryId, queryNameLength, ptr3, dataSize, noCounters, noInstances, capsMask); queryName := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters[0], noInstances[0], capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: array of UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters[0], noInstances[0], @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters[0], noInstances[0], capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: array of UInt32; var noInstances: UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters[0], @noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: array of UInt32; var noInstances: UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters[0], @noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: array of UInt32; var noInstances: UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters[0], @noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: pointer; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters[0], noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: pointer; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters[0], noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: array of UInt32; noInstances: pointer; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters[0], noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; var noCounters: UInt32; noInstances: array of UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], @noCounters, noInstances[0], capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; var noCounters: UInt32; noInstances: array of UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], @noCounters, noInstances[0], @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; var noCounters: UInt32; noInstances: array of UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], @noCounters, noInstances[0], capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; var noCounters: UInt32; var noInstances: UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], @noCounters, @noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; var noCounters: UInt32; var noInstances: UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], @noCounters, @noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; var noCounters: UInt32; var noInstances: UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], @noCounters, @noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; var noCounters: UInt32; noInstances: pointer; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], @noCounters, noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; var noCounters: UInt32; noInstances: pointer; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], @noCounters, noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; var noCounters: UInt32; noInstances: pointer; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], @noCounters, noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: pointer; noInstances: array of UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters, noInstances[0], capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: pointer; noInstances: array of UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters, noInstances[0], @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: pointer; noInstances: array of UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters, noInstances[0], capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: pointer; var noInstances: UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters, @noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: pointer; var noInstances: UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters, @noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: pointer; var noInstances: UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters, @noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: pointer; noInstances: pointer; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters, noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: pointer; noInstances: pointer; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters, noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: array of UInt32; noCounters: pointer; noInstances: pointer; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize[0], noCounters, noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters[0], noInstances[0], capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: array of UInt32; noInstances: array of UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters[0], noInstances[0], @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters[0], noInstances[0], capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: array of UInt32; var noInstances: UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters[0], @noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: array of UInt32; var noInstances: UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters[0], @noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: array of UInt32; var noInstances: UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters[0], @noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: array of UInt32; noInstances: pointer; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters[0], noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: array of UInt32; noInstances: pointer; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters[0], noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: array of UInt32; noInstances: pointer; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters[0], noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; noInstances: array of UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, @noCounters, noInstances[0], capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; noInstances: array of UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, @noCounters, noInstances[0], @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; noInstances: array of UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, @noCounters, noInstances[0], capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, @noCounters, @noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, @noCounters, @noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; var noInstances: UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, @noCounters, @noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; noInstances: pointer; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, @noCounters, noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; noInstances: pointer; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, @noCounters, noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; var noCounters: UInt32; noInstances: pointer; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, @noCounters, noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: pointer; noInstances: array of UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters, noInstances[0], capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: pointer; noInstances: array of UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters, noInstances[0], @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: pointer; noInstances: array of UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters, noInstances[0], capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: pointer; var noInstances: UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters, @noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: pointer; var noInstances: UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters, @noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: pointer; var noInstances: UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters, @noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: pointer; noInstances: pointer; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters, noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: pointer; noInstances: pointer; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters, noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; var dataSize: UInt32; noCounters: pointer; noInstances: pointer; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, @dataSize, noCounters, noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters[0], noInstances[0], capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: array of UInt32; noInstances: array of UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters[0], noInstances[0], @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: array of UInt32; noInstances: array of UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters[0], noInstances[0], capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: array of UInt32; var noInstances: UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters[0], @noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: array of UInt32; var noInstances: UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters[0], @noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: array of UInt32; var noInstances: UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters[0], @noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: array of UInt32; noInstances: pointer; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters[0], noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: array of UInt32; noInstances: pointer; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters[0], noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: array of UInt32; noInstances: pointer; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters[0], noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; var noCounters: UInt32; noInstances: array of UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, @noCounters, noInstances[0], capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; var noCounters: UInt32; noInstances: array of UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, @noCounters, noInstances[0], @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; var noCounters: UInt32; noInstances: array of UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, @noCounters, noInstances[0], capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; var noCounters: UInt32; var noInstances: UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, @noCounters, @noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; var noCounters: UInt32; var noInstances: UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, @noCounters, @noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; var noCounters: UInt32; var noInstances: UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, @noCounters, @noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; var noCounters: UInt32; noInstances: pointer; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, @noCounters, noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; var noCounters: UInt32; noInstances: pointer; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, @noCounters, noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; var noCounters: UInt32; noInstances: pointer; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, @noCounters, noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; noInstances: array of UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances[0], capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; noInstances: array of UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances[0], @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; noInstances: array of UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances[0], capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; var noInstances: UInt32; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, @noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; var noInstances: UInt32; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, @noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; var noInstances: UInt32; capsMask: pointer) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, @noInstances, capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; noInstances: pointer; capsMask: array of UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; noInstances: pointer; var capsMask: UInt32) := GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, @capsMask);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryInfoINTEL(queryId: UInt32; queryNameLength: UInt32; queryName: IntPtr; dataSize: pointer; noCounters: pointer; noInstances: pointer; capsMask: pointer) := z_GetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
    
    public z_GetPerfCounterInfoINTEL: procedure(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := FuncPtrOrNil&<procedure(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer)>(GetGLProcAdr('glGetPerfCounterInfoINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: string; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr4 := Marshal.StringToHGlobalAnsi(counterName); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, ptr4, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterName := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: string; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer); begin var ptr6 := Marshal.StringToHGlobalAnsi(counterDesc); GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, ptr6, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue); counterDesc := Marshal.PtrToStringAnsi(ptr6); Marshal.FreeHGlobal(ptr6); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: array of UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset[0], counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; var counterOffset: UInt32; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, @counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: array of UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize[0], counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; var counterDataSize: UInt32; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, @counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: array of UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum[0], counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; var counterTypeEnum: UInt32; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, @counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: array of UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum[0], rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; var counterDataTypeEnum: UInt32; rawCounterMaxValue: pointer) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, @counterDataTypeEnum, rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: array of UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; var rawCounterMaxValue: UInt64) := GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, @rawCounterMaxValue);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfCounterInfoINTEL(queryId: UInt32; counterId: UInt32; counterNameLength: UInt32; counterName: IntPtr; counterDescLength: UInt32; counterDesc: IntPtr; counterOffset: pointer; counterDataSize: pointer; counterTypeEnum: pointer; counterDataTypeEnum: pointer; rawCounterMaxValue: pointer) := z_GetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
    
    public z_CreatePerfQueryINTEL: procedure(queryId: UInt32; queryHandle: pointer) := FuncPtrOrNil&<procedure(queryId: UInt32; queryHandle: pointer)>(GetGLProcAdr('glCreatePerfQueryINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreatePerfQueryINTEL(queryId: UInt32; queryHandle: array of UInt32) := CreatePerfQueryINTEL(queryId, queryHandle[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreatePerfQueryINTEL(queryId: UInt32; var queryHandle: UInt32) := CreatePerfQueryINTEL(queryId, @queryHandle);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreatePerfQueryINTEL(queryId: UInt32; queryHandle: pointer) := z_CreatePerfQueryINTEL(queryId, queryHandle);
    
    public z_DeletePerfQueryINTEL: procedure(queryHandle: UInt32) := FuncPtrOrNil&<procedure(queryHandle: UInt32)>(GetGLProcAdr('glDeletePerfQueryINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePerfQueryINTEL(queryHandle: UInt32) := z_DeletePerfQueryINTEL(queryHandle);
    
    public z_BeginPerfQueryINTEL: procedure(queryHandle: UInt32) := FuncPtrOrNil&<procedure(queryHandle: UInt32)>(GetGLProcAdr('glBeginPerfQueryINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginPerfQueryINTEL(queryHandle: UInt32) := z_BeginPerfQueryINTEL(queryHandle);
    
    public z_EndPerfQueryINTEL: procedure(queryHandle: UInt32) := FuncPtrOrNil&<procedure(queryHandle: UInt32)>(GetGLProcAdr('glEndPerfQueryINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndPerfQueryINTEL(queryHandle: UInt32) := z_EndPerfQueryINTEL(queryHandle);
    
    public z_GetPerfQueryDataINTEL: procedure(queryHandle: UInt32; flags: UInt32; dataSize: Int32; data: pointer; bytesWritten: pointer) := FuncPtrOrNil&<procedure(queryHandle: UInt32; flags: UInt32; dataSize: Int32; data: pointer; bytesWritten: pointer)>(GetGLProcAdr('glGetPerfQueryDataINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: UInt32; flags: UInt32; dataSize: Int32; data: pointer; bytesWritten: array of UInt32) := GetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: UInt32; flags: UInt32; dataSize: Int32; data: pointer; var bytesWritten: UInt32) := GetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, @bytesWritten);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPerfQueryDataINTEL(queryHandle: UInt32; flags: UInt32; dataSize: Int32; data: pointer; bytesWritten: pointer) := z_GetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
    
    {$endregion INTEL_performance_query}
    
    {$region INTEL_texture_scissor}
    
    public z_TexScissorINTEL: procedure(target: DummyEnum; tlow: single; thigh: single) := FuncPtrOrNil&<procedure(target: DummyEnum; tlow: single; thigh: single)>(GetGLProcAdr('glTexScissorINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexScissorINTEL(target: DummyEnum; tlow: single; thigh: single) := z_TexScissorINTEL(target, tlow, thigh);
    
    public z_TexScissorFuncINTEL: procedure(target: DummyEnum; lfunc: DummyEnum; hfunc: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum; lfunc: DummyEnum; hfunc: DummyEnum)>(GetGLProcAdr('glTexScissorFuncINTEL'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexScissorFuncINTEL(target: DummyEnum; lfunc: DummyEnum; hfunc: DummyEnum) := z_TexScissorFuncINTEL(target, lfunc, hfunc);
    
    {$endregion INTEL_texture_scissor}
    
  end;
  
  gl_KHR = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region KHR_blend_equation_advanced, NV_blend_equation_advanced}
    
    public z_BlendBarrierKHR: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glBlendBarrierKHR'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendBarrierKHR := z_BlendBarrierKHR();
    
    {$endregion KHR_blend_equation_advanced, NV_blend_equation_advanced}
    
  end;
  
  gl_MESA = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region MESA_resize_buffers}
    
    public z_ResizeBuffersMESA: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glResizeBuffersMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResizeBuffersMESA := z_ResizeBuffersMESA();
    
    {$endregion MESA_resize_buffers}
    
    {$region MESA_window_pos}
    
    public z_WindowPos4iMESA: procedure(x: Int32; y: Int32; z: Int32; w: Int32) := FuncPtrOrNil&<procedure(x: Int32; y: Int32; z: Int32; w: Int32)>(GetGLProcAdr('glWindowPos4iMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4iMESA(x: Int32; y: Int32; z: Int32; w: Int32) := z_WindowPos4iMESA(x, y, z, w);
    
    public z_WindowPos4sMESA: procedure(x: Int16; y: Int16; z: Int16; w: Int16) := FuncPtrOrNil&<procedure(x: Int16; y: Int16; z: Int16; w: Int16)>(GetGLProcAdr('glWindowPos4sMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4sMESA(x: Int16; y: Int16; z: Int16; w: Int16) := z_WindowPos4sMESA(x, y, z, w);
    
    public z_WindowPos4fMESA: procedure(x: single; y: single; z: single; w: single) := FuncPtrOrNil&<procedure(x: single; y: single; z: single; w: single)>(GetGLProcAdr('glWindowPos4fMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fMESA(x: single; y: single; z: single; w: single) := z_WindowPos4fMESA(x, y, z, w);
    
    public z_WindowPos4dMESA: procedure(x: double; y: double; z: double; w: double) := FuncPtrOrNil&<procedure(x: double; y: double; z: double; w: double)>(GetGLProcAdr('glWindowPos4dMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dMESA(x: double; y: double; z: double; w: double) := z_WindowPos4dMESA(x, y, z, w);
    
    public z_WindowPos4ivMESA: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos4ivMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(v: array of Int32) := WindowPos4ivMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(var v: Int32) := WindowPos4ivMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4ivMESA(v: pointer) := z_WindowPos4ivMESA(v);
    
    public z_WindowPos4svMESA: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos4svMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(v: array of Int16) := WindowPos4svMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(var v: Int16) := WindowPos4svMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4svMESA(v: pointer) := z_WindowPos4svMESA(v);
    
    public z_WindowPos4fvMESA: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos4fvMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(v: array of single) := WindowPos4fvMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(var v: single) := WindowPos4fvMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4fvMESA(v: pointer) := z_WindowPos4fvMESA(v);
    
    public z_WindowPos4dvMESA: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glWindowPos4dvMESA'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(v: array of double) := WindowPos4dvMESA(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(var v: double) := WindowPos4dvMESA(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WindowPos4dvMESA(v: pointer) := z_WindowPos4dvMESA(v);
    
    {$endregion MESA_window_pos}
    
  end;
  
  gl_NV = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region Unsorted}
    
    public z_CopyPathNV: procedure(resultPath: UInt32; srcPath: UInt32) := FuncPtrOrNil&<procedure(resultPath: UInt32; srcPath: UInt32)>(GetGLProcAdr('glCopyPathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CopyPathNV(resultPath: UInt32; srcPath: UInt32) := z_CopyPathNV(resultPath, srcPath);
    
    public z_CoverFillPathInstancedNV: procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := FuncPtrOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer)>(GetGLProcAdr('glCoverFillPathInstancedNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: array of single) := CoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single) := CoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := z_CoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    
    public z_CoverFillPathNV: procedure(path: UInt32; coverMode: DummyEnum) := FuncPtrOrNil&<procedure(path: UInt32; coverMode: DummyEnum)>(GetGLProcAdr('glCoverFillPathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverFillPathNV(path: UInt32; coverMode: DummyEnum) := z_CoverFillPathNV(path, coverMode);
    
    public z_CoverStrokePathInstancedNV: procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := FuncPtrOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer)>(GetGLProcAdr('glCoverStrokePathInstancedNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: array of single) := CoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single) := CoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := z_CoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
    
    public z_CoverStrokePathNV: procedure(path: UInt32; coverMode: DummyEnum) := FuncPtrOrNil&<procedure(path: UInt32; coverMode: DummyEnum)>(GetGLProcAdr('glCoverStrokePathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverStrokePathNV(path: UInt32; coverMode: DummyEnum) := z_CoverStrokePathNV(path, coverMode);
    
    public z_DeletePathsNV: procedure(path: UInt32; range: Int32) := FuncPtrOrNil&<procedure(path: UInt32; range: Int32)>(GetGLProcAdr('glDeletePathsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeletePathsNV(path: UInt32; range: Int32) := z_DeletePathsNV(path, range);
    
    public z_GenPathsNV: function(range: Int32): UInt32 := FuncPtrOrNil&<function(range: Int32): UInt32>(GetGLProcAdr('glGenPathsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenPathsNV(range: Int32): UInt32 := z_GenPathsNV(range);
    
    public z_GetPathColorGenfvNV: procedure(color: DummyEnum; pname: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(color: DummyEnum; pname: DummyEnum; value: pointer)>(GetGLProcAdr('glGetPathColorGenfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenfvNV(color: DummyEnum; pname: DummyEnum; value: array of single) := GetPathColorGenfvNV(color, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenfvNV(color: DummyEnum; pname: DummyEnum; var value: single) := GetPathColorGenfvNV(color, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenfvNV(color: DummyEnum; pname: DummyEnum; value: pointer) := z_GetPathColorGenfvNV(color, pname, value);
    
    public z_GetPathColorGenivNV: procedure(color: DummyEnum; pname: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(color: DummyEnum; pname: DummyEnum; value: pointer)>(GetGLProcAdr('glGetPathColorGenivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenivNV(color: DummyEnum; pname: DummyEnum; value: array of Int32) := GetPathColorGenivNV(color, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenivNV(color: DummyEnum; pname: DummyEnum; var value: Int32) := GetPathColorGenivNV(color, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathColorGenivNV(color: DummyEnum; pname: DummyEnum; value: pointer) := z_GetPathColorGenivNV(color, pname, value);
    
    public z_GetPathCommandsNV: procedure(path: UInt32; commands: pointer) := FuncPtrOrNil&<procedure(path: UInt32; commands: pointer)>(GetGLProcAdr('glGetPathCommandsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCommandsNV(path: UInt32; commands: array of Byte) := GetPathCommandsNV(path, commands[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCommandsNV(path: UInt32; var commands: Byte) := GetPathCommandsNV(path, @commands);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCommandsNV(path: UInt32; commands: pointer) := z_GetPathCommandsNV(path, commands);
    
    public z_GetPathCoordsNV: procedure(path: UInt32; coords: pointer) := FuncPtrOrNil&<procedure(path: UInt32; coords: pointer)>(GetGLProcAdr('glGetPathCoordsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCoordsNV(path: UInt32; coords: array of single) := GetPathCoordsNV(path, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCoordsNV(path: UInt32; var coords: single) := GetPathCoordsNV(path, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathCoordsNV(path: UInt32; coords: pointer) := z_GetPathCoordsNV(path, coords);
    
    public z_GetPathDashArrayNV: procedure(path: UInt32; dashArray: pointer) := FuncPtrOrNil&<procedure(path: UInt32; dashArray: pointer)>(GetGLProcAdr('glGetPathDashArrayNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathDashArrayNV(path: UInt32; dashArray: array of single) := GetPathDashArrayNV(path, dashArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathDashArrayNV(path: UInt32; var dashArray: single) := GetPathDashArrayNV(path, @dashArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathDashArrayNV(path: UInt32; dashArray: pointer) := z_GetPathDashArrayNV(path, dashArray);
    
    public z_GetPathLengthNV: function(path: UInt32; startSegment: Int32; numSegments: Int32): single := FuncPtrOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32): single>(GetGLProcAdr('glGetPathLengthNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetPathLengthNV(path: UInt32; startSegment: Int32; numSegments: Int32): single := z_GetPathLengthNV(path, startSegment, numSegments);
    
    public z_GetPathMetricRangeNV: procedure(metricQueryMask: DummyFlags; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: pointer) := FuncPtrOrNil&<procedure(metricQueryMask: DummyFlags; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: pointer)>(GetGLProcAdr('glGetPathMetricRangeNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricRangeNV(metricQueryMask: DummyFlags; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: array of single) := GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricRangeNV(metricQueryMask: DummyFlags; firstPathName: UInt32; numPaths: Int32; stride: Int32; var metrics: single) := GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, @metrics);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricRangeNV(metricQueryMask: DummyFlags; firstPathName: UInt32; numPaths: Int32; stride: Int32; metrics: pointer) := z_GetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
    
    public z_GetPathMetricsNV: procedure(metricQueryMask: DummyFlags; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; stride: Int32; metrics: pointer) := FuncPtrOrNil&<procedure(metricQueryMask: DummyFlags; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; stride: Int32; metrics: pointer)>(GetGLProcAdr('glGetPathMetricsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricsNV(metricQueryMask: DummyFlags; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; stride: Int32; metrics: array of single) := GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricsNV(metricQueryMask: DummyFlags; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; stride: Int32; var metrics: single) := GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, @metrics);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathMetricsNV(metricQueryMask: DummyFlags; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; stride: Int32; metrics: pointer) := z_GetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
    
    public z_GetPathParameterfvNV: procedure(path: UInt32; pname: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(path: UInt32; pname: DummyEnum; value: pointer)>(GetGLProcAdr('glGetPathParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterfvNV(path: UInt32; pname: DummyEnum; value: array of single) := GetPathParameterfvNV(path, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterfvNV(path: UInt32; pname: DummyEnum; var value: single) := GetPathParameterfvNV(path, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterfvNV(path: UInt32; pname: DummyEnum; value: pointer) := z_GetPathParameterfvNV(path, pname, value);
    
    public z_GetPathParameterivNV: procedure(path: UInt32; pname: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(path: UInt32; pname: DummyEnum; value: pointer)>(GetGLProcAdr('glGetPathParameterivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterivNV(path: UInt32; pname: DummyEnum; value: array of Int32) := GetPathParameterivNV(path, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterivNV(path: UInt32; pname: DummyEnum; var value: Int32) := GetPathParameterivNV(path, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathParameterivNV(path: UInt32; pname: DummyEnum; value: pointer) := z_GetPathParameterivNV(path, pname, value);
    
    public z_GetPathSpacingNV: procedure(pathListMode: DummyEnum; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: DummyEnum; returnedSpacing: pointer) := FuncPtrOrNil&<procedure(pathListMode: DummyEnum; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: DummyEnum; returnedSpacing: pointer)>(GetGLProcAdr('glGetPathSpacingNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathSpacingNV(pathListMode: DummyEnum; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: DummyEnum; returnedSpacing: array of single) := GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathSpacingNV(pathListMode: DummyEnum; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: DummyEnum; var returnedSpacing: single) := GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, @returnedSpacing);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathSpacingNV(pathListMode: DummyEnum; numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; advanceScale: single; kerningScale: single; transformType: DummyEnum; returnedSpacing: pointer) := z_GetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
    
    public z_GetPathTexGenfvNV: procedure(texCoordSet: DummyEnum; pname: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(texCoordSet: DummyEnum; pname: DummyEnum; value: pointer)>(GetGLProcAdr('glGetPathTexGenfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenfvNV(texCoordSet: DummyEnum; pname: DummyEnum; value: array of single) := GetPathTexGenfvNV(texCoordSet, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenfvNV(texCoordSet: DummyEnum; pname: DummyEnum; var value: single) := GetPathTexGenfvNV(texCoordSet, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenfvNV(texCoordSet: DummyEnum; pname: DummyEnum; value: pointer) := z_GetPathTexGenfvNV(texCoordSet, pname, value);
    
    public z_GetPathTexGenivNV: procedure(texCoordSet: DummyEnum; pname: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(texCoordSet: DummyEnum; pname: DummyEnum; value: pointer)>(GetGLProcAdr('glGetPathTexGenivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenivNV(texCoordSet: DummyEnum; pname: DummyEnum; value: array of Int32) := GetPathTexGenivNV(texCoordSet, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenivNV(texCoordSet: DummyEnum; pname: DummyEnum; var value: Int32) := GetPathTexGenivNV(texCoordSet, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPathTexGenivNV(texCoordSet: DummyEnum; pname: DummyEnum; value: pointer) := z_GetPathTexGenivNV(texCoordSet, pname, value);
    
    public z_GetProgramResourcefvNV: procedure(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: pointer)>(GetGLProcAdr('glGetProgramResourcefvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: array of Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: array of Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: array of Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; var length: Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, @length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; var length: Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, @length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; var length: Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, @length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: pointer; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: pointer; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: array of DummyEnum; bufSize: Int32; length: pointer; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props[0], bufSize, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: array of Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: array of Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: array of Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; var length: Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, @length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; var length: Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, @length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; var length: Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, @length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: pointer; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: pointer; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; var props: DummyEnum; bufSize: Int32; length: pointer; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, @props, bufSize, length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: array of Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: array of Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: array of Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; var length: Int32; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, @length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; var length: Int32; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, @length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; var length: Int32; &params: pointer) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, @length, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: array of single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; var &params: single) := GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramResourcefvNV(&program: UInt32; programInterface: DummyEnum; index: UInt32; propCount: Int32; props: pointer; bufSize: Int32; length: pointer; &params: pointer) := z_GetProgramResourcefvNV(&program, programInterface, index, propCount, props, bufSize, length, &params);
    
    public z_GetProgramSubroutineParameteruivNV: procedure(target: DummyEnum; index: UInt32; param: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; param: pointer)>(GetGLProcAdr('glGetProgramSubroutineParameteruivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramSubroutineParameteruivNV(target: DummyEnum; index: UInt32; param: array of UInt32) := GetProgramSubroutineParameteruivNV(target, index, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramSubroutineParameteruivNV(target: DummyEnum; index: UInt32; var param: UInt32) := GetProgramSubroutineParameteruivNV(target, index, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramSubroutineParameteruivNV(target: DummyEnum; index: UInt32; param: pointer) := z_GetProgramSubroutineParameteruivNV(target, index, param);
    
    public z_InterpolatePathsNV: procedure(resultPath: UInt32; pathA: UInt32; pathB: UInt32; weight: single) := FuncPtrOrNil&<procedure(resultPath: UInt32; pathA: UInt32; pathB: UInt32; weight: single)>(GetGLProcAdr('glInterpolatePathsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InterpolatePathsNV(resultPath: UInt32; pathA: UInt32; pathB: UInt32; weight: single) := z_InterpolatePathsNV(resultPath, pathA, pathB, weight);
    
    public z_IsPathNV: function(path: UInt32): Byte := FuncPtrOrNil&<function(path: UInt32): Byte>(GetGLProcAdr('glIsPathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPathNV(path: UInt32): Byte := z_IsPathNV(path);
    
    public z_IsPointInFillPathNV: function(path: UInt32; mask: UInt32; x: single; y: single): Byte := FuncPtrOrNil&<function(path: UInt32; mask: UInt32; x: single; y: single): Byte>(GetGLProcAdr('glIsPointInFillPathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPointInFillPathNV(path: UInt32; mask: UInt32; x: single; y: single): Byte := z_IsPointInFillPathNV(path, mask, x, y);
    
    public z_IsPointInStrokePathNV: function(path: UInt32; x: single; y: single): Byte := FuncPtrOrNil&<function(path: UInt32; x: single; y: single): Byte>(GetGLProcAdr('glIsPointInStrokePathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsPointInStrokePathNV(path: UInt32; x: single; y: single): Byte := z_IsPointInStrokePathNV(path, x, y);
    
    public z_MatrixLoad3x2fNV: procedure(matrixMode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixLoad3x2fNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; m: array of single) := MatrixLoad3x2fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; var m: single) := MatrixLoad3x2fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x2fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixLoad3x2fNV(matrixMode, m);
    
    public z_MatrixLoad3x3fNV: procedure(matrixMode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixLoad3x3fNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; m: array of single) := MatrixLoad3x3fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; var m: single) := MatrixLoad3x3fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoad3x3fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixLoad3x3fNV(matrixMode, m);
    
    public z_MatrixLoadTranspose3x3fNV: procedure(matrixMode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixLoadTranspose3x3fNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; m: array of single) := MatrixLoadTranspose3x3fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; var m: single) := MatrixLoadTranspose3x3fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixLoadTranspose3x3fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixLoadTranspose3x3fNV(matrixMode, m);
    
    public z_MatrixMult3x2fNV: procedure(matrixMode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixMult3x2fNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; m: array of single) := MatrixMult3x2fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; var m: single) := MatrixMult3x2fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x2fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixMult3x2fNV(matrixMode, m);
    
    public z_MatrixMult3x3fNV: procedure(matrixMode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixMult3x3fNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; m: array of single) := MatrixMult3x3fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; var m: single) := MatrixMult3x3fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMult3x3fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixMult3x3fNV(matrixMode, m);
    
    public z_MatrixMultTranspose3x3fNV: procedure(matrixMode: DummyEnum; m: pointer) := FuncPtrOrNil&<procedure(matrixMode: DummyEnum; m: pointer)>(GetGLProcAdr('glMatrixMultTranspose3x3fNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; m: array of single) := MatrixMultTranspose3x3fNV(matrixMode, m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; var m: single) := MatrixMultTranspose3x3fNV(matrixMode, @m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MatrixMultTranspose3x3fNV(matrixMode: DummyEnum; m: pointer) := z_MatrixMultTranspose3x3fNV(matrixMode, m);
    
    public z_PathColorGenNV: procedure(color: DummyEnum; genMode: DummyEnum; colorFormat: DummyEnum; coeffs: pointer) := FuncPtrOrNil&<procedure(color: DummyEnum; genMode: DummyEnum; colorFormat: DummyEnum; coeffs: pointer)>(GetGLProcAdr('glPathColorGenNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: DummyEnum; genMode: DummyEnum; colorFormat: DummyEnum; coeffs: array of single) := PathColorGenNV(color, genMode, colorFormat, coeffs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: DummyEnum; genMode: DummyEnum; colorFormat: DummyEnum; var coeffs: single) := PathColorGenNV(color, genMode, colorFormat, @coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathColorGenNV(color: DummyEnum; genMode: DummyEnum; colorFormat: DummyEnum; coeffs: pointer) := z_PathColorGenNV(color, genMode, colorFormat, coeffs);
    
    public z_PathCommandsNV: procedure(path: UInt32; numCommands: Int32; commands: pointer; numCoords: Int32; coordType: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(path: UInt32; numCommands: Int32; commands: pointer; numCoords: Int32; coordType: DummyEnum; coords: pointer)>(GetGLProcAdr('glPathCommandsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; commands: array of Byte; numCoords: Int32; coordType: DummyEnum; coords: pointer) := PathCommandsNV(path, numCommands, commands[0], numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; var commands: Byte; numCoords: Int32; coordType: DummyEnum; coords: pointer) := PathCommandsNV(path, numCommands, @commands, numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCommandsNV(path: UInt32; numCommands: Int32; commands: pointer; numCoords: Int32; coordType: DummyEnum; coords: pointer) := z_PathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
    
    public z_PathCoordsNV: procedure(path: UInt32; numCoords: Int32; coordType: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(path: UInt32; numCoords: Int32; coordType: DummyEnum; coords: pointer)>(GetGLProcAdr('glPathCoordsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCoordsNV(path: UInt32; numCoords: Int32; coordType: DummyEnum; coords: pointer) := z_PathCoordsNV(path, numCoords, coordType, coords);
    
    public z_PathCoverDepthFuncNV: procedure(func: DummyEnum) := FuncPtrOrNil&<procedure(func: DummyEnum)>(GetGLProcAdr('glPathCoverDepthFuncNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathCoverDepthFuncNV(func: DummyEnum) := z_PathCoverDepthFuncNV(func);
    
    public z_PathDashArrayNV: procedure(path: UInt32; dashCount: Int32; dashArray: pointer) := FuncPtrOrNil&<procedure(path: UInt32; dashCount: Int32; dashArray: pointer)>(GetGLProcAdr('glPathDashArrayNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; dashArray: array of single) := PathDashArrayNV(path, dashCount, dashArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; var dashArray: single) := PathDashArrayNV(path, dashCount, @dashArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathDashArrayNV(path: UInt32; dashCount: Int32; dashArray: pointer) := z_PathDashArrayNV(path, dashCount, dashArray);
    
    public z_PathFogGenNV: procedure(genMode: DummyEnum) := FuncPtrOrNil&<procedure(genMode: DummyEnum)>(GetGLProcAdr('glPathFogGenNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathFogGenNV(genMode: DummyEnum) := z_PathFogGenNV(genMode);
    
    public z_PathGlyphIndexArrayNV: function(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum := FuncPtrOrNil&<function(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum>(GetGLProcAdr('glPathGlyphIndexArrayNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexArrayNV(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum := z_PathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    
    public z_PathGlyphIndexRangeNV: function(fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; pathParameterTemplate: UInt32; emScale: single; baseAndCount: Vec2ui): DummyEnum := FuncPtrOrNil&<function(fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; pathParameterTemplate: UInt32; emScale: single; baseAndCount: Vec2ui): DummyEnum>(GetGLProcAdr('glPathGlyphIndexRangeNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathGlyphIndexRangeNV(fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; pathParameterTemplate: UInt32; emScale: single; baseAndCount: Vec2ui): DummyEnum := z_PathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
    
    public z_PathGlyphRangeNV: procedure(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; firstGlyph: UInt32; numGlyphs: Int32; handleMissingGlyphs: DummyEnum; pathParameterTemplate: UInt32; emScale: single) := FuncPtrOrNil&<procedure(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; firstGlyph: UInt32; numGlyphs: Int32; handleMissingGlyphs: DummyEnum; pathParameterTemplate: UInt32; emScale: single)>(GetGLProcAdr('glPathGlyphRangeNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathGlyphRangeNV(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; firstGlyph: UInt32; numGlyphs: Int32; handleMissingGlyphs: DummyEnum; pathParameterTemplate: UInt32; emScale: single) := z_PathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
    
    public z_PathGlyphsNV: procedure(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; numGlyphs: Int32; &type: DummyEnum; charcodes: pointer; handleMissingGlyphs: DummyEnum; pathParameterTemplate: UInt32; emScale: single) := FuncPtrOrNil&<procedure(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; numGlyphs: Int32; &type: DummyEnum; charcodes: pointer; handleMissingGlyphs: DummyEnum; pathParameterTemplate: UInt32; emScale: single)>(GetGLProcAdr('glPathGlyphsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathGlyphsNV(firstPathName: UInt32; fontTarget: DummyEnum; fontName: pointer; fontStyle: DummyFlags; numGlyphs: Int32; &type: DummyEnum; charcodes: pointer; handleMissingGlyphs: DummyEnum; pathParameterTemplate: UInt32; emScale: single) := z_PathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, &type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
    
    public z_PathMemoryGlyphIndexArrayNV: function(firstPathName: UInt32; fontTarget: DummyEnum; fontSize: UIntPtr; fontData: pointer; faceIndex: Int32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum := FuncPtrOrNil&<function(firstPathName: UInt32; fontTarget: DummyEnum; fontSize: UIntPtr; fontData: pointer; faceIndex: Int32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum>(GetGLProcAdr('glPathMemoryGlyphIndexArrayNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PathMemoryGlyphIndexArrayNV(firstPathName: UInt32; fontTarget: DummyEnum; fontSize: UIntPtr; fontData: pointer; faceIndex: Int32; firstGlyphIndex: UInt32; numGlyphs: Int32; pathParameterTemplate: UInt32; emScale: single): DummyEnum := z_PathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
    
    public z_PathParameterfNV: procedure(path: UInt32; pname: DummyEnum; value: single) := FuncPtrOrNil&<procedure(path: UInt32; pname: DummyEnum; value: single)>(GetGLProcAdr('glPathParameterfNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfNV(path: UInt32; pname: DummyEnum; value: single) := z_PathParameterfNV(path, pname, value);
    
    public z_PathParameterfvNV: procedure(path: UInt32; pname: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(path: UInt32; pname: DummyEnum; value: pointer)>(GetGLProcAdr('glPathParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: DummyEnum; value: array of single) := PathParameterfvNV(path, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: DummyEnum; var value: single) := PathParameterfvNV(path, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterfvNV(path: UInt32; pname: DummyEnum; value: pointer) := z_PathParameterfvNV(path, pname, value);
    
    public z_PathParameteriNV: procedure(path: UInt32; pname: DummyEnum; value: Int32) := FuncPtrOrNil&<procedure(path: UInt32; pname: DummyEnum; value: Int32)>(GetGLProcAdr('glPathParameteriNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameteriNV(path: UInt32; pname: DummyEnum; value: Int32) := z_PathParameteriNV(path, pname, value);
    
    public z_PathParameterivNV: procedure(path: UInt32; pname: DummyEnum; value: pointer) := FuncPtrOrNil&<procedure(path: UInt32; pname: DummyEnum; value: pointer)>(GetGLProcAdr('glPathParameterivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: DummyEnum; value: array of Int32) := PathParameterivNV(path, pname, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: DummyEnum; var value: Int32) := PathParameterivNV(path, pname, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathParameterivNV(path: UInt32; pname: DummyEnum; value: pointer) := z_PathParameterivNV(path, pname, value);
    
    public z_PathStencilDepthOffsetNV: procedure(factor: single; units: single) := FuncPtrOrNil&<procedure(factor: single; units: single)>(GetGLProcAdr('glPathStencilDepthOffsetNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStencilDepthOffsetNV(factor: single; units: single) := z_PathStencilDepthOffsetNV(factor, units);
    
    public z_PathStencilFuncNV: procedure(func: DummyEnum; ref: Int32; mask: UInt32) := FuncPtrOrNil&<procedure(func: DummyEnum; ref: Int32; mask: UInt32)>(GetGLProcAdr('glPathStencilFuncNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStencilFuncNV(func: DummyEnum; ref: Int32; mask: UInt32) := z_PathStencilFuncNV(func, ref, mask);
    
    public z_PathStringNV: procedure(path: UInt32; format: DummyEnum; length: Int32; pathString: pointer) := FuncPtrOrNil&<procedure(path: UInt32; format: DummyEnum; length: Int32; pathString: pointer)>(GetGLProcAdr('glPathStringNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathStringNV(path: UInt32; format: DummyEnum; length: Int32; pathString: pointer) := z_PathStringNV(path, format, length, pathString);
    
    public z_PathSubCommandsNV: procedure(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: pointer; numCoords: Int32; coordType: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: pointer; numCoords: Int32; coordType: DummyEnum; coords: pointer)>(GetGLProcAdr('glPathSubCommandsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: array of Byte; numCoords: Int32; coordType: DummyEnum; coords: pointer) := PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands[0], numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; var commands: Byte; numCoords: Int32; coordType: DummyEnum; coords: pointer) := PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, @commands, numCoords, coordType, coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCommandsNV(path: UInt32; commandStart: Int32; commandsToDelete: Int32; numCommands: Int32; commands: pointer; numCoords: Int32; coordType: DummyEnum; coords: pointer) := z_PathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
    
    public z_PathSubCoordsNV: procedure(path: UInt32; coordStart: Int32; numCoords: Int32; coordType: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(path: UInt32; coordStart: Int32; numCoords: Int32; coordType: DummyEnum; coords: pointer)>(GetGLProcAdr('glPathSubCoordsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathSubCoordsNV(path: UInt32; coordStart: Int32; numCoords: Int32; coordType: DummyEnum; coords: pointer) := z_PathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
    
    public z_PathTexGenNV: procedure(texCoordSet: DummyEnum; genMode: DummyEnum; components: Int32; coeffs: pointer) := FuncPtrOrNil&<procedure(texCoordSet: DummyEnum; genMode: DummyEnum; components: Int32; coeffs: pointer)>(GetGLProcAdr('glPathTexGenNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: DummyEnum; genMode: DummyEnum; components: Int32; coeffs: array of single) := PathTexGenNV(texCoordSet, genMode, components, coeffs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: DummyEnum; genMode: DummyEnum; components: Int32; var coeffs: single) := PathTexGenNV(texCoordSet, genMode, components, @coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PathTexGenNV(texCoordSet: DummyEnum; genMode: DummyEnum; components: Int32; coeffs: pointer) := z_PathTexGenNV(texCoordSet, genMode, components, coeffs);
    
    public z_PointAlongPathNV: function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: pointer; tangentY: pointer): Byte := FuncPtrOrNil&<function(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: pointer; tangentY: pointer): Byte>(GetGLProcAdr('glPointAlongPathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: array of single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: array of single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: array of single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; var tangentX: single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; var tangentX: single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; var tangentX: single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: pointer; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: pointer; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: array of single; tangentX: pointer; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y[0], tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: array of single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: array of single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: array of single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; var tangentX: single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; var tangentX: single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; var tangentX: single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: pointer; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: pointer; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; var y: single; tangentX: pointer; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], @y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: array of single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: array of single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: array of single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; var tangentX: single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; var tangentX: single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; var tangentX: single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: pointer; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: pointer; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: array of single; y: pointer; tangentX: pointer; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x[0], y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: array of single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: array of single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: array of single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; var tangentX: single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; var tangentX: single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; var tangentX: single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: pointer; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: pointer; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: array of single; tangentX: pointer; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y[0], tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: array of single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: array of single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: array of single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; var tangentX: single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; var tangentX: single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; var tangentX: single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: pointer; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: pointer; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; var y: single; tangentX: pointer; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, @y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: array of single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: array of single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: array of single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; var tangentX: single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; var tangentX: single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; var tangentX: single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: pointer; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: pointer; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; var x: single; y: pointer; tangentX: pointer; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, @x, y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: array of single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: array of single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: array of single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; var tangentX: single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; var tangentX: single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; var tangentX: single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: pointer; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: pointer; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: array of single; tangentX: pointer; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y[0], tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: array of single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: array of single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: array of single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; var tangentX: single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; var tangentX: single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; var tangentX: single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: pointer; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: pointer; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; var y: single; tangentX: pointer; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, @y, tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: array of single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX[0], tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: array of single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX[0], @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: array of single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX[0], tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; var tangentX: single; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, @tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; var tangentX: single; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, @tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; var tangentX: single; tangentY: pointer): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, @tangentX, tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: pointer; tangentY: array of single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: pointer; var tangentY: single): Byte := PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, @tangentY);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PointAlongPathNV(path: UInt32; startSegment: Int32; numSegments: Int32; distance: single; x: pointer; y: pointer; tangentX: pointer; tangentY: pointer): Byte := z_PointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
    
    public z_ProgramPathFragmentInputGenNV: procedure(&program: UInt32; location: Int32; genMode: DummyEnum; components: Int32; coeffs: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; genMode: DummyEnum; components: Int32; coeffs: pointer)>(GetGLProcAdr('glProgramPathFragmentInputGenNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: UInt32; location: Int32; genMode: DummyEnum; components: Int32; coeffs: array of single) := ProgramPathFragmentInputGenNV(&program, location, genMode, components, coeffs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: UInt32; location: Int32; genMode: DummyEnum; components: Int32; var coeffs: single) := ProgramPathFragmentInputGenNV(&program, location, genMode, components, @coeffs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramPathFragmentInputGenNV(&program: UInt32; location: Int32; genMode: DummyEnum; components: Int32; coeffs: pointer) := z_ProgramPathFragmentInputGenNV(&program, location, genMode, components, coeffs);
    
    public z_ProgramSubroutineParametersuivNV: procedure(target: DummyEnum; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; count: Int32; &params: pointer)>(GetGLProcAdr('glProgramSubroutineParametersuivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; &params: array of UInt32) := ProgramSubroutineParametersuivNV(target, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; var &params: UInt32) := ProgramSubroutineParametersuivNV(target, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramSubroutineParametersuivNV(target: DummyEnum; count: Int32; &params: pointer) := z_ProgramSubroutineParametersuivNV(target, count, &params);
    
    public z_ShadingRateSampleOrderNV: procedure(order: DummyEnum) := FuncPtrOrNil&<procedure(order: DummyEnum)>(GetGLProcAdr('glShadingRateSampleOrderNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderNV(order: DummyEnum) := z_ShadingRateSampleOrderNV(order);
    
    public z_StencilFillPathInstancedNV: procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; transformType: DummyEnum; transformValues: pointer) := FuncPtrOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; transformType: DummyEnum; transformValues: pointer)>(GetGLProcAdr('glStencilFillPathInstancedNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; transformType: DummyEnum; transformValues: array of single) := StencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; transformType: DummyEnum; var transformValues: single) := StencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; transformType: DummyEnum; transformValues: pointer) := z_StencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
    
    public z_StencilFillPathNV: procedure(path: UInt32; fillMode: DummyEnum; mask: UInt32) := FuncPtrOrNil&<procedure(path: UInt32; fillMode: DummyEnum; mask: UInt32)>(GetGLProcAdr('glStencilFillPathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilFillPathNV(path: UInt32; fillMode: DummyEnum; mask: UInt32) := z_StencilFillPathNV(path, fillMode, mask);
    
    public z_StencilStrokePathInstancedNV: procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: DummyEnum; transformValues: pointer) := FuncPtrOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: DummyEnum; transformValues: pointer)>(GetGLProcAdr('glStencilStrokePathInstancedNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: DummyEnum; transformValues: array of single) := StencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: DummyEnum; var transformValues: single) := StencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; transformType: DummyEnum; transformValues: pointer) := z_StencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
    
    public z_StencilStrokePathNV: procedure(path: UInt32; reference: Int32; mask: UInt32) := FuncPtrOrNil&<procedure(path: UInt32; reference: Int32; mask: UInt32)>(GetGLProcAdr('glStencilStrokePathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilStrokePathNV(path: UInt32; reference: Int32; mask: UInt32) := z_StencilStrokePathNV(path, reference, mask);
    
    public z_StencilThenCoverFillPathInstancedNV: procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := FuncPtrOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer)>(GetGLProcAdr('glStencilThenCoverFillPathInstancedNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: array of single) := StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single) := StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := z_StencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
    
    public z_StencilThenCoverFillPathNV: procedure(path: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum) := FuncPtrOrNil&<procedure(path: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum)>(GetGLProcAdr('glStencilThenCoverFillPathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverFillPathNV(path: UInt32; fillMode: DummyEnum; mask: UInt32; coverMode: DummyEnum) := z_StencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
    
    public z_StencilThenCoverStrokePathInstancedNV: procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := FuncPtrOrNil&<procedure(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer)>(GetGLProcAdr('glStencilThenCoverStrokePathInstancedNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: array of single) := StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; var transformValues: single) := StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathInstancedNV(numPaths: Int32; pathNameType: DummyEnum; paths: pointer; pathBase: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum; transformType: DummyEnum; transformValues: pointer) := z_StencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
    
    public z_StencilThenCoverStrokePathNV: procedure(path: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum) := FuncPtrOrNil&<procedure(path: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum)>(GetGLProcAdr('glStencilThenCoverStrokePathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StencilThenCoverStrokePathNV(path: UInt32; reference: Int32; mask: UInt32; coverMode: DummyEnum) := z_StencilThenCoverStrokePathNV(path, reference, mask, coverMode);
    
    public z_TransformFeedbackStreamAttribsNV: procedure(count: Int32; attribs: pointer; nbuffers: Int32; bufstreams: pointer; bufferMode: DummyEnum) := FuncPtrOrNil&<procedure(count: Int32; attribs: pointer; nbuffers: Int32; bufstreams: pointer; bufferMode: DummyEnum)>(GetGLProcAdr('glTransformFeedbackStreamAttribsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: array of Int32; nbuffers: Int32; bufstreams: array of Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, attribs[0], nbuffers, bufstreams[0], bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: array of Int32; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, attribs[0], nbuffers, @bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: array of Int32; nbuffers: Int32; bufstreams: pointer; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, attribs[0], nbuffers, bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; var attribs: Int32; nbuffers: Int32; bufstreams: array of Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, @attribs, nbuffers, bufstreams[0], bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; var attribs: Int32; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, @attribs, nbuffers, @bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; var attribs: Int32; nbuffers: Int32; bufstreams: pointer; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, @attribs, nbuffers, bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: pointer; nbuffers: Int32; bufstreams: array of Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams[0], bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: pointer; nbuffers: Int32; var bufstreams: Int32; bufferMode: DummyEnum) := TransformFeedbackStreamAttribsNV(count, attribs, nbuffers, @bufstreams, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackStreamAttribsNV(count: Int32; attribs: pointer; nbuffers: Int32; bufstreams: pointer; bufferMode: DummyEnum) := z_TransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode);
    
    public z_TransformPathNV: procedure(resultPath: UInt32; srcPath: UInt32; transformType: DummyEnum; transformValues: pointer) := FuncPtrOrNil&<procedure(resultPath: UInt32; srcPath: UInt32; transformType: DummyEnum; transformValues: pointer)>(GetGLProcAdr('glTransformPathNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: DummyEnum; transformValues: array of single) := TransformPathNV(resultPath, srcPath, transformType, transformValues[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: DummyEnum; var transformValues: single) := TransformPathNV(resultPath, srcPath, transformType, @transformValues);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformPathNV(resultPath: UInt32; srcPath: UInt32; transformType: DummyEnum; transformValues: pointer) := z_TransformPathNV(resultPath, srcPath, transformType, transformValues);
    
    public z_WeightPathsNV: procedure(resultPath: UInt32; numPaths: Int32; paths: pointer; weights: pointer) := FuncPtrOrNil&<procedure(resultPath: UInt32; numPaths: Int32; paths: pointer; weights: pointer)>(GetGLProcAdr('glWeightPathsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: array of UInt32; weights: array of single) := WeightPathsNV(resultPath, numPaths, paths[0], weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: array of UInt32; var weights: single) := WeightPathsNV(resultPath, numPaths, paths[0], @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: array of UInt32; weights: pointer) := WeightPathsNV(resultPath, numPaths, paths[0], weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; var paths: UInt32; weights: array of single) := WeightPathsNV(resultPath, numPaths, @paths, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; var paths: UInt32; var weights: single) := WeightPathsNV(resultPath, numPaths, @paths, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; var paths: UInt32; weights: pointer) := WeightPathsNV(resultPath, numPaths, @paths, weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: pointer; weights: array of single) := WeightPathsNV(resultPath, numPaths, paths, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: pointer; var weights: single) := WeightPathsNV(resultPath, numPaths, paths, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WeightPathsNV(resultPath: UInt32; numPaths: Int32; paths: pointer; weights: pointer) := z_WeightPathsNV(resultPath, numPaths, paths, weights);
    
    {$endregion Unsorted}
    
    {$region NV_3dvision_settings}
    
    public z_StereoParameterfNV: procedure(pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: single)>(GetGLProcAdr('glStereoParameterfNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StereoParameterfNV(pname: DummyEnum; param: single) := z_StereoParameterfNV(pname, param);
    
    public z_StereoParameteriNV: procedure(pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: Int32)>(GetGLProcAdr('glStereoParameteriNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StereoParameteriNV(pname: DummyEnum; param: Int32) := z_StereoParameteriNV(pname, param);
    
    {$endregion NV_3dvision_settings}
    
    {$region NV_alpha_to_coverage_dither_control}
    
    public z_AlphaToCoverageDitherControlNV: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glAlphaToCoverageDitherControlNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaToCoverageDitherControlNV(mode: DummyEnum) := z_AlphaToCoverageDitherControlNV(mode);
    
    {$endregion NV_alpha_to_coverage_dither_control}
    
    {$region NV_bindless_multi_draw_indirect}
    
    public z_MultiDrawArraysIndirectBindlessNV: procedure(mode: DummyEnum; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32) := FuncPtrOrNil&<procedure(mode: DummyEnum; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(GetGLProcAdr('glMultiDrawArraysIndirectBindlessNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectBindlessNV(mode: DummyEnum; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32) := z_MultiDrawArraysIndirectBindlessNV(mode, indirect, drawCount, stride, vertexBufferCount);
    
    public z_MultiDrawElementsIndirectBindlessNV: procedure(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32) := FuncPtrOrNil&<procedure(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(GetGLProcAdr('glMultiDrawElementsIndirectBindlessNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectBindlessNV(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawCount: Int32; stride: Int32; vertexBufferCount: Int32) := z_MultiDrawElementsIndirectBindlessNV(mode, &type, indirect, drawCount, stride, vertexBufferCount);
    
    {$endregion NV_bindless_multi_draw_indirect}
    
    {$region NV_bindless_multi_draw_indirect_count}
    
    public z_MultiDrawArraysIndirectBindlessCountNV: procedure(mode: DummyEnum; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32) := FuncPtrOrNil&<procedure(mode: DummyEnum; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(GetGLProcAdr('glMultiDrawArraysIndirectBindlessCountNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawArraysIndirectBindlessCountNV(mode: DummyEnum; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32) := z_MultiDrawArraysIndirectBindlessCountNV(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    
    public z_MultiDrawElementsIndirectBindlessCountNV: procedure(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32) := FuncPtrOrNil&<procedure(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32)>(GetGLProcAdr('glMultiDrawElementsIndirectBindlessCountNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawElementsIndirectBindlessCountNV(mode: DummyEnum; &type: DummyEnum; indirect: pointer; drawCount: Int32; maxDrawCount: Int32; stride: Int32; vertexBufferCount: Int32) := z_MultiDrawElementsIndirectBindlessCountNV(mode, &type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
    
    {$endregion NV_bindless_multi_draw_indirect_count}
    
    {$region NV_blend_equation_advanced}
    
    public z_BlendParameteriNV: procedure(pname: DummyEnum; value: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; value: Int32)>(GetGLProcAdr('glBlendParameteriNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendParameteriNV(pname: DummyEnum; value: Int32) := z_BlendParameteriNV(pname, value);
    
    {$endregion NV_blend_equation_advanced}
    
    {$region NV_clip_space_w_scaling}
    
    public z_ViewportPositionWScaleNV: procedure(index: UInt32; xcoeff: single; ycoeff: single) := FuncPtrOrNil&<procedure(index: UInt32; xcoeff: single; ycoeff: single)>(GetGLProcAdr('glViewportPositionWScaleNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportPositionWScaleNV(index: UInt32; xcoeff: single; ycoeff: single) := z_ViewportPositionWScaleNV(index, xcoeff, ycoeff);
    
    {$endregion NV_clip_space_w_scaling}
    
    {$region NV_command_list}
    
    public z_CreateStatesNV: procedure(n: Int32; states: pointer) := FuncPtrOrNil&<procedure(n: Int32; states: pointer)>(GetGLProcAdr('glCreateStatesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; states: array of UInt32) := CreateStatesNV(n, states[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; var states: UInt32) := CreateStatesNV(n, @states);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateStatesNV(n: Int32; states: pointer) := z_CreateStatesNV(n, states);
    
    public z_DeleteStatesNV: procedure(n: Int32; states: pointer) := FuncPtrOrNil&<procedure(n: Int32; states: pointer)>(GetGLProcAdr('glDeleteStatesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; states: array of UInt32) := DeleteStatesNV(n, states[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; var states: UInt32) := DeleteStatesNV(n, @states);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteStatesNV(n: Int32; states: pointer) := z_DeleteStatesNV(n, states);
    
    public z_IsStateNV: function(state: UInt32): Byte := FuncPtrOrNil&<function(state: UInt32): Byte>(GetGLProcAdr('glIsStateNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsStateNV(state: UInt32): Byte := z_IsStateNV(state);
    
    public z_StateCaptureNV: procedure(state: UInt32; mode: DummyEnum) := FuncPtrOrNil&<procedure(state: UInt32; mode: DummyEnum)>(GetGLProcAdr('glStateCaptureNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StateCaptureNV(state: UInt32; mode: DummyEnum) := z_StateCaptureNV(state, mode);
    
    public z_GetCommandHeaderNV: function(tokenID: DummyEnum; size: UInt32): UInt32 := FuncPtrOrNil&<function(tokenID: DummyEnum; size: UInt32): UInt32>(GetGLProcAdr('glGetCommandHeaderNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetCommandHeaderNV(tokenID: DummyEnum; size: UInt32): UInt32 := z_GetCommandHeaderNV(tokenID, size);
    
    public z_GetStageIndexNV: function(shadertype: DummyEnum): UInt16 := FuncPtrOrNil&<function(shadertype: DummyEnum): UInt16>(GetGLProcAdr('glGetStageIndexNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetStageIndexNV(shadertype: DummyEnum): UInt16 := z_GetStageIndexNV(shadertype);
    
    public z_DrawCommandsNV: procedure(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: pointer; count: UInt32) := FuncPtrOrNil&<procedure(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: pointer; count: UInt32)>(GetGLProcAdr('glDrawCommandsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, indirects[0], sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, indirects[0], @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: array of IntPtr; sizes: pointer; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, indirects[0], sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, @indirects, sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; var sizes: Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, @indirects, @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; var indirects: IntPtr; sizes: pointer; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, @indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: array of Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, indirects, sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; var sizes: Int32; count: UInt32) := DrawCommandsNV(primitiveMode, buffer, indirects, @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsNV(primitiveMode: DummyEnum; buffer: UInt32; indirects: pointer; sizes: pointer; count: UInt32) := z_DrawCommandsNV(primitiveMode, buffer, indirects, sizes, count);
    
    public z_DrawCommandsAddressNV: procedure(primitiveMode: DummyEnum; indirects: pointer; sizes: pointer; count: UInt32) := FuncPtrOrNil&<procedure(primitiveMode: DummyEnum; indirects: pointer; sizes: pointer; count: UInt32)>(GetGLProcAdr('glDrawCommandsAddressNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: array of UInt64; sizes: array of Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, indirects[0], sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: array of UInt64; var sizes: Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, indirects[0], @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: array of UInt64; sizes: pointer; count: UInt32) := DrawCommandsAddressNV(primitiveMode, indirects[0], sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; var indirects: UInt64; sizes: array of Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, @indirects, sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; var indirects: UInt64; var sizes: Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, @indirects, @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; var indirects: UInt64; sizes: pointer; count: UInt32) := DrawCommandsAddressNV(primitiveMode, @indirects, sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: pointer; sizes: array of Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, indirects, sizes[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: pointer; var sizes: Int32; count: UInt32) := DrawCommandsAddressNV(primitiveMode, indirects, @sizes, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsAddressNV(primitiveMode: DummyEnum; indirects: pointer; sizes: pointer; count: UInt32) := z_DrawCommandsAddressNV(primitiveMode, indirects, sizes, count);
    
    public z_DrawCommandsStatesNV: procedure(buffer: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := FuncPtrOrNil&<procedure(buffer: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32)>(GetGLProcAdr('glDrawCommandsStatesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects[0], sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, @indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesNV(buffer, indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesNV(buffer: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := z_DrawCommandsStatesNV(buffer, indirects, sizes, states, fbos, count);
    
    public z_DrawCommandsStatesAddressNV: procedure(indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := FuncPtrOrNil&<procedure(indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32)>(GetGLProcAdr('glDrawCommandsStatesAddressNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: array of UInt64; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects[0], sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(var indirects: UInt64; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(@indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := DrawCommandsStatesAddressNV(indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawCommandsStatesAddressNV(indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := z_DrawCommandsStatesAddressNV(indirects, sizes, states, fbos, count);
    
    public z_CreateCommandListsNV: procedure(n: Int32; lists: pointer) := FuncPtrOrNil&<procedure(n: Int32; lists: pointer)>(GetGLProcAdr('glCreateCommandListsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; lists: array of UInt32) := CreateCommandListsNV(n, lists[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; var lists: UInt32) := CreateCommandListsNV(n, @lists);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CreateCommandListsNV(n: Int32; lists: pointer) := z_CreateCommandListsNV(n, lists);
    
    public z_DeleteCommandListsNV: procedure(n: Int32; lists: pointer) := FuncPtrOrNil&<procedure(n: Int32; lists: pointer)>(GetGLProcAdr('glDeleteCommandListsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; lists: array of UInt32) := DeleteCommandListsNV(n, lists[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; var lists: UInt32) := DeleteCommandListsNV(n, @lists);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteCommandListsNV(n: Int32; lists: pointer) := z_DeleteCommandListsNV(n, lists);
    
    public z_IsCommandListNV: function(list: UInt32): Byte := FuncPtrOrNil&<function(list: UInt32): Byte>(GetGLProcAdr('glIsCommandListNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsCommandListNV(list: UInt32): Byte := z_IsCommandListNV(list);
    
    public z_ListDrawCommandsStatesClientNV: procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := FuncPtrOrNil&<procedure(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32)>(GetGLProcAdr('glListDrawCommandsStatesClientNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: array of IntPtr; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects[0], sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; var indirects: IntPtr; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, @indirects, sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: array of Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes[0], states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; var sizes: Int32; states: pointer; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, @sizes, states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states[0], fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states[0], @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: array of UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states[0], fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, @states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, @states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; var states: UInt32; fbos: pointer; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, @states, fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: array of UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, fbos[0], count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: pointer; var fbos: UInt32; count: UInt32) := ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, @fbos, count);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListDrawCommandsStatesClientNV(list: UInt32; segment: UInt32; indirects: pointer; sizes: pointer; states: pointer; fbos: pointer; count: UInt32) := z_ListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, fbos, count);
    
    public z_CommandListSegmentsNV: procedure(list: UInt32; segments: UInt32) := FuncPtrOrNil&<procedure(list: UInt32; segments: UInt32)>(GetGLProcAdr('glCommandListSegmentsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CommandListSegmentsNV(list: UInt32; segments: UInt32) := z_CommandListSegmentsNV(list, segments);
    
    public z_CompileCommandListNV: procedure(list: UInt32) := FuncPtrOrNil&<procedure(list: UInt32)>(GetGLProcAdr('glCompileCommandListNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CompileCommandListNV(list: UInt32) := z_CompileCommandListNV(list);
    
    public z_CallCommandListNV: procedure(list: UInt32) := FuncPtrOrNil&<procedure(list: UInt32)>(GetGLProcAdr('glCallCommandListNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CallCommandListNV(list: UInt32) := z_CallCommandListNV(list);
    
    {$endregion NV_command_list}
    
    {$region NV_conservative_raster}
    
    public z_SubpixelPrecisionBiasNV: procedure(xbits: UInt32; ybits: UInt32) := FuncPtrOrNil&<procedure(xbits: UInt32; ybits: UInt32)>(GetGLProcAdr('glSubpixelPrecisionBiasNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SubpixelPrecisionBiasNV(xbits: UInt32; ybits: UInt32) := z_SubpixelPrecisionBiasNV(xbits, ybits);
    
    {$endregion NV_conservative_raster}
    
    {$region NV_conservative_raster_dilate}
    
    public z_ConservativeRasterParameterfNV: procedure(pname: DummyEnum; value: single) := FuncPtrOrNil&<procedure(pname: DummyEnum; value: single)>(GetGLProcAdr('glConservativeRasterParameterfNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConservativeRasterParameterfNV(pname: DummyEnum; value: single) := z_ConservativeRasterParameterfNV(pname, value);
    
    {$endregion NV_conservative_raster_dilate}
    
    {$region NV_conservative_raster_pre_snap_triangles}
    
    public z_ConservativeRasterParameteriNV: procedure(pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: Int32)>(GetGLProcAdr('glConservativeRasterParameteriNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConservativeRasterParameteriNV(pname: DummyEnum; param: Int32) := z_ConservativeRasterParameteriNV(pname, param);
    
    {$endregion NV_conservative_raster_pre_snap_triangles}
    
    {$region NV_coverage_sample}
    
    public z_CoverageMaskNV: procedure(mask: Byte) := FuncPtrOrNil&<procedure(mask: Byte)>(GetGLProcAdr('glCoverageMaskNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageMaskNV(mask: Byte) := z_CoverageMaskNV(mask);
    
    public z_CoverageOperationNV: procedure(operation: DummyEnum) := FuncPtrOrNil&<procedure(operation: DummyEnum)>(GetGLProcAdr('glCoverageOperationNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageOperationNV(operation: DummyEnum) := z_CoverageOperationNV(operation);
    
    {$endregion NV_coverage_sample}
    
    {$region NV_depth_buffer_float}
    
    public z_DepthRangedNV: procedure(zNear: double; zFar: double) := FuncPtrOrNil&<procedure(zNear: double; zFar: double)>(GetGLProcAdr('glDepthRangedNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangedNV(zNear: double; zFar: double) := z_DepthRangedNV(zNear, zFar);
    
    public z_ClearDepthdNV: procedure(depth: double) := FuncPtrOrNil&<procedure(depth: double)>(GetGLProcAdr('glClearDepthdNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthdNV(depth: double) := z_ClearDepthdNV(depth);
    
    public z_DepthBoundsdNV: procedure(zmin: double; zmax: double) := FuncPtrOrNil&<procedure(zmin: double; zmax: double)>(GetGLProcAdr('glDepthBoundsdNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthBoundsdNV(zmin: double; zmax: double) := z_DepthBoundsdNV(zmin, zmax);
    
    {$endregion NV_depth_buffer_float}
    
    {$region NV_draw_texture}
    
    public z_DrawTextureNV: procedure(texture: UInt32; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single) := FuncPtrOrNil&<procedure(texture: UInt32; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single)>(GetGLProcAdr('glDrawTextureNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTextureNV(texture: UInt32; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single) := z_DrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    
    {$endregion NV_draw_texture}
    
    {$region NV_draw_vulkan_image}
    
    public z_DrawVkImageNV: procedure(vkImage: UInt64; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single) := FuncPtrOrNil&<procedure(vkImage: UInt64; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single)>(GetGLProcAdr('glDrawVkImageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawVkImageNV(vkImage: UInt64; sampler: UInt32; x0: single; y0: single; x1: single; y1: single; z: single; s0: single; t0: single; s1: single; t1: single) := z_DrawVkImageNV(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
    
    public z_GetVkProcAddrNV: function(name: IntPtr): GLVULKANPROCNV := FuncPtrOrNil&<function(name: IntPtr): GLVULKANPROCNV>(GetGLProcAdr('glGetVkProcAddrNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVkProcAddrNV(name: string): GLVULKANPROCNV; begin var ptr1 := Marshal.StringToHGlobalAnsi(name); Result := GetVkProcAddrNV(ptr1); name := Marshal.PtrToStringAnsi(ptr1); Marshal.FreeHGlobal(ptr1); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVkProcAddrNV(name: IntPtr): GLVULKANPROCNV := z_GetVkProcAddrNV(name);
    
    public z_WaitVkSemaphoreNV: procedure(vkSemaphore: UInt64) := FuncPtrOrNil&<procedure(vkSemaphore: UInt64)>(GetGLProcAdr('glWaitVkSemaphoreNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitVkSemaphoreNV(vkSemaphore: UInt64) := z_WaitVkSemaphoreNV(vkSemaphore);
    
    public z_SignalVkSemaphoreNV: procedure(vkSemaphore: UInt64) := FuncPtrOrNil&<procedure(vkSemaphore: UInt64)>(GetGLProcAdr('glSignalVkSemaphoreNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalVkSemaphoreNV(vkSemaphore: UInt64) := z_SignalVkSemaphoreNV(vkSemaphore);
    
    public z_SignalVkFenceNV: procedure(vkFence: UInt64) := FuncPtrOrNil&<procedure(vkFence: UInt64)>(GetGLProcAdr('glSignalVkFenceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalVkFenceNV(vkFence: UInt64) := z_SignalVkFenceNV(vkFence);
    
    {$endregion NV_draw_vulkan_image}
    
    {$region NV_evaluators}
    
    public z_MapControlPointsNV: procedure(target: DummyEnum; index: UInt32; &type: DummyEnum; ustride: Int32; vstride: Int32; uorder: Int32; vorder: Int32; &packed: Byte; points: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &type: DummyEnum; ustride: Int32; vstride: Int32; uorder: Int32; vorder: Int32; &packed: Byte; points: pointer)>(GetGLProcAdr('glMapControlPointsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapControlPointsNV(target: DummyEnum; index: UInt32; &type: DummyEnum; ustride: Int32; vstride: Int32; uorder: Int32; vorder: Int32; &packed: Byte; points: pointer) := z_MapControlPointsNV(target, index, &type, ustride, vstride, uorder, vorder, &packed, points);
    
    public z_MapParameterivNV: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMapParameterivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := MapParameterivNV(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: DummyEnum; pname: DummyEnum; var &params: Int32) := MapParameterivNV(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterivNV(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MapParameterivNV(target, pname, &params);
    
    public z_MapParameterfvNV: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMapParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: DummyEnum; pname: DummyEnum; &params: array of single) := MapParameterfvNV(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: DummyEnum; pname: DummyEnum; var &params: single) := MapParameterfvNV(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapParameterfvNV(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_MapParameterfvNV(target, pname, &params);
    
    public z_GetMapControlPointsNV: procedure(target: DummyEnum; index: UInt32; &type: DummyEnum; ustride: Int32; vstride: Int32; &packed: Byte; points: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &type: DummyEnum; ustride: Int32; vstride: Int32; &packed: Byte; points: pointer)>(GetGLProcAdr('glGetMapControlPointsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapControlPointsNV(target: DummyEnum; index: UInt32; &type: DummyEnum; ustride: Int32; vstride: Int32; &packed: Byte; points: pointer) := z_GetMapControlPointsNV(target, index, &type, ustride, vstride, &packed, points);
    
    public z_GetMapParameterivNV: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMapParameterivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterivNV(target: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetMapParameterivNV(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterivNV(target: DummyEnum; pname: DummyEnum; var &params: Int32) := GetMapParameterivNV(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterivNV(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMapParameterivNV(target, pname, &params);
    
    public z_GetMapParameterfvNV: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMapParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterfvNV(target: DummyEnum; pname: DummyEnum; &params: array of single) := GetMapParameterfvNV(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterfvNV(target: DummyEnum; pname: DummyEnum; var &params: single) := GetMapParameterfvNV(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapParameterfvNV(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetMapParameterfvNV(target, pname, &params);
    
    public z_GetMapAttribParameterivNV: procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMapAttribParameterivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterivNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: array of Int32) := GetMapAttribParameterivNV(target, index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterivNV(target: DummyEnum; index: UInt32; pname: DummyEnum; var &params: Int32) := GetMapAttribParameterivNV(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterivNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := z_GetMapAttribParameterivNV(target, index, pname, &params);
    
    public z_GetMapAttribParameterfvNV: procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetMapAttribParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: array of single) := GetMapAttribParameterfvNV(target, index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; var &params: single) := GetMapAttribParameterfvNV(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapAttribParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := z_GetMapAttribParameterfvNV(target, index, pname, &params);
    
    public z_EvalMapsNV: procedure(target: DummyEnum; mode: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum; mode: DummyEnum)>(GetGLProcAdr('glEvalMapsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalMapsNV(target: DummyEnum; mode: DummyEnum) := z_EvalMapsNV(target, mode);
    
    {$endregion NV_evaluators}
    
    {$region NV_explicit_multisample}
    
    public z_SampleMaskIndexedNV: procedure(index: UInt32; mask: DummyFlags) := FuncPtrOrNil&<procedure(index: UInt32; mask: DummyFlags)>(GetGLProcAdr('glSampleMaskIndexedNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleMaskIndexedNV(index: UInt32; mask: DummyFlags) := z_SampleMaskIndexedNV(index, mask);
    
    public z_TexRenderbufferNV: procedure(target: DummyEnum; renderbuffer: UInt32) := FuncPtrOrNil&<procedure(target: DummyEnum; renderbuffer: UInt32)>(GetGLProcAdr('glTexRenderbufferNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexRenderbufferNV(target: DummyEnum; renderbuffer: UInt32) := z_TexRenderbufferNV(target, renderbuffer);
    
    {$endregion NV_explicit_multisample}
    
    {$region NV_fence}
    
    public z_GetFenceivNV: procedure(fence: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(fence: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetFenceivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFenceivNV(fence: UInt32; pname: DummyEnum; &params: array of Int32) := GetFenceivNV(fence, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFenceivNV(fence: UInt32; pname: DummyEnum; var &params: Int32) := GetFenceivNV(fence, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFenceivNV(fence: UInt32; pname: DummyEnum; &params: pointer) := z_GetFenceivNV(fence, pname, &params);
    
    {$endregion NV_fence}
    
    {$region NV_fragment_coverage_to_color}
    
    public z_FragmentCoverageColorNV: procedure(color: UInt32) := FuncPtrOrNil&<procedure(color: UInt32)>(GetGLProcAdr('glFragmentCoverageColorNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentCoverageColorNV(color: UInt32) := z_FragmentCoverageColorNV(color);
    
    {$endregion NV_fragment_coverage_to_color}
    
    {$region NV_fragment_program}
    
    public z_ProgramNamedParameter4fNV: procedure(id: UInt32; len: Int32; name: pointer; x: single; y: single; z: single; w: single) := FuncPtrOrNil&<procedure(id: UInt32; len: Int32; name: pointer; x: single; y: single; z: single; w: single)>(GetGLProcAdr('glProgramNamedParameter4fNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: UInt32; len: Int32; name: array of Byte; x: single; y: single; z: single; w: single) := ProgramNamedParameter4fNV(id, len, name[0], x, y, z, w);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: UInt32; len: Int32; var name: Byte; x: single; y: single; z: single; w: single) := ProgramNamedParameter4fNV(id, len, @name, x, y, z, w);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fNV(id: UInt32; len: Int32; name: pointer; x: single; y: single; z: single; w: single) := z_ProgramNamedParameter4fNV(id, len, name, x, y, z, w);
    
    public z_ProgramNamedParameter4dNV: procedure(id: UInt32; len: Int32; name: pointer; x: double; y: double; z: double; w: double) := FuncPtrOrNil&<procedure(id: UInt32; len: Int32; name: pointer; x: double; y: double; z: double; w: double)>(GetGLProcAdr('glProgramNamedParameter4dNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: UInt32; len: Int32; name: array of Byte; x: double; y: double; z: double; w: double) := ProgramNamedParameter4dNV(id, len, name[0], x, y, z, w);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: UInt32; len: Int32; var name: Byte; x: double; y: double; z: double; w: double) := ProgramNamedParameter4dNV(id, len, @name, x, y, z, w);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dNV(id: UInt32; len: Int32; name: pointer; x: double; y: double; z: double; w: double) := z_ProgramNamedParameter4dNV(id, len, name, x, y, z, w);
    
    public z_ProgramNamedParameter4fvNV: procedure(id: UInt32; len: Int32; name: pointer; v: pointer) := FuncPtrOrNil&<procedure(id: UInt32; len: Int32; name: pointer; v: pointer)>(GetGLProcAdr('glProgramNamedParameter4fvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: array of Byte; v: array of single) := ProgramNamedParameter4fvNV(id, len, name[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: array of Byte; var v: single) := ProgramNamedParameter4fvNV(id, len, name[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: array of Byte; v: pointer) := ProgramNamedParameter4fvNV(id, len, name[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; var name: Byte; v: array of single) := ProgramNamedParameter4fvNV(id, len, @name, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; var name: Byte; var v: single) := ProgramNamedParameter4fvNV(id, len, @name, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; var name: Byte; v: pointer) := ProgramNamedParameter4fvNV(id, len, @name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: pointer; v: array of single) := ProgramNamedParameter4fvNV(id, len, name, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: pointer; var v: single) := ProgramNamedParameter4fvNV(id, len, name, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4fvNV(id: UInt32; len: Int32; name: pointer; v: pointer) := z_ProgramNamedParameter4fvNV(id, len, name, v);
    
    public z_ProgramNamedParameter4dvNV: procedure(id: UInt32; len: Int32; name: pointer; v: pointer) := FuncPtrOrNil&<procedure(id: UInt32; len: Int32; name: pointer; v: pointer)>(GetGLProcAdr('glProgramNamedParameter4dvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: array of Byte; v: array of double) := ProgramNamedParameter4dvNV(id, len, name[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: array of Byte; var v: double) := ProgramNamedParameter4dvNV(id, len, name[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: array of Byte; v: pointer) := ProgramNamedParameter4dvNV(id, len, name[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; var name: Byte; v: array of double) := ProgramNamedParameter4dvNV(id, len, @name, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; var name: Byte; var v: double) := ProgramNamedParameter4dvNV(id, len, @name, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; var name: Byte; v: pointer) := ProgramNamedParameter4dvNV(id, len, @name, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: pointer; v: array of double) := ProgramNamedParameter4dvNV(id, len, name, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: pointer; var v: double) := ProgramNamedParameter4dvNV(id, len, name, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramNamedParameter4dvNV(id: UInt32; len: Int32; name: pointer; v: pointer) := z_ProgramNamedParameter4dvNV(id, len, name, v);
    
    public z_GetProgramNamedParameterfvNV: procedure(id: UInt32; len: Int32; name: pointer; &params: pointer) := FuncPtrOrNil&<procedure(id: UInt32; len: Int32; name: pointer; &params: pointer)>(GetGLProcAdr('glGetProgramNamedParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: array of Byte; &params: array of single) := GetProgramNamedParameterfvNV(id, len, name[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: array of Byte; var &params: single) := GetProgramNamedParameterfvNV(id, len, name[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: array of Byte; &params: pointer) := GetProgramNamedParameterfvNV(id, len, name[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; var name: Byte; &params: array of single) := GetProgramNamedParameterfvNV(id, len, @name, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; var name: Byte; var &params: single) := GetProgramNamedParameterfvNV(id, len, @name, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; var name: Byte; &params: pointer) := GetProgramNamedParameterfvNV(id, len, @name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: pointer; &params: array of single) := GetProgramNamedParameterfvNV(id, len, name, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: pointer; var &params: single) := GetProgramNamedParameterfvNV(id, len, name, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterfvNV(id: UInt32; len: Int32; name: pointer; &params: pointer) := z_GetProgramNamedParameterfvNV(id, len, name, &params);
    
    public z_GetProgramNamedParameterdvNV: procedure(id: UInt32; len: Int32; name: pointer; &params: pointer) := FuncPtrOrNil&<procedure(id: UInt32; len: Int32; name: pointer; &params: pointer)>(GetGLProcAdr('glGetProgramNamedParameterdvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: array of Byte; &params: array of double) := GetProgramNamedParameterdvNV(id, len, name[0], &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: array of Byte; var &params: double) := GetProgramNamedParameterdvNV(id, len, name[0], @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: array of Byte; &params: pointer) := GetProgramNamedParameterdvNV(id, len, name[0], &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; var name: Byte; &params: array of double) := GetProgramNamedParameterdvNV(id, len, @name, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; var name: Byte; var &params: double) := GetProgramNamedParameterdvNV(id, len, @name, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; var name: Byte; &params: pointer) := GetProgramNamedParameterdvNV(id, len, @name, &params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: pointer; &params: array of double) := GetProgramNamedParameterdvNV(id, len, name, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: pointer; var &params: double) := GetProgramNamedParameterdvNV(id, len, name, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramNamedParameterdvNV(id: UInt32; len: Int32; name: pointer; &params: pointer) := z_GetProgramNamedParameterdvNV(id, len, name, &params);
    
    {$endregion NV_fragment_program}
    
    {$region NV_framebuffer_mixed_samples}
    
    public z_CoverageModulationTableNV: procedure(n: Int32; v: pointer) := FuncPtrOrNil&<procedure(n: Int32; v: pointer)>(GetGLProcAdr('glCoverageModulationTableNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; v: array of single) := CoverageModulationTableNV(n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; var v: single) := CoverageModulationTableNV(n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationTableNV(n: Int32; v: pointer) := z_CoverageModulationTableNV(n, v);
    
    public z_GetCoverageModulationTableNV: procedure(bufsize: Int32; v: pointer) := FuncPtrOrNil&<procedure(bufsize: Int32; v: pointer)>(GetGLProcAdr('glGetCoverageModulationTableNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCoverageModulationTableNV(bufsize: Int32; v: array of single) := GetCoverageModulationTableNV(bufsize, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCoverageModulationTableNV(bufsize: Int32; var v: single) := GetCoverageModulationTableNV(bufsize, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCoverageModulationTableNV(bufsize: Int32; v: pointer) := z_GetCoverageModulationTableNV(bufsize, v);
    
    public z_CoverageModulationNV: procedure(components: DummyEnum) := FuncPtrOrNil&<procedure(components: DummyEnum)>(GetGLProcAdr('glCoverageModulationNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CoverageModulationNV(components: DummyEnum) := z_CoverageModulationNV(components);
    
    {$endregion NV_framebuffer_mixed_samples}
    
    {$region NV_framebuffer_multisample_coverage}
    
    public z_RenderbufferStorageMultisampleCoverageNV: procedure(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32)>(GetGLProcAdr('glRenderbufferStorageMultisampleCoverageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderbufferStorageMultisampleCoverageNV(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalformat: DummyEnum; width: Int32; height: Int32) := z_RenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
    
    {$endregion NV_framebuffer_multisample_coverage}
    
    {$region NV_geometry_program4}
    
    public z_ProgramVertexLimitNV: procedure(target: DummyEnum; limit: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; limit: Int32)>(GetGLProcAdr('glProgramVertexLimitNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramVertexLimitNV(target: DummyEnum; limit: Int32) := z_ProgramVertexLimitNV(target, limit);
    
    {$endregion NV_geometry_program4}
    
    {$region NV_gpu_multicast}
    
    public z_RenderGpuMaskNV: procedure(mask: DummyFlags) := FuncPtrOrNil&<procedure(mask: DummyFlags)>(GetGLProcAdr('glRenderGpuMaskNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RenderGpuMaskNV(mask: DummyFlags) := z_RenderGpuMaskNV(mask);
    
    public z_MulticastBufferSubDataNV: procedure(gpuMask: DummyFlags; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer) := FuncPtrOrNil&<procedure(gpuMask: DummyFlags; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer)>(GetGLProcAdr('glMulticastBufferSubDataNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBufferSubDataNV(gpuMask: DummyFlags; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer) := z_MulticastBufferSubDataNV(gpuMask, buffer, offset, size, data);
    
    public z_MulticastCopyBufferSubDataNV: procedure(readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := FuncPtrOrNil&<procedure(readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr)>(GetGLProcAdr('glMulticastCopyBufferSubDataNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastCopyBufferSubDataNV(readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr) := z_MulticastCopyBufferSubDataNV(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
    
    public z_MulticastCopyImageSubDataNV: procedure(srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) := FuncPtrOrNil&<procedure(srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32)>(GetGLProcAdr('glMulticastCopyImageSubDataNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastCopyImageSubDataNV(srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32) := z_MulticastCopyImageSubDataNV(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
    
    public z_MulticastBlitFramebufferNV: procedure(srcGpu: UInt32; dstGpu: UInt32; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := FuncPtrOrNil&<procedure(srcGpu: UInt32; dstGpu: UInt32; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum)>(GetGLProcAdr('glMulticastBlitFramebufferNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBlitFramebufferNV(srcGpu: UInt32; dstGpu: UInt32; srcX0: Int32; srcY0: Int32; srcX1: Int32; srcY1: Int32; dstX0: Int32; dstY0: Int32; dstX1: Int32; dstY1: Int32; mask: DummyFlags; filter: DummyEnum) := z_MulticastBlitFramebufferNV(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
    
    public z_MulticastFramebufferSampleLocationsfvNV: procedure(gpu: UInt32; framebuffer: UInt32; start: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(gpu: UInt32; framebuffer: UInt32; start: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glMulticastFramebufferSampleLocationsfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: UInt32; start: UInt32; count: Int32; v: array of single) := MulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: UInt32; start: UInt32; count: Int32; var v: single) := MulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastFramebufferSampleLocationsfvNV(gpu: UInt32; framebuffer: UInt32; start: UInt32; count: Int32; v: pointer) := z_MulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v);
    
    public z_MulticastBarrierNV: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glMulticastBarrierNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastBarrierNV := z_MulticastBarrierNV();
    
    public z_MulticastWaitSyncNV: procedure(signalGpu: UInt32; waitGpuMask: DummyFlags) := FuncPtrOrNil&<procedure(signalGpu: UInt32; waitGpuMask: DummyFlags)>(GetGLProcAdr('glMulticastWaitSyncNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastWaitSyncNV(signalGpu: UInt32; waitGpuMask: DummyFlags) := z_MulticastWaitSyncNV(signalGpu, waitGpuMask);
    
    public z_MulticastGetQueryObjectivNV: procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMulticastGetQueryObjectivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of Int32) := MulticastGetQueryObjectivNV(gpu, id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int32) := MulticastGetQueryObjectivNV(gpu, id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := z_MulticastGetQueryObjectivNV(gpu, id, pname, &params);
    
    public z_MulticastGetQueryObjectuivNV: procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMulticastGetQueryObjectuivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of UInt32) := MulticastGetQueryObjectuivNV(gpu, id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt32) := MulticastGetQueryObjectuivNV(gpu, id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectuivNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := z_MulticastGetQueryObjectuivNV(gpu, id, pname, &params);
    
    public z_MulticastGetQueryObjecti64vNV: procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMulticastGetQueryObjecti64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of Int64) := MulticastGetQueryObjecti64vNV(gpu, id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: Int64) := MulticastGetQueryObjecti64vNV(gpu, id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjecti64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := z_MulticastGetQueryObjecti64vNV(gpu, id, pname, &params);
    
    public z_MulticastGetQueryObjectui64vNV: procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glMulticastGetQueryObjectui64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: array of UInt64) := MulticastGetQueryObjectui64vNV(gpu, id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; var &params: UInt64) := MulticastGetQueryObjectui64vNV(gpu, id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastGetQueryObjectui64vNV(gpu: UInt32; id: UInt32; pname: DummyEnum; &params: pointer) := z_MulticastGetQueryObjectui64vNV(gpu, id, pname, &params);
    
    {$endregion NV_gpu_multicast}
    
    {$region NV_gpu_program4}
    
    public z_ProgramLocalParameterI4iNV: procedure(target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(GetGLProcAdr('glProgramLocalParameterI4iNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4iNV(target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := z_ProgramLocalParameterI4iNV(target, index, x, y, z, w);
    
    public z_ProgramLocalParameterI4ivNV: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glProgramLocalParameterI4ivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: DummyEnum; index: UInt32; &params: array of Int32) := ProgramLocalParameterI4ivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: DummyEnum; index: UInt32; var &params: Int32) := ProgramLocalParameterI4ivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4ivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramLocalParameterI4ivNV(target, index, &params);
    
    public z_ProgramLocalParametersI4ivNV: procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glProgramLocalParametersI4ivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; &params: array of Int32) := ProgramLocalParametersI4ivNV(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; var &params: Int32) := ProgramLocalParametersI4ivNV(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramLocalParametersI4ivNV(target, index, count, &params);
    
    public z_ProgramLocalParameterI4uiNV: procedure(target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(GetGLProcAdr('glProgramLocalParameterI4uiNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uiNV(target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := z_ProgramLocalParameterI4uiNV(target, index, x, y, z, w);
    
    public z_ProgramLocalParameterI4uivNV: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glProgramLocalParameterI4uivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: DummyEnum; index: UInt32; &params: array of UInt32) := ProgramLocalParameterI4uivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: DummyEnum; index: UInt32; var &params: UInt32) := ProgramLocalParameterI4uivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParameterI4uivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramLocalParameterI4uivNV(target, index, &params);
    
    public z_ProgramLocalParametersI4uivNV: procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glProgramLocalParametersI4uivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; &params: array of UInt32) := ProgramLocalParametersI4uivNV(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; var &params: UInt32) := ProgramLocalParametersI4uivNV(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramLocalParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramLocalParametersI4uivNV(target, index, count, &params);
    
    public z_ProgramEnvParameterI4iNV: procedure(target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32)>(GetGLProcAdr('glProgramEnvParameterI4iNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4iNV(target: DummyEnum; index: UInt32; x: Int32; y: Int32; z: Int32; w: Int32) := z_ProgramEnvParameterI4iNV(target, index, x, y, z, w);
    
    public z_ProgramEnvParameterI4ivNV: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glProgramEnvParameterI4ivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: DummyEnum; index: UInt32; &params: array of Int32) := ProgramEnvParameterI4ivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: DummyEnum; index: UInt32; var &params: Int32) := ProgramEnvParameterI4ivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4ivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramEnvParameterI4ivNV(target, index, &params);
    
    public z_ProgramEnvParametersI4ivNV: procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glProgramEnvParametersI4ivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; &params: array of Int32) := ProgramEnvParametersI4ivNV(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; var &params: Int32) := ProgramEnvParametersI4ivNV(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4ivNV(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramEnvParametersI4ivNV(target, index, count, &params);
    
    public z_ProgramEnvParameterI4uiNV: procedure(target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32)>(GetGLProcAdr('glProgramEnvParameterI4uiNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uiNV(target: DummyEnum; index: UInt32; x: UInt32; y: UInt32; z: UInt32; w: UInt32) := z_ProgramEnvParameterI4uiNV(target, index, x, y, z, w);
    
    public z_ProgramEnvParameterI4uivNV: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glProgramEnvParameterI4uivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: DummyEnum; index: UInt32; &params: array of UInt32) := ProgramEnvParameterI4uivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: DummyEnum; index: UInt32; var &params: UInt32) := ProgramEnvParameterI4uivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParameterI4uivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_ProgramEnvParameterI4uivNV(target, index, &params);
    
    public z_ProgramEnvParametersI4uivNV: procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glProgramEnvParametersI4uivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; &params: array of UInt32) := ProgramEnvParametersI4uivNV(target, index, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; var &params: UInt32) := ProgramEnvParametersI4uivNV(target, index, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramEnvParametersI4uivNV(target: DummyEnum; index: UInt32; count: Int32; &params: pointer) := z_ProgramEnvParametersI4uivNV(target, index, count, &params);
    
    public z_GetProgramLocalParameterIivNV: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetProgramLocalParameterIivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIivNV(target: DummyEnum; index: UInt32; &params: array of Int32) := GetProgramLocalParameterIivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIivNV(target: DummyEnum; index: UInt32; var &params: Int32) := GetProgramLocalParameterIivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramLocalParameterIivNV(target, index, &params);
    
    public z_GetProgramLocalParameterIuivNV: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetProgramLocalParameterIuivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIuivNV(target: DummyEnum; index: UInt32; &params: array of UInt32) := GetProgramLocalParameterIuivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIuivNV(target: DummyEnum; index: UInt32; var &params: UInt32) := GetProgramLocalParameterIuivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramLocalParameterIuivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramLocalParameterIuivNV(target, index, &params);
    
    public z_GetProgramEnvParameterIivNV: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetProgramEnvParameterIivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIivNV(target: DummyEnum; index: UInt32; &params: array of Int32) := GetProgramEnvParameterIivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIivNV(target: DummyEnum; index: UInt32; var &params: Int32) := GetProgramEnvParameterIivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramEnvParameterIivNV(target, index, &params);
    
    public z_GetProgramEnvParameterIuivNV: procedure(target: DummyEnum; index: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; &params: pointer)>(GetGLProcAdr('glGetProgramEnvParameterIuivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIuivNV(target: DummyEnum; index: UInt32; &params: array of UInt32) := GetProgramEnvParameterIuivNV(target, index, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIuivNV(target: DummyEnum; index: UInt32; var &params: UInt32) := GetProgramEnvParameterIuivNV(target, index, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramEnvParameterIuivNV(target: DummyEnum; index: UInt32; &params: pointer) := z_GetProgramEnvParameterIuivNV(target, index, &params);
    
    {$endregion NV_gpu_program4}
    
    {$region NV_half_float}
    
    public z_Vertex2hNV: procedure(x: half; y: half) := FuncPtrOrNil&<procedure(x: half; y: half)>(GetGLProcAdr('glVertex2hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hNV(x: half; y: half) := z_Vertex2hNV(x, y);
    
    public z_Vertex2hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glVertex2hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(v: array of half) := Vertex2hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(var v: half) := Vertex2hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2hvNV(v: pointer) := z_Vertex2hvNV(v);
    
    public z_Vertex3hNV: procedure(x: half; y: half; z: half) := FuncPtrOrNil&<procedure(x: half; y: half; z: half)>(GetGLProcAdr('glVertex3hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hNV(x: half; y: half; z: half) := z_Vertex3hNV(x, y, z);
    
    public z_Vertex3hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glVertex3hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(v: array of half) := Vertex3hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(var v: half) := Vertex3hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3hvNV(v: pointer) := z_Vertex3hvNV(v);
    
    public z_Vertex4hNV: procedure(x: half; y: half; z: half; w: half) := FuncPtrOrNil&<procedure(x: half; y: half; z: half; w: half)>(GetGLProcAdr('glVertex4hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hNV(x: half; y: half; z: half; w: half) := z_Vertex4hNV(x, y, z, w);
    
    public z_Vertex4hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glVertex4hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(v: array of half) := Vertex4hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(var v: half) := Vertex4hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4hvNV(v: pointer) := z_Vertex4hvNV(v);
    
    public z_Normal3hNV: procedure(nx: half; ny: half; nz: half) := FuncPtrOrNil&<procedure(nx: half; ny: half; nz: half)>(GetGLProcAdr('glNormal3hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hNV(nx: half; ny: half; nz: half) := z_Normal3hNV(nx, ny, nz);
    
    public z_Normal3hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glNormal3hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(v: array of half) := Normal3hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(var v: half) := Normal3hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3hvNV(v: pointer) := z_Normal3hvNV(v);
    
    public z_Color3hNV: procedure(red: half; green: half; blue: half) := FuncPtrOrNil&<procedure(red: half; green: half; blue: half)>(GetGLProcAdr('glColor3hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hNV(red: half; green: half; blue: half) := z_Color3hNV(red, green, blue);
    
    public z_Color3hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glColor3hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(v: array of half) := Color3hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(var v: half) := Color3hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3hvNV(v: pointer) := z_Color3hvNV(v);
    
    public z_Color4hNV: procedure(red: half; green: half; blue: half; alpha: half) := FuncPtrOrNil&<procedure(red: half; green: half; blue: half; alpha: half)>(GetGLProcAdr('glColor4hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hNV(red: half; green: half; blue: half; alpha: half) := z_Color4hNV(red, green, blue, alpha);
    
    public z_Color4hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glColor4hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(v: array of half) := Color4hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(var v: half) := Color4hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4hvNV(v: pointer) := z_Color4hvNV(v);
    
    public z_TexCoord1hNV: procedure(s: half) := FuncPtrOrNil&<procedure(s: half)>(GetGLProcAdr('glTexCoord1hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hNV(s: half) := z_TexCoord1hNV(s);
    
    public z_TexCoord1hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glTexCoord1hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(v: array of half) := TexCoord1hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(var v: half) := TexCoord1hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1hvNV(v: pointer) := z_TexCoord1hvNV(v);
    
    public z_TexCoord2hNV: procedure(s: half; t: half) := FuncPtrOrNil&<procedure(s: half; t: half)>(GetGLProcAdr('glTexCoord2hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hNV(s: half; t: half) := z_TexCoord2hNV(s, t);
    
    public z_TexCoord2hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glTexCoord2hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(v: array of half) := TexCoord2hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(var v: half) := TexCoord2hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2hvNV(v: pointer) := z_TexCoord2hvNV(v);
    
    public z_TexCoord3hNV: procedure(s: half; t: half; r: half) := FuncPtrOrNil&<procedure(s: half; t: half; r: half)>(GetGLProcAdr('glTexCoord3hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hNV(s: half; t: half; r: half) := z_TexCoord3hNV(s, t, r);
    
    public z_TexCoord3hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glTexCoord3hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(v: array of half) := TexCoord3hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(var v: half) := TexCoord3hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3hvNV(v: pointer) := z_TexCoord3hvNV(v);
    
    public z_TexCoord4hNV: procedure(s: half; t: half; r: half; q: half) := FuncPtrOrNil&<procedure(s: half; t: half; r: half; q: half)>(GetGLProcAdr('glTexCoord4hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hNV(s: half; t: half; r: half; q: half) := z_TexCoord4hNV(s, t, r, q);
    
    public z_TexCoord4hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glTexCoord4hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(v: array of half) := TexCoord4hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(var v: half) := TexCoord4hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4hvNV(v: pointer) := z_TexCoord4hvNV(v);
    
    public z_MultiTexCoord1hNV: procedure(target: DummyEnum; s: half) := FuncPtrOrNil&<procedure(target: DummyEnum; s: half)>(GetGLProcAdr('glMultiTexCoord1hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hNV(target: DummyEnum; s: half) := z_MultiTexCoord1hNV(target, s);
    
    public z_MultiTexCoord1hvNV: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord1hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: DummyEnum; v: array of half) := MultiTexCoord1hvNV(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: DummyEnum; var v: half) := MultiTexCoord1hvNV(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1hvNV(target: DummyEnum; v: pointer) := z_MultiTexCoord1hvNV(target, v);
    
    public z_MultiTexCoord2hNV: procedure(target: DummyEnum; s: half; t: half) := FuncPtrOrNil&<procedure(target: DummyEnum; s: half; t: half)>(GetGLProcAdr('glMultiTexCoord2hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hNV(target: DummyEnum; s: half; t: half) := z_MultiTexCoord2hNV(target, s, t);
    
    public z_MultiTexCoord2hvNV: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord2hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: DummyEnum; v: array of half) := MultiTexCoord2hvNV(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: DummyEnum; var v: half) := MultiTexCoord2hvNV(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2hvNV(target: DummyEnum; v: pointer) := z_MultiTexCoord2hvNV(target, v);
    
    public z_MultiTexCoord3hNV: procedure(target: DummyEnum; s: half; t: half; r: half) := FuncPtrOrNil&<procedure(target: DummyEnum; s: half; t: half; r: half)>(GetGLProcAdr('glMultiTexCoord3hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hNV(target: DummyEnum; s: half; t: half; r: half) := z_MultiTexCoord3hNV(target, s, t, r);
    
    public z_MultiTexCoord3hvNV: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord3hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: DummyEnum; v: array of half) := MultiTexCoord3hvNV(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: DummyEnum; var v: half) := MultiTexCoord3hvNV(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3hvNV(target: DummyEnum; v: pointer) := z_MultiTexCoord3hvNV(target, v);
    
    public z_MultiTexCoord4hNV: procedure(target: DummyEnum; s: half; t: half; r: half; q: half) := FuncPtrOrNil&<procedure(target: DummyEnum; s: half; t: half; r: half; q: half)>(GetGLProcAdr('glMultiTexCoord4hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hNV(target: DummyEnum; s: half; t: half; r: half; q: half) := z_MultiTexCoord4hNV(target, s, t, r, q);
    
    public z_MultiTexCoord4hvNV: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord4hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: DummyEnum; v: array of half) := MultiTexCoord4hvNV(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: DummyEnum; var v: half) := MultiTexCoord4hvNV(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4hvNV(target: DummyEnum; v: pointer) := z_MultiTexCoord4hvNV(target, v);
    
    public z_VertexAttrib1hNV: procedure(index: UInt32; x: half) := FuncPtrOrNil&<procedure(index: UInt32; x: half)>(GetGLProcAdr('glVertexAttrib1hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hNV(index: UInt32; x: half) := z_VertexAttrib1hNV(index, x);
    
    public z_VertexAttrib1hvNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttrib1hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; v: array of half) := VertexAttrib1hvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; var v: half) := VertexAttrib1hvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib1hvNV(index: UInt32; v: pointer) := z_VertexAttrib1hvNV(index, v);
    
    public z_VertexAttrib2hNV: procedure(index: UInt32; x: half; y: half) := FuncPtrOrNil&<procedure(index: UInt32; x: half; y: half)>(GetGLProcAdr('glVertexAttrib2hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hNV(index: UInt32; x: half; y: half) := z_VertexAttrib2hNV(index, x, y);
    
    public z_VertexAttrib2hvNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttrib2hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; v: array of half) := VertexAttrib2hvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; var v: half) := VertexAttrib2hvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib2hvNV(index: UInt32; v: pointer) := z_VertexAttrib2hvNV(index, v);
    
    public z_VertexAttrib3hNV: procedure(index: UInt32; x: half; y: half; z: half) := FuncPtrOrNil&<procedure(index: UInt32; x: half; y: half; z: half)>(GetGLProcAdr('glVertexAttrib3hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hNV(index: UInt32; x: half; y: half; z: half) := z_VertexAttrib3hNV(index, x, y, z);
    
    public z_VertexAttrib3hvNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttrib3hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; v: array of half) := VertexAttrib3hvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; var v: half) := VertexAttrib3hvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib3hvNV(index: UInt32; v: pointer) := z_VertexAttrib3hvNV(index, v);
    
    public z_VertexAttrib4hNV: procedure(index: UInt32; x: half; y: half; z: half; w: half) := FuncPtrOrNil&<procedure(index: UInt32; x: half; y: half; z: half; w: half)>(GetGLProcAdr('glVertexAttrib4hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hNV(index: UInt32; x: half; y: half; z: half; w: half) := z_VertexAttrib4hNV(index, x, y, z, w);
    
    public z_VertexAttrib4hvNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttrib4hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; v: array of half) := VertexAttrib4hvNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; var v: half) := VertexAttrib4hvNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4hvNV(index: UInt32; v: pointer) := z_VertexAttrib4hvNV(index, v);
    
    public z_VertexAttribs1hvNV: procedure(index: UInt32; n: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; n: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs1hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; v: array of half) := VertexAttribs1hvNV(index, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; var v: half) := VertexAttribs1hvNV(index, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1hvNV(index: UInt32; n: Int32; v: pointer) := z_VertexAttribs1hvNV(index, n, v);
    
    public z_VertexAttribs2hvNV: procedure(index: UInt32; n: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; n: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs2hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; v: array of half) := VertexAttribs2hvNV(index, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; var v: half) := VertexAttribs2hvNV(index, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2hvNV(index: UInt32; n: Int32; v: pointer) := z_VertexAttribs2hvNV(index, n, v);
    
    public z_VertexAttribs3hvNV: procedure(index: UInt32; n: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; n: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs3hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; v: array of half) := VertexAttribs3hvNV(index, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; var v: half) := VertexAttribs3hvNV(index, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3hvNV(index: UInt32; n: Int32; v: pointer) := z_VertexAttribs3hvNV(index, n, v);
    
    public z_VertexAttribs4hvNV: procedure(index: UInt32; n: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; n: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs4hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; v: array of half) := VertexAttribs4hvNV(index, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; var v: half) := VertexAttribs4hvNV(index, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4hvNV(index: UInt32; n: Int32; v: pointer) := z_VertexAttribs4hvNV(index, n, v);
    
    public z_FogCoordhNV: procedure(fog: half) := FuncPtrOrNil&<procedure(fog: half)>(GetGLProcAdr('glFogCoordhNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhNV(fog: half) := z_FogCoordhNV(fog);
    
    public z_FogCoordhvNV: procedure(fog: pointer) := FuncPtrOrNil&<procedure(fog: pointer)>(GetGLProcAdr('glFogCoordhvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(fog: array of half) := FogCoordhvNV(fog[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(var fog: half) := FogCoordhvNV(@fog);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordhvNV(fog: pointer) := z_FogCoordhvNV(fog);
    
    public z_SecondaryColor3hNV: procedure(red: half; green: half; blue: half) := FuncPtrOrNil&<procedure(red: half; green: half; blue: half)>(GetGLProcAdr('glSecondaryColor3hNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hNV(red: half; green: half; blue: half) := z_SecondaryColor3hNV(red, green, blue);
    
    public z_SecondaryColor3hvNV: procedure(v: pointer) := FuncPtrOrNil&<procedure(v: pointer)>(GetGLProcAdr('glSecondaryColor3hvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(v: array of half) := SecondaryColor3hvNV(v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(var v: half) := SecondaryColor3hvNV(@v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColor3hvNV(v: pointer) := z_SecondaryColor3hvNV(v);
    
    public z_VertexWeighthNV: procedure(weight: half) := FuncPtrOrNil&<procedure(weight: half)>(GetGLProcAdr('glVertexWeighthNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthNV(weight: half) := z_VertexWeighthNV(weight);
    
    public z_VertexWeighthvNV: procedure(weight: pointer) := FuncPtrOrNil&<procedure(weight: pointer)>(GetGLProcAdr('glVertexWeighthvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(weight: array of half) := VertexWeighthvNV(weight[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(var weight: half) := VertexWeighthvNV(@weight);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexWeighthvNV(weight: pointer) := z_VertexWeighthvNV(weight);
    
    {$endregion NV_half_float}
    
    {$region NV_internalformat_sample_query}
    
    public z_GetInternalformatSampleivNV: procedure(target: DummyEnum; internalformat: DummyEnum; samples: Int32; pname: DummyEnum; bufSize: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; internalformat: DummyEnum; samples: Int32; pname: DummyEnum; bufSize: Int32; &params: pointer)>(GetGLProcAdr('glGetInternalformatSampleivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformatSampleivNV(target: DummyEnum; internalformat: DummyEnum; samples: Int32; pname: DummyEnum; bufSize: Int32; &params: array of Int32) := GetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformatSampleivNV(target: DummyEnum; internalformat: DummyEnum; samples: Int32; pname: DummyEnum; bufSize: Int32; var &params: Int32) := GetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetInternalformatSampleivNV(target: DummyEnum; internalformat: DummyEnum; samples: Int32; pname: DummyEnum; bufSize: Int32; &params: pointer) := z_GetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, &params);
    
    {$endregion NV_internalformat_sample_query}
    
    {$region NV_memory_attachment}
    
    public z_GetMemoryObjectDetachedResourcesuivNV: procedure(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: pointer)>(GetGLProcAdr('glGetMemoryObjectDetachedResourcesuivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: array of UInt32) := GetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; var &params: UInt32) := GetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMemoryObjectDetachedResourcesuivNV(memory: UInt32; pname: DummyEnum; first: Int32; count: Int32; &params: pointer) := z_GetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, &params);
    
    public z_ResetMemoryObjectParameterNV: procedure(memory: UInt32; pname: DummyEnum) := FuncPtrOrNil&<procedure(memory: UInt32; pname: DummyEnum)>(GetGLProcAdr('glResetMemoryObjectParameterNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResetMemoryObjectParameterNV(memory: UInt32; pname: DummyEnum) := z_ResetMemoryObjectParameterNV(memory, pname);
    
    public z_TexAttachMemoryNV: procedure(target: DummyEnum; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(target: DummyEnum; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTexAttachMemoryNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexAttachMemoryNV(target: DummyEnum; memory: UInt32; offset: UInt64) := z_TexAttachMemoryNV(target, memory, offset);
    
    public z_BufferAttachMemoryNV: procedure(target: DummyEnum; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(target: DummyEnum; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glBufferAttachMemoryNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferAttachMemoryNV(target: DummyEnum; memory: UInt32; offset: UInt64) := z_BufferAttachMemoryNV(target, memory, offset);
    
    public z_TextureAttachMemoryNV: procedure(texture: UInt32; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(texture: UInt32; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glTextureAttachMemoryNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureAttachMemoryNV(texture: UInt32; memory: UInt32; offset: UInt64) := z_TextureAttachMemoryNV(texture, memory, offset);
    
    public z_NamedBufferAttachMemoryNV: procedure(buffer: UInt32; memory: UInt32; offset: UInt64) := FuncPtrOrNil&<procedure(buffer: UInt32; memory: UInt32; offset: UInt64)>(GetGLProcAdr('glNamedBufferAttachMemoryNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedBufferAttachMemoryNV(buffer: UInt32; memory: UInt32; offset: UInt64) := z_NamedBufferAttachMemoryNV(buffer, memory, offset);
    
    {$endregion NV_memory_attachment}
    
    {$region NV_mesh_shader}
    
    public z_DrawMeshTasksNV: procedure(first: UInt32; count: UInt32) := FuncPtrOrNil&<procedure(first: UInt32; count: UInt32)>(GetGLProcAdr('glDrawMeshTasksNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshTasksNV(first: UInt32; count: UInt32) := z_DrawMeshTasksNV(first, count);
    
    public z_DrawMeshTasksIndirectNV: procedure(indirect: IntPtr) := FuncPtrOrNil&<procedure(indirect: IntPtr)>(GetGLProcAdr('glDrawMeshTasksIndirectNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshTasksIndirectNV(indirect: IntPtr) := z_DrawMeshTasksIndirectNV(indirect);
    
    public z_MultiDrawMeshTasksIndirectNV: procedure(indirect: IntPtr; drawcount: Int32; stride: Int32) := FuncPtrOrNil&<procedure(indirect: IntPtr; drawcount: Int32; stride: Int32)>(GetGLProcAdr('glMultiDrawMeshTasksIndirectNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawMeshTasksIndirectNV(indirect: IntPtr; drawcount: Int32; stride: Int32) := z_MultiDrawMeshTasksIndirectNV(indirect, drawcount, stride);
    
    public z_MultiDrawMeshTasksIndirectCountNV: procedure(indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) := FuncPtrOrNil&<procedure(indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32)>(GetGLProcAdr('glMultiDrawMeshTasksIndirectCountNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiDrawMeshTasksIndirectCountNV(indirect: IntPtr; drawcount: IntPtr; maxdrawcount: Int32; stride: Int32) := z_MultiDrawMeshTasksIndirectCountNV(indirect, drawcount, maxdrawcount, stride);
    
    {$endregion NV_mesh_shader}
    
    {$region NV_occlusion_query}
    
    public z_GenOcclusionQueriesNV: procedure(n: Int32; ids: pointer) := FuncPtrOrNil&<procedure(n: Int32; ids: pointer)>(GetGLProcAdr('glGenOcclusionQueriesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; ids: array of UInt32) := GenOcclusionQueriesNV(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; var ids: UInt32) := GenOcclusionQueriesNV(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenOcclusionQueriesNV(n: Int32; ids: pointer) := z_GenOcclusionQueriesNV(n, ids);
    
    public z_DeleteOcclusionQueriesNV: procedure(n: Int32; ids: pointer) := FuncPtrOrNil&<procedure(n: Int32; ids: pointer)>(GetGLProcAdr('glDeleteOcclusionQueriesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; ids: array of UInt32) := DeleteOcclusionQueriesNV(n, ids[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; var ids: UInt32) := DeleteOcclusionQueriesNV(n, @ids);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteOcclusionQueriesNV(n: Int32; ids: pointer) := z_DeleteOcclusionQueriesNV(n, ids);
    
    public z_IsOcclusionQueryNV: function(id: UInt32): Byte := FuncPtrOrNil&<function(id: UInt32): Byte>(GetGLProcAdr('glIsOcclusionQueryNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsOcclusionQueryNV(id: UInt32): Byte := z_IsOcclusionQueryNV(id);
    
    public z_BeginOcclusionQueryNV: procedure(id: UInt32) := FuncPtrOrNil&<procedure(id: UInt32)>(GetGLProcAdr('glBeginOcclusionQueryNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BeginOcclusionQueryNV(id: UInt32) := z_BeginOcclusionQueryNV(id);
    
    public z_EndOcclusionQueryNV: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glEndOcclusionQueryNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndOcclusionQueryNV := z_EndOcclusionQueryNV();
    
    public z_GetOcclusionQueryivNV: procedure(id: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetOcclusionQueryivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryivNV(id: UInt32; pname: DummyEnum; &params: array of Int32) := GetOcclusionQueryivNV(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryivNV(id: UInt32; pname: DummyEnum; var &params: Int32) := GetOcclusionQueryivNV(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryivNV(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetOcclusionQueryivNV(id, pname, &params);
    
    public z_GetOcclusionQueryuivNV: procedure(id: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(id: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetOcclusionQueryuivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryuivNV(id: UInt32; pname: DummyEnum; &params: array of UInt32) := GetOcclusionQueryuivNV(id, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryuivNV(id: UInt32; pname: DummyEnum; var &params: UInt32) := GetOcclusionQueryuivNV(id, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetOcclusionQueryuivNV(id: UInt32; pname: DummyEnum; &params: pointer) := z_GetOcclusionQueryuivNV(id, pname, &params);
    
    {$endregion NV_occlusion_query}
    
    {$region NV_parameter_buffer_object}
    
    public z_ProgramBufferParametersfvNV: procedure(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glProgramBufferParametersfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of single) := ProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: single) := ProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersfvNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer) := z_ProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, &params);
    
    public z_ProgramBufferParametersIivNV: procedure(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glProgramBufferParametersIivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of Int32) := ProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: Int32) := ProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer) := z_ProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, &params);
    
    public z_ProgramBufferParametersIuivNV: procedure(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer)>(GetGLProcAdr('glProgramBufferParametersIuivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: array of UInt32) := ProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; var &params: UInt32) := ProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramBufferParametersIuivNV(target: DummyEnum; bindingIndex: UInt32; wordIndex: UInt32; count: Int32; &params: pointer) := z_ProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, &params);
    
    {$endregion NV_parameter_buffer_object}
    
    {$region NV_pixel_data_range}
    
    public z_PixelDataRangeNV: procedure(target: DummyEnum; length: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; length: Int32; _pointer: pointer)>(GetGLProcAdr('glPixelDataRangeNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelDataRangeNV(target: DummyEnum; length: Int32; _pointer: pointer) := z_PixelDataRangeNV(target, length, _pointer);
    
    public z_FlushPixelDataRangeNV: procedure(target: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum)>(GetGLProcAdr('glFlushPixelDataRangeNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushPixelDataRangeNV(target: DummyEnum) := z_FlushPixelDataRangeNV(target);
    
    {$endregion NV_pixel_data_range}
    
    {$region NV_primitive_restart}
    
    public z_PrimitiveRestartNV: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glPrimitiveRestartNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrimitiveRestartNV := z_PrimitiveRestartNV();
    
    {$endregion NV_primitive_restart}
    
    {$region NV_query_resource}
    
    public z_QueryResourceNV: function(queryType: DummyEnum; tagId: Int32; bufSize: UInt32; buffer: pointer): Int32 := FuncPtrOrNil&<function(queryType: DummyEnum; tagId: Int32; bufSize: UInt32; buffer: pointer): Int32>(GetGLProcAdr('glQueryResourceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; bufSize: UInt32; buffer: array of Int32): Int32 := QueryResourceNV(queryType, tagId, bufSize, buffer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; bufSize: UInt32; var buffer: Int32): Int32 := QueryResourceNV(queryType, tagId, bufSize, @buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryResourceNV(queryType: DummyEnum; tagId: Int32; bufSize: UInt32; buffer: pointer): Int32 := z_QueryResourceNV(queryType, tagId, bufSize, buffer);
    
    {$endregion NV_query_resource}
    
    {$region NV_query_resource_tag}
    
    public z_GenQueryResourceTagNV: procedure(n: Int32; tagIds: pointer) := FuncPtrOrNil&<procedure(n: Int32; tagIds: pointer)>(GetGLProcAdr('glGenQueryResourceTagNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; tagIds: array of Int32) := GenQueryResourceTagNV(n, tagIds[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; var tagIds: Int32) := GenQueryResourceTagNV(n, @tagIds);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GenQueryResourceTagNV(n: Int32; tagIds: pointer) := z_GenQueryResourceTagNV(n, tagIds);
    
    public z_DeleteQueryResourceTagNV: procedure(n: Int32; tagIds: pointer) := FuncPtrOrNil&<procedure(n: Int32; tagIds: pointer)>(GetGLProcAdr('glDeleteQueryResourceTagNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; tagIds: array of Int32) := DeleteQueryResourceTagNV(n, tagIds[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; var tagIds: Int32) := DeleteQueryResourceTagNV(n, @tagIds);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteQueryResourceTagNV(n: Int32; tagIds: pointer) := z_DeleteQueryResourceTagNV(n, tagIds);
    
    public z_QueryResourceTagNV: procedure(tagId: Int32; tagString: IntPtr) := FuncPtrOrNil&<procedure(tagId: Int32; tagString: IntPtr)>(GetGLProcAdr('glQueryResourceTagNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryResourceTagNV(tagId: Int32; tagString: string); begin var ptr2 := Marshal.StringToHGlobalAnsi(tagString); QueryResourceTagNV(tagId, ptr2); tagString := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure QueryResourceTagNV(tagId: Int32; tagString: IntPtr) := z_QueryResourceTagNV(tagId, tagString);
    
    {$endregion NV_query_resource_tag}
    
    {$region NV_register_combiners}
    
    public z_CombinerParameterfvNV: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glCombinerParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: DummyEnum; &params: array of single) := CombinerParameterfvNV(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: DummyEnum; var &params: single) := CombinerParameterfvNV(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfvNV(pname: DummyEnum; &params: pointer) := z_CombinerParameterfvNV(pname, &params);
    
    public z_CombinerParameterivNV: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glCombinerParameterivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: DummyEnum; &params: array of Int32) := CombinerParameterivNV(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: DummyEnum; var &params: Int32) := CombinerParameterivNV(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterivNV(pname: DummyEnum; &params: pointer) := z_CombinerParameterivNV(pname, &params);
    
    public z_CombinerParameterfNV: procedure(pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: single)>(GetGLProcAdr('glCombinerParameterfNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameterfNV(pname: DummyEnum; param: single) := z_CombinerParameterfNV(pname, param);
    
    public z_CombinerParameteriNV: procedure(pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: Int32)>(GetGLProcAdr('glCombinerParameteriNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerParameteriNV(pname: DummyEnum; param: Int32) := z_CombinerParameteriNV(pname, param);
    
    public z_CombinerInputNV: procedure(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; input: DummyEnum; mapping: DummyEnum; componentUsage: DummyEnum) := FuncPtrOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; input: DummyEnum; mapping: DummyEnum; componentUsage: DummyEnum)>(GetGLProcAdr('glCombinerInputNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerInputNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; input: DummyEnum; mapping: DummyEnum; componentUsage: DummyEnum) := z_CombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
    
    public z_CombinerOutputNV: procedure(stage: DummyEnum; portion: DummyEnum; abOutput: DummyEnum; cdOutput: DummyEnum; sumOutput: DummyEnum; scale: DummyEnum; bias: DummyEnum; abDotProduct: Byte; cdDotProduct: Byte; muxSum: Byte) := FuncPtrOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; abOutput: DummyEnum; cdOutput: DummyEnum; sumOutput: DummyEnum; scale: DummyEnum; bias: DummyEnum; abDotProduct: Byte; cdDotProduct: Byte; muxSum: Byte)>(GetGLProcAdr('glCombinerOutputNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerOutputNV(stage: DummyEnum; portion: DummyEnum; abOutput: DummyEnum; cdOutput: DummyEnum; sumOutput: DummyEnum; scale: DummyEnum; bias: DummyEnum; abDotProduct: Byte; cdDotProduct: Byte; muxSum: Byte) := z_CombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
    
    public z_FinalCombinerInputNV: procedure(variable: DummyEnum; input: DummyEnum; mapping: DummyEnum; componentUsage: DummyEnum) := FuncPtrOrNil&<procedure(variable: DummyEnum; input: DummyEnum; mapping: DummyEnum; componentUsage: DummyEnum)>(GetGLProcAdr('glFinalCombinerInputNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinalCombinerInputNV(variable: DummyEnum; input: DummyEnum; mapping: DummyEnum; componentUsage: DummyEnum) := z_FinalCombinerInputNV(variable, input, mapping, componentUsage);
    
    public z_GetCombinerInputParameterfvNV: procedure(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetCombinerInputParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterfvNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: array of single) := GetCombinerInputParameterfvNV(stage, portion, variable, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterfvNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; var &params: single) := GetCombinerInputParameterfvNV(stage, portion, variable, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterfvNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetCombinerInputParameterfvNV(stage, portion, variable, pname, &params);
    
    public z_GetCombinerInputParameterivNV: procedure(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetCombinerInputParameterivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterivNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetCombinerInputParameterivNV(stage, portion, variable, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterivNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; var &params: Int32) := GetCombinerInputParameterivNV(stage, portion, variable, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerInputParameterivNV(stage: DummyEnum; portion: DummyEnum; variable: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetCombinerInputParameterivNV(stage, portion, variable, pname, &params);
    
    public z_GetCombinerOutputParameterfvNV: procedure(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetCombinerOutputParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterfvNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: array of single) := GetCombinerOutputParameterfvNV(stage, portion, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterfvNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; var &params: single) := GetCombinerOutputParameterfvNV(stage, portion, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterfvNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetCombinerOutputParameterfvNV(stage, portion, pname, &params);
    
    public z_GetCombinerOutputParameterivNV: procedure(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetCombinerOutputParameterivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterivNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetCombinerOutputParameterivNV(stage, portion, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterivNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; var &params: Int32) := GetCombinerOutputParameterivNV(stage, portion, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerOutputParameterivNV(stage: DummyEnum; portion: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetCombinerOutputParameterivNV(stage, portion, pname, &params);
    
    public z_GetFinalCombinerInputParameterfvNV: procedure(variable: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(variable: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetFinalCombinerInputParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterfvNV(variable: DummyEnum; pname: DummyEnum; &params: array of single) := GetFinalCombinerInputParameterfvNV(variable, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterfvNV(variable: DummyEnum; pname: DummyEnum; var &params: single) := GetFinalCombinerInputParameterfvNV(variable, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterfvNV(variable: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetFinalCombinerInputParameterfvNV(variable, pname, &params);
    
    public z_GetFinalCombinerInputParameterivNV: procedure(variable: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(variable: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetFinalCombinerInputParameterivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterivNV(variable: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetFinalCombinerInputParameterivNV(variable, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterivNV(variable: DummyEnum; pname: DummyEnum; var &params: Int32) := GetFinalCombinerInputParameterivNV(variable, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFinalCombinerInputParameterivNV(variable: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetFinalCombinerInputParameterivNV(variable, pname, &params);
    
    {$endregion NV_register_combiners}
    
    {$region NV_register_combiners2}
    
    public z_CombinerStageParameterfvNV: procedure(stage: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(stage: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glCombinerStageParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; &params: array of single) := CombinerStageParameterfvNV(stage, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; var &params: single) := CombinerStageParameterfvNV(stage, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure CombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; &params: pointer) := z_CombinerStageParameterfvNV(stage, pname, &params);
    
    public z_GetCombinerStageParameterfvNV: procedure(stage: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(stage: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetCombinerStageParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; &params: array of single) := GetCombinerStageParameterfvNV(stage, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; var &params: single) := GetCombinerStageParameterfvNV(stage, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetCombinerStageParameterfvNV(stage: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetCombinerStageParameterfvNV(stage, pname, &params);
    
    {$endregion NV_register_combiners2}
    
    {$region NV_sample_locations}
    
    public z_ResolveDepthValuesNV: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glResolveDepthValuesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ResolveDepthValuesNV := z_ResolveDepthValuesNV();
    
    {$endregion NV_sample_locations}
    
    {$region NV_scissor_exclusive}
    
    public z_ScissorExclusiveArrayvNV: procedure(first: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glScissorExclusiveArrayvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; v: array of Int32) := ScissorExclusiveArrayvNV(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; var v: Int32) := ScissorExclusiveArrayvNV(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveArrayvNV(first: UInt32; count: Int32; v: pointer) := z_ScissorExclusiveArrayvNV(first, count, v);
    
    public z_ScissorExclusiveNV: procedure(x: Int32; y: Int32; width: Int32; height: Int32) := FuncPtrOrNil&<procedure(x: Int32; y: Int32; width: Int32; height: Int32)>(GetGLProcAdr('glScissorExclusiveNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScissorExclusiveNV(x: Int32; y: Int32; width: Int32; height: Int32) := z_ScissorExclusiveNV(x, y, width, height);
    
    {$endregion NV_scissor_exclusive}
    
    {$region NV_shader_buffer_load}
    
    public z_MakeBufferResidentNV: procedure(target: DummyEnum; access: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum; access: DummyEnum)>(GetGLProcAdr('glMakeBufferResidentNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeBufferResidentNV(target: DummyEnum; access: DummyEnum) := z_MakeBufferResidentNV(target, access);
    
    public z_MakeBufferNonResidentNV: procedure(target: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum)>(GetGLProcAdr('glMakeBufferNonResidentNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeBufferNonResidentNV(target: DummyEnum) := z_MakeBufferNonResidentNV(target);
    
    public z_IsBufferResidentNV: function(target: DummyEnum): Byte := FuncPtrOrNil&<function(target: DummyEnum): Byte>(GetGLProcAdr('glIsBufferResidentNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsBufferResidentNV(target: DummyEnum): Byte := z_IsBufferResidentNV(target);
    
    public z_MakeNamedBufferResidentNV: procedure(buffer: UInt32; access: DummyEnum) := FuncPtrOrNil&<procedure(buffer: UInt32; access: DummyEnum)>(GetGLProcAdr('glMakeNamedBufferResidentNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeNamedBufferResidentNV(buffer: UInt32; access: DummyEnum) := z_MakeNamedBufferResidentNV(buffer, access);
    
    public z_MakeNamedBufferNonResidentNV: procedure(buffer: UInt32) := FuncPtrOrNil&<procedure(buffer: UInt32)>(GetGLProcAdr('glMakeNamedBufferNonResidentNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MakeNamedBufferNonResidentNV(buffer: UInt32) := z_MakeNamedBufferNonResidentNV(buffer);
    
    public z_IsNamedBufferResidentNV: function(buffer: UInt32): Byte := FuncPtrOrNil&<function(buffer: UInt32): Byte>(GetGLProcAdr('glIsNamedBufferResidentNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsNamedBufferResidentNV(buffer: UInt32): Byte := z_IsNamedBufferResidentNV(buffer);
    
    public z_GetBufferParameterui64vNV: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetBufferParameterui64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterui64vNV(target: DummyEnum; pname: DummyEnum; &params: array of UInt64) := GetBufferParameterui64vNV(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterui64vNV(target: DummyEnum; pname: DummyEnum; var &params: UInt64) := GetBufferParameterui64vNV(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetBufferParameterui64vNV(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetBufferParameterui64vNV(target, pname, &params);
    
    public z_GetNamedBufferParameterui64vNV: procedure(buffer: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(buffer: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetNamedBufferParameterui64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterui64vNV(buffer: UInt32; pname: DummyEnum; &params: array of UInt64) := GetNamedBufferParameterui64vNV(buffer, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterui64vNV(buffer: UInt32; pname: DummyEnum; var &params: UInt64) := GetNamedBufferParameterui64vNV(buffer, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetNamedBufferParameterui64vNV(buffer: UInt32; pname: DummyEnum; &params: pointer) := z_GetNamedBufferParameterui64vNV(buffer, pname, &params);
    
    public z_GetIntegerui64vNV: procedure(value: DummyEnum; result: pointer) := FuncPtrOrNil&<procedure(value: DummyEnum; result: pointer)>(GetGLProcAdr('glGetIntegerui64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64vNV(value: DummyEnum; result: array of UInt64) := GetIntegerui64vNV(value, result[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64vNV(value: DummyEnum; var result: UInt64) := GetIntegerui64vNV(value, @result);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64vNV(value: DummyEnum; result: pointer) := z_GetIntegerui64vNV(value, result);
    
    public z_Uniformui64NV: procedure(location: Int32; value: UInt64) := FuncPtrOrNil&<procedure(location: Int32; value: UInt64)>(GetGLProcAdr('glUniformui64NV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64NV(location: Int32; value: UInt64) := z_Uniformui64NV(location, value);
    
    public z_Uniformui64vNV: procedure(location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glUniformui64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; value: array of UInt64) := Uniformui64vNV(location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; var value: UInt64) := Uniformui64vNV(location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Uniformui64vNV(location: Int32; count: Int32; value: pointer) := z_Uniformui64vNV(location, count, value);
    
    public z_ProgramUniformui64NV: procedure(&program: UInt32; location: Int32; value: UInt64) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; value: UInt64)>(GetGLProcAdr('glProgramUniformui64NV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64NV(&program: UInt32; location: Int32; value: UInt64) := z_ProgramUniformui64NV(&program, location, value);
    
    public z_ProgramUniformui64vNV: procedure(&program: UInt32; location: Int32; count: Int32; value: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; location: Int32; count: Int32; value: pointer)>(GetGLProcAdr('glProgramUniformui64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: UInt32; location: Int32; count: Int32; value: array of UInt64) := ProgramUniformui64vNV(&program, location, count, value[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: UInt32; location: Int32; count: Int32; var value: UInt64) := ProgramUniformui64vNV(&program, location, count, @value);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramUniformui64vNV(&program: UInt32; location: Int32; count: Int32; value: pointer) := z_ProgramUniformui64vNV(&program, location, count, value);
    
    {$endregion NV_shader_buffer_load}
    
    {$region NV_shading_rate_image}
    
    public z_BindShadingRateImageNV: procedure(texture: UInt32) := FuncPtrOrNil&<procedure(texture: UInt32)>(GetGLProcAdr('glBindShadingRateImageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BindShadingRateImageNV(texture: UInt32) := z_BindShadingRateImageNV(texture);
    
    public z_ShadingRateImagePaletteNV: procedure(viewport: UInt32; first: UInt32; count: Int32; rates: pointer) := FuncPtrOrNil&<procedure(viewport: UInt32; first: UInt32; count: Int32; rates: pointer)>(GetGLProcAdr('glShadingRateImagePaletteNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; rates: array of DummyEnum) := ShadingRateImagePaletteNV(viewport, first, count, rates[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; var rates: DummyEnum) := ShadingRateImagePaletteNV(viewport, first, count, @rates);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImagePaletteNV(viewport: UInt32; first: UInt32; count: Int32; rates: pointer) := z_ShadingRateImagePaletteNV(viewport, first, count, rates);
    
    public z_GetShadingRateImagePaletteNV: procedure(viewport: UInt32; entry: UInt32; rate: pointer) := FuncPtrOrNil&<procedure(viewport: UInt32; entry: UInt32; rate: pointer)>(GetGLProcAdr('glGetShadingRateImagePaletteNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; rate: array of DummyEnum) := GetShadingRateImagePaletteNV(viewport, entry, rate[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; var rate: DummyEnum) := GetShadingRateImagePaletteNV(viewport, entry, @rate);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateImagePaletteNV(viewport: UInt32; entry: UInt32; rate: pointer) := z_GetShadingRateImagePaletteNV(viewport, entry, rate);
    
    public z_ShadingRateSampleOrderCustomNV: procedure(rate: DummyEnum; samples: UInt32; locations: pointer) := FuncPtrOrNil&<procedure(rate: DummyEnum; samples: UInt32; locations: pointer)>(GetGLProcAdr('glShadingRateSampleOrderCustomNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; locations: array of Int32) := ShadingRateSampleOrderCustomNV(rate, samples, locations[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; var locations: Int32) := ShadingRateSampleOrderCustomNV(rate, samples, @locations);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateSampleOrderCustomNV(rate: DummyEnum; samples: UInt32; locations: pointer) := z_ShadingRateSampleOrderCustomNV(rate, samples, locations);
    
    public z_GetShadingRateSampleLocationivNV: procedure(rate: DummyEnum; samples: UInt32; index: UInt32; location: pointer) := FuncPtrOrNil&<procedure(rate: DummyEnum; samples: UInt32; index: UInt32; location: pointer)>(GetGLProcAdr('glGetShadingRateSampleLocationivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateSampleLocationivNV(rate: DummyEnum; samples: UInt32; index: UInt32; location: array of Int32) := GetShadingRateSampleLocationivNV(rate, samples, index, location[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateSampleLocationivNV(rate: DummyEnum; samples: UInt32; index: UInt32; var location: Int32) := GetShadingRateSampleLocationivNV(rate, samples, index, @location);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetShadingRateSampleLocationivNV(rate: DummyEnum; samples: UInt32; index: UInt32; location: pointer) := z_GetShadingRateSampleLocationivNV(rate, samples, index, location);
    
    {$endregion NV_shading_rate_image}
    
    {$region NV_texture_multisample}
    
    public z_TexImage2DMultisampleCoverageNV: procedure(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte) := FuncPtrOrNil&<procedure(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte)>(GetGLProcAdr('glTexImage2DMultisampleCoverageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage2DMultisampleCoverageNV(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte) := z_TexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    
    public z_TexImage3DMultisampleCoverageNV: procedure(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte) := FuncPtrOrNil&<procedure(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte)>(GetGLProcAdr('glTexImage3DMultisampleCoverageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage3DMultisampleCoverageNV(target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte) := z_TexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    
    public z_TextureImage2DMultisampleNV: procedure(texture: UInt32; target: DummyEnum; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte)>(GetGLProcAdr('glTextureImage2DMultisampleNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DMultisampleNV(texture: UInt32; target: DummyEnum; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte) := z_TextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
    
    public z_TextureImage3DMultisampleNV: procedure(texture: UInt32; target: DummyEnum; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte)>(GetGLProcAdr('glTextureImage3DMultisampleNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DMultisampleNV(texture: UInt32; target: DummyEnum; samples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte) := z_TextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
    
    public z_TextureImage2DMultisampleCoverageNV: procedure(texture: UInt32; target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte)>(GetGLProcAdr('glTextureImage2DMultisampleCoverageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage2DMultisampleCoverageNV(texture: UInt32; target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; fixedSampleLocations: Byte) := z_TextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
    
    public z_TextureImage3DMultisampleCoverageNV: procedure(texture: UInt32; target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte) := FuncPtrOrNil&<procedure(texture: UInt32; target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte)>(GetGLProcAdr('glTextureImage3DMultisampleCoverageNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureImage3DMultisampleCoverageNV(texture: UInt32; target: DummyEnum; coverageSamples: Int32; colorSamples: Int32; internalFormat: Int32; width: Int32; height: Int32; depth: Int32; fixedSampleLocations: Byte) := z_TextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
    
    {$endregion NV_texture_multisample}
    
    {$region NV_transform_feedback}
    
    public z_TransformFeedbackAttribsNV: procedure(count: Int32; attribs: pointer; bufferMode: DummyEnum) := FuncPtrOrNil&<procedure(count: Int32; attribs: pointer; bufferMode: DummyEnum)>(GetGLProcAdr('glTransformFeedbackAttribsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; attribs: array of Int32; bufferMode: DummyEnum) := TransformFeedbackAttribsNV(count, attribs[0], bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; var attribs: Int32; bufferMode: DummyEnum) := TransformFeedbackAttribsNV(count, @attribs, bufferMode);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TransformFeedbackAttribsNV(count: Int32; attribs: pointer; bufferMode: DummyEnum) := z_TransformFeedbackAttribsNV(count, attribs, bufferMode);
    
    public z_GetVaryingLocationNV: function(&program: UInt32; name: IntPtr): Int32 := FuncPtrOrNil&<function(&program: UInt32; name: IntPtr): Int32>(GetGLProcAdr('glGetVaryingLocationNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVaryingLocationNV(&program: UInt32; name: string): Int32; begin var ptr2 := Marshal.StringToHGlobalAnsi(name); Result := GetVaryingLocationNV(&program, ptr2); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetVaryingLocationNV(&program: UInt32; name: IntPtr): Int32 := z_GetVaryingLocationNV(&program, name);
    
    public z_GetActiveVaryingNV: procedure(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr) := FuncPtrOrNil&<procedure(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr)>(GetGLProcAdr('glGetActiveVaryingNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], &type[0], ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], @&type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: pointer; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], &type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], @size, &type[0], ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; var &type: DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], @size, @&type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: pointer; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], @size, &type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; var size: Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: array of DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size, &type[0], ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; var &type: DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size, @&type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: pointer; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length[0], size, &type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: array of Int32; size: pointer; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length[0], size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size[0], &type[0], ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size[0], @&type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: pointer; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size[0], &type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, @size, &type[0], ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, @size, @&type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, @size, &type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; var size: Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: array of DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size, &type[0], ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; var &type: DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size, @&type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: pointer; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, @length, size, &type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; var length: Int32; size: pointer; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, @length, size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: array of DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size[0], &type[0], ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, size[0], &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; var &type: DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size[0], @&type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, size[0], @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: pointer; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size[0], &type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: array of Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, size[0], &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: array of DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, @size, &type[0], ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, @size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; var &type: DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, @size, @&type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, @size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: pointer; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, @size, &type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; var size: Int32; &type: pointer; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, @size, &type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: array of DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size, &type[0], ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: array of DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, size, &type[0], name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: DummyEnum; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size, @&type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; var &type: DummyEnum; name: IntPtr) := GetActiveVaryingNV(&program, index, bufSize, length, size, @&type, name);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: string); begin var ptr7 := Marshal.StringToHGlobalAnsi(name); GetActiveVaryingNV(&program, index, bufSize, length, size, &type, ptr7); name := Marshal.PtrToStringAnsi(ptr7); Marshal.FreeHGlobal(ptr7); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetActiveVaryingNV(&program: UInt32; index: UInt32; bufSize: Int32; length: pointer; size: pointer; &type: pointer; name: IntPtr) := z_GetActiveVaryingNV(&program, index, bufSize, length, size, &type, name);
    
    public z_ActiveVaryingNV: procedure(&program: UInt32; name: IntPtr) := FuncPtrOrNil&<procedure(&program: UInt32; name: IntPtr)>(GetGLProcAdr('glActiveVaryingNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveVaryingNV(&program: UInt32; name: string); begin var ptr2 := Marshal.StringToHGlobalAnsi(name); ActiveVaryingNV(&program, ptr2); name := Marshal.PtrToStringAnsi(ptr2); Marshal.FreeHGlobal(ptr2); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ActiveVaryingNV(&program: UInt32; name: IntPtr) := z_ActiveVaryingNV(&program, name);
    
    {$endregion NV_transform_feedback}
    
    {$region NV_vdpau_interop}
    
    public z_VDPAUInitNV: procedure(vdpDevice: pointer; getProcAddress: pointer) := FuncPtrOrNil&<procedure(vdpDevice: pointer; getProcAddress: pointer)>(GetGLProcAdr('glVDPAUInitNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUInitNV(vdpDevice: pointer; getProcAddress: pointer) := z_VDPAUInitNV(vdpDevice, getProcAddress);
    
    public z_VDPAUFiniNV: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glVDPAUFiniNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUFiniNV := z_VDPAUFiniNV();
    
    public z_VDPAURegisterVideoSurfaceNV: function(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer): GLvdpauSurfaceNV := FuncPtrOrNil&<function(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer): GLvdpauSurfaceNV>(GetGLProcAdr('glVDPAURegisterVideoSurfaceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32): GLvdpauSurfaceNV := VDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): GLvdpauSurfaceNV := VDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, @textureNames);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer): GLvdpauSurfaceNV := z_VDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
    
    public z_VDPAURegisterOutputSurfaceNV: function(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer): GLvdpauSurfaceNV := FuncPtrOrNil&<function(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer): GLvdpauSurfaceNV>(GetGLProcAdr('glVDPAURegisterOutputSurfaceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32): GLvdpauSurfaceNV := VDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32): GLvdpauSurfaceNV := VDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, @textureNames);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterOutputSurfaceNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer): GLvdpauSurfaceNV := z_VDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
    
    public z_VDPAUIsSurfaceNV: function(surface: GLvdpauSurfaceNV): Byte := FuncPtrOrNil&<function(surface: GLvdpauSurfaceNV): Byte>(GetGLProcAdr('glVDPAUIsSurfaceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAUIsSurfaceNV(surface: GLvdpauSurfaceNV): Byte := z_VDPAUIsSurfaceNV(surface);
    
    public z_VDPAUUnregisterSurfaceNV: procedure(surface: GLvdpauSurfaceNV) := FuncPtrOrNil&<procedure(surface: GLvdpauSurfaceNV)>(GetGLProcAdr('glVDPAUUnregisterSurfaceNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnregisterSurfaceNV(surface: GLvdpauSurfaceNV) := z_VDPAUUnregisterSurfaceNV(surface);
    
    public z_VDPAUGetSurfaceivNV: procedure(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: pointer; values: pointer) := FuncPtrOrNil&<procedure(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: pointer; values: pointer)>(GetGLProcAdr('glVDPAUGetSurfaceivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: array of Int32; values: array of Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, length[0], values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: array of Int32; var values: Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, length[0], @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: array of Int32; values: pointer) := VDPAUGetSurfaceivNV(surface, pname, bufSize, length[0], values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; var length: Int32; values: array of Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, @length, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; var length: Int32; var values: Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, @length, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; var length: Int32; values: pointer) := VDPAUGetSurfaceivNV(surface, pname, bufSize, @length, values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: pointer; values: array of Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, length, values[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: pointer; var values: Int32) := VDPAUGetSurfaceivNV(surface, pname, bufSize, length, @values);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUGetSurfaceivNV(surface: GLvdpauSurfaceNV; pname: DummyEnum; bufSize: Int32; length: pointer; values: pointer) := z_VDPAUGetSurfaceivNV(surface, pname, bufSize, length, values);
    
    public z_VDPAUSurfaceAccessNV: procedure(surface: GLvdpauSurfaceNV; access: DummyEnum) := FuncPtrOrNil&<procedure(surface: GLvdpauSurfaceNV; access: DummyEnum)>(GetGLProcAdr('glVDPAUSurfaceAccessNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUSurfaceAccessNV(surface: GLvdpauSurfaceNV; access: DummyEnum) := z_VDPAUSurfaceAccessNV(surface, access);
    
    public z_VDPAUMapSurfacesNV: procedure(numSurfaces: Int32; surfaces: pointer) := FuncPtrOrNil&<procedure(numSurfaces: Int32; surfaces: pointer)>(GetGLProcAdr('glVDPAUMapSurfacesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; surfaces: array of GLvdpauSurfaceNV) := VDPAUMapSurfacesNV(numSurfaces, surfaces[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; var surfaces: GLvdpauSurfaceNV) := VDPAUMapSurfacesNV(numSurfaces, @surfaces);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUMapSurfacesNV(numSurfaces: Int32; surfaces: pointer) := z_VDPAUMapSurfacesNV(numSurfaces, surfaces);
    
    public z_VDPAUUnmapSurfacesNV: procedure(numSurface: Int32; surfaces: pointer) := FuncPtrOrNil&<procedure(numSurface: Int32; surfaces: pointer)>(GetGLProcAdr('glVDPAUUnmapSurfacesNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; surfaces: array of GLvdpauSurfaceNV) := VDPAUUnmapSurfacesNV(numSurface, surfaces[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; var surfaces: GLvdpauSurfaceNV) := VDPAUUnmapSurfacesNV(numSurface, @surfaces);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VDPAUUnmapSurfacesNV(numSurface: Int32; surfaces: pointer) := z_VDPAUUnmapSurfacesNV(numSurface, surfaces);
    
    {$endregion NV_vdpau_interop}
    
    {$region NV_vdpau_interop2}
    
    public z_VDPAURegisterVideoSurfaceWithPictureStructureNV: function(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer; isFrameStructure: Byte): GLvdpauSurfaceNV := FuncPtrOrNil&<function(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer; isFrameStructure: Byte): GLvdpauSurfaceNV>(GetGLProcAdr('glVDPAURegisterVideoSurfaceWithPictureStructureNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: array of UInt32; isFrameStructure: Byte): GLvdpauSurfaceNV := VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface, target, numTextureNames, textureNames[0], isFrameStructure);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; var textureNames: UInt32; isFrameStructure: Byte): GLvdpauSurfaceNV := VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface, target, numTextureNames, @textureNames, isFrameStructure);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface: pointer; target: DummyEnum; numTextureNames: Int32; textureNames: pointer; isFrameStructure: Byte): GLvdpauSurfaceNV := z_VDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
    
    {$endregion NV_vdpau_interop2}
    
    {$region NV_vertex_attrib_integer_64bit}
    
    public z_VertexAttribL1i64NV: procedure(index: UInt32; x: Int64) := FuncPtrOrNil&<procedure(index: UInt32; x: Int64)>(GetGLProcAdr('glVertexAttribL1i64NV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64NV(index: UInt32; x: Int64) := z_VertexAttribL1i64NV(index, x);
    
    public z_VertexAttribL2i64NV: procedure(index: UInt32; x: Int64; y: Int64) := FuncPtrOrNil&<procedure(index: UInt32; x: Int64; y: Int64)>(GetGLProcAdr('glVertexAttribL2i64NV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64NV(index: UInt32; x: Int64; y: Int64) := z_VertexAttribL2i64NV(index, x, y);
    
    public z_VertexAttribL3i64NV: procedure(index: UInt32; x: Int64; y: Int64; z: Int64) := FuncPtrOrNil&<procedure(index: UInt32; x: Int64; y: Int64; z: Int64)>(GetGLProcAdr('glVertexAttribL3i64NV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64NV(index: UInt32; x: Int64; y: Int64; z: Int64) := z_VertexAttribL3i64NV(index, x, y, z);
    
    public z_VertexAttribL4i64NV: procedure(index: UInt32; x: Int64; y: Int64; z: Int64; w: Int64) := FuncPtrOrNil&<procedure(index: UInt32; x: Int64; y: Int64; z: Int64; w: Int64)>(GetGLProcAdr('glVertexAttribL4i64NV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64NV(index: UInt32; x: Int64; y: Int64; z: Int64; w: Int64) := z_VertexAttribL4i64NV(index, x, y, z, w);
    
    public z_VertexAttribL1i64vNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttribL1i64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; v: array of Int64) := VertexAttribL1i64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; var v: Int64) := VertexAttribL1i64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL1i64vNV(index: UInt32; v: pointer) := z_VertexAttribL1i64vNV(index, v);
    
    public z_VertexAttribL2i64vNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttribL2i64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; v: array of Int64) := VertexAttribL2i64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; var v: Int64) := VertexAttribL2i64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2i64vNV(index: UInt32; v: pointer) := z_VertexAttribL2i64vNV(index, v);
    
    public z_VertexAttribL3i64vNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttribL3i64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; v: array of Int64) := VertexAttribL3i64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; var v: Int64) := VertexAttribL3i64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3i64vNV(index: UInt32; v: pointer) := z_VertexAttribL3i64vNV(index, v);
    
    public z_VertexAttribL4i64vNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttribL4i64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; v: array of Int64) := VertexAttribL4i64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; var v: Int64) := VertexAttribL4i64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4i64vNV(index: UInt32; v: pointer) := z_VertexAttribL4i64vNV(index, v);
    
    public z_VertexAttribL2ui64NV: procedure(index: UInt32; x: UInt64; y: UInt64) := FuncPtrOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64)>(GetGLProcAdr('glVertexAttribL2ui64NV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64NV(index: UInt32; x: UInt64; y: UInt64) := z_VertexAttribL2ui64NV(index, x, y);
    
    public z_VertexAttribL3ui64NV: procedure(index: UInt32; x: UInt64; y: UInt64; z: UInt64) := FuncPtrOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64; z: UInt64)>(GetGLProcAdr('glVertexAttribL3ui64NV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64NV(index: UInt32; x: UInt64; y: UInt64; z: UInt64) := z_VertexAttribL3ui64NV(index, x, y, z);
    
    public z_VertexAttribL4ui64NV: procedure(index: UInt32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := FuncPtrOrNil&<procedure(index: UInt32; x: UInt64; y: UInt64; z: UInt64; w: UInt64)>(GetGLProcAdr('glVertexAttribL4ui64NV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64NV(index: UInt32; x: UInt64; y: UInt64; z: UInt64; w: UInt64) := z_VertexAttribL4ui64NV(index, x, y, z, w);
    
    public z_VertexAttribL2ui64vNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttribL2ui64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; v: array of UInt64) := VertexAttribL2ui64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; var v: UInt64) := VertexAttribL2ui64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL2ui64vNV(index: UInt32; v: pointer) := z_VertexAttribL2ui64vNV(index, v);
    
    public z_VertexAttribL3ui64vNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttribL3ui64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; v: array of UInt64) := VertexAttribL3ui64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; var v: UInt64) := VertexAttribL3ui64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL3ui64vNV(index: UInt32; v: pointer) := z_VertexAttribL3ui64vNV(index, v);
    
    public z_VertexAttribL4ui64vNV: procedure(index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; v: pointer)>(GetGLProcAdr('glVertexAttribL4ui64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; v: array of UInt64) := VertexAttribL4ui64vNV(index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; var v: UInt64) := VertexAttribL4ui64vNV(index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribL4ui64vNV(index: UInt32; v: pointer) := z_VertexAttribL4ui64vNV(index, v);
    
    public z_GetVertexAttribLi64vNV: procedure(index: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(index: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetVertexAttribLi64vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLi64vNV(index: UInt32; pname: DummyEnum; &params: array of Int64) := GetVertexAttribLi64vNV(index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLi64vNV(index: UInt32; pname: DummyEnum; var &params: Int64) := GetVertexAttribLi64vNV(index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetVertexAttribLi64vNV(index: UInt32; pname: DummyEnum; &params: pointer) := z_GetVertexAttribLi64vNV(index, pname, &params);
    
    {$endregion NV_vertex_attrib_integer_64bit}
    
    {$region NV_vertex_buffer_unified_memory}
    
    public z_BufferAddressRangeNV: procedure(pname: DummyEnum; index: UInt32; address: UInt64; length: UIntPtr) := FuncPtrOrNil&<procedure(pname: DummyEnum; index: UInt32; address: UInt64; length: UIntPtr)>(GetGLProcAdr('glBufferAddressRangeNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BufferAddressRangeNV(pname: DummyEnum; index: UInt32; address: UInt64; length: UIntPtr) := z_BufferAddressRangeNV(pname, index, address, length);
    
    public z_VertexFormatNV: procedure(size: Int32; &type: DummyEnum; stride: Int32) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>(GetGLProcAdr('glVertexFormatNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexFormatNV(size: Int32; &type: DummyEnum; stride: Int32) := z_VertexFormatNV(size, &type, stride);
    
    public z_NormalFormatNV: procedure(&type: DummyEnum; stride: Int32) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32)>(GetGLProcAdr('glNormalFormatNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NormalFormatNV(&type: DummyEnum; stride: Int32) := z_NormalFormatNV(&type, stride);
    
    public z_ColorFormatNV: procedure(size: Int32; &type: DummyEnum; stride: Int32) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>(GetGLProcAdr('glColorFormatNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ColorFormatNV(size: Int32; &type: DummyEnum; stride: Int32) := z_ColorFormatNV(size, &type, stride);
    
    public z_IndexFormatNV: procedure(&type: DummyEnum; stride: Int32) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32)>(GetGLProcAdr('glIndexFormatNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexFormatNV(&type: DummyEnum; stride: Int32) := z_IndexFormatNV(&type, stride);
    
    public z_TexCoordFormatNV: procedure(size: Int32; &type: DummyEnum; stride: Int32) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>(GetGLProcAdr('glTexCoordFormatNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoordFormatNV(size: Int32; &type: DummyEnum; stride: Int32) := z_TexCoordFormatNV(size, &type, stride);
    
    public z_EdgeFlagFormatNV: procedure(stride: Int32) := FuncPtrOrNil&<procedure(stride: Int32)>(GetGLProcAdr('glEdgeFlagFormatNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EdgeFlagFormatNV(stride: Int32) := z_EdgeFlagFormatNV(stride);
    
    public z_SecondaryColorFormatNV: procedure(size: Int32; &type: DummyEnum; stride: Int32) := FuncPtrOrNil&<procedure(size: Int32; &type: DummyEnum; stride: Int32)>(GetGLProcAdr('glSecondaryColorFormatNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SecondaryColorFormatNV(size: Int32; &type: DummyEnum; stride: Int32) := z_SecondaryColorFormatNV(size, &type, stride);
    
    public z_FogCoordFormatNV: procedure(&type: DummyEnum; stride: Int32) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32)>(GetGLProcAdr('glFogCoordFormatNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogCoordFormatNV(&type: DummyEnum; stride: Int32) := z_FogCoordFormatNV(&type, stride);
    
    public z_GetIntegerui64i_vNV: procedure(value: DummyEnum; index: UInt32; result: pointer) := FuncPtrOrNil&<procedure(value: DummyEnum; index: UInt32; result: pointer)>(GetGLProcAdr('glGetIntegerui64i_vNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64i_vNV(value: DummyEnum; index: UInt32; result: array of UInt64) := GetIntegerui64i_vNV(value, index, result[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64i_vNV(value: DummyEnum; index: UInt32; var result: UInt64) := GetIntegerui64i_vNV(value, index, @result);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetIntegerui64i_vNV(value: DummyEnum; index: UInt32; result: pointer) := z_GetIntegerui64i_vNV(value, index, result);
    
    {$endregion NV_vertex_buffer_unified_memory}
    
    {$region NV_vertex_program}
    
    public z_ExecuteProgramNV: procedure(target: DummyEnum; id: UInt32; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; id: UInt32; &params: pointer)>(GetGLProcAdr('glExecuteProgramNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: DummyEnum; id: UInt32; &params: array of single) := ExecuteProgramNV(target, id, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: DummyEnum; id: UInt32; var &params: single) := ExecuteProgramNV(target, id, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExecuteProgramNV(target: DummyEnum; id: UInt32; &params: pointer) := z_ExecuteProgramNV(target, id, &params);
    
    public z_AreProgramsResidentNV: function(n: Int32; programs: pointer; residences: pointer): Byte := FuncPtrOrNil&<function(n: Int32; programs: pointer; residences: pointer): Byte>(GetGLProcAdr('glAreProgramsResidentNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: array of UInt32; residences: array of Byte): Byte := AreProgramsResidentNV(n, programs[0], residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: array of UInt32; var residences: Byte): Byte := AreProgramsResidentNV(n, programs[0], @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: array of UInt32; residences: pointer): Byte := AreProgramsResidentNV(n, programs[0], residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; var programs: UInt32; residences: array of Byte): Byte := AreProgramsResidentNV(n, @programs, residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; var programs: UInt32; var residences: Byte): Byte := AreProgramsResidentNV(n, @programs, @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; var programs: UInt32; residences: pointer): Byte := AreProgramsResidentNV(n, @programs, residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: pointer; residences: array of Byte): Byte := AreProgramsResidentNV(n, programs, residences[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: pointer; var residences: Byte): Byte := AreProgramsResidentNV(n, programs, @residences);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AreProgramsResidentNV(n: Int32; programs: pointer; residences: pointer): Byte := z_AreProgramsResidentNV(n, programs, residences);
    
    public z_RequestResidentProgramsNV: procedure(n: Int32; programs: pointer) := FuncPtrOrNil&<procedure(n: Int32; programs: pointer)>(GetGLProcAdr('glRequestResidentProgramsNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; programs: array of UInt32) := RequestResidentProgramsNV(n, programs[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; var programs: UInt32) := RequestResidentProgramsNV(n, @programs);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RequestResidentProgramsNV(n: Int32; programs: pointer) := z_RequestResidentProgramsNV(n, programs);
    
    public z_GetProgramParameterfvNV: procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetProgramParameterfvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: array of single) := GetProgramParameterfvNV(target, index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; var &params: single) := GetProgramParameterfvNV(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterfvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := z_GetProgramParameterfvNV(target, index, pname, &params);
    
    public z_GetProgramParameterdvNV: procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetProgramParameterdvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterdvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: array of double) := GetProgramParameterdvNV(target, index, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterdvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; var &params: double) := GetProgramParameterdvNV(target, index, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetProgramParameterdvNV(target: DummyEnum; index: UInt32; pname: DummyEnum; &params: pointer) := z_GetProgramParameterdvNV(target, index, pname, &params);
    
    public z_GetTrackMatrixivNV: procedure(target: DummyEnum; address: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; address: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetTrackMatrixivNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTrackMatrixivNV(target: DummyEnum; address: UInt32; pname: DummyEnum; &params: array of Int32) := GetTrackMatrixivNV(target, address, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTrackMatrixivNV(target: DummyEnum; address: UInt32; pname: DummyEnum; var &params: Int32) := GetTrackMatrixivNV(target, address, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTrackMatrixivNV(target: DummyEnum; address: UInt32; pname: DummyEnum; &params: pointer) := z_GetTrackMatrixivNV(target, address, pname, &params);
    
    public z_LoadProgramNV: procedure(target: DummyEnum; id: UInt32; len: Int32; &program: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; id: UInt32; len: Int32; &program: pointer)>(GetGLProcAdr('glLoadProgramNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: DummyEnum; id: UInt32; len: Int32; &program: array of Byte) := LoadProgramNV(target, id, len, &program[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: DummyEnum; id: UInt32; len: Int32; var &program: Byte) := LoadProgramNV(target, id, len, @&program);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadProgramNV(target: DummyEnum; id: UInt32; len: Int32; &program: pointer) := z_LoadProgramNV(target, id, len, &program);
    
    public z_ProgramParameter4fNV: procedure(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single)>(GetGLProcAdr('glProgramParameter4fNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fNV(target: DummyEnum; index: UInt32; x: single; y: single; z: single; w: single) := z_ProgramParameter4fNV(target, index, x, y, z, w);
    
    public z_ProgramParameter4dNV: procedure(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double)>(GetGLProcAdr('glProgramParameter4dNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dNV(target: DummyEnum; index: UInt32; x: double; y: double; z: double; w: double) := z_ProgramParameter4dNV(target, index, x, y, z, w);
    
    public z_ProgramParameter4dvNV: procedure(target: DummyEnum; index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; v: pointer)>(GetGLProcAdr('glProgramParameter4dvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: DummyEnum; index: UInt32; v: array of double) := ProgramParameter4dvNV(target, index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: DummyEnum; index: UInt32; var v: double) := ProgramParameter4dvNV(target, index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4dvNV(target: DummyEnum; index: UInt32; v: pointer) := z_ProgramParameter4dvNV(target, index, v);
    
    public z_ProgramParameter4fvNV: procedure(target: DummyEnum; index: UInt32; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; v: pointer)>(GetGLProcAdr('glProgramParameter4fvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: DummyEnum; index: UInt32; v: array of single) := ProgramParameter4fvNV(target, index, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: DummyEnum; index: UInt32; var v: single) := ProgramParameter4fvNV(target, index, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameter4fvNV(target: DummyEnum; index: UInt32; v: pointer) := z_ProgramParameter4fvNV(target, index, v);
    
    public z_ProgramParameters4dvNV: procedure(target: DummyEnum; index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glProgramParameters4dvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: DummyEnum; index: UInt32; count: Int32; v: array of double) := ProgramParameters4dvNV(target, index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: DummyEnum; index: UInt32; count: Int32; var v: double) := ProgramParameters4dvNV(target, index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4dvNV(target: DummyEnum; index: UInt32; count: Int32; v: pointer) := z_ProgramParameters4dvNV(target, index, count, v);
    
    public z_ProgramParameters4fvNV: procedure(target: DummyEnum; index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glProgramParameters4fvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: DummyEnum; index: UInt32; count: Int32; v: array of single) := ProgramParameters4fvNV(target, index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: DummyEnum; index: UInt32; count: Int32; var v: single) := ProgramParameters4fvNV(target, index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ProgramParameters4fvNV(target: DummyEnum; index: UInt32; count: Int32; v: pointer) := z_ProgramParameters4fvNV(target, index, count, v);
    
    public z_TrackMatrixNV: procedure(target: DummyEnum; address: UInt32; matrix: DummyEnum; transform: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum; address: UInt32; matrix: DummyEnum; transform: DummyEnum)>(GetGLProcAdr('glTrackMatrixNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TrackMatrixNV(target: DummyEnum; address: UInt32; matrix: DummyEnum; transform: DummyEnum) := z_TrackMatrixNV(target, address, matrix, transform);
    
    public z_VertexAttrib4ubNV: procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) := FuncPtrOrNil&<procedure(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte)>(GetGLProcAdr('glVertexAttrib4ubNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttrib4ubNV(index: UInt32; x: Byte; y: Byte; z: Byte; w: Byte) := z_VertexAttrib4ubNV(index, x, y, z, w);
    
    public z_VertexAttribs1svNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs1svNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; v: array of Int16) := VertexAttribs1svNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; var v: Int16) := VertexAttribs1svNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1svNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs1svNV(index, count, v);
    
    public z_VertexAttribs1fvNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs1fvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; v: array of single) := VertexAttribs1fvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; var v: single) := VertexAttribs1fvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1fvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs1fvNV(index, count, v);
    
    public z_VertexAttribs1dvNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs1dvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; v: array of double) := VertexAttribs1dvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; var v: double) := VertexAttribs1dvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs1dvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs1dvNV(index, count, v);
    
    public z_VertexAttribs2svNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs2svNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; v: array of Int16) := VertexAttribs2svNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; var v: Int16) := VertexAttribs2svNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2svNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs2svNV(index, count, v);
    
    public z_VertexAttribs2fvNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs2fvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; v: array of single) := VertexAttribs2fvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; var v: single) := VertexAttribs2fvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2fvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs2fvNV(index, count, v);
    
    public z_VertexAttribs2dvNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs2dvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; v: array of double) := VertexAttribs2dvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; var v: double) := VertexAttribs2dvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs2dvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs2dvNV(index, count, v);
    
    public z_VertexAttribs3svNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs3svNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; v: array of Int16) := VertexAttribs3svNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; var v: Int16) := VertexAttribs3svNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3svNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs3svNV(index, count, v);
    
    public z_VertexAttribs3fvNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs3fvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; v: array of single) := VertexAttribs3fvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; var v: single) := VertexAttribs3fvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3fvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs3fvNV(index, count, v);
    
    public z_VertexAttribs3dvNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs3dvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; v: array of double) := VertexAttribs3dvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; var v: double) := VertexAttribs3dvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs3dvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs3dvNV(index, count, v);
    
    public z_VertexAttribs4svNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs4svNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; v: array of Int16) := VertexAttribs4svNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; var v: Int16) := VertexAttribs4svNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4svNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs4svNV(index, count, v);
    
    public z_VertexAttribs4fvNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs4fvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; v: array of single) := VertexAttribs4fvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; var v: single) := VertexAttribs4fvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4fvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs4fvNV(index, count, v);
    
    public z_VertexAttribs4dvNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs4dvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; v: array of double) := VertexAttribs4dvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; var v: double) := VertexAttribs4dvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4dvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs4dvNV(index, count, v);
    
    public z_VertexAttribs4ubvNV: procedure(index: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(index: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glVertexAttribs4ubvNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; v: array of Byte) := VertexAttribs4ubvNV(index, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; var v: Byte) := VertexAttribs4ubvNV(index, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure VertexAttribs4ubvNV(index: UInt32; count: Int32; v: pointer) := z_VertexAttribs4ubvNV(index, count, v);
    
    {$endregion NV_vertex_program}
    
    {$region NV_viewport_swizzle}
    
    public z_ViewportSwizzleNV: procedure(index: UInt32; swizzlex: DummyEnum; swizzley: DummyEnum; swizzlez: DummyEnum; swizzlew: DummyEnum) := FuncPtrOrNil&<procedure(index: UInt32; swizzlex: DummyEnum; swizzley: DummyEnum; swizzlez: DummyEnum; swizzlew: DummyEnum)>(GetGLProcAdr('glViewportSwizzleNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ViewportSwizzleNV(index: UInt32; swizzlex: DummyEnum; swizzley: DummyEnum; swizzlez: DummyEnum; swizzlew: DummyEnum) := z_ViewportSwizzleNV(index, swizzlex, swizzley, swizzlez, swizzlew);
    
    {$endregion NV_viewport_swizzle}
    
    {$region NV_shading_rate_image, NV_shading_rate_image}
    
    public z_ShadingRateImageBarrierNV: procedure(synchronize: Byte) := FuncPtrOrNil&<procedure(synchronize: Byte)>(GetGLProcAdr('glShadingRateImageBarrierNV'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ShadingRateImageBarrierNV(synchronize: Byte) := z_ShadingRateImageBarrierNV(synchronize);
    
    {$endregion NV_shading_rate_image, NV_shading_rate_image}
    
  end;
  
  gl_NVX = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region NVX_gpu_multicast2}
    
    public z_AsyncCopyImageSubDataNVX: function(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := FuncPtrOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32>(GetGLProcAdr('glAsyncCopyImageSubDataNVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: array of UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray[0], srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var waitValueArray: UInt64; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyImageSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; waitValueArray: pointer; srcGpu: UInt32; dstGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srcY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; srcWidth: Int32; srcHeight: Int32; srcDepth: Int32; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := z_AsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    
    public z_AsyncCopyBufferSubDataNVX: function(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := FuncPtrOrNil&<function(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32>(GetGLProcAdr('glAsyncCopyBufferSubDataNVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: array of UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray[0], fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; var waitSemaphoreArray: UInt32; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, @waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: array of UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray[0], readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; var fenceValueArray: UInt64; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, @fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: array of UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray[0], signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; var signalSemaphoreArray: UInt32; signalValueArray: pointer): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, @signalSemaphoreArray, signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: array of UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; var signalValueArray: UInt64): UInt32 := AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, @signalValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function AsyncCopyBufferSubDataNVX(waitSemaphoreCount: Int32; waitSemaphoreArray: pointer; fenceValueArray: pointer; readGpu: UInt32; writeGpuMask: DummyFlags; readBuffer: UInt32; writeBuffer: UInt32; readOffset: IntPtr; writeOffset: IntPtr; size: UIntPtr; signalSemaphoreCount: Int32; signalSemaphoreArray: pointer; signalValueArray: pointer): UInt32 := z_AsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
    
    public z_UploadGpuMaskNVX: procedure(mask: DummyFlags) := FuncPtrOrNil&<procedure(mask: DummyFlags)>(GetGLProcAdr('glUploadGpuMaskNVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure UploadGpuMaskNVX(mask: DummyFlags) := z_UploadGpuMaskNVX(mask);
    
    public z_MulticastViewportArrayvNVX: procedure(gpu: UInt32; first: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glMulticastViewportArrayvNVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: array of single) := MulticastViewportArrayvNVX(gpu, first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; var v: single) := MulticastViewportArrayvNVX(gpu, first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: pointer) := z_MulticastViewportArrayvNVX(gpu, first, count, v);
    
    public z_MulticastScissorArrayvNVX: procedure(gpu: UInt32; first: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(gpu: UInt32; first: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glMulticastScissorArrayvNVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: array of Int32) := MulticastScissorArrayvNVX(gpu, first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; var v: Int32) := MulticastScissorArrayvNVX(gpu, first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastScissorArrayvNVX(gpu: UInt32; first: UInt32; count: Int32; v: pointer) := z_MulticastScissorArrayvNVX(gpu, first, count, v);
    
    public z_MulticastViewportPositionWScaleNVX: procedure(gpu: UInt32; index: UInt32; xcoeff: single; ycoeff: single) := FuncPtrOrNil&<procedure(gpu: UInt32; index: UInt32; xcoeff: single; ycoeff: single)>(GetGLProcAdr('glMulticastViewportPositionWScaleNVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MulticastViewportPositionWScaleNVX(gpu: UInt32; index: UInt32; xcoeff: single; ycoeff: single) := z_MulticastViewportPositionWScaleNVX(gpu, index, xcoeff, ycoeff);
    
    {$endregion NVX_gpu_multicast2}
    
    {$region NVX_linked_gpu_multicast}
    
    public z_LGPUNamedBufferSubDataNVX: procedure(gpuMask: DummyFlags; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer) := FuncPtrOrNil&<procedure(gpuMask: DummyFlags; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer)>(GetGLProcAdr('glLGPUNamedBufferSubDataNVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUNamedBufferSubDataNVX(gpuMask: DummyFlags; buffer: UInt32; offset: IntPtr; size: UIntPtr; data: pointer) := z_LGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, data);
    
    public z_LGPUCopyImageSubDataNVX: procedure(sourceGpu: UInt32; destinationGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srxY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) := FuncPtrOrNil&<procedure(sourceGpu: UInt32; destinationGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srxY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32)>(GetGLProcAdr('glLGPUCopyImageSubDataNVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUCopyImageSubDataNVX(sourceGpu: UInt32; destinationGpuMask: DummyFlags; srcName: UInt32; srcTarget: DummyEnum; srcLevel: Int32; srcX: Int32; srxY: Int32; srcZ: Int32; dstName: UInt32; dstTarget: DummyEnum; dstLevel: Int32; dstX: Int32; dstY: Int32; dstZ: Int32; width: Int32; height: Int32; depth: Int32) := z_LGPUCopyImageSubDataNVX(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
    
    public z_LGPUInterlockNVX: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glLGPUInterlockNVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LGPUInterlockNVX := z_LGPUInterlockNVX();
    
    {$endregion NVX_linked_gpu_multicast}
    
    {$region NVX_progress_fence}
    
    public z_CreateProgressFenceNVX: function: UInt32 := FuncPtrOrNil&<function: UInt32>(GetGLProcAdr('glCreateProgressFenceNVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function CreateProgressFenceNVX: UInt32 := z_CreateProgressFenceNVX();
    
    public z_SignalSemaphoreui64NVX: procedure(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer) := FuncPtrOrNil&<procedure(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer)>(GetGLProcAdr('glSignalSemaphoreui64NVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; var fenceValueArray: UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray[0], @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: pointer) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: array of UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, @semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, @semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: pointer) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, @semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: array of UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; var fenceValueArray: UInt64) := SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SignalSemaphoreui64NVX(signalGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer) := z_SignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    
    public z_WaitSemaphoreui64NVX: procedure(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer) := FuncPtrOrNil&<procedure(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer)>(GetGLProcAdr('glWaitSemaphoreui64NVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; var fenceValueArray: UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray[0], @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: pointer) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray[0], fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: array of UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, @semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, @semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: pointer) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, @semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: array of UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; var fenceValueArray: UInt64) := WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure WaitSemaphoreui64NVX(waitGpu: UInt32; fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer) := z_WaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
    
    public z_ClientWaitSemaphoreui64NVX: procedure(fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer) := FuncPtrOrNil&<procedure(fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer)>(GetGLProcAdr('glClientWaitSemaphoreui64NVX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: array of UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray[0], fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: array of UInt32; var fenceValueArray: UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray[0], @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: array of UInt32; fenceValueArray: pointer) := ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray[0], fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: array of UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, @semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; var semaphoreArray: UInt32; var fenceValueArray: UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, @semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; var semaphoreArray: UInt32; fenceValueArray: pointer) := ClientWaitSemaphoreui64NVX(fenceObjectCount, @semaphoreArray, fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: array of UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray, fenceValueArray[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: pointer; var fenceValueArray: UInt64) := ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray, @fenceValueArray);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClientWaitSemaphoreui64NVX(fenceObjectCount: Int32; semaphoreArray: pointer; fenceValueArray: pointer) := z_ClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray, fenceValueArray);
    
    {$endregion NVX_progress_fence}
    
  end;
  
  gl_OES = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region Unsorted}
    
    public z_MultiTexCoord1bOES: procedure(texture: DummyEnum; s: SByte) := FuncPtrOrNil&<procedure(texture: DummyEnum; s: SByte)>(GetGLProcAdr('glMultiTexCoord1bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bOES(texture: DummyEnum; s: SByte) := z_MultiTexCoord1bOES(texture, s);
    
    public z_MultiTexCoord1bvOES: procedure(texture: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoord1bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bvOES(texture: DummyEnum; coords: array of SByte) := MultiTexCoord1bvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bvOES(texture: DummyEnum; var coords: SByte) := MultiTexCoord1bvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1bvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord1bvOES(texture, coords);
    
    public z_MultiTexCoord2bOES: procedure(texture: DummyEnum; s: SByte; t: SByte) := FuncPtrOrNil&<procedure(texture: DummyEnum; s: SByte; t: SByte)>(GetGLProcAdr('glMultiTexCoord2bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bOES(texture: DummyEnum; s: SByte; t: SByte) := z_MultiTexCoord2bOES(texture, s, t);
    
    public z_MultiTexCoord2bvOES: procedure(texture: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoord2bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bvOES(texture: DummyEnum; coords: array of SByte) := MultiTexCoord2bvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bvOES(texture: DummyEnum; var coords: SByte) := MultiTexCoord2bvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2bvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord2bvOES(texture, coords);
    
    public z_MultiTexCoord3bOES: procedure(texture: DummyEnum; s: SByte; t: SByte; r: SByte) := FuncPtrOrNil&<procedure(texture: DummyEnum; s: SByte; t: SByte; r: SByte)>(GetGLProcAdr('glMultiTexCoord3bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bOES(texture: DummyEnum; s: SByte; t: SByte; r: SByte) := z_MultiTexCoord3bOES(texture, s, t, r);
    
    public z_MultiTexCoord3bvOES: procedure(texture: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoord3bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bvOES(texture: DummyEnum; coords: array of SByte) := MultiTexCoord3bvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bvOES(texture: DummyEnum; var coords: SByte) := MultiTexCoord3bvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3bvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord3bvOES(texture, coords);
    
    public z_MultiTexCoord4bOES: procedure(texture: DummyEnum; s: SByte; t: SByte; r: SByte; q: SByte) := FuncPtrOrNil&<procedure(texture: DummyEnum; s: SByte; t: SByte; r: SByte; q: SByte)>(GetGLProcAdr('glMultiTexCoord4bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bOES(texture: DummyEnum; s: SByte; t: SByte; r: SByte; q: SByte) := z_MultiTexCoord4bOES(texture, s, t, r, q);
    
    public z_MultiTexCoord4bvOES: procedure(texture: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoord4bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bvOES(texture: DummyEnum; coords: array of SByte) := MultiTexCoord4bvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bvOES(texture: DummyEnum; var coords: SByte) := MultiTexCoord4bvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4bvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord4bvOES(texture, coords);
    
    public z_TexCoord1bOES: procedure(s: SByte) := FuncPtrOrNil&<procedure(s: SByte)>(GetGLProcAdr('glTexCoord1bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bOES(s: SByte) := z_TexCoord1bOES(s);
    
    public z_TexCoord1bvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glTexCoord1bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bvOES(coords: array of SByte) := TexCoord1bvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bvOES(var coords: SByte) := TexCoord1bvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1bvOES(coords: pointer) := z_TexCoord1bvOES(coords);
    
    public z_TexCoord2bOES: procedure(s: SByte; t: SByte) := FuncPtrOrNil&<procedure(s: SByte; t: SByte)>(GetGLProcAdr('glTexCoord2bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bOES(s: SByte; t: SByte) := z_TexCoord2bOES(s, t);
    
    public z_TexCoord2bvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glTexCoord2bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bvOES(coords: array of SByte) := TexCoord2bvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bvOES(var coords: SByte) := TexCoord2bvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2bvOES(coords: pointer) := z_TexCoord2bvOES(coords);
    
    public z_TexCoord3bOES: procedure(s: SByte; t: SByte; r: SByte) := FuncPtrOrNil&<procedure(s: SByte; t: SByte; r: SByte)>(GetGLProcAdr('glTexCoord3bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bOES(s: SByte; t: SByte; r: SByte) := z_TexCoord3bOES(s, t, r);
    
    public z_TexCoord3bvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glTexCoord3bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bvOES(coords: array of SByte) := TexCoord3bvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bvOES(var coords: SByte) := TexCoord3bvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3bvOES(coords: pointer) := z_TexCoord3bvOES(coords);
    
    public z_TexCoord4bOES: procedure(s: SByte; t: SByte; r: SByte; q: SByte) := FuncPtrOrNil&<procedure(s: SByte; t: SByte; r: SByte; q: SByte)>(GetGLProcAdr('glTexCoord4bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bOES(s: SByte; t: SByte; r: SByte; q: SByte) := z_TexCoord4bOES(s, t, r, q);
    
    public z_TexCoord4bvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glTexCoord4bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bvOES(coords: array of SByte) := TexCoord4bvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bvOES(var coords: SByte) := TexCoord4bvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4bvOES(coords: pointer) := z_TexCoord4bvOES(coords);
    
    public z_Vertex2bOES: procedure(x: SByte; y: SByte) := FuncPtrOrNil&<procedure(x: SByte; y: SByte)>(GetGLProcAdr('glVertex2bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bOES(x: SByte; y: SByte) := z_Vertex2bOES(x, y);
    
    public z_Vertex2bvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glVertex2bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bvOES(coords: array of SByte) := Vertex2bvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bvOES(var coords: SByte) := Vertex2bvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2bvOES(coords: pointer) := z_Vertex2bvOES(coords);
    
    public z_Vertex3bOES: procedure(x: SByte; y: SByte; z: SByte) := FuncPtrOrNil&<procedure(x: SByte; y: SByte; z: SByte)>(GetGLProcAdr('glVertex3bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bOES(x: SByte; y: SByte; z: SByte) := z_Vertex3bOES(x, y, z);
    
    public z_Vertex3bvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glVertex3bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bvOES(coords: array of SByte) := Vertex3bvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bvOES(var coords: SByte) := Vertex3bvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3bvOES(coords: pointer) := z_Vertex3bvOES(coords);
    
    public z_Vertex4bOES: procedure(x: SByte; y: SByte; z: SByte; w: SByte) := FuncPtrOrNil&<procedure(x: SByte; y: SByte; z: SByte; w: SByte)>(GetGLProcAdr('glVertex4bOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bOES(x: SByte; y: SByte; z: SByte; w: SByte) := z_Vertex4bOES(x, y, z, w);
    
    public z_Vertex4bvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glVertex4bvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bvOES(coords: array of SByte) := Vertex4bvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bvOES(var coords: SByte) := Vertex4bvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4bvOES(coords: pointer) := z_Vertex4bvOES(coords);
    
    {$endregion Unsorted}
    
    {$region OES_draw_texture}
    
    public z_DrawTexsOES: procedure(x: Int16; y: Int16; z: Int16; width: Int16; height: Int16) := FuncPtrOrNil&<procedure(x: Int16; y: Int16; z: Int16; width: Int16; height: Int16)>(GetGLProcAdr('glDrawTexsOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexsOES(x: Int16; y: Int16; z: Int16; width: Int16; height: Int16) := z_DrawTexsOES(x, y, z, width, height);
    
    public z_DrawTexiOES: procedure(x: Int32; y: Int32; z: Int32; width: Int32; height: Int32) := FuncPtrOrNil&<procedure(x: Int32; y: Int32; z: Int32; width: Int32; height: Int32)>(GetGLProcAdr('glDrawTexiOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexiOES(x: Int32; y: Int32; z: Int32; width: Int32; height: Int32) := z_DrawTexiOES(x, y, z, width, height);
    
    public z_DrawTexfOES: procedure(x: single; y: single; z: single; width: single; height: single) := FuncPtrOrNil&<procedure(x: single; y: single; z: single; width: single; height: single)>(GetGLProcAdr('glDrawTexfOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexfOES(x: single; y: single; z: single; width: single; height: single) := z_DrawTexfOES(x, y, z, width, height);
    
    public z_DrawTexxOES: procedure(x: fixed; y: fixed; z: fixed; width: fixed; height: fixed) := FuncPtrOrNil&<procedure(x: fixed; y: fixed; z: fixed; width: fixed; height: fixed)>(GetGLProcAdr('glDrawTexxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexxOES(x: fixed; y: fixed; z: fixed; width: fixed; height: fixed) := z_DrawTexxOES(x, y, z, width, height);
    
    public z_DrawTexsvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glDrawTexsvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexsvOES(coords: array of Int16) := DrawTexsvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexsvOES(var coords: Int16) := DrawTexsvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexsvOES(coords: pointer) := z_DrawTexsvOES(coords);
    
    public z_DrawTexivOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glDrawTexivOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexivOES(coords: array of Int32) := DrawTexivOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexivOES(var coords: Int32) := DrawTexivOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexivOES(coords: pointer) := z_DrawTexivOES(coords);
    
    public z_DrawTexfvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glDrawTexfvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexfvOES(coords: array of single) := DrawTexfvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexfvOES(var coords: single) := DrawTexfvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexfvOES(coords: pointer) := z_DrawTexfvOES(coords);
    
    public z_DrawTexxvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glDrawTexxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexxvOES(coords: array of fixed) := DrawTexxvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexxvOES(var coords: fixed) := DrawTexxvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawTexxvOES(coords: pointer) := z_DrawTexxvOES(coords);
    
    {$endregion OES_draw_texture}
    
    {$region OES_EGL_image}
    
    public z_EGLImageTargetRenderbufferStorageOES: procedure(target: DummyEnum; image: GLeglImageOES) := FuncPtrOrNil&<procedure(target: DummyEnum; image: GLeglImageOES)>(GetGLProcAdr('glEGLImageTargetRenderbufferStorageOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetRenderbufferStorageOES(target: DummyEnum; image: GLeglImageOES) := z_EGLImageTargetRenderbufferStorageOES(target, image);
    
    {$endregion OES_EGL_image}
    
    {$region OES_fixed_point}
    
    public z_Vertex2xOES: procedure(x: fixed) := FuncPtrOrNil&<procedure(x: fixed)>(GetGLProcAdr('glVertex2xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xOES(x: fixed) := z_Vertex2xOES(x);
    
    public z_Vertex3xOES: procedure(x: fixed; y: fixed) := FuncPtrOrNil&<procedure(x: fixed; y: fixed)>(GetGLProcAdr('glVertex3xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xOES(x: fixed; y: fixed) := z_Vertex3xOES(x, y);
    
    public z_Vertex4xOES: procedure(x: fixed; y: fixed; z: fixed) := FuncPtrOrNil&<procedure(x: fixed; y: fixed; z: fixed)>(GetGLProcAdr('glVertex4xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xOES(x: fixed; y: fixed; z: fixed) := z_Vertex4xOES(x, y, z);
    
    public z_Vertex2xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glVertex2xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(coords: array of fixed) := Vertex2xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(var coords: fixed) := Vertex2xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex2xvOES(coords: pointer) := z_Vertex2xvOES(coords);
    
    public z_Vertex3xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glVertex3xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(coords: array of fixed) := Vertex3xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(var coords: fixed) := Vertex3xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex3xvOES(coords: pointer) := z_Vertex3xvOES(coords);
    
    public z_Vertex4xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glVertex4xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(coords: array of fixed) := Vertex4xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(var coords: fixed) := Vertex4xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Vertex4xvOES(coords: pointer) := z_Vertex4xvOES(coords);
    
    public z_Normal3xOES: procedure(nx: fixed; ny: fixed; nz: fixed) := FuncPtrOrNil&<procedure(nx: fixed; ny: fixed; nz: fixed)>(GetGLProcAdr('glNormal3xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xOES(nx: fixed; ny: fixed; nz: fixed) := z_Normal3xOES(nx, ny, nz);
    
    public z_Normal3xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glNormal3xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(coords: array of fixed) := Normal3xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(var coords: fixed) := Normal3xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3xvOES(coords: pointer) := z_Normal3xvOES(coords);
    
    public z_TexCoord1xOES: procedure(s: fixed) := FuncPtrOrNil&<procedure(s: fixed)>(GetGLProcAdr('glTexCoord1xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xOES(s: fixed) := z_TexCoord1xOES(s);
    
    public z_TexCoord2xOES: procedure(s: fixed; t: fixed) := FuncPtrOrNil&<procedure(s: fixed; t: fixed)>(GetGLProcAdr('glTexCoord2xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xOES(s: fixed; t: fixed) := z_TexCoord2xOES(s, t);
    
    public z_TexCoord3xOES: procedure(s: fixed; t: fixed; r: fixed) := FuncPtrOrNil&<procedure(s: fixed; t: fixed; r: fixed)>(GetGLProcAdr('glTexCoord3xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xOES(s: fixed; t: fixed; r: fixed) := z_TexCoord3xOES(s, t, r);
    
    public z_TexCoord4xOES: procedure(s: fixed; t: fixed; r: fixed; q: fixed) := FuncPtrOrNil&<procedure(s: fixed; t: fixed; r: fixed; q: fixed)>(GetGLProcAdr('glTexCoord4xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xOES(s: fixed; t: fixed; r: fixed; q: fixed) := z_TexCoord4xOES(s, t, r, q);
    
    public z_TexCoord1xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glTexCoord1xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(coords: array of fixed) := TexCoord1xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(var coords: fixed) := TexCoord1xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord1xvOES(coords: pointer) := z_TexCoord1xvOES(coords);
    
    public z_TexCoord2xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glTexCoord2xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(coords: array of fixed) := TexCoord2xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(var coords: fixed) := TexCoord2xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2xvOES(coords: pointer) := z_TexCoord2xvOES(coords);
    
    public z_TexCoord3xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glTexCoord3xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(coords: array of fixed) := TexCoord3xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(var coords: fixed) := TexCoord3xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord3xvOES(coords: pointer) := z_TexCoord3xvOES(coords);
    
    public z_TexCoord4xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glTexCoord4xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(coords: array of fixed) := TexCoord4xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(var coords: fixed) := TexCoord4xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4xvOES(coords: pointer) := z_TexCoord4xvOES(coords);
    
    public z_MultiTexCoord1xOES: procedure(texture: DummyEnum; s: fixed) := FuncPtrOrNil&<procedure(texture: DummyEnum; s: fixed)>(GetGLProcAdr('glMultiTexCoord1xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xOES(texture: DummyEnum; s: fixed) := z_MultiTexCoord1xOES(texture, s);
    
    public z_MultiTexCoord2xOES: procedure(texture: DummyEnum; s: fixed; t: fixed) := FuncPtrOrNil&<procedure(texture: DummyEnum; s: fixed; t: fixed)>(GetGLProcAdr('glMultiTexCoord2xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xOES(texture: DummyEnum; s: fixed; t: fixed) := z_MultiTexCoord2xOES(texture, s, t);
    
    public z_MultiTexCoord3xOES: procedure(texture: DummyEnum; s: fixed; t: fixed; r: fixed) := FuncPtrOrNil&<procedure(texture: DummyEnum; s: fixed; t: fixed; r: fixed)>(GetGLProcAdr('glMultiTexCoord3xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xOES(texture: DummyEnum; s: fixed; t: fixed; r: fixed) := z_MultiTexCoord3xOES(texture, s, t, r);
    
    public z_MultiTexCoord4xOES: procedure(texture: DummyEnum; s: fixed; t: fixed; r: fixed; q: fixed) := FuncPtrOrNil&<procedure(texture: DummyEnum; s: fixed; t: fixed; r: fixed; q: fixed)>(GetGLProcAdr('glMultiTexCoord4xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xOES(texture: DummyEnum; s: fixed; t: fixed; r: fixed; q: fixed) := z_MultiTexCoord4xOES(texture, s, t, r, q);
    
    public z_MultiTexCoord1xvOES: procedure(texture: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoord1xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: DummyEnum; coords: array of fixed) := MultiTexCoord1xvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: DummyEnum; var coords: fixed) := MultiTexCoord1xvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1xvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord1xvOES(texture, coords);
    
    public z_MultiTexCoord2xvOES: procedure(texture: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoord2xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: DummyEnum; coords: array of fixed) := MultiTexCoord2xvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: DummyEnum; var coords: fixed) := MultiTexCoord2xvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2xvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord2xvOES(texture, coords);
    
    public z_MultiTexCoord3xvOES: procedure(texture: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoord3xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: DummyEnum; coords: array of fixed) := MultiTexCoord3xvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: DummyEnum; var coords: fixed) := MultiTexCoord3xvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3xvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord3xvOES(texture, coords);
    
    public z_MultiTexCoord4xvOES: procedure(texture: DummyEnum; coords: pointer) := FuncPtrOrNil&<procedure(texture: DummyEnum; coords: pointer)>(GetGLProcAdr('glMultiTexCoord4xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: DummyEnum; coords: array of fixed) := MultiTexCoord4xvOES(texture, coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: DummyEnum; var coords: fixed) := MultiTexCoord4xvOES(texture, @coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4xvOES(texture: DummyEnum; coords: pointer) := z_MultiTexCoord4xvOES(texture, coords);
    
    public z_Color3xOES: procedure(red: fixed; green: fixed; blue: fixed) := FuncPtrOrNil&<procedure(red: fixed; green: fixed; blue: fixed)>(GetGLProcAdr('glColor3xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xOES(red: fixed; green: fixed; blue: fixed) := z_Color3xOES(red, green, blue);
    
    public z_Color4xOES: procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed) := FuncPtrOrNil&<procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed)>(GetGLProcAdr('glColor4xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xOES(red: fixed; green: fixed; blue: fixed; alpha: fixed) := z_Color4xOES(red, green, blue, alpha);
    
    public z_Color3xvOES: procedure(components: pointer) := FuncPtrOrNil&<procedure(components: pointer)>(GetGLProcAdr('glColor3xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(components: array of fixed) := Color3xvOES(components[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(var components: fixed) := Color3xvOES(@components);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3xvOES(components: pointer) := z_Color3xvOES(components);
    
    public z_Color4xvOES: procedure(components: pointer) := FuncPtrOrNil&<procedure(components: pointer)>(GetGLProcAdr('glColor4xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(components: array of fixed) := Color4xvOES(components[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(var components: fixed) := Color4xvOES(@components);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4xvOES(components: pointer) := z_Color4xvOES(components);
    
    public z_IndexxOES: procedure(component: fixed) := FuncPtrOrNil&<procedure(component: fixed)>(GetGLProcAdr('glIndexxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxOES(component: fixed) := z_IndexxOES(component);
    
    public z_IndexxvOES: procedure(component: pointer) := FuncPtrOrNil&<procedure(component: pointer)>(GetGLProcAdr('glIndexxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(component: array of fixed) := IndexxvOES(component[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(var component: fixed) := IndexxvOES(@component);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IndexxvOES(component: pointer) := z_IndexxvOES(component);
    
    public z_RectxOES: procedure(x1: fixed; y1: fixed; x2: fixed; y2: fixed) := FuncPtrOrNil&<procedure(x1: fixed; y1: fixed; x2: fixed; y2: fixed)>(GetGLProcAdr('glRectxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxOES(x1: fixed; y1: fixed; x2: fixed; y2: fixed) := z_RectxOES(x1, y1, x2, y2);
    
    public z_RectxvOES: procedure(v1: pointer; v2: pointer) := FuncPtrOrNil&<procedure(v1: pointer; v2: pointer)>(GetGLProcAdr('glRectxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: array of fixed; v2: array of fixed) := RectxvOES(v1[0], v2[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: array of fixed; var v2: fixed) := RectxvOES(v1[0], @v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: array of fixed; v2: pointer) := RectxvOES(v1[0], v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(var v1: fixed; v2: array of fixed) := RectxvOES(@v1, v2[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(var v1: fixed; var v2: fixed) := RectxvOES(@v1, @v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(var v1: fixed; v2: pointer) := RectxvOES(@v1, v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: pointer; v2: array of fixed) := RectxvOES(v1, v2[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: pointer; var v2: fixed) := RectxvOES(v1, @v2);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RectxvOES(v1: pointer; v2: pointer) := z_RectxvOES(v1, v2);
    
    public z_DepthRangexOES: procedure(n: fixed; f: fixed) := FuncPtrOrNil&<procedure(n: fixed; f: fixed)>(GetGLProcAdr('glDepthRangexOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangexOES(n: fixed; f: fixed) := z_DepthRangexOES(n, f);
    
    public z_LoadMatrixxOES: procedure(m: pointer) := FuncPtrOrNil&<procedure(m: pointer)>(GetGLProcAdr('glLoadMatrixxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(m: array of fixed) := LoadMatrixxOES(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(var m: fixed) := LoadMatrixxOES(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadMatrixxOES(m: pointer) := z_LoadMatrixxOES(m);
    
    public z_MultMatrixxOES: procedure(m: pointer) := FuncPtrOrNil&<procedure(m: pointer)>(GetGLProcAdr('glMultMatrixxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(m: array of fixed) := MultMatrixxOES(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(var m: fixed) := MultMatrixxOES(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultMatrixxOES(m: pointer) := z_MultMatrixxOES(m);
    
    public z_LoadTransposeMatrixxOES: procedure(m: pointer) := FuncPtrOrNil&<procedure(m: pointer)>(GetGLProcAdr('glLoadTransposeMatrixxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(m: array of fixed) := LoadTransposeMatrixxOES(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(var m: fixed) := LoadTransposeMatrixxOES(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadTransposeMatrixxOES(m: pointer) := z_LoadTransposeMatrixxOES(m);
    
    public z_MultTransposeMatrixxOES: procedure(m: pointer) := FuncPtrOrNil&<procedure(m: pointer)>(GetGLProcAdr('glMultTransposeMatrixxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(m: array of fixed) := MultTransposeMatrixxOES(m[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(var m: fixed) := MultTransposeMatrixxOES(@m);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultTransposeMatrixxOES(m: pointer) := z_MultTransposeMatrixxOES(m);
    
    public z_RotatexOES: procedure(angle: fixed; x: fixed; y: fixed; z: fixed) := FuncPtrOrNil&<procedure(angle: fixed; x: fixed; y: fixed; z: fixed)>(GetGLProcAdr('glRotatexOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RotatexOES(angle: fixed; x: fixed; y: fixed; z: fixed) := z_RotatexOES(angle, x, y, z);
    
    public z_ScalexOES: procedure(x: fixed; y: fixed; z: fixed) := FuncPtrOrNil&<procedure(x: fixed; y: fixed; z: fixed)>(GetGLProcAdr('glScalexOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ScalexOES(x: fixed; y: fixed; z: fixed) := z_ScalexOES(x, y, z);
    
    public z_TranslatexOES: procedure(x: fixed; y: fixed; z: fixed) := FuncPtrOrNil&<procedure(x: fixed; y: fixed; z: fixed)>(GetGLProcAdr('glTranslatexOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TranslatexOES(x: fixed; y: fixed; z: fixed) := z_TranslatexOES(x, y, z);
    
    public z_FrustumxOES: procedure(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed) := FuncPtrOrNil&<procedure(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed)>(GetGLProcAdr('glFrustumxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrustumxOES(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed) := z_FrustumxOES(l, r, b, t, n, f);
    
    public z_OrthoxOES: procedure(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed) := FuncPtrOrNil&<procedure(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed)>(GetGLProcAdr('glOrthoxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure OrthoxOES(l: fixed; r: fixed; b: fixed; t: fixed; n: fixed; f: fixed) := z_OrthoxOES(l, r, b, t, n, f);
    
    public z_GetClipPlanexOES: procedure(plane: DummyEnum; equation: pointer) := FuncPtrOrNil&<procedure(plane: DummyEnum; equation: pointer)>(GetGLProcAdr('glGetClipPlanexOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanexOES(plane: DummyEnum; equation: array of fixed) := GetClipPlanexOES(plane, equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanexOES(plane: DummyEnum; var equation: fixed) := GetClipPlanexOES(plane, @equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanexOES(plane: DummyEnum; equation: pointer) := z_GetClipPlanexOES(plane, equation);
    
    public z_RasterPos2xOES: procedure(x: fixed; y: fixed) := FuncPtrOrNil&<procedure(x: fixed; y: fixed)>(GetGLProcAdr('glRasterPos2xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xOES(x: fixed; y: fixed) := z_RasterPos2xOES(x, y);
    
    public z_RasterPos3xOES: procedure(x: fixed; y: fixed; z: fixed) := FuncPtrOrNil&<procedure(x: fixed; y: fixed; z: fixed)>(GetGLProcAdr('glRasterPos3xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xOES(x: fixed; y: fixed; z: fixed) := z_RasterPos3xOES(x, y, z);
    
    public z_RasterPos4xOES: procedure(x: fixed; y: fixed; z: fixed; w: fixed) := FuncPtrOrNil&<procedure(x: fixed; y: fixed; z: fixed; w: fixed)>(GetGLProcAdr('glRasterPos4xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xOES(x: fixed; y: fixed; z: fixed; w: fixed) := z_RasterPos4xOES(x, y, z, w);
    
    public z_RasterPos2xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glRasterPos2xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(coords: array of fixed) := RasterPos2xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(var coords: fixed) := RasterPos2xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos2xvOES(coords: pointer) := z_RasterPos2xvOES(coords);
    
    public z_RasterPos3xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glRasterPos3xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(coords: array of fixed) := RasterPos3xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(var coords: fixed) := RasterPos3xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos3xvOES(coords: pointer) := z_RasterPos3xvOES(coords);
    
    public z_RasterPos4xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glRasterPos4xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(coords: array of fixed) := RasterPos4xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(var coords: fixed) := RasterPos4xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure RasterPos4xvOES(coords: pointer) := z_RasterPos4xvOES(coords);
    
    public z_MaterialxOES: procedure(face: DummyEnum; pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; param: fixed)>(GetGLProcAdr('glMaterialxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxOES(face: DummyEnum; pname: DummyEnum; param: fixed) := z_MaterialxOES(face, pname, param);
    
    public z_MaterialxvOES: procedure(face: DummyEnum; pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; param: pointer)>(GetGLProcAdr('glMaterialxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: DummyEnum; pname: DummyEnum; param: array of fixed) := MaterialxvOES(face, pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: DummyEnum; pname: DummyEnum; var param: fixed) := MaterialxvOES(face, pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MaterialxvOES(face: DummyEnum; pname: DummyEnum; param: pointer) := z_MaterialxvOES(face, pname, param);
    
    public z_GetMaterialxOES: procedure(face: DummyEnum; pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; param: fixed)>(GetGLProcAdr('glGetMaterialxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMaterialxOES(face: DummyEnum; pname: DummyEnum; param: fixed) := z_GetMaterialxOES(face, pname, param);
    
    public z_LightxOES: procedure(light: DummyEnum; pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; param: fixed)>(GetGLProcAdr('glLightxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxOES(light: DummyEnum; pname: DummyEnum; param: fixed) := z_LightxOES(light, pname, param);
    
    public z_LightxvOES: procedure(light: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glLightxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: DummyEnum; pname: DummyEnum; &params: array of fixed) := LightxvOES(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: DummyEnum; pname: DummyEnum; var &params: fixed) := LightxvOES(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightxvOES(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_LightxvOES(light, pname, &params);
    
    public z_GetLightxOES: procedure(light: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetLightxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxOES(light: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetLightxOES(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxOES(light: DummyEnum; pname: DummyEnum; var &params: fixed) := GetLightxOES(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetLightxOES(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetLightxOES(light, pname, &params);
    
    public z_LightModelxOES: procedure(pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: fixed)>(GetGLProcAdr('glLightModelxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxOES(pname: DummyEnum; param: fixed) := z_LightModelxOES(pname, param);
    
    public z_LightModelxvOES: procedure(pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: pointer)>(GetGLProcAdr('glLightModelxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: DummyEnum; param: array of fixed) := LightModelxvOES(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: DummyEnum; var param: fixed) := LightModelxvOES(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightModelxvOES(pname: DummyEnum; param: pointer) := z_LightModelxvOES(pname, param);
    
    public z_PointSizexOES: procedure(size: fixed) := FuncPtrOrNil&<procedure(size: fixed)>(GetGLProcAdr('glPointSizexOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointSizexOES(size: fixed) := z_PointSizexOES(size);
    
    public z_PointParameterxvOES: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glPointParameterxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: DummyEnum; &params: array of fixed) := PointParameterxvOES(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: DummyEnum; var &params: fixed) := PointParameterxvOES(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointParameterxvOES(pname: DummyEnum; &params: pointer) := z_PointParameterxvOES(pname, &params);
    
    public z_LineWidthxOES: procedure(width: fixed) := FuncPtrOrNil&<procedure(width: fixed)>(GetGLProcAdr('glLineWidthxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LineWidthxOES(width: fixed) := z_LineWidthxOES(width);
    
    public z_PolygonOffsetxOES: procedure(factor: fixed; units: fixed) := FuncPtrOrNil&<procedure(factor: fixed; units: fixed)>(GetGLProcAdr('glPolygonOffsetxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PolygonOffsetxOES(factor: fixed; units: fixed) := z_PolygonOffsetxOES(factor, units);
    
    public z_PixelTransferxOES: procedure(pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: fixed)>(GetGLProcAdr('glPixelTransferxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransferxOES(pname: DummyEnum; param: fixed) := z_PixelTransferxOES(pname, param);
    
    public z_ConvolutionParameterxOES: procedure(target: DummyEnum; pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: fixed)>(GetGLProcAdr('glConvolutionParameterxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxOES(target: DummyEnum; pname: DummyEnum; param: fixed) := z_ConvolutionParameterxOES(target, pname, param);
    
    public z_ConvolutionParameterxvOES: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glConvolutionParameterxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := ConvolutionParameterxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := ConvolutionParameterxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_ConvolutionParameterxvOES(target, pname, &params);
    
    public z_GetConvolutionParameterxvOES: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetConvolutionParameterxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetConvolutionParameterxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := GetConvolutionParameterxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetConvolutionParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetConvolutionParameterxvOES(target, pname, &params);
    
    public z_GetHistogramParameterxvOES: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetHistogramParameterxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetHistogramParameterxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := GetHistogramParameterxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetHistogramParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetHistogramParameterxvOES(target, pname, &params);
    
    public z_PixelZoomxOES: procedure(xfactor: fixed; yfactor: fixed) := FuncPtrOrNil&<procedure(xfactor: fixed; yfactor: fixed)>(GetGLProcAdr('glPixelZoomxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelZoomxOES(xfactor: fixed; yfactor: fixed) := z_PixelZoomxOES(xfactor, yfactor);
    
    public z_BitmapxOES: procedure(width: Int32; height: Int32; xorig: fixed; yorig: fixed; xmove: fixed; ymove: fixed; bitmap: pointer) := FuncPtrOrNil&<procedure(width: Int32; height: Int32; xorig: fixed; yorig: fixed; xmove: fixed; ymove: fixed; bitmap: pointer)>(GetGLProcAdr('glBitmapxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: fixed; yorig: fixed; xmove: fixed; ymove: fixed; bitmap: array of Byte) := BitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: fixed; yorig: fixed; xmove: fixed; ymove: fixed; var bitmap: Byte) := BitmapxOES(width, height, xorig, yorig, xmove, ymove, @bitmap);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BitmapxOES(width: Int32; height: Int32; xorig: fixed; yorig: fixed; xmove: fixed; ymove: fixed; bitmap: pointer) := z_BitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap);
    
    public z_TexParameterxOES: procedure(target: DummyEnum; pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: fixed)>(GetGLProcAdr('glTexParameterxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxOES(target: DummyEnum; pname: DummyEnum; param: fixed) := z_TexParameterxOES(target, pname, param);
    
    public z_GetTexParameterxvOES: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetTexParameterxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetTexParameterxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := GetTexParameterxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexParameterxvOES(target, pname, &params);
    
    public z_GetTexLevelParameterxvOES: procedure(target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetTexLevelParameterxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterxvOES(target: DummyEnum; level: Int32; pname: DummyEnum; &params: array of fixed) := GetTexLevelParameterxvOES(target, level, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterxvOES(target: DummyEnum; level: Int32; pname: DummyEnum; var &params: fixed) := GetTexLevelParameterxvOES(target, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexLevelParameterxvOES(target: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := z_GetTexLevelParameterxvOES(target, level, pname, &params);
    
    public z_PrioritizeTexturesxOES: procedure(n: Int32; textures: pointer; priorities: pointer) := FuncPtrOrNil&<procedure(n: Int32; textures: pointer; priorities: pointer)>(GetGLProcAdr('glPrioritizeTexturesxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: array of UInt32; priorities: array of fixed) := PrioritizeTexturesxOES(n, textures[0], priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: array of UInt32; var priorities: fixed) := PrioritizeTexturesxOES(n, textures[0], @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: array of UInt32; priorities: pointer) := PrioritizeTexturesxOES(n, textures[0], priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; var textures: UInt32; priorities: array of fixed) := PrioritizeTexturesxOES(n, @textures, priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; var textures: UInt32; var priorities: fixed) := PrioritizeTexturesxOES(n, @textures, @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; var textures: UInt32; priorities: pointer) := PrioritizeTexturesxOES(n, @textures, priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: pointer; priorities: array of fixed) := PrioritizeTexturesxOES(n, textures, priorities[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: pointer; var priorities: fixed) := PrioritizeTexturesxOES(n, textures, @priorities);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PrioritizeTexturesxOES(n: Int32; textures: pointer; priorities: pointer) := z_PrioritizeTexturesxOES(n, textures, priorities);
    
    public z_TexEnvxOES: procedure(target: DummyEnum; pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: fixed)>(GetGLProcAdr('glTexEnvxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxOES(target: DummyEnum; pname: DummyEnum; param: fixed) := z_TexEnvxOES(target, pname, param);
    
    public z_TexEnvxvOES: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glTexEnvxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := TexEnvxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := TexEnvxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexEnvxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexEnvxvOES(target, pname, &params);
    
    public z_GetTexEnvxvOES: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetTexEnvxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetTexEnvxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := GetTexEnvxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexEnvxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexEnvxvOES(target, pname, &params);
    
    public z_FogxOES: procedure(pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: fixed)>(GetGLProcAdr('glFogxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxOES(pname: DummyEnum; param: fixed) := z_FogxOES(pname, param);
    
    public z_FogxvOES: procedure(pname: DummyEnum; param: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: pointer)>(GetGLProcAdr('glFogxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: DummyEnum; param: array of fixed) := FogxvOES(pname, param[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: DummyEnum; var param: fixed) := FogxvOES(pname, @param);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogxvOES(pname: DummyEnum; param: pointer) := z_FogxvOES(pname, param);
    
    public z_SampleCoveragex: procedure(value: Int32; invert: Byte) := FuncPtrOrNil&<procedure(value: Int32; invert: Byte)>(GetGLProcAdr('glSampleCoveragex'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SampleCoveragex(value: Int32; invert: Byte) := z_SampleCoveragex(value, invert);
    
    public z_AlphaFuncxOES: procedure(func: DummyEnum; ref: fixed) := FuncPtrOrNil&<procedure(func: DummyEnum; ref: fixed)>(GetGLProcAdr('glAlphaFuncxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AlphaFuncxOES(func: DummyEnum; ref: fixed) := z_AlphaFuncxOES(func, ref);
    
    public z_BlendColorxOES: procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed) := FuncPtrOrNil&<procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed)>(GetGLProcAdr('glBlendColorxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure BlendColorxOES(red: fixed; green: fixed; blue: fixed; alpha: fixed) := z_BlendColorxOES(red, green, blue, alpha);
    
    public z_ClearColorxOES: procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed) := FuncPtrOrNil&<procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed)>(GetGLProcAdr('glClearColorxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearColorxOES(red: fixed; green: fixed; blue: fixed; alpha: fixed) := z_ClearColorxOES(red, green, blue, alpha);
    
    public z_ClearDepthxOES: procedure(depth: fixed) := FuncPtrOrNil&<procedure(depth: fixed)>(GetGLProcAdr('glClearDepthxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearDepthxOES(depth: fixed) := z_ClearDepthxOES(depth);
    
    public z_ClearAccumxOES: procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed) := FuncPtrOrNil&<procedure(red: fixed; green: fixed; blue: fixed; alpha: fixed)>(GetGLProcAdr('glClearAccumxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClearAccumxOES(red: fixed; green: fixed; blue: fixed; alpha: fixed) := z_ClearAccumxOES(red, green, blue, alpha);
    
    public z_AccumxOES: procedure(op: DummyEnum; value: fixed) := FuncPtrOrNil&<procedure(op: DummyEnum; value: fixed)>(GetGLProcAdr('glAccumxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AccumxOES(op: DummyEnum; value: fixed) := z_AccumxOES(op, value);
    
    public z_Map1xOES: procedure(target: DummyEnum; u1: fixed; u2: fixed; stride: Int32; order: Int32; points: fixed) := FuncPtrOrNil&<procedure(target: DummyEnum; u1: fixed; u2: fixed; stride: Int32; order: Int32; points: fixed)>(GetGLProcAdr('glMap1xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map1xOES(target: DummyEnum; u1: fixed; u2: fixed; stride: Int32; order: Int32; points: fixed) := z_Map1xOES(target, u1, u2, stride, order, points);
    
    public z_Map2xOES: procedure(target: DummyEnum; u1: fixed; u2: fixed; ustride: Int32; uorder: Int32; v1: fixed; v2: fixed; vstride: Int32; vorder: Int32; points: fixed) := FuncPtrOrNil&<procedure(target: DummyEnum; u1: fixed; u2: fixed; ustride: Int32; uorder: Int32; v1: fixed; v2: fixed; vstride: Int32; vorder: Int32; points: fixed)>(GetGLProcAdr('glMap2xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Map2xOES(target: DummyEnum; u1: fixed; u2: fixed; ustride: Int32; uorder: Int32; v1: fixed; v2: fixed; vstride: Int32; vorder: Int32; points: fixed) := z_Map2xOES(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
    
    public z_MapGrid1xOES: procedure(n: Int32; u1: fixed; u2: fixed) := FuncPtrOrNil&<procedure(n: Int32; u1: fixed; u2: fixed)>(GetGLProcAdr('glMapGrid1xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid1xOES(n: Int32; u1: fixed; u2: fixed) := z_MapGrid1xOES(n, u1, u2);
    
    public z_MapGrid2xOES: procedure(n: Int32; u1: fixed; u2: fixed; v1: fixed; v2: fixed) := FuncPtrOrNil&<procedure(n: Int32; u1: fixed; u2: fixed; v1: fixed; v2: fixed)>(GetGLProcAdr('glMapGrid2xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MapGrid2xOES(n: Int32; u1: fixed; u2: fixed; v1: fixed; v2: fixed) := z_MapGrid2xOES(n, u1, u2, v1, v2);
    
    public z_GetMapxvOES: procedure(target: DummyEnum; query: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; query: DummyEnum; v: pointer)>(GetGLProcAdr('glGetMapxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapxvOES(target: DummyEnum; query: DummyEnum; v: array of fixed) := GetMapxvOES(target, query, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapxvOES(target: DummyEnum; query: DummyEnum; var v: fixed) := GetMapxvOES(target, query, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetMapxvOES(target: DummyEnum; query: DummyEnum; v: pointer) := z_GetMapxvOES(target, query, v);
    
    public z_EvalCoord1xOES: procedure(u: fixed) := FuncPtrOrNil&<procedure(u: fixed)>(GetGLProcAdr('glEvalCoord1xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xOES(u: fixed) := z_EvalCoord1xOES(u);
    
    public z_EvalCoord2xOES: procedure(u: fixed; v: fixed) := FuncPtrOrNil&<procedure(u: fixed; v: fixed)>(GetGLProcAdr('glEvalCoord2xOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xOES(u: fixed; v: fixed) := z_EvalCoord2xOES(u, v);
    
    public z_EvalCoord1xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glEvalCoord1xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(coords: array of fixed) := EvalCoord1xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(var coords: fixed) := EvalCoord1xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord1xvOES(coords: pointer) := z_EvalCoord1xvOES(coords);
    
    public z_EvalCoord2xvOES: procedure(coords: pointer) := FuncPtrOrNil&<procedure(coords: pointer)>(GetGLProcAdr('glEvalCoord2xvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(coords: array of fixed) := EvalCoord2xvOES(coords[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(var coords: fixed) := EvalCoord2xvOES(@coords);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EvalCoord2xvOES(coords: pointer) := z_EvalCoord2xvOES(coords);
    
    public z_FeedbackBufferxOES: procedure(n: Int32; &type: DummyEnum; buffer: pointer) := FuncPtrOrNil&<procedure(n: Int32; &type: DummyEnum; buffer: pointer)>(GetGLProcAdr('glFeedbackBufferxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; buffer: array of fixed) := FeedbackBufferxOES(n, &type, buffer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; var buffer: fixed) := FeedbackBufferxOES(n, &type, @buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FeedbackBufferxOES(n: Int32; &type: DummyEnum; buffer: pointer) := z_FeedbackBufferxOES(n, &type, buffer);
    
    public z_PassThroughxOES: procedure(token: fixed) := FuncPtrOrNil&<procedure(token: fixed)>(GetGLProcAdr('glPassThroughxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PassThroughxOES(token: fixed) := z_PassThroughxOES(token);
    
    public z_GetFixedvOES: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetFixedvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFixedvOES(pname: DummyEnum; &params: array of fixed) := GetFixedvOES(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFixedvOES(pname: DummyEnum; var &params: fixed) := GetFixedvOES(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFixedvOES(pname: DummyEnum; &params: pointer) := z_GetFixedvOES(pname, &params);
    
    {$endregion OES_fixed_point}
    
    {$region OES_matrix_palette}
    
    public z_LoadPaletteFromModelViewMatrixOES: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glLoadPaletteFromModelViewMatrixOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadPaletteFromModelViewMatrixOES := z_LoadPaletteFromModelViewMatrixOES();
    
    {$endregion OES_matrix_palette}
    
    {$region OES_point_size_array}
    
    public z_PointSizePointerOES: procedure(&type: DummyEnum; stride: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>(GetGLProcAdr('glPointSizePointerOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PointSizePointerOES(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_PointSizePointerOES(&type, stride, _pointer);
    
    {$endregion OES_point_size_array}
    
    {$region OES_query_matrix}
    
    public z_QueryMatrixxOES: function(mantissa: pointer; exponent: pointer): DummyFlags := FuncPtrOrNil&<function(mantissa: pointer; exponent: pointer): DummyFlags>(GetGLProcAdr('glQueryMatrixxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: array of fixed; exponent: array of Int32): DummyFlags := QueryMatrixxOES(mantissa[0], exponent[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: array of fixed; var exponent: Int32): DummyFlags := QueryMatrixxOES(mantissa[0], @exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: array of fixed; exponent: pointer): DummyFlags := QueryMatrixxOES(mantissa[0], exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(var mantissa: fixed; exponent: array of Int32): DummyFlags := QueryMatrixxOES(@mantissa, exponent[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(var mantissa: fixed; var exponent: Int32): DummyFlags := QueryMatrixxOES(@mantissa, @exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(var mantissa: fixed; exponent: pointer): DummyFlags := QueryMatrixxOES(@mantissa, exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: pointer; exponent: array of Int32): DummyFlags := QueryMatrixxOES(mantissa, exponent[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: pointer; var exponent: Int32): DummyFlags := QueryMatrixxOES(mantissa, @exponent);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function QueryMatrixxOES(mantissa: pointer; exponent: pointer): DummyFlags := z_QueryMatrixxOES(mantissa, exponent);
    
    {$endregion OES_query_matrix}
    
    {$region OES_single_precision}
    
    public z_FrustumfOES: procedure(l: single; r: single; b: single; t: single; n: single; f: single) := FuncPtrOrNil&<procedure(l: single; r: single; b: single; t: single; n: single; f: single)>(GetGLProcAdr('glFrustumfOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrustumfOES(l: single; r: single; b: single; t: single; n: single; f: single) := z_FrustumfOES(l, r, b, t, n, f);
    
    public z_OrthofOES: procedure(l: single; r: single; b: single; t: single; n: single; f: single) := FuncPtrOrNil&<procedure(l: single; r: single; b: single; t: single; n: single; f: single)>(GetGLProcAdr('glOrthofOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure OrthofOES(l: single; r: single; b: single; t: single; n: single; f: single) := z_OrthofOES(l, r, b, t, n, f);
    
    public z_GetClipPlanefOES: procedure(plane: DummyEnum; equation: pointer) := FuncPtrOrNil&<procedure(plane: DummyEnum; equation: pointer)>(GetGLProcAdr('glGetClipPlanefOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanefOES(plane: DummyEnum; equation: array of single) := GetClipPlanefOES(plane, equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanefOES(plane: DummyEnum; var equation: single) := GetClipPlanefOES(plane, @equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetClipPlanefOES(plane: DummyEnum; equation: pointer) := z_GetClipPlanefOES(plane, equation);
    
    {$endregion OES_single_precision}
    
    {$region OES_texture_cube_map}
    
    public z_TexGenfOES: procedure(coord: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glTexGenfOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfOES(coord: DummyEnum; pname: DummyEnum; param: single) := z_TexGenfOES(coord, pname, param);
    
    public z_TexGenfvOES: procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glTexGenfvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfvOES(coord: DummyEnum; pname: DummyEnum; &params: array of single) := TexGenfvOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfvOES(coord: DummyEnum; pname: DummyEnum; var &params: single) := TexGenfvOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenfvOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexGenfvOES(coord, pname, &params);
    
    public z_TexGeniOES: procedure(coord: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glTexGeniOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGeniOES(coord: DummyEnum; pname: DummyEnum; param: Int32) := z_TexGeniOES(coord, pname, param);
    
    public z_TexGenivOES: procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glTexGenivOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenivOES(coord: DummyEnum; pname: DummyEnum; &params: array of Int32) := TexGenivOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenivOES(coord: DummyEnum; pname: DummyEnum; var &params: Int32) := TexGenivOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenivOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexGenivOES(coord, pname, &params);
    
    public z_GetTexGenfvOES: procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetTexGenfvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfvOES(coord: DummyEnum; pname: DummyEnum; &params: array of single) := GetTexGenfvOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfvOES(coord: DummyEnum; pname: DummyEnum; var &params: single) := GetTexGenfvOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenfvOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexGenfvOES(coord, pname, &params);
    
    public z_GetTexGenivOES: procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetTexGenivOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenivOES(coord: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetTexGenivOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenivOES(coord: DummyEnum; pname: DummyEnum; var &params: Int32) := GetTexGenivOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenivOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexGenivOES(coord, pname, &params);
    
    {$endregion OES_texture_cube_map}
    
    {$region IMG_user_clip_plane, OES_single_precision}
    
    public z_ClipPlanefOES: procedure(plane: DummyEnum; equation: pointer) := FuncPtrOrNil&<procedure(plane: DummyEnum; equation: pointer)>(GetGLProcAdr('glClipPlanefOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: DummyEnum; equation: array of single) := ClipPlanefOES(plane, equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: DummyEnum; var equation: single) := ClipPlanefOES(plane, @equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanefOES(plane: DummyEnum; equation: pointer) := z_ClipPlanefOES(plane, equation);
    
    {$endregion IMG_user_clip_plane, OES_single_precision}
    
    {$region IMG_user_clip_plane, OES_fixed_point}
    
    public z_ClipPlanexOES: procedure(plane: DummyEnum; equation: pointer) := FuncPtrOrNil&<procedure(plane: DummyEnum; equation: pointer)>(GetGLProcAdr('glClipPlanexOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: DummyEnum; equation: array of fixed) := ClipPlanexOES(plane, equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: DummyEnum; var equation: fixed) := ClipPlanexOES(plane, @equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ClipPlanexOES(plane: DummyEnum; equation: pointer) := z_ClipPlanexOES(plane, equation);
    
    {$endregion IMG_user_clip_plane, OES_fixed_point}
    
    {$region NV_viewport_array, OES_viewport_array}
    
    public z_DepthRangeArrayfvOES: procedure(first: UInt32; count: Int32; v: pointer) := FuncPtrOrNil&<procedure(first: UInt32; count: Int32; v: pointer)>(GetGLProcAdr('glDepthRangeArrayfvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayfvOES(first: UInt32; count: Int32; v: array of single) := DepthRangeArrayfvOES(first, count, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayfvOES(first: UInt32; count: Int32; var v: single) := DepthRangeArrayfvOES(first, count, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeArrayfvOES(first: UInt32; count: Int32; v: pointer) := z_DepthRangeArrayfvOES(first, count, v);
    
    public z_DepthRangeIndexedfOES: procedure(index: UInt32; n: single; f: single) := FuncPtrOrNil&<procedure(index: UInt32; n: single; f: single)>(GetGLProcAdr('glDepthRangeIndexedfOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DepthRangeIndexedfOES(index: UInt32; n: single; f: single) := z_DepthRangeIndexedfOES(index, n, f);
    
    {$endregion NV_viewport_array, OES_viewport_array}
    
    {$region OES_draw_texture, OES_fixed_point}
    
    public z_TexParameterxvOES: procedure(target: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glTexParameterxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: array of fixed) := TexParameterxvOES(target, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: DummyEnum; pname: DummyEnum; var &params: fixed) := TexParameterxvOES(target, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexParameterxvOES(target: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexParameterxvOES(target, pname, &params);
    
    {$endregion OES_draw_texture, OES_fixed_point}
    
    {$region OES_EGL_image, OES_EGL_image_external}
    
    public z_EGLImageTargetTexture2DOES: procedure(target: DummyEnum; image: GLeglImageOES) := FuncPtrOrNil&<procedure(target: DummyEnum; image: GLeglImageOES)>(GetGLProcAdr('glEGLImageTargetTexture2DOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EGLImageTargetTexture2DOES(target: DummyEnum; image: GLeglImageOES) := z_EGLImageTargetTexture2DOES(target, image);
    
    {$endregion OES_EGL_image, OES_EGL_image_external}
    
    {$region OES_fixed_point, OES_texture_cube_map}
    
    public z_TexGenxOES: procedure(coord: DummyEnum; pname: DummyEnum; param: fixed) := FuncPtrOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; param: fixed)>(GetGLProcAdr('glTexGenxOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxOES(coord: DummyEnum; pname: DummyEnum; param: fixed) := z_TexGenxOES(coord, pname, param);
    
    public z_TexGenxvOES: procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glTexGenxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: DummyEnum; pname: DummyEnum; &params: array of fixed) := TexGenxvOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: DummyEnum; pname: DummyEnum; var &params: fixed) := TexGenxvOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexGenxvOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_TexGenxvOES(coord, pname, &params);
    
    public z_GetTexGenxvOES: procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(coord: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetTexGenxvOES'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenxvOES(coord: DummyEnum; pname: DummyEnum; &params: array of fixed) := GetTexGenxvOES(coord, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenxvOES(coord: DummyEnum; pname: DummyEnum; var &params: fixed) := GetTexGenxvOES(coord, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexGenxvOES(coord: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetTexGenxvOES(coord, pname, &params);
    
    {$endregion OES_fixed_point, OES_texture_cube_map}
    
  end;
  
  gl_OVR = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region OVR_multiview}
    
    public z_FramebufferTextureMultiviewOVR: procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32)>(GetGLProcAdr('glFramebufferTextureMultiviewOVR'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureMultiviewOVR(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32) := z_FramebufferTextureMultiviewOVR(target, attachment, texture, level, baseViewIndex, numViews);
    
    public z_NamedFramebufferTextureMultiviewOVR: procedure(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32) := FuncPtrOrNil&<procedure(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32)>(GetGLProcAdr('glNamedFramebufferTextureMultiviewOVR'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure NamedFramebufferTextureMultiviewOVR(framebuffer: UInt32; attachment: DummyEnum; texture: UInt32; level: Int32; baseViewIndex: Int32; numViews: Int32) := z_NamedFramebufferTextureMultiviewOVR(framebuffer, attachment, texture, level, baseViewIndex, numViews);
    
    {$endregion OVR_multiview}
    
    {$region OVR_multiview_multisampled_render_to_texture}
    
    public z_FramebufferTextureMultisampleMultiviewOVR: procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; samples: Int32; baseViewIndex: Int32; numViews: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; samples: Int32; baseViewIndex: Int32; numViews: Int32)>(GetGLProcAdr('glFramebufferTextureMultisampleMultiviewOVR'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferTextureMultisampleMultiviewOVR(target: DummyEnum; attachment: DummyEnum; texture: UInt32; level: Int32; samples: Int32; baseViewIndex: Int32; numViews: Int32) := z_FramebufferTextureMultisampleMultiviewOVR(target, attachment, texture, level, samples, baseViewIndex, numViews);
    
    {$endregion OVR_multiview_multisampled_render_to_texture}
    
  end;
  
  gl_QCOM = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region QCOM_driver_control}
    
    public z_GetDriverControlsQCOM: procedure(num: pointer; size: Int32; driverControls: pointer) := FuncPtrOrNil&<procedure(num: pointer; size: Int32; driverControls: pointer)>(GetGLProcAdr('glGetDriverControlsQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: array of Int32; size: Int32; driverControls: array of UInt32) := GetDriverControlsQCOM(num[0], size, driverControls[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: array of Int32; size: Int32; var driverControls: UInt32) := GetDriverControlsQCOM(num[0], size, @driverControls);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: array of Int32; size: Int32; driverControls: pointer) := GetDriverControlsQCOM(num[0], size, driverControls);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(var num: Int32; size: Int32; driverControls: array of UInt32) := GetDriverControlsQCOM(@num, size, driverControls[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(var num: Int32; size: Int32; var driverControls: UInt32) := GetDriverControlsQCOM(@num, size, @driverControls);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(var num: Int32; size: Int32; driverControls: pointer) := GetDriverControlsQCOM(@num, size, driverControls);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: pointer; size: Int32; driverControls: array of UInt32) := GetDriverControlsQCOM(num, size, driverControls[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: pointer; size: Int32; var driverControls: UInt32) := GetDriverControlsQCOM(num, size, @driverControls);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlsQCOM(num: pointer; size: Int32; driverControls: pointer) := z_GetDriverControlsQCOM(num, size, driverControls);
    
    public z_GetDriverControlStringQCOM: procedure(driverControl: UInt32; bufSize: Int32; length: pointer; driverControlString: IntPtr) := FuncPtrOrNil&<procedure(driverControl: UInt32; bufSize: Int32; length: pointer; driverControlString: IntPtr)>(GetGLProcAdr('glGetDriverControlStringQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; length: array of Int32; driverControlString: string); begin var ptr4 := Marshal.StringToHGlobalAnsi(driverControlString); GetDriverControlStringQCOM(driverControl, bufSize, length[0], ptr4); driverControlString := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; length: array of Int32; driverControlString: IntPtr) := GetDriverControlStringQCOM(driverControl, bufSize, length[0], driverControlString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; var length: Int32; driverControlString: string); begin var ptr4 := Marshal.StringToHGlobalAnsi(driverControlString); GetDriverControlStringQCOM(driverControl, bufSize, @length, ptr4); driverControlString := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; var length: Int32; driverControlString: IntPtr) := GetDriverControlStringQCOM(driverControl, bufSize, @length, driverControlString);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; length: pointer; driverControlString: string); begin var ptr4 := Marshal.StringToHGlobalAnsi(driverControlString); GetDriverControlStringQCOM(driverControl, bufSize, length, ptr4); driverControlString := Marshal.PtrToStringAnsi(ptr4); Marshal.FreeHGlobal(ptr4); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDriverControlStringQCOM(driverControl: UInt32; bufSize: Int32; length: pointer; driverControlString: IntPtr) := z_GetDriverControlStringQCOM(driverControl, bufSize, length, driverControlString);
    
    public z_EnableDriverControlQCOM: procedure(driverControl: UInt32) := FuncPtrOrNil&<procedure(driverControl: UInt32)>(GetGLProcAdr('glEnableDriverControlQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EnableDriverControlQCOM(driverControl: UInt32) := z_EnableDriverControlQCOM(driverControl);
    
    public z_DisableDriverControlQCOM: procedure(driverControl: UInt32) := FuncPtrOrNil&<procedure(driverControl: UInt32)>(GetGLProcAdr('glDisableDriverControlQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DisableDriverControlQCOM(driverControl: UInt32) := z_DisableDriverControlQCOM(driverControl);
    
    {$endregion QCOM_driver_control}
    
    {$region QCOM_extended_get}
    
    public z_ExtGetTexturesQCOM: procedure(textures: pointer; maxTextures: Int32; numTextures: pointer) := FuncPtrOrNil&<procedure(textures: pointer; maxTextures: Int32; numTextures: pointer)>(GetGLProcAdr('glExtGetTexturesQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: array of UInt32; maxTextures: Int32; numTextures: array of Int32) := ExtGetTexturesQCOM(textures[0], maxTextures, numTextures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: array of UInt32; maxTextures: Int32; var numTextures: Int32) := ExtGetTexturesQCOM(textures[0], maxTextures, @numTextures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: array of UInt32; maxTextures: Int32; numTextures: pointer) := ExtGetTexturesQCOM(textures[0], maxTextures, numTextures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(var textures: UInt32; maxTextures: Int32; numTextures: array of Int32) := ExtGetTexturesQCOM(@textures, maxTextures, numTextures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(var textures: UInt32; maxTextures: Int32; var numTextures: Int32) := ExtGetTexturesQCOM(@textures, maxTextures, @numTextures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(var textures: UInt32; maxTextures: Int32; numTextures: pointer) := ExtGetTexturesQCOM(@textures, maxTextures, numTextures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: pointer; maxTextures: Int32; numTextures: array of Int32) := ExtGetTexturesQCOM(textures, maxTextures, numTextures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: pointer; maxTextures: Int32; var numTextures: Int32) := ExtGetTexturesQCOM(textures, maxTextures, @numTextures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexturesQCOM(textures: pointer; maxTextures: Int32; numTextures: pointer) := z_ExtGetTexturesQCOM(textures, maxTextures, numTextures);
    
    public z_ExtGetBuffersQCOM: procedure(buffers: pointer; maxBuffers: Int32; numBuffers: pointer) := FuncPtrOrNil&<procedure(buffers: pointer; maxBuffers: Int32; numBuffers: pointer)>(GetGLProcAdr('glExtGetBuffersQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: array of UInt32; maxBuffers: Int32; numBuffers: array of Int32) := ExtGetBuffersQCOM(buffers[0], maxBuffers, numBuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: array of UInt32; maxBuffers: Int32; var numBuffers: Int32) := ExtGetBuffersQCOM(buffers[0], maxBuffers, @numBuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: array of UInt32; maxBuffers: Int32; numBuffers: pointer) := ExtGetBuffersQCOM(buffers[0], maxBuffers, numBuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(var buffers: UInt32; maxBuffers: Int32; numBuffers: array of Int32) := ExtGetBuffersQCOM(@buffers, maxBuffers, numBuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(var buffers: UInt32; maxBuffers: Int32; var numBuffers: Int32) := ExtGetBuffersQCOM(@buffers, maxBuffers, @numBuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(var buffers: UInt32; maxBuffers: Int32; numBuffers: pointer) := ExtGetBuffersQCOM(@buffers, maxBuffers, numBuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: pointer; maxBuffers: Int32; numBuffers: array of Int32) := ExtGetBuffersQCOM(buffers, maxBuffers, numBuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: pointer; maxBuffers: Int32; var numBuffers: Int32) := ExtGetBuffersQCOM(buffers, maxBuffers, @numBuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBuffersQCOM(buffers: pointer; maxBuffers: Int32; numBuffers: pointer) := z_ExtGetBuffersQCOM(buffers, maxBuffers, numBuffers);
    
    public z_ExtGetRenderbuffersQCOM: procedure(renderbuffers: pointer; maxRenderbuffers: Int32; numRenderbuffers: pointer) := FuncPtrOrNil&<procedure(renderbuffers: pointer; maxRenderbuffers: Int32; numRenderbuffers: pointer)>(GetGLProcAdr('glExtGetRenderbuffersQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: array of UInt32; maxRenderbuffers: Int32; numRenderbuffers: array of Int32) := ExtGetRenderbuffersQCOM(renderbuffers[0], maxRenderbuffers, numRenderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: array of UInt32; maxRenderbuffers: Int32; var numRenderbuffers: Int32) := ExtGetRenderbuffersQCOM(renderbuffers[0], maxRenderbuffers, @numRenderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: array of UInt32; maxRenderbuffers: Int32; numRenderbuffers: pointer) := ExtGetRenderbuffersQCOM(renderbuffers[0], maxRenderbuffers, numRenderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(var renderbuffers: UInt32; maxRenderbuffers: Int32; numRenderbuffers: array of Int32) := ExtGetRenderbuffersQCOM(@renderbuffers, maxRenderbuffers, numRenderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(var renderbuffers: UInt32; maxRenderbuffers: Int32; var numRenderbuffers: Int32) := ExtGetRenderbuffersQCOM(@renderbuffers, maxRenderbuffers, @numRenderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(var renderbuffers: UInt32; maxRenderbuffers: Int32; numRenderbuffers: pointer) := ExtGetRenderbuffersQCOM(@renderbuffers, maxRenderbuffers, numRenderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: pointer; maxRenderbuffers: Int32; numRenderbuffers: array of Int32) := ExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: pointer; maxRenderbuffers: Int32; var numRenderbuffers: Int32) := ExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, @numRenderbuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetRenderbuffersQCOM(renderbuffers: pointer; maxRenderbuffers: Int32; numRenderbuffers: pointer) := z_ExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers);
    
    public z_ExtGetFramebuffersQCOM: procedure(framebuffers: pointer; maxFramebuffers: Int32; numFramebuffers: pointer) := FuncPtrOrNil&<procedure(framebuffers: pointer; maxFramebuffers: Int32; numFramebuffers: pointer)>(GetGLProcAdr('glExtGetFramebuffersQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: array of UInt32; maxFramebuffers: Int32; numFramebuffers: array of Int32) := ExtGetFramebuffersQCOM(framebuffers[0], maxFramebuffers, numFramebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: array of UInt32; maxFramebuffers: Int32; var numFramebuffers: Int32) := ExtGetFramebuffersQCOM(framebuffers[0], maxFramebuffers, @numFramebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: array of UInt32; maxFramebuffers: Int32; numFramebuffers: pointer) := ExtGetFramebuffersQCOM(framebuffers[0], maxFramebuffers, numFramebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(var framebuffers: UInt32; maxFramebuffers: Int32; numFramebuffers: array of Int32) := ExtGetFramebuffersQCOM(@framebuffers, maxFramebuffers, numFramebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(var framebuffers: UInt32; maxFramebuffers: Int32; var numFramebuffers: Int32) := ExtGetFramebuffersQCOM(@framebuffers, maxFramebuffers, @numFramebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(var framebuffers: UInt32; maxFramebuffers: Int32; numFramebuffers: pointer) := ExtGetFramebuffersQCOM(@framebuffers, maxFramebuffers, numFramebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: pointer; maxFramebuffers: Int32; numFramebuffers: array of Int32) := ExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: pointer; maxFramebuffers: Int32; var numFramebuffers: Int32) := ExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, @numFramebuffers);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetFramebuffersQCOM(framebuffers: pointer; maxFramebuffers: Int32; numFramebuffers: pointer) := z_ExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers);
    
    public z_ExtGetTexLevelParameterivQCOM: procedure(texture: UInt32; face: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(texture: UInt32; face: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glExtGetTexLevelParameterivQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexLevelParameterivQCOM(texture: UInt32; face: DummyEnum; level: Int32; pname: DummyEnum; &params: array of Int32) := ExtGetTexLevelParameterivQCOM(texture, face, level, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexLevelParameterivQCOM(texture: UInt32; face: DummyEnum; level: Int32; pname: DummyEnum; var &params: Int32) := ExtGetTexLevelParameterivQCOM(texture, face, level, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexLevelParameterivQCOM(texture: UInt32; face: DummyEnum; level: Int32; pname: DummyEnum; &params: pointer) := z_ExtGetTexLevelParameterivQCOM(texture, face, level, pname, &params);
    
    public z_ExtTexObjectStateOverrideiQCOM: procedure(target: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glExtTexObjectStateOverrideiQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtTexObjectStateOverrideiQCOM(target: DummyEnum; pname: DummyEnum; param: Int32) := z_ExtTexObjectStateOverrideiQCOM(target, pname, param);
    
    public z_ExtGetTexSubImageQCOM: procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; texels: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; texels: pointer)>(GetGLProcAdr('glExtGetTexSubImageQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetTexSubImageQCOM(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; width: Int32; height: Int32; depth: Int32; format: DummyEnum; &type: DummyEnum; texels: pointer) := z_ExtGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, format, &type, texels);
    
    public z_ExtGetBufferPointervQCOM: procedure(target: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; &params: pointer)>(GetGLProcAdr('glExtGetBufferPointervQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBufferPointervQCOM(target: DummyEnum; &params: array of IntPtr) := ExtGetBufferPointervQCOM(target, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBufferPointervQCOM(target: DummyEnum; var &params: IntPtr) := ExtGetBufferPointervQCOM(target, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetBufferPointervQCOM(target: DummyEnum; &params: pointer) := z_ExtGetBufferPointervQCOM(target, &params);
    
    {$endregion QCOM_extended_get}
    
    {$region QCOM_extended_get2}
    
    public z_ExtGetShadersQCOM: procedure(shaders: pointer; maxShaders: Int32; numShaders: pointer) := FuncPtrOrNil&<procedure(shaders: pointer; maxShaders: Int32; numShaders: pointer)>(GetGLProcAdr('glExtGetShadersQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: array of UInt32; maxShaders: Int32; numShaders: array of Int32) := ExtGetShadersQCOM(shaders[0], maxShaders, numShaders[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: array of UInt32; maxShaders: Int32; var numShaders: Int32) := ExtGetShadersQCOM(shaders[0], maxShaders, @numShaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: array of UInt32; maxShaders: Int32; numShaders: pointer) := ExtGetShadersQCOM(shaders[0], maxShaders, numShaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(var shaders: UInt32; maxShaders: Int32; numShaders: array of Int32) := ExtGetShadersQCOM(@shaders, maxShaders, numShaders[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(var shaders: UInt32; maxShaders: Int32; var numShaders: Int32) := ExtGetShadersQCOM(@shaders, maxShaders, @numShaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(var shaders: UInt32; maxShaders: Int32; numShaders: pointer) := ExtGetShadersQCOM(@shaders, maxShaders, numShaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: pointer; maxShaders: Int32; numShaders: array of Int32) := ExtGetShadersQCOM(shaders, maxShaders, numShaders[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: pointer; maxShaders: Int32; var numShaders: Int32) := ExtGetShadersQCOM(shaders, maxShaders, @numShaders);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetShadersQCOM(shaders: pointer; maxShaders: Int32; numShaders: pointer) := z_ExtGetShadersQCOM(shaders, maxShaders, numShaders);
    
    public z_ExtGetProgramsQCOM: procedure(programs: pointer; maxPrograms: Int32; numPrograms: pointer) := FuncPtrOrNil&<procedure(programs: pointer; maxPrograms: Int32; numPrograms: pointer)>(GetGLProcAdr('glExtGetProgramsQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: array of UInt32; maxPrograms: Int32; numPrograms: array of Int32) := ExtGetProgramsQCOM(programs[0], maxPrograms, numPrograms[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: array of UInt32; maxPrograms: Int32; var numPrograms: Int32) := ExtGetProgramsQCOM(programs[0], maxPrograms, @numPrograms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: array of UInt32; maxPrograms: Int32; numPrograms: pointer) := ExtGetProgramsQCOM(programs[0], maxPrograms, numPrograms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(var programs: UInt32; maxPrograms: Int32; numPrograms: array of Int32) := ExtGetProgramsQCOM(@programs, maxPrograms, numPrograms[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(var programs: UInt32; maxPrograms: Int32; var numPrograms: Int32) := ExtGetProgramsQCOM(@programs, maxPrograms, @numPrograms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(var programs: UInt32; maxPrograms: Int32; numPrograms: pointer) := ExtGetProgramsQCOM(@programs, maxPrograms, numPrograms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: pointer; maxPrograms: Int32; numPrograms: array of Int32) := ExtGetProgramsQCOM(programs, maxPrograms, numPrograms[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: pointer; maxPrograms: Int32; var numPrograms: Int32) := ExtGetProgramsQCOM(programs, maxPrograms, @numPrograms);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramsQCOM(programs: pointer; maxPrograms: Int32; numPrograms: pointer) := z_ExtGetProgramsQCOM(programs, maxPrograms, numPrograms);
    
    public z_ExtIsProgramBinaryQCOM: function(&program: UInt32): Byte := FuncPtrOrNil&<function(&program: UInt32): Byte>(GetGLProcAdr('glExtIsProgramBinaryQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function ExtIsProgramBinaryQCOM(&program: UInt32): Byte := z_ExtIsProgramBinaryQCOM(&program);
    
    public z_ExtGetProgramBinarySourceQCOM: procedure(&program: UInt32; shadertype: DummyEnum; source: IntPtr; length: pointer) := FuncPtrOrNil&<procedure(&program: UInt32; shadertype: DummyEnum; source: IntPtr; length: pointer)>(GetGLProcAdr('glExtGetProgramBinarySourceQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: string; length: array of Int32); begin var ptr3 := Marshal.StringToHGlobalAnsi(source); ExtGetProgramBinarySourceQCOM(&program, shadertype, ptr3, length[0]); source := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: string; var length: Int32); begin var ptr3 := Marshal.StringToHGlobalAnsi(source); ExtGetProgramBinarySourceQCOM(&program, shadertype, ptr3, @length); source := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: string; length: pointer); begin var ptr3 := Marshal.StringToHGlobalAnsi(source); ExtGetProgramBinarySourceQCOM(&program, shadertype, ptr3, length); source := Marshal.PtrToStringAnsi(ptr3); Marshal.FreeHGlobal(ptr3); end;
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: IntPtr; length: array of Int32) := ExtGetProgramBinarySourceQCOM(&program, shadertype, source, length[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: IntPtr; var length: Int32) := ExtGetProgramBinarySourceQCOM(&program, shadertype, source, @length);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ExtGetProgramBinarySourceQCOM(&program: UInt32; shadertype: DummyEnum; source: IntPtr; length: pointer) := z_ExtGetProgramBinarySourceQCOM(&program, shadertype, source, length);
    
    {$endregion QCOM_extended_get2}
    
    {$region QCOM_framebuffer_foveated}
    
    public z_FramebufferFoveationConfigQCOM: procedure(framebuffer: UInt32; numLayers: UInt32; focalPointsPerLayer: UInt32; requestedFeatures: UInt32; providedFeatures: pointer) := FuncPtrOrNil&<procedure(framebuffer: UInt32; numLayers: UInt32; focalPointsPerLayer: UInt32; requestedFeatures: UInt32; providedFeatures: pointer)>(GetGLProcAdr('glFramebufferFoveationConfigQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFoveationConfigQCOM(framebuffer: UInt32; numLayers: UInt32; focalPointsPerLayer: UInt32; requestedFeatures: UInt32; providedFeatures: array of UInt32) := FramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, providedFeatures[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFoveationConfigQCOM(framebuffer: UInt32; numLayers: UInt32; focalPointsPerLayer: UInt32; requestedFeatures: UInt32; var providedFeatures: UInt32) := FramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, @providedFeatures);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFoveationConfigQCOM(framebuffer: UInt32; numLayers: UInt32; focalPointsPerLayer: UInt32; requestedFeatures: UInt32; providedFeatures: pointer) := z_FramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, providedFeatures);
    
    public z_FramebufferFoveationParametersQCOM: procedure(framebuffer: UInt32; layer: UInt32; focalPoint: UInt32; focalX: single; focalY: single; gainX: single; gainY: single; foveaArea: single) := FuncPtrOrNil&<procedure(framebuffer: UInt32; layer: UInt32; focalPoint: UInt32; focalX: single; focalY: single; gainX: single; gainY: single; foveaArea: single)>(GetGLProcAdr('glFramebufferFoveationParametersQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FramebufferFoveationParametersQCOM(framebuffer: UInt32; layer: UInt32; focalPoint: UInt32; focalX: single; focalY: single; gainX: single; gainY: single; foveaArea: single) := z_FramebufferFoveationParametersQCOM(framebuffer, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
    
    {$endregion QCOM_framebuffer_foveated}
    
    {$region QCOM_texture_foveated}
    
    public z_TextureFoveationParametersQCOM: procedure(texture: UInt32; layer: UInt32; focalPoint: UInt32; focalX: single; focalY: single; gainX: single; gainY: single; foveaArea: single) := FuncPtrOrNil&<procedure(texture: UInt32; layer: UInt32; focalPoint: UInt32; focalX: single; focalY: single; gainX: single; gainY: single; foveaArea: single)>(GetGLProcAdr('glTextureFoveationParametersQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureFoveationParametersQCOM(texture: UInt32; layer: UInt32; focalPoint: UInt32; focalX: single; focalY: single; gainX: single; gainY: single; foveaArea: single) := z_TextureFoveationParametersQCOM(texture, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
    
    {$endregion QCOM_texture_foveated}
    
    {$region QCOM_tiled_rendering}
    
    public z_StartTilingQCOM: procedure(x: UInt32; y: UInt32; width: UInt32; height: UInt32; preserveMask: DummyFlags) := FuncPtrOrNil&<procedure(x: UInt32; y: UInt32; width: UInt32; height: UInt32; preserveMask: DummyFlags)>(GetGLProcAdr('glStartTilingQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StartTilingQCOM(x: UInt32; y: UInt32; width: UInt32; height: UInt32; preserveMask: DummyFlags) := z_StartTilingQCOM(x, y, width, height, preserveMask);
    
    public z_EndTilingQCOM: procedure(preserveMask: DummyFlags) := FuncPtrOrNil&<procedure(preserveMask: DummyFlags)>(GetGLProcAdr('glEndTilingQCOM'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure EndTilingQCOM(preserveMask: DummyFlags) := z_EndTilingQCOM(preserveMask);
    
    {$endregion QCOM_tiled_rendering}
    
  end;
  
  gl_SGI = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region SGI_fft}
    
    public z_PixelTransformSGI: procedure(target: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum)>(GetGLProcAdr('glPixelTransformSGI'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTransformSGI(target: DummyEnum) := z_PixelTransformSGI(target);
    
    {$endregion SGI_fft}
    
  end;
  
  gl_SGIS = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region Unsorted}
    
    public z_FogFuncSGIS: procedure(n: Int32; points: pointer) := FuncPtrOrNil&<procedure(n: Int32; points: pointer)>(GetGLProcAdr('glFogFuncSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; points: array of single) := FogFuncSGIS(n, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; var points: single) := FogFuncSGIS(n, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FogFuncSGIS(n: Int32; points: pointer) := z_FogFuncSGIS(n, points);
    
    public z_GetFogFuncSGIS: procedure(points: pointer) := FuncPtrOrNil&<procedure(points: pointer)>(GetGLProcAdr('glGetFogFuncSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFogFuncSGIS(points: array of single) := GetFogFuncSGIS(points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFogFuncSGIS(var points: single) := GetFogFuncSGIS(@points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFogFuncSGIS(points: pointer) := z_GetFogFuncSGIS(points);
    
    public z_PixelTexGenParameterfvSGIS: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glPixelTexGenParameterfvSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: DummyEnum; &params: array of single) := PixelTexGenParameterfvSGIS(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: DummyEnum; var &params: single) := PixelTexGenParameterfvSGIS(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfvSGIS(pname: DummyEnum; &params: pointer) := z_PixelTexGenParameterfvSGIS(pname, &params);
    
    public z_PixelTexGenParameterivSGIS: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glPixelTexGenParameterivSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: DummyEnum; &params: array of Int32) := PixelTexGenParameterivSGIS(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: DummyEnum; var &params: Int32) := PixelTexGenParameterivSGIS(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterivSGIS(pname: DummyEnum; &params: pointer) := z_PixelTexGenParameterivSGIS(pname, &params);
    
    public z_TexImage4DSGIS: procedure(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; size4d: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; size4d: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glTexImage4DSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexImage4DSGIS(target: DummyEnum; level: Int32; internalformat: DummyEnum; width: Int32; height: Int32; depth: Int32; size4d: Int32; border: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, &type, pixels);
    
    public z_TexSubImage4DSGIS: procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; woffset: Int32; width: Int32; height: Int32; depth: Int32; size4d: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; woffset: Int32; width: Int32; height: Int32; depth: Int32; size4d: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer)>(GetGLProcAdr('glTexSubImage4DSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexSubImage4DSGIS(target: DummyEnum; level: Int32; xoffset: Int32; yoffset: Int32; zoffset: Int32; woffset: Int32; width: Int32; height: Int32; depth: Int32; size4d: Int32; format: DummyEnum; &type: DummyEnum; pixels: pointer) := z_TexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, &type, pixels);
    
    {$endregion Unsorted}
    
    {$region SGIS_detail_texture}
    
    public z_DetailTexFuncSGIS: procedure(target: DummyEnum; n: Int32; points: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; n: Int32; points: pointer)>(GetGLProcAdr('glDetailTexFuncSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: DummyEnum; n: Int32; points: array of single) := DetailTexFuncSGIS(target, n, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: DummyEnum; n: Int32; var points: single) := DetailTexFuncSGIS(target, n, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DetailTexFuncSGIS(target: DummyEnum; n: Int32; points: pointer) := z_DetailTexFuncSGIS(target, n, points);
    
    public z_GetDetailTexFuncSGIS: procedure(target: DummyEnum; points: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; points: pointer)>(GetGLProcAdr('glGetDetailTexFuncSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDetailTexFuncSGIS(target: DummyEnum; points: array of single) := GetDetailTexFuncSGIS(target, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDetailTexFuncSGIS(target: DummyEnum; var points: single) := GetDetailTexFuncSGIS(target, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetDetailTexFuncSGIS(target: DummyEnum; points: pointer) := z_GetDetailTexFuncSGIS(target, points);
    
    {$endregion SGIS_detail_texture}
    
    {$region SGIS_multitexture}
    
    public z_MultiTexCoord1s: procedure(target: DummyEnum; s: Int16) := FuncPtrOrNil&<procedure(target: DummyEnum; s: Int16)>(GetGLProcAdr('glMultiTexCoord1s'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1s(target: DummyEnum; s: Int16) := z_MultiTexCoord1s(target, s);
    
    public z_MultiTexCoord1i: procedure(target: DummyEnum; s: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; s: Int32)>(GetGLProcAdr('glMultiTexCoord1i'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1i(target: DummyEnum; s: Int32) := z_MultiTexCoord1i(target, s);
    
    public z_MultiTexCoord1f: procedure(target: DummyEnum; s: single) := FuncPtrOrNil&<procedure(target: DummyEnum; s: single)>(GetGLProcAdr('glMultiTexCoord1f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1f(target: DummyEnum; s: single) := z_MultiTexCoord1f(target, s);
    
    public z_MultiTexCoord1d: procedure(target: DummyEnum; s: double) := FuncPtrOrNil&<procedure(target: DummyEnum; s: double)>(GetGLProcAdr('glMultiTexCoord1d'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1d(target: DummyEnum; s: double) := z_MultiTexCoord1d(target, s);
    
    public z_MultiTexCoord2s: procedure(target: DummyEnum; s: Int16; t: Int16) := FuncPtrOrNil&<procedure(target: DummyEnum; s: Int16; t: Int16)>(GetGLProcAdr('glMultiTexCoord2s'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2s(target: DummyEnum; s: Int16; t: Int16) := z_MultiTexCoord2s(target, s, t);
    
    public z_MultiTexCoord2i: procedure(target: DummyEnum; s: Int32; t: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; s: Int32; t: Int32)>(GetGLProcAdr('glMultiTexCoord2i'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2i(target: DummyEnum; s: Int32; t: Int32) := z_MultiTexCoord2i(target, s, t);
    
    public z_MultiTexCoord2f: procedure(target: DummyEnum; s: single; t: single) := FuncPtrOrNil&<procedure(target: DummyEnum; s: single; t: single)>(GetGLProcAdr('glMultiTexCoord2f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2f(target: DummyEnum; s: single; t: single) := z_MultiTexCoord2f(target, s, t);
    
    public z_MultiTexCoord2d: procedure(target: DummyEnum; s: double; t: double) := FuncPtrOrNil&<procedure(target: DummyEnum; s: double; t: double)>(GetGLProcAdr('glMultiTexCoord2d'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2d(target: DummyEnum; s: double; t: double) := z_MultiTexCoord2d(target, s, t);
    
    public z_MultiTexCoord3s: procedure(target: DummyEnum; s: Int16; t: Int16; r: Int16) := FuncPtrOrNil&<procedure(target: DummyEnum; s: Int16; t: Int16; r: Int16)>(GetGLProcAdr('glMultiTexCoord3s'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3s(target: DummyEnum; s: Int16; t: Int16; r: Int16) := z_MultiTexCoord3s(target, s, t, r);
    
    public z_MultiTexCoord3i: procedure(target: DummyEnum; s: Int32; t: Int32; r: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; s: Int32; t: Int32; r: Int32)>(GetGLProcAdr('glMultiTexCoord3i'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3i(target: DummyEnum; s: Int32; t: Int32; r: Int32) := z_MultiTexCoord3i(target, s, t, r);
    
    public z_MultiTexCoord3f: procedure(target: DummyEnum; s: single; t: single; r: single) := FuncPtrOrNil&<procedure(target: DummyEnum; s: single; t: single; r: single)>(GetGLProcAdr('glMultiTexCoord3f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3f(target: DummyEnum; s: single; t: single; r: single) := z_MultiTexCoord3f(target, s, t, r);
    
    public z_MultiTexCoord3d: procedure(target: DummyEnum; s: double; t: double; r: double) := FuncPtrOrNil&<procedure(target: DummyEnum; s: double; t: double; r: double)>(GetGLProcAdr('glMultiTexCoord3d'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3d(target: DummyEnum; s: double; t: double; r: double) := z_MultiTexCoord3d(target, s, t, r);
    
    public z_MultiTexCoord4s: procedure(target: DummyEnum; s: Int16; t: Int16; r: Int16; q: Int16) := FuncPtrOrNil&<procedure(target: DummyEnum; s: Int16; t: Int16; r: Int16; q: Int16)>(GetGLProcAdr('glMultiTexCoord4s'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4s(target: DummyEnum; s: Int16; t: Int16; r: Int16; q: Int16) := z_MultiTexCoord4s(target, s, t, r, q);
    
    public z_MultiTexCoord4i: procedure(target: DummyEnum; s: Int32; t: Int32; r: Int32; q: Int32) := FuncPtrOrNil&<procedure(target: DummyEnum; s: Int32; t: Int32; r: Int32; q: Int32)>(GetGLProcAdr('glMultiTexCoord4i'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4i(target: DummyEnum; s: Int32; t: Int32; r: Int32; q: Int32) := z_MultiTexCoord4i(target, s, t, r, q);
    
    public z_MultiTexCoord4f: procedure(target: DummyEnum; s: single; t: single; r: single; q: single) := FuncPtrOrNil&<procedure(target: DummyEnum; s: single; t: single; r: single; q: single)>(GetGLProcAdr('glMultiTexCoord4f'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4f(target: DummyEnum; s: single; t: single; r: single; q: single) := z_MultiTexCoord4f(target, s, t, r, q);
    
    public z_MultiTexCoord4d: procedure(target: DummyEnum; s: double; t: double; r: double; q: double) := FuncPtrOrNil&<procedure(target: DummyEnum; s: double; t: double; r: double; q: double)>(GetGLProcAdr('glMultiTexCoord4d'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4d(target: DummyEnum; s: double; t: double; r: double; q: double) := z_MultiTexCoord4d(target, s, t, r, q);
    
    public z_MultiTexCoord1sv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord1sv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: DummyEnum; v: array of Int16) := MultiTexCoord1sv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: DummyEnum; var v: Int16) := MultiTexCoord1sv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1sv(target: DummyEnum; v: pointer) := z_MultiTexCoord1sv(target, v);
    
    public z_MultiTexCoord1iv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord1iv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: DummyEnum; v: array of Int32) := MultiTexCoord1iv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: DummyEnum; var v: Int32) := MultiTexCoord1iv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1iv(target: DummyEnum; v: pointer) := z_MultiTexCoord1iv(target, v);
    
    public z_MultiTexCoord1fv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord1fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: DummyEnum; v: array of single) := MultiTexCoord1fv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: DummyEnum; var v: single) := MultiTexCoord1fv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1fv(target: DummyEnum; v: pointer) := z_MultiTexCoord1fv(target, v);
    
    public z_MultiTexCoord1dv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord1dv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: DummyEnum; v: array of double) := MultiTexCoord1dv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: DummyEnum; var v: double) := MultiTexCoord1dv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord1dv(target: DummyEnum; v: pointer) := z_MultiTexCoord1dv(target, v);
    
    public z_MultiTexCoord2sv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord2sv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: DummyEnum; v: array of Int16) := MultiTexCoord2sv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: DummyEnum; var v: Int16) := MultiTexCoord2sv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2sv(target: DummyEnum; v: pointer) := z_MultiTexCoord2sv(target, v);
    
    public z_MultiTexCoord2iv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord2iv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: DummyEnum; v: array of Int32) := MultiTexCoord2iv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: DummyEnum; var v: Int32) := MultiTexCoord2iv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2iv(target: DummyEnum; v: pointer) := z_MultiTexCoord2iv(target, v);
    
    public z_MultiTexCoord2fv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord2fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: DummyEnum; v: array of single) := MultiTexCoord2fv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: DummyEnum; var v: single) := MultiTexCoord2fv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2fv(target: DummyEnum; v: pointer) := z_MultiTexCoord2fv(target, v);
    
    public z_MultiTexCoord2dv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord2dv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: DummyEnum; v: array of double) := MultiTexCoord2dv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: DummyEnum; var v: double) := MultiTexCoord2dv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord2dv(target: DummyEnum; v: pointer) := z_MultiTexCoord2dv(target, v);
    
    public z_MultiTexCoord3sv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord3sv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: DummyEnum; v: array of Int16) := MultiTexCoord3sv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: DummyEnum; var v: Int16) := MultiTexCoord3sv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3sv(target: DummyEnum; v: pointer) := z_MultiTexCoord3sv(target, v);
    
    public z_MultiTexCoord3iv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord3iv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: DummyEnum; v: array of Int32) := MultiTexCoord3iv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: DummyEnum; var v: Int32) := MultiTexCoord3iv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3iv(target: DummyEnum; v: pointer) := z_MultiTexCoord3iv(target, v);
    
    public z_MultiTexCoord3fv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord3fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: DummyEnum; v: array of single) := MultiTexCoord3fv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: DummyEnum; var v: single) := MultiTexCoord3fv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3fv(target: DummyEnum; v: pointer) := z_MultiTexCoord3fv(target, v);
    
    public z_MultiTexCoord3dv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord3dv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: DummyEnum; v: array of double) := MultiTexCoord3dv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: DummyEnum; var v: double) := MultiTexCoord3dv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord3dv(target: DummyEnum; v: pointer) := z_MultiTexCoord3dv(target, v);
    
    public z_MultiTexCoord4sv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord4sv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: DummyEnum; v: array of Int16) := MultiTexCoord4sv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: DummyEnum; var v: Int16) := MultiTexCoord4sv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4sv(target: DummyEnum; v: pointer) := z_MultiTexCoord4sv(target, v);
    
    public z_MultiTexCoord4iv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord4iv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: DummyEnum; v: array of Int32) := MultiTexCoord4iv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: DummyEnum; var v: Int32) := MultiTexCoord4iv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4iv(target: DummyEnum; v: pointer) := z_MultiTexCoord4iv(target, v);
    
    public z_MultiTexCoord4fv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord4fv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: DummyEnum; v: array of single) := MultiTexCoord4fv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: DummyEnum; var v: single) := MultiTexCoord4fv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4fv(target: DummyEnum; v: pointer) := z_MultiTexCoord4fv(target, v);
    
    public z_MultiTexCoord4dv: procedure(target: DummyEnum; v: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; v: pointer)>(GetGLProcAdr('glMultiTexCoord4dv'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: DummyEnum; v: array of double) := MultiTexCoord4dv(target, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: DummyEnum; var v: double) := MultiTexCoord4dv(target, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultiTexCoord4dv(target: DummyEnum; v: pointer) := z_MultiTexCoord4dv(target, v);
    
    public z_InterleavedTextureCoordSetsSGIS: procedure(factor: Int32) := FuncPtrOrNil&<procedure(factor: Int32)>(GetGLProcAdr('glInterleavedTextureCoordSetsSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InterleavedTextureCoordSetsSGIS(factor: Int32) := z_InterleavedTextureCoordSetsSGIS(factor);
    
    public z_SelectTextureSGIS: procedure(target: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum)>(GetGLProcAdr('glSelectTextureSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectTextureSGIS(target: DummyEnum) := z_SelectTextureSGIS(target);
    
    public z_SelectTextureCoordSetSGIS: procedure(target: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum)>(GetGLProcAdr('glSelectTextureCoordSetSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectTextureCoordSetSGIS(target: DummyEnum) := z_SelectTextureCoordSetSGIS(target);
    
    public z_SelectTextureTransformSGIS: procedure(target: DummyEnum) := FuncPtrOrNil&<procedure(target: DummyEnum)>(GetGLProcAdr('glSelectTextureTransformSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SelectTextureTransformSGIS(target: DummyEnum) := z_SelectTextureTransformSGIS(target);
    
    {$endregion SGIS_multitexture}
    
    {$region SGIS_pixel_texture}
    
    public z_PixelTexGenParameteriSGIS: procedure(pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: Int32)>(GetGLProcAdr('glPixelTexGenParameteriSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameteriSGIS(pname: DummyEnum; param: Int32) := z_PixelTexGenParameteriSGIS(pname, param);
    
    public z_PixelTexGenParameterfSGIS: procedure(pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: single)>(GetGLProcAdr('glPixelTexGenParameterfSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenParameterfSGIS(pname: DummyEnum; param: single) := z_PixelTexGenParameterfSGIS(pname, param);
    
    public z_GetPixelTexGenParameterivSGIS: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetPixelTexGenParameterivSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterivSGIS(pname: DummyEnum; &params: array of Int32) := GetPixelTexGenParameterivSGIS(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterivSGIS(pname: DummyEnum; var &params: Int32) := GetPixelTexGenParameterivSGIS(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterivSGIS(pname: DummyEnum; &params: pointer) := z_GetPixelTexGenParameterivSGIS(pname, &params);
    
    public z_GetPixelTexGenParameterfvSGIS: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetPixelTexGenParameterfvSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterfvSGIS(pname: DummyEnum; &params: array of single) := GetPixelTexGenParameterfvSGIS(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterfvSGIS(pname: DummyEnum; var &params: single) := GetPixelTexGenParameterfvSGIS(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetPixelTexGenParameterfvSGIS(pname: DummyEnum; &params: pointer) := z_GetPixelTexGenParameterfvSGIS(pname, &params);
    
    {$endregion SGIS_pixel_texture}
    
    {$region SGIS_shared_multisample}
    
    public z_MultisampleSubRectPosSGIS: procedure(x: Int32; y: Int32) := FuncPtrOrNil&<procedure(x: Int32; y: Int32)>(GetGLProcAdr('glMultisampleSubRectPosSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure MultisampleSubRectPosSGIS(x: Int32; y: Int32) := z_MultisampleSubRectPosSGIS(x, y);
    
    {$endregion SGIS_shared_multisample}
    
    {$region SGIS_sharpen_texture}
    
    public z_SharpenTexFuncSGIS: procedure(target: DummyEnum; n: Int32; points: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; n: Int32; points: pointer)>(GetGLProcAdr('glSharpenTexFuncSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: DummyEnum; n: Int32; points: array of single) := SharpenTexFuncSGIS(target, n, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: DummyEnum; n: Int32; var points: single) := SharpenTexFuncSGIS(target, n, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SharpenTexFuncSGIS(target: DummyEnum; n: Int32; points: pointer) := z_SharpenTexFuncSGIS(target, n, points);
    
    public z_GetSharpenTexFuncSGIS: procedure(target: DummyEnum; points: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; points: pointer)>(GetGLProcAdr('glGetSharpenTexFuncSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSharpenTexFuncSGIS(target: DummyEnum; points: array of single) := GetSharpenTexFuncSGIS(target, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSharpenTexFuncSGIS(target: DummyEnum; var points: single) := GetSharpenTexFuncSGIS(target, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetSharpenTexFuncSGIS(target: DummyEnum; points: pointer) := z_GetSharpenTexFuncSGIS(target, points);
    
    {$endregion SGIS_sharpen_texture}
    
    {$region SGIS_texture_color_mask}
    
    public z_TextureColorMaskSGIS: procedure(red: Byte; green: Byte; blue: Byte; alpha: Byte) := FuncPtrOrNil&<procedure(red: Byte; green: Byte; blue: Byte; alpha: Byte)>(GetGLProcAdr('glTextureColorMaskSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TextureColorMaskSGIS(red: Byte; green: Byte; blue: Byte; alpha: Byte) := z_TextureColorMaskSGIS(red, green, blue, alpha);
    
    {$endregion SGIS_texture_color_mask}
    
    {$region SGIS_texture_filter4}
    
    public z_TexFilterFuncSGIS: procedure(target: DummyEnum; filter: DummyEnum; n: Int32; weights: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; filter: DummyEnum; n: Int32; weights: pointer)>(GetGLProcAdr('glTexFilterFuncSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; n: Int32; weights: array of single) := TexFilterFuncSGIS(target, filter, n, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; n: Int32; var weights: single) := TexFilterFuncSGIS(target, filter, n, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; n: Int32; weights: pointer) := z_TexFilterFuncSGIS(target, filter, n, weights);
    
    public z_GetTexFilterFuncSGIS: procedure(target: DummyEnum; filter: DummyEnum; weights: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; filter: DummyEnum; weights: pointer)>(GetGLProcAdr('glGetTexFilterFuncSGIS'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; weights: array of single) := GetTexFilterFuncSGIS(target, filter, weights[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; var weights: single) := GetTexFilterFuncSGIS(target, filter, @weights);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetTexFilterFuncSGIS(target: DummyEnum; filter: DummyEnum; weights: pointer) := z_GetTexFilterFuncSGIS(target, filter, weights);
    
    {$endregion SGIS_texture_filter4}
    
  end;
  
  gl_SGIX = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region Unsorted}
    
    public z_AsyncMarkerSGIX: procedure(marker: UInt32) := FuncPtrOrNil&<procedure(marker: UInt32)>(GetGLProcAdr('glAsyncMarkerSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure AsyncMarkerSGIX(marker: UInt32) := z_AsyncMarkerSGIX(marker);
    
    public z_DeleteAsyncMarkersSGIX: procedure(marker: UInt32; range: Int32) := FuncPtrOrNil&<procedure(marker: UInt32; range: Int32)>(GetGLProcAdr('glDeleteAsyncMarkersSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeleteAsyncMarkersSGIX(marker: UInt32; range: Int32) := z_DeleteAsyncMarkersSGIX(marker, range);
    
    public z_FinishAsyncSGIX: function(markerp: pointer): Int32 := FuncPtrOrNil&<function(markerp: pointer): Int32>(GetGLProcAdr('glFinishAsyncSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FinishAsyncSGIX(markerp: array of UInt32): Int32 := FinishAsyncSGIX(markerp[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FinishAsyncSGIX(var markerp: UInt32): Int32 := FinishAsyncSGIX(@markerp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function FinishAsyncSGIX(markerp: pointer): Int32 := z_FinishAsyncSGIX(markerp);
    
    public z_FlushRasterSGIX: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glFlushRasterSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FlushRasterSGIX := z_FlushRasterSGIX();
    
    public z_GenAsyncMarkersSGIX: function(range: Int32): UInt32 := FuncPtrOrNil&<function(range: Int32): UInt32>(GetGLProcAdr('glGenAsyncMarkersSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GenAsyncMarkersSGIX(range: Int32): UInt32 := z_GenAsyncMarkersSGIX(range);
    
    public z_GetInstrumentsSGIX: function: Int32 := FuncPtrOrNil&<function: Int32>(GetGLProcAdr('glGetInstrumentsSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function GetInstrumentsSGIX: Int32 := z_GetInstrumentsSGIX();
    
    public z_GetListParameterfvSGIX: procedure(list: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(list: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetListParameterfvSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterfvSGIX(list: UInt32; pname: DummyEnum; &params: array of single) := GetListParameterfvSGIX(list, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterfvSGIX(list: UInt32; pname: DummyEnum; var &params: single) := GetListParameterfvSGIX(list, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterfvSGIX(list: UInt32; pname: DummyEnum; &params: pointer) := z_GetListParameterfvSGIX(list, pname, &params);
    
    public z_GetListParameterivSGIX: procedure(list: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(list: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetListParameterivSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterivSGIX(list: UInt32; pname: DummyEnum; &params: array of Int32) := GetListParameterivSGIX(list, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterivSGIX(list: UInt32; pname: DummyEnum; var &params: Int32) := GetListParameterivSGIX(list, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetListParameterivSGIX(list: UInt32; pname: DummyEnum; &params: pointer) := z_GetListParameterivSGIX(list, pname, &params);
    
    public z_InstrumentsBufferSGIX: procedure(size: Int32; buffer: pointer) := FuncPtrOrNil&<procedure(size: Int32; buffer: pointer)>(GetGLProcAdr('glInstrumentsBufferSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InstrumentsBufferSGIX(size: Int32; buffer: array of Int32) := InstrumentsBufferSGIX(size, buffer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InstrumentsBufferSGIX(size: Int32; var buffer: Int32) := InstrumentsBufferSGIX(size, @buffer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure InstrumentsBufferSGIX(size: Int32; buffer: pointer) := z_InstrumentsBufferSGIX(size, buffer);
    
    public z_IsAsyncMarkerSGIX: function(marker: UInt32): Byte := FuncPtrOrNil&<function(marker: UInt32): Byte>(GetGLProcAdr('glIsAsyncMarkerSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function IsAsyncMarkerSGIX(marker: UInt32): Byte := z_IsAsyncMarkerSGIX(marker);
    
    public z_ListParameterfSGIX: procedure(list: UInt32; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(list: UInt32; pname: DummyEnum; param: single)>(GetGLProcAdr('glListParameterfSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfSGIX(list: UInt32; pname: DummyEnum; param: single) := z_ListParameterfSGIX(list, pname, param);
    
    public z_ListParameterfvSGIX: procedure(list: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(list: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glListParameterfvSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfvSGIX(list: UInt32; pname: DummyEnum; &params: array of single) := ListParameterfvSGIX(list, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfvSGIX(list: UInt32; pname: DummyEnum; var &params: single) := ListParameterfvSGIX(list, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterfvSGIX(list: UInt32; pname: DummyEnum; &params: pointer) := z_ListParameterfvSGIX(list, pname, &params);
    
    public z_ListParameteriSGIX: procedure(list: UInt32; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(list: UInt32; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glListParameteriSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameteriSGIX(list: UInt32; pname: DummyEnum; param: Int32) := z_ListParameteriSGIX(list, pname, param);
    
    public z_ListParameterivSGIX: procedure(list: UInt32; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(list: UInt32; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glListParameterivSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterivSGIX(list: UInt32; pname: DummyEnum; &params: array of Int32) := ListParameterivSGIX(list, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterivSGIX(list: UInt32; pname: DummyEnum; var &params: Int32) := ListParameterivSGIX(list, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ListParameterivSGIX(list: UInt32; pname: DummyEnum; &params: pointer) := z_ListParameterivSGIX(list, pname, &params);
    
    public z_PollAsyncSGIX: function(markerp: pointer): Int32 := FuncPtrOrNil&<function(markerp: pointer): Int32>(GetGLProcAdr('glPollAsyncSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollAsyncSGIX(markerp: array of UInt32): Int32 := PollAsyncSGIX(markerp[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollAsyncSGIX(var markerp: UInt32): Int32 := PollAsyncSGIX(@markerp);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollAsyncSGIX(markerp: pointer): Int32 := z_PollAsyncSGIX(markerp);
    
    public z_PollInstrumentsSGIX: function(marker_p: pointer): Int32 := FuncPtrOrNil&<function(marker_p: pointer): Int32>(GetGLProcAdr('glPollInstrumentsSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollInstrumentsSGIX(marker_p: array of Int32): Int32 := PollInstrumentsSGIX(marker_p[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollInstrumentsSGIX(var marker_p: Int32): Int32 := PollInstrumentsSGIX(@marker_p);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] function PollInstrumentsSGIX(marker_p: pointer): Int32 := z_PollInstrumentsSGIX(marker_p);
    
    public z_ReadInstrumentsSGIX: procedure(marker: Int32) := FuncPtrOrNil&<procedure(marker: Int32)>(GetGLProcAdr('glReadInstrumentsSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReadInstrumentsSGIX(marker: Int32) := z_ReadInstrumentsSGIX(marker);
    
    public z_StartInstrumentsSGIX: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glStartInstrumentsSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StartInstrumentsSGIX := z_StartInstrumentsSGIX();
    
    public z_StopInstrumentsSGIX: procedure(marker: Int32) := FuncPtrOrNil&<procedure(marker: Int32)>(GetGLProcAdr('glStopInstrumentsSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure StopInstrumentsSGIX(marker: Int32) := z_StopInstrumentsSGIX(marker);
    
    {$endregion Unsorted}
    
    {$region EXT_fragment_lighting}
    
    public z_FragmentLightModeliSGIX: procedure(pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: Int32)>(GetGLProcAdr('glFragmentLightModeliSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModeliSGIX(pname: DummyEnum; param: Int32) := z_FragmentLightModeliSGIX(pname, param);
    
    public z_FragmentLightModelfSGIX: procedure(pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: single)>(GetGLProcAdr('glFragmentLightModelfSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfSGIX(pname: DummyEnum; param: single) := z_FragmentLightModelfSGIX(pname, param);
    
    public z_FragmentLightModelivSGIX: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glFragmentLightModelivSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelivSGIX(pname: DummyEnum; &params: array of Int32) := FragmentLightModelivSGIX(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelivSGIX(pname: DummyEnum; var &params: Int32) := FragmentLightModelivSGIX(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelivSGIX(pname: DummyEnum; &params: pointer) := z_FragmentLightModelivSGIX(pname, &params);
    
    public z_FragmentLightModelfvSGIX: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glFragmentLightModelfvSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfvSGIX(pname: DummyEnum; &params: array of single) := FragmentLightModelfvSGIX(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfvSGIX(pname: DummyEnum; var &params: single) := FragmentLightModelfvSGIX(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightModelfvSGIX(pname: DummyEnum; &params: pointer) := z_FragmentLightModelfvSGIX(pname, &params);
    
    public z_FragmentLightiSGIX: procedure(light: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glFragmentLightiSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightiSGIX(light: DummyEnum; pname: DummyEnum; param: Int32) := z_FragmentLightiSGIX(light, pname, param);
    
    public z_FragmentLightfSGIX: procedure(light: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glFragmentLightfSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfSGIX(light: DummyEnum; pname: DummyEnum; param: single) := z_FragmentLightfSGIX(light, pname, param);
    
    public z_FragmentLightivSGIX: procedure(light: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glFragmentLightivSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightivSGIX(light: DummyEnum; pname: DummyEnum; &params: array of Int32) := FragmentLightivSGIX(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightivSGIX(light: DummyEnum; pname: DummyEnum; var &params: Int32) := FragmentLightivSGIX(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightivSGIX(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_FragmentLightivSGIX(light, pname, &params);
    
    public z_FragmentLightfvSGIX: procedure(light: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glFragmentLightfvSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfvSGIX(light: DummyEnum; pname: DummyEnum; &params: array of single) := FragmentLightfvSGIX(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfvSGIX(light: DummyEnum; pname: DummyEnum; var &params: single) := FragmentLightfvSGIX(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentLightfvSGIX(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_FragmentLightfvSGIX(light, pname, &params);
    
    public z_GetFragmentLightivSGIX: procedure(light: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetFragmentLightivSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightivSGIX(light: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetFragmentLightivSGIX(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightivSGIX(light: DummyEnum; pname: DummyEnum; var &params: Int32) := GetFragmentLightivSGIX(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightivSGIX(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetFragmentLightivSGIX(light, pname, &params);
    
    public z_GetFragmentLightfvSGIX: procedure(light: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(light: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetFragmentLightfvSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightfvSGIX(light: DummyEnum; pname: DummyEnum; &params: array of single) := GetFragmentLightfvSGIX(light, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightfvSGIX(light: DummyEnum; pname: DummyEnum; var &params: single) := GetFragmentLightfvSGIX(light, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentLightfvSGIX(light: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetFragmentLightfvSGIX(light, pname, &params);
    
    public z_FragmentMaterialfSGIX: procedure(face: DummyEnum; pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; param: single)>(GetGLProcAdr('glFragmentMaterialfSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfSGIX(face: DummyEnum; pname: DummyEnum; param: single) := z_FragmentMaterialfSGIX(face, pname, param);
    
    public z_FragmentMaterialiSGIX: procedure(face: DummyEnum; pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; param: Int32)>(GetGLProcAdr('glFragmentMaterialiSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialiSGIX(face: DummyEnum; pname: DummyEnum; param: Int32) := z_FragmentMaterialiSGIX(face, pname, param);
    
    public z_FragmentMaterialfvSGIX: procedure(face: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glFragmentMaterialfvSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfvSGIX(face: DummyEnum; pname: DummyEnum; &params: array of single) := FragmentMaterialfvSGIX(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfvSGIX(face: DummyEnum; pname: DummyEnum; var &params: single) := FragmentMaterialfvSGIX(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialfvSGIX(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_FragmentMaterialfvSGIX(face, pname, &params);
    
    public z_FragmentMaterialivSGIX: procedure(face: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glFragmentMaterialivSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialivSGIX(face: DummyEnum; pname: DummyEnum; &params: array of Int32) := FragmentMaterialivSGIX(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialivSGIX(face: DummyEnum; pname: DummyEnum; var &params: Int32) := FragmentMaterialivSGIX(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentMaterialivSGIX(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_FragmentMaterialivSGIX(face, pname, &params);
    
    public z_FragmentColorMaterialSGIX: procedure(face: DummyEnum; mode: DummyEnum) := FuncPtrOrNil&<procedure(face: DummyEnum; mode: DummyEnum)>(GetGLProcAdr('glFragmentColorMaterialSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FragmentColorMaterialSGIX(face: DummyEnum; mode: DummyEnum) := z_FragmentColorMaterialSGIX(face, mode);
    
    public z_GetFragmentMaterialfvSGIX: procedure(face: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetFragmentMaterialfvSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialfvSGIX(face: DummyEnum; pname: DummyEnum; &params: array of single) := GetFragmentMaterialfvSGIX(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialfvSGIX(face: DummyEnum; pname: DummyEnum; var &params: single) := GetFragmentMaterialfvSGIX(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialfvSGIX(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetFragmentMaterialfvSGIX(face, pname, &params);
    
    public z_GetFragmentMaterialivSGIX: procedure(face: DummyEnum; pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(face: DummyEnum; pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glGetFragmentMaterialivSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialivSGIX(face: DummyEnum; pname: DummyEnum; &params: array of Int32) := GetFragmentMaterialivSGIX(face, pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialivSGIX(face: DummyEnum; pname: DummyEnum; var &params: Int32) := GetFragmentMaterialivSGIX(face, pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GetFragmentMaterialivSGIX(face: DummyEnum; pname: DummyEnum; &params: pointer) := z_GetFragmentMaterialivSGIX(face, pname, &params);
    
    public z_LightEnviSGIX: procedure(pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: Int32)>(GetGLProcAdr('glLightEnviSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LightEnviSGIX(pname: DummyEnum; param: Int32) := z_LightEnviSGIX(pname, param);
    
    {$endregion EXT_fragment_lighting}
    
    {$region SGIX_framezoom}
    
    public z_FrameZoomSGIX: procedure(factor: Int32) := FuncPtrOrNil&<procedure(factor: Int32)>(GetGLProcAdr('glFrameZoomSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FrameZoomSGIX(factor: Int32) := z_FrameZoomSGIX(factor);
    
    {$endregion SGIX_framezoom}
    
    {$region SGIX_igloo_interface}
    
    public z_IglooInterfaceSGIX: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glIglooInterfaceSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure IglooInterfaceSGIX(pname: DummyEnum; &params: pointer) := z_IglooInterfaceSGIX(pname, &params);
    
    {$endregion SGIX_igloo_interface}
    
    {$region SGIX_pixel_texture}
    
    public z_PixelTexGenSGIX: procedure(mode: DummyEnum) := FuncPtrOrNil&<procedure(mode: DummyEnum)>(GetGLProcAdr('glPixelTexGenSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure PixelTexGenSGIX(mode: DummyEnum) := z_PixelTexGenSGIX(mode);
    
    {$endregion SGIX_pixel_texture}
    
    {$region SGIX_polynomial_ffd}
    
    public z_DeformationMap3fSGIX: procedure(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: pointer)>(GetGLProcAdr('glDeformationMap3fSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: array of single) := DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; var points: single) := DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3fSGIX(target: DummyEnum; u1: single; u2: single; ustride: Int32; uorder: Int32; v1: single; v2: single; vstride: Int32; vorder: Int32; w1: single; w2: single; wstride: Int32; worder: Int32; points: pointer) := z_DeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    
    public z_DeformationMap3dSGIX: procedure(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: pointer) := FuncPtrOrNil&<procedure(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: pointer)>(GetGLProcAdr('glDeformationMap3dSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: array of double) := DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; var points: double) := DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, @points);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformationMap3dSGIX(target: DummyEnum; u1: double; u2: double; ustride: Int32; uorder: Int32; v1: double; v2: double; vstride: Int32; vorder: Int32; w1: double; w2: double; wstride: Int32; worder: Int32; points: pointer) := z_DeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
    
    public z_LoadIdentityDeformationMapSGIX: procedure(mask: DummyFlags) := FuncPtrOrNil&<procedure(mask: DummyFlags)>(GetGLProcAdr('glLoadIdentityDeformationMapSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure LoadIdentityDeformationMapSGIX(mask: DummyFlags) := z_LoadIdentityDeformationMapSGIX(mask);
    
    public z_DeformSGIX: procedure(mask: DummyFlags) := FuncPtrOrNil&<procedure(mask: DummyFlags)>(GetGLProcAdr('glDeformSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DeformSGIX(mask: DummyFlags) := z_DeformSGIX(mask);
    
    {$endregion SGIX_polynomial_ffd}
    
    {$region SGIX_reference_plane}
    
    public z_ReferencePlaneSGIX: procedure(equation: pointer) := FuncPtrOrNil&<procedure(equation: pointer)>(GetGLProcAdr('glReferencePlaneSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(equation: array of double) := ReferencePlaneSGIX(equation[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(var equation: double) := ReferencePlaneSGIX(@equation);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReferencePlaneSGIX(equation: pointer) := z_ReferencePlaneSGIX(equation);
    
    {$endregion SGIX_reference_plane}
    
    {$region SGIX_sprite}
    
    public z_SpriteParameteriSGIX: procedure(pname: DummyEnum; param: Int32) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: Int32)>(GetGLProcAdr('glSpriteParameteriSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameteriSGIX(pname: DummyEnum; param: Int32) := z_SpriteParameteriSGIX(pname, param);
    
    public z_SpriteParameterfSGIX: procedure(pname: DummyEnum; param: single) := FuncPtrOrNil&<procedure(pname: DummyEnum; param: single)>(GetGLProcAdr('glSpriteParameterfSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfSGIX(pname: DummyEnum; param: single) := z_SpriteParameterfSGIX(pname, param);
    
    public z_SpriteParameterivSGIX: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glSpriteParameterivSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: DummyEnum; &params: array of Int32) := SpriteParameterivSGIX(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: DummyEnum; var &params: Int32) := SpriteParameterivSGIX(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterivSGIX(pname: DummyEnum; &params: pointer) := z_SpriteParameterivSGIX(pname, &params);
    
    public z_SpriteParameterfvSGIX: procedure(pname: DummyEnum; &params: pointer) := FuncPtrOrNil&<procedure(pname: DummyEnum; &params: pointer)>(GetGLProcAdr('glSpriteParameterfvSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: DummyEnum; &params: array of single) := SpriteParameterfvSGIX(pname, &params[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: DummyEnum; var &params: single) := SpriteParameterfvSGIX(pname, @&params);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure SpriteParameterfvSGIX(pname: DummyEnum; &params: pointer) := z_SpriteParameterfvSGIX(pname, &params);
    
    {$endregion SGIX_sprite}
    
    {$region SGIX_tag_sample_buffer}
    
    public z_TagSampleBufferSGIX: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glTagSampleBufferSGIX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TagSampleBufferSGIX := z_TagSampleBufferSGIX();
    
    {$endregion SGIX_tag_sample_buffer}
    
  end;
  
  gl_SUN = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region SUN_global_alpha}
    
    public z_GlobalAlphaFactorbSUN: procedure(factor: SByte) := FuncPtrOrNil&<procedure(factor: SByte)>(GetGLProcAdr('glGlobalAlphaFactorbSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorbSUN(factor: SByte) := z_GlobalAlphaFactorbSUN(factor);
    
    public z_GlobalAlphaFactorsSUN: procedure(factor: Int16) := FuncPtrOrNil&<procedure(factor: Int16)>(GetGLProcAdr('glGlobalAlphaFactorsSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorsSUN(factor: Int16) := z_GlobalAlphaFactorsSUN(factor);
    
    public z_GlobalAlphaFactoriSUN: procedure(factor: Int32) := FuncPtrOrNil&<procedure(factor: Int32)>(GetGLProcAdr('glGlobalAlphaFactoriSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactoriSUN(factor: Int32) := z_GlobalAlphaFactoriSUN(factor);
    
    public z_GlobalAlphaFactorfSUN: procedure(factor: single) := FuncPtrOrNil&<procedure(factor: single)>(GetGLProcAdr('glGlobalAlphaFactorfSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorfSUN(factor: single) := z_GlobalAlphaFactorfSUN(factor);
    
    public z_GlobalAlphaFactordSUN: procedure(factor: double) := FuncPtrOrNil&<procedure(factor: double)>(GetGLProcAdr('glGlobalAlphaFactordSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactordSUN(factor: double) := z_GlobalAlphaFactordSUN(factor);
    
    public z_GlobalAlphaFactorubSUN: procedure(factor: Byte) := FuncPtrOrNil&<procedure(factor: Byte)>(GetGLProcAdr('glGlobalAlphaFactorubSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorubSUN(factor: Byte) := z_GlobalAlphaFactorubSUN(factor);
    
    public z_GlobalAlphaFactorusSUN: procedure(factor: UInt16) := FuncPtrOrNil&<procedure(factor: UInt16)>(GetGLProcAdr('glGlobalAlphaFactorusSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactorusSUN(factor: UInt16) := z_GlobalAlphaFactorusSUN(factor);
    
    public z_GlobalAlphaFactoruiSUN: procedure(factor: UInt32) := FuncPtrOrNil&<procedure(factor: UInt32)>(GetGLProcAdr('glGlobalAlphaFactoruiSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure GlobalAlphaFactoruiSUN(factor: UInt32) := z_GlobalAlphaFactoruiSUN(factor);
    
    {$endregion SUN_global_alpha}
    
    {$region SUN_mesh_array}
    
    public z_DrawMeshArraysSUN: procedure(mode: DummyEnum; first: Int32; count: Int32; width: Int32) := FuncPtrOrNil&<procedure(mode: DummyEnum; first: Int32; count: Int32; width: Int32)>(GetGLProcAdr('glDrawMeshArraysSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure DrawMeshArraysSUN(mode: DummyEnum; first: Int32; count: Int32; width: Int32) := z_DrawMeshArraysSUN(mode, first, count, width);
    
    {$endregion SUN_mesh_array}
    
    {$region SUN_triangle_list}
    
    public z_ReplacementCodeuiSUN: procedure(code: UInt32) := FuncPtrOrNil&<procedure(code: UInt32)>(GetGLProcAdr('glReplacementCodeuiSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiSUN(code: UInt32) := z_ReplacementCodeuiSUN(code);
    
    public z_ReplacementCodeusSUN: procedure(code: UInt16) := FuncPtrOrNil&<procedure(code: UInt16)>(GetGLProcAdr('glReplacementCodeusSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusSUN(code: UInt16) := z_ReplacementCodeusSUN(code);
    
    public z_ReplacementCodeubSUN: procedure(code: Byte) := FuncPtrOrNil&<procedure(code: Byte)>(GetGLProcAdr('glReplacementCodeubSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubSUN(code: Byte) := z_ReplacementCodeubSUN(code);
    
    public z_ReplacementCodeuivSUN: procedure(code: pointer) := FuncPtrOrNil&<procedure(code: pointer)>(GetGLProcAdr('glReplacementCodeuivSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(code: array of UInt32) := ReplacementCodeuivSUN(code[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(var code: UInt32) := ReplacementCodeuivSUN(@code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuivSUN(code: pointer) := z_ReplacementCodeuivSUN(code);
    
    public z_ReplacementCodeusvSUN: procedure(code: pointer) := FuncPtrOrNil&<procedure(code: pointer)>(GetGLProcAdr('glReplacementCodeusvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(code: array of UInt16) := ReplacementCodeusvSUN(code[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(var code: UInt16) := ReplacementCodeusvSUN(@code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeusvSUN(code: pointer) := z_ReplacementCodeusvSUN(code);
    
    public z_ReplacementCodeubvSUN: procedure(code: pointer) := FuncPtrOrNil&<procedure(code: pointer)>(GetGLProcAdr('glReplacementCodeubvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(code: array of Byte) := ReplacementCodeubvSUN(code[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(var code: Byte) := ReplacementCodeubvSUN(@code);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeubvSUN(code: pointer) := z_ReplacementCodeubvSUN(code);
    
    public z_ReplacementCodePointerSUN: procedure(&type: DummyEnum; stride: Int32; _pointer: pointer) := FuncPtrOrNil&<procedure(&type: DummyEnum; stride: Int32; _pointer: pointer)>(GetGLProcAdr('glReplacementCodePointerSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: DummyEnum; stride: Int32; _pointer: array of IntPtr) := ReplacementCodePointerSUN(&type, stride, _pointer[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: DummyEnum; stride: Int32; var _pointer: IntPtr) := ReplacementCodePointerSUN(&type, stride, @_pointer);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodePointerSUN(&type: DummyEnum; stride: Int32; _pointer: pointer) := z_ReplacementCodePointerSUN(&type, stride, _pointer);
    
    {$endregion SUN_triangle_list}
    
    {$region SUN_vertex}
    
    public z_Color4ubVertex2fSUN: procedure(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single) := FuncPtrOrNil&<procedure(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single)>(GetGLProcAdr('glColor4ubVertex2fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fSUN(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single) := z_Color4ubVertex2fSUN(r, g, b, a, x, y);
    
    public z_Color4ubVertex2fvSUN: procedure(c: pointer; v: pointer) := FuncPtrOrNil&<procedure(c: pointer; v: pointer)>(GetGLProcAdr('glColor4ubVertex2fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: array of Byte; v: array of single) := Color4ubVertex2fvSUN(c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: array of Byte; var v: single) := Color4ubVertex2fvSUN(c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: array of Byte; v: pointer) := Color4ubVertex2fvSUN(c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(var c: Byte; v: array of single) := Color4ubVertex2fvSUN(@c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(var c: Byte; var v: single) := Color4ubVertex2fvSUN(@c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(var c: Byte; v: pointer) := Color4ubVertex2fvSUN(@c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: pointer; v: array of single) := Color4ubVertex2fvSUN(c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: pointer; var v: single) := Color4ubVertex2fvSUN(c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex2fvSUN(c: pointer; v: pointer) := z_Color4ubVertex2fvSUN(c, v);
    
    public z_Color4ubVertex3fSUN: procedure(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>(GetGLProcAdr('glColor4ubVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fSUN(r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) := z_Color4ubVertex3fSUN(r, g, b, a, x, y, z);
    
    public z_Color4ubVertex3fvSUN: procedure(c: pointer; v: pointer) := FuncPtrOrNil&<procedure(c: pointer; v: pointer)>(GetGLProcAdr('glColor4ubVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: array of Byte; v: array of single) := Color4ubVertex3fvSUN(c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: array of Byte; var v: single) := Color4ubVertex3fvSUN(c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: array of Byte; v: pointer) := Color4ubVertex3fvSUN(c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(var c: Byte; v: array of single) := Color4ubVertex3fvSUN(@c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(var c: Byte; var v: single) := Color4ubVertex3fvSUN(@c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(var c: Byte; v: pointer) := Color4ubVertex3fvSUN(@c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: pointer; v: array of single) := Color4ubVertex3fvSUN(c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: pointer; var v: single) := Color4ubVertex3fvSUN(c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4ubVertex3fvSUN(c: pointer; v: pointer) := z_Color4ubVertex3fvSUN(c, v);
    
    public z_Color3fVertex3fSUN: procedure(r: single; g: single; b: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(r: single; g: single; b: single; x: single; y: single; z: single)>(GetGLProcAdr('glColor3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fSUN(r: single; g: single; b: single; x: single; y: single; z: single) := z_Color3fVertex3fSUN(r, g, b, x, y, z);
    
    public z_Color3fVertex3fvSUN: procedure(c: pointer; v: pointer) := FuncPtrOrNil&<procedure(c: pointer; v: pointer)>(GetGLProcAdr('glColor3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: array of single; v: array of single) := Color3fVertex3fvSUN(c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: array of single; var v: single) := Color3fVertex3fvSUN(c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: array of single; v: pointer) := Color3fVertex3fvSUN(c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(var c: single; v: array of single) := Color3fVertex3fvSUN(@c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(var c: single; var v: single) := Color3fVertex3fvSUN(@c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(var c: single; v: pointer) := Color3fVertex3fvSUN(@c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: pointer; v: array of single) := Color3fVertex3fvSUN(c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: pointer; var v: single) := Color3fVertex3fvSUN(c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color3fVertex3fvSUN(c: pointer; v: pointer) := z_Color3fVertex3fvSUN(c, v);
    
    public z_Normal3fVertex3fSUN: procedure(nx: single; ny: single; nz: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(nx: single; ny: single; nz: single; x: single; y: single; z: single)>(GetGLProcAdr('glNormal3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fSUN(nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_Normal3fVertex3fSUN(nx, ny, nz, x, y, z);
    
    public z_Normal3fVertex3fvSUN: procedure(n: pointer; v: pointer) := FuncPtrOrNil&<procedure(n: pointer; v: pointer)>(GetGLProcAdr('glNormal3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: array of single; v: array of single) := Normal3fVertex3fvSUN(n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: array of single; var v: single) := Normal3fVertex3fvSUN(n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: array of single; v: pointer) := Normal3fVertex3fvSUN(n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(var n: single; v: array of single) := Normal3fVertex3fvSUN(@n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(var n: single; var v: single) := Normal3fVertex3fvSUN(@n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(var n: single; v: pointer) := Normal3fVertex3fvSUN(@n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: pointer; v: array of single) := Normal3fVertex3fvSUN(n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: pointer; var v: single) := Normal3fVertex3fvSUN(n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Normal3fVertex3fvSUN(n: pointer; v: pointer) := z_Normal3fVertex3fvSUN(n, v);
    
    public z_Color4fNormal3fVertex3fSUN: procedure(r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(GetGLProcAdr('glColor4fNormal3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fSUN(r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_Color4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
    
    public z_Color4fNormal3fVertex3fvSUN: procedure(c: pointer; n: pointer; v: pointer) := FuncPtrOrNil&<procedure(c: pointer; n: pointer; v: pointer)>(GetGLProcAdr('glColor4fNormal3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; n: array of single; v: array of single) := Color4fNormal3fVertex3fvSUN(c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; n: array of single; var v: single) := Color4fNormal3fVertex3fvSUN(c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; n: array of single; v: pointer) := Color4fNormal3fVertex3fvSUN(c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; var n: single; v: array of single) := Color4fNormal3fVertex3fvSUN(c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; var n: single; var v: single) := Color4fNormal3fVertex3fvSUN(c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; var n: single; v: pointer) := Color4fNormal3fVertex3fvSUN(c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; n: pointer; v: array of single) := Color4fNormal3fVertex3fvSUN(c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; n: pointer; var v: single) := Color4fNormal3fVertex3fvSUN(c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: array of single; n: pointer; v: pointer) := Color4fNormal3fVertex3fvSUN(c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; n: array of single; v: array of single) := Color4fNormal3fVertex3fvSUN(@c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; n: array of single; var v: single) := Color4fNormal3fVertex3fvSUN(@c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; n: array of single; v: pointer) := Color4fNormal3fVertex3fvSUN(@c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; var n: single; v: array of single) := Color4fNormal3fVertex3fvSUN(@c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; var n: single; var v: single) := Color4fNormal3fVertex3fvSUN(@c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; var n: single; v: pointer) := Color4fNormal3fVertex3fvSUN(@c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; n: pointer; v: array of single) := Color4fNormal3fVertex3fvSUN(@c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; n: pointer; var v: single) := Color4fNormal3fVertex3fvSUN(@c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(var c: single; n: pointer; v: pointer) := Color4fNormal3fVertex3fvSUN(@c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: pointer; n: array of single; v: array of single) := Color4fNormal3fVertex3fvSUN(c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: pointer; n: array of single; var v: single) := Color4fNormal3fVertex3fvSUN(c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: pointer; n: array of single; v: pointer) := Color4fNormal3fVertex3fvSUN(c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: pointer; var n: single; v: array of single) := Color4fNormal3fVertex3fvSUN(c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: pointer; var n: single; var v: single) := Color4fNormal3fVertex3fvSUN(c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: pointer; var n: single; v: pointer) := Color4fNormal3fVertex3fvSUN(c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: pointer; n: pointer; v: array of single) := Color4fNormal3fVertex3fvSUN(c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: pointer; n: pointer; var v: single) := Color4fNormal3fVertex3fvSUN(c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure Color4fNormal3fVertex3fvSUN(c: pointer; n: pointer; v: pointer) := z_Color4fNormal3fVertex3fvSUN(c, n, v);
    
    public z_TexCoord2fVertex3fSUN: procedure(s: single; t: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(s: single; t: single; x: single; y: single; z: single)>(GetGLProcAdr('glTexCoord2fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fSUN(s: single; t: single; x: single; y: single; z: single) := z_TexCoord2fVertex3fSUN(s, t, x, y, z);
    
    public z_TexCoord2fVertex3fvSUN: procedure(tc: pointer; v: pointer) := FuncPtrOrNil&<procedure(tc: pointer; v: pointer)>(GetGLProcAdr('glTexCoord2fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: array of single; v: array of single) := TexCoord2fVertex3fvSUN(tc[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: array of single; var v: single) := TexCoord2fVertex3fvSUN(tc[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: array of single; v: pointer) := TexCoord2fVertex3fvSUN(tc[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(var tc: single; v: array of single) := TexCoord2fVertex3fvSUN(@tc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(var tc: single; var v: single) := TexCoord2fVertex3fvSUN(@tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(var tc: single; v: pointer) := TexCoord2fVertex3fvSUN(@tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: pointer; v: array of single) := TexCoord2fVertex3fvSUN(tc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: pointer; var v: single) := TexCoord2fVertex3fvSUN(tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fVertex3fvSUN(tc: pointer; v: pointer) := z_TexCoord2fVertex3fvSUN(tc, v);
    
    public z_TexCoord4fVertex4fSUN: procedure(s: single; t: single; p: single; q: single; x: single; y: single; z: single; w: single) := FuncPtrOrNil&<procedure(s: single; t: single; p: single; q: single; x: single; y: single; z: single; w: single)>(GetGLProcAdr('glTexCoord4fVertex4fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fSUN(s: single; t: single; p: single; q: single; x: single; y: single; z: single; w: single) := z_TexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
    
    public z_TexCoord4fVertex4fvSUN: procedure(tc: pointer; v: pointer) := FuncPtrOrNil&<procedure(tc: pointer; v: pointer)>(GetGLProcAdr('glTexCoord4fVertex4fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: array of single; v: array of single) := TexCoord4fVertex4fvSUN(tc[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: array of single; var v: single) := TexCoord4fVertex4fvSUN(tc[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: array of single; v: pointer) := TexCoord4fVertex4fvSUN(tc[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(var tc: single; v: array of single) := TexCoord4fVertex4fvSUN(@tc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(var tc: single; var v: single) := TexCoord4fVertex4fvSUN(@tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(var tc: single; v: pointer) := TexCoord4fVertex4fvSUN(@tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: pointer; v: array of single) := TexCoord4fVertex4fvSUN(tc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: pointer; var v: single) := TexCoord4fVertex4fvSUN(tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fVertex4fvSUN(tc: pointer; v: pointer) := z_TexCoord4fVertex4fvSUN(tc, v);
    
    public z_TexCoord2fColor4ubVertex3fSUN: procedure(s: single; t: single; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(s: single; t: single; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>(GetGLProcAdr('glTexCoord2fColor4ubVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fSUN(s: single; t: single; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) := z_TexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
    
    public z_TexCoord2fColor4ubVertex3fvSUN: procedure(tc: pointer; c: pointer; v: pointer) := FuncPtrOrNil&<procedure(tc: pointer; c: pointer; v: pointer)>(GetGLProcAdr('glTexCoord2fColor4ubVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; c: array of Byte; v: array of single) := TexCoord2fColor4ubVertex3fvSUN(tc[0], c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; c: array of Byte; var v: single) := TexCoord2fColor4ubVertex3fvSUN(tc[0], c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; c: array of Byte; v: pointer) := TexCoord2fColor4ubVertex3fvSUN(tc[0], c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; var c: Byte; v: array of single) := TexCoord2fColor4ubVertex3fvSUN(tc[0], @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; var c: Byte; var v: single) := TexCoord2fColor4ubVertex3fvSUN(tc[0], @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; var c: Byte; v: pointer) := TexCoord2fColor4ubVertex3fvSUN(tc[0], @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; c: pointer; v: array of single) := TexCoord2fColor4ubVertex3fvSUN(tc[0], c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; c: pointer; var v: single) := TexCoord2fColor4ubVertex3fvSUN(tc[0], c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: array of single; c: pointer; v: pointer) := TexCoord2fColor4ubVertex3fvSUN(tc[0], c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; c: array of Byte; v: array of single) := TexCoord2fColor4ubVertex3fvSUN(@tc, c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; c: array of Byte; var v: single) := TexCoord2fColor4ubVertex3fvSUN(@tc, c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; c: array of Byte; v: pointer) := TexCoord2fColor4ubVertex3fvSUN(@tc, c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; var c: Byte; v: array of single) := TexCoord2fColor4ubVertex3fvSUN(@tc, @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; var c: Byte; var v: single) := TexCoord2fColor4ubVertex3fvSUN(@tc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; var c: Byte; v: pointer) := TexCoord2fColor4ubVertex3fvSUN(@tc, @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; c: pointer; v: array of single) := TexCoord2fColor4ubVertex3fvSUN(@tc, c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; c: pointer; var v: single) := TexCoord2fColor4ubVertex3fvSUN(@tc, c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(var tc: single; c: pointer; v: pointer) := TexCoord2fColor4ubVertex3fvSUN(@tc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: pointer; c: array of Byte; v: array of single) := TexCoord2fColor4ubVertex3fvSUN(tc, c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: pointer; c: array of Byte; var v: single) := TexCoord2fColor4ubVertex3fvSUN(tc, c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: pointer; c: array of Byte; v: pointer) := TexCoord2fColor4ubVertex3fvSUN(tc, c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: pointer; var c: Byte; v: array of single) := TexCoord2fColor4ubVertex3fvSUN(tc, @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: pointer; var c: Byte; var v: single) := TexCoord2fColor4ubVertex3fvSUN(tc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: pointer; var c: Byte; v: pointer) := TexCoord2fColor4ubVertex3fvSUN(tc, @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: pointer; c: pointer; v: array of single) := TexCoord2fColor4ubVertex3fvSUN(tc, c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: pointer; c: pointer; var v: single) := TexCoord2fColor4ubVertex3fvSUN(tc, c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4ubVertex3fvSUN(tc: pointer; c: pointer; v: pointer) := z_TexCoord2fColor4ubVertex3fvSUN(tc, c, v);
    
    public z_TexCoord2fColor3fVertex3fSUN: procedure(s: single; t: single; r: single; g: single; b: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(s: single; t: single; r: single; g: single; b: single; x: single; y: single; z: single)>(GetGLProcAdr('glTexCoord2fColor3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fSUN(s: single; t: single; r: single; g: single; b: single; x: single; y: single; z: single) := z_TexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
    
    public z_TexCoord2fColor3fVertex3fvSUN: procedure(tc: pointer; c: pointer; v: pointer) := FuncPtrOrNil&<procedure(tc: pointer; c: pointer; v: pointer)>(GetGLProcAdr('glTexCoord2fColor3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; c: array of single; v: array of single) := TexCoord2fColor3fVertex3fvSUN(tc[0], c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; c: array of single; var v: single) := TexCoord2fColor3fVertex3fvSUN(tc[0], c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; c: array of single; v: pointer) := TexCoord2fColor3fVertex3fvSUN(tc[0], c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; var c: single; v: array of single) := TexCoord2fColor3fVertex3fvSUN(tc[0], @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; var c: single; var v: single) := TexCoord2fColor3fVertex3fvSUN(tc[0], @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; var c: single; v: pointer) := TexCoord2fColor3fVertex3fvSUN(tc[0], @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; c: pointer; v: array of single) := TexCoord2fColor3fVertex3fvSUN(tc[0], c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; c: pointer; var v: single) := TexCoord2fColor3fVertex3fvSUN(tc[0], c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: array of single; c: pointer; v: pointer) := TexCoord2fColor3fVertex3fvSUN(tc[0], c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; c: array of single; v: array of single) := TexCoord2fColor3fVertex3fvSUN(@tc, c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; c: array of single; var v: single) := TexCoord2fColor3fVertex3fvSUN(@tc, c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; c: array of single; v: pointer) := TexCoord2fColor3fVertex3fvSUN(@tc, c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; var c: single; v: array of single) := TexCoord2fColor3fVertex3fvSUN(@tc, @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; var c: single; var v: single) := TexCoord2fColor3fVertex3fvSUN(@tc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; var c: single; v: pointer) := TexCoord2fColor3fVertex3fvSUN(@tc, @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; c: pointer; v: array of single) := TexCoord2fColor3fVertex3fvSUN(@tc, c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; c: pointer; var v: single) := TexCoord2fColor3fVertex3fvSUN(@tc, c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(var tc: single; c: pointer; v: pointer) := TexCoord2fColor3fVertex3fvSUN(@tc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: pointer; c: array of single; v: array of single) := TexCoord2fColor3fVertex3fvSUN(tc, c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: pointer; c: array of single; var v: single) := TexCoord2fColor3fVertex3fvSUN(tc, c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: pointer; c: array of single; v: pointer) := TexCoord2fColor3fVertex3fvSUN(tc, c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: pointer; var c: single; v: array of single) := TexCoord2fColor3fVertex3fvSUN(tc, @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: pointer; var c: single; var v: single) := TexCoord2fColor3fVertex3fvSUN(tc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: pointer; var c: single; v: pointer) := TexCoord2fColor3fVertex3fvSUN(tc, @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: pointer; c: pointer; v: array of single) := TexCoord2fColor3fVertex3fvSUN(tc, c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: pointer; c: pointer; var v: single) := TexCoord2fColor3fVertex3fvSUN(tc, c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor3fVertex3fvSUN(tc: pointer; c: pointer; v: pointer) := z_TexCoord2fColor3fVertex3fvSUN(tc, c, v);
    
    public z_TexCoord2fNormal3fVertex3fSUN: procedure(s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(GetGLProcAdr('glTexCoord2fNormal3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fSUN(s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_TexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
    
    public z_TexCoord2fNormal3fVertex3fvSUN: procedure(tc: pointer; n: pointer; v: pointer) := FuncPtrOrNil&<procedure(tc: pointer; n: pointer; v: pointer)>(GetGLProcAdr('glTexCoord2fNormal3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; n: array of single; v: array of single) := TexCoord2fNormal3fVertex3fvSUN(tc[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; n: array of single; var v: single) := TexCoord2fNormal3fVertex3fvSUN(tc[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; n: array of single; v: pointer) := TexCoord2fNormal3fVertex3fvSUN(tc[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; var n: single; v: array of single) := TexCoord2fNormal3fVertex3fvSUN(tc[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; var n: single; var v: single) := TexCoord2fNormal3fVertex3fvSUN(tc[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; var n: single; v: pointer) := TexCoord2fNormal3fVertex3fvSUN(tc[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; n: pointer; v: array of single) := TexCoord2fNormal3fVertex3fvSUN(tc[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; n: pointer; var v: single) := TexCoord2fNormal3fVertex3fvSUN(tc[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: array of single; n: pointer; v: pointer) := TexCoord2fNormal3fVertex3fvSUN(tc[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; n: array of single; v: array of single) := TexCoord2fNormal3fVertex3fvSUN(@tc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; n: array of single; var v: single) := TexCoord2fNormal3fVertex3fvSUN(@tc, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; n: array of single; v: pointer) := TexCoord2fNormal3fVertex3fvSUN(@tc, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; var n: single; v: array of single) := TexCoord2fNormal3fVertex3fvSUN(@tc, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; var n: single; var v: single) := TexCoord2fNormal3fVertex3fvSUN(@tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; var n: single; v: pointer) := TexCoord2fNormal3fVertex3fvSUN(@tc, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; n: pointer; v: array of single) := TexCoord2fNormal3fVertex3fvSUN(@tc, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; n: pointer; var v: single) := TexCoord2fNormal3fVertex3fvSUN(@tc, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(var tc: single; n: pointer; v: pointer) := TexCoord2fNormal3fVertex3fvSUN(@tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: pointer; n: array of single; v: array of single) := TexCoord2fNormal3fVertex3fvSUN(tc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: pointer; n: array of single; var v: single) := TexCoord2fNormal3fVertex3fvSUN(tc, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: pointer; n: array of single; v: pointer) := TexCoord2fNormal3fVertex3fvSUN(tc, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: pointer; var n: single; v: array of single) := TexCoord2fNormal3fVertex3fvSUN(tc, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: pointer; var n: single; var v: single) := TexCoord2fNormal3fVertex3fvSUN(tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: pointer; var n: single; v: pointer) := TexCoord2fNormal3fVertex3fvSUN(tc, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: pointer; n: pointer; v: array of single) := TexCoord2fNormal3fVertex3fvSUN(tc, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: pointer; n: pointer; var v: single) := TexCoord2fNormal3fVertex3fvSUN(tc, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fNormal3fVertex3fvSUN(tc: pointer; n: pointer; v: pointer) := z_TexCoord2fNormal3fVertex3fvSUN(tc, n, v);
    
    public z_TexCoord2fColor4fNormal3fVertex3fSUN: procedure(s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(GetGLProcAdr('glTexCoord2fColor4fNormal3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fSUN(s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_TexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
    
    public z_TexCoord2fColor4fNormal3fVertex3fvSUN: procedure(tc: pointer; c: pointer; n: pointer; v: pointer) := FuncPtrOrNil&<procedure(tc: pointer; c: pointer; n: pointer; v: pointer)>(GetGLProcAdr('glTexCoord2fColor4fNormal3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; n: array of single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; n: array of single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; n: array of single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; var n: single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; var n: single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; var n: single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; n: pointer; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; n: pointer; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: array of single; n: pointer; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; var c: single; n: array of single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; var c: single; n: array of single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; var c: single; n: array of single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; var c: single; var n: single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; var c: single; var n: single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; var c: single; var n: single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; var c: single; n: pointer; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; var c: single; n: pointer; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; var c: single; n: pointer; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: pointer; n: array of single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: pointer; n: array of single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: pointer; n: array of single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: pointer; var n: single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: pointer; var n: single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: pointer; var n: single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: pointer; n: pointer; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: pointer; n: pointer; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: array of single; c: pointer; n: pointer; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc[0], c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: array of single; n: array of single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: array of single; n: array of single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: array of single; n: array of single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: array of single; var n: single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: array of single; var n: single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: array of single; var n: single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: array of single; n: pointer; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: array of single; n: pointer; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: array of single; n: pointer; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; n: array of single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; n: array of single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; n: array of single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; var n: single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; var n: single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; var n: single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; n: pointer; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; n: pointer; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; var c: single; n: pointer; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: pointer; n: array of single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: pointer; n: array of single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: pointer; n: array of single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: pointer; var n: single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: pointer; var n: single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: pointer; var n: single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: pointer; n: pointer; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: pointer; n: pointer; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(var tc: single; c: pointer; n: pointer; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(@tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: array of single; n: array of single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: array of single; n: array of single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: array of single; n: array of single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: array of single; var n: single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: array of single; var n: single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: array of single; var n: single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: array of single; n: pointer; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: array of single; n: pointer; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: array of single; n: pointer; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; var c: single; n: array of single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; var c: single; n: array of single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; var c: single; n: array of single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; var c: single; var n: single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; var c: single; var n: single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; var c: single; var n: single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; var c: single; n: pointer; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; var c: single; n: pointer; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; var c: single; n: pointer; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: pointer; n: array of single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: pointer; n: array of single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: pointer; n: array of single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: pointer; var n: single; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: pointer; var n: single; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: pointer; var n: single; v: pointer) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: pointer; n: pointer; v: array of single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: pointer; n: pointer; var v: single) := TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord2fColor4fNormal3fVertex3fvSUN(tc: pointer; c: pointer; n: pointer; v: pointer) := z_TexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
    
    public z_TexCoord4fColor4fNormal3fVertex4fSUN: procedure(s: single; t: single; p: single; q: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single; w: single) := FuncPtrOrNil&<procedure(s: single; t: single; p: single; q: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single; w: single)>(GetGLProcAdr('glTexCoord4fColor4fNormal3fVertex4fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fSUN(s: single; t: single; p: single; q: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single; w: single) := z_TexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
    
    public z_TexCoord4fColor4fNormal3fVertex4fvSUN: procedure(tc: pointer; c: pointer; n: pointer; v: pointer) := FuncPtrOrNil&<procedure(tc: pointer; c: pointer; n: pointer; v: pointer)>(GetGLProcAdr('glTexCoord4fColor4fNormal3fVertex4fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; n: array of single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; n: array of single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; n: array of single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; var n: single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; var n: single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; var n: single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; n: pointer; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; n: pointer; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: array of single; n: pointer; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; var c: single; n: array of single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; var c: single; n: array of single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; var c: single; n: array of single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; var c: single; var n: single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; var c: single; var n: single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; var c: single; var n: single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; var c: single; n: pointer; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; var c: single; n: pointer; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; var c: single; n: pointer; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: pointer; n: array of single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: pointer; n: array of single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: pointer; n: array of single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: pointer; var n: single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: pointer; var n: single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: pointer; var n: single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: pointer; n: pointer; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: pointer; n: pointer; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: array of single; c: pointer; n: pointer; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc[0], c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: array of single; n: array of single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: array of single; n: array of single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: array of single; n: array of single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: array of single; var n: single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: array of single; var n: single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: array of single; var n: single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: array of single; n: pointer; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: array of single; n: pointer; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: array of single; n: pointer; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; n: array of single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; n: array of single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; n: array of single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; var n: single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; var n: single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; var n: single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; n: pointer; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; n: pointer; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; var c: single; n: pointer; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: pointer; n: array of single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: pointer; n: array of single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: pointer; n: array of single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: pointer; var n: single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: pointer; var n: single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: pointer; var n: single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: pointer; n: pointer; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: pointer; n: pointer; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(var tc: single; c: pointer; n: pointer; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(@tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: array of single; n: array of single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: array of single; n: array of single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: array of single; n: array of single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: array of single; var n: single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: array of single; var n: single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: array of single; var n: single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: array of single; n: pointer; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: array of single; n: pointer; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: array of single; n: pointer; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; var c: single; n: array of single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; var c: single; n: array of single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; var c: single; n: array of single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; var c: single; var n: single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; var c: single; var n: single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; var c: single; var n: single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; var c: single; n: pointer; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; var c: single; n: pointer; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; var c: single; n: pointer; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: pointer; n: array of single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: pointer; n: array of single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: pointer; n: array of single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: pointer; var n: single; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: pointer; var n: single; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: pointer; var n: single; v: pointer) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: pointer; n: pointer; v: array of single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: pointer; n: pointer; var v: single) := TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure TexCoord4fColor4fNormal3fVertex4fvSUN(tc: pointer; c: pointer; n: pointer; v: pointer) := z_TexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
    
    public z_ReplacementCodeuiVertex3fSUN: procedure(rc: UInt32; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(rc: UInt32; x: single; y: single; z: single)>(GetGLProcAdr('glReplacementCodeuiVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fSUN(rc: UInt32; x: single; y: single; z: single) := z_ReplacementCodeuiVertex3fSUN(rc, x, y, z);
    
    public z_ReplacementCodeuiVertex3fvSUN: procedure(rc: pointer; v: pointer) := FuncPtrOrNil&<procedure(rc: pointer; v: pointer)>(GetGLProcAdr('glReplacementCodeuiVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(rc: array of UInt32; v: array of single) := ReplacementCodeuiVertex3fvSUN(rc[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(rc: array of UInt32; var v: single) := ReplacementCodeuiVertex3fvSUN(rc[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(rc: array of UInt32; v: pointer) := ReplacementCodeuiVertex3fvSUN(rc[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: UInt32; v: array of single) := ReplacementCodeuiVertex3fvSUN(@rc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: UInt32; var v: single) := ReplacementCodeuiVertex3fvSUN(@rc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(var rc: UInt32; v: pointer) := ReplacementCodeuiVertex3fvSUN(@rc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(rc: pointer; v: array of single) := ReplacementCodeuiVertex3fvSUN(rc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(rc: pointer; var v: single) := ReplacementCodeuiVertex3fvSUN(rc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiVertex3fvSUN(rc: pointer; v: pointer) := z_ReplacementCodeuiVertex3fvSUN(rc, v);
    
    public z_ReplacementCodeuiColor4ubVertex3fSUN: procedure(rc: UInt32; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(rc: UInt32; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single)>(GetGLProcAdr('glReplacementCodeuiColor4ubVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fSUN(rc: UInt32; r: Byte; g: Byte; b: Byte; a: Byte; x: single; y: single; z: single) := z_ReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
    
    public z_ReplacementCodeuiColor4ubVertex3fvSUN: procedure(rc: pointer; c: pointer; v: pointer) := FuncPtrOrNil&<procedure(rc: pointer; c: pointer; v: pointer)>(GetGLProcAdr('glReplacementCodeuiColor4ubVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: array of UInt32; c: array of Byte; v: array of single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc[0], c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: array of UInt32; c: array of Byte; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc[0], c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: array of UInt32; c: array of Byte; v: pointer) := ReplacementCodeuiColor4ubVertex3fvSUN(rc[0], c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: array of UInt32; var c: Byte; v: array of single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc[0], @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: array of UInt32; var c: Byte; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc[0], @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: array of UInt32; var c: Byte; v: pointer) := ReplacementCodeuiColor4ubVertex3fvSUN(rc[0], @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: array of UInt32; c: pointer; v: array of single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc[0], c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: array of UInt32; c: pointer; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc[0], c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: array of UInt32; c: pointer; v: pointer) := ReplacementCodeuiColor4ubVertex3fvSUN(rc[0], c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; c: array of Byte; v: array of single) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; c: array of Byte; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; c: array of Byte; v: pointer) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; var c: Byte; v: array of single) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; var c: Byte; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; var c: Byte; v: pointer) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; c: pointer; v: array of single) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; c: pointer; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(var rc: UInt32; c: pointer; v: pointer) := ReplacementCodeuiColor4ubVertex3fvSUN(@rc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; c: array of Byte; v: array of single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc, c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; c: array of Byte; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc, c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; c: array of Byte; v: pointer) := ReplacementCodeuiColor4ubVertex3fvSUN(rc, c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; var c: Byte; v: array of single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc, @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; var c: Byte; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; var c: Byte; v: pointer) := ReplacementCodeuiColor4ubVertex3fvSUN(rc, @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; c: pointer; v: array of single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; c: pointer; var v: single) := ReplacementCodeuiColor4ubVertex3fvSUN(rc, c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4ubVertex3fvSUN(rc: pointer; c: pointer; v: pointer) := z_ReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
    
    public z_ReplacementCodeuiColor3fVertex3fSUN: procedure(rc: UInt32; r: single; g: single; b: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(rc: UInt32; r: single; g: single; b: single; x: single; y: single; z: single)>(GetGLProcAdr('glReplacementCodeuiColor3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fSUN(rc: UInt32; r: single; g: single; b: single; x: single; y: single; z: single) := z_ReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
    
    public z_ReplacementCodeuiColor3fVertex3fvSUN: procedure(rc: pointer; c: pointer; v: pointer) := FuncPtrOrNil&<procedure(rc: pointer; c: pointer; v: pointer)>(GetGLProcAdr('glReplacementCodeuiColor3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: array of UInt32; c: array of single; v: array of single) := ReplacementCodeuiColor3fVertex3fvSUN(rc[0], c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: array of UInt32; c: array of single; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(rc[0], c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: array of UInt32; c: array of single; v: pointer) := ReplacementCodeuiColor3fVertex3fvSUN(rc[0], c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: array of UInt32; var c: single; v: array of single) := ReplacementCodeuiColor3fVertex3fvSUN(rc[0], @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: array of UInt32; var c: single; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(rc[0], @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: array of UInt32; var c: single; v: pointer) := ReplacementCodeuiColor3fVertex3fvSUN(rc[0], @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: array of UInt32; c: pointer; v: array of single) := ReplacementCodeuiColor3fVertex3fvSUN(rc[0], c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: array of UInt32; c: pointer; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(rc[0], c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: array of UInt32; c: pointer; v: pointer) := ReplacementCodeuiColor3fVertex3fvSUN(rc[0], c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; c: array of single; v: array of single) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; c: array of single; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; c: array of single; v: pointer) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; var c: single; v: array of single) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; var c: single; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; var c: single; v: pointer) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; c: pointer; v: array of single) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; c: pointer; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(var rc: UInt32; c: pointer; v: pointer) := ReplacementCodeuiColor3fVertex3fvSUN(@rc, c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; c: array of single; v: array of single) := ReplacementCodeuiColor3fVertex3fvSUN(rc, c[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; c: array of single; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(rc, c[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; c: array of single; v: pointer) := ReplacementCodeuiColor3fVertex3fvSUN(rc, c[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; var c: single; v: array of single) := ReplacementCodeuiColor3fVertex3fvSUN(rc, @c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; var c: single; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(rc, @c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; var c: single; v: pointer) := ReplacementCodeuiColor3fVertex3fvSUN(rc, @c, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; c: pointer; v: array of single) := ReplacementCodeuiColor3fVertex3fvSUN(rc, c, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; c: pointer; var v: single) := ReplacementCodeuiColor3fVertex3fvSUN(rc, c, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor3fVertex3fvSUN(rc: pointer; c: pointer; v: pointer) := z_ReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
    
    public z_ReplacementCodeuiNormal3fVertex3fSUN: procedure(rc: UInt32; nx: single; ny: single; nz: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(rc: UInt32; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(GetGLProcAdr('glReplacementCodeuiNormal3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fSUN(rc: UInt32; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_ReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
    
    public z_ReplacementCodeuiNormal3fVertex3fvSUN: procedure(rc: pointer; n: pointer; v: pointer) := FuncPtrOrNil&<procedure(rc: pointer; n: pointer; v: pointer)>(GetGLProcAdr('glReplacementCodeuiNormal3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: array of UInt32; n: array of single; v: array of single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: array of UInt32; n: array of single; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: array of UInt32; n: array of single; v: pointer) := ReplacementCodeuiNormal3fVertex3fvSUN(rc[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: array of UInt32; var n: single; v: array of single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: array of UInt32; var n: single; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: array of UInt32; var n: single; v: pointer) := ReplacementCodeuiNormal3fVertex3fvSUN(rc[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: array of UInt32; n: pointer; v: array of single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: array of UInt32; n: pointer; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: array of UInt32; n: pointer; v: pointer) := ReplacementCodeuiNormal3fVertex3fvSUN(rc[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; n: array of single; v: array of single) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; n: array of single; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; n: array of single; v: pointer) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; var n: single; v: array of single) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; var n: single; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; var n: single; v: pointer) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; n: pointer; v: array of single) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; n: pointer; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(var rc: UInt32; n: pointer; v: pointer) := ReplacementCodeuiNormal3fVertex3fvSUN(@rc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; n: array of single; v: array of single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; n: array of single; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; n: array of single; v: pointer) := ReplacementCodeuiNormal3fVertex3fvSUN(rc, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; var n: single; v: array of single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; var n: single; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; var n: single; v: pointer) := ReplacementCodeuiNormal3fVertex3fvSUN(rc, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; n: pointer; v: array of single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; n: pointer; var v: single) := ReplacementCodeuiNormal3fVertex3fvSUN(rc, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiNormal3fVertex3fvSUN(rc: pointer; n: pointer; v: pointer) := z_ReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
    
    public z_ReplacementCodeuiColor4fNormal3fVertex3fSUN: procedure(rc: UInt32; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(rc: UInt32; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(GetGLProcAdr('glReplacementCodeuiColor4fNormal3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fSUN(rc: UInt32; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_ReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
    
    public z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN: procedure(rc: pointer; c: pointer; n: pointer; v: pointer) := FuncPtrOrNil&<procedure(rc: pointer; c: pointer; n: pointer; v: pointer)>(GetGLProcAdr('glReplacementCodeuiColor4fNormal3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: array of single; n: array of single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: array of single; var n: single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: array of single; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: array of single; var n: single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: array of single; n: pointer; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var c: single; n: array of single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var c: single; n: array of single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var c: single; n: array of single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var c: single; var n: single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var c: single; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var c: single; var n: single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var c: single; n: pointer; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var c: single; n: pointer; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var c: single; n: pointer; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: pointer; n: array of single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: pointer; var n: single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: pointer; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: pointer; var n: single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: pointer; n: pointer; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: array of UInt32; c: pointer; n: pointer; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc[0], c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: array of single; n: array of single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: array of single; var n: single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: array of single; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: array of single; var n: single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: array of single; n: pointer; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: single; n: array of single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: single; n: array of single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: single; n: array of single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: single; var n: single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: single; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: single; var n: single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: single; n: pointer; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: single; n: pointer; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; var c: single; n: pointer; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: pointer; n: array of single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: pointer; var n: single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: pointer; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: pointer; var n: single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: pointer; n: pointer; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(var rc: UInt32; c: pointer; n: pointer; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(@rc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: array of single; n: array of single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: array of single; var n: single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: array of single; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: array of single; var n: single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: array of single; n: pointer; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; var c: single; n: array of single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; var c: single; n: array of single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; var c: single; n: array of single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; var c: single; var n: single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; var c: single; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; var c: single; var n: single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; var c: single; n: pointer; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; var c: single; n: pointer; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; var c: single; n: pointer; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: pointer; n: array of single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: pointer; var n: single; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: pointer; var n: single; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: pointer; var n: single; v: pointer) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: pointer; n: pointer; var v: single) := ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc: pointer; c: pointer; n: pointer; v: pointer) := z_ReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
    
    public z_ReplacementCodeuiTexCoord2fVertex3fSUN: procedure(rc: UInt32; s: single; t: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(rc: UInt32; s: single; t: single; x: single; y: single; z: single)>(GetGLProcAdr('glReplacementCodeuiTexCoord2fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fSUN(rc: UInt32; s: single; t: single; x: single; y: single; z: single) := z_ReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
    
    public z_ReplacementCodeuiTexCoord2fVertex3fvSUN: procedure(rc: pointer; tc: pointer; v: pointer) := FuncPtrOrNil&<procedure(rc: pointer; tc: pointer; v: pointer)>(GetGLProcAdr('glReplacementCodeuiTexCoord2fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: array of UInt32; tc: array of single; v: array of single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc[0], tc[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: array of UInt32; tc: array of single; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc[0], tc[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: array of UInt32; tc: array of single; v: pointer) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc[0], tc[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: array of UInt32; var tc: single; v: array of single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc[0], @tc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: array of UInt32; var tc: single; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc[0], @tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: array of UInt32; var tc: single; v: pointer) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc[0], @tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: array of UInt32; tc: pointer; v: array of single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc[0], tc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: array of UInt32; tc: pointer; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc[0], tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: array of UInt32; tc: pointer; v: pointer) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc[0], tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; tc: array of single; v: array of single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, tc[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; tc: array of single; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, tc[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; tc: array of single; v: pointer) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, tc[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; var tc: single; v: array of single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, @tc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; var tc: single; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, @tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; var tc: single; v: pointer) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, @tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; tc: pointer; v: array of single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, tc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; tc: pointer; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(var rc: UInt32; tc: pointer; v: pointer) := ReplacementCodeuiTexCoord2fVertex3fvSUN(@rc, tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; tc: array of single; v: array of single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; tc: array of single; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; tc: array of single; v: pointer) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; var tc: single; v: array of single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, @tc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; var tc: single; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, @tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; var tc: single; v: pointer) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, @tc, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; tc: pointer; v: array of single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; tc: pointer; var v: single) := ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fVertex3fvSUN(rc: pointer; tc: pointer; v: pointer) := z_ReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
    
    public z_ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN: procedure(rc: UInt32; s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(rc: UInt32; s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(GetGLProcAdr('glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc: UInt32; s: single; t: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_ReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
    
    public z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN: procedure(rc: pointer; tc: pointer; n: pointer; v: pointer) := FuncPtrOrNil&<procedure(rc: pointer; tc: pointer; n: pointer; v: pointer)>(GetGLProcAdr('glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], @tc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], @tc, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], @tc, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], @tc, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], @tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], @tc, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], @tc, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], @tc, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], @tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc[0], tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, @tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(@rc, tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; var tc: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, @tc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; var tc: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, @tc, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; var tc: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, @tc, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, @tc, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, @tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, @tc, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; var tc: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, @tc, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; var tc: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, @tc, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; var tc: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, @tc, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; n: pointer; v: pointer) := z_ReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
    
    public z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN: procedure(rc: UInt32; s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := FuncPtrOrNil&<procedure(rc: UInt32; s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single)>(GetGLProcAdr('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc: UInt32; s: single; t: single; r: single; g: single; b: single; a: single; nx: single; ny: single; nz: single; x: single; y: single; z: single) := z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
    
    public z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN: procedure(rc: pointer; tc: pointer; c: pointer; n: pointer; v: pointer) := FuncPtrOrNil&<procedure(rc: pointer; tc: pointer; c: pointer; n: pointer; v: pointer)>(GetGLProcAdr('glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var c: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var c: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var c: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var c: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var c: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var c: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var c: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; var c: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: array of single; c: pointer; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc[0], c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var c: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var c: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var c: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var c: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var c: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var c: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var c: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; var c: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; var tc: single; c: pointer; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], @tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var c: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var c: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var c: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var c: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var c: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var c: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var c: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; var c: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: array of UInt32; tc: pointer; c: pointer; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc[0], tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var c: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var c: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var c: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var c: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var c: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var c: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var c: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; var c: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: array of single; c: pointer; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc[0], c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var c: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var c: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var c: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var c: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var c: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var c: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var c: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; var c: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; var tc: single; c: pointer; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, @tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var c: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var c: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var c: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var c: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var c: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var c: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var c: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; var c: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(var rc: UInt32; tc: pointer; c: pointer; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(@rc, tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var c: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var c: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var c: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var c: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var c: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var c: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var c: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; var c: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: array of single; c: pointer; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc[0], c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var c: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var c: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var c: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var c: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var c: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var c: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var c: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; var c: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; var tc: single; c: pointer; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, @tc, c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: array of single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c[0], n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: array of single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c[0], n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: array of single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c[0], n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: array of single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c[0], @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: array of single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c[0], @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: array of single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c[0], @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: array of single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c[0], n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: array of single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c[0], n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: array of single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c[0], n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var c: single; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, @c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var c: single; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, @c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var c: single; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, @c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var c: single; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, @c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var c: single; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, @c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var c: single; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, @c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var c: single; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, @c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var c: single; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, @c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; var c: single; n: pointer; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, @c, n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: pointer; n: array of single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n[0], v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: pointer; n: array of single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n[0], @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: pointer; n: array of single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n[0], v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: pointer; var n: single; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, @n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: pointer; var n: single; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, @n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: pointer; var n: single; v: pointer) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, @n, v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: pointer; n: pointer; v: array of single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v[0]);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: pointer; n: pointer; var v: single) := ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, @v);
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc: pointer; tc: pointer; c: pointer; n: pointer; v: pointer) := z_ReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
    
    {$endregion SUN_vertex}
    
  end;
  
  gl_SUNX = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    public static function GetGLProcAdr([MarshalAs(UnmanagedType.LPStr)] lpszProc: string): IntPtr;
    external 'opengl32.dll' name 'wglGetProcAddress';
    
    {$region SUNX_constant_data}
    
    public z_FinishTextureSUNX: procedure := FuncPtrOrNil&<procedure>(GetGLProcAdr('glFinishTextureSUNX'));
    public [MethodImpl(MethodImplOptions.AggressiveInlining)] procedure FinishTextureSUNX := z_FinishTextureSUNX();
    
    {$endregion SUNX_constant_data}
    
  end;
  
  gdi = sealed class
    private static function FuncPtrOrNil<T>(ptr: IntPtr) := ptr=IntPtr.Zero ? default(T) : Marshal.GetDelegateForFunctionPointer&<T>(ptr);
    
    {$region Unsorted}
    
    public static function ChoosePixelFormat(hDc: GDI_DC; [MarshalAs(UnmanagedType.LPArray)] pPfd: array of GDI_PixelFormatDescriptor): Int32;
    external 'gdi32.dll' name 'ChoosePixelFormat';
    public static function ChoosePixelFormat(hDc: GDI_DC; var pPfd: GDI_PixelFormatDescriptor): Int32;
    external 'gdi32.dll' name 'ChoosePixelFormat';
    public static function ChoosePixelFormat(hDc: GDI_DC; pPfd: pointer): Int32;
    external 'gdi32.dll' name 'ChoosePixelFormat';
    
    public static function DescribePixelFormat(hdc: GDI_DC; ipfd: Int32; cjpfd: UInt32; [MarshalAs(UnmanagedType.LPArray)] ppfd: array of GDI_PixelFormatDescriptor): Int32;
    external 'gdi32.dll' name 'DescribePixelFormat';
    public static function DescribePixelFormat(hdc: GDI_DC; ipfd: Int32; cjpfd: UInt32; var ppfd: GDI_PixelFormatDescriptor): Int32;
    external 'gdi32.dll' name 'DescribePixelFormat';
    public static function DescribePixelFormat(hdc: GDI_DC; ipfd: Int32; cjpfd: UInt32; ppfd: pointer): Int32;
    external 'gdi32.dll' name 'DescribePixelFormat';
    
    public static function GetEnhMetaFilePixelFormat(hemf: GDI_HENHMetafile; [MarshalAs(UnmanagedType.LPArray)] ppfd: array of GDI_PixelFormatDescriptor): UInt32;
    external 'gdi32.dll' name 'GetEnhMetaFilePixelFormat';
    public static function GetEnhMetaFilePixelFormat(hemf: GDI_HENHMetafile; var ppfd: GDI_PixelFormatDescriptor): UInt32;
    external 'gdi32.dll' name 'GetEnhMetaFilePixelFormat';
    public static function GetEnhMetaFilePixelFormat(hemf: GDI_HENHMetafile; ppfd: pointer): UInt32;
    external 'gdi32.dll' name 'GetEnhMetaFilePixelFormat';
    
    public static function GetPixelFormat(hdc: GDI_DC): Int32;
    external 'gdi32.dll' name 'GetPixelFormat';
    
    public static function SetPixelFormat(hdc: GDI_DC; ipfd: Int32; [MarshalAs(UnmanagedType.LPArray)] ppfd: array of GDI_PixelFormatDescriptor): UInt32;
    external 'gdi32.dll' name 'SetPixelFormat';
    public static function SetPixelFormat(hdc: GDI_DC; ipfd: Int32; var ppfd: GDI_PixelFormatDescriptor): UInt32;
    external 'gdi32.dll' name 'SetPixelFormat';
    public static function SetPixelFormat(hdc: GDI_DC; ipfd: Int32; ppfd: pointer): UInt32;
    external 'gdi32.dll' name 'SetPixelFormat';
    
    public static function SwapBuffers(hdc: GDI_DC): UInt32;
    external 'gdi32.dll' name 'SwapBuffers';
    
    {$endregion Unsorted}
    
  end;
  
  {$endregion Auto translated}
  
  ///Методы для интеграции с gdi
  gl_gdi = static class
    {$reference System.Windows.Forms.dll}
    
    {$region Misc}
    
    ///Создаёт новую поверхность рисования GDI для дескриптора элемента управления
    public static function GetControlDC(hwnd: IntPtr): GDI_DC;
    external 'user32.dll' name 'GetDC';
    
    {$endregion Misc}
    
    {$region InitControl}
    
    ///Создаёт и настраивает поверхность рисования GDI элемента управления WF
    ///hwnd - дескриптор элемента управления
    public static function InitControl(hwnd: IntPtr): GDI_DC;
    begin
      Result := gl_gdi.GetControlDC(hwnd);
      
      var pfd: GDI_PixelFormatDescriptor;
      pfd.nSize := sizeof( GDI_PixelFormatDescriptor ); //ToDo это же можно убрать, оно есть в заголовке записи...
      pfd.nVersion := 1;
      
      pfd.dwFlags :=
        GDI_PixelFormatFlags.DRAW_TO_WINDOW or
        GDI_PixelFormatFlags.SUPPORT_OPENGL or
        GDI_PixelFormatFlags.DOUBLEBUFFER
      ;
      pfd.cColorBits := 24;
      pfd.cDepthBits := 16;
      
      if 1 <> gdi.SetPixelFormat(
        Result,
        gdi.ChoosePixelFormat(Result, pfd),
        pfd
      ) then raise new InvalidOperationException;
      
    end;
    
    ///Создаёт и настраивает поверхность рисования GDI элемента управления WF
    public static function InitControl(c: System.Windows.Forms.Control) := InitControl(c.Handle);
    
    {$endregion InitControl}
    
    {$region SetupControlRedrawing}
    
    ///Добавляет в эвент Form.Load формы (f) обработчик, который:
    ///1. Создаёт контекст OpenGL на поверхности рисования GDI (hdc)
    ///2. Запускает перерисовку (RedrawThreadProc)
    public static procedure SetupControlRedrawing(f: System.Windows.Forms.Form; hdc: GDI_DC; RedrawThreadProc: procedure(EndFrame: ()->()); vsync_fps: integer := 65);
    begin
      
      f.Load += (o,e)->
        System.Threading.Thread.Create(()->
        begin
          
          var context := wgl.CreateContext(hdc);
          if 1 <> wgl.MakeCurrent(hdc, context) then raise new InvalidOperationException;
          
          var EndFrame: ()->();
          if vsync_fps<=0 then
            EndFrame := ()->gdi.SwapBuffers(hdc) else
          begin
            var LastRedr := DateTime.Now;
            var FrameDuration := new TimeSpan(Trunc(TimeSpan.TicksPerSecond/vsync_fps));
            var MaxSlowDown := FrameDuration.Ticks*3;
            
            EndFrame := ()->
            begin
              gdi.SwapBuffers(hdc);
              
              LastRedr := LastRedr+FrameDuration;
              var time_left := LastRedr-DateTime.Now;
              
              if time_left.Ticks>0 then
                System.Threading.Thread.Sleep(time_left) else
              if -time_left.Ticks > MaxSlowDown then
                LastRedr := LastRedr.AddTicks(-time_left.Ticks - MaxSlowDown);
              
            end;
            
          end;
          
          RedrawThreadProc(EndFrame);
        end).Start();
      
    end;
    
    {$endregion SetupControlRedrawing}
    
  end;
  
implementation

{$region MtrMlt}

function operator*(m1: Mtr2x2f; m2: Mtr2x2f): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
end;

function operator*(m1: Mtr2x2f; m2: Mtr2x3f): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
end;

function operator*(m1: Mtr2x2f; m2: Mtr2x4f): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
end;

function operator*(m1: Mtr2x2f; m2: Mtr2x2d): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
end;

function operator*(m1: Mtr2x2f; m2: Mtr2x3d): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
end;

function operator*(m1: Mtr2x2f; m2: Mtr2x4d): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x3f): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x2f): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x4f): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x3d): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x2d): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
end;

function operator*(m1: Mtr3x3f; m2: Mtr3x4d): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x4f): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x2f): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x3f): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x4d): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x2d): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
end;

function operator*(m1: Mtr4x4f; m2: Mtr4x3d): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x3f): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x2f): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x4f): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x3d): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x2d): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
end;

function operator*(m1: Mtr2x3f; m2: Mtr3x4d): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x2f): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x3f): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x4f): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x2d): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x3d): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
end;

function operator*(m1: Mtr3x2f; m2: Mtr2x4d): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x4f): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x2f): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x3f): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x4d): Mtr2x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x2d): Mtr2x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
end;

function operator*(m1: Mtr2x4f; m2: Mtr4x3d): Mtr2x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x2f): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x3f): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x4f): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x2d): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x3d): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
end;

function operator*(m1: Mtr4x2f; m2: Mtr2x4d): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x4f): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x2f): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x3f): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x4d): Mtr3x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x2d): Mtr3x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
end;

function operator*(m1: Mtr3x4f; m2: Mtr4x3d): Mtr3x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x3f): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x2f): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x4f): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x3d): Mtr4x3f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x2d): Mtr4x2f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
end;

function operator*(m1: Mtr4x3f; m2: Mtr3x4d): Mtr4x4f; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x2f): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x3f): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x4f): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x2d): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x3d): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
end;

function operator*(m1: Mtr2x2d; m2: Mtr2x4d): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x3f): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x2f): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x4f): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x3d): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x2d): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
end;

function operator*(m1: Mtr3x3d; m2: Mtr3x4d): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x4f): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x2f): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x3f): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x4d): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23 + m1.val33*m2.val33;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x2d): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
end;

function operator*(m1: Mtr4x4d; m2: Mtr4x3d): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20 + m1.val33*m2.val30;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21 + m1.val33*m2.val31;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22 + m1.val33*m2.val32;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x3f): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x2f): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x4f): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x3d): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x2d): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
end;

function operator*(m1: Mtr2x3d; m2: Mtr3x4d): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x2f): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x3f): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x4f): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x2d): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x3d): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
end;

function operator*(m1: Mtr3x2d; m2: Mtr2x4d): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x4f): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x2f): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x3f): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x4d): Mtr2x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x2d): Mtr2x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
end;

function operator*(m1: Mtr2x4d; m2: Mtr4x3d): Mtr2x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x2f): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x3f): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x4f): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x2d): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x3d): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
end;

function operator*(m1: Mtr4x2d; m2: Mtr2x4d): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x4f): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x2f): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x3f): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x4d): Mtr3x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23 + m1.val03*m2.val33;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23 + m1.val13*m2.val33;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23 + m1.val23*m2.val33;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x2d): Mtr3x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
end;

function operator*(m1: Mtr3x4d; m2: Mtr4x3d): Mtr3x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20 + m1.val03*m2.val30;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21 + m1.val03*m2.val31;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22 + m1.val03*m2.val32;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20 + m1.val13*m2.val30;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21 + m1.val13*m2.val31;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22 + m1.val13*m2.val32;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20 + m1.val23*m2.val30;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21 + m1.val23*m2.val31;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22 + m1.val23*m2.val32;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x3f): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x2f): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x4f): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x3d): Mtr4x3d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x2d): Mtr4x2d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
end;

function operator*(m1: Mtr4x3d; m2: Mtr3x4d): Mtr4x4d; extensionmethod;
begin
  Result.val00 := m1.val00*m2.val00 + m1.val01*m2.val10 + m1.val02*m2.val20;
  Result.val01 := m1.val00*m2.val01 + m1.val01*m2.val11 + m1.val02*m2.val21;
  Result.val02 := m1.val00*m2.val02 + m1.val01*m2.val12 + m1.val02*m2.val22;
  Result.val03 := m1.val00*m2.val03 + m1.val01*m2.val13 + m1.val02*m2.val23;
  Result.val10 := m1.val10*m2.val00 + m1.val11*m2.val10 + m1.val12*m2.val20;
  Result.val11 := m1.val10*m2.val01 + m1.val11*m2.val11 + m1.val12*m2.val21;
  Result.val12 := m1.val10*m2.val02 + m1.val11*m2.val12 + m1.val12*m2.val22;
  Result.val13 := m1.val10*m2.val03 + m1.val11*m2.val13 + m1.val12*m2.val23;
  Result.val20 := m1.val20*m2.val00 + m1.val21*m2.val10 + m1.val22*m2.val20;
  Result.val21 := m1.val20*m2.val01 + m1.val21*m2.val11 + m1.val22*m2.val21;
  Result.val22 := m1.val20*m2.val02 + m1.val21*m2.val12 + m1.val22*m2.val22;
  Result.val23 := m1.val20*m2.val03 + m1.val21*m2.val13 + m1.val22*m2.val23;
  Result.val30 := m1.val30*m2.val00 + m1.val31*m2.val10 + m1.val32*m2.val20;
  Result.val31 := m1.val30*m2.val01 + m1.val31*m2.val11 + m1.val32*m2.val21;
  Result.val32 := m1.val30*m2.val02 + m1.val31*m2.val12 + m1.val32*m2.val22;
  Result.val33 := m1.val30*m2.val03 + m1.val31*m2.val13 + m1.val32*m2.val23;
end;

{$endregion MtrMlt}

{$region MtrTranspose}

function Transpose(self: Mtr2x2f); extensionmethod :=
new Mtr2x2f(self.val00, self.val10, self.val01, self.val11);

function Transpose(self: Mtr3x3f); extensionmethod :=
new Mtr3x3f(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22);

function Transpose(self: Mtr4x4f); extensionmethod :=
new Mtr4x4f(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32, self.val03, self.val13, self.val23, self.val33);

function Transpose(self: Mtr2x3f); extensionmethod :=
new Mtr3x2f(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12);
function Transpose(self: Mtr3x2f); extensionmethod :=
new Mtr2x3f(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21);

function Transpose(self: Mtr2x4f); extensionmethod :=
new Mtr4x2f(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12, self.val03, self.val13);
function Transpose(self: Mtr4x2f); extensionmethod :=
new Mtr2x4f(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31);

function Transpose(self: Mtr3x4f); extensionmethod :=
new Mtr4x3f(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22, self.val03, self.val13, self.val23);
function Transpose(self: Mtr4x3f); extensionmethod :=
new Mtr3x4f(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32);

function Transpose(self: Mtr2x2d); extensionmethod :=
new Mtr2x2d(self.val00, self.val10, self.val01, self.val11);

function Transpose(self: Mtr3x3d); extensionmethod :=
new Mtr3x3d(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22);

function Transpose(self: Mtr4x4d); extensionmethod :=
new Mtr4x4d(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32, self.val03, self.val13, self.val23, self.val33);

function Transpose(self: Mtr2x3d); extensionmethod :=
new Mtr3x2d(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12);
function Transpose(self: Mtr3x2d); extensionmethod :=
new Mtr2x3d(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21);

function Transpose(self: Mtr2x4d); extensionmethod :=
new Mtr4x2d(self.val00, self.val10, self.val01, self.val11, self.val02, self.val12, self.val03, self.val13);
function Transpose(self: Mtr4x2d); extensionmethod :=
new Mtr2x4d(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31);

function Transpose(self: Mtr3x4d); extensionmethod :=
new Mtr4x3d(self.val00, self.val10, self.val20, self.val01, self.val11, self.val21, self.val02, self.val12, self.val22, self.val03, self.val13, self.val23);
function Transpose(self: Mtr4x3d); extensionmethod :=
new Mtr3x4d(self.val00, self.val10, self.val20, self.val30, self.val01, self.val11, self.val21, self.val31, self.val02, self.val12, self.val22, self.val32);

{$endregion MtrTranspose}

end.