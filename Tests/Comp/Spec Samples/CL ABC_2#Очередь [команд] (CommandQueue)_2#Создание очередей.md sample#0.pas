uses OpenCLABC;

begin
  // Ѕуфер достаточного размера чтоб содержать 3 значени€ типа integer
  var b := new Buffer( 3*sizeof(integer) );
  
  // —оздаЄм очередь
  var q := b.NewQueue;
  
  // ƒобавл€ть команды в полученную очередь можно вызыва€ соответствующие методы
  q.AddWriteValue(1, 0*sizeof(integer) );
  
  // ћетоды, добавл€ющие команду в очередь - возвращают очередь, дл€ которой их вызвали (не копию а ссылку на оригинал)
  // ѕоэтому можно добавл€ть по несколько команд в 1 строчке:
  q.AddWriteValue(5, 1*sizeof(integer) ).AddWriteValue(7, 2*sizeof(integer) );
  // ¬се команды в q будут выполн€тс€ последовательно, что не всегда хорошо
  // ≈сли надо выполн€ть параллельно - создавайте несколько "b.NewQueue" и умножайте друг на друга
  
  // ¬ данной версии надо писать "as CommandQueue<...>" при использовании [Buffer/Kernel]CommandQueue там,
  // где принимает CommandQueue<...>, из за бага компил€тора #1981
  Context.Default.SyncInvoke(q as CommandQueue<Buffer>);
  
  // ¬ообще чтение тоже надо делать через очереди, но дл€ простого примера - и не€вные очереди подход€т
  b.GetArray1&<integer>(3).Println;
  
end.