


# CommandQueue[%Base,<T>%]
Представляет очередь, состоящую в основном из команд, выполняемых на GPU



# CommandQueueBase.Cast<T>
Если данная очередь проходит по условию "... is CommandQueue<T>" - возвращает себя же
Иначе возвращает очередь-обёртку, выполняющую "res := T(res)", где res - результат данной очереди



# CommandQueueBase.ThenConvert<TOtp>(object->TOtp)
# CommandQueue<T>.ThenConvert<TOtp>(T->TOtp)
# CQ:ThenConvertDef
Создаёт очередь, которая выполнит данную
А затем выполнит на CPU функцию f, используя результат данной очереди

# CommandQueueBase.ThenConvert<TOtp>((object, Context)->TOtp)
# CommandQueue<T>.ThenConvert<TOtp>((T, Context)->TOtp)
%CQ:ThenConvertDef% и контекст выполнения



# CommandQueue[%Base,<T>%].Multiusable
Создаёт функцию, вызывая которую можно создать любое кол-во очередей-удлинителей для данной очереди
Подробнее в справке: "Очередь>>Создание очередей>>Множественное использование очереди"



# CQ:ThenWaitDef
Создаёт очередь, сначала выполняющую данную, а затем ожидающую

# CommandQueue[%Base,<T>%].ThenWaitFor(MarkerQueue)
%CQ:ThenWaitDef% сигнала выполненности от заданого маркера

# CommandQueue[%Base,<T>%].ThenWaitForAll([%sequence,array%] of MarkerQueue)
%CQ:ThenWaitDef% сигнала выполненности от каждого из заданых маркеров

# CommandQueue[%Base,<T>%].ThenWaitForAny([%sequence,array%] of MarkerQueue)
%CQ:ThenWaitDef% первого сигнала выполненности от любого из заданных маркеров



# CommandQueueBase.ToString
Возвращает строковое представление данной очереди
Используйте это значение только для отладки, потому что данный метод довольно медленный

# CommandQueueBase.Print[%,ln%]
Вызывает Write{%0%}(ToString) для данной очереди и возвращает её же


