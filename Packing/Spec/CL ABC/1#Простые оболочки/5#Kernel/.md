


Объект типа `Kernel` представляет одну подпрограмму в OpenCL-C коде,
объявленную с ключевым словом `__kernel`.

---

Обычно `Kernel` создаётся через индексное свойтсво `ProgramCode`:
```
var code: ProgramCode;
...
var k := code['KernelName'];
```
Тут `'KernelName'` — имя подпрограммы-kernel'а в исходном коде (регистр важен!).

---

Так же можно получить список всех kernel'ов объекта `ProgramCode`, методом `ProgramCode.GetAllKernels`:
```
var code: ProgramCode;
...
var ks := code.GetAllKernels;
ks.PrintLines;
```

---

Методы, запускающие `Kernel` - принемают специальные аргументы типа `KernelArg`, которые передаются в OpenCL-C код.\
Экземпляр `KernelArg` может быть создан из нескольких типов значений, а точнее:
```
uses OpenCLABC;

begin
  var k: Kernel;
  var val1 := 3;
  var val2 := 5;
  
  k.Exec1(1,
    // Передавать можно:
    
    // Буфер
    new Buffer(1),
    // Очередь возвращающую буфер
    HFQ(()->new Buffer(1)),
    // В том числе BufferCommandQueue
    Buffer.Create(1).NewQueue as CommandQueue<Buffer>,
    
    // Размерное значение
    val1,
    HFQ(()->val1),
    
    // И указатель на размерное значение
    // (в kernel попадёт само значение, не указатель)
    @val2,
    // Так нельзя, потому что val1 уже захвачена лямбдой HFQ
//  @val1,
    // Расширенный набор параметров
    KernelArg.FromPtr(new System.IntPtr(@val2), new System.UIntPtr(sizeof(integer)))
    
  );
end.
```
Обратите внимание, `KernelArg` из указателя на `val2` будет немного эффективнее
чем `KernelArg` из самого значения `val2`. Но эту возможность стоит использовать
только как тонкую оптимизацию, потому что много чего может пойти не так.
Если передавать `@val2` в качестве `KernelArg` - надо знать все тонкости.

---

Если `@val2` передали вкачестве `KernelArg`:

1. `val2` не может быть глобальной переменной или полем класса (в том числе статическим).\
   Она должна быть объявлена в той же подпрограмме, где использована.

2. `val2` не должно быть захвачего лямбдой.\
   Хотя указатель на `val2` - уже можно захватывать:
   ```
   uses OpenCLABC;
   
   begin
     var k: Kernel;
     var val1 := 3;
     var val2 := 5;
     
     // на val1 всё ещё накладываются все ограничени
     // но у val1_ptr этих ограничений нет
     var val1_ptr := @val1;
     
     k.Exec1(1,
       
       val1,
       HFQ(()->val1_ptr^), // захватили val1_ptr, а не val1
       
       // Сама val1 нигде не захвачена, поэтому теперь так можно
       @val1,
       val1_ptr // то же самое
       
     );
     
   end.
   ```

3. Выходить из подпрограммы, где объявили `val2` нельзя, пока `.Exec` не закончит выполнятся.
   Это так же значит, что возвращать очередь, содержащую `KernelArg` из `@val2` обычно нельзя.\
   Но это можно обойти, если объявлять переменную в другой подпрограмме, а дальше передавать только её адрес:
   ```
   uses OpenCLABC;
   
   var k: Kernel; // Вообще лучше передавать параметром в p2
   
   // Обратите внимание - val принимает var-параметром
   // То есть, p2 принимает адрес val
   // (можно так же принимать указатель, но это не так удобно)
   // Иначе переменная будет копироваться при передаче
   // То есть без var перед параметром - val тут
   // будет новой переменной, объявленной в p2 а не в p1
   function p2(var val: integer): CommandQueueBase;
   begin
     
     Result := k.NewQueue.AddExec1(1,
       
       @val
       
     );
     
   end;
   
   procedure p1;
   begin
     var val: integer;
     
     var q := p2(val);
     // Опять же, q не должна продолжать выпоняться
     // после выхода из p1, потому что тут объявлена val
     Context.Default.SyncInvoke(q);
     
   end;
   
   begin
     p1;
   end.
   ```

Компилятор не заставит вас следовать этим ограничениям. И программа может даже работать, игнорируя большинство сказанного тут.\
Но потом вы добавите что то в совсем другой части программы, или запустите её на
другом компьютере и она вдруг начнёт выводить мусорные значения,
или падать с ошибками вроде `AccessViolationException`, которые совершенно не объясняют в чём проблема.


