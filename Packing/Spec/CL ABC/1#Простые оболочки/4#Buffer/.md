


Программам, выпоняемые на GPU, не удобно использовать оперативную память.
Поэтому обычно надо выделять память на самом GPU.\
Объекты типа `Buffer` представляют такую область памяти.

---

Буфер создаётся конструктором (`new Buffer(...)`).

Но если не передавать контекст в конструктор - память на GPU выделится только при вызове метода `Buffer.Init`.\
Если вызвать `Buffer.Init` 2 раза - память освободится и выделится заново.

Когда на GPU выделяется память - она **НЕ** очищается нулями, а значит содержит мусорные данные.

Если метод `Buffer.Init` не был вызван до первой операции чтения/записи - он будет вызван автоматически.
В таком случае в качестве контекста в котором выделяется память берётся тот,
на котором вызвали `.BeginInvoke`, который запустил команду чтения/записи буфера.

Память на GPU можно моментально освободить, вызвав метод `Buffer.Dispose`.
Но если снова использовать буфер, у которого освободили память - память выделится заново.

Если сборщик мусора удаляет объект типа `Buffer` - `.Dispose` вызывается автоматически.

---

Но кроме выделения памяти GPU - OpenCL так же позволяет выделять память внутри другого буфера.\
Для этого используется тип `SubBuffer`:
```
uses OpenCLABC;

begin
  var c := Context.Default;
  
  // Не обязательно MainDevice, можно взять любое устройство из контекста
  var align := c.MainDevice.Properties.MemBaseAddrAlign;
  
  var b := new Buffer(align*2, c);
  // size может быть любым, но origin
  // должно быть align*N, где N - целое
  var b1 := new SubBuffer(b, 0, Min(123,align));
  var b2 := new SubBuffer(b, align, align);
  
  Writeln(b1);
  Writeln(b2);
end.
```


