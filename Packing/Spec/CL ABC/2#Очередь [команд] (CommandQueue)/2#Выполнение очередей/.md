


Самый простой способ выполнить очередь - вызвать метод `Context.SyncInvoke`.\
Он синхронно выполняет очередь и вызвращает её результат.

Но если надо выполнить очередь асинхронно - лучше использовать метод `Context.BeginInvoke`.\
Он запускает асинхронное выполнение очереди и как только очередь была полностью запущена - возвращает объект типа `CLTask<>`, у которого есть:
- Event'ы (но реализованы методами), позволяющие указать что должно выполнятся когда выполнение `CLTask` завершится.
- Свойства, возвращающие оригинальную очередь и контекст выполнения.
- Методы для ожидания окончания выполнения и получения результата очереди.

Метод `Context.SyncInvoke` реализован как `.BeginInvoke(...).WaitRes`.
Поэтому, везде где сказано "... происходит при вызове `.BeginInvoke`", это же относится и к `.SyncInvoke`.

У `CLTask`, как и у очереди - в `<>`, указывается тип возвращаемого значения. То есть:
```
var t: CLTask<integer>;
```
В такую переменную можно сохранить только результат `Context.BeginInvoke` для очереди типа `CommandQueue<integer>`.

И как и у `CommandQueue`:
- Существует так же и тип `CLTaskBase`, у которого типа возвращаемого значения не указывается.
- Переменной типа `CLTaskBase` можно присвоить `CLTask` с любым возвращаемым значением.
- `Context.BeginInvoke` для очереди типа `CommandQueueBase` возвращает `CLTaskBase`.

---

Если при выполнении возникла ошибка, о ней выведет не полную информацию. Чтобы получить всю информацию - используется `try`:
```
try
  
  //ToDo ваш код, вызывающий ошибку
  
except
  // Writeln выводит все внутренние исключения. "e.ToString" тоже.
  on e: Exception do Writeln(e);
end;
```
Для этого кода есть стандартный снипет. Чтобы активировать его - напишите `tryo` и нажмите Shift+Пробел.


