


Если сложить две очереди A и B (`var C := A+B`) — получится очередь C, в которой сначала выполнится A, а затем B.\
Очередь C будет считаться выполненной тогда, когда выполнится очередь B.

Если умножить две очереди A и B (`var C := A*B`) — получится очередь C, в которой одновременно начнут выполняться A и B.\
Очередь C будет считаться выполненной тогда, когда обе очереди (A и B) выполнятся.

Как и в математике, умножение имеет бОльший приоритет чем сложение.

В обоих случаях очередь C будет возвращать то, что вернула очередь B. То есть если складывать и умножать много очередей - результат будет всегда возвращать то, что вернула самая последняя очередь.

Простейший пример:
```
uses OpenCLABC;

begin
  
  var q1 := HPQ(()->
  begin
    // lock необходим чтобы при параллельном выполнении два потока
    // не пытались использовать вывод одновременно. Иначе выведет кашу
    lock output do Writeln('Очередь 1 начала выполняться');
    Sleep(500);
    lock output do Writeln('Очередь 1 закончила выполняться');
  end);
  var q2 := HPQ(()->
  begin
    lock output do Writeln('Очередь 2 начала выполняться');
    Sleep(500);
    lock output do Writeln('Очередь 2 закончила выполняться');
  end);
  
  Writeln('Последовательное выполнение:');
  Context.Default.SyncInvoke( q1 + q2 );
  
  Writeln;
  Writeln('Параллельное выполнение:');
  Context.Default.SyncInvoke( q1 * q2 );
  
end.
```

Операторы += и \*= также применимы к очередям.\
И как и для чисел - `A += B` работает как `A := A+B` (и аналогично с \*=).\
А значит, возвращаемые типы очередей A и B должны быть одинаковыми, чтобы к ним можно было применить +=/*=.

Если надо сложить/умножить много очередей - лучше применять `CombineSyncQueue`/`CombineAsyncQueue` соответственно.\
Эти подпрограммы работают немного быстрее чем сложение и умножение, если объединять больше двух очередей.

Кроме того, они могут принимать ещё один параметр перед очередями:
Этот параметр позволяет указать функцию преобразования, которая использует результаты всех входных очередей:
```
uses OpenCLABC;

begin
  
  var q1 := HFQ( ()->1 );
  var q2 := HFQ( ()->2 );
  
  // Выводит 2, то есть только результат последней очереди
  // Так сделано из за вопросов производительности
  Context.Default.SyncInvoke( q1+q2 ).Println;
  // Однако бывает так, что нужны результаты всех сложенных/умноженных очередей
  
  // В таком случае надо использовать CombineSyncQueue и CombineAsyncQueue
  // А точнее их перегрузку, первый параметр которой - функция преобразования
  Context.Default.SyncInvoke(
    CombineSyncQueue(
      results->results.JoinToString, // функция преобразования
      q1, q2
    )
  ).Println;
  // Теперь выводит строку "1 2". Это то же самое, что вернёт "Arr(1,2).JoinToString"
  
end.
```


