


Передавать команды по одной, когда их несколько - ужасно не эффективно!\
Но нередко бывает так, что команда всего одна. Или для отладки надо одноразово выполнить одну команду.

Для таких случаев можно создавать очередь неявно:\
У каждого `.Add*` метода есть дублирующий метод в оригинальном объекте. Такие методы сами создают
новую очередь, добавляют в неё одну соответствующую команду и выполняют полученную очередь в `Context.Default.SyncInvoke(...)`.

Обычный код с очередями:
```
uses OpenCLABC;

begin
  var b := new Buffer( 3*sizeof(integer) );
  
  var Q_BuffWrite := b.NewQueue
    .AddWriteValue(1, 0*sizeof(integer) )
    .AddWriteValue(5, 1*sizeof(integer) )
    .AddWriteValue(7, 2*sizeof(integer) )
  ;
  
  var Q_BuffRead :=
    b.NewQueue.AddGetArray1&<integer>
    .ThenConvert(A->A.Println);
  ;
  
  Context.Default.SyncInvoke(
    Q_BuffWrite +
    Q_BuffRead
  );
  
end.
```
Он же, но с неявными очередями:
```
uses OpenCLABC;

begin
  var b := new Buffer( 3*sizeof(integer) );
  
  // Аналог Q_BuffWrite
  b.WriteValue(1, 0*sizeof(integer) );
  b.WriteValue(5, 1*sizeof(integer) );
  b.WriteValue(7, 2*sizeof(integer) );
  
  // Аналог Q_BuffRead
  b.GetArray1&<integer>.Println;
  
end.
```


