


Большинство деревьев выполнения очередей можно реализовать используя только сложение и умножение очередей. Но есть несколько проблем:

-  Большинство но не все. Пример дерева которое нельзя реализовать через сложение и умножение можно найти [тут](https://github.com/SunSerega/POCGL/blob/master/Samples/OpenCLABC/Wait%20очереди/1.pas) или в файле:\
   C:\\PABCWork.NET\\Samples\\OpenGL и OpenCL\\OpenCLABC\\Wait очереди\\1.pas
   
-  Даже если дерево реализуется сложением+умножением - такая реализация может выглядеть запутано и не похоже на график дерева выполнения, [к примеру](https://github.com/SunSerega/POCGL/blob/master/Samples/OpenCLABC/Wait%20очереди/2.pas):\
   C:\\PABCWork.NET\\Samples\\OpenGL и OpenCL\\OpenCLABC\\Wait очереди\\2.pas
   
-  Очереди, выполняемые на разных контекстах не могут эффективно взаимодействовать.

Эти проблемы решают `Wait`-очереди:
```
## uses OpenCLABC;

var M := new WaitMarker;

var t := Context.Default.BeginInvoke(
  HPQ(()->Writeln('Начало .BeginInvoke')) +
  WaitFor(M) +
  HPQ(()->Writeln('Конец .BeginInvoke'))
);

Sleep(2000);
Writeln('Посылаем сигнал маркера M');
M.SendSignal;

t.Wait;
```
`WaitFor(M)` создаёт очень простую `Wait`-очередь.\
Внутри вызова `.BeginInvoke` (до того как он вернёт `CLTask`)
эта очередь входит в режим ожидания сигналов от маркера `M`.\
В этом режиме она **не** тратит время процессора, но готова возобновить выполнение в любой момент.

Далее, вызов `M.SendSignal` посылает по 1 сигналу всем `.BeginInvoke`, имеющим `Wait` очереди в ожидании этого сигнала.

`WaitMarker`, так же, является своеобразной очередью, то есть
его можно складывать с другими очередями и передавать в `.BeginInvoke` .\
При выполнении в качестве очереди маркер вызывает свой метод `.SendSignal` и сразу возвращает `object(nil)`.\
То есть как очередь он равноценен `HPQ(M.SendSignal)`, но немного более эффективен.

Но стоит так же сказать, прямой вызов `M.SendSignal` всё равно всегда эффективнее чем `Context.Default.SyncInvoke(M)`.\
Используйте выполнение маркеров внутри `.BeginInvoke` только если вам надо активировать его сразу после других очередей:
```
var M := new WaitMarker;

Context.Default.SyncInvoke(
  HFQ(()->5) + M
);
```
Но в этом же коде видно ещё одну проблему - сложение очередей возвращает последний результат,
то есть результат маркера (который `object(nil)`).

Если нужно иметь сразу и маркер и возвращаемое значение предыдущей очереди,
можно создать псевдо-маркер методом `.ThenWaitMarker`:
```
uses OpenCLABC;

begin
  var Q := HFQ(()->5).ThenWaitMarker;
  
  var t := Context.Default.BeginInvoke( WaitFor(Q) );
  Context.Default.SyncInvoke( Q ).Println;
  
  t.Wait;
end.
```
Псевдо-маркеры разлагаются в настоящие маркеры при передаче в `Wait` очереди,
но при этом сохраняют результат оригинальной очереди при выполнении в `.BeginInvoke`.

Точнее `Q` в последнем коде сначала выполнит `HFQ`, затем пошлёт сигнал в
`Wait` очередь `WaitFor(Q)` и в конце вернёт то, что вернула `HFQ`.

---

Есть всего 3 группы подпрограмм, создающих `Wait` очереди:

1. Глобальные, `WaitFor*`:\
   Ничего не делают сами, но блокируют выполнение ожидая сигналов указанных маркеров.
   
2. Особые методы `.Add*` - `.AddWait*`:\
   Как и `.AddQueue` и `.AddProc`, `.AddWait(...)` это всего лишь аналог
   `.AddQueue(WaitFor(...))`, существующий только ради простоты кода.
   
3. Методы очередей, `.ThenWaitFor*`:\
   Как и `.ThenWaitMarker`, сначала выполняет исходную очередь, потом ожидает и в конце возвращает результат исходной очереди.

В каждой из групп `Wait` очередей `*` можно заменить:
1. Ничем: Ожидание одной очереди.
2. На `All`: Ожидание всех указанных очередей.
3. На `Any`: Ожидание любой из указанных очередей (какая раньше выполнится).

То есть, к примеру, `WaitForAny` создаёт `Wait` очередь, которая сама ничего не выполняет, но ожидает сигнала от любого из указанных маркеров.

---
### `Wait` очереди между вызовами `Context.BeginInvoke`

`Wait` очереди работают даже между вызовами `Context.BeginInvoke`, в отличии от всего остального в `OpenCLABC`.

Это не всегда безопастно:
```
Context.Default.BeginInvoke(Q1);
Context.Default.BeginInvoke(WaitFor(Q1) + Q2);
```
Проблема этого кода в том, что `Q1` может послать сигнал ещё до того как `WaitFor(Q1)` начнёт ждать.

Чтоб такое не происходило - надо всегда запускать `Wait` очередь раньше маркера:
```
Context.Default.BeginInvoke(WaitFor(Q1) + Q2);
Context.Default.BeginInvoke(Q1);
```
Но, как всегда, лучше объединять вызовы `Context.BeginInvoke`:
```
Context.Default.BeginInvoke(
  ( Q1 ) *
  ( WaitFor(Q1) + Q2 )
);
```
Все `Wait` очереди начинают ждать в самом начале вызова `Context.BeginInvoke`, перед началом выполнения очереди.
Поэтому если `Wait` очередь и вызов её маркера находятся в общем `Context.BeginInvoke` - использовать их можно в любом порядке.

---
### Множественное ожидание одних и тех же маркеров

Все `Wait` очереди в одном `Context.BeginInvoke`, ожидающие один и тот же маркер, образуют общую `Wait` группу.\
Когда ожидаемый этой группой маркер активируется - он удаляет из `Wait` группы одну из `Wait` очередей, посылая ей сигнал.
```
## uses OpenCLABC;

var Q1 := HPQ(()->
begin
  Sleep(10);
  lock output do Writeln('Выполнилась Q1');
end).ThenWaitMarker;

var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));

var t1 := Context.Default.BeginInvoke(
  (WaitFor(Q1)+Q2) *
  (WaitFor(Q1)+Q3)
);
Context.Default.SyncInvoke(Q1+Q1);

// Все оставшиеся CLTask лучше ожидать, чтобы
// вывести ошибки, если возникнут при выполнении очереди
t1.Wait;
```
Тут `Q1` посылает 2 сигнала, сначала в первый `WaitFor(Q1)`, затем во второй.\
В данный момент не рекомендуется расчитывать на порядок `Wait` очередей в `Wait` группе.

Ну и, конечно, лучше совместить вызовы `Context.BeginInvoke`, раз контекст общий:
```
## uses OpenCLABC;

var Q1 := HPQ(()->
begin
  Sleep(10);
  lock output do Writeln('Выполнилась Q1');
end).ThenWaitMarker;

var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));

Context.Default.SyncInvoke(
  (Q1+Q1) *
  (WaitFor(Q1)+Q2) *
  (WaitFor(Q1)+Q3)
);
```
Будьте осторожны, лишняя `Wait` очередь вызовет зависание:
```
## uses OpenCLABC;

var Q1 := HFQ(()->0).ThenWaitMarker;

var t1 := Context.Default.BeginInvoke(
  WaitFor(Q1) +
  // Второй запуск Q1 никогда не произойдёт,
  // поэтому эта Wait очередь зависнет
  WaitFor(Q1)
);
Context.Default.SyncInvoke(Q1);

t1.Wait;
```

---

`Wait` очереди ожидающие один и тот же маркер в разных `Context.BeginInvoke` - образуют отдельные `Wait` группы.\
И при активации маркера - он посылает по 1 сигналу **каждой** `Wait` группе:
```
## uses OpenCLABC;

var Q1 := HPQ(()->
begin
  Sleep(1000);
  lock output do Writeln('Выполнилась Q1');
end).ThenWaitMarker;

var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));

var Q4 := HPQ(()->lock output do Writeln('Выполнилась Q4'));
var Q5 := HPQ(()->lock output do Writeln('Выполнилась Q5'));

var t1 := Context.Default.BeginInvoke(
  ( WaitFor(Q1)+Q2 ) *
  ( WaitFor(Q1)+Q3 )
);
var t2 := Context.Default.BeginInvoke(
  ( WaitFor(Q1)+Q4 ) *
  ( WaitFor(Q1)+Q5 )
);
// Каждый вызов Q1 тут - активирует по одному WaitFor(Q1) в каждом .BeginInvoke
Context.Default.SyncInvoke(Q1+Q1);

t1.Wait;
t2.Wait;
```


