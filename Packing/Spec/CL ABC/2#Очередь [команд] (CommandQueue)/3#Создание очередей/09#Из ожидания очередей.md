


Большинство деревьев выполнения очередей можно реализовать используя только сложение и умножение очередей. Но есть несколько проблем:

-  Большинство но не все. Пример дерева которое нельзя реализовать через сложение и умножение можно найти в файле:\
   C:\\PABCWork.NET\\Samples\\OpenGL и OpenCL\\OpenCLABC\\Wait очереди\\1.pas
   
-  Даже если дерево реализуется сложением+умножением - такая реализация может выглядеть запутано и не похоже на график дерева выполнения:\
   C:\\PABCWork.NET\\Samples\\OpenGL и OpenCL\\OpenCLABC\\Wait очереди\\2.pas
   
-  Очереди, выполняемые на разных контекстах не могут эффективно взаимодействовать.

Эти проблемы решают `Wait`-очереди:
```
uses OpenCLABC;

begin
  var M := new WaitMarker;
  
  var t := Context.Default.BeginInvoke(
    HPQ(()->Writeln('Начало .BeginInvoke')) +
    WaitFor(M) +
    HPQ(()->Writeln('Конец .BeginInvoke'))
  );
  
  Sleep(2000);
  Writeln('Посылаем сигнал маркера M');
  M.SendSignal;
  
  t.Wait;
end.
```
`WaitFor(M)` создаёт очень простую `Wait`-очередь.

Внутри вызова `.BeginInvoke` (до его завершения) эта очередь
входит в режим ожидания сигналов от маркера `M`.\
В этом режиме она **Не** тратит время процессора, но готова возобновить выполнение в любой момент.

Далее, вызов `M.SendSignal` посылает сигнал всем `Wait` очередям,
которые в данный момент находятся в режиме ожидания маркера `M`.

`WaitMarker`, так же, является своеобразной очередью, то есть
его можно складывать с другими очередями и передавать в `.BeginInvoke`

При выполнении в качестве очереди маркер вызывает свой метод `.SendSignal` и сразу возвращает `object(nil)`.\
То есть как очередь он равноценен `HPQ(M.SendSignal)`, но немного более эффективен.

Но стоит так же сказать, прямой вызов `M.SendSignal` всё равно всегда эффективнее чем `Context.Default.SyncInvoke(M)`.\
Используйте выполнение маркеров внутри `.BeginInvoke` только если вам надо активировать его сразу после других очередей:
```
  var M := new WaitMarker;
  
  Context.Default.SyncInvoke(
    HFQ(()->5) + M
  );
```
Но в этом же коде видно ещё одну проблему - сложение очередей возвращает последний результат,
то есть результат маркера (который `object(nil)`).

Если нужно иметь сразу и маркер и возвращаемое значение предыдущей очереди,
можно создать псевдо-маркер методом `.ThenWaitMarker`:
```
uses OpenCLABC;

begin
  var Q := HFQ(()->5).ThenWaitMarker;
  
  var t := Context.Default.BeginInvoke( WaitFor(Q) );
  Context.Default.SyncInvoke( Q ).Println;
  
  t.Wait;
end.
```
Псевдо-маркеры разлагаются в настоящие маркеры при передаче в `Wait` очереди,
но при этом сохраняют результат оригинальной очереди при выполнении в `.BeginInvoke`.

Точнее `Q` в последнем коде сначала выполнит `HFQ`, затем пошлёт сигнал в
`Wait` очередь `WaitFor(Q)` и в конце вернёт то, что вернула `HFQ`.

---

Есть всего 3 группы подпрограмм, создающих `Wait` очереди:

1. Глобальные, `WaitFor*`:\
   Ничего не делают сами, но блокируют выполнение ожидая сигналов указанных маркеров.
   
2. Особые методы `.Add*` - `.AddWait*`:\
   Как и `.AddQueue` и `.AddProc`, `.AddWait(...)` это всего лишь аналог
   `.AddQueue(WaitFor(...))`, существующий только ради простоты кода.
   
3. Методы очередей, `.ThenWaitFor*`:\
   Как и `.ThenWaitMarker`, сначала выполняет исходную очередь, потом ожидает и в конце возвращает результат исходной очереди.

В каждой из групп `Wait` очередей `*` можно заменить:
1. Ничем: Ожидание одной очереди.
2. На `All`: Ожидание всех указанных очередей.
3. На `Any`: Ожидание любой из указанных очередей (какая раньше выполнится).

То есть, к примеру, `WaitForAny` создаёт `Wait` очередь, которая сама ничего не выполняет, но ожидает сигнала от любого из указанных маркеров.

---
### `Wait` очереди между вызовами `Context.BeginInvoke`

`Wait` очереди работают даже между вызовами `Context.BeginInvoke`, в отличии от всего остального в `OpenCLABC`.

Это не всегда безопастно:
```
Context.Default.BeginInvoke(Q1);
Context.Default.BeginInvoke(WaitFor(Q1) + Q2);
```
Проблема этого кода в том, что `Q1` может послать сигнал ещё до того как `WaitFor(Q1)` начнёт ждать.

Чтоб такое не происходило - надо всегда запускать `Wait` очередь раньше маркера:
```
Context.Default.BeginInvoke(WaitFor(Q1) + Q2);
Context.Default.BeginInvoke(Q1);
```
Но, как всегда, лучше объединять вызовы `Context.BeginInvoke`:
```
Context.Default.BeginInvoke(
  ( Q1 ) *
  ( WaitFor(Q1) + Q2 )
);
```
Все `Wait` очереди начинают ждать в самом начале вызова `Context.BeginInvoke`, перед началом выполнения очереди.
Поэтому если `Wait` очередь и маркер находятся в общем `Context.BeginInvoke` - маркер никогда не активируется.

---
### Множественное ожидание одних и тех же маркеров

Когда начинает выполняться `Context.BeginInvoke` - для каждой `Wait` очереди в соответствующем маркере
создаётся новый счётчик для того, сколько раз маркер был активирован.

Поэтому можно делать так:
```
uses OpenCLABC;

begin
  var Q1 := HPQ(()->
  begin
    Sleep(10);
    lock output do Writeln('Выполнилась Q1');
  end).ThenWaitMarker;
  
  var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
  var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));
  
  var t1 := Context.Default.BeginInvoke(
    (WaitFor(Q1)+Q2) *
    (WaitFor(Q1)+Q3)
  );
  Context.Default.SyncInvoke(Q1+Q1);
  
  t1.Wait; // Чтобы вывести ошибки, если возникнут при выполнении
end.
```
Ну и, конечно, лучше совместить вызовы `Context.BeginInvoke`, раз контекст общий:
```
uses OpenCLABC;

begin
  var Q1 := HPQ(()->
  begin
    Sleep(10);
    lock output do Writeln('Выполнилась Q1');
  end).ThenWaitMarker;
  
  var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
  var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));
  
  Context.Default.SyncInvoke(
    (Q1+Q1) *
    (WaitFor(Q1)+Q2) *
    (WaitFor(Q1)+Q3)
  );
  
end.
```
Каждое окончание выполнения `Q1` добавляет 1 в счётчик внутри маркера.\
Каждое окончание ожидания `WaitFor(Q1)` отнимает 1 от того же счётчика.

Будьте осторожны, лишняя `Wait` очередь вызовет зависание:
```
uses OpenCLABC;

begin
  var Q1 := HFQ(()->0).ThenWaitMarker;
  
  var t1 := Context.Default.BeginInvoke(
    WaitFor(Q1) +
    WaitFor(Q1) // второй запуск Q1 никогда не произойдёт, поэтому это зависнет
  );
  Context.Default.SyncInvoke(Q1);
  
  t1.Wait;
end.
```

---

Cчётчик создаётся для каждой пары \[маркера\] и \[вызова `Context.BeginInvoke` с `Wait` очередью\].
То есть это тоже сработает:
```
uses OpenCLABC;

begin
  var Q1 := HPQ(()->
  begin
    Sleep(1000);
    lock output do Writeln('Выполнилась Q1');
  end).ThenWaitMarker;
  
  var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
  var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));
  
  var Q4 := HPQ(()->lock output do Writeln('Выполнилась Q4'));
  var Q5 := HPQ(()->lock output do Writeln('Выполнилась Q5'));
  
  var t1 := Context.Default.BeginInvoke(
    ( WaitFor(Q1)+Q2 ) *
    ( WaitFor(Q1)+Q3 )
  );
  var t2 := Context.Default.BeginInvoke(
    ( WaitFor(Q1)+Q4 ) *
    ( WaitFor(Q1)+Q5 )
  );
  // Каждый вызов Q1 тут - активирует по одному WaitFor(Q1) в каждом .BeginInvoke
  Context.Default.SyncInvoke(Q1+Q1);
  
  t1.Wait;
  t2.Wait;
end.
```
Но каждая активация маркера добавляет 1 в уже существующий счётчик:
```
uses OpenCLABC;

begin
  var Q1 := HPQ(()->
  begin
    Sleep(1000);
    lock output do Writeln('Выполнилась Q1');
  end).ThenWaitMarker;
  
  var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
  var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));
  
  var t := Context.Default.BeginInvoke(
    ( WaitFor(Q1)+Q2 ) *
    ( WaitFor(Q1)+Q3 )
  );
  Q1.SendSignal;
  Context.Default.SyncInvoke(Q1);
  
  t.Wait;
end.
```


