


Самый просто способ создать очередь — выбрать объект, имеющий методы, соответствующие командам для GPU, и вызвав его метод `.NewQueue`.

Полученная очередь будет иметь особый тип, с припиской CCQ (что значит "Command Container Queue", то есть очередь-контейнер для коман GPU).\
К примеру, метод `CLArray<byte>.NewQueue` вернёт очередь типа `CLArrayCCQ<byte>`.\
К такой очереди можно добавлять команды, вызывая её методы, имена которых начинаются с `.Add`.

К примеру:
```
## uses OpenCLABC;

// Массив на 3 элемента типа integer
var a := new CLArray<integer>(3);

// Создаём очередь
var q: CLArrayCCQ<integer> := a.NewQueue;

// Добавлять команды в полученную очередь можно вызывая соответствующие методы
q.AddWriteItem(1, 0);

// .Add методы возвращают очередь, для которой их вызвали
// (не копию, а именно ссылку на оригинал)
// Поэтому можно добавлять по несколько команд в 1 строчке:
q.AddWriteItem(5, 1).AddWriteItem(7, 2);
// Все команды в q будут выполняться в порядке их добавления

// .AddGet методы особенные, потому что они возвращают новую очередь
// В данном случае эта очередь читает весь CLArray как обычный массив на CPU
// .SyncInvoke возвращает то, что вернула последняя очередь
// А .Println сразу выводит полученный массив
Context.Default.SyncInvoke(q.AddGetArray).Println;
```

Также, `CCQ` очереди можно создавать из очередей, возвращающих объект с командами. Для этого используется конструктор:
```
var q0: CommandQueue<MemorySegment>;
...
var q := new MemorySegmentCCQ(q0);
```

---

Команды объектов, представляющих память на GPU можно разделить на группы.

По направлению передачи:
1. `Write` и `Fill`: Из RAM в память GPU;
2. `Read`: Из памяти GPU в RAM;
3. `Copy`: Между двумя областями памяти GPU.
4. `Get`: Как `Read`, но вместо использования существующей памяти RAM, выделяется новая.

И по типу данных на стороне RAM:
1. `Data`: Используются данные, находящиеся по указанному адресу;
2. `Value`: Используется копия указанного размерного значения;
3. `Array`: Используется содержимое указанного массива размерных значений.

Но при этом отсутствуют некоторые комбинации.

В первую очередь, в случае `Copy` нет понятия типа данных на стороне RAM, потому что RAM в принципе не задействуется.

Так же нет `ReadValue`, потому что нет смысла читать в копию указанного значения.\
Вместо него надо использовать `GetValue` - создающее и возвращающее новое размерное значение.\
Или `ReadData`, передавая адрес значения, которое надо перезаписать - но с этим надо осторожно, как и в случае <a path="../../Простые обёртки/Kernel/KernelArg"> `KernelArg` </a>.


