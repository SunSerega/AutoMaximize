


Самый простой способ выполнить очередь - вызывы метод `Context.SyncInvoke`.\
Он синхронно выполняет очередь и вызвращает её результат.

Но если надо выполнить очередь асинхронно - лучше использовать метод `Context.BeginInvoke`.\
Он завершает выполнятся как только очередь была полностью запущена и возвращает объект типа `CLTask<>`, через который можно:
- Ожидать пока выполнение не закончится методом `CLTask<>.Wait`.
- Ожидать пока выполнение не закончится и сразу получить возвращаемое значение, методом `CLTask<>.GetRes`.

Метод `Context.SyncInvoke` реализован через `.BeginInvoke(...).GetRes`. Поэтому, если далее в справке сказано "... происходит при вызове `.BeginInvoke`" - это же относится и к `.SyncInvoke`.

У `CLTask` как и у очереди - в `<>` указывается тип возвращаемого значения. То есть:
```pas
var t: CLTask<integer>;
```
В такую переменную можно сохранить только результат `Context.BeginInvoke` для очереди типа `CommandQueue<integer>`.

Если при выполнении возникла ошибку, о ней выведет не полную информацию. Чтобы получить всю информацию - используется `try`{ .language-pas }:
```pas
try
  
  //ToDo ваш код, вызывающий ошибку
  
except
  // Writeln выводит все внутренние исключения. "e.ToString" тоже.
  on e: Exception do Writeln(e);
end;
```
Для этого кода есть стандартный снипет. Чтоб активировать его - напишите `tryo` и нажмите Shift+Пробел.


