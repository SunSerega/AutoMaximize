


Передавать команды по одной, когда их несколько - ужасно медленно!\
Но нередко бывает так, что команда всего одна. Или для отладки надо одноразово выполнить одну команду.

Для таких случаев можно создавать очередь неявно:\
У каждого `.Add*` метода есть дублирующий метод в оригинальном объекте. Такие методы сами создают
новую очередь, добавляют в неё одну соответствующую команду и выполняют полученную очередь в `Context.Default.SyncInvoke(...)`.

Обычный код с очередями:
```
uses OpenCLABC;

begin
  var b := new Buffer( 3*sizeof(integer) );
  var A := new integer[3];
  
  var Q_BuffWrite :=
    ( b.NewQueue.AddWriteValue(1, 0*sizeof(integer) ) as CommandQueue<Buffer> ) *
    ( b.NewQueue.AddWriteValue(5, 1*sizeof(integer) ) as CommandQueue<Buffer> ) *
    ( b.NewQueue.AddWriteValue(7, 2*sizeof(integer) ) as CommandQueue<Buffer> )
  ;
  
  var Q_BuffRead := b.NewQueue.AddReadArray(A) as CommandQueue<Buffer>;
  
  var Q_Otp := HPQ(()->
  begin
    A.Println;
  end);
  
  Context.Default.SyncInvoke(
    Q_BuffWrite +
    Q_BuffRead +
    Q_Otp
  );
  
end.
```
Он же, но с неявными очередями:
```
uses OpenCLABC;

begin
  var b := new Buffer( 3*sizeof(integer) );
  var A := new integer[3];
  
  // Аналог Q_BuffWrite
  System.Threading.Tasks.Parallel.Invoke(
    ()->b.WriteValue(1, 0*sizeof(integer) ),
    ()->b.WriteValue(5, 1*sizeof(integer) ),
    ()->b.WriteValue(7, 2*sizeof(integer) )
  );
  
  // Аналог Q_BuffRead
  b.ReadArray(A);
  
  // Аналог Q_Otp
  A.Println;
  
end.
```

Кроме того, у типа `Buffer` есть дополнительные методы `Buffer.Get*`.
Соответствующих методов у очередей — нет (`ToDo` возможно, в будущем появятся).

Методы `.Get*` создают новый объект типа записи, массива или выделяют область неуправляемой памяти,
читают в полученный объект содержимое буфера и возвращают этот объект.
Они также используют неявную очередь (для чтения буфера).


