


Одну и ту же очередь можно использовать несколько раз, в том числе одновременно:
```
uses OpenCLABC;

begin
  var Q := HPQ(()->lock output do Writeln('Q выполнилась'));
  
  var t1 := Context.Default.BeginInvoke(Q);
  var t2 := Context.Default.BeginInvoke(Q*Q);
  
  t1.Wait;
  t2.Wait;
end.
```
Но эта программа выведет "Q выполнилась" три раза, потому что при каждом упоминании - Q запускается ещё раз.

Это не всегда хорошо. К примеру, может быть так что `Q` содержит какой то затратный алгоритм. Или ввод значения с клавиатуры:
```
uses OpenCLABC;

begin
  var Q := HFQ(()->
  begin
    lock input do
      Result := ReadInteger;
  end);
  
  Context.Default.SyncInvoke(CombineAsyncQueue(
    res->res,
    Q,
    Q.ThenConvert(i->i*i),
    Q.ThenConvert(i->i*i*i)
  )).Println;
  
end.
```
Эта программа запросит три разных значения, что не всегда то что надо.

Чтоб использовать результат одной очереди несколько раз - используется `.Multiusable`:
```
uses OpenCLABC;

begin
  var Q := HFQ(()->
  begin
    lock input do
      Result := ReadInteger;
  end);
  
  var Qs := Q.Multiusable;
  
  Context.Default.SyncInvoke(CombineAsyncQueue(
    res->res,
    Qs(),
    Qs().ThenConvert(i->i*i),
    Qs().ThenConvert(i->i*i*i)
  )).Println;
  
end.
```
`.Multiusable` создаёт новую функцию, вызывая которую можно получить любое количество очередей,
у которых будет общий результат.

Каждый вызов `.Multiusable` создаёт именно новую функцию.\
Это значит, что если использовать результаты двух вызовов `.Multiusable` - исходная очередь выполнится два раза.

`.Multiusable` не работает между вызовами `Context.BeginInvoke`,
потому что каждый следующий `Context.BeginInvoke` может быть вызван на новом объекте типа `Context`:
```
uses OpenCLABC;

begin
  var Q := HFQ(()->
  begin
    lock input do
      Result := ReadInteger;
  end);
  
  var Qs := Q.Multiusable;
  
  Context.Default.SyncInvoke( Qs()                      ).Println;
  Context.Default.SyncInvoke( Qs().ThenConvert(i->i*i)  ).Println;
  
end.
```
Эта программа запросит ввод два раза.

Если контекст у двух очередей общий - лучше объединить вызовы `Context.BeginInvoke`.
Так не только `.Multiusable` будет работать, но и выполнение будет в целом быстрее.

А если контекст разный - надо сохранять результат в переменную и использовать `Wait` очереди
(<a path="Из ожидания очередей">подробнее на странице ниже</a>).


