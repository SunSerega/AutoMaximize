


Есть всего 3 группы подпрограмм, создающих очереди для ожидания других очередей:

1. Глобальные, `WaitFor*`:\
	Ничего не делают сами, но блокируют выполнение пока указанные очереди не выполнятся.
	
2. Особые методы `.Add*` - `.AddWait*`:\
	Как и `.AddQueue` и `.AddProc`, `.AddWait(...)` это всего лишь аналог
	`.AddQueue(WaitFor(...))`, существующий только ради простоты кода.
	
3. Методы очередей, `.ThenWaitFor*`:\
	Так же не имеет незаменимых применений, но ещё полезнее.\
	`Q.ThenWaitFor(...)` работает как `Q + WaitFor(...)`, за исключением того, что возвращает результат `Q`.\
	То есть, правильнее будет:
	```
	var Qs := Q.Multiusable;
	Result := Qs() + WaitFor(...) + Qs();
	```
	Но это уже даже в одну строчку не напишешь.
	
В каждой из групп Wait очередей - `*` можно заменить:
1. Ничем: Ожидание одной очереди.
2. На `All`: Ожидание всех указанных очередей.
3. На `Any`: Ожидание любой из указанных очередей (какая раньше выполнится).

То есть, к примеру, `WaitForAny` создаёт очередь, которая сама ничего не выполняет, но ожидает выполнения любой из указанных очередей.

---

`Wait` очереди делают реализацию некоторых сложных деревьев выполнения очередей возможными.\
Примеры можно найти в папке `PABCWork.NET\Samples\OpenCLABC\Wait очереди`.

Но они наиболее полезны благодаря одному особенному свойству:\
`Wait` очереди работают даже между вызовами `Context.BeginInvoke`, в отличии от всего остального в `OpenCLABC`.

Это не всегда безопастно:
```
Context.Default.BeginInvoke(Q1);
Context.Default.BeginInvoke(WaitFor(Q1) + Q2);
```
Проблема этого кода в том, что `Q1` может закончить выполнятся ещё до того как `WaitFor(Q1)` начнёт ожидать.

Чтоб такое не происходило - надо всегда запускать ожидаемую очередь
в том же или, хотя бы, следующем вызове `Context.BeginInvoke` что и ожидающая:
```
Context.Default.BeginInvoke(WaitFor(Q1) + Q2);
Context.Default.BeginInvoke(Q1);
```
Но, как всегда, лучше, по возможности, объединять вызовы `Context.BeginInvoke`:
```
Context.Default.BeginInvoke(
  ( Q1 ) *
  ( WaitFor(Q1) + Q2 )
);
```
Если ожидаемая и ожидающая очереди находятся в общем `Context.BeginInvoke` - не важно в каком порядке они написаны.
`OpenCLABC` гарантирует что ожидающие очереди начнут ожидать до начала выполнения ожидаемых.

---
### Множественное ожидание несколько раз выполнившейся очереди

Когда начинает выполняться `Context.BeginInvoke` - для каждой ожидающей очереди в соответствующей
ожидаемой очереди создаётся новый счётчик для того, сколько раз ожидаемая очередь была выполнена.

Поэтому можно делать так:
```
uses OpenCLABC;

begin
  var Q1 := HPQ(()->
  begin
    Sleep(200);
    lock output do Writeln('Выполнилась Q1');
  end);
  
  var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
  var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));
  
  var t1 := Context.Default.BeginInvoke(
    (WaitFor(Q1)+Q2) *
    (WaitFor(Q1)+Q3)
  );
  Context.Default.BeginInvoke(Q1+Q1);
  
  t1.Wait;
end.
```
Ну и, конечно, лучше совместить вызовы `Context.BeginInvoke`, раз контекст общий:
```
uses OpenCLABC;

begin
  var Q1 := HPQ(()->
  begin
    Sleep(200);
    lock output do Writeln('Выполнилась Q1');
  end);
  
  var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
  var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));
  
  Context.Default.SyncInvoke(
    (Q1+Q1) *
    (WaitFor(Q1)+Q2) *
    (WaitFor(Q1)+Q3)
  );
  
end.
```
Каждое окончание выполнения `Q1` добавляет 1 в счётчик внутри `Q1`.\
Каждое окончание ожидания `WaitFor(Q1)` отнимание 1 от того же счётчика.

Будьте осторожны, лишняя `Wait` очередь вызовет зависание:
```
uses OpenCLABC;

begin
  var Q1 := HFQ(()->0);
  
  var t1 := Context.Default.BeginInvoke(
    WaitFor(Q1) +
    WaitFor(Q1) // второй запуск Q1 никогда не произойдёт, поэтому это зависнет
  );
  Context.Default.BeginInvoke(Q1);
  
  t1.Wait;
end.
```

---

Cчётчик создаётся для каждой пары [ожидаемой очереди] и [вызова `Context.BeginInvoke` с ожидающей очередью].
То есть это тоже сработает:
```
uses OpenCLABC;

begin
  var Q1 := HPQ(()->
  begin
    Sleep(200);
    lock output do Writeln('Выполнилась Q1');
  end);
  
  var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
  var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));
  
  var Q4 := HPQ(()->lock output do Writeln('Выполнилась Q4'));
  var Q5 := HPQ(()->lock output do Writeln('Выполнилась Q5'));
  
  var t1 := Context.Default.BeginInvoke(
    (WaitFor(Q1)+Q2) *
    (WaitFor(Q1)+Q3)
  );
  var t2 := Context.Default.BeginInvoke(
    (WaitFor(Q1)+Q4) *
    (WaitFor(Q1)+Q5)
  );
  Context.Default.BeginInvoke(Q1+Q1);
  
  t1.Wait;
  t2.Wait;
end.
```
Но каждый `Context.BeginInvoke` для ожидаемой очереди - добавляет в уже существующий счётчик:
```
uses OpenCLABC;

begin
  var Q1 := HPQ(()->
  begin
    Sleep(200);
    lock output do Writeln('Выполнилась Q1');
  end);
  
  var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
  var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));
  
  var t1 := Context.Default.BeginInvoke(
    (WaitFor(Q1)+Q2) *
    (WaitFor(Q1)+Q3)
  );
  Context.Default.BeginInvoke(WaitFor(Q1)+Q1);
  Context.Default.BeginInvoke(Q1);
  
  t1.Wait;
end.
```


