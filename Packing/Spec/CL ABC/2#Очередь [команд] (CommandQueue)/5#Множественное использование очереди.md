


# `ToDo` эта страница будет переделана и перенесена на страницу создания очередей, потому что необходимость в .Clone скоро отпадёт и большинство текста тут станет устаревшим

```
// 3.4.0
// 
// Одну и ту же очередь можно использовать несколько раз:
// <------------------------->
// var Q1: CommandQueue<...>;
// ...
// Context.Default.SyncInvoke(Q1);
// Context.Default.SyncInvoke(Q1);
// <------------------------->
// 
// Однако, во время выполнения очередь хранит в себе данные о своём состоянии выполнения и результат, когда он уже вычислен
// Это значит, что 1 объект очереди нельзя выполнять в 2 местах параллельно
// Иначе данные о состоянии и результате двух выполнений перемешаются
// То есть, такой код:
// <------------------------->
// var Q1: CommandQueue<...>;
// ...
// Context.Default.SyncInvoke( Q1 * Q1 );
// <------------------------->
// Приведёт к вызову исключения QueueDoubleInvokeException
// 
// Однако, если вам всё же надо использовать одну очередь в нескольких местах одновременно - есть 2 способа:

// 3.4.1 — Клонирование очередей (.Clone)
// 
// Методом .Clone можно создать полную копию очереди
// При этом, если исходная очередь проводила какие то вычисления,
// они будут произведены дважды, оригиналом и копией, при вызове обоих
// 
// Клон очереди является полностью независимым объектом
// Его можно вызывать не только параллельно с оригиналом
// Оригинал и копию можно вызывать даже в двух разных Context.BeginInvoke одновременно
// 

// 3.4.2 — Удлинители для очередей (.Multiusable)
// 
// Вариант выполнять очередь несколько раз, как в случае с .Clone, нередко не подходит,
// потому что это удваивает затраты производительности
// И некоторые очереди (например, выполнения kernel'ов) могут дать разные результаты, если выполнить их лишний раз
// 
// Если вам нужно использовать результат одной очереди многократно, лучше использовать метод .Multiusable
// !! Созданные таким образом очереди НЕ является независимыми объектами !!
// 
// .Multiusable работает словно провод-удлинитель,
// если сравнивать возвращаемое значение очереди с розеткой
// 
// Исходная очередь, для которой вызвали .Multiusable начинает выполняться сразу при вызове Context.BeginInvoke,
// Если хотя бы 1 из очередей, которую вернул метод .Multiusable была использована в этом Context.BeginInvoke
// 
// Очереди, которые вернул .Multiusable могут быть использованы параллельно:
// <------------------------->
// var Q1: CommandQueue<...>;
// ...
// Qs1 := Q1.Multiusable(3); // создаёт массив из 3 очередей
// Context.Default.SyncInvoke( Qs1[0] * Qs1[1] * Qs1[2].ThenConvert(o->...) );
// <------------------------->
// Однако, все очереди, полученные из .Multiusable всё ещё связаны оригинальной очередью
// А так как Context.BeginInvoke управляет переключением состояния выполнения очереди
// Следующий код попытается два раза запустить очередь Q1:
// <------------------------->
// var Q1: CommandQueue<...>;
// ...
// Qs1 := Q1.Multiusable(2);
// Context.Default.BeginInvoke( Qs1[0] );
// Context.Default.BeginInvoke( Qs1[1] );
// <------------------------->
// А т.к. это запрещено - будет вызвано исключение QueueDoubleInvokeException
// Чтобы исправить такой код - надо объеденить вызовы метода Context.BeginInvoke
// 
```


