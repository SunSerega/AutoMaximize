


У каждого типа-очереди есть свой тип возвращаемого значение.\
К примеру, так объявляется переменная в которую можно будет сохранить очередь, возвращающую `integer`:
```pas
var Q1: CommandQueue<integer>;
```

Очереди, созданные из буфера или kernel-а возващают свой `Buffer`/`Kernel` соответственно, из которого были созданы;\
Очереди, созданные с `HFQ` - значение, которое вернёт переданная функция;\
Очереди, созданные с `HPQ` - значение типа `object` (и всегда `nil`).

К примеру:
```pas
uses OpenCLABC;

/// Вывод типа и значения объекта
procedure OtpObject(o: object) :=
Writeln( $'{o?.GetType}[{_ObjectToString(o)}]' );
// "o?.GetType" это короткая форма "o=nil ? nil : o.GetType", то есть берём или тип объекта, или nil если сам объект nil
// _ObjectToString это функция, которую использует Writeln для форматирования значений

begin
  var b0 := new Buffer(1);
  
  // Тип - буфер, потому что очередь создали из буфера
  OtpObject(  Context.Default.SyncInvoke( b0.NewQueue as CommandQueue<Buffer>   )  );
  
  // Тип - Int32 (то есть integer), потому что это тип по-умолчанию для выражения (5)
  OtpObject(  Context.Default.SyncInvoke( HFQ( ()->5                          ) )  );
  
  // Тип - string, по той же причине
  OtpObject(  Context.Default.SyncInvoke( HFQ( ()->'abc'                      ) )  );
  
  // Тип отсутствует, потому что HPQ возвращает nil
  OtpObject(  Context.Default.SyncInvoke( HPQ( ()->Writeln('Выполнилась HPQ') ) )  );
  
end.
```

После выполнения очереди метод `Context.SyncInvoke` возвращает то, что вернула очередь.\
А если использовать метод `Context.BeginInvoke` - возвращаемое значение можно получить с помощью метода `CLTask.GetRes`.

---



Бывает необходимо хранить несколько очередей, с разными возвращаемыми значениями,
вместе, к примеру, в переменной типа `List<>`.\
Однако в переменной типа `CommandQueue<SomeT>` можно хранить только очередь с конкретным типом `SomeT`.

Для того чтоб хранить очереди с любым возвращаемым значением в 1 переменной - надо использовать `CommandQueueBase`.\
`CommandQueueBase` это особый тип очереди, у которого не указывается возвращаемое значение.\
От него наследует `CommandQueue<>`, поэтому переменной типа `CommandQueueBase` можно присвоить любую очередь.

Если попытаться выполнить такую очередь в `Context.[Begin,Sync]Invoke`,
или применять операции преобразования очередей, как `.ThenConvert`,
то тип возвращаемого значения будет восприниматься как `Object`.


