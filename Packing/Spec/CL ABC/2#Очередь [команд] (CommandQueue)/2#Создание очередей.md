


Есть всего 7 базовых способов создать очередь:

<ol>
<li>

:::spoiler { summary="Из буфера/kernel-а" hidden=true }

Самый просто способ создать очередь — выбрать объект типа `Buffer` или `Kernel` и вызвать для него метод `.NewQueue`.

Полученная очередь будет иметь особый тип: `BufferCommandQueue`/`KernelCommandQueue` для буфера/kernel'а соответственно.\
К такой очереди можно добавлять команды, вызывая её методы, имена которых начинаются с `.Add...`.

К примеру:
```
uses OpenCLABC;

begin
  // Буфер достаточного размера чтоб содержать 3 значения типа integer
  var b := new Buffer( 3*sizeof(integer) );
  
  // Создаём очередь
  var q := b.NewQueue;
  
  // Добавлять команды в полученную очередь можно вызывая соответствующие методы
  q.AddWriteValue(1, 0*sizeof(integer) );
  
  // Методы, добавляющие команду в очередь - возвращают очередь, для которой их вызвали (не копию а ссылку на оригинал)
  // Поэтому можно добавлять по несколько команд в 1 строчке:
  q.AddWriteValue(5, 1*sizeof(integer) ).AddWriteValue(7, 2*sizeof(integer) );
  // Все команды в q будут выполнятся последовательно, что не всегда хорошо
  // Если надо выполнять параллельно - создавайте несколько "b.NewQueue" и умножайте друг на друга
  
  // В данной версии надо писать "as CommandQueue<...>" при использовании [Buffer/Kernel]CommandQueue там,
  // где принимает CommandQueue<...>, из за бага компилятора #1981
  Context.Default.SyncInvoke(q as CommandQueue<Buffer>);
  
  // Вообще чтение тоже надо делать через очереди, но для простого примера - и неявные очереди подходят
  b.GetArray1&<integer>(3).Println;
  
end.
```

Так же, очереди `BufferCommandQueue`/`KernelCommandQueue` можно создавать из очередей, возвращающих `Buffer`/`Kernel` соответственно. Для этого используется конструктор:
```
var q0: CommandQueue<Buffer>;
...
var q := new BufferCommandQueue(q0);
```

:::
</li><li>

:::spoiler { summary="Из возвращаемого значения" hidden=true }

Переменной очереди можно присвоить значение, тип которого совпадает с возвращаемым значением очереди:
```
var q: CommandQueue<integer> := 5;
```
Этот код присваевает переменной `q` константную очередь, которая ничего не выполняет и возвращает `5`.

Получить значение, из которого создали константную очередь, можно преобразовав её к `ConstQueue<>`:
```
var cq := q as ConstQueue<integer>;
if cq=nil then
  Writeln('Очередь не константная') else
  Writeln($'Очередь была создана из значения {cq.Val}');
```

`CommandQueueBase` так же можно создать из значения, но для этого - тип значения должен быть `Object`:
```
var q: CommandQueueBase := 5 as object;
```

Чтоб получить значение, из которого создали константную очередь, когда не знаете его тип - используйте интерфейс `IConstQueue`:
```
var cq := q as IConstQueue;
if cq=nil then
  Writeln('Очередь не константная') else
  Writeln($'Очередь была создана из значения ({cq.GetConstVal})');
```

:::
</li><li>

:::spoiler { summary="Из обычной подпрограммы" hidden=true }

Иногда между командами для GPU надо вставить выполнение обычного кода на CPU.
А разрывать для этого очередь на две части - плохо, потому что
одна целая очередь всегда выполнится быстрее двух её частей.

Для таких случае существуют глобальные подпрограммы HFQ и HPQ:

HFQ — Host Function Queue\
HPQ — Host Procedure Queue\
(Хост в контексте OpenCL - это CPU, потому что с него посылаются команды для GPU)

Они возвращают очередь, выполняющую код (функцию/процедуру соотвественно) на CPU.\
Подробнее уже описано
<a path="Возвращаемое значение очередей">
на предыдущей странице
</a>
.

:::
</li><li>

:::spoiler { summary="Из нескольких других очередей" hidden=true }

Если сложить две очереди A и B (`var C := A+B`) — получится очередь C, в которой сначала выполнится A, а затем B.\
Очередь C будет считаться выполненной тогда, когда выполнится очередь B.

Если умножить две очереди A и B (`var C := A*B`) — получится очередь C, в которой одновременно начнут выполняться A и B.\
Очередь C будет считаться выполненной тогда, когда обе очереди (A и B) выполнятся.

Как и в математике, умножение имеет бОльший приоритет чем сложение.

В обоих случаях очередь C будет возвращать то, что вернула очередь B. То есть если складывать и умножать много очередей - результат будет всегда возвращать то, что вернула самая последняя очередь.

Простейший пример:
```
uses OpenCLABC;

begin
  
  var q1 := HPQ(()->
  begin
    // lock надо чтоб при параллельном выполнении два потока не пытались использовать вывод одновременно. Иначе выведет кашу
    lock output do Writeln('Очередь 1 начала выполняться');
    Sleep(500);
    lock output do Writeln('Очередь 1 закончила выполняться');
  end);
  var q2 := HPQ(()->
  begin
    lock output do Writeln('Очередь 2 начала выполняться');
    Sleep(500);
    lock output do Writeln('Очередь 2 закончила выполняться');
  end);
  
  Writeln('Последовательное выполнение:');
  Context.Default.SyncInvoke( q1 + q2 );
  
  Writeln;
  Writeln('Параллельное выполнение:');
  Context.Default.SyncInvoke( q1 * q2 );
  
end.
```

Операторы += и \*= также применимы к очередям.\
И как и для чисел - `A += B` работает как `A := A+B` (и так же с \*=).\
А значит возвращаемые типы очередей A и B должны быть одинаковыми, чтобы к ним можно было применить +=/*=.

Если надо сложить/умножить много очередей - лучше применять `CombineSyncQueue`/`CombineAsyncQueue` соответственно.\
Эти подпрограммы работают немного быстрее чем сложение и умножение, если объединять больше двух очередей.

Кроме того они так же могут принимать ещё 1 параметр перед очередями:
Этот параметр позволяет указать функцию преобразования, которая использует результаты всех входных очередей:
```
uses OpenCLABC;

begin
  
  var q1 := HFQ( ()->1 );
  var q2 := HFQ( ()->2 );
  
  // Выводит 2, то есть только результат последней очереди
  // Так сделано из за вопросов производительности
  Context.Default.SyncInvoke( q1+q2 ).Println;
  // Однако всё же бывает так, что нужны результаты всех сложенных/умноженных очередей
  
  // В таком случае надо использовать CombineSyncQueue и CombineAsyncQueue
  // А точнее их перегрузку, первый параметр которой - функция преобразования
  Context.Default.SyncInvoke(
    CombineSyncQueue(
      results->results.JoinIntoString, // функция преобразования
      q1, q2
    )
  ).Println;
  // Теперь выводит строку "1 2". Это то же самое что вернёт "Arr(1,2).JoinIntoString"
  
end.
```

:::
</li><li>

:::spoiler { summary="Из очереди + преобразования результата" hidden=true }

Если надо с минимальными затратами изменить представление компилятора об очереди - лучше всего использовать `.Cast`.\
Но он ограничен примерно так же, как метод последовательностей `.Cast`. То есть:
```
type t1 = class ... end;
type t2 = class(t1) ... end;
...
var Q1: CommandQueue<integer> := 5;
var Q2: CommandQueueBase := Q1;
var Q3: CommandQueue<t1> := (new t2) as t1;
var Q4: CommandQueue<t1> := new t1;
var Q5: CommandQueue<t2> := new t2;

// Можно, потому что к object можно преобразовать всё
Context.Default.SyncInvoke( Q1.Cast&<object> );

// Нельзя, преобразование из integer в byte - изменяет внутреннее представление данных
Context.Default.SyncInvoke( Q1.Cast&<byte> );

// Можно, Q2 и так имеет тип CommandQueue<integer>, а значит тут Cast вернёт (Q2 as CommandQueue<integer>)
Context.Default.SyncInvoke( Q2.Cast&<integer> );

// Можно, потому что Q3 возвращает t2
Context.Default.SyncInvoke( Q3.Cast&<t2> );

// Нельзя, Q4 возвращает не t2 а t1, поэтому к t2 преобразовать не получится
Context.Default.SyncInvoke( Q4.Cast&<t2> );

// Можно, потому что t2 наследует от t1
Context.Default.SyncInvoke( Q5.Cast&<t1> );
```

Ну а если эти ограничения не подходят - остаётся только `.ThenConvert`. Он позволяет указать любой алгоритм преобразования, но и требует бОльшей производительности:
```
uses OpenCLABC;

begin
  var q := HFQ(()->123);
  
  Context.Default.SyncInvoke(
    q.ThenConvert(i -> i*2 )
  ).Println;
  
end.
```

:::
</li><li>

:::spoiler { summary="Из повторения очереди" hidden=true }

~~В данный момент всё ещё не работает... Но уже совсем скоро, правда правда!~~

:::
</li><li>

:::spoiler { summary="Не создавая явно" hidden=true }

Передавать команды по одной, когда их несколько - ужасно медленно!\
Но нередко бывает так, что команда всего одна. Или для отладки надо одноразово выполнить одну команду.

Для таких случаев можно создавать очередь неявно:\
У каждого метода очереди, создаваемой с `.NewQueue` есть дублирующий метод в оригинальном объекте.\
Такие методы сами создают новую очередь, добавляют в неё одну соответствующую команду и выполняют полученную очередь в `Context.Default.SyncInvoke(...)`.

Следующий пример сравнивает явные и неявные очереди:
```
uses OpenCLABC;

begin
  
  var b := new Buffer( 3*sizeof(integer) );
  var A := new integer[3];
  
  // Код с очередями
  
  var Q_BuffWrite :=
    ( b.NewQueue.AddWriteValue(1, 0*sizeof(integer) ) as CommandQueue<Buffer> ) *
    ( b.NewQueue.AddWriteValue(5, 1*sizeof(integer) ) as CommandQueue<Buffer> ) *
    ( b.NewQueue.AddWriteValue(7, 2*sizeof(integer) ) as CommandQueue<Buffer> )
  ;
  
  var Q_BuffRead := b.NewQueue.AddReadArray(A) as CommandQueue<Buffer>;
  
  var Q_Otp := HPQ(()->
  begin
    A.Println;
  end);
  
  Context.Default.SyncInvoke(
    Q_BuffWrite +
    Q_BuffRead +
    Q_Otp
  );
  
  // Этот же код ещё раз, но без явных очередей
  // Неявно - каждый метод .Write*** и .Read*** всё равно создаёт по очереди
  // Такая запись короче, но выполняется медленнее
  
  // Аналог Q_BuffWrite
  System.Threading.Tasks.Parallel.Invoke(
    ()->b.WriteValue(1, 0*sizeof(integer) ),
    ()->b.WriteValue(5, 1*sizeof(integer) ),
    ()->b.WriteValue(7, 2*sizeof(integer) )
  );
  
  // Аналог Q_BuffRead
  b.ReadArray(A);
  
  // Аналог Q_Otp
  A.Println;
  
end.
```
Кроме того, у типа `Buffer` есть дополнительные методы `Buffer.Get...`.
Соответствующих методов у очередей — нет (`ToDo` возможно, в будущем появятся).\
Методы `.Get...` создают новый объект типа записи, массива или выделяют область неуправляемой памяти,
читают в полученный объект содержимое буфера и возвращают этот объект.
Они также используют неявную очередь (для чтения буфера).

:::

</li>
</ol>


