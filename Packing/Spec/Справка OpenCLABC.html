<html>
<head>
<meta charset="utf-8">
<style>
/* ============================== *\
			 page base
\* ============================== */

body {
	background-color: #F0F0F0;
	margin: 0px;
}

.page-base {
	position: absolute;
}

#splitter {
	width: 5px;
	cursor: col-resize;
	box-shadow: 0 0 4px #B0B0B0;
}

.page-container {
	margin: 7.5px;
	background-color: white;
	overflow: auto;
}
#page-select-container {
	white-space: nowrap;
}

#page-display-container-body {
	padding: 7px;
	width: fit-content;
}

/* ============================== *\
		    page select
\* ============================== */

.clickable-span {
	cursor: pointer;
}
.dot-page-root {
	cursor: default;
	margin-left: 5px;
	margin-right: 6px;
}

.ps-root-container {
	margin: 7px;
}

.ps-folder {
	display: table;
}

.ps-container {
	margin-left: 7;
	padding-left: 7;
	border-left: thin solid;
	border-color: #80808080;
}

.ps-page {
	cursor: pointer;
}

/* ============================== *\
	       page display
\* ============================== */

.smart-link {
	color: blue;
	cursor: pointer;
}

.spoiler {
	margin-left: 8px;
}
.spoiler-wrap {
	border-left: thin solid;
	padding-left: 2px;
}

.code-block {
	display: inline-block;
	cursor: text;
	background: #F0F0F0;
	border-radius: 3px;
	
	padding: 4px;
	padding-right: 12px;
	
	margin: 0;
	
}
.inline-code {
	background: #F0F0F0;
}

.code-keyword {
	font-weight: bold;
}
.code-build-in {
	color: blue;
}
.code-red {
	color: red;
	font-weight: bold;
}
.code-glowing-bracket {
	color: red;
	background-color: #C0C0C0;
}
</style>
</head>
<body>
<div class="page-base" id="page-select">
	<div class="page-container" id="page-select-container"></div>
</div>
<div class="page-base" id="page-display">
	<div class="page-container" id="page-display-container">
		<div id="page-display-container-body"></div>
	</div>
</div>
<div class="page-base" id="splitter"></div>
<script>
/* ============================== *\
		   on page load
\* ============================== */

{
	
	let page_select = document.getElementById("page-select");
	let page_display = document.getElementById("page-display");
	let splitter = document.getElementById("splitter");
	
	let ww = window.innerWidth;
	let wh = window.innerHeight;
	
	for (let cont of document.getElementsByClassName("page-container"))
	{
		let par = cont.parentElement;
		par.update_cont = (w)=>{
			cont.style.width = w-15 + "px";
			cont.style.height = wh-15 + "px";
		};
	}
	
	let spl_X = ww * 0.30;
	const reset_spl = ()=>{
		ww = window.innerWidth;
		wh = window.innerHeight;
		
		page_select.style.height = wh + "px";
		splitter.style.height = wh + "px";
		page_display.style.height = wh + "px";
		
		if (ww-5<spl_X) spl_X = ww-5;
		if (spl_X<5) spl_X = 5;
		
		page_select.style.width = spl_X + "px";
		splitter.style.left = spl_X + "px";
		let x2 = spl_X+splitter.clientWidth;
		let w2 = ww - x2;
		page_display.style.left = x2 + "px";
		page_display.style.width = w2 + "px";
		
		page_select.update_cont(spl_X);
		page_display.update_cont(w2);
	}
	reset_spl();
	
	window.onresize = ()=>reset_spl();
	
	splitter.addEventListener("dblclick", ()=>{
		let w = 0;
		let psc = document.getElementsByClassName("page-container")[0];
		let psc2 = psc.children[0];
		for (let n of psc2.children)
			if (n.clientWidth>w) w = n.clientWidth;
		
		let get_margin = (el)=>{
			let style = el.currentStyle || window.getComputedStyle(el);
			return parseFloat(style.marginLeft) + parseFloat(style.marginRight);
		}
		
		spl_X = w +
			get_margin(psc) +
			get_margin(psc2)
		;
		reset_spl();
	});
	
	let spl_grabed = false;
	splitter.addEventListener("mousedown", (e)=>{
		spl_grabed=true;
		e.preventDefault();
	});
	window.addEventListener("mousemove", (e)=>{if (spl_grabed) {
		spl_X = e.clientX - splitter.clientWidth/2;
		reset_spl();
		e.preventDefault();
	}});
	window.addEventListener("mouseup", ()=>spl_grabed=false);
	
}

/* ============================== *\
		    page select
\* ============================== */

var root_folder = null;
var selected_page = null;

var currently_loading_folder = null;

const select_page = (new_page)=>{
	if (selected_page == new_page) return;
	fix_element(new_page);
	
	if (selected_page) {
		selected_page.hidden = true;
		let name_span = selected_page.name_span;
		if (name_span) name_span.style.backgroundColor = "inherit";
	}
	
	selected_page = new_page;
	if (selected_page)
	{
		selected_page.hidden = false;
		let name_span = selected_page.name_span;
		if (name_span) name_span.style.backgroundColor = "#D0D0D0";
		
		let tree_obj = new_page.tree_obj.root;
		while (tree_obj)
		{
			if ( tree_obj.state==false && tree_obj.reverse_state ) tree_obj.reverse_state();
			tree_obj = tree_obj.root;
		}
		
	}
	
};

const on_start_folder = (folder_name, root_page)=>{
	let res = {
		folders: [],
		pages: [],
		content_ref: root_page,
		container: document.createElement("div"),
		name: folder_name,
	};
	
	if (root_page)
	{
		root_page.tree_obj = res;
		document.getElementById("page-display-container-body").append(root_page);
	}
	
	if (!root_folder)
	{
		root_folder = res;
		document.getElementById("page-select-container").append(res.container);
		res.container.className = "ps-root-container";
	} else
	{
		currently_loading_folder.folders.push(res);
		res.root = currently_loading_folder;
		
		for (let t of broken_links)
			if (t.path.substr(0,t.path.indexOf('/')) == folder_name)
				t.path = t.path.substr(t.path.indexOf('/')+1); else
				t.path = "../"+t.path;
		
		res.body = document.createElement("div");
		res.body.className = "ps-folder";
		res.state = false;
		currently_loading_folder.container.append(res.body);
		
		res.update = ()=>{
			res.state_span.innerHTML = String.fromCharCode( res.empty? 0x2022 : res.state ? 0x25BC : 0x25BA );
			res.container.hidden = !res.state;
		}
		res.reverse_state = ()=>{
			res.state = !res.state;
			res.update();
		};
		
		res.state_span = document.createElement("span");
		res.body.append(res.state_span);
		
		res.name_span = document.createElement("span");
		res.name_span.className = "clickable-span";
		res.name_span.innerHTML = folder_name;
		if (root_page) root_page.name_span = res.name_span;
		res.body.append(res.name_span);
		if (root_page) res.name_span.addEventListener("click", ()=>select_page(root_page));
		
		res.container.className = "ps-container";
		res.body.append(res.container);
		
	}
	
	currently_loading_folder = res;
	if (root_page) fix_links(root_page);
}

const on_page_added = (page)=>{
	document.getElementById("page-display-container-body").append(page);
	fix_links(page);
	
	let res = {
		root: currently_loading_folder,
		name:  page.getAttribute("page_name"),
	};
	
	res.dot_span = document.createElement("span");
	res.dot_span.className = "dot-page-root";
	res.dot_span.innerHTML = String.fromCharCode( 0x2022 );
	currently_loading_folder.container.append(res.dot_span);
	
	res.name_span = document.createElement("span");
	res.name_span.innerHTML = res.name + "<br>";
	res.name_span.className = "ps-page";
	res.name_span.addEventListener("click", ()=>select_page(page));
	currently_loading_folder.container.append(res.name_span);
	page.name_span = res.name_span;
	
	res.content_ref = page;
	page.tree_obj = res;
	
	currently_loading_folder.pages.push(res);
	
	if (!selected_page) select_page(page);
}

const on_end_folder = ()=>{
	
	if (currently_loading_folder!=root_folder) {
		let folder = currently_loading_folder;
		
		if ( folder.folders.length || folder.pages.length )
		{
			folder.state_span.className = "clickable-span";
			folder.state_span.addEventListener("click", folder.reverse_state);
			folder.name_span.addEventListener("dblclick", folder.reverse_state);
		} else
		{
			folder.empty = true;
			folder.state_span.innerHTML = String.fromCharCode(0x2022);
			folder.state_span.className = "dot-page-root";
		}
		
		currently_loading_folder.update();
	}
	
	if (currently_loading_folder.name_span && !currently_loading_folder.content_ref)
	{
		let res = document.createElement("div");
		res.hidden = true;
		res.name_span = currently_loading_folder.name_span;
		res.name_span.addEventListener("click", ()=>select_page(res));
		document.getElementById("page-display-container-body").append(res);
		currently_loading_folder.content_ref = res;
		res.tree_obj = currently_loading_folder;
		
		if (currently_loading_folder.folders.length)
		{
			let h = document.createElement("h1");
			h.innerHTML = "Под-папки:";
			res.append(h);
			
			let l = document.createElement("ul");
			for (let folder of currently_loading_folder.folders)
			{
				let li = document.createElement("li");
				li.innerHTML = folder.name_span.innerHTML;
				make_smart_link(li, folder.content_ref);
				l.append(li);
			}
			res.append(l);
			
		}
		
		if (currently_loading_folder.pages.length)
		{
			let h = document.createElement("h1");
			h.innerHTML = "Страницы:";
			res.append(h);
			
			let l = document.createElement("ul");
			for (let page of currently_loading_folder.pages)
			{
				let li = document.createElement("li");
				li.innerHTML = page.name_span.innerHTML;
				make_smart_link(li, page.content_ref);
				l.append(li);
			}
			res.append(l);
			
		}
		
	}
	
	//try_fix_broken_links();
	
	broken_links = broken_links.map((t)=>{
		
		if (t.path.startsWith("../"))
		{
			t.path = t.path.substr(3);
			return t;
		} else
		{
			var page_name = t.path.toLowerCase();
			
			if (page_name == "")
				make_smart_link(t.lnk, currently_loading_folder.content_ref); else
				for (let page of currently_loading_folder.pages)
					if (page.name.toLowerCase() == page_name)
						make_smart_link(t.lnk, page.content_ref);
			
			return null;
		};
		
	}).filter((t)=>t);
	
	currently_loading_folder = currently_loading_folder.root;
}

/* ============================== *\
	       page display
\* ============================== */

const find_page_by_path = (path)=>{
	let folder = currently_loading_folder;
	
	while (path.startsWith("../"))
	{
		path = path.substr(3);
		folder = folder.root;
	}
	
	while (path.includes('/'))
	{
		let sfn = path.substr(0,path.indexOf('/')).toLowerCase();
		path = path.substr(path.indexOf('/')+1);
		
		let nfound = true;
		for (let sf of folder.folders)
			if (sf.name.toLowerCase() == sfn)
			{
				folder = sf;
				nfound = false;
				break;
			}
		
		if (nfound) return null;
	}
	
	if (path == "")
		return folder.content_ref; else
		for (let page of folder.pages)
			if (page.name.toLowerCase() == path.toLowerCase())
				return page.content_ref;
	
	return null;
}
const make_smart_link = (lnk, page)=>{
	lnk.className = "smart-link";
	lnk.addEventListener("click", ()=>select_page(page));
}

var broken_links = [];
const fix_links = (page)=>{
	
	for (let lnk of page.getElementsByTagName('a'))
	{
		lnk.path = lnk.getAttribute("path");
		lnk.removeAttribute("path");
		
		if (!lnk.path) continue;
		let page = find_page_by_path(lnk.path);
		if (page)
			make_smart_link(lnk, page); else
			broken_links.push({
				"path": lnk.path,
				"lnk": lnk
			});
		
	}
	
}

const code_words_color = {
	"pas": {
		"keyword": ["begin", "end", "var", "uses", "as", "new", "try", "except", "on", "do", "const"],
		"build-in": ["nil", "integer", "string"],
		"red": ["ToDo"],
	},
	"cl-c": {
		"keyword": ["__kernel"],
	},
	"default": {
		
	}
}

const fix_element = (page)=>{
	if (page.fixed) return;
	page.fixed = true;
	
	for (let spoiler of page.getElementsByClassName('spoiler'))
	{
		let get_spoiler_text = ()=> + ' ' + spoiler.getAttribute('summary');
		
		let wrap = document.createElement('p');
		wrap.className = "spoiler-wrap";
		wrap.update = ()=>{
			wrap.state_span.innerHTML = String.fromCharCode( 	spoiler.hidden ? 0x25BA : 0x25BC );
			wrap.style.border = 								spoiler.hidden ? "none" : null;
			wrap.style.marginLeft = 							spoiler.hidden ? "1px" 	: null;
		}
		
		wrap.state_span = document.createElement("span");
		wrap.update();
		wrap.append(wrap.state_span);
		
		wrap.name_span = document.createElement("span");
		wrap.name_span.innerHTML = spoiler.getAttribute("summary");
		wrap.append(wrap.name_span);
		
		wrap.reverse_state = ()=>{
			spoiler.hidden = !spoiler.hidden;
			wrap.update();
		}
		
		wrap.state_span.addEventListener("click", wrap.reverse_state);
		wrap.name_span.addEventListener("click", wrap.reverse_state);
		
		wrap.state_span.style.cursor = "pointer";
		wrap.name_span.style.cursor = "pointer";
		
		spoiler.replaceWith(wrap);
		wrap.append(spoiler);
	}
	
	for (let code of page.getElementsByTagName('code'))
	{
		let w_to_regex = (w)=>`(?<!\\w)${w}(?!\\w)`;
		
		// Автоопределение языка кода
		if (!code.className)
		{
			let best = {lang: null, c: 0};
			let multiple_best = true;
			
			for (let lang_name in code_words_color)
			{
				let c = 0;
				for (let wordt in code_words_color[lang_name])
					for (let w of code_words_color[lang_name][wordt])
					{
						var m = code.innerHTML.match(new RegExp( w_to_regex(w), "gi" ));
						if (m) c += m.length;
					}
				
				if (best.c == c)
					multiple_best = true; else
				if (best.c < c)
				{
					multiple_best = false;
					best.lang = lang_name;
					best.c = c;
				}
			}
			
			if (multiple_best)
				code.className = "language-default"; else
				code.className = "language-" + best.lang;
		}
		
		// Подсветка особых слов в коде
		{
			let lang = code.className.substr("language-".length);
			let curr_cw = code_words_color[lang];
			if (!curr_cw) curr_cw = code_words_color["default"];
			for (let wordt in curr_cw)
				code.innerHTML = code.innerHTML.replace(
					new RegExp(curr_cw[wordt].map(w_to_regex).join('|'),"gi"),
					w=> `<span class="code-${wordt}">${w}</span>`
				);
		}
		
		// Подсветка скобок
		{
			var br_types = {
				op: ["(", "[", "{", "&lt;", "'"],
				cl: [")", "]", "}", "&gt;", "'"],
			}
			for (let op in br_types)
				for (let i=0; i<br_types[op].length; i++)
					code.innerHTML = code.innerHTML.replace(
						new RegExp('\\'+br_types[op][i], "g"),
						`<span class=bracket ${ op=="op" ? "op=true" : "" } bt=${i}>${br_types[op][i]}</span>`
					);
			
			let br_st = [];
			for (let obj2 of code.getElementsByClassName("bracket"))
			{
				let b2t = obj2.getAttribute("bt");
				
				if (obj2.getAttribute("op"))
					br_st.push({
						obj: obj2,
						bt: b2t,
					}); else
				{
					let b1 = br_st.pop();
					let b0 = null;
					if (!b1) continue;
					if (b1.obj == obj2.parentElement)
					{
						b0 = b1;
						b1 = br_st.pop();
					}
					if (!b1) continue;
					if (b1.bt == b2t)
					{
						let obj1 = b1.obj;
						
						let on_enter = ()=>{
							obj1.className = "code-glowing-bracket";
							obj2.className = "code-glowing-bracket";
						}
						let on_leave = ()=>{
							obj1.className = null;
							obj2.className = null;
						}
						
						obj1.addEventListener("mouseenter", on_enter);
						obj2.addEventListener("mouseenter", on_enter);
						obj1.addEventListener("mouseleave", on_leave);
						obj2.addEventListener("mouseleave", on_leave);
					} else
					{
						br_st.push(b1);
						if (b0) br_st.push(b0);
					}
				}
				
			}
			
		}
		
		if (code.parentElement.tagName == "PRE")
		{
			let pre = code.parentElement;
			pre.className = 'code-block';
			
			let wrap = document.createElement('p');
			pre.replaceWith(wrap);
			wrap.append(pre);
			
		} else
			code.className = "inline-code";
		
	}
	
}
</script>
<script>on_start_folder("CL ABC", null)</script>
<script>on_start_folder("Общие сведения", null)</script>
<div id="page-1" page_name="О справке" hidden=true>
<p>Данная справка относится к модулю <code>OpenCLABC</code>, входящему в состав стандартных модулей языка <code>PascalABC.Net</code>.</p>
<p>Модуль <code>OpenCLABC</code> это высокоуровневая оболочка модуля <code>OpenCL</code>.<br />
Это значит, что с <code>OpenCLABC</code> можно писать гораздо меньше кода в больших и сложных программах,
однако такой же уровень микроконтроля как с модулем <code>OpenCL</code> недоступен.
Например, напрямую управлять <code>cl_event</code>'ами в <code>OpenCLABC</code> невозможно.
Вместо этого надо использовать операции с очередями (как сложение и умножение очередей)</p>
<p>Справка модуля <code>OpenCL</code> отсутствует. Вместо неё смотрите:</p>
<ul>
<li><a href="../%D0%93%D0%B0%D0%B9%D0%B4%20%D0%BF%D0%BE%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E%20OpenCL%20%D0%B8%20OpenGL.html">Общий гайд по использованию модулей <code>OpenCL</code> и <code>OpenGL</code></a></li>
<li><a href="https://www.khronos.org/registry/OpenCL/">Контейнер справок библиотеки <code>OpenCL</code>, на которой основан модуль <code>OpenCL</code></a></li>
</ul>
<p>Если в найдена ошибка, или чего-либо не хватает (в справке или модуле) - пишите в <a href="https://github.com/SunSerega/POCGL/issues">issue</a>.</p>
</div>
<script>on_page_added(document.getElementById("page-1"))</script>
<div id="page-2" page_name="Термины, которые часто путают новички" hidden=true>
<ul>
<li><p>CPU — Центральное Процессорное Устройство (процессор)</p>
</li>
<li><p>GPU — Графическое Процессорное Устройство (видеокарта)</p>
</li>
<li><p>Команда — запрос на выполнение чего-либо. К примеру:</p>
<ul>
<li>Запрос на запуск программы на GPU</li>
<li>Запрос на начало чтения данных из памяти GPU в оперативную память</li>
</ul>
<p><strong>Называть процедуры и функции командами ошибочно!</strong></p>
</li>
<li><p>Подпрограмма — процедура или функция</p>
</li>
<li><p>Метод — особая подпрограмма, вызываемая через экземпляр</p>
<ul>
<li>К примеру, метод <code>Context.SyncInvoke</code> выглядит в коде как <code>cont.SyncInvoke(...)</code>, где <code>cont</code> — переменная типа <code>Context</code></li>
</ul>
</li>
</ul>
<p>Остальные непонятные термины ищите в справке <code>PascalABC.NET</code> или в интернете</p>
</div>
<script>on_page_added(document.getElementById("page-2"))</script>
<script>on_end_folder()</script>
<div id="page-3" page_name="" hidden=true>
<p>Для отправки команд в GPU необходим контекст (объект типа <code>Context</code>):<br />
Он содержит информацию о том, какое устройство будет использоваться при выполнении программ и хранении содержимого буферов.</p>
<hr />
<p>Создать контекст можно конструктором (<code>new Context(...)</code>).<br />
Контекст можно и не создавать, используя всюду свойство <code>Context.Default</code>.</p>
<p>Изначально этому свойству присваивается контекст, использующий один любой GPU, если таковой есть,
или одно любое другое устройство, поддерживающее OpenCL, если GPU отсутствует.</p>
<p>Если устройств поддерживающих <code>OpenCL</code> нет - <code>Context.Default</code> будет <code>nil</code>.<br />
Однако такая ситуация теоретически невозможна, потому что OpenCL поддерживается
всеми современными устройствами, занимающимися выводом картинки на экран.<br />
Если <code>Context.Default=nil</code> - переустановите графические драйверы.</p>
<p><code>Context.Default</code> можно перезаписывать. Это может понадобиться, если во всей программе использовать общий контекст, но не стандартный.</p>
<p>Операции, у которых невозможно указать контекст - всегда используют <code>Context.Default</code>.</p>
<p>Контекст используется только для
<a path="../Буфер (Buffer)/">инициализации буферов</a>
и
<a path="../Очередь [команд] (CommandQueue)/Выполнение очередей">выполнения команд</a>
на GPU.</p>
</div>
<script>on_start_folder("Контекст (Context)", document.getElementById("page-3"))</script>
<script>on_end_folder()</script>
<div id="page-4" page_name="" hidden=true>
<p>Передавать команды для GPU по одной не эффективно.
Гораздо эффективнее передавать несколько команд сразу.</p>
<p>Для этого существуют очереди (типы, наследующие от <code>CommandQueue&lt;T&gt;</code> и <code>CommandQueueBase</code>).
Они хранят произвольное количество команд для GPU.
А при необходимости также и части кода, выполняемые на CPU.</p>
<h1>Страницы:</h1>
<ul>
<li><p><a path="Возвращаемое значение очередей">Возвращаемое значение</a></p>
</li>
<li><p><a path="Создание очередей">Создание</a></p>
</li>
<li><p><a path="Выполнение очередей">Выполнение</a></p>
</li>
<li><p><a path="Вложенные очереди">Вложенные очереди</a></p>
</li>
<li><p><a path="Множественное использование очереди">Множественное использование</a></p>
</li>
<li><p><a path="Особые команды у [Buffer,Kernel]CommandQueue">Особые команды у <code>BufferCommandQueue</code>/<code>KernelCommandQueue</code></a></p>
</li>
</ul>
</div>
<script>on_start_folder("Очередь [команд] (CommandQueue)", document.getElementById("page-4"))</script>
<div id="page-5" page_name="Возвращаемое значение очередей" hidden=true>
<p>У каждого типа-очереди есть свой тип возвращаемого значение.<br />
К примеру, так объявляется переменная в которую можно будет сохранить очередь, возвращающую <code>integer</code>:</p>
<pre><code>var Q1: CommandQueue&lt;integer&gt;;
</code></pre>
<p>Очереди, созданные из буфера или kernel-а возващают свой <code>Buffer</code>/<code>Kernel</code> соответственно, из которого были созданы;<br />
Очереди, созданные с <code>HFQ</code> - значение, которое вернёт переданная функция;<br />
Очереди, созданные с <code>HPQ</code> - значение типа <code>object</code> (и всегда <code>nil</code>).</p>
<p>К примеру:</p>
<pre><code>uses OpenCLABC;

/// Вывод типа и значения объекта
procedure OtpObject(o: object) :=
Writeln( $'{o?.GetType}[{_ObjectToString(o)}]' );
// &quot;o?.GetType&quot; это короткая форма &quot;o=nil ? nil : o.GetType&quot;,
// то есть берём или тип объекта, или nil если сам объект nil
// _ObjectToString это функция, которую использует Writeln для форматирования значений

begin
  var b0 := new Buffer(1);
  
  // Тип - буфер, потому что очередь создали из буфера
  OtpObject(  Context.Default.SyncInvoke( b0.NewQueue as CommandQueue&lt;Buffer&gt;   )  );
  
  // Тип - Int32 (то есть integer), потому что это тип по-умолчанию для выражения (5)
  OtpObject(  Context.Default.SyncInvoke( HFQ( ()-&gt;5                          ) )  );
  
  // Тип - string, по той же причине
  OtpObject(  Context.Default.SyncInvoke( HFQ( ()-&gt;'abc'                      ) )  );
  
  // Тип отсутствует, потому что HPQ возвращает nil
  OtpObject(  Context.Default.SyncInvoke( HPQ( ()-&gt;Writeln('Выполнилась HPQ') ) )  );
  
end.
</code></pre>
<p>После выполнения очереди метод <code>Context.SyncInvoke</code> возвращает то, что вернула очередь.<br />
А если использовать метод <code>Context.BeginInvoke</code> - возвращаемое значение можно получить с помощью метода <code>CLTask.GetRes</code>.</p>
<hr />
<p>Бывает необходимо хранить несколько очередей, с разными возвращаемыми значениями,
вместе, к примеру, в переменной типа <code>List&lt;&gt;</code>.<br />
Но в переменной типа <code>CommandQueue&lt;SomeT&gt;</code> можно хранить только очередь с конкретным типом возвращаемого значения <code>SomeT</code>.</p>
<p>Для того чтоб хранить очереди с любым возвращаемым значением в 1 переменной - надо использовать <code>CommandQueueBase</code>.<br />
<code>CommandQueueBase</code> это особый тип очереди, у которого не указывается возвращаемое значение.<br />
От него наследует <code>CommandQueue&lt;&gt;</code>, поэтому переменной типа <code>CommandQueueBase</code> можно присвоить любую очередь.</p>
<p>Если попытаться выполнить такую очередь,
или применять операции преобразования очередей, как <code>.ThenConvert</code>,
то тип возвращаемого значения будет восприниматься как <code>Object</code>.</p>
</div>
<script>on_page_added(document.getElementById("page-5"))</script>
<div id="page-6" page_name="Создание очередей" hidden=true>
<p>Есть всего 7 базовых способов создать очередь:</p>
<div class="spoiler" summary="1. Из буфера/kernel-а" hidden="true"><p>Самый просто способ создать очередь — выбрать объект типа <code>Buffer</code> или <code>Kernel</code> и вызвать для него метод <code>.NewQueue</code>.</p>
<p>Полученная очередь будет иметь особый тип: <code>BufferCommandQueue</code>/<code>KernelCommandQueue</code> для буфера/kernel'а соответственно.<br />
К такой очереди можно добавлять команды, вызывая её методы, имена которых начинаются с <code>.Add...</code>.</p>
<p>К примеру:</p>
<pre><code>uses OpenCLABC;

begin
  // Буфер достаточного размера чтоб содержать 3 значения типа integer
  var b := new Buffer( 3*sizeof(integer) );
  
  // Создаём очередь
  var q := b.NewQueue;
  
  // Добавлять команды в полученную очередь можно вызывая соответствующие методы
  q.AddWriteValue(1, 0*sizeof(integer) );
  
  // Методы, добавляющие команду в очередь - возвращают очередь, для которой их вызвали (не копию а ссылку на оригинал)
  // Поэтому можно добавлять по несколько команд в 1 строчке:
  q.AddWriteValue(5, 1*sizeof(integer) ).AddWriteValue(7, 2*sizeof(integer) );
  // Все команды в q будут выполнятся последовательно, что не всегда хорошо
  // Если надо выполнять параллельно - создавайте несколько &quot;b.NewQueue&quot; и умножайте друг на друга
  
  // В данной версии надо писать &quot;as CommandQueue&lt;...&gt;&quot; при использовании [Buffer/Kernel]CommandQueue там,
  // где принимает CommandQueue&lt;...&gt;, из за бага компилятора #1981
  Context.Default.SyncInvoke(q as CommandQueue&lt;Buffer&gt;);
  
  // Вообще чтение тоже надо делать через очереди, но для простого примера - и неявные очереди подходят
  b.GetArray1&amp;&lt;integer&gt;(3).Println;
  
end.
</code></pre>
<p>Так же, очереди <code>BufferCommandQueue</code>/<code>KernelCommandQueue</code> можно создавать из очередей, возвращающих <code>Buffer</code>/<code>Kernel</code> соответственно. Для этого используется конструктор:</p>
<pre><code>var q0: CommandQueue&lt;Buffer&gt;;
...
var q := new BufferCommandQueue(q0);
</code></pre>
</div>
<div class="spoiler" summary="2. Из возвращаемого значения" hidden="true"><p>Переменной очереди можно присвоить значение, тип которого совпадает с возвращаемым значением очереди:</p>
<pre><code>var q: CommandQueue&lt;integer&gt; := 5;
</code></pre>
<p>Этот код присваевает переменной <code>q</code> константную очередь, которая ничего не выполняет и возвращает <code>5</code>.</p>
<p>Получить значение, из которого создали константную очередь, можно преобразовав её к <code>ConstQueue&lt;&gt;</code>:</p>
<pre><code>var cq := q as ConstQueue&lt;integer&gt;;
if cq=nil then
  Writeln('Очередь не константная') else
  Writeln($'Очередь была создана из значения {cq.Val}');
</code></pre>
<p><code>CommandQueueBase</code> так же можно создать из значения, но для этого - тип значения должен быть <code>Object</code>:</p>
<pre><code>var q: CommandQueueBase := 5 as object;
</code></pre>
<p>Чтоб получить значение, из которого создали константную очередь, когда не знаете его тип - используйте интерфейс <code>IConstQueue</code>:</p>
<pre><code>var cq := q as IConstQueue;
if cq=nil then
  Writeln('Очередь не константная') else
  Writeln($'Очередь была создана из значения ({cq.GetConstVal})');
</code></pre>
</div>
<div class="spoiler" summary="3. Из обычной подпрограммы" hidden="true"><p>Иногда между командами для GPU надо вставить выполнение обычного кода на CPU.
А разрывать для этого очередь на две части - плохо, потому что
одна целая очередь всегда выполнится быстрее двух её частей.</p>
<p>Для таких случае существуют глобальные подпрограммы HFQ и HPQ:</p>
<p>HFQ — Host Function Queue<br />
HPQ — Host Procedure Queue<br />
(Хост в контексте OpenCL - это CPU, потому что с него посылаются команды для GPU)</p>
<p>Они возвращают очередь, выполняющую код (функцию/процедуру соотвественно) на CPU.<br />
Подробнее уже описано
<a path="Возвращаемое значение очередей">
на предыдущей странице
</a>
.</p>
</div>
<div class="spoiler" summary="4. Из нескольких других очередей" hidden="true"><p>Если сложить две очереди A и B (<code>var C := A+B</code>) — получится очередь C, в которой сначала выполнится A, а затем B.<br />
Очередь C будет считаться выполненной тогда, когда выполнится очередь B.</p>
<p>Если умножить две очереди A и B (<code>var C := A*B</code>) — получится очередь C, в которой одновременно начнут выполняться A и B.<br />
Очередь C будет считаться выполненной тогда, когда обе очереди (A и B) выполнятся.</p>
<p>Как и в математике, умножение имеет бОльший приоритет чем сложение.</p>
<p>В обоих случаях очередь C будет возвращать то, что вернула очередь B. То есть если складывать и умножать много очередей - результат будет всегда возвращать то, что вернула самая последняя очередь.</p>
<p>Простейший пример:</p>
<pre><code>uses OpenCLABC;

begin
  
  var q1 := HPQ(()-&gt;
  begin
    // lock надо чтоб при параллельном выполнении два потока не пытались использовать вывод одновременно. Иначе выведет кашу
    lock output do Writeln('Очередь 1 начала выполняться');
    Sleep(500);
    lock output do Writeln('Очередь 1 закончила выполняться');
  end);
  var q2 := HPQ(()-&gt;
  begin
    lock output do Writeln('Очередь 2 начала выполняться');
    Sleep(500);
    lock output do Writeln('Очередь 2 закончила выполняться');
  end);
  
  Writeln('Последовательное выполнение:');
  Context.Default.SyncInvoke( q1 + q2 );
  
  Writeln;
  Writeln('Параллельное выполнение:');
  Context.Default.SyncInvoke( q1 * q2 );
  
end.
</code></pre>
<p>Операторы += и *= также применимы к очередям.<br />
И как и для чисел - <code>A += B</code> работает как <code>A := A+B</code> (и так же с *=).<br />
А значит возвращаемые типы очередей A и B должны быть одинаковыми, чтобы к ним можно было применить +=/*=.</p>
<p>Если надо сложить/умножить много очередей - лучше применять <code>CombineSyncQueue</code>/<code>CombineAsyncQueue</code> соответственно.<br />
Эти подпрограммы работают немного быстрее чем сложение и умножение, если объединять больше двух очередей.</p>
<p>Кроме того они так же могут принимать ещё 1 параметр перед очередями:
Этот параметр позволяет указать функцию преобразования, которая использует результаты всех входных очередей:</p>
<pre><code>uses OpenCLABC;

begin
  
  var q1 := HFQ( ()-&gt;1 );
  var q2 := HFQ( ()-&gt;2 );
  
  // Выводит 2, то есть только результат последней очереди
  // Так сделано из за вопросов производительности
  Context.Default.SyncInvoke( q1+q2 ).Println;
  // Однако всё же бывает так, что нужны результаты всех сложенных/умноженных очередей
  
  // В таком случае надо использовать CombineSyncQueue и CombineAsyncQueue
  // А точнее их перегрузку, первый параметр которой - функция преобразования
  Context.Default.SyncInvoke(
    CombineSyncQueue(
      results-&gt;results.JoinIntoString, // функция преобразования
      q1, q2
    )
  ).Println;
  // Теперь выводит строку &quot;1 2&quot;. Это то же самое что вернёт &quot;Arr(1,2).JoinIntoString&quot;
  
end.
</code></pre>
</div>
<div class="spoiler" summary="5. Из очереди + преобразования результата" hidden="true"><p>Если надо с минимальными затратами изменить представление компилятора об очереди - лучше всего использовать <code>.Cast</code>.<br />
Но он ограничен примерно так же, как метод последовательностей <code>.Cast</code>. То есть:</p>
<pre><code>type t1 = class ... end;
type t2 = class(t1) ... end;
...
var Q1: CommandQueue&lt;integer&gt; := 5;
var Q2: CommandQueueBase := Q1;
var Q3: CommandQueue&lt;t1&gt; := (new t2) as t1;
var Q4: CommandQueue&lt;t1&gt; := new t1;
var Q5: CommandQueue&lt;t2&gt; := new t2;

// Можно, потому что к object можно преобразовать всё
Context.Default.SyncInvoke( Q1.Cast&amp;&lt;object&gt; );

// Нельзя, преобразование из integer в byte - изменяет внутреннее представление данных
Context.Default.SyncInvoke( Q1.Cast&amp;&lt;byte&gt; );

// Можно, Q2 и так имеет тип CommandQueue&lt;integer&gt;, а значит тут Cast вернёт (Q2 as CommandQueue&lt;integer&gt;)
Context.Default.SyncInvoke( Q2.Cast&amp;&lt;integer&gt; );

// Можно, потому что Q3 возвращает t2
Context.Default.SyncInvoke( Q3.Cast&amp;&lt;t2&gt; );

// Нельзя, Q4 возвращает не t2 а t1, поэтому к t2 преобразовать не получится
Context.Default.SyncInvoke( Q4.Cast&amp;&lt;t2&gt; );

// Можно, потому что t2 наследует от t1
Context.Default.SyncInvoke( Q5.Cast&amp;&lt;t1&gt; );
</code></pre>
<p>Ну а если эти ограничения не подходят - остаётся только <code>.ThenConvert</code>. Он позволяет указать любой алгоритм преобразования, но и требует бОльшей производительности:</p>
<pre><code>uses OpenCLABC;

begin
  var q := HFQ(()-&gt;123);
  
  Context.Default.SyncInvoke(
    q.ThenConvert(i -&gt; i*2 )
  ).Println;
  
end.
</code></pre>
</div>
<div class="spoiler" summary="6. Из повторения очереди" hidden="true"><p><del>В данный момент всё ещё не работает... Но уже совсем скоро, правда правда!</del></p>
</div>
<div class="spoiler" summary="7. Не создавая явно" hidden="true"><p>Передавать команды по одной, когда их несколько - ужасно медленно!<br />
Но нередко бывает так, что команда всего одна. Или для отладки надо одноразово выполнить одну команду.</p>
<p>Для таких случаев можно создавать очередь неявно:<br />
У каждого метода очереди, создаваемой с <code>.NewQueue</code> есть дублирующий метод в оригинальном объекте.<br />
Такие методы сами создают новую очередь, добавляют в неё одну соответствующую команду и выполняют полученную очередь в <code>Context.Default.SyncInvoke(...)</code>.</p>
<p>Следующий пример сравнивает явные и неявные очереди:</p>
<pre><code>uses OpenCLABC;

begin
  
  var b := new Buffer( 3*sizeof(integer) );
  var A := new integer[3];
  
  // Код с очередями
  
  var Q_BuffWrite :=
    ( b.NewQueue.AddWriteValue(1, 0*sizeof(integer) ) as CommandQueue&lt;Buffer&gt; ) *
    ( b.NewQueue.AddWriteValue(5, 1*sizeof(integer) ) as CommandQueue&lt;Buffer&gt; ) *
    ( b.NewQueue.AddWriteValue(7, 2*sizeof(integer) ) as CommandQueue&lt;Buffer&gt; )
  ;
  
  var Q_BuffRead := b.NewQueue.AddReadArray(A) as CommandQueue&lt;Buffer&gt;;
  
  var Q_Otp := HPQ(()-&gt;
  begin
    A.Println;
  end);
  
  Context.Default.SyncInvoke(
    Q_BuffWrite +
    Q_BuffRead +
    Q_Otp
  );
  
  // Этот же код ещё раз, но без явных очередей
  // Неявно - каждый метод .Write*** и .Read*** всё равно создаёт по очереди
  // Такая запись короче, но выполняется медленнее
  
  // Аналог Q_BuffWrite
  System.Threading.Tasks.Parallel.Invoke(
    ()-&gt;b.WriteValue(1, 0*sizeof(integer) ),
    ()-&gt;b.WriteValue(5, 1*sizeof(integer) ),
    ()-&gt;b.WriteValue(7, 2*sizeof(integer) )
  );
  
  // Аналог Q_BuffRead
  b.ReadArray(A);
  
  // Аналог Q_Otp
  A.Println;
  
end.
</code></pre>
<p>Кроме того, у типа <code>Buffer</code> есть дополнительные методы <code>Buffer.Get...</code>.
Соответствующих методов у очередей — нет (<code>ToDo</code> возможно, в будущем появятся).<br />
Методы <code>.Get...</code> создают новый объект типа записи, массива или выделяют область неуправляемой памяти,
читают в полученный объект содержимое буфера и возвращают этот объект.
Они также используют неявную очередь (для чтения буфера).</p>
</div>
</div>
<script>on_page_added(document.getElementById("page-6"))</script>
<div id="page-7" page_name="Выполнение очередей" hidden=true>
<p>Самый простой способ выполнить очередь - вызвать метод <code>Context.SyncInvoke</code>.<br />
Он синхронно выполняет очередь и вызвращает её результат.</p>
<p>Но если надо выполнить очередь асинхронно - лучше использовать метод <code>Context.BeginInvoke</code>.<br />
Он запускает асинхронное выполнение очереди и как только очередь была полностью запущена - возвращает объект типа <code>CLTask&lt;&gt;</code>, через который можно:</p>
<ul>
<li>Ожидать пока выполнение не закончится методом <code>CLTask&lt;&gt;.Wait</code>.</li>
<li>Ожидать пока выполнение не закончится и сразу получить возвращаемое значение, методом <code>CLTask&lt;&gt;.GetRes</code>.</li>
</ul>
<p>Метод <code>Context.SyncInvoke</code> реализован через <code>.BeginInvoke(...).GetRes</code>. Поэтому, далее всюду где сказано &quot;... происходит при вызове <code>.BeginInvoke</code>&quot; - это же относится и к <code>.SyncInvoke</code>.</p>
<p>У <code>CLTask</code> как и у очереди - в <code>&lt;&gt;</code> указывается тип возвращаемого значения. То есть:</p>
<pre><code>var t: CLTask&lt;integer&gt;;
</code></pre>
<p>В такую переменную можно сохранить только результат <code>Context.BeginInvoke</code> для очереди типа <code>CommandQueue&lt;integer&gt;</code>.</p>
<p>Если при выполнении возникла ошибку, о ней выведет не полную информацию. Чтобы получить всю информацию - используется <code>try</code>:</p>
<pre><code>try
  
  //ToDo ваш код, вызывающий ошибку
  
except
  // Writeln выводит все внутренние исключения. &quot;e.ToString&quot; тоже.
  on e: Exception do Writeln(e);
end;
</code></pre>
<p>Для этого кода есть стандартный снипет. Чтоб активировать его - напишите <code>tryo</code> и нажмите Shift+Пробел.</p>
</div>
<script>on_page_added(document.getElementById("page-7"))</script>
<div id="page-8" page_name="Вложенные очереди" hidden=true>
<p>Все методы создающие одну команду (<code>.Add*</code> методы + все методы неявных очередей)
могут принемать очередь вместо значения в качестве любого параметра. Но в таком случае
возвращаемый тип очереди должен совпадать с типом параметра. К примеру:</p>
<pre><code>uses OpenCLABC;

begin
  var b := new Buffer(10*sizeof(integer));
  // Очищаем весь буфер ноликами, чтоб небыло мусора
  b.FillValue(0);
  
  var q := b.NewQueue
    
    // Второй параметр AddWriteValue - отступ от начала буфера
    // Он имеет тип integer, а значит можно передать и CommandQueue&lt;integer&gt;
    // Таким образом в параметр сохраняется алгоритм а не готовое значение
    // Поэтому 3 вызова ниже могут получится с 3 разными отступами
    .AddWriteValue(5, HFQ(()-&gt; Random(0,9)*sizeof(integer) ))
    
  as CommandQueue&lt;Buffer&gt;;
  
  Context.Default.SyncInvoke(q);
  Context.Default.SyncInvoke(q);
  Context.Default.SyncInvoke(q);
  
  b.GetArray1&amp;&lt;integer&gt;.Println;
  
end.
</code></pre>
<p>Все очереди-параметры начинают выполнятся сразу при вызове метода <code>Context.BeginInvoke</code>, не ожидая других очередей.</p>
<p>Обычно очереди-параметры используются при вызове kernel'а,
когда надо записать что то в буфер прямо перед вызовом kernel'а.</p>
</div>
<script>on_page_added(document.getElementById("page-8"))</script>
<div id="page-9" page_name="Множественное использование очереди" hidden=true>
<h1><code>ToDo</code> эта страница будет переделана и перенесена на страницу создания очередей, потому что необходимость в .Clone скоро отпадёт и большинство текста тут станет устаревшим</h1>
<pre><code>// 3.4.0
// 
// Одну и ту же очередь можно использовать несколько раз:
// &lt;-------------------------&gt;
// var Q1: CommandQueue&lt;...&gt;;
// ...
// Context.Default.SyncInvoke(Q1);
// Context.Default.SyncInvoke(Q1);
// &lt;-------------------------&gt;
// 
// Однако, во время выполнения очередь хранит в себе данные о своём состоянии выполнения и результат, когда он уже вычислен
// Это значит, что 1 объект очереди нельзя выполнять в 2 местах параллельно
// Иначе данные о состоянии и результате двух выполнений перемешаются
// То есть, такой код:
// &lt;-------------------------&gt;
// var Q1: CommandQueue&lt;...&gt;;
// ...
// Context.Default.SyncInvoke( Q1 * Q1 );
// &lt;-------------------------&gt;
// Приведёт к вызову исключения QueueDoubleInvokeException
// 
// Однако, если вам всё же надо использовать одну очередь в нескольких местах одновременно - есть 2 способа:

// 3.4.1 — Клонирование очередей (.Clone)
// 
// Методом .Clone можно создать полную копию очереди
// При этом, если исходная очередь проводила какие то вычисления,
// они будут произведены дважды, оригиналом и копией, при вызове обоих
// 
// Клон очереди является полностью независимым объектом
// Его можно вызывать не только параллельно с оригиналом
// Оригинал и копию можно вызывать даже в двух разных Context.BeginInvoke одновременно
// 

// 3.4.2 — Удлинители для очередей (.Multiusable)
// 
// Вариант выполнять очередь несколько раз, как в случае с .Clone, нередко не подходит,
// потому что это удваивает затраты производительности
// И некоторые очереди (например, выполнения kernel'ов) могут дать разные результаты, если выполнить их лишний раз
// 
// Если вам нужно использовать результат одной очереди многократно, лучше использовать метод .Multiusable
// !! Созданные таким образом очереди НЕ является независимыми объектами !!
// 
// .Multiusable работает словно провод-удлинитель,
// если сравнивать возвращаемое значение очереди с розеткой
// 
// Исходная очередь, для которой вызвали .Multiusable начинает выполняться сразу при вызове Context.BeginInvoke,
// Если хотя бы 1 из очередей, которую вернул метод .Multiusable была использована в этом Context.BeginInvoke
// 
// Очереди, которые вернул .Multiusable могут быть использованы параллельно:
// &lt;-------------------------&gt;
// var Q1: CommandQueue&lt;...&gt;;
// ...
// Qs1 := Q1.Multiusable(3); // создаёт массив из 3 очередей
// Context.Default.SyncInvoke( Qs1[0] * Qs1[1] * Qs1[2].ThenConvert(o-&gt;...) );
// &lt;-------------------------&gt;
// Однако, все очереди, полученные из .Multiusable всё ещё связаны оригинальной очередью
// А так как Context.BeginInvoke управляет переключением состояния выполнения очереди
// Следующий код попытается два раза запустить очередь Q1:
// &lt;-------------------------&gt;
// var Q1: CommandQueue&lt;...&gt;;
// ...
// Qs1 := Q1.Multiusable(2);
// Context.Default.BeginInvoke( Qs1[0] );
// Context.Default.BeginInvoke( Qs1[1] );
// &lt;-------------------------&gt;
// А т.к. это запрещено - будет вызвано исключение QueueDoubleInvokeException
// Чтобы исправить такой код - надо объеденить вызовы метода Context.BeginInvoke
// 
</code></pre>
</div>
<script>on_page_added(document.getElementById("page-9"))</script>
<div id="page-10" page_name="Особые команды у [Buffer,Kernel]CommandQueue" hidden=true>
<p>Между командами для GPU (хранимыми в очередях типов <code>BufferCommandQueue</code> и <code>KernelCommandQueue</code>)
бывает надо вставить выполнение другой очереди или кода для CPU.</p>
<p>Это можно сделать, используя несколько <code>.NewQueue</code>:</p>
<pre><code>var b: Buffer;
var q0: CommandQueueBase;
...
var q :=
  b.NewQueue.AddWriteValue(...) +
  q0 +
  HPQ(...) +
  b.NewQueue.AddWriteValue(...)
;
</code></pre>
<p>Однако можно сделать и красивее:</p>
<pre><code>var b: Buffer;
var q0: CommandQueueBase;
...
var q := b.NewQueue
  .AddWriteValue(...)
  .AddQueue(q0)
  .AddProc(...)
  .AddWriteValue(...)
;
</code></pre>
<p>Эти методы не имеют незаменимых применений, но позволяют сделать код значительно читабельнее</p>
</div>
<script>on_page_added(document.getElementById("page-10"))</script>
<script>on_end_folder()</script>
<div id="page-11" page_name="" hidden=true>
<p>Программы, выпоняемые на GPU, не могут использовать оперативную память (без определённых расширений).
Поэтому приходится выделять память на самом GPU.</p>
<p>Объекты типа <code>Buffer</code> содержат информацию об области памяти,
выделенной на GPU, а так же предоставляют методы для работы с этой памятью.</p>
<hr />
<p>Буфер создаётся конструктором (<code>new Buffer(...)</code>).</p>
<p>Но если не передавать контекст в конструктор - память на GPU выделится только при вызове метода <code>Buffer.Init</code>.<br />
Если вызвать <code>Buffer.Init</code> 2 раза - память освободится и выделится заново.</p>
<p>Когда на GPU выделяется память - она <strong>НЕ</strong> отчищается нулями, а значит содержит мусорные данные.</p>
<p>Если метод <code>Buffer.Init</code> не был вызван до первой операции чтения/записи - он будет вызван автоматически.
В таком случае в качестве контекста в котором выделяется память берётся тот,
для которого вызвали <code>.BeginInvoke</code>, который запустил команду чтения/записи буфера.</p>
<p>Память на GPU можно моментально освободить, вызвав метод <code>Buffer.Dispose</code>.
Но если снова использовать буфер, у которого освободили память - память опять выделится.</p>
<p>Если сборщик мусора удаляет объект типа <code>Buffer</code> - <code>.Dispose</code> вызывается автоматически.</p>
</div>
<script>on_start_folder("Буфер (Buffer)", document.getElementById("page-11"))</script>
<script>on_end_folder()</script>
<div id="page-12" page_name="" hidden=true>
<p>Обычные программы невозможно запустить на GPU. Для этого надо писать особые программы.<br />
В контексте OpenCL - эти программы обычно пишутся на языке &quot;OpenCL C&quot; (основанном на языке &quot;C&quot;).</p>
<p>Язык OpenCL-C это часть библиотеки OpenCL, поэтому его справку можно найти <a href="https://www.khronos.org/registry/OpenCL/">там же</a> где и справку OpenCL.</p>
<p>В <code>OpenCLABC</code> код на языке &quot;OpenCL C&quot; хранится в объектах типа <code>ProgramCode</code>.<br />
Объекты этого типа используются только как контейнеры.
Один объект ProgramCode может содержать любое количествово подпрограмм-kernel-ов.</p>
<h1>Есть 2 способа создать объект типа <code>ProgramCode</code>:</h1>
<ul>
<li><p><a path="Создание из исходного кода">Из исходного кода</a></p>
</li>
<li><p><a path="Создание из бинарного файла">Из прекомпилированного кода</a></p>
</li>
</ul>
</div>
<script>on_start_folder("Контейнер для кода (ProgramCode)", document.getElementById("page-12"))</script>
<div id="page-13" page_name="Создание из исходного кода" hidden=true>
<p>Конструктор <code>ProgramCode</code> (<code>new ProgramCode(...)</code>) принимает тексты исходников программы на языке OpenCL-C.<br />
<strong>Именно тексты исходников, не имена файлов</strong></p>
<p>Так же как исходники паскаля хранятся в .pas файлах - исходники OpenCL-C кода обычно хранят в .cl файлах.
Но вообще это не принципиально, потому что код даже не обязательно должен быть в файле.
Так как конструктор <code>ProgramCode</code> принимает текст - исходники программы на OpenCL-C можно хранить даже в строке в .pas программе.
Тем не менее, хранение исходников OpenCL-C кода в .cl файлах упрощает жизнь, потому что тогда их легко найти.</p>
</div>
<script>on_page_added(document.getElementById("page-13"))</script>
<div id="page-14" page_name="Создание из бинарного файла" hidden=true>
<h2><code>ToDo</code> в данный момент наблюдаются некоторые проблемы, возможно <code>ProgramCode.DeserializeFrom</code> реализован неправильно.</h2>
<p>После создания объекта типа <code>ProgramCode</code> из исходников можно вызвать
метод <code>ProgramCode.SerializeTo</code>, чтобы сохранить код в бинарном и прекомпилированном виде.
Обычно это делается отдельной программой (не той же самой, которая будет использовать этот бинарный код).</p>
<p>После этого основная программа может создать объект <code>ProgramCode</code>,
используя статический метод <code>ProgramCode.DeserializeFrom</code>.</p>
<p>К примеру, имеем следующий файл <code>0.cl</code>:</p>
<pre><code class="language-cl-c">__kernel void TEST(__global int* message)
{
	int gid = get_global_id(0);
	
	message[gid] += gid;
}
</code></pre>
<p>Для начала используем такую программу чтоб прекомпилировать его в бинарный файл:</p>
<pre><code>uses OpenCLABC;

begin
  var code := new ProgramCode(ReadAllText('0.cl'));
  
  var nf := System.IO.File.Create('0.bin');
  code.SerializeTo(nf);
  nf.Close;
  
end.
</code></pre>
<p>Затем готовый бинарный файл можно загрузить так:</p>
<pre><code>uses OpenCLABC;

begin
  {$resource '0.bin'} // добавляет 0.bin внутрь готового .exe файла
  
  var code := ProgramCode.DeserializeFrom(Context.Default, GetResourceStream('0.bin'));
  
  var A := new Buffer( 10 * sizeof(integer) );
  
  code['TEST'].Exec1(10,
    
    A.NewQueue.AddFillValue(1)
    as CommandQueue&lt;Buffer&gt;
    
  );
  
  A.GetArray1&amp;&lt;integer&gt;(10).Println;
  
end.
</code></pre>
</div>
<script>on_page_added(document.getElementById("page-14"))</script>
<script>on_end_folder()</script>
<div id="page-15" page_name="" hidden=true>
<p>Объект типа <code>Kernel</code> представляет одну подпрограмму в OpenCL-C коде,
объявленную с ключевым словом <code>__kernel</code>.</p>
<hr />
<p><code>Kernel</code> создаётся через индексное свойтсво <code>ProgramCode</code>:</p>
<pre><code>var k := code['KernelName'];
</code></pre>
<p>Где <code>code</code> имеет тип <code>ProgramCode</code>, а <code>'KernelName'</code> — имя подпрограммы-kernel'а в исходном коде (регистр важен!).</p>
<p>Пример выполнения kernel-а:</p>
<pre><code>uses OpenCLABC;

begin
  
  // проще всего - прямую считать текст исходника из файла:
//  var code_text := ReadAllText('0.cl');
  
  // но лучше добавить .cl файл внутрь .exe и загружать оттуда:
  {$resource '0.cl'}
  var code_text := System.IO.StreamReader.Create( GetResourceStream('0.cl') ).ReadToEnd;
  // так не нужно таскать .cl файл вместе с .exe
  
  var code := new ProgramCode(code_text);
  
  var A := new Buffer( 10 * sizeof(integer) ); // буфер на 10 чисел типа &quot;integer&quot;
  
  // 'TEST' - имя подпрограммы-кёрнела из .cl файла. Регистр важен!
  var kernel := code['TEST'];
  
  kernel.Exec1(10, // используем 10 потоков
    
    A.NewQueue.AddFillValue(1) // заполняем весь буфер единичками, прямо перед выполнением
    as CommandQueue&lt;Buffer&gt; //ToDo нужно только из за issue компилятора #1981, иначе получаем странную ошибку. Когда исправят - можно будет убрать
    
  );
  
  A.GetArray1&amp;&lt;integer&gt;.Println; // читаем весь буфер как одномерный массив с элементами типа &quot;integer&quot; и сразу выводим
  
end.
</code></pre>
<p>Файл <code>0.cl</code>:</p>
<pre><code class="language-cl-c">__kernel void TEST(__global int* message)
{
	int gid = get_global_id(0);
	
	message[gid] += gid;
}
</code></pre>
</div>
<script>on_start_folder("Kernel", document.getElementById("page-15"))</script>
<script>on_end_folder()</script>
<script>on_end_folder()</script>
</body>
</html>
