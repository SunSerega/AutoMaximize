<html>
<head>
<meta charset="utf-8">
<style>
/* ============================== *\
			 page base
\* ============================== */

body {
	background-color: #F0F0F0;
	margin: 0px;
}

.page-base {
	position: absolute;
}

#splitter {
	width: 5px;
	cursor: col-resize;
	box-shadow: 0 0 4px #B0B0B0;
}

.page-container {
	margin: 7.5px;
	background-color: white;
	overflow: auto;
}
#page-select-container {
	white-space: nowrap;
}

#page-display-container-body {
	padding: 7px;
	width: fit-content;
}

/* ============================== *\
		    page select
\* ============================== */

.arrow-page-root {
	cursor: pointer;
}
.dot-page-root {
	cursor: default;
	margin-left: 5px;
	margin-right: 6px;
}

.ps-root-container {
	margin: 7px;
}

.ps-folder {
	display: table;
}
.ps-folder-name {
	cursor: pointer;
    padding: 1;
}
.ps-container {
	margin-left: 7;
	padding-left: 7;
	border-left: thin solid;
	border-color: #80808080;
}

.ps-page {
}
.ps-page-name {
	cursor: pointer;
    padding: 1;
}

/* ============================== *\
	       page display
\* ============================== */

.smart-link {
	color: blue;
	cursor: pointer;
}

.spoiler {
	margin-left: 8px;
}
.spoiler-wrap {
	border-left: thin solid;
	padding-left: 2px;
}

.code-block {
	display: inline-block;
	cursor: text;
	background: #F0F0F0;
	border-radius: 3px;
	
	padding: 4px;
	padding-right: 12px;
	
	margin: 0;
	
}
.inline-code {
	background: #F0F0F0;
}

.code-keyword {
	font-weight: bold;
}
.code-build-in {
	color: blue;
}
.code-red {
	color: red;
	font-weight: bold;
}
.code-glowing-bracket {
	color: red;
	background-color: #C0C0C0;
}
</style>
</head>
<body>
<div class="page-base" id="page-select">
	<div class="page-container" id="page-select-container"></div>
</div>
<div class="page-base" id="page-display">
	<div class="page-container" id="page-display-container">
		<div id="page-display-container-body"></div>
	</div>
</div>
<div class="page-base" id="splitter"></div>
<script>
/* ============================== *\
		        misc
\* ============================== */

const selected_name_color = "#eaeaea";
const  pointed_name_color = "#d1faff";

var localStorageKey = "";

/* ============================== *\
		     page load
\* ============================== */

var root_folder = null;
var currently_loading_folder = null;

var prev_opened_folders = null;
var opened_folders = [];

var page_by_path = {};
const define_page_with_path = (path, page)=>{
	
	if (page_by_path[path])
		console.error(`page with path "${path}" defined multiple times`); else
		page_by_path[path] = page;
	
	if (broken_links[path])
	{
		for (let lnk of broken_links[path])
			lnk.fix(page);
		delete broken_links[path];
	}
	
}

const on_start_folder = (folder_name, root_page)=>{
	let res = {
		folders: [],
		pages: [],
		content_ref: root_page,
		container: document.createElement("div"),
		name: folder_name,
	};
	
	if (root_page)
	{
		root_page.tree_obj = res;
		document.getElementById("page-display-container-body").append(root_page);
	}
	
	if (!root_folder)
	{
		root_folder = res;
		res.path = "";
		
		localStorageKey = `spec : ${folder_name} : `;
		let prev_opened_folders_str = localStorage[localStorageKey+"opened_folders"];
		prev_opened_folders = prev_opened_folders_str ? JSON.parse(prev_opened_folders_str) : [];
		
		res.container.className = "ps-root-container";
		document.getElementById("page-select-container").append(res.container);
		if (root_page) select_page(root_page);
	} else
	{
		currently_loading_folder.folders.push(res);
		res.root = currently_loading_folder;
		res.path = res.root.path + folder_name + '/';
		
		res.body = document.createElement("div");
		res.body.className = "ps-folder";
		{
			let ind = prev_opened_folders.indexOf(res.path);
			res.state = ind!==-1;
			if (res.state)
			{
				prev_opened_folders.splice(ind,1);
				opened_folders.push(res.path);
			}
		}
		currently_loading_folder.container.append(res.body);
		
		res.update = ()=>{
			res.state_span.innerHTML = String.fromCharCode( res.empty? 0x2022 : res.state ? 0x25BC : 0x25BA );
			res.container.hidden = !res.state;
		}
		res.reverse_state = ()=>{
			res.state = !res.state;
			
			if (res.state)
				opened_folders.push(res.path); else
				opened_folders.splice(opened_folders.indexOf(res.path), 1);
			localStorage[localStorageKey+"opened_folders"] = JSON.stringify(opened_folders);
			
			res.update();
		};
		
		res.state_span = document.createElement("span");
		res.state_span.className = "dot-page-root";
		res.state_span.innerHTML = String.fromCharCode( 0x2022 );
		res.body.append(res.state_span);
		
		res.name_span = document.createElement("span");
		res.name_span.className = "ps-folder-name";
		res.name_span.innerHTML = folder_name;
		if (root_page) root_page.name_span = res.name_span;
		res.body.append(res.name_span);
		//
		if (root_page) res.name_span.addEventListener("click", ()=>select_page(root_page));
		res.name_span.addEventListener("mouseenter", ()=>{ if (is_selected(res.name_span)) res.name_span.style.backgroundColor=pointed_name_color; });
		res.name_span.addEventListener("mouseleave", ()=>{ if (is_selected(res.name_span)) res.name_span.style.backgroundColor="inherit"; });
		
		res.container.className = "ps-container";
		res.body.append(res.container);
		
	}
	
	currently_loading_folder = res;
	if (root_page) fix_links(root_page);
}

const on_page_added = (page)=>{
	document.getElementById("page-display-container-body").append(page);
	
	let res = {
		root: currently_loading_folder,
		name: page.getAttribute("page_name"),
	};
	res.path = currently_loading_folder.path + res.name;
	
	res.cont_div = document.createElement("div");
	res.cont_div.className = "ps-page";
	currently_loading_folder.container.append(res.cont_div);
	
	res.dot_span = document.createElement("span");
	res.dot_span.className = "dot-page-root";
	res.dot_span.innerHTML = String.fromCharCode( 0x2022 );
	res.cont_div.append(res.dot_span);
	
	res.name_span = document.createElement("span");
	res.name_span.innerHTML = res.name + "<br>";
	res.name_span.className = "ps-page-name";
	res.name_span.addEventListener("click", ()=>select_page(page));
	res.name_span.addEventListener("mouseenter", ()=>{ if (is_selected(res.name_span)) res.name_span.style.backgroundColor=pointed_name_color; });
	res.name_span.addEventListener("mouseleave", ()=>{ if (is_selected(res.name_span)) res.name_span.style.backgroundColor="inherit"; });
	res.cont_div.append(res.name_span);
	page.name_span = res.name_span;
	
	res.content_ref = page;
	page.tree_obj = res;
	
	currently_loading_folder.pages.push(res);
	define_page_with_path(res.path, page);
	fix_links(page);
	
	if (!selected_page && !document.location.hash) select_page(page);
}

const on_end_folder = ()=>{
	
	if (currently_loading_folder!=root_folder) {
		let folder = currently_loading_folder;
		
		if ( folder.folders.length || folder.pages.length )
		{
			folder.state_span.className = "arrow-page-root";
			folder.state_span.addEventListener("click", folder.reverse_state);
			folder.name_span.addEventListener("dblclick", folder.reverse_state);
			currently_loading_folder.update();
		} else
			folder.empty = true;
		
	}
	
	if (currently_loading_folder !== root_folder)
	{
		
		if (!currently_loading_folder.content_ref)
		{
			let res = document.createElement("div");
			res.hidden = true;
			res.name_span = currently_loading_folder.name_span;
			res.name_span.addEventListener("click", ()=>select_page(res));
			document.getElementById("page-display-container-body").append(res);
			currently_loading_folder.content_ref = res;
			res.tree_obj = currently_loading_folder;
			
			if (currently_loading_folder.folders.length)
			{
				let h = document.createElement("h1");
				h.innerHTML = "Под-папки:";
				res.append(h);
				
				let l = document.createElement("ul");
				for (let folder of currently_loading_folder.folders)
				{
					let li = document.createElement("li");
					li.innerHTML = folder.name_span.innerHTML;
					make_smart_link(li, folder.content_ref);
					l.append(li);
				}
				res.append(l);
				
			}
			
			if (currently_loading_folder.pages.length)
			{
				let h = document.createElement("h1");
				h.innerHTML = "Страницы:";
				res.append(h);
				
				let l = document.createElement("ul");
				for (let page of currently_loading_folder.pages)
				{
					let li = document.createElement("li");
					li.innerHTML = page.name_span.innerHTML;
					make_smart_link(li, page.content_ref);
					l.append(li);
				}
				res.append(l);
				
			}
			
		}
		
		define_page_with_path(currently_loading_folder.path, currently_loading_folder.content_ref);
		currently_loading_folder = currently_loading_folder.root;
	}
	
}

/* ============================== *\
	        page display
\* ============================== */

var selected_page = null;
const is_selected = (name_span)=>(!selected_page || selected_page.name_span!==name_span);
const select_page = (new_page)=>{
	if (selected_page == new_page) return;
	document.location.hash = new_page.tree_obj.path;
	fix_element(new_page);
	
	if (selected_page) {
		selected_page.hidden = true;
		let name_span = selected_page.name_span;
		if (name_span) name_span.style.backgroundColor = "inherit";
	}
	
	document.getElementById("page-display-container-body").scrollTop = 0;
	
	selected_page = new_page;
	if (selected_page)
	{
		selected_page.hidden = false;
		let name_span = selected_page.name_span;
		if (name_span) name_span.style.backgroundColor = selected_name_color;
		
		let tree_obj = new_page.tree_obj.root;
		while (tree_obj)
		{
			if ( tree_obj.state==false && tree_obj.reverse_state ) tree_obj.reverse_state();
			tree_obj = tree_obj.root;
		}
		
	}
	
}

const make_smart_link = (lnk, page)=>{
	lnk.className = "smart-link";
	lnk.addEventListener("click", ()=>select_page(page));
}

var broken_links = {};
const define_broken_lnk = (path, source, fixer)=>{
	if (!broken_links[path]) broken_links[path] = [];
	broken_links[path].push({
		source:	source,
		fix:	fixer,
	});
}

const fix_links = (page)=>{
	
	for (let lnk of page.getElementsByTagName('a'))
	{
		lnk.path = lnk.getAttribute("path");
		if (!lnk.path) continue;
		lnk.removeAttribute("path");
		
		start_folder = currently_loading_folder;
		while (lnk.path.startsWith("../"))
		{
			start_folder = start_folder.root;
			lnk.path = lnk.path.substr(3);
		}
		lnk.path = start_folder.path+lnk.path;
		
		let lnk_page = page_by_path[lnk.path];
		if (lnk_page)
			make_smart_link(lnk, lnk_page); else
			define_broken_lnk(lnk.path, page.tree_obj.path, new_page=>make_smart_link(lnk, new_page))
		
	}
	
}

const code_words_color = {
	"pas": {
		"keyword": ["begin", "end", "var", "uses", "as", "new", "try", "except", "on", "do", "const", "procedure", "function", "lock", "type", "class","record", "sizeof","typeof", "external", "static", "array", "where"],
		"build-in": ["nil", "string", "object", "shortint","byte", "smallint","word", "integer","longword","cardinal", "int64", "uint64", "single","real"],
		"red": ["ToDo"],
	},
	"cl-c": {
		"keyword": ["__kernel", "__global"],
		"build-in": ["int", "void"],
	},
	"default": {
		
	}
}

const fix_element = (page)=>{
	if (page.fixed) return;
	page.fixed = true;
	
	for (let spoiler of page.getElementsByClassName('spoiler'))
	{
		let get_spoiler_text = ()=> + ' ' + spoiler.getAttribute('summary');
		
		let wrap = document.createElement('p');
		wrap.className = "spoiler-wrap";
		wrap.update = ()=>{
			wrap.state_span.innerHTML = String.fromCharCode( 	spoiler.hidden ? 0x25BA : 0x25BC );
			wrap.style.border = 								spoiler.hidden ? "none" : null;
			wrap.style.marginLeft = 							spoiler.hidden ? "1px" 	: null;
		}
		
		wrap.state_span = document.createElement("span");
		wrap.update();
		wrap.append(wrap.state_span);
		
		wrap.name_span = document.createElement("span");
		wrap.name_span.innerHTML = spoiler.getAttribute("summary");
		wrap.append(wrap.name_span);
		
		wrap.reverse_state = ()=>{
			spoiler.hidden = !spoiler.hidden;
			wrap.update();
		}
		
		wrap.state_span.addEventListener("click", wrap.reverse_state);
		wrap.name_span.addEventListener("click", wrap.reverse_state);
		
		wrap.state_span.style.cursor = "pointer";
		wrap.name_span.style.cursor = "pointer";
		
		spoiler.replaceWith(wrap);
		wrap.append(spoiler);
	}
	
	for (let code of page.getElementsByTagName('code'))
	{
		let w_to_regex = (w)=>`(?<!\\w)${w}(?!\\w)`;
		
		// Автоопределение языка кода
		if (!code.className)
		{
			let best = {lang: null, c: 0};
			let multiple_best = true;
			
			for (let lang_name in code_words_color)
			{
				let c = 0;
				for (let wordt in code_words_color[lang_name])
					for (let w of code_words_color[lang_name][wordt])
					{
						var m = code.innerHTML.match(new RegExp( w_to_regex(w), "gi" ));
						if (m) c += m.length;
					}
				
				if (best.c == c)
					multiple_best = true; else
				if (best.c < c)
				{
					multiple_best = false;
					best.lang = lang_name;
					best.c = c;
				}
			}
			
			if (multiple_best)
				code.className = "language-default"; else
				code.className = "language-" + best.lang;
		}
		
		// Подсветка особых слов в коде
		{
			let lang = code.className.substr("language-".length);
			let curr_cw = code_words_color[lang];
			if (!curr_cw) curr_cw = code_words_color["default"];
			for (let wordt in curr_cw)
				code.innerHTML = code.innerHTML.replace(
					new RegExp(curr_cw[wordt].map(w_to_regex).join('|'),"gi"),
					w=> `<span class="code-${wordt}">${w}</span>`
				);
		}
		
		// Подсветка скобок
		{
			var br_types = {
				op: ["(", "[", "{", "&lt;", "'"],
				cl: [")", "]", "}", "&gt;", "'"],
			}
			for (let op in br_types)
				for (let i=0; i<br_types[op].length; i++)
					code.innerHTML = code.innerHTML.replace(
						new RegExp('\\'+br_types[op][i], "g"),
						`<span class=bracket ${ op=="op" ? "op=true" : "" } bt=${i}>${br_types[op][i]}</span>`
					);
			
			let br_st = [];
			for (let obj2 of code.getElementsByClassName("bracket"))
			{
				let b2t = obj2.getAttribute("bt");
				
				if (obj2.getAttribute("op"))
					br_st.push({
						obj: obj2,
						bt: b2t,
					}); else
				{
					let b1 = br_st.pop();
					let b0 = null;
					if (!b1) continue;
					if (b1.obj == obj2.parentElement)
					{
						b0 = b1;
						b1 = br_st.pop();
					}
					if (!b1) continue;
					if (b1.bt == b2t)
					{
						let obj1 = b1.obj;
						
						let on_enter = ()=>{
							obj1.className = "code-glowing-bracket";
							obj2.className = "code-glowing-bracket";
						}
						let on_leave = ()=>{
							obj1.className = null;
							obj2.className = null;
						}
						
						obj1.addEventListener("mouseenter", on_enter);
						obj2.addEventListener("mouseenter", on_enter);
						obj1.addEventListener("mouseleave", on_leave);
						obj2.addEventListener("mouseleave", on_leave);
					} else
					{
						br_st.push(b1);
						if (b0) br_st.push(b0);
					}
				}
				
			}
			
		}
		
		if (code.parentElement.tagName == "PRE")
		{
			let pre = code.parentElement;
			pre.className = 'code-block';
			
			let wrap = document.createElement('p');
			pre.replaceWith(wrap);
			wrap.append(pre);
			
		} else
			code.className = "inline-code";
		
	}
	
}

/* ============================== *\
		        init
\* ============================== */

{
	if (document.location.hash)
		define_broken_lnk(
			decodeURIComponent(document.location.hash.substr(1)),
			"document.location.hash",
			page=>select_page(page)
		);
	
	let page_select = document.getElementById("page-select");
	let page_display = document.getElementById("page-display");
	let splitter = document.getElementById("splitter");
	
	let ww = window.innerWidth;
	let wh = window.innerHeight;
	
	for (let cont of document.getElementsByClassName("page-container"))
	{
		let par = cont.parentElement;
		par.update_cont = (w)=>{
			cont.style.width = w-15 + "px";
			cont.style.height = wh-15 + "px";
		};
	}
	
	let spl_X = ww * 0.30;
	const reset_spl = ()=>{
		ww = window.innerWidth;
		wh = window.innerHeight;
		
		page_select.style.height = wh + "px";
		splitter.style.height = wh + "px";
		page_display.style.height = wh + "px";
		
		if (ww-5<spl_X) spl_X = ww-5;
		if (spl_X<5) spl_X = 5;
		
		page_select.style.width = spl_X + "px";
		splitter.style.left = spl_X + "px";
		let x2 = spl_X+splitter.clientWidth;
		let w2 = ww - x2;
		page_display.style.left = x2 + "px";
		page_display.style.width = w2 + "px";
		
		page_select.update_cont(spl_X);
		page_display.update_cont(w2);
	}
	reset_spl();
	
	window.onresize = ()=>reset_spl();
	
	splitter.addEventListener("dblclick", ()=>{
		let w = 0;
		let psc = document.getElementsByClassName("page-container")[0];
		let psc2 = psc.children[0];
		for (let n of psc2.children)
			if (n.clientWidth>w) w = n.clientWidth;
		
		let get_margin = (el)=>{
			let style = el.currentStyle || window.getComputedStyle(el);
			return parseFloat(style.marginLeft) + parseFloat(style.marginRight);
		}
		
		spl_X = w +
			get_margin(psc) +
			get_margin(psc2)
		;
		reset_spl();
	});
	
	let spl_grabed = false;
	splitter.addEventListener("mousedown", (e)=>{
		spl_grabed=true;
		e.preventDefault();
	});
	window.addEventListener("mousemove", (e)=>{if (spl_grabed) {
		spl_X = e.clientX - splitter.clientWidth/2;
		reset_spl();
		e.preventDefault();
	}});
	window.addEventListener("mouseup", ()=>spl_grabed=false);
	
}

window.onload = ()=>{
	
	for (path in broken_links)
		console.error(`Page "${path}" referenced ${broken_links[path].length} times but not found:`, broken_links[path].map(lnk=>lnk.source));
	
	localStorage[localStorageKey+"opened_folders"] = JSON.stringify(opened_folders);
	if (prev_opened_folders.length) console.log("folders were marked as opened, but not found:", prev_opened_folders);
	delete prev_opened_folders;
	
}
</script>
<script>on_start_folder("Nativ Interop", null)</script>
<script>on_start_folder("Общие сведения", null)</script>
<div id="page-1" page_name="О справке" hidden=true>
<p>Данная справка рассказывает про подводные камни при работе с неуправляемыми .dll,
которые можно встретить при работе с модулями <code>OpenGL</code> и <code>OpenCL</code>, входящеми в состав стандартных модулей языка PascalABC.NET.</p>
<p>Справки по соответствующим библиотекам:</p>
<ul>
<li><a href="https://www.khronos.org/registry/OpenGL/specs/gl/">OpenGL.dll</a></li>
<li><a href="https://www.khronos.org/registry/OpenCL/">OpenCL.dll</a></li>
</ul>
<p>(Далее &quot;исходные библиотеки&quot; относится сразу к обоим этим библиотекам)</p>
<p>Отдельных справок по модулям <code>OpenGL</code> и <code>OpenCL</code> (далее просто &quot;н.у. модули&quot;, н.у. значит &quot;низко-уровневые&quot;)
нет, потому что они сделаны по общим принципам:</p>
<ol>
<li><p>Эти модули представляют весь возможный функционал из своих соответствующих .dll</p>
</li>
<li><p>Но при этом балансируют между максимальными удобством и низко-уровневостью.</p>
</li>
</ol>
<p>Если нужна высоко-уровневость - используйте соответственно модули
<a href="%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0%20OpenGLABC.html">OpenGLABC</a>
и
<a href="%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%B0%20OpenCLABC.html">OpenCLABC</a>
.</p>
<p>Но всё же, у модуля <code>OpenGL</code> есть типы которые можно считать высоко-уровневыми: типы векторов и матриц.<br />
Для них в этой справке есть <a path="Особые типы модуля OpenGL">отдельная страница</a>.</p>
<hr />
<p>Н.у. модули созданы как промежуточная точка между библиотеками и модулями <code>OpenGLABC</code> и <code>OpenCLABC</code>,
на случай если вы хотите использовать OpenGL и/или OpenCL, но хотите написать свою высоко-уровневую оболочку.
Возможно, ради опыта. Возможно, ради особых оптимизаций. И т.п.</p>
<p>Если вы будете использовать только модули <code>OpenGLABC</code> и <code>OpenCLABC</code> - данная справка вам не нужна,
потому что <code>OpenGLABC</code> и <code>OpenCLABC</code> специально созданы так, чтоб отстранить программиста от всех сложностей
работы с неуправляемыми .dll и предоставить привычный ООП интерфейс со всевозможными удобствами.</p>
<hr />
<p>Если:</p>
<ul>
<li><p>В н.у. модулях или данной справке найдена ошибка или чего-либо не хватает;</p>
</li>
<li><p>Вы наткнулись на какую то особенностью работы с неуправляемыми .dll, которая тут не (или недо-) описана;</p>
</li>
<li><p>Или вы хотите по какой-либо другой причине (касающейся этих модулей или справки) рассказать мне какой я дурак:</p>
</li>
</ul>
<p>Пишите в <a href="https://github.com/SunSerega/POCGL/issues">issue</a>.</p>
</div>
<script>on_page_added(document.getElementById("page-1"))</script>
<div id="page-2" page_name="О неуправляемых .dll" hidden=true>
<p>Лучше прочитайте <a href="https://docs.microsoft.com/en-us/dotnet/standard/managed-code">оффициальный документ от microsoft</a>, если хотите точной и подробно информации.</p>
<p>Если в кратце:</p>
<p>Есть платформа .Net, объединяющая много языков программирования. В том числе C# и PascalABC.NET.</p>
<p>.exe и .dll созданные такими языками содержат код в особом виде,
позволяющем легко подключать .dll созданные на 1 .Net языке к программе на любом другом .Net языке.</p>
<p>Такие .exe и .dll называются управляемыми. .exe и .dll созданные на любом другом (то есть не .Net) языке называются неуправляемыми.</p>
<p>OpenCL.dll и OpenGL.dll созданы на- и для языков C/C++, поэтому являются неуправляемыми.</p>
<hr />
<p>Неуправляемые .dll могут содержать только глобальные подпрограммы.</p>
<p>Для получения подпрограммы из неуправляемой .dll - в PABC.Net используется <code>external</code> (как использовать - смотрите в справке PABC.Net).</p>
<p>Так же можно использовать всеобщий .Net-овский атрибут <code>DllImport</code>. О нём можно прочитать на том же сайте microsoft'а, ссылка выше.</p>
<p>Но это вам вряд ли понадобится, н.у. модули сами справляются с получением функций.</p>
<hr />
<p>Большинство проблем при использовании неуправляемых .dll - вытекают из следующих 2 различий:</p>
<ol>
<li><p>Все типы, в том числе строки и массивы - в .Net описаны как общие типы, доступные для всех .Net языков.</p>
<p>А в C++ строки и массивы не только описаны не так же как в .Net . У них так же есть множество разных стандартов. Благо, исходные библиотеки придерживаются 1 общего стандарта.</p>
</li>
<li><p>В управляемом коде оперативная память (дальше просто память) обычно управляется сборщиком мусора. Поэтому если создать массив - когда он стал не нужен о нём можно просто забыть.</p>
<p>А в C++ память управляется только самим программистом, поэтому неуправляемую память нужно всегда освобождать после использования.<br />
Забытая и не_освобождённая неуправляемая память называется утечкой памяти. И это 1 из самых сложно-ловимых багов, потому что у него нет явно видимых симптомов, вроде вызова ошибки, пока память окончательно не закончится.</p>
</li>
</ol>
<p>В .Net так же можно выделять и освобождать неуправляемую память, статичными методами класса <code>Marshal</code>. Обычно это надо для п.1., для преобразований между .Net и неуправляемыми типами.</p>
<p>Полное имя класса <code>Marshal</code> это <code>System.Runtime.InteropServices.Marshal</code>. Но Чтоб не писать его целиком - можно написать в начале файла <code>uses System.Runtime.InteropServices</code>, и дальше использовать просто <code>Marshal</code>.</p>
<hr />
<p>Стоит так же заметить, что в н.у. модулях все подпрограммы, напрямую вызывающие подпрограммы
из неуправляемых .dll - принимают параметрами как неуправляемые, так и управляемые типы
массивов и строк (самостоятельно выполняя преобразования), по мере необходимости.<br />
Если ваша необходимость не удовлетворена (то есть не хватает перегрузки с управляемым типом) - это особо хороший повод написать в issue.</p>
</div>
<script>on_page_added(document.getElementById("page-2"))</script>
<div id="page-3" page_name="Особые типы модуля OpenGL" hidden=true>
<p>Среди всех типов-записей, которые можно найти в н.у. модулях, модуль <code>OpenGL</code> так же содержит типы векторов и матриц.</p>
<p>Они особенны тем, что поддерживают некоторые математические операции,
которые можно считать высокоуровневыми, а значит противоречущими основным принципам н.у. модулей.</p>
<p>Но реализовывать их все в качестве <code>extensionmethod</code>'ов было бы сложно, не красиво, а в случае статичных методов - ещё и невозможно.</p>
<hr />
<h1>Векторы</h1>
<p>Все типы векторов можно описать разом как <code>Vec[1,2,3,4][ b,ub, s,us, i,ui, i64,ui64, f,d ]</code>.</p>
<p>Если вы уже прочитали спецификацию OpenGL.dll (что в любом случае стоит сделать) - вы уже поняли как это прочитать. Если нет:</p>
<div class="spoiler" summary="Подробнее" hidden="true"><p>Каждый тип вектора берёт по 1 из строк, перечисленных в <code>[]</code>, через запятую.</p>
<p>К примеру, есть <code>Vec2d</code> и <code>Vec4ui64</code>.</p>
<p>Число в первых скобках - значит кол-во измерений вектора.</p>
<p>Буква (буквы) в следующих скобках - значит тип координат вектора:</p>
<ul>
<li><p><code>b=shortint</code>, <code>s=smallint</code>, <code>i=integer</code>, <code>i64=int64</code>: Все 4 типа - целые числа со знаком (±), на 1, 2, 4 и 8 байт соответственно;</p>
</li>
<li><p>Они же но с приставкой <code>u</code> - целые числа без знака. К примеру <code>ui</code> значит целое на 4 байта без знака, то есть <code>longword</code> (он же <code>cardinal</code>);</p>
</li>
<li><p>f=<code>single</code> и d=<code>real</code> - числа с плавающей запятой, на 4 и 8 байт соответственно.</p>
</li>
</ul>
<p>Таким образом <code>Vec2d</code> хранит 2 числа типа <code>real</code>, а <code>Vec4ui64</code> хранит 4 числа типа <code>uint64</code>.</p>
</div>
<h3>Свойства</h3>
<p>У векторов есть только индексное свойство <code>val</code>. Оно принимает индекс, считаемый от 0, и возвращает или задаёт значение вектора для соответствующего измерения.</p>
<p>К примеру:</p>
<pre><code>var v: Vec4d;
v[0] := 123.456; // записываем 123.456 по индексу 0
v[1].Println; // читаем и выводим значение по индексу 1
v.val[2] := 1; // можно так же писать и имя свойства
</code></pre>
<p>Но использование этого свойства не рекомендуется. Обычно, прямое обращение к полю будет быстрее. То есть аналогично предыдущему коду:</p>
<pre><code>var v: Vec4d;
v.val0 := 123.456;
v.val1.Println;
v.val2 := 1;
</code></pre>
<p>Используйте свойство <code>val</code> только тогда, когда индекс это НЕ константа.</p>
<h3>Унарные операторы</h3>
<pre><code>var v0: Vec4d;
...
var v1 := -v0; // v1 будет иметь ту же длину, но противоположное v0 направление
var v2 := +v0; // а унарный + не делает ничего, он только для красоты. То есть v2 будет =v0
</code></pre>
<h3>Умножение/деление на скаляр</h3>
<pre><code>var v1: Vec4d;
var v2: Vec4i;
...
(v1*2).Println; // выведет вектор, имеющий то же направление что v1, но в 2 раза длиннее
(v1/2).Println; // выведет вектор, имеющий то же направление что v1, но в 2 раза короче
(v2 div 2).Println; // к целочисленным векторам - вместо обычного деления надо применять div
</code></pre>
<h3>Операции с 2 векторами</h3>
<pre><code>var v1, v2: Vec4d;
...
(v1*v2).Println; // скалярное произведение векторов
(v1+v2).Println; // сумма векторов, складывает отдельно каждый элемент вектора
(v1-v2).Println; // разность векторов, так же работает отдельно на каждый элемент вектора
</code></pre>
<p>Чтоб применить 1 из этих операций к 2 векторам - их типы должны быть одинаковые.<br />
Если это не так - 1 из них (или оба) надо явно преобразовать, так чтоб типы были одинаковые:</p>
<pre><code>var v1: Vec4d;
var v2: Vec2i;
...
( v1 + Vec4d(v2) ).Println;
</code></pre>
<h3>SqrLength</h3>
<p>Метод <code>.SqrLength</code> возвращает квадрат длины (то есть модуля) вектора.<br />
Возвращаемый тип <code>.SqrLength</code> совпадает с типом элементов вектора.<br />
Каким образом находить корень полученного значения - дело программиста.</p>
<pre><code>var v1: Vec4d;
...
v1.SqrLength.Println; // квадрат длины
v1.SqrLength.Sqrt.Println; // сама длина
</code></pre>
<h3>Normalized</h3>
<p>Метод <code>.Normalized</code> возвращает нормализированную (с длиной =1) версию вектора.<br />
Так как эта операция требует деления - она применима только к векторам с элементами типов <code>single</code> или <code>real</code> (<code>f</code> или <code>d</code>).</p>
<pre><code>var v1 := new Vec3d(1,1,1);
v1.Println;
v1.SqrLength.Sqrt.Println;
var v2 := v1.Normalized;
v2.Println;
v2.SqrLength.Sqrt.Println; // обязательно будет 1
</code></pre>
<h3>Cross</h3>
<p>Статичный метод <code>.Cross</code> возвращает произведение векторов (Cross product, не путать со скалярным произведением).
Векторное произведение - это вектор, перпендикулярный обоим входным векторам и имеющий длину, равную площади параллелограмма, образованного входными векторами.</p>
<p>Работает только для 3-х мерных векторов.</p>
<p>И не работает для векторов с элементами-беззнаковыми целыми.<br />
(потому что даёт переполнение на практически любых входных значениях. Если найдёте нормальное применение - напишите в issue).</p>
<p>В математике произведение векторов может вернуть 2 противоположных друг другу вектора,
в зависимости от ориентации системы координат. В OpenGL.pas это решено следующим образом:</p>
<pre><code>var c := Vec3d.Cross(a,b);
</code></pre>
<p>В данном случае, вектор <code>c</code> будет такой, чтоб соблюдалось следующее условие:</p>
<ul>
<li>Если поставить начала всех 3 векторов в точку (0;0;0), а камеру в точку (a+b+c) и направить в точку (0;0;0) - вектора a, b и c будут расположены по часовой стрелке вокруг центра экрана.</li>
</ul>
<p>Если надо чтоб было против часовой стрелки - можно использовать CCW (counter clock wise, против часовой стрелки) версию <code>.Cross</code>:</p>
<pre><code>var c := Vec3d.CrossCCW(a,b);
</code></pre>
<p>(ну или можно использовать <code>-Vec3d.Cross(a,b)</code>, это даст тот же результат но с 1 лишней операцией)</p>
<h3>Превращение в строку</h3>
<pre><code>var v1: Vec4d;
...
v1.Println; // вывод вектора
var s := v1.ToString; // s присвоит ту же строку, что выводит .Println
</code></pre>
<p>Методы <code>.ToString</code> и <code>.Println</code> должны быть использованы только для чего то вроде дебага или красивого вывода,
потому что операции со строками это в целом медленно.</p>
<hr />
<h1>Матрицы</h1>
<p>Все типы матриц можно описать разом как <code>Mtr[2,3,4]x[2,3,4][f,d]</code>.</p>
<p>Но у каждой квадратной матрицы есть короткий синоним.<br />
К примеру вместо <code>Mtr3x3d</code> можно писать <code>Mtr3d</code>.</p>
<p>Так же стоит заметить - конструктор матрицы принимает элементы по строкам, но в самой матрице элементы хранятся в транспонированном виде.</p>
<p>Это потому, что в OpenGL.dll в шейдерах матрицы хранятся по столбцам.<br />
Но в если создавать матрицу конструктором - элементы удобнее передавать по строкам, вот так:</p>
<pre><code>var m := new Mtr3d(
  1,2,3, // (1;2;3) станет нулевой строкой матрицы
  4,5,6,
  7,8,9
);
</code></pre>
<h3>Свойства</h3>
<p>Как и у векторов, у матриц есть свойство <code>val</code>:</p>
<pre><code>var m: Mtr4d;
m[0,0] := 123.456;
m[1,2].Println;
m.val[3,1] := 1;
</code></pre>
<p>И как и у векторов - <code>val</code> всегда медленнее прямого обращения к полям:</p>
<pre><code>var m: Mtr4d;
m.val00 := 123.456;
m.val12.Println;
m.val31 := 1;
</code></pre>
<p>Но у матриц так же есть свойства для столбцов и строк:</p>
<pre><code>var m: Mtr3d;
...
m.Row0.Println; // вывод нулевой строчки в виде вектора
m.Row1 := new Vec3d(1,2,3);
m.Col2.Println;
</code></pre>
<p>И в качестве аналога <code>val</code> - строку и стобец тоже можно получать по динамическому индексу (но, опять же, это медленнее):</p>
<pre><code>var m: Mtr3d;
...
m.Row[0].Println; // вывод нулевой строчки в виде вектора
m.Row[1] := new Vec3d(1,2,3);
m.Col[2].Println;
</code></pre>
<p>Для столбцов так же есть особые свойства, возвращающие не столбец, а его адрес в памяти:</p>
<pre><code>var m: Mtr3d;
...
var ptr1 := m.ColPtr0;
var ptr2 := m.ColPtr[3];
</code></pre>
<p>Но используйте это свойство на свой страх и риск:<br />
Получение адреса для того, что не находится на стеке или в неуправляемой памяти -
может давать ошибки доступа, когда сборщик мусора перемещает память.</p>
<h3>Identity</h3>
<p>Это тоже свойство, но статичное и применение совершенно другое:</p>
<p><code>Identity</code> создаёт новую единичную матрицу. То есть матрицу, у которой главная диагональ заполнена 1, а всё останое заполнено 0.</p>
<pre><code>Mtr3d.Identity.Println;

// работает и для не_квадратных матриц
Mtr2x3d.Identity.Println; // выводит такую матрицу:
// 1 0 0
// 0 1 0
</code></pre>
<h3>Scale</h3>
<p>Статичный метод <code>.Scale</code> возвращает матрицу, при умножении на которую вектор маштабируется в k раз.</p>
<pre><code>var m := Mtr3d.Scale(2);
var v := new Vec3d(1,2,3);
(m*v).Println; // (2;4;6)
</code></pre>
<h3>Translate</h3>
<p>Статичный метод <code>.Translate</code> возвращает матрицу, при умножении на которую к вектору добавляется заданное значение.</p>
<pre><code>var m := Mtr4d.Translate(1,2,3);
var v := new Vec4d(0,0,0,1); // последнее значение должно быть 1, чтоб матрица из Translate работала адекватно
(m*v).Println; // (1;2;3)
</code></pre>
<p>Так же есть статичный метод <code>.TraslateTransposed</code>. Он возвращает то же самое что <code>.Translate</code>, но транспонированное.</p>
<h3>2D вращение</h3>
<p>Группа статичных методов <code>.Rotate[XY,YZ,ZX][cw,ccw]</code> возвращает матрицу вращения в определённой плоскости.</p>
<p>Первые скобки определяют плоскость.<br />
(Но у 2x2 матриц только XY вариант)</p>
<p>Вторые скобки определяют направление вращения:</p>
<ul>
<li>cw (clock wise) значит по часовой стрелке</li>
<li>ccw (counter clock wise) значит против часовой стрелки</li>
</ul>
<h3>3D вращение</h3>
<p>Группа статичных методов <code>.Rotate3D[cw,ccw]</code> возвращает матрицу вращения вокруг нормализованного 3-х мерного вектора.
(разумеется, не существует для матриц 2x2,2x3 и 3x2)</p>
<h3>Det</h3>
<p>Метод <code>.Det</code> возвращает определитель матрицы. Существует только для квадратных матриц.</p>
<h3>Transpose</h3>
<p>Метод <code>.Transpose</code> возвращает транспонированную версию матрицы:</p>
<pre><code>var m := new Mtr2x3d(
  1,2,3,
  4,5,6
);
m.Transpose.Println; // выводит:
// 1 4
// 2 5
// 3 6
</code></pre>
<h3>Умножение матрицы и вектора</h3>
<p><code>m*v</code> - это обычное умножение матрицы <code>m</code> на вектор <code>v</code>, возвращающее результат после применения преобразования из <code>m</code> к <code>v</code>.</p>
<p>Но так же как в шейдерах - поддерживается и обратная запись:<br />
<code>v*m</code> это то же самое что <code>m.Transpose*v</code>.</p>
<h3>Умножение 2 матриц</h3>
<p><code>m1*m2</code> - это обычное умножение матрицы <code>m1</code> на матрицу <code>m2</code>.</p>
<h3>Превращение в строку</h3>
<p>Как и у векторов - матрицы можно выводить и превращать в строку</p>
<pre><code>var m: Mtr4d;
...
m.Println; // вывод матрицы
var s := m.ToString; // s присвоит ту же строку, что выводит .Println
</code></pre>
<p>Для того чтоб матрица выведенная 1 из этих методов выглядела красиво -
надо использовать моноширный шрифт и поддерживать юникод (потому что для матриц - используются символы псевдографики).</p>
<p>Обычно это не проблема для <code>.Println</code>, потому что и консоль и окно вывода в IDE имеют моноширный шрифт и поддерживают юникод.</p>
<p>Но если выводить на форму - придётся специально поставить моноширный шрифт.<br />
А если выводить в файл - надо выбрать кодировку файла - юникод (UTF8).</p>
</div>
<script>on_page_added(document.getElementById("page-3"))</script>
<script>on_end_folder()</script>
<script>on_start_folder("Простейшие типы", null)</script>
<div id="page-4" page_name="var-параметры" hidden=true>
<p>В .Net <code>var</code>-параметры реализованы через указатели. То есть эти 2 кода:</p>
<pre><code>procedure p1(var i: integer);
begin
  i.Println;
  i := 5;
end;

begin
  var i := 3;
  p1(i);
  i.Println;
end.
</code></pre>
<pre><code>procedure p1(i: ^integer);
begin
  i^.Println;
  i^ := 5;
end;

begin
  var i := 3;
  p1(@i);
  i.Println;
end.
</code></pre>
<p>Генерируют практически одинаковые .exe .</p>
<p>Отличие состоит в том, что передавать содержимое класса (к примеру массива)
<code>var</code>-параметром безопастно.</p>
<p>В то же время если передавать указатель на содержимое класса - сборщик мусора
может в любой момент переместить память, ломая указатель.</p>
<p>Статичные поля так же могут быть перемещены, как и содержимое экземпляров,
даже если они имеют размерный тип.</p>
<p>А захваченные лямбдой переменные - превращаются в поля специального анонимного
класса, поэтому, опять же, могут быть перемещены даже если у них размерный тип.</p>
</div>
<script>on_page_added(document.getElementById("page-4"))</script>
<div id="page-5" page_name="Тесты эффектов сборщика мусора" hidden=true>
<p>Кроме удаления неиспользуемых экземпляров классов, сборщик мусора так же может произвольно
перемещать используемые объекты, более плотно их упаковая их в памяти.</p>
<p>И он прекрасно справляется с тем, чтоб сделать эти перемещения незаметными, в обычных ситуациях.
Но как только речь находит об указателях и неуправляемом коде - начинаются проблемы.
Чтоб избажать их, надо очень хорошо понимать как работает сборщик мусора.</p>
<div class="spoiler" summary="Страницы в данной папке операются на результаты теста:" hidden="true">
<pre><code>uses System;
uses System.Runtime.InteropServices;

type
  punch_gc_callback = procedure(ptr: pointer);
  
function get_addr(a: array of integer) := '$'+Marshal.UnsafeAddrOfPinnedArrayElement(a,0).ToString('X');

function ptr_adr&lt;T&gt;(var a: T) := new IntPtr(@a);

function copy_arr(a: IntPtr; punch_gc: punch_gc_callback): IntPtr;
external 'Dll1.dll';
function copy_arr(a: ^integer; punch_gc: punch_gc_callback): IntPtr;
external 'Dll1.dll';

function copy_arr(var a: integer; punch_gc: punch_gc_callback): IntPtr;
external 'Dll1.dll';
function copy_arr(var a: byte; punch_gc: punch_gc_callback): IntPtr;
external 'Dll1.dll';

function copy_arr([MarshalAs(UnmanagedType.LPArray)] a: array of integer; punch_gc: punch_gc_callback): IntPtr;
external 'Dll1.dll';

function copy_arr_recall1(var a: integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr(@a, punch_gc);

function copy_arr_recall2(a: array of integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr(a, punch_gc);

function copy_arr_recall3(var a: integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr(a, punch_gc);

function copy_arr_recall4_helper(a: ^integer; punch_gc: punch_gc_callback): IntPtr;
begin
  punch_gc(a);
  Result := copy_arr(a^, ptr-&gt;begin end); // второй раз вызывать punch_gc и вывод - ни к чему, всё ломается уже на предыдущей строчке
end;
function copy_arr_recall4(var a: integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr_recall4_helper(@a, punch_gc);

function copy_arr_recall5(var a: integer; punch_gc: punch_gc_callback): IntPtr :=
copy_arr(PByte(pointer(@a))^, punch_gc);

// У меня это вызывает смещение массива в памяти, но только при первом вызове
// Writeln тоже вызывает этот метод, поэтому придётся обходиться Console.WriteLine
// Вообще это ужастный костыль, но я не знаю ничего лучше
procedure punch_gc := System.Diagnostics.Debug.WriteLine('');

begin
  var a := Arr(1,2,3,4,5,6);
  var b := Arr(1,2,3,4,5);
  Console.WriteLine('begin');
  Console.WriteLine(get_addr(a));
  Console.WriteLine(get_addr(b));
  
  // punch_gc работает только 1 раз, эти строчки только чтоб протестировать, работает ли он у вас вообще
//  punch_gc;
//  Console.WriteLine('after first gc');
//  Console.WriteLine(get_addr(a));
//  Console.WriteLine(get_addr(b));
  
  {$region заголовки вызова copy_arr}
  
  // безопастно
//  var ptr := copy_arr(a,              // передавать как массив безопастно
//  var ptr := copy_arr(a[0],           // передавать элемент массива var-параметром безопастно
//  var ptr := copy_arr(a[1],           // и это касается не только элемента [0]
//  var ptr := copy_arr_recall2(a,      // безопастно, потому что с точки зрения copy_arr_recall2 ситуация та же что &quot;copy_arr(a,&quot;
//  var ptr := copy_arr_recall3(a[0],   // и var-параметры тоже безопастны через промежуточные подпрограммы
//  var ptr := copy_arr_recall5(a[0],   // тут указатели не попадают в готовый .exe, они только чтоб испокоить компилятор, поэтому безопастно
  
  // НЕ безопастно
//  var ptr := copy_arr(Marshal.UnsafeAddrOfPinnedArrayElement(a,0), ptr-&gt; // GC не следит за содержимым IntPtr
//  var ptr := copy_arr(ptr_adr(a[0]),  // и за другими формами указателей тоже
//  var ptr := copy_arr_recall1(a[0],   // проблема не в передаче адреса возвращаемым значением
//  var ptr := copy_arr_recall4(a[0],   // кроме того, проблема вообще не в неуправляемом коде, в управляемом тоже воспроизводится
  
  {$endregion заголовки вызова copy_arr}
  
  var ptr := copy_arr(a,
  ptr-&gt;
  begin
    Console.WriteLine('before gc');
    Console.WriteLine(get_addr(a));
    Console.WriteLine('$'+IntPtr(ptr).ToString('X'));
    Console.WriteLine(get_addr(b));
    
    // &quot;b&quot; в любом случае перемещается при punch_gc, его ничего не держит. Таким образом оно показывает что punch_gc успешно сработал
    // Но главное тут - если &quot;ptr&quot; и &quot;a&quot; окажутся разным, значит неуправляемый код потерял настоящий адрес &quot;a&quot; при перемещении
    // Тесты приведённые тут показывают так же что GC вообще не перемещает &quot;a&quot; в любом безопасном сценарии. И никогда не меняет &quot;ptr&quot;
    punch_gc;
    Console.WriteLine('after gc');
    Console.WriteLine(get_addr(a));
    Console.WriteLine('$'+IntPtr(ptr).ToString('X'));
    Console.WriteLine(get_addr(b));
  end);
  
  Console.WriteLine('end');
  Console.WriteLine(get_addr(a));
  Console.WriteLine(get_addr(b));
  
//  punch_gc;
//  Console.WriteLine('after last gc');
//  Console.WriteLine(get_addr(a));
//  Console.WriteLine(get_addr(b));
  
  // Показывает эффекты НЕ безопастного вызова
  // Точнее если неуправляемый код потеряет адрес массива,
  // то тут будет мусор (или ошибку доступа, но её я ни разу не получил)
  // вместо того, что было содержимым массива
  var res := new byte[20];
  Marshal.Copy(ptr,res,0,20);
  res.Println;
end.
</code></pre>
<p><code>Dll1.dll</code> должна быть неуправляемой библиотекой, содержащей следующую функцию (это C++):</p>
<pre><code>extern &quot;C&quot; __declspec(dllexport) BYTE* copy_arr(int* a, void (*punch_gc)(void*))
{
    BYTE* res = new BYTE[20]; // выделяем 20 байт неуправляемой памяти
    punch_gc(a); // вызываем ту подпрограмму, чей адрес сюда передали
    memcpy(res, a, 20); // копируем 20 байт из &quot;a&quot; в &quot;res&quot;
    return res; // плохо что неуправляемая память не освобождается, но в этом тесте не важно
}
</code></pre>
<p>Подробнее о параметрах:</p>
<ol>
<li><p><code>a</code> принимает указатель на <code>integer</code>, что в C++ так же может являеться массивом с элементами типа <code>integer</code>;</p>
</li>
<li><p><code>punch_gc</code> принемает адрес подпрограммы, принемающей <code>void*</code> (безтиповый указатель)
и возвращающей <code>void</code> (ничего не возвращающей, то есть это процедура);</p>
</li>
<li><p>Ну и возвращаемое значение - <code>BYTE*</code>. Так же как <code>a</code>, вообще указатель, но в данном случае массив.</p>
</li>
</ol>
<p>Пожалуйста, попробуйте поэксперементировать с этим кодом сами. И если найдёте
что то интересное - обязательно напишите в issue. В этом деле много тестов не бывает.</p>
</div>
<h3>В кратце:</h3>
<p>Вся безопастность зависит только от объявления подпрограммы. Если подпрограмма принимает:</p>
<ul>
<li><p>Массив или <code>var</code>-параметр:<br />
Пока вызов не завершится - сборщик мусора НЕ будет передвигать объект в памяти.</p>
</li>
<li><p>Указатель в любом виде (типизированный, безтиповый или даже обёрнутый в запись вроде <code>IntPtr</code>):<br />
Передавать адрес содержимого класса НЕ безопастно.</p>
</li>
<li><p>Любой размерный тип (то есть запись):<br />
Сборщик мусора никак не управляет записями, при передаче в
подпрограмму их значение копируется. Поэтому это всегда безопастно.</p>
</li>
</ul>
</div>
<script>on_page_added(document.getElementById("page-5"))</script>
<div id="page-6" page_name="Массивы" hidden=true>
<p>В .Net массивы хранят не только содержимое, но и данные о своём размере.</p>
<p>А в C++ вместо обычных массивов используется безформенная область памяти.<br />
При её выделении - в переменную записывается указатель <code>[0]</code> элемента.
А о том чтоб сохранить данные о размере этой области - должен позаботится программист.<br />
(вообще обычно в C++ используют обёртки, хранящие длину так же как .Net массивы. Но OpenGL.dll и OpenCL.dll это не касается)</p>
<hr />
<p>Если вы видели старые коды с использованием OpenGL из какого то из паскалей - наверняка видели что то такое:</p>
<pre><code>glИмяПодпрограммы(@a[0]);
</code></pre>
<p>Но в PascalABC.Net так делать нельзя! Получение адреса элемента массива моментально создаёт утечку памяти,
потому что компилятор, на всякий случай, вставляет полную блокировку массива в памяти, используя <code>GCHandle</code> с <code>GCHandleType.Pinned</code>.</p>
<p>Такая блокировка нужна, потому что иначе полученный указатель может в любой момент стать устаревшим.</p>
<p>Обычно <code>GCHandle</code> освобождают методом <code>.Free</code>. Но если позволить компилятору использовать
<code>GCHandle</code> - освобождение никогда не произойдёт, потому что компилятор не знает когда указатель уже не нужен.</p>
<hr />
<p>Из очевидных вариантов - использовать <code>GCHandle</code> самостоятельно. Он создаётся статичным методом <code>GCHandle.Alloc</code>.
Далее, адрес можно получить методом <code>GCHandle.AddrOfPinnedObject</code>.</p>
<p>Но <code>GCHandle</code> довольно ограничен. К примеру, он может заблокировать <code>array of char</code>, но не <code>array of r</code>,
для <code>r</code> - запись, содержащая поле типа <code>char</code>. И то же самое с <code>DateTime</code> и ещё несколькими стандартными
типами, которые <code>GCHandle</code> считает &quot;опасными&quot;.</p>
<hr />
<p>Как видно в тесте на странице выше - массив можно заблокировать в памяти без <code>GCHandle</code>, если выбрать правильный тип параметра.
И, в отличии от <code>GCHandle</code>, это будет работать с массивами с любым размерным типом элементов.</p>
<p>К примеру, если имеем процедуру <code>p1</code> из неуправляемой .dll, принимающую массив из двух чисел типа <code>integer</code>:</p>
<pre><code>var a := new integer[5](...);
p1(a); // передача массива целиком
p1(a[3]); // передача [3] элемента var-параметром
</code></pre>
<p>Из первого вызова <code>p1</code> возьмёт только элементы <code>a[0]</code> и <code>a[1]</code>, потому что <code>p1</code> по условию требует только два элемента.</p>
<p>Из второго вызова <code>p1</code> возьмёт <code>a[3]</code> и <code>a[4]</code>, потому что в C++ нет разницы между указателем на один элемент и указателем на начало массива.</p>
<hr />
<p>Обычнно эти два способа передать массив в неуправляемый код - всё что вам понадобится.</p>
<p>Но, допустим, вы хотите написать подпрограмму для создания OpenGL буфера из массива векторов.
Можно сделать перегрузку для каждого типа вектора, но тогда получится очень много дублей кода.
Этого довольно просто избежать, используя шаблоны:</p>
<pre><code>// это не настоящая подпрограмма, а только пример
procedure FillBuffer(var data: byte);
external 'some.dll';

// external подпрограммы не могут быть шаблонными, поэтому нужна ещё одна промежуточная перегрузка
// &quot;where T: record;&quot; делает так, что FillBuffer будет можно вызвать только для размерных типов T
procedure FillBuffer&lt;T&gt;(var data: T); where T: record;
begin
  // Компилятор развернёт это в &quot;FillBuffer(data)&quot;
  // То есть никакие преобразования в .exe не попадут
  // Но указатели всё равно нужны, чтоб компилятор не ругался на несовместимость типов
  FillBuffer(PByte(pointer(@data))^);
end;

procedure FillBuffer&lt;T&gt;(data: array of T); where T: record;
begin
  // В C++ нет разницы между массивом и адресом начала его содержимого
  // Поэтому можно передавать массив в виде [0] элемента-var-параметра.
  FillBuffer(data[0]);
end;
</code></pre>
<p>Но это для одномерных массивов. А что насчёт многомерных?</p>
<p>Сделать перегрузку для заданного кол-ва измерений не сложно:</p>
<pre><code>procedure FillBuffer&lt;T&gt;(data: array[,] of T); where T: record;
begin
  // Многомерные массивы расположены в памяти как одномерные,
  // Но обращение к элементам идёт по нескольким индексам
  // Элемент [0,0,...] в любом случае будет в самом начале,
  // Поэтому кол-во измерений не влияет на сложность кода
  // Элемент [x,y] будет расположен на позиции &quot;x*h+y&quot;, где &quot;h&quot; - кол-во допустимых значений &quot;y&quot;
  FillBuffer(data[0,0]);
end;
</code></pre>
<p>Но, опять же, получается так, что для каждой размерности - приходится добавлять перегрузку.</p>
<p>И, к сожалению, в данном случае я не знаю красивого способа обхода.<br />
Лучшее что я могу придумать - создать <code>Dictionary&lt;integer, Action&lt;System.Array&gt;&gt;</code>,
где ключи - размерности массивов, а значения - делегаты, работающие с соответствующей размерностью.<br />
Когда происходит вызов с массивом определённой размерности - создавать новый делегат
в виде динамичного метода, с помощью <code>System.Reflection.Emit</code>, если его ещё нет в словаре.</p>
</div>
<script>on_page_added(document.getElementById("page-6"))</script>
<div id="page-7" page_name="Строки" hidden=true>
<p>Как и массивы - неуправляемые строки это указатель на первый символ строки.<br />
Но со строками ещё сложнее - исходные библиотеки хранят строки в кодировке ANSI (и требуют 1 байт на символ)<br />
А управляемые строки - хранят символы в кодировке Unicode (2 байта на символ).</p>
<p>Кроме того, у неуправляемых строк принятно добавлять в конце строки символ <code>#0</code>.
Это позволяет вообще не хранить длину строки. Вместо этого конец строки считается там, где первый раз встретится символ <code>#0</code>.</p>
<hr />
<p>Благо, для перевода между этими типами уже есть <code>Marshal.StringToHGlobalAnsi</code> и <code>Marshal.PtrToStringAnsi</code>.</p>
<p>Но будьте осторожны - <code>Marshal.StringToHGlobalAnsi</code> выделяет неуправляемую память для хранения неуправляемого варианта строки.<br />
Когда неуправляемая память стала не нужна - её надо обязательно удалить методом <code>Marshal.FreeHGlobal</code>, иначе получите утечку памяти.</p>
<hr />
<p>В отличии от массивов - пытаться передавать строки в виде символа-<code>var</code>-параметра безсмысленно, из за разницы форматов.</p>
<p>Более того, передача символа строки <code>var</code>-параметром, в отличии от массивов, всё равно вызывает копирование строки,
на всякий случай, потому что в .Net строки неизменяемы, а компилятор не может знать,
будет неуправляемый код только читать, или ещё и перезаписывать строку.</p>
<p>Единственный способ не выполнять лишних копирований - написать свою обёртку неуправляемых строк. Обычно оно того не стоит.</p>
<p>Но если вы, к примеру, создаёте много OpenGL шейдеров из исходников - можно перед компиляцией программы:</p>
<ol>
<li>Прочитать все текстовые файлы исходников шейдеров;</li>
<li>Использовать <code>Marshal.StringToHGlobalAnsi</code> чтоб получить неуправляемые строки;</li>
<li>Пересохранить их в бинарном виде (то есть как массив байт содержимого неуправляемой строки);</li>
<li>Полученные бинарные файлы подключать в виде <code>$resource</code>, читать как массив байт и его уже передавать неуправляемому коду вместо строки.</li>
</ol>
</div>
<script>on_page_added(document.getElementById("page-7"))</script>
<script>on_end_folder()</script>
<div id="page-8" page_name="" hidden=true>
<p>Делегаты - это адреса подпрограмм:</p>
<pre><code>procedure p1(i: integer);
begin
  Writeln(i);
end;

begin
  
  var d: System.Delegate := p1; // это не вызов, а получение адреса p1
  d.DynamicInvoke(5); // вообще .DynamicInvoke это очень медленно
  
  var p: integer-&gt;();
//  var p: Action&lt;integer&gt;; // такое же объявление как на предыдущей строчке, но в другом стиле
  p := p1;
  
  p(5); // типизированные делегаты можно вызывать быстрее и проще, так же как обычные подпрограммы
  
end.
</code></pre>
<hr />
<p>Так же как обычные подпрограммы - подпрограммы из неуправляемых .dll могут принимать делегаты параметром.<br />
Далее всё будет рассматриваться на примере <code>cl.SetEventCallback</code> из модуля <code>OpenCL</code>, потому что с ним есть особые проблемы.</p>
<div class="spoiler" summary="Объявления" hidden="true"><p>Объявление <code>cl.SetEventCallback</code>:</p>
<pre><code>    static function SetEventCallback(&amp;event: cl_event; command_exec_callback_type: CommandExecutionStatus; pfn_notify: Event_Callback; user_data: pointer): ErrorCode;
    external 'opencl.dll' name 'clSetEventCallback';
    static function SetEventCallback(&amp;event: cl_event; command_exec_callback_type: CommandExecutionStatus; pfn_notify: IntPtr; user_data: pointer): ErrorCode;
    external 'opencl.dll' name 'clSetEventCallback';
</code></pre>
<p>Объявление <code>Event_Callback</code>:</p>
<pre><code>  Event_Callback = procedure(&amp;event: cl_event; event_command_exec_status: CommandExecutionStatus; user_data: pointer);
</code></pre>
</div>
<p>Рассмотрим следующий пример:</p>
<pre><code>uses OpenCL;

begin
  
  var cb: Event_Callback := (ev,st,data)-&gt;
  begin
    Writeln($'{ev} перешёл в состояние {st}');
  end;
  
  var ev: cl_event; //ToDo := ...
  
  cl.SetEventCallback(ev, CommandExecutionStatus.COMPLETE, cb, nil).RaiseIfError;
end.
</code></pre>
<p>Этот код будет работать не всегда, потому что:</p>
<ol>
<li><p><code>cl.SetEventCallback</code> вызывает свой коллбек тогда, когда посчитает нужным (но обычно после того как вызов <code>cl.SetEventCallback</code> завершился);</p>
</li>
<li><p>Делегаты - это классы. И на самом деле кроме самого адреса хранят ещё много всякой информации (как типы параметров);</p>
</li>
<li><p>Сборщик мусора распоряжается памятью классов и удаляет их, тоже когда посчитает нужным.</p>
</li>
</ol>
<p>Раз после вызова <code>cl.SetEventCallback</code> делегат <code>cb</code> больше нигде не используется - сборщик мусора может в любой момент
решить выкинуть его. Но, опять же, это редко случается сразу после вызова <code>cl.SetEventCallback</code>,
поэтому ошибки связанные с этим удалением - могут быть плавающие.</p>
<p>Если сборщик мусора удалит делегат, а затем OpenCL.dll попытается его вызвать -
это приведёт или к ошибке доступа, или к моментальному беззвучному вылету.</p>
<p>Чтоб запретить сборщику мусора удалять делегать - нужно создать <code>GCHandle</code>, привязанный к нему.<br />
Но в отличии от массивов - <code>GCHandleType.Pinned</code> не нужно, потому что сборщик мусора может перемещать
в памяти данные о параметрах делегата, но не сам адрес (а он единственное что передаётся в OpenCL.dll).
Это потому что адрес хранится в виде неуправляемого делегата, а им сборщик мусора уже не распоряжается.</p>
<pre><code>uses System.Runtime.InteropServices;
uses OpenCL;

begin
  
  var gc_hnd: GCHandle;
  var cb: Event_Callback := (ev,st,data)-&gt;
  begin
    
    Writeln($'{ev} перешёл в состояние {st}');
    
    // в данном случае освобождать GCHandle станет можно тогда, когда делегат 1 раз выполнится,
    // а значит очень удобно поставить освобождение в конец самого делегата
    gc_hnd.Free;
  end;
  gc_hnd := GCHandle.Alloc(cb);
  
  var ev: cl_event; //ToDo := ...
  
  cl.SetEventCallback(ev, CommandExecutionStatus.COMPLETE, cb, nil).RaiseIfError;
end.
</code></pre>
</div>
<script>on_start_folder("Делегаты", document.getElementById("page-8"))</script>
<script>on_end_folder()</script>
<script>on_end_folder()</script>
</body>
</html>
