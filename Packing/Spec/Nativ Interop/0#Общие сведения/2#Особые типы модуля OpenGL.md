


Среди всех типов-записей, которые можно найти в н.у. модулях, модуль `OpenGL` так же содержит типы векторов и матриц.

Они особенны тем, что поддерживают некоторые математические операции,
которые можно считать высокоуровневыми, а значит противоречущими основным принципам н.у. модулей.

Но реализовывать их все в качестве `extensionmethod`'ов было бы сложно, не красиво, а в случае статичных методов - ещё и невозможно.

---

# Векторы

Все типы векторов можно описать разом как `Vec[1,2,3,4][ b,ub, s,us, i,ui, i64,ui64, f,d ]`.

Если вы уже прочитали спецификацию OpenGL.dll (что в любом случае стоит сделать) - вы уже поняли как это прочитать. Если нет:

:::spoiler { summary="Подробнее" hidden=true }

Каждый тип вектора берёт по 1 из строк, перечисленных в `[]`, через запятую.

К примеру, есть `Vec2d` и `Vec4ui64`.

Число в первых скобках - значит кол-во измерений вектора.

Буква (буквы) в следующих скобках - значит тип координат вектора:

- `b=shortint`, `s=smallint`, `i=integer`, `i64=int64`: Все 4 типа - целые числа со знаком (±), на 1, 2, 4 и 8 байт соответственно;

- Они же но с приставкой `u` - целые числа без знака. К примеру `ui` значит целое на 4 байта без знака, то есть `longword` (он же `cardinal`);

- f=`single` и d=`real` - числа с плавающей запятой, на 4 и 8 байт соответственно.

Таким образом `Vec2d` хранит 2 числа типа `real`, а `Vec4ui64` хранит 4 числа типа `uint64`.

:::

### Свойства

У векторов есть только индексное свойство `val`. Оно принимает индекс, считаемый от 0, и возвращает или задаёт значение вектора для соответствующего измерения.

К примеру:

```
var v: Vec4d;
v[0] := 123.456; // записываем 123.456 по индексу 0
v[1].Println; // читаем и выводим значение по индексу 1
v.val[2] := 1; // можно так же писать и имя свойства
```
Но использование этого свойства не рекомендуется. Обычно, прямое обращение к полю будет быстрее. То есть аналогично предыдущему коду:
```
var v: Vec4d;
v.val0 := 123.456;
v.val1.Println;
v.val2 := 1;
```

Используйте свойство `val` только тогда, когда индекс это НЕ константа.

### Унарные операторы

```
var v0: Vec4d;
...
var v1 := -v0; // v1 будет иметь ту же длину, но противоположное v0 направление
var v2 := +v0; // а унарный + не делает ничего, он только для красоты. То есть v2 будет =v0
```

### Умножение/деление на скаляр

```
var v1: Vec4d;
var v2: Vec4i;
...
(v1*2).Println; // выведет вектор, имеющий то же направление что v1, но в 2 раза длиннее
(v1/2).Println; // выведет вектор, имеющий то же направление что v1, но в 2 раза короче
(v2 div 2).Println; // к целочисленным векторам - вместо обычного деления надо применять div
```

### Операции с 2 векторами

```
var v1, v2: Vec4d;
...
(v1*v2).Println; // скалярное произведение векторов
(v1+v2).Println; // сумма векторов, складывает отдельно каждый элемент вектора
(v1-v2).Println; // разность векторов, так же работает отдельно на каждый элемент вектора
```

Чтоб применить 1 из этих операций к 2 векторам - их типы должны быть одинаковые.\
Если это не так - 1 из них (или оба) надо явно преобразовать, так чтоб типы были одинаковые:
```
var v1: Vec4d;
var v2: Vec2i;
...
( v1 + Vec4d(v2) ).Println;
```

### SqrLength

Метод `.SqrLength` возвращает квадрат длины (то есть модуля) вектора.\
Возвращаемый тип `.SqrLength` совпадает с типом элементов вектора.\
Каким образом находить корень полученного значения - дело программиста.

```
var v1: Vec4d;
...
v1.SqrLength.Println; // квадрат длины
v1.SqrLength.Sqrt.Println; // сама длина
```

### Normalized

Метод `.Normalized` возвращает нормализированную (с длиной =1) версию вектора.\
Так как эта операция требует деления - она применима только к векторам с элементами типов `single` или `real` (`f` или `d`).

```
var v1 := new Vec3d(1,1,1);
v1.Println;
v1.SqrLength.Sqrt.Println;
var v2 := v1.Normalized;
v2.Println;
v2.SqrLength.Sqrt.Println; // обязательно будет 1
```

### Cross

Статичный метод `.Cross` возвращает произведение векторов (Cross product, не путать со скалярным произведением).
Векторное произведение - это вектор, перпендикулярный обоим входным векторам и имеющий длину, равную площади параллелограмма, образованного входными векторами.

Работает только для 3-х мерных векторов.

И не работает для векторов с элементами-беззнаковыми целыми.\
(потому что даёт переполнение на практически любых входных значениях. Если найдёте нормальное применение - напишите в issue).

В математике произведение векторов может вернуть 2 противоположных друг другу вектора,
в зависимости от ориентации системы координат. В OpenGL.pas это решено следующим образом:
```
var c := Vec3d.Cross(a,b);
```
В данном случае, вектор `c` будет такой, чтоб соблюдалось следующее условие:

- Если поставить начала всех 3 векторов в точку (0;0;0), а камеру в точку (a+b+c) и направить в точку (0;0;0) - вектора a, b и c будут расположены по часовой стрелке вокруг центра экрана.

Если надо чтоб было против часовой стрелки - можно использовать CCW (counter clock wise, против часовой стрелки) версию `.Cross`:
```
var c := Vec3d.CrossCCW(a,b);
```
(ну или можно использовать `-Vec3d.Cross(a,b)`, это даст тот же результат но с 1 лишней операцией)

### Превращение в строку

```
var v1: Vec4d;
...
v1.Println; // вывод вектора
var s := v1.ToString; // s присвоит ту же строку, что выводит .Println
```
Методы `.ToString` и `.Println` должны быть использованы только для чего то вроде дебага или красивого вывода,
потому что операции со строками это в целом медленно.

---

# Матрицы

Все типы матриц можно описать разом как `Mtr[2,3,4]x[2,3,4][f,d]`.

Но у каждой квадратной матрицы есть короткий синоним.\
К примеру вместо `Mtr3x3d` можно писать `Mtr3d`.

Так же стоит заметить - конструктор матрицы принимает элементы по строкам, но в самой матрице элементы хранятся в транспонированном виде.

Это потому, что в OpenGL.dll в шейдерах матрицы хранятся по столбцам.\
Но в если создавать матрицу конструктором - элементы удобнее передавать по строкам, вот так:
```
var m := new Mtr3d(
  1,2,3, // (1;2;3) станет нулевой строкой матрицы
  4,5,6,
  7,8,9
);
```

### Свойства

Как и у векторов, у матриц есть свойство `val`:
```
var m: Mtr4d;
m[0,0] := 123.456;
m[1,2].Println;
m.val[3,1] := 1;
```
И как и у векторов - `val` всегда медленнее прямого обращения к полям:
```
var m: Mtr4d;
m.val00 := 123.456;
m.val12.Println;
m.val31 := 1;
```

Но у матриц так же есть свойства для столбцов и строк:
```
var m: Mtr3d;
...
m.Row0.Println; // вывод нулевой строчки в виде вектора
m.Row1 := new Vec3d(1,2,3);
m.Col2.Println;
```
И в качестве аналога `val` - строку и стобец тоже можно получать по динамическому индексу (но, опять же, это медленнее):
```
var m: Mtr3d;
...
m.Row[0].Println; // вывод нулевой строчки в виде вектора
m.Row[1] := new Vec3d(1,2,3);
m.Col[2].Println;
```

Для столбцов так же есть особые свойства, возвращающие не столбец, а его адрес в памяти:
```
var m: Mtr3d;
...
var ptr1 := m.ColPtr0;
var ptr2 := m.ColPtr[3];
```
Но используйте это свойство на свой страх и риск:\
Получение адреса для того, что не находится на стеке или в неуправляемой памяти -
может давать ошибки доступа, когда сборщик мусора перемещает память.

### Identity

Это тоже свойство, но статичное и применение совершенно другое:

`Identity` создаёт новую единичную матрицу. То есть матрицу, у которой главная диагональ заполнена 1, а всё останое заполнено 0.
```
Mtr3d.Identity.Println;

// работает и для не_квадратных матриц
Mtr2x3d.Identity.Println; // выводит такую матрицу:
// 1 0 0
// 0 1 0
```

### Scale

Статичный метод `.Scale` возвращает матрицу, при умножении на которую вектор маштабируется в k раз.
```
var m := Mtr3d.Scale(2);
var v := new Vec3d(1,2,3);
(m*v).Println; // (2;4;6)
```

### Translate

Статичный метод `.Translate` возвращает матрицу, при умножении на которую к вектору добавляется заданное значение.
```
var m := Mtr4d.Translate(1,2,3);
var v := new Vec4d(0,0,0,1); // последнее значение должно быть 1, чтоб матрица из Translate работала адекватно
(m*v).Println; // (1;2;3)
```

Так же есть статичный метод `.TraslateTransposed`. Он возвращает то же самое что `.Translate`, но транспонированное.

### 2D вращение

Группа статичных методов `.Rotate[XY,YZ,ZX][cw,ccw]` возвращает матрицу вращения в определённой плоскости.

Первые скобки определяют плоскость.\
(Но у 2x2 матриц только XY вариант)

Вторые скобки определяют направление вращения:
- cw (clock wise) значит по часовой стрелке
- ccw (counter clock wise) значит против часовой стрелки

### 3D вращение

Группа статичных методов `.Rotate3D[cw,ccw]` возвращает матрицу вращения вокруг нормализованного 3-х мерного вектора.
(разумеется, не существует для матриц 2x2,2x3 и 3x2)

### Det

Метод `.Det` возвращает определитель матрицы. Существует только для квадратных матриц.

### Transpose

Метод `.Transpose` возвращает транспонированную версию матрицы:
```
var m := new Mtr2x3d(
  1,2,3,
  4,5,6
);
m.Transpose.Println; // выводит:
// 1 4
// 2 5
// 3 6
```

### Умножение матрицы и вектора

`m*v` - это обычное умножение матрицы `m` на вектор `v`, возвращающее результат после применения преобразования из `m` к `v`.

Но так же как в шейдерах - поддерживается и обратная запись:\
`v*m` это то же самое что `m.Transpose*v`.

### Умножение 2 матриц

`m1*m2` - это обычное умножение матрицы `m1` на матрицу `m2`.

### Превращение в строку

Как и у векторов - матрицы можно выводить и превращать в строку
```
var m: Mtr4d;
...
m.Println; // вывод матрицы
var s := m.ToString; // s присвоит ту же строку, что выводит .Println
```
Для того чтоб матрица выведенная 1 из этих методов выглядела красиво -
надо использовать моноширный шрифт и поддерживать юникод (потому что для матриц - используются символы псевдографики).

Обычно это не проблема для `.Println`, потому что и консоль и окно вывода в IDE имеют моноширный шрифт и поддерживают юникод.

Но если выводить на форму - придётся специально поставить моноширный шрифт.\
А если выводить в файл - надо выбрать кодировку файла - юникод (UTF8).


