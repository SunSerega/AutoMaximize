


Лучше прочитайте [оффициальный документ от microsoft](https://docs.microsoft.com/en-us/dotnet/standard/managed-code), если хотите точной и подробно информации.

Если в кратце:

Есть платформа .Net, объединяющая много языков программирования. В том числе C# и PascalABC.NET.

.exe и .dll созданные такими языками содержат код в особом виде,
позволяющем легко подключать .dll созданные на 1 .Net языке к программе на любом другом .Net языке.

Такие .exe и .dll называются управляемыми. .exe и .dll созданные на любом другом (то есть не .Net) языке называются неуправляемыми.

OpenCL.dll и OpenGL.dll созданы на- и для языков C/C++, поэтому являются неуправляемыми.

---

Неуправляемые .dll могут содержать только глобальные подпрограммы.

Для получения подпрограммы из неуправляемой .dll - в PABC.Net используется `external` (как использовать - смотрите в справке PABC.Net).

Так же можно использовать всеобщий .Net-овский атрибут `DllImport`. О нём можно прочитать на том же сайте microsoft'а, ссылка выше.

---

Большинство проблем при использовании неуправляемых .dll - вытекают из следующих 2 различий:

1. Все типы, в том числе строки и массивы - в .Net описаны как общие типы, доступные для всех .Net языков.
	
	А в C++ строки и массивы не только описаны не так же как в .Net . У них так же есть множество разных стандартов. Благо, исходные библиотеки придерживаются 1 общего стандарта.

2. В управляемом коде оперативная память (дальше просто память) обычно управляется сборщиком мусора. Поэтому если создать массив - когда он стал не нужен о нём можно просто забыть.
	
	А в C++ память управляется только самим программистом, поэтому неуправляемую память нужно всегда освобождать после использования.\
	Забытая и не_освобождённая неуправляемая память называется утечкой памяти. И это 1 из самых сложно-ловимых багов, потому что у него нет явно видимых симптомов, вроде вызова ошибки, пока память окончательно не закончится.

В .Net так же можно выделять и освобождать неуправляемую память, статичными методами класса `Marshal`. Обычно это надо для п.1., для преобразований между .Net и неуправляемыми типами.

Полное имя класса `Marshal` это `System.Runtime.InteropServices.Marshal`. Но Чтоб не писать его целиком - можно написать в начале файла `uses System.Runtime.InteropServices`, и дальше использовать просто `Marshal`.

---

Стоит так же заметить, что в н.у. модулях все подпрограммы, напрямую вызывающие подпрограммы
из неуправляемых .dll - принимают параметрами как неуправляемые, так и управляемые типы
массивов и строк (самостоятельно выполняя преобразования), по мере необходимости.\
Если ваша необходимость не удовлетворена (то есть не хватает перегрузки с управляемым типом) - это особо хороший повод написать в issue.


