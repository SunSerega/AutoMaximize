


Многие параметры подпрограмм в исходных библиотеках принимают перечисления (enum's).

Перечисления, как и имена, это числа. Но в отличии от имён - перечисления принимают заданные заранее константные значения.

В качестве примера:
```
procedure gl.BeginQuery(target: QueryTarget; id: QueryName);
```
Параметр `target` принимает одно из значений, сгрупированных в записи `QueryTarget`:
```
  QueryTarget = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    
    private static _TRANSFORM_FEEDBACK_OVERFLOW           := new QueryTarget($82EC);
    private static _VERTICES_SUBMITTED                    := new QueryTarget($82EE);
    private static _PRIMITIVES_SUBMITTED                  := new QueryTarget($82EF);
    private static _VERTEX_SHADER_INVOCATIONS             := new QueryTarget($82F0);
    private static _TIME_ELAPSED                          := new QueryTarget($88BF);
    private static _SAMPLES_PASSED                        := new QueryTarget($8914);
    private static _ANY_SAMPLES_PASSED                    := new QueryTarget($8C2F);
    private static _PRIMITIVES_GENERATED                  := new QueryTarget($8C87);
    private static _TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN := new QueryTarget($8C88);
    private static _ANY_SAMPLES_PASSED_CONSERVATIVE       := new QueryTarget($8D6A);
    
    public static property TRANSFORM_FEEDBACK_OVERFLOW:           QueryTarget read _TRANSFORM_FEEDBACK_OVERFLOW;
    public static property VERTICES_SUBMITTED:                    QueryTarget read _VERTICES_SUBMITTED;
    public static property PRIMITIVES_SUBMITTED:                  QueryTarget read _PRIMITIVES_SUBMITTED;
    public static property VERTEX_SHADER_INVOCATIONS:             QueryTarget read _VERTEX_SHADER_INVOCATIONS;
    public static property TIME_ELAPSED:                          QueryTarget read _TIME_ELAPSED;
    public static property SAMPLES_PASSED:                        QueryTarget read _SAMPLES_PASSED;
    public static property ANY_SAMPLES_PASSED:                    QueryTarget read _ANY_SAMPLES_PASSED;
    public static property PRIMITIVES_GENERATED:                  QueryTarget read _PRIMITIVES_GENERATED;
    public static property TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: QueryTarget read _TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN;
    public static property ANY_SAMPLES_PASSED_CONSERVATIVE:       QueryTarget read _ANY_SAMPLES_PASSED_CONSERVATIVE;
    
    ...
    
  end;
```
То есть вызов может выглядеть так:
```
var name: QueryName;
...
gl.BeginQuery(QueryTarget.VERTICES_SUBMITTED, name);
```
Чтоб увидеть доступные значения - достаточно написать `QueryTarget` и поставить точку,
после этого анализатор кода покажет список доступных имён.

---

Так же бывают особые перечисления - битовые маски. Они могут принимать сразу несколько значений:
```
procedure gl.Clear(mask: ClearBufferMask);
```
```
gl.Clear(
	ClearBufferMask.COLOR_BUFFER_BIT or // очистка поверхности рисования одним цветом
	ClearBufferMask.DEPTH_BUFFER_BIT    // очистка буфера глубины - обязательна при рисовании 3D
);
```

`or`, в данном случае, побитовое а не логическое. Поэтому его нельзя читать как "или":

Выражение\
`ClearBufferMask.COLOR_BUFFER_BIT or ClearBufferMask.DEPTH_BUFFER_BIT`\
можно читать как "все биты `COLOR_BUFFER_BIT` + все биты `DEPTH_BUFFER_BIT`".

А в случае `gl.Clear` эта комбинация значит "очистить буфер цвета **и** буфер глубины"


