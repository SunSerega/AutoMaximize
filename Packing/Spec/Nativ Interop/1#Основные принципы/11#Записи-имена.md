


В исходных библиотеках обращение ко всем объектам идёт по "именам" (их так же можно назвать дескрипторами или id этих объектов).

Имена объектов - это числа (в OpenGL обычно на 32 бита, в OpenCL - зависит от битности системы).

Чтоб имя одного типа объектов нельзя было передать в подпрограмму, принимающую имена
объектов другого типа - в н.у. модулях для каждого типа объектов описана подобная запись:
```
  BufferName = record
    public val: UInt32;
    public constructor(val: UInt32) := self.val := val;
    public static property Zero: BufferName read default(BufferName);
  end;
```
Такой подход не замедляет готовую программу, но позволяет отловить на этапе компиляции некоторые ошибки.

Поле `.val` и конструктор публичны только на случай ошибки в перегрузках,
то есть если подпрограмма принемает неправильный тип имени.

В обычной ситуации - вы будете взаимодействовать с именами только 3 способами:

1. Объявление:
   ```
   var name: BufferName;
   var names: array of BufferName := new BufferName[5];
   ```

2. Передача исходным библиотекам:
   ```
   gl.CreateBuffers(1, name);
   gl.CreateBuffers(names.Length, names);
   ```

3. Использование статичного свойства `.Zero`:
   ```
   procedure MyProc(buff: BufferName);
   begin
     ...
   end;
   ...
   MyProc(BufferName.Zero);
   // Это то же самое, но с лишними скобками
   MyProc(default(BufferName));
   ```
   У настоящих объектов имя никогда не будет нулевым.
   
   Но бывает не мало случаев когда исходные библиотеки могут принимать нулевое имя.\
   К примеру, привязка шейдера с нулевым именем в OpenGL отменяет предыдущую привязку шейдера.
   
   И в своих подпрограммах вы так же можете определить особое поведение при передачи нулевого имени.


