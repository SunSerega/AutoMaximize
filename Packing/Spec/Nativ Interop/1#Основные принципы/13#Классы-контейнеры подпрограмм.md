


Все подпрограммы исходных библиотек можно разделить на подпрограммы ядра + множество мелких расширений.

---

Все подпрограммы ядра находятся в классе `gl`/`cl` для OpenGL/OpenCL соответственно.

То есть если вы хотите вызвать функцию `clCreateBuffer` надо писать:
```
cl.CreateBuffer(...);
```
По нажатию точки после `cl` вам так же покажет список всех функций в ядре OpenCL.

---

С OpenGL немного сложнее: в каждом контексте у каждой подпрограммы может быть свой адрес.
Поэтому подпрограммы надо получать в зависимости от контекста. В модуле `OpenGL` это реализовано так:
```
//ToDo создание контекста и привязка его к текущему потоку

// все адреса и экземпляры делегатов создаются в конструкторе
var gl := new OpenGL.gl;

while true do
begin
  // Локальные переменные имеют бОльший приоритет чем классы
  // Поэтому тут "gl" это не класс, а экземпляр, который создали выше
  gl.Clear( ClearBufferMask.COLOR_BUFFER_BIT );
  
  //ToDo само рисование
  
end;
```

---

У каждого расширения есть свой класс. К примеру, так используется расширение `GL_AMD_debug_output`:
```
//ToDo опять же, сначала контекст

var glDebugOutputAMD := new OpenGL.glDebugOutputAMD;
...
glDebugOutputAMD.DebugMessageEnableAMD(...);
```

---

В модуле `OpenGL` так же есть особые классы, `wgl` и `gdi`:

- `gdi` содержит несколько методов библиотеки `gdi32.dll`. На этой библиотеке основано всё в `System.Windows.Forms`.\
Подпрограммы включённые в класс `gdi` - это то что может понадобиться вам чтоб настроить и подготовить форму для рисования на ней с помощью OpenGL.

- `wgl` содержит методы для работы с OpenGL на Windows. Для других ОС есть класс `glX`, но он сейчас выключен из релиза.
Это потому, что у меня нет компьютера, на котором установлена другая ОС, а значит я не могу
заняться тестированием чтоб узнать как правильно объявлять всё в этом классе. Если у вас есть
другая ОС и вы хотите помочь мне разобраться - пожалуйста, свяжитесь со мной (желательно в issue).

Оба этих класса работают как класс `cl`, то есть им **не** надо создавать экземпляр.

---

И последнее что вам надо знать об этих классах: если адрес определённой подпрограммы не удалось получить
(к примеру, при попытке получить адрес подпрограммы из более новой версии OpenGL, чем установлена в драйверах),
то возвращается нулевой адрес.

Адрес можно проверить через специальное поле класса:

```
if gl.z_BindTextures_adr=IntPtr.Zero then ... ;
// Так же можно проверить адрес одной из перегрузок:
if gl.z_BindTextures_ovr_0=nil then ... ;
```
Для подпрограмм, подключаемых с помощью `external` (всё из OpenCL + `wgl`+`gdi` + функции из `gl` версий OpenGL1.1 и ниже)
адрес хранится в статичном поле. То есть их адрес можно читать только через имя класса:
```
// У "external" подпрограмм нет "z_*_adr" поля
if OpenGL.gl.z_BindTexture_ovr0=nil then ... ;
// Если экземпляра класса нет - обращаться к имени класса можно и без "OpenGL."
if wgl.z_CreateContext_ovr0=nil then ... ;
```
Однако проверять адрес это, в целом, плохая практика.

К примеру, узнать поддерживаемую версию `OpenGL` и список поддерживаемых расширений можно функцией `gl.GetString(...)`.
И такой подход на много правильнее чем создавать экземпляр расширения и смотреть, что с адресами его подпрограмм.

Адреса подпрограмм доступны публично только чтоб упростить вам жизнь при поиске ошибок.


