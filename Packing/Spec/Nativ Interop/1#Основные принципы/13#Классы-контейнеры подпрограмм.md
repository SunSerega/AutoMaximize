


Все подпрограммы исходных библиотек можно разделить на подпрограммы ядра + множество мелких расширений.

---

Все подпрограммы ядра находятся в классе `gl`/`cl` для OpenGL/OpenCL соответственно.

То есть если вы хотите вызвать функцию `clCreateBuffer` надо писать:
```
cl.CreateBuffer(...);
```
По нажатию точки после `cl` вам так же покажет список всех функций в ядре OpenCL.

---

С OpenGL немного сложнее: в каждом контексте у каждой подпрограммы может быть свой адрес.
Поэтому подпрограммы надо получать в зависимости от контекста. В модуле `OpenGL` это реализовано так:
```
//ToDo создание контекста и привязка его к текущему потоку

// все адреса и экземпляры делегатов создаются в конструкторе
var gl := new OpenGL.gl;

while true do
begin
  // Локальные переменные имеют бОльший приоритет чем классы
  // Поэтому тут "gl" это не класс, а экземпляр, который создали выше
  gl.Clear( ClearBufferMask.COLOR_BUFFER_BIT );
  
  //ToDo само рисование
  
end;
```

---

У каждого расширения есть свой класс. К примеру, так используется расширение `GL_AMD_debug_output`:
```
//ToDo опять же, сначала контекст

var glDebugOutputAMD := new OpenGL.glDebugOutputAMD;
...
glDebugOutputAMD.DebugMessageEnableAMD(...);
```

---

В модуле `OpenGL` так же есть особые классы, `wgl` и `gdi`:

- `gdi` содержит несколько методов библиотеки `gdi32.dll`. На этой библиотеке основано всё в `System.Windows.Forms`.\
Подпрограммы включённые в класс `gdi` - это то что может понадобиться вам чтоб настроить и подготовить форму для рисования на ней с помощью OpenGL.

- `wgl` содержит методы для работы с OpenGL на Windows. Для других ОС есть класс `glX`, но он сейчас выключен из релиза.
Это потому, что у меня нет компьютера, на котором установлена другая ОС, а значит я не могу
заняться тестированием чтоб узнать как правильно объявлять всё в этом классе. Если у вас есть
другая ОС и вы хотите помочь мне разобраться - пожалуйста, свяжитесь со мной (желательно в issue).

Оба этих класса работают как класс `cl`, то есть им **не** надо создавать экземпляр.

---

И последнее что вам надо знать об этих классах: Если вы получаете `NullReferenceException`:

1. Скорее всего вы попытались вызвать подпрограмму, которой нет в реализации библиотеки на вашем компьютере.\
Проверьте версию библиотеки, или, если это подпрограмма из расширения - проверьте существование у вас этого расширения.

2. Так же, возможно, проблема в н.у. модуле. Если вы уверены что п.1. вас не касается - напишите в issue.


