


Делегаты - это адреса подпрограмм:
```
procedure p1(i: integer);
begin
  Writeln(i);
end;

begin
  
  var d: System.Delegate := p1; // это не вызов, а получение адреса p1
  d.DynamicInvoke(5); // вообще .DynamicInvoke это очень медленно
  
  var p: integer->();
//  var p: Action<integer>; // такое же объявление как на предыдущей строчке, но в другом стиле
  
  p(5); // типизированные делегаты можно вызывать быстрее и проще, так же как обычные подпрограммы
  
end.
```

---

Так же как обычные подпрограммы - подпрограммы из неуправляемых .dll могут принимать делегаты параметром.\
Далее всё будет рассматриваться на примере `cl.SetEventCallback` из модуля `OpenCL`, потому что с ним есть особые проблемы.

:::spoiler { summary="Объявления" hidden=true }

Объявление `cl.SetEventCallback`:
```
    static function SetEventCallback(&event: cl_event; command_exec_callback_type: CommandExecutionStatus; pfn_notify: Event_Callback; user_data: pointer): ErrorCode;
    external 'opencl.dll' name 'clSetEventCallback';
    static function SetEventCallback(&event: cl_event; command_exec_callback_type: CommandExecutionStatus; pfn_notify: IntPtr; user_data: pointer): ErrorCode;
    external 'opencl.dll' name 'clSetEventCallback';
```
Объявление `Event_Callback`:
```
  Event_Callback = procedure(&event: cl_event; event_command_exec_status: CommandExecutionStatus; user_data: pointer);
```

:::

Рассмотрим следующий пример:
```
uses OpenCL;

begin
  
  var cb: Event_Callback := (ev,st,data)->
  begin
    Writeln($'{ev} перешёл в состояние {st}');
  end;
  
  var ev: cl_event; //ToDo := ...
  
  cl.SetEventCallback(ev, CommandExecutionStatus.COMPLETE, cb, nil).RaiseIfError;
end.
```
Этот код будет работать не всегда, потому что:

1. `cl.SetEventCallback` вызывает свой коллбек тогда, когда посчитает нужным (но обычно после того как вызов `cl.SetEventCallback` завершился);

2. Делегаты - это классы. И на самом деле кроме самого адреса хранят ещё много всякой информации (как типы параметров);

3. Сборщик мусора распоряжается памятью классов и удаляет их, тоже когда посчитает нужным.

Раз после вызова `cl.SetEventCallback` делегат `cb` больше нигде не используется - сборщик мусора может в любой момент
решить выкинуть его. Но, опять же, это редко случается сразу после вызова `cl.SetEventCallback`,
поэтому ошибки связанные с этим удалением - могут быть плавающие.

Если сборщик мусора удалит делегат, а затем OpenCL.dll попытается его вызвать -
это приведёт или к ошибке доступа, или к моментальному беззвучному вылету.

Чтоб запретить сборщику мусора удалять делегать - нужно создать `GCHandle`, привязанный к нему.\
Но в отличии от массивов - `GCHandleType.Pinned` не нужно, потому что сборщик мусора может перемещать
в памяти данные о параметрах делегата, но не сам адрес (а он единственное что передаётся в OpenCL.dll).
Это потому что адрес хранится в виде неуправляемого делегата, а им сборщик мусора уже не распоряжается.

```
uses System.Runtime.InteropServices;
uses OpenCL;

begin
  
  var gc_hnd: GCHandle;
  var cb: Event_Callback := (ev,st,data)->
  begin
    
    Writeln($'{ev} перешёл в состояние {st}');
    
    // в данном случае освобождать GCHandle станет можно тогда, когда делегат 1 раз выполнится,
    // а значит очень удобно поставить освобождение в конец самого делегата
    gc_hnd.Free;
  end;
  gc_hnd := GCHandle.Alloc(cb);
  
  var ev: cl_event; //ToDo := ...
  
  cl.SetEventCallback(ev, CommandExecutionStatus.COMPLETE, cb, nil).RaiseIfError;
end.
```


