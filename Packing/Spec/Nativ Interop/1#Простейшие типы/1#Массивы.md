


В .Net массивы хранят не только содержимое, но и данные о своём размере.\
Для одно-мерных массивов размер получают свойством `.Length`, а для много-мерных методом `.GetLength(integer)`.

А в C++ вместо обычных массивов используется безформенная область памяти.\
При её выделении - в переменную записывается указатель `[0]` элемента.
А о том чтоб сохранить данные о размере этой области - должен позаботится программист.\
(вообще обычно в C++ используют обёртки, хранящие длину так же как .Net массивы. Но OpenGL.dll и OpenCL.dll это не касается)

---

Если вы видели старые коды с использованием OpenGL из какого то из паскалей - наверняка видели что то такое:
```
glИмяПодпрограммы(@a[0]);
```
Но в PascalABC.Net так делать нельзя! Получение адреса элемента массива моментально создаёт утечку памяти,
потому что компилятор, на всякий случай, вставляет полную блокировку массива в памяти.

Она нужна, потому что сборщик мусора (то что управляет памятью в .Net) может перемещать содержимое
классов (в том числе массивов) в памяти, ради экономии места. После такого перемещения, любой указатель
на содержимое класса может оказаться устаревшим. И перемещения могут происходит в любой произвольный момент.

Чтоб заблокировать массив в памяти - компилятор использует `GCHandle` с `GCHandleType.Pinned`.
Обычно `GCHandle` освобождают методом `.Free`. Но если дать компилятору использовать
`GCHandle` - освобождение никогда не произойдёт, потому что компилятор не знает когда указатель уже не нужен.

Из очевидных вариантов - использовать `GCHandle` самостоятельно. Он создаётся статичным методом `GCHandle.Alloc`.
Далее, адрес можно получить методом `.AddrOfPinnedObject`.\
Но это не лучший способ, потому что `GCHandle` довольно ограничен. К примеру, он может заблокировать `array of char`,
но не `array of r`, для `r` - запись, содержащая поле типа `char`. И то же самое с `DateTime` и ещё несколькими стандартными
типами, которые `GCHandle` считает "опасными". Кроме того, с `GCHandle` можно получить только адрес `[0]` элемента.

---

Более простой и не_ограниченный способ - использовать `Marshal.UnsafeAddrOfPinnedArrayElement`:
```
glИмяПодпрограммы(Marshal.UnsafeAddrOfPinnedArrayElement(a,0));
```
Это работает с любыми массивами (но если массив хранит классы, или записи содержащие классы среди полей - работать будет не правильно).

`Marshal.UnsafeAddrOfPinnedArrayElement` требует бОльшего тестирования. И когда оно будет проведено - я добавлю сюда коды тестов.

Но пока я могу только утверждать, что:

- Если сохранить результат `Marshal.UnsafeAddrOfPinnedArrayElement` в локальную переменную-указатель,
а затем дождаться перемещения массива в памяти - сборщик мусора изменит адрес, хранимый в переменной.

- А пока работает подпрограмма из неуправляемой .dll - сборщик мусора вообще не двигает массив, если его адрес передали параметром.

Но сохранение адреса в статичном поле (в том числе глобальной переменной) или
в содержимом класса - не всегда оказывается безопасным. Именно это требует бОльшего тестирования.

---

Некоторые могли уже заметить, неуправляемые `var`-параметр и массив из 1 элемента - ничем не отличаются.

То есть, если нужно передать параметром массив из 1 элемента, когда уже есть локальная переменная - можно вместо массива передать адрес этой переменной:
```
var i: integer;
...
glИмяПодпрограммы(@i);
```
Но, обычно, если подпрограмма принимает массив - она так же принимает и `var`-параметр. То есть должно быть можно и так:
```
var i: integer;
...
glИмяПодпрограммы(i); // компилятор выберет перегрузку, принимающую var-параметр
```


