


В .Net массивы хранят не только содержимое, но и данные о своём размере.

А в C++ вместо обычных массивов используется безформенная область памяти.\
При её выделении - в переменную записывается указатель `[0]` элемента.
А о том чтоб сохранить данные о размере этой области - должен позаботится программист.\
(вообще обычно в C++ используют обёртки, хранящие длину так же как .Net массивы. Но OpenGL.dll и OpenCL.dll это не касается)

---

Если вы видели старые коды с использованием OpenGL из какого то из паскалей - наверняка видели что то такое:
```
glИмяПодпрограммы(@a[0]);
```
Но в PascalABC.Net так делать нельзя! Получение адреса элемента массива моментально создаёт утечку памяти,
потому что компилятор, на всякий случай, вставляет полную блокировку массива в памяти, используя `GCHandle` с `GCHandleType.Pinned`.

Такая блокировка нужна, потому что иначе полученный указатель может в любой момент стать устаревшим.

Обычно `GCHandle` освобождают методом `.Free`. Но если позволить компилятору использовать
`GCHandle` - освобождение никогда не произойдёт, потому что компилятор не знает когда указатель уже не нужен.

---

Из очевидных вариантов - использовать `GCHandle` самостоятельно. Он создаётся статичным методом `GCHandle.Alloc`.
Далее, адрес можно получить методом `GCHandle.AddrOfPinnedObject`.

Но `GCHandle` довольно ограничен. К примеру, он может заблокировать `array of char`, но не `array of r`,
для `r` - запись, содержащая поле типа `char`. И то же самое с `DateTime` и ещё несколькими стандартными
типами, которые `GCHandle` считает "опасными".

---

Как видно в тесте на странице выше - массив можно заблокировать в памяти без `GCHandle`, если выбрать правильный тип параметра.
И, в отличии от `GCHandle`, это будет работать с массивами с любым размерным типом элементов.

К примеру, если имеем процедуру `p1` из неуправляемой .dll, принимающую массив из двух чисел типа `integer`:
```
var a := new integer[5](...);
p1(a); // передача массива целиком
p1(a[3]); // передача [3] элемента var-параметром
```
Из первого вызова `p1` возьмёт только элементы `a[0]` и `a[1]`, потому что `p1` по условию требует только два элемента.

Из второго вызова `p1` возьмёт `a[3]` и `a[4]`, потому что в C++ нет разницы между указателем на один элемент и указателем на начало массива.

---

Обычнно эти два способа передать массив в неуправляемый код - всё что вам понадобится.

Но, допустим, вы хотите написать подпрограмму для создания OpenGL буфера из массива векторов.
Можно сделать перегрузку для каждого типа вектора, но тогда получится очень много дублей кода.
Этого довольно просто избежать, используя шаблоны:
```
// это не настоящая подпрограмма, а только пример
procedure FillBuffer(var data: byte);
external 'some.dll';

// external подпрограммы не могут быть шаблонными, поэтому нужна ещё одна промежуточная перегрузка
// "where T: record;" делает так, что FillBuffer будет можно вызвать только для размерных типов T
procedure FillBuffer<T>(var data: T); where T: record;
begin
  // Компилятор развернёт это в "FillBuffer(data)"
  // То есть никакие преобразования в .exe не попадут
  // Но указатели всё равно нужны, чтоб компилятор не ругался на несовместимость типов
  FillBuffer(PByte(pointer(@data))^);
end;

procedure FillBuffer<T>(data: array of T); where T: record;
begin
  // В C++ нет разницы между массивом и адресом начала его содержимого
  // Поэтому можно передавать массив в виде [0] элемента-var-параметра.
  FillBuffer(data[0]);
end;
```
Но это для одномерных массивов. А что насчёт многомерных?

Сделать перегрузку для заданного кол-ва измерений не сложно:
```
procedure FillBuffer<T>(data: array[,] of T); where T: record;
begin
  // Многомерные массивы расположены в памяти как одномерные,
  // Но обращение к элементам идёт по нескольким индексам
  // Элемент [0,0,...] в любом случае будет в самом начале,
  // Поэтому кол-во измерений не влияет на сложность кода
  // Элемент [x,y] будет расположен на позиции "x*h+y", где "h" - кол-во допустимых значений "y"
  FillBuffer(data[0,0]);
end;
```
Но, опять же, получается так, что для каждой размерности - приходится добавлять перегрузку.

И, к сожалению, в данном случае я не знаю красивого способа обхода.\
Лучшее что я могу придумать - создать `Dictionary<integer, Action<System.Array>>`,
где ключи - размерности массивов, а значения - делегаты, работающие с соответствующей размерностью.\
Когда происходит вызов с массивом определённой размерности - создавать новый делегат
в виде динамичного метода, с помощью `System.Reflection.Emit`, если его ещё нет в словаре.


