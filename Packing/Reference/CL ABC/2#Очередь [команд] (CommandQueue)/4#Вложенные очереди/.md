


Все методы создающие одну команду (`*CCQ.Add*` методы и все методы неявных очередей)
могут принимать очередь вместо значения в качестве практически любого параметра. Но в таком случае
возвращаемый тип очереди должен совпадать с типом параметра. К примеру:
```
## uses OpenCLABC;

var a := new CLArray<integer>(10);
// Очищаем весь буфер нулями, чтобы не было мусора
a.FillValue(0);

// Второй параметр AddWriteItem - индекс в массиве
// Он имеет тип integer, а значит можно передать и CommandQueue<integer>
// Таким образом, в параметр сохраняется алгоритм, а не готовое значение
// Поэтому 3 вызова ниже могут получится с 3 разными индексами
var q := a.NewQueue
  .AddWriteValue(5, HFQQ(()-> Random(a.Length) ))
;

Context.Default.SyncInvoke(q);
Context.Default.SyncInvoke(q);
Context.Default.SyncInvoke(q);

a.GetArray.Println;
```
Все вложенные очереди начинают выполняться сразу при вызове метода `Context.BeginInvoke`, не ожидая других очередей.

Обычно вложенные очереди особо полезны когда надо записать что-то в память GPU прямо перед вызовом kernel'а:
```
k.Exec1(N, a.NewQueue.AddFillValue(1))
```
Вместо:
```
a.NewQueue.AddFillValue(1) +
k.Exec1(N, a)
```


