


Все типы очередей наследует от `CommandQueueBase`. Это значит что любую очередь можно сохранить в переменную типа `CommandQueueBase`.\
Но о значении типа `CommandQueueBase` известно не на много больше чем о значении типа `object`.

Так же, все очереди наследуют от одного из двух типов:
1. `CommandQueueNil` - очередь возващающая `nil` (именно нулевую ссылку, не пустое значение любого типа).
1. `CommandQueue<T>` (где `T` - любой тип) - очередь возвращающая значение типа `T`;

После выполнения очереди `CommandQueue<T>` метод `Context.SyncInvoke` возвращает то, что вернула очередь.\
А если использовать метод `Context.BeginInvoke` - возвращаемое значение можно получить с помощью метода `CLTask<T>.WaitRes`.

---

Результат других типов очередей нельзя получить, но их можно преобразовать к `CommandQueue<T>` с произвольным `T` с помощью `.Cast`:
```
## uses OpenCLABC;

// Q объявлена как CommandQueueBase,
// а значит в неё можно сохранить любую очередь
var Q: CommandQueueBase;

// В данном случае сохраняем CommandQueueNil
Q := HPQ(()->Writeln('Q выполнилась'));

// Преобразовывать nil можно в любой ссылочный тип
Writeln(Context.Default.SyncInvoke( Q.Cast&<object> ));
// Exception тоже класс - поэтому можно и в него
// Но в результате всё равно получится nil
Writeln(Context.Default.SyncInvoke( Q.Cast&<Exception> ));

Sleep(1000); // Чтобы было видно предыдущий вывод
//Ошибка времени выполнения: .Cast не может преобразовывать nil в System.Int32
// Ошибка кидается ещё в момент создания .Cast очереди
Writeln(Context.Default.SyncInvoke( Q.Cast&<integer> ));
```
Подробнее <a path="../Создание очередей/Из очереди + преобразователя">тут</a>.

---

Очереди, созданные из областей памяти OpenCL или kernel'ов возващают свои области памяти/`Kernel`'ы соответственно, из которых были созданы;\
Очереди, созданные с `HFQ` - значение, которое вернёт переданная функция;\
Очереди, созданные с `HPQ` являются `CommandQueueNil`.

Демонстрация:
```
## uses OpenCLABC;

/// Вывод типа и значения объекта
procedure OtpObject(o: object) :=
$'{o?.GetType}[{_ObjectToString(o)}]'.Println;
// "o?.GetType" это короткая форма "o=nil ? nil : o.GetType",
// то есть, берём или тип объекта, или nil если сам объект nil
// _ObjectToString это функция, которую использует Writeln для форматирования значений

procedure Test(q: CommandQueueBase) :=
OtpObject(Context.Default.SyncInvoke(
  // Преобразовываем результат к object, чтобы его вернула SyncInvoke
  q.Cast&<object>
));

var s := new MemorySegment(1);

// Тип - MemorySegment, потому что очередь создали из него
Test( s.NewQueue );

// Тип - Int32 (то есть integer), потому что это тип по умолчанию для выражения (5)
Test( HFQ(()->5) );

// Тип - string, по той же причине
Test( HFQ(()->'abc') );

// Тип отсутствует, потому что HPQ возвращает nil
Test( HPQ(()->Print('Выполнилась HPQ:')) );
```

---

Проверить что очередь ничего не возвращает очень просто:
```
var Q: CommandQueueBase;
...
if Q is CommandQueueNil(var cqn) then
  p1(cqn) else
  p2(Q);
```
Но для типа `CommandQueue<T>` надо указать конкретный тип, чтобы вызвать `is`.
Другими словами, с помощью `is` можно проверять только по 1 типу возвращаемого значения за раз:
```
var Q: CommandQueueBase;
...
if Q is CommandQueueNil(var cqn) then
  p1(cqn) else
if Q is CommandQueue<byte>(var cq) then
  p2&<byte>(cq) else
if Q is CommandQueue<word>(var cq) then
  p2&<word>(cq) else
  // Не должно происходить
  raise new System.NotSupportedException;
```
Если надо вызвать `p2` для очереди с любым возвращаемым значением - используется `.UseTyped`:
```
uses OpenCLABC;

procedure p1(cq: CommandQueueNil) := Writeln('nil');
procedure p2<T>(cq: CommandQueue<T>) := Writeln($'<{typeof(T)}>');

type
  // Не обязательно запись
  TypedUser = record(ITypedCQUser)
    
    public procedure UseNil(cq: CommandQueueNil) := p1(cq);
    public procedure Use<T>(cq: CommandQueue<T>) := p2(cq);
    
  end;
  
procedure Test(Q: CommandQueueBase) :=
Q.UseTyped(new TypedUser);

begin
  Test(HPQ(()->begin end));
  Test(HFQ(()->0));
  Test(HFQ(()->0.0));
end.
```
Объявлять дополнительный тип (`TypedUser` в этом коде) необходимо потому, что иначе
передать подпрограмму `Use<T>`, не указывая её `<T>`, в `UseTyped` не получится.

Так же, если нужно не только использовать очередь, но и что-то вернуть - используется `.ConvertTyped`:
```
uses OpenCLABC;

type
  // Получает имя типа результата очереди, или nil если он отсутствует
  QueueConverterResTName = record(ITypedCQConverter<string>)
    
    public function ConvertNil(cq: CommandQueueNil): string := nil;
    public function Convert<T>(cq: CommandQueue<T>): string := typeof(T).ToString;
    
  end;
  
procedure Test(Q: CommandQueueBase) :=
Writeln( Q.ConvertTyped(new QueueConverterResTName) );

begin
  Test(HPQ(()->begin end));
  Test(HFQ(()->0));
  Test(HFQ(()->0.0));
end.
```
И `.UseTyped` и `.ConvertTyped` гарантируют что обязательно будет вызван ровно один
из двух методов - либо принимающий `CommandQueueNil`, либо принимающий `CommandQueue<T>`.


