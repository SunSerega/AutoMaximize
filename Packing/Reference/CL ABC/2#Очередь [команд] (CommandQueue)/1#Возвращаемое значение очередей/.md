


Все типы очередей наследует от `CommandQueueBase`. Это значит что любую очередь можно сохранить в переменную типа `CommandQueueBase`.\
Но о значении типа `CommandQueueBase` известно не на много больше чем о значении типа `object`.

Так же, все очереди наследуют от одного из двух типов:
1. `CommandQueueNil` - очередь возващающая `nil` (именно нулевую ссылку, не пустое значение любого типа).
1. `CommandQueue<T>` (где `T` - любой тип) - очередь возвращающая значение типа `T`;

После выполнения очереди `CommandQueue<T>` метод `Context.SyncInvoke` возвращает то, что вернула очередь.\
А если использовать метод `Context.BeginInvoke` - возвращаемое значение можно получить с помощью метода `CLTask<T>.WaitRes`.

---

Результат других типов очередей нельзя получить, но их можно преобразовать к `CommandQueue<T>` с произвольным `T` с помощью `.Cast`:
```
## uses OpenCLABC;

// Q объявлена как CommandQueueBase,
// а значит в неё можно сохранить любую очередь
var Q: CommandQueueBase;

// В данном случае сохраняем CommandQueueNil
Q := HPQ(()->Writeln('Q выполнилась'));

// Преобразовывать nil можно в любой ссылочный тип
Writeln(Context.Default.SyncInvoke( Q.Cast&<object> ));
// Exception тоже класс - поэтому можно и в него
// Но в результате всё равно получится nil
Writeln(Context.Default.SyncInvoke( Q.Cast&<Exception> ));

Sleep(1000); // Чтобы было видно предыдущий вывод
//Ошибка времени выполнения: .Cast не может преобразовывать nil в integer
// Ошибка кидается ещё в момент создания .Cast очереди
Writeln(Context.Default.SyncInvoke( Q.Cast&<integer> ));
```
Подробнее <a path="../Создание очередей/С кодом для CPU">тут</a>.

---

В то же время, если результат выполнения очереди не нужен,
от него можно избавится с помощью `.DiscardResult`.

Это может понадобится если вы хотите:
- Защититься от случайного использования результата;
- Передать очередь туда, где ожидается `CommandQueueNil`;
- Сократить (мизерное, но не нулевое) использование ресурсов, выделяемых для передачи резутата. К примеру:
```
## uses OpenCLABC;

var Q := HFQQ(()->
begin
  Writeln('Функция выполнилась');
  Result := 5;
end).DiscardResult;

var t := Context.Default.BeginInvoke(Q as CommandQueueBase);
$'Has result: {not (t is CLTaskNil)}'.Println;

t.Wait;
```
Без `.DiscardResult` - `BeginInvoke` создаст `CLTask<integer>`,
не смотря на то, что в него передают `CommandQueueBase`.

А с `.DiscardResult` - `HFQQ` выполняется как будто это `HPQQ`.

Обратите внимание, если результат очереди выкидывается, без
какого-либо использования - ресурсы на него не выделяются. К примеру:
```
## uses OpenCLABC;

Context.Default.SyncInvoke(
  HFQQ(()->1) +
  HFQQ(()->2)
);
```
Первая `HFQQ` выполнится как будто это `HPQQ`, потому что
из `SyncInvoke` можно получить только результат второй `HFQQ`.

---

Очереди, созданные из областей памяти OpenCL или kernel'ов возващают свои области памяти/`Kernel`'ы соответственно, из которых были созданы;\
Очереди, созданные с `HF[Q]Q` - значение, которое вернёт переданная функция;\
Очереди, созданные с `HP[Q]Q` являются `CommandQueueNil`.

Демонстрация:
```
## uses OpenCLABC;

/// Вывод типа и значения объекта
procedure OtpObject(o: object) :=
$'{if o=nil then nil else TypeName(o)}[{_ObjectToString(o)}]'.Println;
// _ObjectToString это функция, которую используют
// Writeln и Println для форматирования значений

procedure Test(q: CommandQueueBase) :=
OtpObject(Context.Default.SyncInvoke(
  // Преобразовываем результат к object, чтобы его вернула SyncInvoke
  q.Cast&<object>
));

var s := new MemorySegment(1);

// Тип - MemorySegment, потому что очередь создали из него
Test( s.NewQueue );

// Тип - integer, потому что это тип по умолчанию для выражения (5)
Test( HFQQ(()->5) );

// Тип - string, по той же причине
Test( HFQQ(()->'abc') );

// Тип отсутствует, потому что HP[Q]Q возвращает nil
Test( HPQQ(()->Print('Выполнилась HPQQ:')) );
```

---

Проверить что очередь ничего не возвращает очень просто:
```
var Q: CommandQueueBase;
...
if Q is CommandQueueNil(var cqn) then
  p1(cqn) else
  p2(Q);
```
Но для типа `CommandQueue<T>` надо указать конкретный тип, чтобы вызвать `is`.
Другими словами, с помощью `is` можно проверять только по одному типу возвращаемого значения за раз:
```
var Q: CommandQueueBase;
...
if Q is CommandQueueNil(var cqn) then
  p1(cqn) else
if Q is CommandQueue<byte>(var cq) then
  p2&<byte>(cq) else
if Q is CommandQueue<word>(var cq) then
  p2&<word>(cq) else
  // Не должно происходить
  raise new System.NotSupportedException;
```
Если надо вызвать `p2` для очереди с любым возвращаемым значением - используется `.UseTyped`:
```
uses OpenCLABC;

procedure p1(cq: CommandQueueNil) := Writeln('nil');
procedure p2<T>(cq: CommandQueue<T>) := Writeln($'<{TypeToTypeName(typeof(T))}>');

type
  // Не обязательно запись
  TypedUser = record(ITypedCQUser)
    
    public procedure UseNil(cq: CommandQueueNil) := p1(cq);
    public procedure Use<T>(cq: CommandQueue<T>) := p2(cq);
    
  end;
  
procedure Test(Q: CommandQueueBase) :=
Q.UseTyped(new TypedUser);

begin
  Test(HPQ(()->begin end));
  Test(HFQ(()->0));
  Test(HFQ(()->0.0));
end.
```
Объявлять дополнительный тип (`TypedUser` в этом коде) необходимо потому, что иначе
передать подпрограмму `Use<T>`, не указывая её `<T>`, в `UseTyped` не получится.

Так же, если нужно не только использовать очередь, но и что-то вернуть - используется `.ConvertTyped`:
```
uses OpenCLABC;

type
  // Получает имя типа результата очереди, или nil если он отсутствует
  QueueConverterResTName = record(ITypedCQConverter<string>)
    
    public function ConvertNil(cq: CommandQueueNil): string := nil;
    public function Convert<T>(cq: CommandQueue<T>): string := TypeToTypeName(typeof(T));
    
  end;
  
procedure Test(Q: CommandQueueBase) :=
Writeln( Q.ConvertTyped(new QueueConverterResTName) );

begin
  Test(HPQ(()->begin end));
  Test(HFQ(()->0));
  Test(HFQ(()->0.0));
end.
```
И `.UseTyped` и `.ConvertTyped` гарантируют что обязательно будет вызван ровно один
из двух методов - либо принимающий `CommandQueueNil`, либо принимающий `CommandQueue<T>`.


