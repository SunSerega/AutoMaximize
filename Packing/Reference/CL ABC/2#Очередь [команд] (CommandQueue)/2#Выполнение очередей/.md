


Самый простой способ выполнить очередь - вызвать метод `Context.SyncInvoke`.

У него есть три перегрузки, для `CommandQueueBase`, `CommandQueueNil` и `CommandQueue<T>`.
Только последняя возвращает результат.

Но если надо выполнить очередь асинхронно - лучше использовать метод `Context.BeginInvoke`,
потому что его всё равно вызывает `Context.SyncInvoke`.

`Context.BeginInvoke` запускает асинхронное выполнение очереди.
Как только очередь была полностью запущена он возвращает объект типа
`CLTaskBase`, `CLTaskNil` или `CLTask<T>` для соответствующих типов очередей.

Так же как в случае очередей, `CLTaskNil` и `CLTask<T>` наследуют от `CLTaskBase`.\
У всех `CLTask`-ов есть:
- Свойства `.OrgContext` и `.OrgQueue`, возвращающие контекст выполнения и выполняемую очередь соответственно.
- Метод `.Wait` для ожидания окончания выполнения очереди.

У `CLTask<T>` так же есть метод `.WaitRes`, вызывающий `.Wait` и затем возвращающий результат очереди.

---

При выполнении очереди может произойти несколько исключений, поэтому, чтобы получить можно было все, их упаковывает в `System.AggregateException`:
```
## uses OpenCLABC;

try
  
  // Context.SyncInvoke или CLTask.Wait
  Context.Default.SyncInvoke(Q);
  
except
  on e: System.AggregateException do
    e.InnerExceptions.PrintLines;
end;
```
Но для более тонкого контроля лучше использовать
<a path="../Создание очередей/Обработка исключений">`.Handle*` методы очередей</a>.


