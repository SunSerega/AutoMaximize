


Самый простой способ выполнить очередь - вызвать метод `Context.SyncInvoke`.

У него есть три перегрузки, для `CommandQueueBase`, `CommandQueueNil` и `CommandQueue<T>`.
Только последняя возвращает результат.

Но если надо выполнить очередь асинхронно - лучше использовать метод `Context.BeginInvoke`,
потому что его всё равно вызывает `Context.SyncInvoke`.

`Context.BeginInvoke` запускает асинхронное выполнение очереди.
Как только очередь была полностью запущена он возвращает объект типа
`CLTaskBase`, `CLTaskNil` или `CLTask<T>` для соответствующих типов очередей.

Так же как в случае очередей, `CLTaskNil` и `CLTask<T>` наследуют от `CLTaskBase`.\
У всех `CLTask`-ов есть:
- Свойства `.OrgContext` и `.OrgQueue`, возвращающие контекст выполнения и выполняемую очередь соответственно.
- Метод `.Wait` для ожидания окончания выполнения очереди.

У `CLTask<T>` так же есть метод `.WaitRes`, вызывающий `.Wait` и затем возвращающий результат очереди.

---

Если при выполнении возникла ошибка, о ней выведет не полную информацию. Чтобы получить всю информацию - используется `try`:
```
try
  
  //ToDo ваш код, вызывающий ошибку
  
except
  // Writeln выводит все внутренние исключения. "e.ToString" тоже.
  on e: Exception do Writeln(e);
end;
```
Для этого кода есть стандартный снипет. Чтобы активировать его - напишите `tryo` и нажмите Shift+Пробел.


