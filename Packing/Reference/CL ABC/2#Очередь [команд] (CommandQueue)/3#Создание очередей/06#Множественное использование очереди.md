


Одну и ту же очередь можно использовать несколько раз, в том числе одновременно:
```
## uses OpenCLABC;
var Q := HPQQ(()->lock output do Writeln('Q выполнилась'));

var t1 := Context.Default.BeginInvoke(Q);
var t2 := Context.Default.BeginInvoke(Q*Q);

t1.Wait;
t2.Wait;
```
Но эта программа выведет "Q выполнилась" три раза, потому что при каждом упоминании - Q запускается ещё раз.

Это не всегда хорошо. К примеру, может быть так что `Q` содержит какой то затратный алгоритм. Или ввод значения с клавиатуры:
```
## uses OpenCLABC;

var Q := HFQ(()->
begin
  lock input do
    Result := ReadInteger;
end);

Context.Default.SyncInvoke(CombineConvAsyncQueue(res->res,
  Q,
  Q.ThenQuickConvert(i->i*i),
  Q.ThenQuickConvert(i->i*i*i)
)).Println;
```
Эта программа запросит три разных значения, что не всегда то что надо.

---

Чтобы использовать результат одной очереди несколько раз применяется `.Multiusable`:
```
## uses OpenCLABC;

var Q := HFQ(()->
begin
  lock input do
    Result := ReadInteger;
end);
var Qs := Q.Multiusable;

// Теперь нет смысла в Async, потому что 
Context.Default.SyncInvoke(CombineConvAsyncQueue(res->res,
  Qs(),
  Qs().ThenQuickConvert(i->i*i),
  Qs().ThenQuickConvert(i->i*i*i)
)).Println;
```
`.Multiusable` создаёт новую функцию, вызывая которую можно получить любое количество очередей,
у которых будет общий результат.

Каждый вызов `.Multiusable` создаёт именно новую функцию.\
Это значит, что если использовать результаты двух вызовов `.Multiusable` - исходная очередь выполнится два раза:
```
## uses OpenCLABC;

var Q := HFQ(()->
begin
  lock input do
    Result := ReadInteger;
end);
var Q1s := Q.Multiusable;
var Q2s := Q.Multiusable;

Context.Default.SyncInvoke(CombineConvAsyncQueue(res->res,
  Q1s(),
  Q1s().ThenQuickConvert(i->i*i),
  Q2s().ThenQuickConvert(i->i*i*i)
)).Println;
```

---

Очередь для которой вызвали `.Multiusable` начинает выполняться не ожидая другие очереди:
```
## uses OpenCLABC;

var Q0 := HPQ(()->
begin
  Sleep(1000);
  Writeln('Q0');
end);

var Q1s := HPQ(()->
begin
  Writeln('Q1');
end).Multiusable;
var Q1 := Q1s();

// Q1 выполнит первым
Context.Default.SyncInvoke( Q0 + Q1 );
```
Чтобы `Q1` выполнялась после `Q0` - они должны быть сумированны под `.Multiusable`:
```
## uses OpenCLABC;

var Q0 := HPQ(()->
begin
  Sleep(1000);
  Writeln('Q0');
end);

var Q1 := HPQ(()->
begin
  Writeln('Q1');
end);

var Qs := (Q0+Q1).Multiusable;
Context.Default.SyncInvoke( Qs() );
```

---

`.Multiusable` не работает между вызовами `Context.BeginInvoke`:
```
## uses OpenCLABC;

var Q := HFQ(()->
begin
  lock input do
    Result := ReadInteger;
end);
var Qs := Q.Multiusable;

Context.Default.SyncInvoke( Qs()                          ).Println;
Context.Default.SyncInvoke( Qs().ThenQuickConvert(i->i*i) ).Println;
```
Эта программа запросит ввод два раза.

Если контекст у двух очередей общий - лучше объединить вызовы `Context.BeginInvoke`.
Так не только `.Multiusable` будет работать, но и выполнение будет в целом быстрее.

А если контекст разный - надо сохранять результат в переменную и использовать `Wait` очереди
(<a path="Из ожидания очередей">подробнее на странице ниже</a>).


