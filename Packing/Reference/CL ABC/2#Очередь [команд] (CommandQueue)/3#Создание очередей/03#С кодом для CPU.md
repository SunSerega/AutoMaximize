


Иногда между командами для GPU надо вставить выполнение обычного кода на CPU.
А разрывать для этого очередь на две части - плохо, потому что
одна целая очередь всегда выполнится быстрее двух её частей.

Для таких случае существуют глобальные подпрограммы `HFQ` и `HPQ`:

HFQ — Host Function Queue\
HPQ — Host Procedure Queue\
(Хост в контексте OpenCL - это CPU, потому что с него посылаются команды для GPU)

Они возвращают очередь, выполняющую код (функцию/процедуру соотвественно) на CPU.\
Пример применения приведён <a path="../Возвращаемое значение очередей/"> на странице выше</a>.

---

Так же бывает нужно использовать результат предыдущей очереди в коде на CPU.
Для этого используются методы `.ThenUse` и `.ThenConvert`:
```
## uses OpenCLABC;
var Q := HFQ(()->5);

Context.Default.SyncInvoke(Q
  .ThenUse(x->Println($'x*2 = {x*2}'))
  .ThenConvert(x->$'x^2 = {x**2}')
).Println;
```
Они схожи с `HPQ` и `HFQ` соответственно, за исключением того, что `.ThenUse` возвращает значение, которое в него передали, а не `nil`.

