


Одну и ту же очередь можно использовать несколько раз, в том числе одновременно:
```
## uses OpenCLABC;
var Q := HPQ(()->lock output do Writeln('Q выполнилась'));

var t1 := Context.Default.BeginInvoke(Q);
var t2 := Context.Default.BeginInvoke(Q*Q);

t1.Wait;
t2.Wait;
```
Но эта программа выведет "Q выполнилась" три раза, потому что при каждом упоминании - Q запускается ещё раз.

Это не всегда хорошо. К примеру, может быть так что `Q` содержит какой то затратный алгоритм. Или ввод значения с клавиатуры:
```
## uses OpenCLABC;

var Q := HFQ(()->
begin
  lock input do
    Result := ReadInteger;
end);

Context.Default.SyncInvoke(CombineAsyncQueue(
  res->res,
  Q,
  Q.ThenConvert(i->i*i),
  Q.ThenConvert(i->i*i*i)
)).Println;
```
Эта программа запросит три разных значения, что не всегда то что надо.

---

Чтобы использовать результат одной очереди несколько раз применяется `.Multiusable`:
```
## uses OpenCLABC;

var Q := HFQ(()->
begin
  lock input do
    Result := ReadInteger;
end);
var Qs := Q.Multiusable;

Context.Default.SyncInvoke(CombineAsyncQueue(
  res->res,
  Qs(),
  Qs().ThenConvert(i->i*i),
  Qs().ThenConvert(i->i*i*i)
)).Println;
```
`.Multiusable` создаёт новую функцию, вызывая которую можно получить любое количество очередей,
у которых будет общий результат.

Каждый вызов `.Multiusable` создаёт именно новую функцию.\
Это значит, что если использовать результаты двух вызовов `.Multiusable` - исходная очередь выполнится два раза:
```
## uses OpenCLABC;

var Q := HFQ(()->
begin
  lock input do
    Result := ReadInteger;
end);
var Q1s := Q.Multiusable;
var Q2s := Q.Multiusable;

Context.Default.SyncInvoke(CombineAsyncQueue(
  res->res,
  Q1s(),
  Q1s().ThenConvert(i->i*i),
  Q2s().ThenConvert(i->i*i*i)
)).Println;
```

---

`.Multiusable` не работает между вызовами `Context.BeginInvoke`:
```
## uses OpenCLABC;

var Q := HFQ(()->
begin
  lock input do
    Result := ReadInteger;
end);
var Qs := Q.Multiusable;

Context.Default.SyncInvoke( Qs()                     ).Println;
Context.Default.SyncInvoke( Qs().ThenConvert(i->i*i) ).Println;
```
Эта программа запросит ввод два раза.

Если контекст у двух очередей общий - лучше объединить вызовы `Context.BeginInvoke`.
Так не только `.Multiusable` будет работать, но и выполнение будет в целом быстрее.

А если контекст разный - надо сохранять результат в переменную и использовать `Wait` очереди
(<a path="Из ожидания очередей">подробнее на странице ниже</a>).


