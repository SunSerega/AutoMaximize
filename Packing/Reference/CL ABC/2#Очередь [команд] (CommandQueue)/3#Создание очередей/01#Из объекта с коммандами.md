


Самый просто способ создать очередь — выбрать объект, имеющий методы, соответствующие командам для GPU, и вызвав его метод `.NewQueue`.

Полученная очередь будет иметь особый тип, с припиской CCQ (что значит "Command Container Queue", то есть очередь-контейнер для коман GPU).\
К примеру, метод `CLArray<byte>.NewQueue` вернёт очередь типа `CLArrayCCQ<byte>`, наследующего от `CommandQueue< CLArray<byte> >`.\
К такой очереди можно добавлять команды, вызывая её методы, имена которых начинаются с `.Add`.

К примеру:
```
## uses OpenCLABC;

// Массив на 3 элемента типа integer
var a := new CLArray<integer>(3);

// Создаём очередь
var q: CLArrayCCQ<integer> := a.NewQueue;

// Добавлять команды в полученную очередь можно вызывая соответствующие методы
q.AddWriteItem(1, 0);

// .Add методы возвращают очередь, для которой их вызвали
// (не копию, а именно ссылку на оригинал)
// Поэтому можно добавлять по несколько команд в 1 строчке:
q.AddWriteItem(5, 1).AddWriteItem(7, 2);
// Все команды в q будут выполняться в порядке их добавления

// .AddGet методы особенные, потому что они возвращают новую очередь
// В данном случае эта очередь читает весь CLArray как обычный массив в RAM
Context.Default.SyncInvoke(q.AddGetArray).Println;
```

Также, `CCQ` очереди можно создавать из очередей, возвращающих объект с командами. Для этого используется конструктор:
```
var q0: CommandQueue<MemorySegment>;
...
var q := new MemorySegmentCCQ(q0);
```

---

Команды объектов, представляющих память на GPU, можно разделить на группы.

По направлению передачи:
1. `Write` и `Fill`: Из RAM в память GPU;
2. `Read` и `Get`: Из памяти GPU в RAM;
3. `Copy`: Между двумя областями памяти GPU.

И по типу данных на стороне RAM:
1. `Data`: Используются данные, находящиеся в RAM по указанному адресу;
2. `Value`: Используется размерное значение;
3. `Array`: Используется содержимое указанного массива размерных значений.

Но при этом отсутствуют некоторые комбинации.

В первую очередь, в случае `Copy` нет понятия типа данных на стороне RAM, потому что RAM в принципе не задействуется.

Так же, `WriteValue` может принимать размерное значение и `NativeValue`, но `ReadValue` принимает только `NativeValue`.\
Это потому, что принимать размерное значение в `ReadValue` `var`-параметром не безопастно,
как и в случае передачи адреса в качестве <a path="../../Простые обёртки/Kernel/KernelArg"> `KernelArg` </a>.\
Если вы понимаете что делаете - используйте `ReadData`, явно передавая в него адрес вашего значения (то есть указатель).\
Но обычно лучше использовать `GetValue`, создающее и возвращающее новое размерное значение, либо `ReadValue` принимающее `NativeValue`.

---

Кроме таких объектов, методы-команды для GPU есть только у `Kernel`. И все они представляют запуск kernel'а.


