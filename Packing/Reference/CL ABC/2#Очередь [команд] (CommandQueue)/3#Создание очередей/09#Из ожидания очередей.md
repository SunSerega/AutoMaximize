


Большинство деревьев выполнения очередей можно реализовать используя только сложение и умножение очередей. Но есть несколько проблем:

-  Большинство но не все. Пример дерева которое нельзя реализовать через сложение и умножение можно найти [тут](https://github.com/SunSerega/POCGL/blob/master/Samples/OpenCLABC/Wait%20очереди/1.pas) или в файле:\
   C:\\PABCWork.NET\\Samples\\OpenGL и OpenCL\\OpenCLABC\\Wait очереди\\1.pas
   
-  Даже если дерево реализуется сложением+умножением - такая реализация может выглядеть запутано и не похоже на график дерева выполнения, [к примеру](https://github.com/SunSerega/POCGL/blob/master/Samples/OpenCLABC/Wait%20очереди/2.pas):\
   C:\\PABCWork.NET\\Samples\\OpenGL и OpenCL\\OpenCLABC\\Wait очереди\\2.pas
   
-  Очереди, выполняемые на разных контекстах не могут эффективно взаимодействовать.

Эти проблемы решают `Wait`-очереди:
```
## uses OpenCLABC;

var M := WaitMarker.Create;

var t := Context.Default.BeginInvoke(
  HPQ(()->Writeln('Начало .BeginInvoke')) +
  WaitFor(M) +
  HPQ(()->Writeln('Конец .BeginInvoke'))
);

Sleep(2000);
Writeln('Посылаем сигнал маркера M');
M.SendSignal;

t.Wait;
```
`WaitFor(M)` создаёт очень простую `Wait`-очередь.\
Внутри вызова `.BeginInvoke` (до того как он вернёт `CLTask`)
эта очередь входит в режим ожидания сигналов от маркера `M`.\
В этом режиме она **не** тратит время процессора, но готова возобновить выполнение в любой момент.

Далее, вызов `M.SendSignal` посылает по 1 сигналу всем `.BeginInvoke`, имеющим `Wait` очереди в ожидании этого сигнала.

---

`WaitMarker`, так же, является своеобразной очередью, то есть
его можно складывать с другими очередями и передавать в `.BeginInvoke` .\
При выполнении в качестве очереди маркер вызывает свой метод `.SendSignal` и сразу возвращает `nil`, так же как `HPQ`.\
То есть как очередь он равноценен `HPQ(M.SendSignal)`, но немного более эффективен.

Но стоит так же сказать, прямой вызов `M.SendSignal` всё равно всегда эффективнее чем `Context.Default.SyncInvoke(M)`.\
Используйте выполнение маркеров внутри `.BeginInvoke` только если вам надо активировать его сразу после других очередей:
```
var M := new WaitMarker;

Context.Default.SyncInvoke(
  HFQ(()->5) + M
);
```

---

Но в этом же коде видно ещё одну проблему - сложение очередей возвращает последний результат,
то есть результат маркера (который `nil`).

Если нужно иметь сразу и маркер и возвращаемое значение предыдущей очереди,
можно создать оторванный сигнал маркера методом `.ThenMarkerSignal`:
```
## uses OpenCLABC;
var Q := HFQ(()->5).ThenMarkerSignal;

var t := Context.Default.BeginInvoke(
  WaitFor(Q) + HPQ(()->Writeln('Получен сигнал от Q'))
);
var res := Context.Default.SyncInvoke( Q );

t.Wait;
res.Println;
```
Такой сигнал можно ожидать `Wait`-очередью, но при этом он
сохраняет результат оригинальной очереди при выполнении в `.BeginInvoke`.

Точнее `Q` в последнем коде сначала выполнит `HFQ`, затем пошлёт сигнал в
`Wait` очередь `WaitFor(Q)` и в конце вернёт то, что вернула `HFQ`.

Того же эффекта можно добится используя `.Multiusable`:
```
## uses OpenCLABC;

var Qs := HFQ(()->5).Multiusable;
var M := WaitMarker.Create;

var t := Context.Default.BeginInvoke(
  WaitFor(M) + HPQ(()->Writeln('Получен сигнал от M'))
);
var res := Context.Default.SyncInvoke( Qs()+M+Qs() );

t.Wait;
res.Println;
```
То есть `.ThenMarkerSignal` не имеет незаменимых применений, но делает код читабельнее.

---

Есть всего 3 подпрограммы, создающие `Wait` очереди:

1. Глобальная, `WaitFor`:\
   Ничего не делает сама, но блокирует выполнение, ожидая сигнала указанного маркера.
   
2. Ещё один особый метод `.Add*` - `.AddWait`:\
   Как и `.AddQueue` и `.AddProc`, `.AddWait(...)` это всего лишь аналог
   `.AddQueue(WaitFor(...))`, существующий только ради читабельности кода.
   
3. Метод очереди, `.ThenWaitFor`:\
   Как и `.ThenMarkerSignal`, сначала выполняет исходную очередь, потом ожидает и в конце возвращает результат исходной очереди.

---

Маркеры можно комбинировать:
```
## uses OpenCLABC;

var M1 := WaitMarker.Create;
var M2 := WaitMarker.Create;

WaitFor(M1 and M2); // Ожидание обоих маркеров
WaitFor(M1 or M2); // Ожидание любого из маркеров
```
При этом если надо применить `and` или `or` >2 маркерам - лучше использовать `WaitAll`/`WaitAny` соответственно:
```
## uses OpenCLABC;

var M1 := WaitMarker.Create;
var M2 := WaitMarker.Create;
var M3 := WaitMarker.Create;

WaitFor(WaitAll(M1,M2,M3)); // Ожидание всех маркеров
WaitFor(WaitAny(M1,M2,M3)); // Ожидание любого из маркеров
```

---

`Wait` очереди работают даже между вызовами `Context.BeginInvoke`, в отличии от всего остального в `OpenCLABC`.

Это не всегда безопастно:
```
Context.Default.BeginInvoke(M);
Context.Default.BeginInvoke(WaitFor(M) + Q);
```
Проблема этого кода в том, что `M` может послать сигнал ещё до того как `WaitFor(M)` начнёт ждать.

Чтоб такое не происходило - надо всегда запускать `Wait` очередь раньше маркера:
```
Context.Default.BeginInvoke(WaitFor(M) + Q);
Context.Default.BeginInvoke(M);
```
Но, как всегда, лучше объединять вызовы `Context.BeginInvoke`:
```
Context.Default.BeginInvoke(
  ( M ) *
  ( WaitFor(M) + Q )
);
```
Все `Wait` очереди начинают ждать в самом начале вызова `Context.BeginInvoke`, перед началом выполнения очереди.
Поэтому если `Wait` очередь и вызов её маркера находятся в общем `Context.BeginInvoke` - использовать их можно в любом порядке.

---

Все `Wait` очереди в одном `Context.BeginInvoke`, ожидающие один и тот же маркер, образуют общую `Wait` группу.\
Когда ожидаемый этой группой маркер активируется - он удаляет из `Wait` группы одну из `Wait` очередей, посылая ей сигнал.
```
## uses OpenCLABC;

var Q1 := HPQ(()->
begin
  Sleep(10);
  lock output do Writeln('Выполнилась Q1');
end).ThenMarkerSignal;

var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));

var t1 := Context.Default.BeginInvoke(
  (WaitFor(Q1)+Q2) *
  (WaitFor(Q1)+Q3)
);
Context.Default.SyncInvoke(Q1+Q1);

// Все оставшиеся CLTask лучше ожидать, чтобы
// вывести ошибки, если возникнут при выполнении очереди
t1.Wait;
```
Тут `Q1` посылает 2 сигнала, сначала в первый `WaitFor(Q1)`, затем во второй.\
В данный момент не рекомендуется расчитывать на порядок `Wait` очередей в `Wait` группе.

Ну и, конечно, лучше совместить вызовы `Context.BeginInvoke`, раз контекст общий:
```
## uses OpenCLABC;

var Q1 := HPQ(()->
begin
  Sleep(10);
  lock output do Writeln('Выполнилась Q1');
end).ThenMarkerSignal;

var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));

Context.Default.SyncInvoke(
  (Q1+Q1) *
  (WaitFor(Q1)+Q2) *
  (WaitFor(Q1)+Q3)
);
```
Будьте осторожны, лишняя `Wait` очередь вызовет зависание:
```
## uses OpenCLABC;

var Q1 := HFQ(()->0).ThenMarkerSignal;

var t1 := Context.Default.BeginInvoke(
  WaitFor(Q1) +
  // Второй запуск Q1 никогда не произойдёт,
  // поэтому эта Wait очередь зависнет
  WaitFor(Q1)
);
Context.Default.SyncInvoke(Q1);

t1.Wait;
```

---

`Wait` очереди ожидающие один и тот же маркер в разных `Context.BeginInvoke` - образуют отдельные `Wait` группы.\
И при активации маркера - он посылает по 1 сигналу **каждой** `Wait` группе:
```
## uses OpenCLABC;

var Q1 := HPQ(()->
begin
  Sleep(1000);
  lock output do Writeln('Выполнилась Q1');
end).ThenMarkerSignal;

var Q2 := HPQ(()->lock output do Writeln('Выполнилась Q2'));
var Q3 := HPQ(()->lock output do Writeln('Выполнилась Q3'));

var Q4 := HPQ(()->lock output do Writeln('Выполнилась Q4'));
var Q5 := HPQ(()->lock output do Writeln('Выполнилась Q5'));

var t1 := Context.Default.BeginInvoke(
  ( WaitFor(Q1)+Q2 ) *
  ( WaitFor(Q1)+Q3 )
);
var t2 := Context.Default.BeginInvoke(
  ( WaitFor(Q1)+Q4 ) *
  ( WaitFor(Q1)+Q5 )
);
// Каждый вызов Q1 тут - активирует по одному WaitFor(Q1) в каждом .BeginInvoke
Context.Default.SyncInvoke(Q1+Q1);

t1.Wait;
t2.Wait;
```


