


OpenCL это неуправляемая библиотека. Обычно можно заставить управляеммые типы данных работать с ней.\
Но часто это приводит к дополнительным затратам производительности.\
И обычно не значит всегда - `MemorySegment.ReadValue`, принимающее запись `var`-параметром не может быть безопасным из за сборщика мусора
(и поэтому отсутствует).

Более прямым будет передача неуправляемых типов - указателей - без преобразований в подпрограммы модуля `OpenCL`.\
И эта возможность тоже существует, к примеру в виде `MemorySegment.WriteData`. Но такие указатели ещё более не_безопасны:\
Как минимум они требуют освобождения в `try-finally` чтобы избежать утечек памяти.
И защиты от дурака, не возволяющей записать значение типа `real` туда, где хранится `int64` - не существует.

Как что-то среднее между этими двумя вариантами - существует `NativeValue<T>`:\
Этот класс является обёрткой указателя. Именно обычного указателя - не памяти `GPU` как все остальные простые обёртки `OpenCLABC`.
```
## uses OpenCLABC;

// В конструктор необходимо передавать значение,
// потому что иначе неуправляемая память будет содержать мусор
// Но можно передать default, чтобы заполнить выделяемую память нулями
var nv := new NativeValue<integer>(default(integer));

nv.Value := 5; // Значение можно и читать,
nv.Value.Println; // и перезаписывать

// Напрямую получать доступ к области памяти,
// через свойство Pointer, не рекомендуется
Writeln(nv.Pointer);

nv.Dispose; // Освобождение памяти - вызывается и само при сборке мусора
```


