


Делегат - это адрес подпрограммы:
```
procedure p1(i: integer);
begin
  Writeln(i);
end;

begin
  
  var d: System.Delegate := p1; // это не вызов, а получение адреса p1
  d.DynamicInvoke(5); // вообще .DynamicInvoke это очень медленно
  
  var p: integer->();
  // Такое же объявление как на предыдущей строчке, но в другом стиле
//  var p: Action<integer>;
  // И ещё один стиль. Этот особенный, потому что
  // он неявно создаёт новый тип делегата
//  var p: procedure(i: integer);
  p := p1;
  
  // Типизированные делегаты можно вызывать быстрее и проще,
  // так же как обычные подпрограммы
  p(5);
  
end.
```

---

Так же как обычные подпрограммы - подпрограммы из неуправляемых .dll могут принимать делегаты параметром.\
Далее всё будет рассматриваться на примере `cl.SetEventCallback` из модуля `OpenCL`, потому что с ним есть особые проблемы.

:::spoiler { summary="Объявления" hidden=true }

Объявление `cl.SetEventCallback`:
```
    static function SetEventCallback(&event: cl_event; command_exec_callback_type: CommandExecutionStatus; pfn_notify: EventCallback; user_data: IntPtr): ErrorCode;
```
Объявление `EventCallback`:
```
  EventCallback = procedure(&event: cl_event; event_command_status: CommandExecutionStatus; user_data: IntPtr);
```

:::

Рассмотрим следующий пример:
```
uses System;
uses OpenCL;

begin
  
  var cb: EventCallback := (ev,st,data)->
  begin
    Writeln($'{ev} перешёл в состояние {st}');
  end;
  
  var ev: cl_event; //ToDo := ...
  
  cl.SetEventCallback(ev, CommandExecutionStatus.COMPLETE, cb,IntPtr.Zero).RaiseIfError;
end.
```
Этот код может время от времени вылетать, потому что:

1. `cl.SetEventCallback` вызывает свой коллбек тогда, когда посчитает нужным (но обычно после того как вызов `cl.SetEventCallback` завершился);

2. Делегаты - это классы.

3. Сборщик мусора распоряжается памятью классов и удаляет их, тоже когда посчитает нужным.

Раз после вызова `cl.SetEventCallback` делегат `cb` больше нигде не используется - сборщик мусора может в любой момент
решить удалить его. Но, опять же, это редко случается сразу после вызова `cl.SetEventCallback`,
поэтому ошибки связанные с этим удалением могут быть плавающие.

Если сборщик мусора удалит делегат, а затем .dll попытается его вызвать -
это приведёт или к ошибке доступа, или к моментальному беззвучному вылету.

Чтоб запретить сборщику мусора удалять делегать - нужно создать `GCHandle`, привязанный к нему.\
Но в отличии от массивов - `GCHandleType.Pinned` не нужно, потому что сборщик мусора
не может перемещать адрес исполняемого кода (а он единственное что передаётся в .dll).
Это потому, что этот адрес хранится в виде указателя на неуправляемый код.

```
uses System.Runtime.InteropServices;
uses System;
uses OpenCL;

begin
  
  var gc_hnd: GCHandle;
  var cb: EventCallback := (ev,st,data)->
  begin
    
    Writeln($'{ev} перешёл в состояние {st}');
    
    // В данном случае освобождать GCHandle станет можно тогда, когда делегат 1 раз выполнится,
    // А значит очень удобно поставить освобождение в конец самого делегата
    gc_hnd.Free;
  end;
  gc_hnd := GCHandle.Alloc(cb);
  
  var ev: cl_event; //ToDo := ...
  
  cl.SetEventCallback(ev, CommandExecutionStatus.COMPLETE, cb,IntPtr.Zero).RaiseIfError;
end.
```


