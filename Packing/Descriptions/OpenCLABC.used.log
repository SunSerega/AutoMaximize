# CLArray<T>
Представляет массив записей, содержимое которого хранится на устройстве OpenCL (обычно GPU)

# CLArray<T>.(array of T)
Выделяет память OpenCL и копирует в неё содержимое указанного массива
Память выделяется в контексте Context.Default

# CLArray<T>.(cl_mem)
# CLMemorySegment.FromNative(cl_mem)
# CLValue<T>.(cl_mem)
# Context.(cl_context)
# Context.(cl_context, Device)
# Kernel.(cl_kernel, boolean)
# ProgramCode.(cl_program)
Создаёт обёртку для указанного неуправляемого объекта
При успешном создании обёртки вызывается cl.Retain
А во время вызова .Dispose - cl.Release

# CLArray<T>.(Context, array of T)
Выделяет память OpenCL и копирует в неё содержимое указанного массива
Память выделяется в указанном контексте

# CLArray<T>.(Context, integer)
Выделяет память OpenCL под указанное кол-во элементов, заполненную мусорными данными
Память выделяется в указанном контексте

# CLArray<T>.(Context, integer, integer, array of T)
Выделяет память OpenCL и копирует в неё содержимое участка указанного массива
Память выделяется в указанном контексте

# CLArray<T>.(integer)
Выделяет память OpenCL под указанное кол-во элементов, заполненную мусорными данными
Память выделяется в контексте Context.Default

# CLArray<T>.(integer, integer, array of T)
Выделяет память OpenCL и копирует в неё содержимое участка указанного массива
Память выделяется в контексте Context.Default

# CLArray<T>.ByteSize
Возвращает размер области памяти, занимаемой массивом, в байтах

# CLArray<T>.CopyFrom(CommandQueue<CLArray<&T>>)
# CLArrayCCQ<T>.ThenCopyFrom(CommandQueue<CLArray<&T>>)
Копирует элементы из a в данный массив
Если у массивов разный размер - копируется кол-во элементов меньшего массива

# CLArray<T>.CopyFrom(CommandQueue<CLArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyFrom(CommandQueue<CLArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует элементы из a в данный массив
from_ind указывает индекс в массиве, из которого копируют
to_ind указывает индекс в массиве, в который копируют
len указывает кол-во копируемых элементов

# CLArray<T>.CopyFrom(CommandQueue<CLMemorySegment>)
# CLArrayCCQ<T>.ThenCopyFrom(CommandQueue<CLMemorySegment>)
Копирует элементы из mem в данный массив
Копируется максимальное кол-во байт, не выходящее за границы данного массива и mem

# CLArray<T>.CopyFrom(CommandQueue<CLMemorySegment>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyFrom(CommandQueue<CLMemorySegment>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует элементы из mem в данный массив
mem_offset указывает отступ от начала области памяти, в байтах
ind указывает индекс первого элемента данного массива
len указывает кол-во копируемых элементов

# CLArray<T>.CopyFrom(CommandQueue<CLValue<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyFrom(CommandQueue<CLValue<&T>>, CommandQueue<integer>)
Копирует val в элемент данного массива с индексом ind

# CLArray<T>.CopyTo(CommandQueue<CLArray<&T>>)
# CLArrayCCQ<T>.ThenCopyTo(CommandQueue<CLArray<&T>>)
Копирует элементы из данного массива в a
Если у массивов разный размер - копируется кол-во элементов меньшего массива

# CLArray<T>.CopyTo(CommandQueue<CLArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyTo(CommandQueue<CLArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует элементы из данного массива в a
from_ind указывает индекс в массиве, из которого копируют
to_ind указывает индекс в массиве, в который копируют
len указывает кол-во копируемых элементов

# CLArray<T>.CopyTo(CommandQueue<CLMemorySegment>)
# CLArrayCCQ<T>.ThenCopyTo(CommandQueue<CLMemorySegment>)
Копирует элементы из данного массива в mem
Копируется максимальное кол-во байт, не выходящее за границы данного массива и mem

# CLArray<T>.CopyTo(CommandQueue<CLMemorySegment>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyTo(CommandQueue<CLMemorySegment>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует элементы из данного массива в mem
mem_offset указывает отступ от начала области памяти, в байтах
ind указывает индекс первого элемента данного массива
len указывает кол-во копируемых элементов

# CLArray<T>.CopyTo(CommandQueue<CLValue<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenCopyTo(CommandQueue<CLValue<&T>>, CommandQueue<integer>)
Копирует элемент с индексом ind из данного массива в val

# CLArray<T>.Dispose
# CLMemorySegment.Dispose
# CLValue<T>.Dispose
# Context.Dispose
# Kernel.Dispose
# ProgramCode.Dispose
Позволяет OpenCL удалить неуправляемый объект
Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён

# CLArray<T>.Equals(object)
# CLMemorySegment.Equals(object)
# CLValue<T>.Equals(object)
# CommandQueue<T>.ConvertTyped<TRes>(ITypedCQConverter<TRes>)
# CommandQueue<T>.UseTyped(ITypedCQUser)
# CommandQueueNil.ConvertTyped<TRes>(ITypedCQConverter<TRes>)
# CommandQueueNil.UseTyped(ITypedCQUser)
# Context.Equals(object)
# Device.Equals(object)
# Kernel.Equals(object)
# Platform.Equals(object)
# ProgramCode.Equals(object)
--

# CLArray<T>.FillArray(CommandQueue<array of &T>)
# CLArray<T>.FillArray2(CommandQueue<array[,] of &T>)
# CLArray<T>.FillArray3(CommandQueue<array[,,] of &T>)
# CLArray<T>.FillNativeArray(CommandQueue<NativeArray<&T>>)
# CLArrayCCQ<T>.ThenFillArray(CommandQueue<array of &T>)
# CLArrayCCQ<T>.ThenFillArray2(CommandQueue<array[,] of &T>)
# CLArrayCCQ<T>.ThenFillArray3(CommandQueue<array[,,] of &T>)
# CLArrayCCQ<T>.ThenFillNativeArray(CommandQueue<NativeArray<&T>>)
Заполняет данный массив OpenCL копиями указанного массива RAM

# CLArray<T>.FillArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.FillNativeArray(CommandQueue<NativeArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillNativeArray(CommandQueue<NativeArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет fill_len элементов данного массива OpenCL копиями участков из pattern_len элементов указанного массива
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM

# CLArray<T>.FillArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.FillArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет fill_len элементов данного массива OpenCL копиями участков из pattern_len элементов указанного массива
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLArray<T>.FillArraySegment(CommandQueue<ArraySegment<&T>>)
# CLArrayCCQ<T>.ThenFillArraySegment(CommandQueue<ArraySegment<&T>>)
Заполняет данный массив OpenCL копиями указанного участка массива RAM

# CLArray<T>.FillArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет fill_len элементов данного массива OpenCL начиная с индекса ind копиями указанного участка массива RAM

# CLArray<T>.FillData(CommandQueue<IntPtr>, CommandQueue<integer>)
# CLArray<T>.FillData(pointer, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillData(CommandQueue<IntPtr>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillData(pointer, CommandQueue<integer>)
Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями весь данный массив

# CLArray<T>.FillData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.FillData(pointer, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillData(pointer, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Берёт pattern_len элементов из RAM по указанному адресу и заполняет их копиями len элементов начиная с индекса ind данного массива

# CLArray<T>.FillData(CommandQueue<NativeMemoryArea>)
# CLArrayCCQ<T>.ThenFillData(CommandQueue<NativeMemoryArea>)
Заполняет весь данный массив копиями содержимого указанной области памяти

# CLArray<T>.FillData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет len элементов начиная с индекса ind данного массива копиями содержимого указанной области памяти

# CLArray<T>.FillNativeValue(CommandQueue<NativeValue<&T>>)
# CLArray<T>.FillValue(&T)
# CLArray<T>.FillValue(CommandQueue<&T>)
# CLArrayCCQ<T>.ThenFillNativeValue(CommandQueue<NativeValue<&T>>)
# CLArrayCCQ<T>.ThenFillValue(&T)
# CLArrayCCQ<T>.ThenFillValue(CommandQueue<&T>)
Заполняет весь массив копиями указанного значения

# CLArray<T>.FillNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.FillValue(&T, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.FillValue(CommandQueue<&T>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillValue(&T, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenFillValue(CommandQueue<&T>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет len элементов начиная с индекса ind копиями указанного значения

# CLArray<T>.Finalize
# CLMemorySegment.Finalize
# CLValue<T>.Finalize
# Context.Finalize
# Kernel.Finalize
# NativeArray<T>.Finalize
# NativeValue<T>.Finalize
# ProgramCode.Finalize
# SubDevice.Finalize
Вызывает Dispose. Данный метод вызывается автоматически во время сборки мусора
Данный метод не должен вызываться из пользовательского кода. Он виден только на случай если вы хотите переопределить его в своём классе-наследнике

# CLArray<T>.GetArray
# CLArrayCCQ<T>.ThenGetArray
Читает весь данный массив OpenCL как массив RAM

# CLArray<T>.GetArray(CommandQueue<integer>)
# CLArray<T>.GetArray2(CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.GetArray3(CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenGetArray(CommandQueue<integer>)
# CLArrayCCQ<T>.ThenGetArray2(CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenGetArray3(CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Создаёт массив RAM с указанным кол-вом элементов и копирует в него данные из начала данного массива OpenCL

# CLArray<T>.GetValue(CommandQueue<integer>)
# CLArrayCCQ<T>.ThenGetValue(CommandQueue<integer>)
Читает элемент по указанному индексу

# CLArray<T>.Item[integer]
Возвращает или задаёт один элемент массива
Внимание! Данные свойство использует неявные очереди при каждом обращение, поэтому может быть очень не эффективным

# CLArray<T>.ItemSize
# NativeArray<T>.ItemSize
Возвращает размер одного элемента массива, в байтах

# CLArray<T>.Length
Возвращает длину массива

# CLArray<T>.Native
# CLMemorySegment.Native
# CLValue<T>.Native
# Context.Native
# Device.Native
# Kernel.Native
# Platform.Native
# ProgramCode.Native
Возвращает имя (дескриптор) неуправляемого объекта

# CLArray<T>.NewQueue
# CLMemorySegment.NewQueue
# CLValue<T>.NewQueue
# Kernel.NewQueue
Создаёт новую очередь-контейнер для команд GPU, применяемых к данному объекту

# CLArray<T>.Properties
# CLMemorySegment.Properties
# CLMemorySubSegment.Properties
# CLValue<T>.Properties
# Context.Properties
# Device.Properties
# Kernel.Properties
# Platform.Properties
# ProgramCode.Properties
# SubDevice.Properties
Возвращает контейнер свойств неуправляемого объекта

# CLArray<T>.ReadArray(CommandQueue<array of &T>)
# CLArray<T>.ReadArray2(CommandQueue<array[,] of &T>)
# CLArray<T>.ReadArray3(CommandQueue<array[,,] of &T>)
# CLArray<T>.ReadNativeArray(CommandQueue<NativeArray<&T>>)
# CLArrayCCQ<T>.ThenReadArray(CommandQueue<array of &T>)
# CLArrayCCQ<T>.ThenReadArray2(CommandQueue<array[,] of &T>)
# CLArrayCCQ<T>.ThenReadArray3(CommandQueue<array[,,] of &T>)
# CLArrayCCQ<T>.ThenReadNativeArray(CommandQueue<NativeArray<&T>>)
Читает начало данного массива OpenCL в указанный массив RAM

# CLArray<T>.ReadArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.ReadNativeArray(CommandQueue<NativeArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadNativeArray(CommandQueue<NativeArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Читает len элементов данного массива OpenCL в указанный массив RAM
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM

# CLArray<T>.ReadArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.ReadArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Читает len элементов данного массива OpenCL в указанный массив RAM
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLArray<T>.ReadArraySegment(CommandQueue<ArraySegment<&T>>)
# CLArrayCCQ<T>.ThenReadArraySegment(CommandQueue<ArraySegment<&T>>)
Читает начало данного массива OpenCL в указанный участок массива RAM

# CLArray<T>.ReadArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>)
Читает данные данного массива OpenCL в указанный участок массива RAM
ind указывает индекс первого элемента данного массива OpenCL

# CLArray<T>.ReadData(CommandQueue<IntPtr>)
# CLArray<T>.ReadData(pointer)
# CLArrayCCQ<T>.ThenReadData(CommandQueue<IntPtr>)
# CLArrayCCQ<T>.ThenReadData(pointer)
Читает всё содержимое из данного массива в RAM, по указанному адресу

# CLArray<T>.ReadData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.ReadData(pointer, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadData(pointer, CommandQueue<integer>, CommandQueue<integer>)
Читает len элементов начиная с индекса ind из данного массива в RAM, по указанному адресу

# CLArray<T>.ReadData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>)
Читает данные из данного массива в указанную область памяти, начиная с элемента с индексом ind

# CLArray<T>.ReadNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenReadNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>)
Читает элемент данного массива с индексом ind в указанное значение

# CLArray<T>.Slice[IntRange]
Возвращает или задаёт элементы массива в заданном диапазоне
Внимание! Данные свойство использует неявные очереди при каждом обращение, поэтому может быть очень не эффективным

# CLArray<T>.ToString
# CLMemorySegment.ToString
# CLMemorySubSegment.ToString
# CLValue<T>.ToString
# Context.ToString
# Device.ToString
# Kernel.ToString
# NativeArray<T>.ToString
# NativeMemoryArea.ToString
# NativeValue<T>.ToString
# Platform.ToString
# ProgramCode.ToString
# SubDevice.ToString
Возвращает строку с основными данными о данном объекте

# CLArray<T>.WriteArray(CommandQueue<array of &T>)
# CLArray<T>.WriteArray2(CommandQueue<array[,] of &T>)
# CLArray<T>.WriteArray3(CommandQueue<array[,,] of &T>)
# CLArray<T>.WriteNativeArray(CommandQueue<NativeArray<&T>>)
# CLArrayCCQ<T>.ThenWriteArray(CommandQueue<array of &T>)
# CLArrayCCQ<T>.ThenWriteArray2(CommandQueue<array[,] of &T>)
# CLArrayCCQ<T>.ThenWriteArray3(CommandQueue<array[,,] of &T>)
# CLArrayCCQ<T>.ThenWriteNativeArray(CommandQueue<NativeArray<&T>>)
Записывает указанный массив RAM в начало данного массива OpenCL

# CLArray<T>.WriteArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.WriteNativeArray(CommandQueue<NativeArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteArray(CommandQueue<array of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteNativeArray(CommandQueue<NativeArray<&T>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Записывает len элементов из указанного массива RAM в данный массив OpenCL
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM

# CLArray<T>.WriteArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.WriteArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteArray2(CommandQueue<array[,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteArray3(CommandQueue<array[,,] of &T>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Записывает len элементов из указанного массива RAM в данный массив OpenCL
ind указывает индекс первого элемента данного массива OpenCL
a_ind(-ы) указывают индекс первого элемента в массиве RAM
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLArray<T>.WriteArraySegment(CommandQueue<ArraySegment<&T>>)
# CLArrayCCQ<T>.ThenWriteArraySegment(CommandQueue<ArraySegment<&T>>)
Записывает указанный участок массива RAM в начало данного массива OpenCL

# CLArray<T>.WriteArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteArraySegment(CommandQueue<ArraySegment<&T>>, CommandQueue<integer>)
Записывает указанный участок массива RAM в данный массив OpenCL
ind указывает индекс первого элемента данного массива OpenCL

# CLArray<T>.WriteData(CommandQueue<IntPtr>)
# CLArray<T>.WriteData(pointer)
# CLArrayCCQ<T>.ThenWriteData(CommandQueue<IntPtr>)
# CLArrayCCQ<T>.ThenWriteData(pointer)
Заполняет весь данный массив данными, находящимися по указанному адресу в RAM

# CLArray<T>.WriteData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLArray<T>.WriteData(pointer, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteData(pointer, CommandQueue<integer>, CommandQueue<integer>)
Заполняет len элементов начиная с индекса ind данного массива данными, находящимися по указанному адресу в RAM

# CLArray<T>.WriteData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>)
Записывает данные из указанной области памяти в данный массив, начиная с элемента с индексом ind

# CLArray<T>.WriteNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>)
# CLArray<T>.WriteValue(&T, CommandQueue<integer>)
# CLArray<T>.WriteValue(CommandQueue<&T>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteNativeValue(CommandQueue<NativeValue<&T>>, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteValue(&T, CommandQueue<integer>)
# CLArrayCCQ<T>.ThenWriteValue(CommandQueue<&T>, CommandQueue<integer>)
Записывает указанное значение в элемент данного массива с индексом ind

# CLArrayCCQ<T>
Представляет очередь-контейнер для команд GPU, применяемых к объекту типа CLArray

# CLArrayCCQ<T>.(CLArray<T>)
# CLMemorySegmentCCQ.(CLMemorySegment)
# CLValueCCQ<T>.(CLValue<T>)
# KernelCCQ.(Kernel)
Создаёт контейнер команд, который будет применять команды к указанному объекту

# CLArrayCCQ<T>.(CommandQueue<CLArray<T>>)
# CLMemorySegmentCCQ.(CommandQueue<CLMemorySegment>)
# CLValueCCQ<T>.(CommandQueue<CLValue<T>>)
# KernelCCQ.(CommandQueue<Kernel>)
Создаёт контейнер команд, который будет применять команды к объекту, который вернёт указанная очередь
За каждое одно выполнение контейнера - q выполнится ровно один раз

# CLArrayCCQ<T>.ThenProc((CLArray<T>, Context)->())
# CLArrayCCQ<T>.ThenProc(CLArray<T>->())
# CLMemorySegmentCCQ.ThenProc((CLMemorySegment, Context)->())
# CLMemorySegmentCCQ.ThenProc(CLMemorySegment->())
# CLValueCCQ<T>.ThenProc((CLValue<T>, Context)->())
# CLValueCCQ<T>.ThenProc(CLValue<T>->())
# KernelCCQ.ThenProc((Kernel, Context)->())
# KernelCCQ.ThenProc(Kernel->())
Добавляет выполнение процедуры на CPU в список обычных команд для GPU
Переданный делегат выполняется в отдельном потоке выполнения (Thread)
Если делегат выполняется быстро и выделение нового потока излишне - используйте соответствующую функцию, начинающуюся на ".ThenQuick..."

# CLArrayCCQ<T>.ThenQueue(CommandQueueBase)
# CLMemorySegmentCCQ.ThenQueue(CommandQueueBase)
# CLValueCCQ<T>.ThenQueue(CommandQueueBase)
# KernelCCQ.ThenQueue(CommandQueueBase)
Добавляет выполнение очереди в список обычных команд для GPU

# CLArrayCCQ<T>.ThenQuickProc((CLArray<T>, Context)->())
# CLArrayCCQ<T>.ThenQuickProc(CLArray<T>->())
# CLMemorySegmentCCQ.ThenQuickProc((CLMemorySegment, Context)->())
# CLMemorySegmentCCQ.ThenQuickProc(CLMemorySegment->())
# CLValueCCQ<T>.ThenQuickProc((CLValue<T>, Context)->())
# CLValueCCQ<T>.ThenQuickProc(CLValue<T>->())
# KernelCCQ.ThenQuickProc((Kernel, Context)->())
# KernelCCQ.ThenQuickProc(Kernel->())
Добавляет выполнение процедуры на CPU в список обычных команд для GPU
Переданный делегат старается выполняется в одном из уже существующих потоков выполнения, но так чтобы не нарушить порядок выполнения дерева очередей
Из делегата категорически нельзя вызывать функции модуля OpenCL блокирующие выполнение, к примеру "cl.WaitForEvents", "clFinish" и блокирующий "cl.EnqueueReadBuffer"
Подробнее - читайте в документации библиотеки OpenCL про функцию "clSetEventCallback"
Так же в делегате не желательно использовать долго выполняющиеся алгоритмы, особенно ввод с клавиатуры
Если эти ограничения не подходят, используйте соответствующую функцию, без "Quick" в названии

# CLArrayCCQ<T>.ThenWait(WaitMarker)
# CLMemorySegmentCCQ.ThenWait(WaitMarker)
# CLValueCCQ<T>.ThenWait(WaitMarker)
# KernelCCQ.ThenWait(WaitMarker)
Добавляет ожидание сигнала выполненности от заданного маркера

# CLMemorySegment
Представляет область памяти устройства OpenCL (обычно GPU)

# CLMemorySegment.(int64)
# CLMemorySegment.(integer)
# CLMemorySegment.(UIntPtr)
Выделяет область памяти устройства OpenCL указанного в байтах размера
Память выделяется в контексте Context.Default

# CLMemorySegment.(int64, Context)
# CLMemorySegment.(integer, Context)
# CLMemorySegment.(UIntPtr, Context)
Выделяет область памяти устройства OpenCL указанного в байтах размера
Память выделяется в указанном контексте

# CLMemorySegment.CopyFrom(CommandQueue<CLMemorySegment>)
# CLMemorySegmentCCQ.ThenCopyFrom(CommandQueue<CLMemorySegment>)
Копирует данные из mem в данную область памяти
Если области памяти имеют разный размер - в качестве объёма данных берётся размер меньшей области

# CLMemorySegment.CopyFrom(CommandQueue<CLMemorySegment>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenCopyFrom(CommandQueue<CLMemorySegment>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует данные из mem в данную область памяти
from_offset указывает отступ в байтах от начала области памяти, из которой копируют
to_offset указывает отступ в байтах от начала области памяти, в которую копируют
len указывает кол-во копируемых байт

# CLMemorySegment.CopyTo(CommandQueue<CLMemorySegment>)
# CLMemorySegmentCCQ.ThenCopyTo(CommandQueue<CLMemorySegment>)
Копирует данные из данной области памяти в mem
Если области памяти имеют разный размер - в качестве объёма данных берётся размер меньшей области

# CLMemorySegment.CopyTo(CommandQueue<CLMemorySegment>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenCopyTo(CommandQueue<CLMemorySegment>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Копирует данные из данной области памяти в mem
from_offset указывает отступ в байтах от начала области памяти, из которой копируют
to_offset указывает отступ в байтах от начала области памяти, в которую копируют
len указывает кол-во копируемых байт

# CLMemorySegment.FillArray1<TRecord>(array of TRecord)
# CLMemorySegment.FillArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemorySegment.FillArray2<TRecord>(array[,] of TRecord)
# CLMemorySegment.FillArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemorySegment.FillArray3<TRecord>(array[,,] of TRecord)
# CLMemorySegment.FillArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemorySegment.FillNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemorySegment.FillNativeArray<TRecord>(NativeArray<TRecord>)
# CLMemorySegmentCCQ.ThenFillArray1<TRecord>(array of TRecord)
# CLMemorySegmentCCQ.ThenFillArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemorySegmentCCQ.ThenFillArray2<TRecord>(array[,] of TRecord)
# CLMemorySegmentCCQ.ThenFillArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemorySegmentCCQ.ThenFillArray3<TRecord>(array[,,] of TRecord)
# CLMemorySegmentCCQ.ThenFillArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemorySegmentCCQ.ThenFillNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemorySegmentCCQ.ThenFillNativeArray<TRecord>(NativeArray<TRecord>)
Заполняет область памяти копиями указанного массива

# CLMemorySegment.FillArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.FillArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.FillNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.FillNativeArray<TRecord>(NativeArray<TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillNativeArray<TRecord>(NativeArray<TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет область памяти копиями указанного участка массива
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт

# CLMemorySegment.FillArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.FillArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.FillArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.FillArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет область памяти копиями указанного участка массива
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLMemorySegment.FillArraySegment<TRecord>(ArraySegment<TRecord>)
# CLMemorySegmentCCQ.ThenFillArraySegment<TRecord>(ArraySegment<TRecord>)
Заполняет область памяти копиями указанного участка массива

# CLMemorySegment.FillArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
Заполняет область памяти копиями указанного участка массива
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт

# CLMemorySegment.FillData(CommandQueue<IntPtr>, CommandQueue<integer>)
# CLMemorySegment.FillData(pointer, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillData(CommandQueue<IntPtr>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillData(pointer, CommandQueue<integer>)
Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями всю область памяти

# CLMemorySegment.FillData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.FillData(pointer, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillData(pointer, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Берёт последовательность из pattern_len байт из RAM по указанному адресу и заполняет её копиями часть области памяти
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт

# CLMemorySegment.FillData(CommandQueue<NativeMemoryArea>)
# CLMemorySegmentCCQ.ThenFillData(CommandQueue<NativeMemoryArea>)
Берёт последовательность байт указанной области памяти RAM и заполняет её копиями всю данную область памяти OpenCL

# CLMemorySegment.FillData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>, CommandQueue<integer>)
Берёт последовательность байт указанной области памяти RAM и заполняет её копиями часть данной области памяти OpenCL
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт

# CLMemorySegment.FillNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemorySegment.FillNativeValue<TRecord>(NativeValue<TRecord>)
# CLMemorySegment.FillValue<TRecord>(CommandQueue<TRecord>)
# CLMemorySegment.FillValue<TRecord>(TRecord)
# CLMemorySegmentCCQ.ThenFillNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemorySegmentCCQ.ThenFillNativeValue<TRecord>(NativeValue<TRecord>)
# CLMemorySegmentCCQ.ThenFillValue<TRecord>(CommandQueue<TRecord>)
# CLMemorySegmentCCQ.ThenFillValue<TRecord>(TRecord)
Заполняет всю область памяти копиями указанного значения размерного типа

# CLMemorySegment.FillNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.FillNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.FillValue<TRecord>(CommandQueue<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.FillValue<TRecord>(TRecord, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillValue<TRecord>(CommandQueue<TRecord>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenFillValue<TRecord>(TRecord, CommandQueue<integer>, CommandQueue<integer>)
Заполняет часть области памяти копиями указанного значения размерного типа
mem_offset указывает отступ от начала области памяти, в байтах
fill_byte_len указывает кол-во заливаемых байт

# CLMemorySegment.GetArray<TRecord>
# CLMemorySegmentCCQ.ThenGetArray<TRecord>
Создаёт массив с максимальным возможным кол-вом элементов и заполняет его содержимым области памяти

# CLMemorySegment.GetArray<TRecord>(CommandQueue<integer>)
# CLMemorySegment.GetArray2<TRecord>(CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.GetArray3<TRecord>(CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenGetArray<TRecord>(CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenGetArray2<TRecord>(CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenGetArray3<TRecord>(CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Создаёт массив с указанным кол-вом элементов и копирует в него содержимое из начала области памяти

# CLMemorySegment.GetValue<TRecord>
# CLMemorySegmentCCQ.ThenGetValue<TRecord>
Читает значение указанного размерного типа из начала области памяти

# CLMemorySegment.GetValue<TRecord>(CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenGetValue<TRecord>(CommandQueue<integer>)
Читает значение указанного размерного типа из области памяти
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemorySegment.ReadArray1<TRecord>(array of TRecord)
# CLMemorySegment.ReadArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemorySegment.ReadArray2<TRecord>(array[,] of TRecord)
# CLMemorySegment.ReadArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemorySegment.ReadArray3<TRecord>(array[,,] of TRecord)
# CLMemorySegment.ReadArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemorySegment.ReadNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemorySegment.ReadNativeArray<TRecord>(NativeArray<TRecord>)
# CLMemorySegmentCCQ.ThenReadArray1<TRecord>(array of TRecord)
# CLMemorySegmentCCQ.ThenReadArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemorySegmentCCQ.ThenReadArray2<TRecord>(array[,] of TRecord)
# CLMemorySegmentCCQ.ThenReadArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemorySegmentCCQ.ThenReadArray3<TRecord>(array[,,] of TRecord)
# CLMemorySegmentCCQ.ThenReadArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemorySegmentCCQ.ThenReadNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemorySegmentCCQ.ThenReadNativeArray<TRecord>(NativeArray<TRecord>)
Заполняет весь массив байбами из начала области памяти

# CLMemorySegment.ReadArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.ReadArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.ReadNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.ReadNativeArray<TRecord>(NativeArray<TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadNativeArray<TRecord>(NativeArray<TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Читает данные из области памяти в указанный участок массива
mem_offset указывает отступ от начала области памяти, в байтах
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива

# CLMemorySegment.ReadArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.ReadArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.ReadArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.ReadArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Читает данные из области памяти в указанный участок массива
mem_offset указывает отступ от начала области памяти, в байтах
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLMemorySegment.ReadArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>)
Читает данные из области памяти в указанный участок массива
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemorySegment.ReadData(CommandQueue<IntPtr>)
# CLMemorySegment.ReadData(pointer)
# CLMemorySegmentCCQ.ThenReadData(CommandQueue<IntPtr>)
# CLMemorySegmentCCQ.ThenReadData(pointer)
Читает всё содержимое области памяти в RAM, по указанному адресу

# CLMemorySegment.ReadData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.ReadData(pointer, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadData(pointer, CommandQueue<integer>, CommandQueue<integer>)
Читает часть содержимого области памяти в RAM, по указанному адресу
mem_offset указывает отступ от начала области памяти, в байтах
len указывает кол-во задействованных в операции байт

# CLMemorySegment.ReadData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>)
Читает достаточно данных данной области памяти OpenCL чтобы заполнить всю указанную область памяти RAM
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemorySegment.ReadNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemorySegment.ReadNativeValue<TRecord>(NativeValue<TRecord>)
# CLMemorySegmentCCQ.ThenReadNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemorySegmentCCQ.ThenReadNativeValue<TRecord>(NativeValue<TRecord>)
Читает значение размерного типа из начала области памяти в указанное значение

# CLMemorySegment.ReadNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>)
# CLMemorySegment.ReadNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenReadNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>)
Читает значение размерного типа из области памяти в указанное значение
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemorySegment.Size
# CLMemorySegment.Size32
# CLMemorySegment.Size64
Возвращает размер области памяти в байтах

# CLMemorySegment.WriteArray1<TRecord>(array of TRecord)
# CLMemorySegment.WriteArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemorySegment.WriteArray2<TRecord>(array[,] of TRecord)
# CLMemorySegment.WriteArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemorySegment.WriteArray3<TRecord>(array[,,] of TRecord)
# CLMemorySegment.WriteArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemorySegment.WriteNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemorySegment.WriteNativeArray<TRecord>(NativeArray<TRecord>)
# CLMemorySegmentCCQ.ThenWriteArray1<TRecord>(array of TRecord)
# CLMemorySegmentCCQ.ThenWriteArray1<TRecord>(CommandQueue<array of TRecord>)
# CLMemorySegmentCCQ.ThenWriteArray2<TRecord>(array[,] of TRecord)
# CLMemorySegmentCCQ.ThenWriteArray2<TRecord>(CommandQueue<array[,] of TRecord>)
# CLMemorySegmentCCQ.ThenWriteArray3<TRecord>(array[,,] of TRecord)
# CLMemorySegmentCCQ.ThenWriteArray3<TRecord>(CommandQueue<array[,,] of TRecord>)
# CLMemorySegmentCCQ.ThenWriteNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>)
# CLMemorySegmentCCQ.ThenWriteNativeArray<TRecord>(NativeArray<TRecord>)
Записывает весь массив в начало области памяти

# CLMemorySegment.WriteArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.WriteArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.WriteNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.WriteNativeArray<TRecord>(NativeArray<TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteArray1<TRecord>(array of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteArray1<TRecord>(CommandQueue<array of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteNativeArray<TRecord>(CommandQueue<NativeArray<TRecord>>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteNativeArray<TRecord>(NativeArray<TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Записывает указанный участок массива в область памяти
mem_offset указывает отступ от начала области памяти, в байтах
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива

# CLMemorySegment.WriteArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.WriteArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.WriteArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.WriteArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteArray2<TRecord>(array[,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteArray2<TRecord>(CommandQueue<array[,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteArray3<TRecord>(array[,,] of TRecord, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteArray3<TRecord>(CommandQueue<array[,,] of TRecord>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>)
Записывает указанный участок массива в область памяти
mem_offset указывает отступ от начала области памяти, в байтах
a_ind(-ы) указывают индекс первого задействованного элемента массива
el_count указывает кол-во задействованных элементов массива
==================================================
ВНИМАНИЕ! У многомерных массивов элементы распологаются так же как у одномерных, разделение на строки виртуально
Это значит что, к примеру, чтение 4 элементов 2-х мерного массива начиная с индекса [0,1] прочитает элементы [0,1], [0,2], [1,0], [1,1]
Для чтения частей из нескольких строк массива - делайте несколько операций чтения, по 1 на строку

# CLMemorySegment.WriteArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteArraySegment<TRecord>(ArraySegment<TRecord>, CommandQueue<integer>)
Записывает указанный участок массива в область памяти
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemorySegment.WriteData(CommandQueue<IntPtr>)
# CLMemorySegment.WriteData(pointer)
# CLMemorySegmentCCQ.ThenWriteData(CommandQueue<IntPtr>)
# CLMemorySegmentCCQ.ThenWriteData(pointer)
Заполняет всю область памяти данными, находящимися по указанному адресу в RAM

# CLMemorySegment.WriteData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegment.WriteData(pointer, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteData(CommandQueue<IntPtr>, CommandQueue<integer>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteData(pointer, CommandQueue<integer>, CommandQueue<integer>)
Заполняет часть области памяти данными, находящимися по указанному адресу в RAM
mem_offset указывает отступ от начала области памяти, в байтах
len указывает кол-во задействованных в операции байт

# CLMemorySegment.WriteData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteData(CommandQueue<NativeMemoryArea>, CommandQueue<integer>)
Записывает данные указанной области памяти RAM в данную область памяти OpenCL
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemorySegment.WriteNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemorySegment.WriteNativeValue<TRecord>(NativeValue<TRecord>)
# CLMemorySegment.WriteValue<TRecord>(CommandQueue<TRecord>)
# CLMemorySegment.WriteValue<TRecord>(TRecord)
# CLMemorySegmentCCQ.ThenWriteNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>)
# CLMemorySegmentCCQ.ThenWriteNativeValue<TRecord>(NativeValue<TRecord>)
# CLMemorySegmentCCQ.ThenWriteValue<TRecord>(CommandQueue<TRecord>)
# CLMemorySegmentCCQ.ThenWriteValue<TRecord>(TRecord)
Записывает указанное значение размерного типа в начало области памяти

# CLMemorySegment.WriteNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>)
# CLMemorySegment.WriteNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>)
# CLMemorySegment.WriteValue<TRecord>(CommandQueue<TRecord>, CommandQueue<integer>)
# CLMemorySegment.WriteValue<TRecord>(TRecord, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteNativeValue<TRecord>(CommandQueue<NativeValue<TRecord>>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteNativeValue<TRecord>(NativeValue<TRecord>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteValue<TRecord>(CommandQueue<TRecord>, CommandQueue<integer>)
# CLMemorySegmentCCQ.ThenWriteValue<TRecord>(TRecord, CommandQueue<integer>)
Записывает указанное значение размерного типа в область памяти
mem_offset указывает отступ от начала области памяти, в байтах

# CLMemorySegmentCCQ
Представляет очередь-контейнер для команд GPU, применяемых к объекту типа CLMemorySegment

# CLMemorySubSegment
Представляет виртуальную область памяти, выделенную внутри CLMemorySegment

# CLMemorySubSegment.(CLMemorySegment, UInt32, UInt32)
# CLMemorySubSegment.(CLMemorySegment, UInt64, UInt64)
# CLMemorySubSegment.(CLMemorySegment, UIntPtr, UIntPtr)
Создаёт виртуальную область памяти, использующую указанную область из parent
origin указывает отступ в байтах от начала parent
size указывает размер новой области памяти

# CLMemorySubSegment.Parent
Возвращает родительскую область памяти

# CLTask<T>
# CLTaskBase
# CLTaskNil
Представляет задачу выполнения очереди, создаваемую методом Context.BeginInvoke

# CLTask<T>.OrgQueue
# CLTaskBase.OrgQueue
# CLTaskNil.OrgQueue
Возвращает очередь, которую выполняет данный CLTask

# CLTask<T>.WaitRes
Ожидает окончания выполнения очереди (если оно ещё не завершилось)
Кидает System.AggregateException, содержащие ошибки при выполнении очереди, если такие имеются
А затем возвращает результат выполнения

# CLTaskBase.OrgContext
Возвращает контекст, в котором выполняется данный CLTask

# CLTaskBase.Wait
Ожидает окончания выполнения очереди (если оно ещё не завершилось)
Кидает System.AggregateException, содержащие ошибки при выполнении очереди, если такие имеются

# CLValue<T>
Представляет запись, значение которой хранится на устройстве OpenCL (обычно GPU)

# CLValue<T>.
Память выделяется в контексте Context.Default
Выделяет память OpenCL, заполненную мусорными данными

# CLValue<T>.(Context)
Память выделяется в указанном контексте
Выделяет память OpenCL, заполненную мусорными данными

# CLValue<T>.(Context, T)
Память выделяется в указанном контексте
Выделяет память OpenCL и копирует в неё указанное значение

# CLValue<T>.(T)
Память выделяется в контексте Context.Default
Выделяет память OpenCL и копирует в неё указанное значение

# CLValue<T>.CopyFrom(CommandQueue<CLMemorySegment>)
# CLValueCCQ<T>.ThenCopyFrom(CommandQueue<CLMemorySegment>)
Копирует данные из mem в данное значение

# CLValue<T>.CopyFrom(CommandQueue<CLMemorySegment>, CommandQueue<integer>)
# CLValueCCQ<T>.ThenCopyFrom(CommandQueue<CLMemorySegment>, CommandQueue<integer>)
Копирует данные из mem в данное значение
mem_offset указывает отступ от начала области памяти, в байтах

# CLValue<T>.CopyFrom(CommandQueue<CLValue<&T>>)
# CLValueCCQ<T>.ThenCopyFrom(CommandQueue<CLValue<&T>>)
Копирует данные из val в данное значение

# CLValue<T>.CopyTo(CommandQueue<CLMemorySegment>)
# CLValueCCQ<T>.ThenCopyTo(CommandQueue<CLMemorySegment>)
Копирует данные из данного значения в mem

# CLValue<T>.CopyTo(CommandQueue<CLMemorySegment>, CommandQueue<integer>)
# CLValueCCQ<T>.ThenCopyTo(CommandQueue<CLMemorySegment>, CommandQueue<integer>)
Копирует данные из данного значения в mem
mem_offset указывает отступ от начала области памяти, в байтах

# CLValue<T>.CopyTo(CommandQueue<CLValue<&T>>)
# CLValueCCQ<T>.ThenCopyTo(CommandQueue<CLValue<&T>>)
Копирует данные из данного значения в val

# CLValue<T>.GetValue
# CLValueCCQ<T>.ThenGetValue
Читает данное значение

# CLValue<T>.ReadData(CommandQueue<IntPtr>)
# CLValue<T>.ReadData(pointer)
# CLValueCCQ<T>.ThenReadData(CommandQueue<IntPtr>)
# CLValueCCQ<T>.ThenReadData(pointer)
Читает данное значение в RAM по указанному адресу

# CLValue<T>.ReadNativeValue(CommandQueue<NativeValue<&T>>)
# CLValueCCQ<T>.ThenReadNativeValue(CommandQueue<NativeValue<&T>>)
Читает данное значение в указанное

# CLValue<T>.ValueSize
# NativeValue<T>.ValueSize
Возвращает размер значения, в байтах

# CLValue<T>.WriteData(CommandQueue<IntPtr>)
# CLValue<T>.WriteData(pointer)
# CLValueCCQ<T>.ThenWriteData(CommandQueue<IntPtr>)
# CLValueCCQ<T>.ThenWriteData(pointer)
Записывает данные из RAM по указанному адресу в данное значение

# CLValue<T>.WriteNativeValue(CommandQueue<NativeValue<&T>>)
# CLValue<T>.WriteValue(&T)
# CLValue<T>.WriteValue(CommandQueue<&T>)
# CLValueCCQ<T>.ThenWriteNativeValue(CommandQueue<NativeValue<&T>>)
# CLValueCCQ<T>.ThenWriteValue(&T)
# CLValueCCQ<T>.ThenWriteValue(CommandQueue<&T>)
Записывает указанное значение в данное

# CLValueCCQ<T>
Представляет очередь-контейнер для команд GPU, применяемых к объекту типа CLValue

# CombineAsyncQueue<T>(array of CommandQueue<T>)
# CombineAsyncQueue<T>(sequence of CommandQueue<T>)
# CombineAsyncQueue<T>(sequence of CommandQueueBase, CommandQueue<T>)
# CombineAsyncQueueBase(array of CommandQueueBase)
# CombineAsyncQueueBase(sequence of CommandQueueBase)
# CombineAsyncQueueNil(array of CommandQueueNil)
# CombineAsyncQueueNil(sequence of CommandQueueBase, CommandQueueNil)
# CombineAsyncQueueNil(sequence of CommandQueueNil)
Создаёт очередь, выполняющую указанные очереди одновременно
И возвращающую результат последней очереди

# CombineConvAsyncQueue<TInp, TRes>(Func<array of TInp, Context, TRes>, array of CommandQueue<TInp>)
# CombineConvAsyncQueue<TInp, TRes>(Func<array of TInp, Context, TRes>, sequence of CommandQueue<TInp>)
# CombineConvAsyncQueue<TInp, TRes>(Func<array of TInp, TRes>, array of CommandQueue<TInp>)
# CombineConvAsyncQueue<TInp, TRes>(Func<array of TInp, TRes>, sequence of CommandQueue<TInp>)
# CombineConvAsyncQueueN2<TInp1, TInp2, TRes>(Func<TInp1, TInp2, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>)
# CombineConvAsyncQueueN2<TInp1, TInp2, TRes>(Func<TInp1, TInp2, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>)
# CombineConvAsyncQueueN3<TInp1, TInp2, TInp3, TRes>(Func<TInp1, TInp2, TInp3, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>)
# CombineConvAsyncQueueN3<TInp1, TInp2, TInp3, TRes>(Func<TInp1, TInp2, TInp3, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>)
# CombineConvAsyncQueueN4<TInp1, TInp2, TInp3, TInp4, TRes>(Func<TInp1, TInp2, TInp3, TInp4, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>)
# CombineConvAsyncQueueN4<TInp1, TInp2, TInp3, TInp4, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>)
# CombineConvAsyncQueueN5<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>)
# CombineConvAsyncQueueN5<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>)
# CombineConvAsyncQueueN6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>)
# CombineConvAsyncQueueN6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>)
# CombineConvAsyncQueueN7<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>, CommandQueue<TInp7>)
# CombineConvAsyncQueueN7<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>, CommandQueue<TInp7>)
Создаёт очередь, выполняющую указанные очереди одновременно
Затем выполняющую указанную первым параметров функцию на CPU, передавая результаты всех очередей
И возвращающую результат этой функции
Переданный делегат выполняется в отдельном потоке выполнения (Thread)
Если делегат выполняется быстро и выделение нового потока излишне - используйте соответствующую функцию, начинающуюся на "CombineQuick..."

# CombineConvSyncQueue<TInp, TRes>(Func<array of TInp, Context, TRes>, array of CommandQueue<TInp>)
# CombineConvSyncQueue<TInp, TRes>(Func<array of TInp, Context, TRes>, sequence of CommandQueue<TInp>)
# CombineConvSyncQueue<TInp, TRes>(Func<array of TInp, TRes>, array of CommandQueue<TInp>)
# CombineConvSyncQueue<TInp, TRes>(Func<array of TInp, TRes>, sequence of CommandQueue<TInp>)
# CombineConvSyncQueueN2<TInp1, TInp2, TRes>(Func<TInp1, TInp2, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>)
# CombineConvSyncQueueN2<TInp1, TInp2, TRes>(Func<TInp1, TInp2, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>)
# CombineConvSyncQueueN3<TInp1, TInp2, TInp3, TRes>(Func<TInp1, TInp2, TInp3, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>)
# CombineConvSyncQueueN3<TInp1, TInp2, TInp3, TRes>(Func<TInp1, TInp2, TInp3, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>)
# CombineConvSyncQueueN4<TInp1, TInp2, TInp3, TInp4, TRes>(Func<TInp1, TInp2, TInp3, TInp4, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>)
# CombineConvSyncQueueN4<TInp1, TInp2, TInp3, TInp4, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>)
# CombineConvSyncQueueN5<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>)
# CombineConvSyncQueueN5<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>)
# CombineConvSyncQueueN6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>)
# CombineConvSyncQueueN6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>)
# CombineConvSyncQueueN7<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>, CommandQueue<TInp7>)
# CombineConvSyncQueueN7<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>, CommandQueue<TInp7>)
Создаёт очередь, выполняющую указанные очереди одну за другой
Затем выполняющую указанную первым параметров функцию на CPU, передавая результаты всех очередей
И возвращающую результат этой функции
Переданный делегат выполняется в отдельном потоке выполнения (Thread)
Если делегат выполняется быстро и выделение нового потока излишне - используйте соответствующую функцию, начинающуюся на "CombineQuick..."

# CombineQuickConvAsyncQueue<TInp, TRes>(Func<array of TInp, Context, TRes>, array of CommandQueue<TInp>)
# CombineQuickConvAsyncQueue<TInp, TRes>(Func<array of TInp, Context, TRes>, sequence of CommandQueue<TInp>)
# CombineQuickConvAsyncQueue<TInp, TRes>(Func<array of TInp, TRes>, array of CommandQueue<TInp>)
# CombineQuickConvAsyncQueue<TInp, TRes>(Func<array of TInp, TRes>, sequence of CommandQueue<TInp>)
# CombineQuickConvAsyncQueueN2<TInp1, TInp2, TRes>(Func<TInp1, TInp2, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>)
# CombineQuickConvAsyncQueueN2<TInp1, TInp2, TRes>(Func<TInp1, TInp2, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>)
# CombineQuickConvAsyncQueueN3<TInp1, TInp2, TInp3, TRes>(Func<TInp1, TInp2, TInp3, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>)
# CombineQuickConvAsyncQueueN3<TInp1, TInp2, TInp3, TRes>(Func<TInp1, TInp2, TInp3, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>)
# CombineQuickConvAsyncQueueN4<TInp1, TInp2, TInp3, TInp4, TRes>(Func<TInp1, TInp2, TInp3, TInp4, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>)
# CombineQuickConvAsyncQueueN4<TInp1, TInp2, TInp3, TInp4, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>)
# CombineQuickConvAsyncQueueN5<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>)
# CombineQuickConvAsyncQueueN5<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>)
# CombineQuickConvAsyncQueueN6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>)
# CombineQuickConvAsyncQueueN6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>)
# CombineQuickConvAsyncQueueN7<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>, CommandQueue<TInp7>)
# CombineQuickConvAsyncQueueN7<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>, CommandQueue<TInp7>)
Создаёт очередь, выполняющую указанные очереди одновременно
Затем выполняющую указанную первым параметров функцию на CPU, передавая результаты всех очередей
И возвращающую результат этой функции
Переданный делегат старается выполняется в одном из уже существующих потоков выполнения, но так чтобы не нарушить порядок выполнения дерева очередей
Из делегата категорически нельзя вызывать функции модуля OpenCL блокирующие выполнение, к примеру "cl.WaitForEvents", "clFinish" и блокирующий "cl.EnqueueReadBuffer"
Подробнее - читайте в документации библиотеки OpenCL про функцию "clSetEventCallback"
Так же в делегате не желательно использовать долго выполняющиеся алгоритмы, особенно ввод с клавиатуры
Если эти ограничения не подходят, используйте соответствующую функцию, без "Quick" в названии

# CombineQuickConvSyncQueue<TInp, TRes>(Func<array of TInp, Context, TRes>, array of CommandQueue<TInp>)
# CombineQuickConvSyncQueue<TInp, TRes>(Func<array of TInp, Context, TRes>, sequence of CommandQueue<TInp>)
# CombineQuickConvSyncQueue<TInp, TRes>(Func<array of TInp, TRes>, array of CommandQueue<TInp>)
# CombineQuickConvSyncQueue<TInp, TRes>(Func<array of TInp, TRes>, sequence of CommandQueue<TInp>)
# CombineQuickConvSyncQueueN2<TInp1, TInp2, TRes>(Func<TInp1, TInp2, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>)
# CombineQuickConvSyncQueueN2<TInp1, TInp2, TRes>(Func<TInp1, TInp2, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>)
# CombineQuickConvSyncQueueN3<TInp1, TInp2, TInp3, TRes>(Func<TInp1, TInp2, TInp3, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>)
# CombineQuickConvSyncQueueN3<TInp1, TInp2, TInp3, TRes>(Func<TInp1, TInp2, TInp3, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>)
# CombineQuickConvSyncQueueN4<TInp1, TInp2, TInp3, TInp4, TRes>(Func<TInp1, TInp2, TInp3, TInp4, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>)
# CombineQuickConvSyncQueueN4<TInp1, TInp2, TInp3, TInp4, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>)
# CombineQuickConvSyncQueueN5<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>)
# CombineQuickConvSyncQueueN5<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>)
# CombineQuickConvSyncQueueN6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>)
# CombineQuickConvSyncQueueN6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>)
# CombineQuickConvSyncQueueN7<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, Context, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>, CommandQueue<TInp7>)
# CombineQuickConvSyncQueueN7<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>(Func<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TInp7, TRes>, CommandQueue<TInp1>, CommandQueue<TInp2>, CommandQueue<TInp3>, CommandQueue<TInp4>, CommandQueue<TInp5>, CommandQueue<TInp6>, CommandQueue<TInp7>)
Создаёт очередь, выполняющую указанные очереди одну за другой
Затем выполняющую указанную первым параметров функцию на CPU, передавая результаты всех очередей
И возвращающую результат этой функции
Переданный делегат старается выполняется в одном из уже существующих потоков выполнения, но так чтобы не нарушить порядок выполнения дерева очередей
Из делегата категорически нельзя вызывать функции модуля OpenCL блокирующие выполнение, к примеру "cl.WaitForEvents", "clFinish" и блокирующий "cl.EnqueueReadBuffer"
Подробнее - читайте в документации библиотеки OpenCL про функцию "clSetEventCallback"
Так же в делегате не желательно использовать долго выполняющиеся алгоритмы, особенно ввод с клавиатуры
Если эти ограничения не подходят, используйте соответствующую функцию, без "Quick" в названии

# CombineSyncQueue<T>(array of CommandQueue<T>)
# CombineSyncQueue<T>(sequence of CommandQueue<T>)
# CombineSyncQueue<T>(sequence of CommandQueueBase, CommandQueue<T>)
# CombineSyncQueueBase(array of CommandQueueBase)
# CombineSyncQueueBase(sequence of CommandQueueBase)
# CombineSyncQueueNil(array of CommandQueueNil)
# CombineSyncQueueNil(sequence of CommandQueueBase, CommandQueueNil)
# CombineSyncQueueNil(sequence of CommandQueueNil)
Создаёт очередь, выполняющую указанные очереди одну за другой
И возвращающую результат последней очереди

# CommandQueue<T>
Представляет очередь команд, в основном выполняемых на GPU
Такая очередь всегда возвращает значение типа T

# CommandQueue<T>.DiscardResult
# CommandQueueBase.DiscardResult
Возвращает данную очередь но без результата

# CommandQueue<T>.HandleDefaultRes(Exception->boolean, T)
# CommandQueue<T>.HandleDefaultRes<TException>(TException->boolean, T)
Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
В конце выполнения созданная очередь возвращает то, что вернула данная, если исключений небыло и указанное значение если обработчик был успешно выполнен

# CommandQueue<T>.HandleReplaceRes(List<Exception> -> T)
Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
Для того чтоб пометить исключение обработанным - его надо удалить из полученного списка
Возвращаемое значение обработчика указывает на что надо заменить возвращаемое значение данной очереди, если обработчик был успешно выполнен

# CommandQueue<T>.Multiusable
# CommandQueueBase.Multiusable
# CommandQueueNil.Multiusable
Создаёт функцию, вызывая которую можно создать любое кол-во очередей-удлинителей для данной очереди
Подробнее в справке: "Очередь>>Создание очередей>>Множественное использование очереди"

# CommandQueue<T>.Print
# CommandQueueBase.Print
# CommandQueueNil.Print
# KernelArg.Print
# WaitMarker.Print
Вызывает Write(ToString) для данного объекта и возвращает его же

# CommandQueue<T>.Println
# CommandQueueBase.Println
# CommandQueueNil.Println
# KernelArg.Println
# WaitMarker.Println
Вызывает Writeln(ToString) для данного объекта и возвращает его же

# CommandQueue<T>.ThenConvert<TOtp>((T, Context)->TOtp)
Создаёт очередь, которая выполнит данную
А затем выполнит на CPU функцию f, используя результат данной очереди и контекст выполнения
Переданный делегат выполняется в отдельном потоке выполнения (Thread)
Если делегат выполняется быстро и выделение нового потока излишне - используйте соответствующую функцию, начинающуюся на ".ThenQuick..."

# CommandQueue<T>.ThenConvert<TOtp>(T->TOtp)
Создаёт очередь, которая выполнит данную
А затем выполнит на CPU функцию f, используя результат данной очереди
Переданный делегат выполняется в отдельном потоке выполнения (Thread)
Если делегат выполняется быстро и выделение нового потока излишне - используйте соответствующую функцию, начинающуюся на ".ThenQuick..."

# CommandQueue<T>.ThenFinallyMarkerSignal
# CommandQueueNil.ThenFinallyMarkerSignal
Создаёт очередь, сначала выполняющую данную, а затем вызывающую свой .SendSignal не зависимо от исключений при выполнении данной очереди
При передаче в Wait-очереди, полученная очередь превращается в маркер
В конце выполнения созданная очередь возвращает то, что вернула данная

# CommandQueue<T>.ThenFinallyWaitFor(WaitMarker)
Создаёт очередь, сначала выполняющую данную, а затем ожидающую сигнала от указанного маркера не зависимо от исключений при выполнении данной очереди
В конце выполнения созданная очередь возвращает то, что вернула данная

# CommandQueue<T>.ThenMarkerSignal
# CommandQueueNil.ThenMarkerSignal
Создаёт очередь, сначала выполняющую данную, а затем вызывающую свой .SendSignal 
При передаче в Wait-очереди, полученная очередь превращается в маркер
В конце выполнения созданная очередь возвращает то, что вернула данная

# CommandQueue<T>.ThenQuickConvert<TOtp>((T, Context)->TOtp)
Создаёт очередь, которая выполнит данную
А затем выполнит на CPU функцию f, используя результат данной очереди и контекст выполнения
Переданный делегат старается выполняется в одном из уже существующих потоков выполнения, но так чтобы не нарушить порядок выполнения дерева очередей
Из делегата категорически нельзя вызывать функции модуля OpenCL блокирующие выполнение, к примеру "cl.WaitForEvents", "clFinish" и блокирующий "cl.EnqueueReadBuffer"
Подробнее - читайте в документации библиотеки OpenCL про функцию "clSetEventCallback"
Так же в делегате не желательно использовать долго выполняющиеся алгоритмы, особенно ввод с клавиатуры
Если эти ограничения не подходят, используйте соответствующую функцию, без "Quick" в названии

# CommandQueue<T>.ThenQuickConvert<TOtp>(T->TOtp)
Создаёт очередь, которая выполнит данную
А затем выполнит на CPU функцию f, используя результат данной очереди
Переданный делегат старается выполняется в одном из уже существующих потоков выполнения, но так чтобы не нарушить порядок выполнения дерева очередей
Из делегата категорически нельзя вызывать функции модуля OpenCL блокирующие выполнение, к примеру "cl.WaitForEvents", "clFinish" и блокирующий "cl.EnqueueReadBuffer"
Подробнее - читайте в документации библиотеки OpenCL про функцию "clSetEventCallback"
Так же в делегате не желательно использовать долго выполняющиеся алгоритмы, особенно ввод с клавиатуры
Если эти ограничения не подходят, используйте соответствующую функцию, без "Quick" в названии

# CommandQueue<T>.ThenQuickUse((T, Context)->())
Создаёт очередь, которая выполнит данную и вернёт её результат
Но перед этим выполнит на CPU процедуру p, используя полученный результат и контекст выполнения
Переданный делегат старается выполняется в одном из уже существующих потоков выполнения, но так чтобы не нарушить порядок выполнения дерева очередей
Из делегата категорически нельзя вызывать функции модуля OpenCL блокирующие выполнение, к примеру "cl.WaitForEvents", "clFinish" и блокирующий "cl.EnqueueReadBuffer"
Подробнее - читайте в документации библиотеки OpenCL про функцию "clSetEventCallback"
Так же в делегате не желательно использовать долго выполняющиеся алгоритмы, особенно ввод с клавиатуры
Если эти ограничения не подходят, используйте соответствующую функцию, без "Quick" в названии

# CommandQueue<T>.ThenQuickUse(T->())
Создаёт очередь, которая выполнит данную и вернёт её результат
Но перед этим выполнит на CPU процедуру p, используя полученный результат
Переданный делегат старается выполняется в одном из уже существующих потоков выполнения, но так чтобы не нарушить порядок выполнения дерева очередей
Из делегата категорически нельзя вызывать функции модуля OpenCL блокирующие выполнение, к примеру "cl.WaitForEvents", "clFinish" и блокирующий "cl.EnqueueReadBuffer"
Подробнее - читайте в документации библиотеки OpenCL про функцию "clSetEventCallback"
Так же в делегате не желательно использовать долго выполняющиеся алгоритмы, особенно ввод с клавиатуры
Если эти ограничения не подходят, используйте соответствующую функцию, без "Quick" в названии

# CommandQueue<T>.ThenUse((T, Context)->())
Создаёт очередь, которая выполнит данную и вернёт её результат
Но перед этим выполнит на CPU процедуру p, используя полученный результат и контекст выполнения
Переданный делегат выполняется в отдельном потоке выполнения (Thread)
Если делегат выполняется быстро и выделение нового потока излишне - используйте соответствующую функцию, начинающуюся на ".ThenQuick..."

# CommandQueue<T>.ThenUse(T->())
Создаёт очередь, которая выполнит данную и вернёт её результат
Но перед этим выполнит на CPU процедуру p, используя полученный результат
Переданный делегат выполняется в отдельном потоке выполнения (Thread)
Если делегат выполняется быстро и выделение нового потока излишне - используйте соответствующую функцию, начинающуюся на ".ThenQuick..."

# CommandQueue<T>.ThenWaitFor(WaitMarker)
Создаёт очередь, сначала выполняющую данную, а затем ожидающую сигнала от указанного маркера 
В конце выполнения созданная очередь возвращает то, что вернула данная

# CommandQueueBase
Представляет очередь команд, в основном выполняемых на GPU

# CommandQueueBase.Cast<T>
Если данная очередь проходит по условию "... is CommandQueue<T>" - возвращает себя же
Иначе возвращает очередь-обёртку, выполняющую "res := T(res)", где res - результат данной очереди

# CommandQueueBase.ConvertTyped<TRes>(ITypedCQConverter<TRes>)
# CommandQueueBase.UseTyped(ITypedCQUser)
Проверяет, какой тип результата у данной очереди
Передаёт результат указанному объекту

# CommandQueueBase.HandleWithoutRes(Exception->boolean)
# CommandQueueBase.HandleWithoutRes<TException>(TException->boolean)
Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения
Созданная очередь возвращает nil не зависимо от исключений при выполнении данной очереди

# CommandQueueBase.ToString
# KernelArg.ToString
# WaitMarker.ToString
Возвращает строковое представление данного объекта
Используйте это значение только для отладки, потому что данный метод не оптимизирован

# CommandQueueNil
Представляет очередь команд, в основном выполняемых на GPU
Такая очередь всегда возвращает nil

# CommandQueueNil.Cast<T>
Создаёт константную очередь, выполняющую данную и возвращающую T(nil)
Для этого T должен быть ссылочным

# CommandQueueNil.DiscardResult
Возвращает данную очередь

# ConstQueue<T>
Представляет константную очередь
Константные очереди ничего не выполняют и возвращают заданное при создании значение

# ConstQueue<T>.(T)
Создаёт новую константную очередь, возвращающую указанное значения

# ConstQueue<T>.Value
Значение, которого возвращает данная константная очередь

# Context
Представляет контекст для хранения данных и выполнения команд на GPU

# Context.(array of Device)
Создаёт контекст с указанными AllDevices
В качестве MainDevice берётся первое устройство из массива

# Context.(IList<Device>, Device)
Создаёт контекст с указанными AllDevices и MainDevice

# Context.AllDevices
Возвращает список устройств, используемых данным контекстом

# Context.BeginInvoke(CommandQueueBase, array of ParameterQueueSetter)
# Context.BeginInvoke(CommandQueueNil, array of ParameterQueueSetter)
# Context.BeginInvoke<T>(CommandQueue<T>, array of ParameterQueueSetter)
Запускает данную очередь и все её подочереди
Как только всё запущено: возвращает CLTask, через который можно следить за процессом выполнения

# Context.Default
Возвращает или задаёт главный контекст, используемый там, где контекст не указывается явно (как неявные очереди)
При первом обращении к данному свойству OpenCLABC пытается создать новый контекст
При создании главного контекста приоритет отдаётся полноценным GPU, но если таких нет - берётся любое устройство, поддерживающее OpenCL

Если устройств поддерживающих OpenCL нет, то Context.Default изначально будет nil
Но это свидетельствует скорее об отсутствии драйверов, чем отстутсвии устройств

# Context.GetContextDevices(cl_context)
Получает неуправляемые устройства указанного неуправляемого контекста

# Context.MainDevice
Возвращает главное устройство контекста, на котором выделяется память

# Context.MakeNewDefaultContext
Создаёт новый контекст, соответствующий изначальному значению Context.Default

# Context.MakeSibling(Device)
Создаёт совместимый контекст, равный данному с одним отличием - MainDevice заменён на dvc

# Context.SyncInvoke(CommandQueueBase, array of ParameterQueueSetter)
# Context.SyncInvoke(CommandQueueNil, array of ParameterQueueSetter)
Запускает данную очередь и все её подочереди
Затем ожидает окончания выполнения

# Context.SyncInvoke<T>(CommandQueue<T>, array of ParameterQueueSetter)
Запускает данную очередь и все её подочереди
Затем ожидает окончания выполнения и возвращает полученный результат

# CQ<T>(T)
Создаёт константную очередь с указанным результатом

# DetachedMarkerSignal<T>
Представляет оторванный сигнал маркера, являющийся обёрткой очереди с возвращаемым значением
Данный тип не является маркером, но преобразуется в него при передаче в Wait-очереди

# DetachedMarkerSignal<T>.(CommandQueue<T>, boolean)
# DetachedMarkerSignalNil.(CommandQueueNil, boolean)
Создаёт новый оторванный сигнал маркера
При выполнении сначала будет выполнена очередь q, а затем метод .SendSignal
signal_in_finally указывает, будут ли проигнорированы ошибки выполнения q при автоматическом вызове .SendSignal

# DetachedMarkerSignal<T>.SendSignal
# DetachedMarkerSignalNil.SendSignal
# WaitMarker.SendSignal
Посылает сигнал выполненности всем ожидающим Wait очередям

# DetachedMarkerSignal<T>.SignalInFinally
# DetachedMarkerSignalNil.SignalInFinally
Указывает, будут ли проигнорированы ошибки выполнения исходной очереди при автоматическом вызове .SendSignal

# DetachedMarkerSignalNil
Представляет оторванный сигнал маркера, являющийся обёрткой очереди без возвращаемого значения
Данный тип не является маркером, но преобразуется в него при передаче в Wait-очереди

# Device
Представляет устройство, поддерживающее OpenCL

# Device.BasePlatform
Возвращает платформу данного устройства

# Device.CanSplitByAffinityDomain
Указывает, поддерживает ли это устройство вызов метода .SplitByAffinityDomain

# Device.CanSplitByCounts
Указывает, поддерживает ли это устройство вызов метода .SplitByCounts

# Device.CanSplitEqually
Указывает, поддерживает ли это устройство вызов метода .SplitEqually

# Device.FromNative(cl_device_id)
# Platform.(cl_platform_id)
Создаёт обёртку для указанного неуправляемого объекта

# Device.GetAllFor(Platform)
Собирает массив устройств GPU для указанной платформы
Возвращает nil, если ни одно устройство не найдено

# Device.GetAllFor(Platform, DeviceType)
Собирает массив устройств указанного типа для указанной платформы
Возвращает nil, если ни одно устройство не найдено

# Device.SplitByAffinityDomain(DeviceAffinityDomain)
Разделяет данное устройство на отдельные группы ядер так,
чтобы у каждой группы ядер был общий кэш указанного уровня

# Device.SplitByCounts(array of integer)
Создаёт массив виртуальных устройств, каждое из которых содержит указанное кол-во ядер

# Device.SplitEqually(integer)
Создаёт максимальное возможное количество виртуальных устройств,
каждое из которых содержит CUCount ядер данного устройства

# DeviceAffinityDomain
Уровень кэша, используемый в Device.SplitByAffinityDomain

# DeviceType
Тип устройства, поддерживающего OpenCL

# Err:Blittable:Blame
Значения типа {TypeToTypeName(t)} нельзя {source_name}, потому что он содержит тип {TypeToTypeName(blame)}

# Err:Blittable:Main
Значения типа {TypeToTypeName(t)} нельзя {source_name}

# Err:Blittable:Source:CLArray
использовать как элементы CLArray<>

# Err:Blittable:Source:CLMemorySegment:FillArray1
# Err:Blittable:Source:CLMemorySegment:FillArray1AutoSize
# Err:Blittable:Source:CLMemorySegment:FillArray2
# Err:Blittable:Source:CLMemorySegment:FillArray2AutoSize
# Err:Blittable:Source:CLMemorySegment:FillArray3
# Err:Blittable:Source:CLMemorySegment:FillArray3AutoSize
# Err:Blittable:Source:CLMemorySegment:FillArraySegment
# Err:Blittable:Source:CLMemorySegment:FillArraySegmentAutoSize
# Err:Blittable:Source:CLMemorySegment:FillNativeArray
# Err:Blittable:Source:CLMemorySegment:FillNativeArrayAutoSize
# Err:Blittable:Source:CLMemorySegment:FillNativeValue
# Err:Blittable:Source:CLMemorySegment:FillNativeValueAutoSize
# Err:Blittable:Source:CLMemorySegment:FillValue
# Err:Blittable:Source:CLMemorySegment:FillValueAutoSize
# Err:Blittable:Source:CLMemorySegment:FillValueAutoSizeQ
# Err:Blittable:Source:CLMemorySegment:FillValueQ
# Err:Blittable:Source:CLMemorySegment:WriteArray1
# Err:Blittable:Source:CLMemorySegment:WriteArray1AutoSize
# Err:Blittable:Source:CLMemorySegment:WriteArray2
# Err:Blittable:Source:CLMemorySegment:WriteArray2AutoSize
# Err:Blittable:Source:CLMemorySegment:WriteArray3
# Err:Blittable:Source:CLMemorySegment:WriteArray3AutoSize
# Err:Blittable:Source:CLMemorySegment:WriteNativeArray
# Err:Blittable:Source:CLMemorySegment:WriteNativeArrayAutoSize
# Err:Blittable:Source:CLMemorySegment:WriteNativeValue
# Err:Blittable:Source:CLMemorySegment:WriteValue
# Err:Blittable:Source:CLMemorySegment:WriteValueQ
записывать в область памяти OpenCL

# Err:Blittable:Source:CLMemorySegment:GetArray
# Err:Blittable:Source:CLMemorySegment:GetArray2
# Err:Blittable:Source:CLMemorySegment:GetArray3
# Err:Blittable:Source:CLMemorySegment:GetArrayAutoSize
# Err:Blittable:Source:CLMemorySegment:GetValue
# Err:Blittable:Source:CLMemorySegment:ReadArray1
# Err:Blittable:Source:CLMemorySegment:ReadArray1AutoSize
# Err:Blittable:Source:CLMemorySegment:ReadArray2
# Err:Blittable:Source:CLMemorySegment:ReadArray2AutoSize
# Err:Blittable:Source:CLMemorySegment:ReadArray3
# Err:Blittable:Source:CLMemorySegment:ReadArray3AutoSize
# Err:Blittable:Source:CLMemorySegment:ReadNativeArray
# Err:Blittable:Source:CLMemorySegment:ReadNativeArrayAutoSize
# Err:Blittable:Source:CLMemorySegment:ReadNativeValue
читать из области памяти OpenCL

# Err:Blittable:Source:CLValue
использовать как тип значения CLValue<>

# Err:Blittable:Source:KernelArg
передавать в качестве параметров kernel''а

# Err:Blittable:Source:NativeArray
использовать как элементы NativeArray<>

# Err:Blittable:Source:NativeValue
использовать как тип значения NativeValue<>

# Err:Blittable:Source:QueueResPtr
использовать в некоторой внутренней ситуации (напишите об этом в issue)

# Err:Cast:nil->T
.Cast не может преобразовывать nil в {TypeToTypeName(typeof(T))}

# Err:Cast:TInp->TRes
.Cast не может преобразовывать {TypeToTypeName(typeof(TInp))} в {TypeToTypeName(typeof(TRes))}

# Err:CLMemorySegment:WrongNtvType
Неправильный тип неуправляемого объекта памяти. Ожидалось [MEM_OBJECT_BUFFER], а не [{t}]

# Err:CLTask:
При выполнении очереди было вызвано {err_lst.Count} исключений. Используйте try чтоб получить больше информации

# Err:Context:WrongMainDvc
main_dvc должен быть в списке устройств контекста

# Err:Device:SplitCUCount
Количество ядер должно быть положительным числом, а не {CUCount}

# Err:Device:SplitNotSupported
Данный режим .Split не поддерживается выбранным устройством

# Err:FlattenQueueArray:InpEmpty
Функции CombineSyncQueue/CombineAsyncQueue не могут принимать 0 очередей

# Err:NativeArray:SliceCopy:WriteSize
Массив присваиваемый свойству NativeArray<>.SliceCopy должен иметь размер ({value.Length}), равный размеру среза ({expected_len})

# Err:NoParamCtor
Был вызван не_применимый конструктор без параметров... Обратитесь к разработчику OpenCLABC

# Err:Parameter:NotFound
Параметр {par.Name} не используется

# Err:Parameter:SetAgain
Значение параметра {name} установлено больше одного раза

# Err:Parameter:UnSet
Значение параметра {name} небыло установлено

# Err:ProgramCode:BuildFail
Ошибка компиляции OpenCL программы:

# Err:WaitCombine:InpEmpty
Количество комбинируемых маркеров должно быть положительным

# Err:WaitMarkerCombination.ConvertToQBase
Преобразовывать комбинацию маркеров в очередь нельзя. Возможно вы забыли написать WaitFor?

# HFQ<T>(()->T)
# HFQ<T>(Context->T)
Создаёт очередь, выполняющую указанную функцию на CPU
И возвращающую результат этой функци
Переданный делегат выполняется в отдельном потоке выполнения (Thread)
Если делегат выполняется быстро и выделение нового потока излишне - используйте соответствующую функцию, с дополнительным "Q" (что значит Quick) в конце

# HFQQ<T>(()->T)
# HFQQ<T>(Context->T)
Создаёт очередь, выполняющую указанную функцию на CPU
И возвращающую результат этой функци
Переданный делегат старается выполняется в одном из уже существующих потоков выполнения, но так чтобы не нарушить порядок выполнения дерева очередей
Из делегата категорически нельзя вызывать функции модуля OpenCL блокирующие выполнение, к примеру "cl.WaitForEvents", "clFinish" и блокирующий "cl.EnqueueReadBuffer"
Подробнее - читайте в документации библиотеки OpenCL про функцию "clSetEventCallback"
Так же в делегате не желательно использовать долго выполняющиеся алгоритмы, особенно ввод с клавиатуры
Если эти ограничения не подходят, используйте соответствующую функцию, без "Quick" в названии

# HPQ(()->())
# HPQ(Context->())
Создаёт очередь, выполняющую указанную процедуру на CPU
И возвращающую nil
Переданный делегат выполняется в отдельном потоке выполнения (Thread)
Если делегат выполняется быстро и выделение нового потока излишне - используйте соответствующую функцию, с дополнительным "Q" (что значит Quick) в конце

# HPQQ(()->())
# HPQQ(Context->())
Создаёт очередь, выполняющую указанную процедуру на CPU
И возвращающую nil
Переданный делегат старается выполняется в одном из уже существующих потоков выполнения, но так чтобы не нарушить порядок выполнения дерева очередей
Из делегата категорически нельзя вызывать функции модуля OpenCL блокирующие выполнение, к примеру "cl.WaitForEvents", "clFinish" и блокирующий "cl.EnqueueReadBuffer"
Подробнее - читайте в документации библиотеки OpenCL про функцию "clSetEventCallback"
Так же в делегате не желательно использовать долго выполняющиеся алгоритмы, особенно ввод с клавиатуры
Если эти ограничения не подходят, используйте соответствующую функцию, без "Quick" в названии

# ITypedCQConverter<TRes>
# ITypedCQUser
Представляет интерфейс типа, содержащего отдельные алгоритмы обработки, очереди без- и с возвращаемым значением

# ITypedCQConverter<TRes>.Convert<T>(CommandQueue<T>)
# ITypedCQUser.Use<T>(CommandQueue<T>)
Вызывается если у очереди есть возвращаемое значение

# ITypedCQConverter<TRes>.ConvertNil(CommandQueueNil)
# ITypedCQUser.UseNil(CommandQueueNil)
Вызывается если у очереди нет возвращаемого значения

# Kernel
Представляет подпрограмму, выполняемую на GPU

# Kernel.CodeContainer
Возвращает контейнер кода, содержащий данную подпрограмму

# Kernel.Exec(CommandQueue<array of UIntPtr>, CommandQueue<array of UIntPtr>, CommandQueue<array of UIntPtr>, array of KernelArg)
# KernelCCQ.ThenExec(CommandQueue<array of UIntPtr>, CommandQueue<array of UIntPtr>, CommandQueue<array of UIntPtr>, array of KernelArg)
Выполняет kernel с расширенным набором параметров
Данная перегрузка используется в первую очередь для тонких оптимизаций
Если она вам понадобилась по другой причина - пожалуйста, напишите в issue

# Kernel.Exec1(CommandQueue<integer>, array of KernelArg)
# Kernel.Exec2(CommandQueue<integer>, CommandQueue<integer>, array of KernelArg)
# Kernel.Exec3(CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, array of KernelArg)
# KernelCCQ.ThenExec1(CommandQueue<integer>, array of KernelArg)
# KernelCCQ.ThenExec2(CommandQueue<integer>, CommandQueue<integer>, array of KernelArg)
# KernelCCQ.ThenExec3(CommandQueue<integer>, CommandQueue<integer>, CommandQueue<integer>, array of KernelArg)
Выполняет kernel с указанным кол-вом ядер и передаёт в него указанные аргументы

# Kernel.MakeNewNtv
Создаёт независимый клон неуправляемого объекта
Внимание: Клон НЕ будет удалён автоматически при сборке мусора. Для него надо вручную вызывать cl.ReleaseKernel

# Kernel.Name
Возвращает имя данной подпрограммы

# Kernel.UseExclusiveNative(cl_kernel->())
# Kernel.UseExclusiveNative<T>(cl_kernel->T)
Гарантирует что неуправляемый объект будет использоваться только в 1 потоке одновременно
Если неуправляемый объект данного kernel-а используется другим потоком - в процедурную переменную передаётся его независимый клон
Внимание: Клон неуправляемого объекта будет удалён сразу после выхода из вашей процедурной переменной, если не вызвать cl.RetainKernel

# KernelArg
Представляет аргумент, передаваемый в вызов kernel-а

# KernelArg.FromArray<TRecord>(array of TRecord)
# KernelArg.FromArray2<TRecord>(array[,] of TRecord)
# KernelArg.FromArray2CQ<TRecord>(CommandQueue<array[,] of TRecord>)
# KernelArg.FromArray3<TRecord>(array[,,] of TRecord)
# KernelArg.FromArray3CQ<TRecord>(CommandQueue<array[,,] of TRecord>)
# KernelArg.FromArrayCQ<TRecord>(CommandQueue<array of TRecord>)
# KernelArg.FromNativeArray<TRecord>(NativeArray<TRecord>)
# KernelArg.FromNativeArrayCQ<TRecord>(CommandQueue<NativeArray<TRecord>>)
Создаёт аргумент kernel'а, при выполнении копирующий в kernel массив

# KernelArg.FromArraySegment<TRecord>(ArraySegment<TRecord>)
# KernelArg.FromArraySegmentCQ<TRecord>(CommandQueue<ArraySegment<TRecord>>)
Создаёт аргумент kernel'а, при выполнении копирующий в kernel часть массива

# KernelArg.FromCLArray<T>(CLArray<T>)
# KernelArg.FromCLArrayCQ<T>(CommandQueue<CLArray<T>>)
Создаёт аргумент kernel'а, ссылающийся на массив

# KernelArg.FromCLMemorySegment(CLMemorySegment)
# KernelArg.FromCLMemorySegmentCQ(CommandQueue<CLMemorySegment>)
Создаёт аргумент kernel'а, ссылающийся на область памяти OpenCL

# KernelArg.FromCLValue<T>(CLValue<T>)
# KernelArg.FromCLValueCQ<T>(CommandQueue<CLValue<T>>)
Создаёт аргумент kernel'а, ссылающийся на небольшое значение размерного типа

# KernelArg.FromData(NativeMemoryArea)
# KernelArg.FromDataCQ(CommandQueue<NativeMemoryArea>)
Создаёт аргумент kernel'а, при выполнении копирующий в kernel область неуправляемой памяти

# KernelArg.FromNativeValue<TRecord>(NativeValue<TRecord>)
# KernelArg.FromNativeValueCQ<TRecord>(CommandQueue<NativeValue<TRecord>>)
# KernelArg.FromValue<TRecord>(TRecord)
# KernelArg.FromValueCQ<TRecord>(CommandQueue<TRecord>)
Создаёт аргумент kernel'а, при выполнении копирующий в kernel небольшое значение размерного типа

# KernelCCQ
Представляет очередь-контейнер для команд GPU, применяемых к объекту типа Kernel

# NativeArray<T>
Представляет массив, содержимое которого хранится в неуправляемой области памяти

# NativeArray<T>.(array of T)
Выделяет неуправляемую память и сохраняет в неё копию указанных данных

# NativeArray<T>.(integer)
Выделяет и обнуляет область неуправляемой памяти достаточного размера для хранения указанного кол-ва элементов

# NativeArray<T>.Contains(T)
Определяет содержится ли элемент в массиве

# NativeArray<T>.CopyTo(array of T, integer)
Копирует всё содержимое данного массива в указанный
Данное свойство проверяет правильность переданных индексов

# NativeArray<T>.Dispose
Освобождает неуправляемую память из по данного массива
Этот метод потоко-безопасен
Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён

# NativeArray<T>.GetEnumerator
Возвращает перечислитель данного массива

# NativeArray<T>.IndexOf(T)
Возвращает индекс по которому находится указанный элемент
Если элемент таковой найден - возвращает nil

# NativeArray<T>.Item[integer]
Возвращает или задаёт элемент массива по указанному индексу
Данное свойство проверяет правильность переданных индексов

# NativeArray<T>.ItemCount
Возвращает кол-во элементов данного массива

# NativeArray<T>.ItemPtr[integer]
Возвращает указатель на элемент с указанным индексом
Данное свойство проверяет правильность переданных индексов

# NativeArray<T>.ItemPtrUnchecked[integer]
Возвращает указатель на элемент с указанным индексом
Данное свойство не проверяет правильность переданных индексов

# NativeArray<T>.MemoryArea
Возвращает описание области памяти, занимаемой содержимым данного массива

# NativeArray<T>.SliceArea[IntRange]
Возвращает описание области памяти для указанного среза элементов
Данное свойство проверяет правильность переданных индексов

# NativeArray<T>.SliceAreaUnchecked[IntRange]
Возвращает описание области памяти для указанного среза элементов
Данное свойство не проверяет правильность переданных индексов

# NativeArray<T>.SliceCopy[IntRange]
Копирует данные между управляемым массивом и срезом данного массива
Данное свойство проверяет правильность переданных индексов

# NativeArrayEnumerator<T>
Представляет перечислитель для типа NativeArray<>

# NativeArrayEnumerator<T>.(NativeArray<T>)
Создаёт перечислитель для указанного массива

# NativeArrayEnumerator<T>.Current
Возвращает элемент массива на который указывает данный перечислитель
Данное свойство проверяет правильность переданных индексов

# NativeArrayEnumerator<T>.Dispose
Обнуляет ссылку перечислителя на массив

# NativeArrayEnumerator<T>.MoveNext
Переходит к следующему элементу массива
Возвращаемое значение указывает можно ли читать данные из свойства Current

# NativeArrayEnumerator<T>.Reset
Сбрасывает перечислитель в его исходное положение

# NativeMemoryArea
Описывает неуправляемою область памяти

# NativeMemoryArea.(IntPtr, UIntPtr)
Создаёт описание указанной области памяти

# NativeMemoryArea.CopyFrom(NativeMemoryArea)
Копирует данные из указанной области памяти в данную
Области памяти не должны пересекаться. Иначе поведение неопределено
Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyMinSize

# NativeMemoryArea.CopyFrom<T>(array of T)
# NativeMemoryArea.CopyFrom<T>(T)
Копирует данные из указанной области памяти в данную
Области памяти не должны пересекаться. Иначе поведение неопределено
Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер

# NativeMemoryArea.CopyMinSize(NativeMemoryArea, NativeMemoryArea)
Копирует данные между указанными областями памяти
Области памяти не должны пересекаться. Иначе поведение неопределено
Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
Количество копируемых байт равняется минимальному размеру указанных областей памяти

# NativeMemoryArea.CopyOverlappedFrom(NativeMemoryArea)
Копирует данные из указанной области памяти в данную
Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyOverlappedMinSize

# NativeMemoryArea.CopyOverlappedFrom<T>(array of T)
# NativeMemoryArea.CopyOverlappedFrom<T>(T)
Копирует данные из указанной области памяти в данную
Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер

# NativeMemoryArea.CopyOverlappedMinSize(NativeMemoryArea, NativeMemoryArea)
Копирует данные между указанными областями памяти
Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
Количество копируемых байт равняется минимальному размеру указанных областей памяти

# NativeMemoryArea.CopyOverlappedTo(NativeMemoryArea)
Копирует данные из данной области памяти в указанную
Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyOverlappedMinSize

# NativeMemoryArea.CopyOverlappedTo<T>(array of T)
# NativeMemoryArea.CopyOverlappedTo<T>(T)
Копирует данные из данной области памяти в указанную
Области памяти могут пересекаться, но взамен данный метод немного медленнее соответствующего метода без Overlapped в названии
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер

# NativeMemoryArea.CopyTo(NativeMemoryArea)
Копирует данные из данной области памяти в указанную
Области памяти не должны пересекаться. Иначе поведение неопределено
Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер
Если надо скопировать минимум размеров данной и указанной области памяти используйте статический метод NativeMemoryArea.CopyMinSize

# NativeMemoryArea.CopyTo<T>(array of T)
# NativeMemoryArea.CopyTo<T>(T)
Копирует данные из данной области памяти в указанную
Области памяти не должны пересекаться. Иначе поведение неопределено
Если пересечение возможно, используйте соответствующий .CopyOverlapped* метод
Кол-во копируемых байт берётся из данной области памяти, даже если указанная область памяти имеет меньший размер

# NativeMemoryArea.Fill(byte)
Заполняет всю область памяти указанными байтами

# NativeMemoryArea.FillZero
Заполняет всю область памяти нулевыми байтами

# NativeValue<T>
Представляет запись, значение которой хранится в неуправляемой области памяти

# NativeValue<T>.
Выделяет и обнуляет область неуправляемой памяти

# NativeValue<T>.(T)
Выделяет область неуправляемой памяти и сохраняет в него указанное значение

# NativeValue<T>.Dispose
Освобождает значение, сохранённое неуправляемой памяти
Ничего не делает, если значение уже освобождено
Данный метод вызывается автоматически во время сборки мусора, если объект ещё не удалён

# NativeValue<T>.MemoryArea
Возвращает описание области памяти, занимаемой данным значением

# NativeValue<T>.Pointer
Возвращает указатель на значение, сохранённое неуправляемой памяти

# NativeValue<T>.Value
Возвращает или задаёт значение, сохранённое неуправляемой памяти

# OpenCLABCInternalException
Исключение, кидаемое при неожиданном поведении внутренностей OpenCLABC
Если это исключение было кинуто - пишите в issue

# OpenCLException
Класс исключений из OpenCL

# ParameterQueue<T>
Представляет очередь-параметр
Очереди-параметры ничего не выполняют, но возвращает установленное при запуске очереди значение

# ParameterQueue<T>.(string)
Создаёт новую очередь-параметр
name указывает имя параметра

# ParameterQueue<T>.(string, T)
Создаёт новую очередь-параметр
name указывает имя параметра
Указанное значение будет использоваться если при запуске очереди значение параметра небыло установлено

# ParameterQueue<T>.Default
Значение, которое будет использоваться если при запуске очереди значение параметра небыло установлено

# ParameterQueue<T>.DefaultDefined
Указывает, установлено ли значение, которое будет использоваться если при запуске очереди значение параметра небыло установлено

# ParameterQueue<T>.Name
Имя параметра

# ParameterQueue<T>.NewSetter(T)
Создаёт установщик данного параметра
Если передать этот установщик в метод запуска очереди,
при выполнении параметр будет иметь указанное значение

# ParameterQueueSetter
Представляет установщик очереди-параметра ParameterQueue<T>, созданный методом .NewSetter
Если передать этот установщик в метод запуска очереди,
при выполнении параметр будет иметь указанное значение

# Platform
Представляет платформу OpenCL, объединяющую одно или несколько устройств

# Platform.All
Возвращает список всех доступных платформ OpenCL
Данный список создаётся 1 раз, при первом обращении

# ProgramCode
Представляет контейнер с откомпилированным кодом для GPU, содержащим подпрограммы-kernel'ы

# ProgramCode.(array of string)
Компилирует указанные тексты программ в контексте Context.Default
Внимание! Именно тексты, Не имена файлов

# ProgramCode.(Context, array of string)
Компилирует указанные тексты программ в указанном контексте
Внимание! Именно тексты, Не имена файлов

# ProgramCode.BaseContext
Возвращает контекст, на котором компилировали данный код для GPU

# ProgramCode.Deserialize(Context, array of array of byte)
Загружает прекомпилированную программу из набора байт

# ProgramCode.DeserializeFrom(Context, System.IO.BinaryReader)
# ProgramCode.DeserializeFrom(Context, System.IO.Stream)
Загружает прекомпилированную программу из потока

# ProgramCode.GetAllKernels
Создаёт массив из всех kernel-ов данного кода

# ProgramCode.KernelByName[string]
Находит в коде kernel с указанным именем
Регистр имени важен!

# ProgramCode.Serialize
Сохраняет прекомпилированную программу как набор байт

# ProgramCode.SerializeTo(System.IO.BinaryWriter)
# ProgramCode.SerializeTo(System.IO.Stream)
Сохраняет прекомпилированную программу в поток

# SubDevice
Представляет виртуальное устройство, использующее часть ядер другого устройства
Объекты данного типа обычно создаются методами "Device.Split*"

# SubDevice.Parent
Возвращает родительское устройство, часть ядер которого использует данное устройство

# WaitAll(array of WaitMarker)
# WaitAll(sequence of WaitMarker)
Создаёт маркер-комбинацию, который активируется когда активированы каждых из указанных маркеров

# WaitAny(array of WaitMarker)
# WaitAny(sequence of WaitMarker)
Создаёт маркер-комбинацию, который активируется когда активированы любого из указанных маркеров

# WaitFor(WaitMarker)
Создаёт очередь, ожидающую сигнала выполненности от заданного маркера

# WaitMarker
Представляет маркер для Wait очередей
Данный тип не является очередью
Но при выполнении преобразуется в очередь, выполняющую .SendSignal исходного маркера

# WaitMarker.Create
Создаёт новый простой маркер

