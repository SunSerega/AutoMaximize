


# CommandQueue[%Base,<T>%]
Представляет очередь, состоящую в основном из команд, выполняемых на GPU



# CommandQueueBase.Cast<T>
Если данная очередь проходит по условию "... is CommandQueue<T>" - возвращает себя же
Иначе возвращает очередь-обёртку, выполняющую "res := T(res)", где res - результат данной очереди



# CommandQueue<T>.ThenConvert<TOtp>(T->TOtp)
# CQ:ThenConvertDef
Создаёт очередь, которая выполнит данную
А затем выполнит на CPU функцию f, используя результат данной очереди

# CommandQueue<T>.ThenConvert<TOtp>((T, Context)->TOtp)
%CQ:ThenConvertDef% и контекст выполнения



# CommandQueue<T>.ThenUse(T->())
# CQ:ThenUseDef
Создаёт очередь, которая выполнит данную и вернёт её результат
Но перед этим выполнит на CPU процедуру p, используя полученный результат

# CommandQueue<T>.ThenUse((T, Context)->())
%CQ:ThenUseDef% и контекст выполнения



# CommandQueue[%Base,<T>%].Multiusable
Создаёт функцию, вызывая которую можно создать любое кол-во очередей-удлинителей для данной очереди
Подробнее в справке: "Очередь>>Создание очередей>>Множественное использование очереди"



# CQ:ThenSaveRes
В конце выполнения созданная очередь возвращает то, что вернула данная

# CQ:FinallyMode:

# CQ:FinallyMode:Finally
не зависимо от исключений при выполнении данной очереди



# CommandQueue<T>.Then[%finally:,Finally%]MarkerSignal
Создаёт очередь, сначала выполняющую данную, а затем вызывающую свой .SendSignal %CQ:FinallyMode:{%finally%}%
При передаче в Wait-очереди, DetachedMarkerSignal превращается в маркер
%CQ:ThenSaveRes%

# CommandQueueBase.Then[%finally:,Finally%]MarkerSignal
Создаёт особый маркер из данной очереди
При выполнении он сначала выполняет данную очередь, а затем вызывает свой .SendSignal %CQ:FinallyMode:{%finally%}%
%CQ:ThenSaveRes%

# CommandQueue[%Base,<T>%].Then[%finally:,Finally%]WaitFor(WaitMarker)
Создаёт очередь, сначала выполняющую данную, а затем ожидающую сигнала от указанного маркера %CQ:FinallyMode:{%finally%}%
%CQ:ThenSaveRes%



# CQ:Handle
Создаёт очередь, сначала выполняющую данную, а затем обрабатывающую кинутые в ней исключения

# CommandQueueBase.HandleWithoutRes<TException>(TException->boolean)
# CommandQueueBase.HandleWithoutRes(Exception->boolean)
%CQ:Handle%
Созданная очередь возвращает nil %CQ:FinallyMode:Finally%

# CommandQueue<T>.HandleDefaultRes<TException>(TException->boolean, T)
# CommandQueue<T>.HandleDefaultRes(Exception->boolean, T)
%CQ:Handle%
%CQ:ThenSaveRes%, если исключений небыло и указанное значение если обработчик был успешно выполнен

# CommandQueue<T>.HandleReplaceRes(List<Exception> -> T)
%CQ:Handle%
Для того чтоб пометить исключение обработанным - его надо удалить из полученного списка
Возвращаемое значение обработчика указывает на что надо заменить возвращаемое значение данной очереди, если обработчик был успешно выполнен



# CommandQueueBase.ToString
Возвращает строковое представление данной очереди
Используйте это значение только для отладки, потому что данный метод довольно медленный

# CommandQueueBase.Print[%,ln%]
Вызывает Write{%0%}(ToString) для данной очереди и возвращает её же


