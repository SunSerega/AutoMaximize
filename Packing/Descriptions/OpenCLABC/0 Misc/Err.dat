


# OpenCLException
Класс исключений из OpenCL



# Err:NoParamCtor
Был вызван не_применимый конструктор без параметров... Обратитесь к разработчику OpenCLABC



# Err:CLMemorySegment:WrongNtvType
Неправильный тип неуправляемого объекта памяти. Ожидалось [MEM_OBJECT_BUFFER], а не [{t}]



# Err:Device:SplitCUCount
Количество ядер должно быть положительным числом, а не {CUCount}

# Err:Device:SplitNotSupported
Данный режим .Split не поддерживается выбранным устройством



# Err:Context:WrongMainDvc
main_dvc должен быть в списке устройств контекста



# Err:ProgramCode:BuildFail
Ошибка компиляции OpenCL программы:



#Err:NativeArray:SliceCopy:WriteSize
Массив присваиваемый свойству NativeArray<>.SliceCopy должен иметь размер ({value.Length}), равный размеру среза ({expected_len})



# Err:Blittable:Main
Значения типа {TypeToTypeName(t)} нельзя {source_name}

# Err:Blittable:Blame
%Err:Blittable:Main%, потому что он содержит тип {TypeToTypeName(blame)}

# Err:Blittable:Source:NativeValue
использовать как тип значения NativeValue<>

# Err:Blittable:Source:NativeArray
использовать как элементы NativeArray<>

# Err:Blittable:Source:CLValue
использовать как тип значения CLValue<>

# Err:Blittable:Source:CLArray
использовать как элементы CLArray<>

# Err:Blittable:Source:KernelArg
передавать в качестве параметров kernel''а

# Err:Blittable:Source:CLMemorySegment:WriteValue
# Err:Blittable:Source:CLMemorySegment:WriteValueQ
# Err:Blittable:Source:CLMemorySegment:WriteArray1AutoSize
# Err:Blittable:Source:CLMemorySegment:WriteArray2AutoSize
# Err:Blittable:Source:CLMemorySegment:WriteArray3AutoSize
# Err:Blittable:Source:CLMemorySegment:WriteArray1
# Err:Blittable:Source:CLMemorySegment:WriteArray2
# Err:Blittable:Source:CLMemorySegment:WriteArray3
# Err:Blittable:Source:CLMemorySegment:WriteNativeValue
# Err:Blittable:Source:CLMemorySegment:WriteNativeArrayAutoSize
# Err:Blittable:Source:CLMemorySegment:WriteNativeArray
# Err:Blittable:Source:CLMemorySegment:FillValueAutoSize
# Err:Blittable:Source:CLMemorySegment:FillValue
# Err:Blittable:Source:CLMemorySegment:FillValueAutoSizeQ
# Err:Blittable:Source:CLMemorySegment:FillValueQ
# Err:Blittable:Source:CLMemorySegment:FillArray1AutoSize
# Err:Blittable:Source:CLMemorySegment:FillArray2AutoSize
# Err:Blittable:Source:CLMemorySegment:FillArray3AutoSize
# Err:Blittable:Source:CLMemorySegment:FillArray1
# Err:Blittable:Source:CLMemorySegment:FillArray2
# Err:Blittable:Source:CLMemorySegment:FillArray3
# Err:Blittable:Source:CLMemorySegment:FillArraySegmentAutoSize
# Err:Blittable:Source:CLMemorySegment:FillArraySegment
# Err:Blittable:Source:CLMemorySegment:FillNativeValueAutoSize
# Err:Blittable:Source:CLMemorySegment:FillNativeValue
# Err:Blittable:Source:CLMemorySegment:FillNativeArrayAutoSize
# Err:Blittable:Source:CLMemorySegment:FillNativeArray
записывать в область памяти OpenCL

# Err:Blittable:Source:CLMemorySegment:ReadArray1AutoSize
# Err:Blittable:Source:CLMemorySegment:ReadArray2AutoSize
# Err:Blittable:Source:CLMemorySegment:ReadArray3AutoSize
# Err:Blittable:Source:CLMemorySegment:ReadArray1
# Err:Blittable:Source:CLMemorySegment:ReadArray2
# Err:Blittable:Source:CLMemorySegment:ReadArray3
# Err:Blittable:Source:CLMemorySegment:ReadNativeValue
# Err:Blittable:Source:CLMemorySegment:ReadNativeArrayAutoSize
# Err:Blittable:Source:CLMemorySegment:ReadNativeArray
# Err:Blittable:Source:CLMemorySegment:GetValue
# Err:Blittable:Source:CLMemorySegment:GetArrayAutoSize
# Err:Blittable:Source:CLMemorySegment:GetArray
# Err:Blittable:Source:CLMemorySegment:GetArray2
# Err:Blittable:Source:CLMemorySegment:GetArray3
читать из области памяти OpenCL



# Err:Blittable:Source:QueueResPtr
использовать в некоторой внутренней ситуации (напишите об этом в issue)



# Err:CLTask:
При выполнении очереди было вызвано {err_lst.Count} исключений. Используйте try чтоб получить больше информации



# Err:Cast:nil->T
.Cast не может преобразовывать nil в {TypeToTypeName(typeof(T))}

# Err:Cast:TInp->TRes
.Cast не может преобразовывать {TypeToTypeName(typeof(TInp))} в {TypeToTypeName(typeof(TRes))}



# Err:FlattenQueueArray:InpEmpty
Функции CombineSyncQueue/CombineAsyncQueue не могут принимать 0 очередей

# Err:WaitCombine:InpEmpty
Количество комбинируемых маркеров должно быть положительным

# Err:WaitMarkerCombination.ConvertToQBase
Преобразовывать комбинацию маркеров в очередь нельзя. Возможно вы забыли написать WaitFor?


