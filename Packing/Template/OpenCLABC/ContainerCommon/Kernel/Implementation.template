


constructor KernelCCQ.Create(o: Kernel) := inherited;
constructor KernelCCQ.Create(q: CommandQueue<Kernel>) := inherited;
constructor KernelCCQ.Create := inherited;

{$region Special .Add's}

function KernelCCQ.ThenQueue(q: CommandQueueBase): KernelCCQ;
begin
  var comm := QueueCommandFactory&<Kernel>.Make(q);
  Result := if comm=nil then self else AddCommand(self, comm);
end;

function KernelCCQ.ThenConstProc(p: Kernel->()) := AddCommand(self, ProcCommandFactory&<Kernel>.MakeConst&<SimpleProcContainer<Kernel>>(p));
function KernelCCQ.ThenConstProc(p: (Kernel, Context)->()) := AddCommand(self, ProcCommandFactory&<Kernel>.MakeConst&<SimpleProcContainerC<Kernel>>(p));
function KernelCCQ.ThenQuickProc(p: Kernel->()) := AddCommand(self, ProcCommandFactory&<Kernel>.MakeQuick&<SimpleProcContainer<Kernel>>(p));
function KernelCCQ.ThenQuickProc(p: (Kernel, Context)->()) := AddCommand(self, ProcCommandFactory&<Kernel>.MakeQuick&<SimpleProcContainerC<Kernel>>(p));
function KernelCCQ.ThenThreadedProc(p: Kernel->()) := AddCommand(self, ProcCommandFactory&<Kernel>.MakeThreaded&<SimpleProcContainer<Kernel>>(p));
function KernelCCQ.ThenThreadedProc(p: (Kernel, Context)->()) := AddCommand(self, ProcCommandFactory&<Kernel>.MakeThreaded&<SimpleProcContainerC<Kernel>>(p));

function KernelCCQ.ThenWait(marker: WaitMarker) := AddCommand(self, WaitCommandFactory&<Kernel>.Make(marker));

{$endregion Special .Add's}


