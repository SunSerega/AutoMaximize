


{$region Get}

{$region GetDataAutoSize}

type
  BufferCommandGetDataAutoSize = sealed class(EnqueueableGetCommand<Buffer, IntPtr>)
    
    protected function ParamCountL1: integer; override := 0;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(ccq: BufferCommandQueue);
    begin
      inherited Create(ccq);
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList, QueueResDelayedBase<IntPtr>)->cl_event; override;
    begin
      
      Result := (o, cq, tsk, evs, own_qr)->
      begin
        
        var res_ev: cl_event;
        
        var res := Marshal.AllocHGlobal(IntPtr(pointer(o.Size))); own_qr.SetRes(res);
        //ToDo А что если результат уже получен и освобождёт сдедующей .ThenConvert
        // - Вообще .WhenError тут (и в +1 месте) - говнокод
        tsk.WhenError((tsk,err)->Marshal.FreeHGlobal(res));
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, o.Size,
          res,
          evs.count, evs.evs, res_ev
        );
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override := exit;
    
  end;
  
{$endregion GetDataAutoSize}

function BufferCommandQueue.AddGetData: CommandQueue<IntPtr> :=
new BufferCommandGetDataAutoSize(self) as CommandQueue<IntPtr>;

{$region GetData}

type
  BufferCommandGetData = sealed class(EnqueueableGetCommand<Buffer, IntPtr>)
    private offset: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    
    protected function ParamCountL1: integer; override := 2;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(ccq: BufferCommandQueue; offset, len: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.offset := offset;
      self.   len :=    len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList, QueueResDelayedBase<IntPtr>)->cl_event; override;
    begin
      var offset_qr := offset.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 += offset_qr.ev;
      var    len_qr :=    len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=    len_qr.ev;
      
      Result := (o, cq, tsk, evs, own_qr)->
      begin
        var offset := offset_qr.GetRes;
        var    len :=    len_qr.GetRes;
        
        var res_ev: cl_event;
        
        var res := Marshal.AllocHGlobal(IntPtr(pointer(o.Size))); own_qr.SetRes(res);
        tsk.WhenError((tsk,err)->Marshal.FreeHGlobal(res));
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(offset), new UIntPtr(len),
          res,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      offset.RegisterWaitables(tsk, prev_hubs);
         len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion GetData}

function BufferCommandQueue.AddGetData(offset, len: CommandQueue<integer>): CommandQueue<IntPtr> :=
new BufferCommandGetData(self, offset, len) as CommandQueue<IntPtr>;

function BufferCommandQueue.AddGetValue<TRecord>: CommandQueue<TRecord> :=
AddGetValue&<TRecord>(0);

{$region GetValue}

type
  BufferCommandGetValue<TRecord> = sealed class(EnqueueableGetCommand<Buffer, TRecord>)
  where TRecord: record;
    private offset: CommandQueue<integer>;
    
    protected function ParamCountL1: integer; override := 1;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(ccq: BufferCommandQueue; offset: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.offset := offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList, QueueResDelayedBase<TRecord>)->cl_event; override;
    begin
      var offset_qr := offset.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 += offset_qr.ev;
      
      Result := (o, cq, tsk, evs, own_qr)->
      begin
        var offset := offset_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(offset), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new IntPtr((own_qr as QueueResDelayedPtr<TRecord>).ptr),
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        var own_qr_hnd := GCHandle.Alloc(own_qr);
        
        EventList.AttachFinallyCallback(res_ev, ()->
        begin
          own_qr_hnd.Free;
        end, tsk);
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      offset.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion GetValue}

function BufferCommandQueue.AddGetValue<TRecord>(offset: CommandQueue<integer>): CommandQueue<TRecord> :=
new BufferCommandGetValue<TRecord>(self, offset) as CommandQueue<TRecord>;

{$endregion Get}


