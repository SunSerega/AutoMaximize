


# [%mode:Write,Read%]Data!AutoSize
ptr: CommandQueue<IntPtr>
!Enqueue
cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  UIntPtr.Zero, o.Size,
  !ptr!,
  !evs!
).RaiseIfError;

# [%mode:Write,Read%]Data
ptr: CommandQueue<IntPtr>; offset, len: CommandQueue<integer>
!Enqueue
cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!offset!), new UIntPtr(!len!),
  !ptr!,
  !evs!
).RaiseIfError;

# [%mode:Write,Read%]Data
ptr: pointer
!ShortDef
{%mode%}Data(IntPtr(ptr));

# [%mode:Write,Read%]Data
ptr: pointer; offset, len: CommandQueue<integer>
!ShortDef
{%mode%}Data(IntPtr(ptr), offset, len);



# WriteValue
val: TRecord
!ShortDef
WriteValue(val, 0);

# WriteValue
val: TRecord; offset: CommandQueue<integer>
!Enqueue
cl.EnqueueWriteBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!offset!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  new IntPtr(!val:ptr!),
  !evs!
).RaiseIfError;

# WriteValue!Q
val: CommandQueue<TRecord>
!ShortDef
WriteValue(val, 0);

# WriteValue!Q
val: CommandQueue<TRecord>; offset: CommandQueue<integer>
!Enqueue
cl.EnqueueWriteBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!offset!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  new IntPtr(!val:ptr!),
  !evs!
).RaiseIfError;



# [%mode:Write,Read%]Array[%rank:1,2,3%]
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>
!ShortDef
{%mode%}Array{%rank%}(a, {%rank? 0 : 0,0 : 0,0,0 %});

# [%mode:Write,Read%]Array[%rank:1,2,3%]!AutoSize
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>; {%rank? a_offset : a_offset1,a_offset2 : a_offset1,a_offset2,a_offset3 %}: CommandQueue<integer>
!Enqueue
cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.BLOCKING,
  UIntPtr.Zero, new UIntPtr(!a!.Length*Marshal.SizeOf&<TRecord>),
  !a![{%rank? !a_offset! : !a_offset1!,!a_offset2! : !a_offset1!,!a_offset2!,!a_offset3! %}],
  !evs!
).RaiseIfError;
!NeedThread

# [%mode:Write,Read%]Array[%rank:1,2,3%]
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>; {%rank? a_offset : a_offset1,a_offset2 : a_offset1,a_offset2,a_offset3 %}, buff_offset, len: CommandQueue<integer>
!Enqueue
cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.BLOCKING,
  new UIntPtr(!buff_offset!), new UIntPtr(!len!*Marshal.SizeOf&<TRecord>),
  !a![{%rank? !a_offset! : !a_offset1!,!a_offset2! : !a_offset1!,!a_offset2!,!a_offset3! %}],
  !evs!
).RaiseIfError;
!NeedThread


