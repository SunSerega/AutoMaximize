


# WriteValue![%Q:,Q%]
val: {%Q?TRecord:CommandQueue<TRecord>%}
!ShortDef
WriteValue(val, 0);

# WriteValue![%Q:,Q%]
val: {%Q?TRecord:CommandQueue<TRecord>%}; mem_offset: CommandQueue<integer>
!Enqueue
var ec := cl.EnqueueWriteBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  new IntPtr(!val:ptr!),
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# [%mode:Write,Read%]Array[%rank:1,2,3%]!AutoSize
a: array{%rank? : [,] : [,,] %} of TRecord
!ShortDef
{%mode%}Array{%rank%}(CQ(a));

# [%mode:Write,Read%]Array[%rank:1,2,3%]
a: array{%rank? : [,] : [,,] %} of TRecord; {%rank? a_ind : a_ind1,a_ind2 : a_ind1,a_ind2,a_ind3 %}, el_count, mem_offset: CommandQueue<integer>
!ShortDef
{%mode%}Array{%rank%}(CQ(a), {%rank? a_ind : a_ind1,a_ind2 : a_ind1,a_ind2,a_ind3 %}, el_count, mem_offset);

# [%mode:Write,Read%]Array[%rank:1,2,3%]!AutoSize
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>
!Enqueue
//TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
var ec := cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  UIntPtr.Zero, new UIntPtr(!a:pinn!.Length*Marshal.SizeOf&<TRecord>),
  !a:pinn![{%rank? 0 : 0,0 : 0,0,0 %}],
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);

# [%mode:Write,Read%]Array[%rank:1,2,3%]
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>; {%rank? a_ind : a_ind1,a_ind2 : a_ind1,a_ind2,a_ind3 %}, el_count, mem_offset: CommandQueue<integer>
!Enqueue
var ec := cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), new UIntPtr(!el_count!*Marshal.SizeOf&<TRecord>),
  !a:pinn![{%rank? !a_ind! : !a_ind1!,!a_ind2! : !a_ind1!,!a_ind2!,!a_ind3! %}],
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# [%mode:Write,Read%]ArraySegment
a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>
!ShortDef
{%mode%}Array1(CQ(a.Array), a.Offset, a.Count, mem_offset);










# [%mode:Write,Read%]Data![%AutoSize:AutoSize,%]
ptr: CommandQueue<IntPtr>{%AutoSize?:; mem_offset, len\: CommandQueue<integer>%}
!Enqueue
var ec := cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!len!) %},
  !ptr!,
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);

# [%mode:Write,Read%]Data![%AutoSize:AutoSize,%]
ptr: pointer{%AutoSize?:; mem_offset, len\: CommandQueue<integer>%}
!ShortDef
{%mode%}Data(IntPtr(ptr){%AutoSize?:, mem_offset, len%});

# [%mode:Write,Read%]Data!Area
data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>
!Enqueue
var ec := cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), !data!.sz,
  !data!.ptr,
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# [%mode:Write,Read%]NativeValue![%AutoOffset:AutoOffset,%]
val: NativeValue<TRecord>{%AutoOffset?: ; mem_offset\: CommandQueue<integer> %}
!ShortDef
{%mode%}NativeValue(CQ(val), {%AutoOffset? 0 : mem_offset %});

# [%mode:Write,Read%]NativeValue
val: CommandQueue<NativeValue<TRecord>>
!ShortDef
{%mode%}NativeValue(val, 0);

# [%mode:Write,Read%]NativeValue
val: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>
!Enqueue
var ec := cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), !val!.MemoryArea.sz,
  !val!.MemoryArea.ptr,
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# [%mode:Write,Read%]NativeArray![%AutoSize:AutoSize,%]
a: NativeArray<TRecord>{%AutoSize?: ; a_ind,el_count,mem_offset\: CommandQueue<integer> %}
!ShortDef
{%mode%}NativeArray(CQ(a){%AutoSize?: ,a_ind,el_count,mem_offset %});

# [%mode:Write,Read%]NativeArray![%AutoSize:AutoSize,%]
a: CommandQueue<NativeArray<TRecord>>{%AutoSize?: ; a_ind,el_count,mem_offset\: CommandQueue<integer> %}
!Enqueue
var ec := cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  {%AutoSize? UIntPtr.Zero : new UIntPtr(!mem_offset!) %},
  {%AutoSize? !a!.MemoryArea.sz : new UIntPtr(!el_count!*Marshal.SizeOf&<TRecord>) %},
  {%AutoSize? !a!.MemoryArea.ptr : new IntPtr( !a!.ItemPtrUnchecked[!a_ind!] ) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);


