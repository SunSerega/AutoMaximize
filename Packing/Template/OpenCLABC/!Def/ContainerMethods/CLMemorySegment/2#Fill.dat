


# FillValue![%AutoSize:AutoSize,%][%Q:,Q%]
val: {%Q?TRecord:CommandQueue<TRecord>%}{%AutoSize?:; mem_offset, fill_byte_len\: CommandQueue<integer>%}
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  new IntPtr(!val:ptr!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!fill_byte_len!) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# FillArray[%rank:1,2,3%]!AutoSize
a: array{%rank? : [,] : [,,] %} of TRecord
!ShortDef
FillArray{%rank%}(CQ(a));

# FillArray[%rank:1,2,3%]
a: array{%rank? : [,] : [,,] %} of TRecord; {%rank? a_ind : a_ind1,a_ind2 : a_ind1,a_ind2,a_ind3 %}, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>
!ShortDef
FillArray{%rank%}(CQ(a), {%rank? a_ind : a_ind1,a_ind2 : a_ind1,a_ind2,a_ind3 %}, pattern_byte_len, mem_offset, fill_byte_len);

# FillArray[%rank:1,2,3%]!AutoSize
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>
!Enqueue
//TODO unable to merge this Enqueue with non-AutoSize, because %rank would be nested in %AutoSize
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !a:pinn![{%rank? 0 : 0,0 : 0,0,0 %}], new UIntPtr(!a:pinn!.Length*Marshal.SizeOf&<TRecord>),
  UIntPtr.Zero, o.Size,
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);

# FillArray[%rank:1,2,3%]
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>; {%rank? a_ind : a_ind1,a_ind2 : a_ind1,a_ind2,a_ind3 %}, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !a:pinn![{%rank? !a_ind! : !a_ind1!,!a_ind2! : !a_ind1!,!a_ind2!,!a_ind3! %}], new UIntPtr(!pattern_byte_len!),
  new UIntPtr(!mem_offset!), new UIntPtr(!fill_byte_len!),
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# FillArraySegment![%AutoSize:AutoSize,%]
a: ArraySegment<TRecord>{%AutoSize?: ; mem_offset, fill_byte_len\: CommandQueue<integer> %}
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !a:pinn!.Array[!a:pinn!.Offset], new UIntPtr(!a:pinn!.Count * Marshal.SizeOf&<TRecord>),
  {%AutoSize? UIntPtr.Zero,o.Size : new UIntPtr(!mem_offset!),new UIntPtr(!fill_byte_len!) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);










# FillData![%AutoSize:AutoSize,%]
ptr: CommandQueue<IntPtr>; pattern_byte_len{%AutoSize?:, mem_offset, fill_byte_len%}: CommandQueue<integer>
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !ptr!, new UIntPtr(!pattern_byte_len!),
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!fill_byte_len!) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);

# FillData![%AutoSize:AutoSize,%]
ptr: pointer; pattern_byte_len{%AutoSize?:, mem_offset, fill_byte_len%}: CommandQueue<integer>
!ShortDef
FillData(IntPtr(ptr), pattern_byte_len{%AutoSize?:, mem_offset, fill_byte_len%});

# FillData!Area[%AutoSize:AutoSize,%]
data: CommandQueue<NativeMemoryArea>{%AutoSize?: ;mem_offset,fill_byte_len\:CommandQueue<integer> %}
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !data!.ptr, !data!.sz,
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!fill_byte_len!) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# FillNativeValue![%AutoSize:AutoSize,%]
val: NativeValue<TRecord>{%AutoSize?: ; mem_offset, fill_byte_len\: CommandQueue<integer> %}
!ShortDef
FillNativeValue(CQ(val){%AutoSize?: ,mem_offset,fill_byte_len %});

# FillNativeValue![%AutoSize:AutoSize,%]
val: CommandQueue<NativeValue<TRecord>>{%AutoSize?: ; mem_offset, fill_byte_len\: CommandQueue<integer> %}
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  !val!.MemoryArea.ptr, !val!.MemoryArea.sz,
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!fill_byte_len!) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# FillNativeArray![%AutoSize:AutoSize,%]
a: NativeArray<TRecord>{%AutoSize?: ; a_ind,pattern_byte_len, mem_offset,fill_byte_len\: CommandQueue<integer> %}
!ShortDef
FillNativeArray(CQ(a){%AutoSize?: ,a_ind,pattern_byte_len, mem_offset,fill_byte_len %});

# FillNativeArray![%AutoSize:AutoSize,%]
a: CommandQueue<NativeArray<TRecord>>{%AutoSize?: ; a_ind,pattern_byte_len, mem_offset,fill_byte_len\: CommandQueue<integer> %}
!Enqueue
var ec := cl.EnqueueFillBuffer(
  cq, o.Native,
  {%AutoSize? !a!.MemoryArea.ptr,!a!.MemoryArea.sz : new IntPtr(!a!.ItemPtrUnchecked[!a_ind!]),new UIntPtr(!pattern_byte_len!) %},
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!fill_byte_len!) %},
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);


