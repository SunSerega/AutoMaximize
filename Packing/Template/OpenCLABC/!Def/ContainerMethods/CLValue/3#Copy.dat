


# Copy[%direction:To,From%]!CLMemorySegment
mem: CommandQueue<CLMemorySegment>
!ShortDef
Copy{%direction%}(mem, 0);

# Copy[%direction:To,From%]
mem: CommandQueue<CLMemorySegment>; mem_offset: CommandQueue<integer>
!Enqueue
var ec := cl.EnqueueCopyBuffer(
  cq, {%direction? o.Native,!mem!.Native : !mem!.Native,o.Native %},
  {%direction? UIntPtr.Zero,new UIntPtr(!mem_offset!) : new UIntPtr(!mem_offset!),UIntPtr.Zero %},
  new UIntPtr(Marshal.SizeOf&<T>),
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# Copy[%direction:To,From%]!CLValue
val: CommandQueue<CLValue<&T>>
!Enqueue
var ec := cl.EnqueueCopyBuffer(
  cq, {%direction? o.Native,!val!.Native : !val!.Native,o.Native %},
  UIntPtr.Zero, UIntPtr.Zero,
  new UIntPtr(Marshal.SizeOf&<T>),
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);


