


# [%mode:Write,Read%]Data![%AutoSize:AutoSize,%]
ptr: CommandQueue<IntPtr>{%AutoSize?:; mem_offset, len\: CommandQueue<integer>%}
!Enqueue
var ec := cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!len!) %},
  !ptr!,
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);

# [%mode:Write,Read%]Data![%AutoSize:AutoSize,%]
ptr: pointer{%AutoSize?:; mem_offset, len\: CommandQueue<integer>%}
!ShortDef
{%mode%}Data(IntPtr(ptr){%AutoSize?:, mem_offset, len%});



# WriteValue![%Q:,Q%]
val: {%Q?TRecord:CommandQueue<TRecord>%}
!ShortDef
WriteValue(val, 0);

# [%mode:Write,Read%]Value!N[%Q:,Q%]
val: {%Q?NativeValue<TRecord>:CommandQueue<NativeValue<TRecord>>%}
!ShortDef
{%mode%}Value(val, 0);

# WriteValue![%Q:,Q%]
val: {%Q?TRecord:CommandQueue<TRecord>%}; mem_offset: CommandQueue<integer>
!Enqueue
var ec := cl.EnqueueWriteBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  new IntPtr(!val:ptr!),
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);

# [%mode:Write,Read%]Value!N[%Q:,Q%]
val: {%Q?NativeValue<TRecord>:CommandQueue<NativeValue<TRecord>>%}; mem_offset: CommandQueue<integer>
!Enqueue
var ec := cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  !val!.ptr,
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# [%mode:Write,Read%]Array[%rank:1,2,3%]!AutoSize
a: array{%rank? : [,] : [,,] %} of TRecord
!ShortDef
{%mode%}Array{%rank%}(new ConstQueue<array{%rank? : [,] : [,,] %} of TRecord>(a));

# [%mode:Write,Read%]Array[%rank:1,2,3%]
a: array{%rank? : [,] : [,,] %} of TRecord; {%rank? a_offset : a_offset1,a_offset2 : a_offset1,a_offset2,a_offset3 %}, len, mem_offset: CommandQueue<integer>
!ShortDef
{%mode%}Array{%rank%}(new ConstQueue<array{%rank? : [,] : [,,] %} of TRecord>(a), {%rank? a_offset : a_offset1,a_offset2 : a_offset1,a_offset2,a_offset3 %}, len, mem_offset);

# [%mode:Write,Read%]Array[%rank:1,2,3%]!AutoSize
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>
!Enqueue
//TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
var ec := cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  UIntPtr.Zero, new UIntPtr(!a:pinn!.Length*Marshal.SizeOf&<TRecord>),
  !a:pinn![{%rank? 0 : 0,0 : 0,0,0 %}],
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);

# [%mode:Write,Read%]Array[%rank:1,2,3%]
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>; {%rank? a_offset : a_offset1,a_offset2 : a_offset1,a_offset2,a_offset3 %}, len, mem_offset: CommandQueue<integer>
!Enqueue
var ec := cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), new UIntPtr(!len!*Marshal.SizeOf&<TRecord>),
  !a:pinn![{%rank? !a_offset! : !a_offset1!,!a_offset2! : !a_offset1!,!a_offset2!,!a_offset3! %}],
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);


