


# GetData!AutoSize
!ResultType
IntPtr
!Enqueue
var res := Marshal.AllocHGlobal(IntPtr(pointer(o.Size)));
//ToDo А что если результат уже получен и освобождёт сдедующей .ThenConvert
// - Вообще .WhenError тут - говнокод. Надо 
tsk.WhenError((tsk,err)->Marshal.FreeHGlobal(res));
cl.EnqueueReadBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  UIntPtr.Zero, o.Size,
  res,
  !evs!
);
qr.SetRes(res);

# GetData
offset, len: CommandQueue<integer>
!ResultType
IntPtr
!Enqueue
res := Marshal.AllocHGlobal(IntPtr(pointer(o.Size)));
tsk.WhenError((tsk,err)->Marshal.FreeHGlobal(res));
cl.EnqueueReadBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!offset!), new UIntPtr(!len!),
  res,
  !evs!
).RaiseIfError;



# GetValue
!ResultType
TRecord
!ShortDef
GetValue&<TRecord>(0);

# GetValue
offset: CommandQueue<integer>
!ResultType
TRecord
!Enqueue
var res_ptr := Marshal.AllocHGlobal(Marshal.SizeOf&<TRecord>);
tsk.WhenError((tsk,err)->Marshal.FreeHGlobal(res_ptr));
res := pointer(res_ptr);
cl.EnqueueReadBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!offset!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  res_ptr,
  !evs!
).RaiseIfError;
!ForcePtrQr


