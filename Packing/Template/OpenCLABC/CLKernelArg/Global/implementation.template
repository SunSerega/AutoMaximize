


{$region Managed}

{$region Array}

type
  CLKernelArgGlobalArray<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalConvCommon;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgGlobal:Array%');
    
    public constructor(a: array of T; c: CLContext; kernel_use: CLMemoryUsage);
    begin
      var ec: ErrorCode;
      var gc_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
      var mem := cl.CreateBuffer((c??CLContext.Default).Native, CLMemoryUsage.MakeCLFlags(kernel_use, CLMemoryUsage.ReadWrite) + MemFlags.MEM_USE_HOST_PTR, new UIntPtr(UInt32(a.Length)*uint64(Marshal.SizeOf(default(T)))), a[0], ec);
      data := new CLKernelArgGlobalConvCommon(mem, gc_hnd);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke();
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromArray<T>(a: array of T; c: CLContext; kernel_use: CLMemoryUsage): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalArray<T>(a, c, kernel_use) end;

{$endregion Array}

{$region Array2}

type
  CLKernelArgGlobalArray2<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalConvCommon;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgGlobal:Array2%');
    
    public constructor(a2: array[,] of T; c: CLContext; kernel_use: CLMemoryUsage);
    begin
      var ec: ErrorCode;
      var gc_hnd := GCHandle.Alloc(a2, GCHandleType.Pinned);
      var mem := cl.CreateBuffer((c??CLContext.Default).Native, CLMemoryUsage.MakeCLFlags(kernel_use, CLMemoryUsage.ReadWrite) + MemFlags.MEM_USE_HOST_PTR, new UIntPtr(UInt32(a2.Length)*uint64(Marshal.SizeOf(default(T)))), a2[0,0], ec);
      data := new CLKernelArgGlobalConvCommon(mem, gc_hnd);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke();
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromArray2<T>(a2: array[,] of T; c: CLContext; kernel_use: CLMemoryUsage): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalArray2<T>(a2, c, kernel_use) end;

{$endregion Array2}

{$region Array3}

type
  CLKernelArgGlobalArray3<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalConvCommon;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgGlobal:Array3%');
    
    public constructor(a3: array[,,] of T; c: CLContext; kernel_use: CLMemoryUsage);
    begin
      var ec: ErrorCode;
      var gc_hnd := GCHandle.Alloc(a3, GCHandleType.Pinned);
      var mem := cl.CreateBuffer((c??CLContext.Default).Native, CLMemoryUsage.MakeCLFlags(kernel_use, CLMemoryUsage.ReadWrite) + MemFlags.MEM_USE_HOST_PTR, new UIntPtr(UInt32(a3.Length)*uint64(Marshal.SizeOf(default(T)))), a3[0,0,0], ec);
      data := new CLKernelArgGlobalConvCommon(mem, gc_hnd);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke();
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromArray3<T>(a3: array[,,] of T; c: CLContext; kernel_use: CLMemoryUsage): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalArray3<T>(a3, c, kernel_use) end;

{$endregion Array3}

{$region ArraySegment}

type
  CLKernelArgGlobalArraySegment<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalConvCommon;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgGlobal:ArraySegment%');
    
    public constructor(seg: ArraySegment<T>; c: CLContext; kernel_use: CLMemoryUsage);
    begin
      var ec: ErrorCode;
      var gc_hnd := GCHandle.Alloc(seg.Array, GCHandleType.Pinned);
      var mem := cl.CreateBuffer((c??CLContext.Default).Native, CLMemoryUsage.MakeCLFlags(kernel_use, CLMemoryUsage.ReadWrite) + MemFlags.MEM_USE_HOST_PTR, new UIntPtr(UInt32(seg.Count)*uint64(Marshal.SizeOf(default(T)))), seg.Array[seg.Offset], ec);
      data := new CLKernelArgGlobalConvCommon(mem, gc_hnd);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke();
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromArraySegment<T>(seg: ArraySegment<T>; c: CLContext; kernel_use: CLMemoryUsage): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalArraySegment<T>(seg, c, kernel_use) end;

{$endregion ArraySegment}

{$endregion Managed}

{$region NativeArea}

{$region NativeMemoryArea}

type
  CLKernelArgGlobalNativeMemoryArea = sealed class(CLKernelArgGlobal)
    private data: CLKernelArgGlobalConvCommon;
    
    public constructor(ntv_mem_area: NativeMemoryArea; c: CLContext; kernel_use: CLMemoryUsage);
    begin
      var ec: ErrorCode;
      var mem := cl.CreateBuffer((c??CLContext.Default).Native, CLMemoryUsage.MakeCLFlags(kernel_use, CLMemoryUsage.ReadWrite) + MemFlags.MEM_USE_HOST_PTR, ntv_mem_area.sz, ntv_mem_area.ptr, ec);
      data := new CLKernelArgGlobalConvCommon(mem);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke();
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromNativeMemoryArea(ntv_mem_area: NativeMemoryArea; c: CLContext; kernel_use: CLMemoryUsage): CLKernelArgGlobal;
begin Result := new CLKernelArgGlobalNativeMemoryArea(ntv_mem_area, c, kernel_use) end;

{$endregion NativeMemoryArea}

{$region NativeValueArea}

type
  CLKernelArgGlobalNativeValueArea<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalConvCommon;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgGlobal:NativeValueArea%');
    
    public constructor(ntv_val_area: NativeValueArea<T>; c: CLContext; kernel_use: CLMemoryUsage);
    begin
      var ec: ErrorCode;
      var mem := cl.CreateBuffer((c??CLContext.Default).Native, CLMemoryUsage.MakeCLFlags(kernel_use, CLMemoryUsage.ReadWrite) + MemFlags.MEM_USE_HOST_PTR, ntv_val_area.ByteSize, ntv_val_area.ptr, ec);
      data := new CLKernelArgGlobalConvCommon(mem);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke();
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromNativeValueArea<T>(ntv_val_area: NativeValueArea<T>; c: CLContext; kernel_use: CLMemoryUsage): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalNativeValueArea<T>(ntv_val_area, c, kernel_use) end;

{$endregion NativeValueArea}

{$region NativeArrayArea}

type
  CLKernelArgGlobalNativeArrayArea<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalConvCommon;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgGlobal:NativeArrayArea%');
    
    public constructor(ntv_arr_area: NativeArrayArea<T>; c: CLContext; kernel_use: CLMemoryUsage);
    begin
      var ec: ErrorCode;
      var mem := cl.CreateBuffer((c??CLContext.Default).Native, CLMemoryUsage.MakeCLFlags(kernel_use, CLMemoryUsage.ReadWrite) + MemFlags.MEM_USE_HOST_PTR, ntv_arr_area.ByteSize, ntv_arr_area.first_ptr, ec);
      data := new CLKernelArgGlobalConvCommon(mem);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke();
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromNativeArrayArea<T>(ntv_arr_area: NativeArrayArea<T>; c: CLContext; kernel_use: CLMemoryUsage): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalNativeArrayArea<T>(ntv_arr_area, c, kernel_use) end;

{$endregion NativeArrayArea}

{$endregion NativeArea}

{$region Native}

{$region NativeMemory}

type
  CLKernelArgGlobalNativeMemory = sealed class(CLKernelArgGlobal)
    private data: CLKernelArgGlobalConvCommon;
    
    public constructor(ntv_mem: NativeMemory; c: CLContext; kernel_use: CLMemoryUsage);
    begin
      var ec: ErrorCode;
      var mem := cl.CreateBuffer((c??CLContext.Default).Native, CLMemoryUsage.MakeCLFlags(kernel_use, CLMemoryUsage.ReadWrite) + MemFlags.MEM_USE_HOST_PTR, ntv_mem.Area.sz, ntv_mem.Area.ptr, ec);
      data := new CLKernelArgGlobalConvCommon(mem);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke();
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromNativeMemory(ntv_mem: NativeMemory; c: CLContext; kernel_use: CLMemoryUsage): CLKernelArgGlobal;
begin Result := new CLKernelArgGlobalNativeMemory(ntv_mem, c, kernel_use) end;

{$endregion NativeMemory}

{$region NativeValue}

type
  CLKernelArgGlobalNativeValue<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalConvCommon;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgGlobal:NativeValue%');
    
    public constructor(ntv_val: NativeValue<T>; c: CLContext; kernel_use: CLMemoryUsage);
    begin
      var ec: ErrorCode;
      var mem := cl.CreateBuffer((c??CLContext.Default).Native, CLMemoryUsage.MakeCLFlags(kernel_use, CLMemoryUsage.ReadWrite) + MemFlags.MEM_USE_HOST_PTR, ntv_val.Area.ByteSize, ntv_val.Area.ptr, ec);
      data := new CLKernelArgGlobalConvCommon(mem);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke();
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromNativeValue<T>(ntv_val: NativeValue<T>; c: CLContext; kernel_use: CLMemoryUsage): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalNativeValue<T>(ntv_val, c, kernel_use) end;

{$endregion NativeValue}

{$region NativeArray}

type
  CLKernelArgGlobalNativeArray<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalConvCommon;
    
    static constructor := BlittableHelper.RaiseIfBad(typeof(T), $'%Err:Blittable:Source:CLKernelArgGlobal:NativeArray%');
    
    public constructor(ntv_arr: NativeArray<T>; c: CLContext; kernel_use: CLMemoryUsage);
    begin
      var ec: ErrorCode;
      var mem := cl.CreateBuffer((c??CLContext.Default).Native, CLMemoryUsage.MakeCLFlags(kernel_use, CLMemoryUsage.ReadWrite) + MemFlags.MEM_USE_HOST_PTR, ntv_arr.Area.ByteSize, ntv_arr.Area.first_ptr, ec);
      data := new CLKernelArgGlobalConvCommon(mem);
      OpenCLABCInternalException.RaiseIfError(ec);
    end;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke();
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromNativeArray<T>(ntv_arr: NativeArray<T>; c: CLContext; kernel_use: CLMemoryUsage): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalNativeArray<T>(ntv_arr, c, kernel_use) end;

{$endregion NativeArray}

{$endregion Native}

{$region CL}

{$region CLMemory}

type
  CLKernelArgGlobalCLMemory = sealed class(CLKernelArgGlobal)
    private data: CLKernelArgGlobalWrapCommon<CLMemory>;
    
    public constructor(cl_mem: CommandQueue<CLMemory>) :=
    data := new CLKernelArgGlobalWrapCommon<CLMemory>(cl_mem);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->o.Native);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromCLMemory(cl_mem: CommandQueue<CLMemory>): CLKernelArgGlobal;
begin Result := new CLKernelArgGlobalCLMemory(cl_mem) end;
static function CLKernelArgGlobal.operator implicit(cl_mem: CLMemoryCCQ): CLKernelArgGlobal;
begin Result := FromCLMemory(cl_mem as object as CommandQueue<CLMemory>) end;

{$endregion CLMemory}

{$region CLValue}

type
  CLKernelArgGlobalCLValue<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalWrapCommon<CLValue<T>>;
    
    public constructor(cl_val: CommandQueue<CLValue<T>>) :=
    data := new CLKernelArgGlobalWrapCommon<CLValue<T>>(cl_val);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->o.Native);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromCLValue<T>(cl_val: CommandQueue<CLValue<T>>): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalCLValue<T>(cl_val) end;
static function CLKernelArgGlobal.operator implicit<T>(cl_val: CLValueCCQ<T>): CLKernelArgGlobal; where T: record;
begin Result := FromCLValue(cl_val as object as CommandQueue<CLValue<T>>) end;

{$endregion CLValue}

{$region CLArray}

type
  CLKernelArgGlobalCLArray<T> = sealed class(CLKernelArgGlobal)
  where T: record;
    private data: CLKernelArgGlobalWrapCommon<CLArray<T>>;
    
    public constructor(cl_arr: CommandQueue<CLArray<T>>) :=
    data := new CLKernelArgGlobalWrapCommon<CLArray<T>>(cl_arr);
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; inited_hubs: HashSet<IMultiusableCommandQueueHub>); override :=
    data.q.InitBeforeInvoke(g, inited_hubs);
    
    protected function Invoke(inv: CLTaskBranchInvoker): ValueTuple<CLKernelArgSetter, EventList>; override :=
    data.Invoke(inv, o->o.Native);
    
    protected procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override :=
    data.ToString(sb, tabs, index, delayed);
    
  end;
  
static function CLKernelArgGlobal.FromCLArray<T>(cl_arr: CommandQueue<CLArray<T>>): CLKernelArgGlobal; where T: record;
begin Result := new CLKernelArgGlobalCLArray<T>(cl_arr) end;
static function CLKernelArgGlobal.operator implicit<T>(cl_arr: CLArrayCCQ<T>): CLKernelArgGlobal; where T: record;
begin Result := FromCLArray(cl_arr as object as CommandQueue<CLArray<T>>) end;

{$endregion CLArray}

{$endregion CL}


