


{$region Write}

{$region WriteDataAutoSize}

type
  BufferCommandWriteDataAutoSize = sealed class(EnqueueableGPUCommand<Buffer>)
    private ptr: CommandQueue<IntPtr>;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList)->cl_event; override;
    begin
      var ptr_qr := ptr.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 += ptr_qr.ev;
      
      Result := (o, cq, tsk, evs)->
      begin
        var ptr := ptr_qr.GetRes;
        
        var res: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, o.Size,
          ptr,
          evs.count, evs.evs, res
        ).RaiseIfError;
        
        Result := res;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      ptr.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteDataAutoSize}

function BufferCommandQueue.AddWriteData(ptr: CommandQueue<IntPtr>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteDataAutoSize(ptr));

{$region WriteData}

type
  BufferCommandWriteData = sealed class(EnqueueableGPUCommand<Buffer>)
    private    ptr: CommandQueue<IntPtr>;
    private offset: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    
    public constructor(ptr: CommandQueue<IntPtr>; offset, len: CommandQueue<integer>);
    begin
      self.   ptr :=    ptr;
      self.offset := offset;
      self.   len :=    len;
    end;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList)->cl_event; override;
    begin
      var    ptr_qr :=    ptr.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=    ptr_qr.ev;
      var offset_qr := offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += offset_qr.ev;
      var    len_qr :=    len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=    len_qr.ev;
      
      Result := (o, cq, tsk, evs)->
      begin
        var    ptr :=    ptr_qr.GetRes;
        var offset := offset_qr.GetRes;
        var    len :=    len_qr.GetRes;
        
        var res: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(offset), new UIntPtr(len),
          ptr,
          evs.count, evs.evs, res
        ).RaiseIfError;
        
        Result := res;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
         ptr.RegisterWaitables(tsk, prev_hubs);
      offset.RegisterWaitables(tsk, prev_hubs);
         len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteData}

function BufferCommandQueue.AddWriteData(ptr: CommandQueue<IntPtr>; offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteData(ptr, offset, len));

function BufferCommandQueue.AddWriteData(ptr: pointer): BufferCommandQueue :=
AddWriteData(IntPtr(ptr));

function BufferCommandQueue.AddWriteData(ptr: pointer; offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddWriteData(IntPtr(ptr), offset, len);

function BufferCommandQueue.AddWriteValue<TRecord>(val: TRecord): BufferCommandQueue :=
AddWriteValue(val, 0);

{$region WriteValue}

type
  BufferCommandWriteValue<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private    val: ^TRecord := pointer(Marshal.AllocHGlobal(Marshal.SizeOf&<TRecord>));
    private offset: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      Marshal.FreeHGlobal(new IntPtr(val));
    end;
    
    public constructor(val: TRecord; offset: CommandQueue<integer>);
    begin
      self.   val^ :=    val;
      self.offset  := offset;
    end;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList)->cl_event; override;
    begin
      var offset_qr := offset.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 += offset_qr.ev;
      
      Result := (o, cq, tsk, evs)->
      begin
        var offset := offset_qr.GetRes;
        
        var res: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(offset), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new IntPtr(val),
          evs.count, evs.evs, res
        ).RaiseIfError;
        
        Result := res;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      offset.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteValue}

function BufferCommandQueue.AddWriteValue<TRecord>(val: TRecord; offset: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteValue<TRecord>(val, offset));

function BufferCommandQueue.AddWriteValue<TRecord>(val: CommandQueue<TRecord>): BufferCommandQueue :=
AddWriteValue(val, 0);

{$region WriteValueQ}

type
  BufferCommandWriteValueQ<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private    val: CommandQueue<TRecord>;
    private offset: CommandQueue<integer>;
    
    public constructor(val: CommandQueue<TRecord>; offset: CommandQueue<integer>);
    begin
      self.   val :=    val;
      self.offset := offset;
    end;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList)->cl_event; override;
    begin
      var    val_qr :=    val.Invoke    (tsk, c, main_dvc,  True, cq, nil); evs_l2 +=    val_qr.ev;
      var offset_qr := offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += offset_qr.ev;
      
      Result := (o, cq, tsk, evs)->
      begin
        var    val :=    val_qr.ToPtr;
        var offset := offset_qr.GetRes;
        
        var res: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(offset), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new IntPtr(val.GetPtr),
          evs.count, evs.evs, res
        ).RaiseIfError;
        
        var val_hnd := GCHandle.Alloc(val);
        
        EventList.AttachFinallyCallback(res, ()->
        begin
          val_hnd.Free;
        end, tsk);
        
        Result := res;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
         val.RegisterWaitables(tsk, prev_hubs);
      offset.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteValueQ}

function BufferCommandQueue.AddWriteValue<TRecord>(val: CommandQueue<TRecord>; offset: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteValueQ<TRecord>(val, offset));

function BufferCommandQueue.AddWriteArray1<TRecord>(a: CommandQueue<array of TRecord>): BufferCommandQueue :=
AddWriteArray1(a, 0, 0);

function BufferCommandQueue.AddWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): BufferCommandQueue :=
AddWriteArray2(a, 0,0, 0);

function BufferCommandQueue.AddWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): BufferCommandQueue :=
AddWriteArray3(a, 0,0,0, 0);

{$region WriteArray1AutoSize}

type
  BufferCommandWriteArray1AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array of TRecord>;
    private    a_offset: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    public constructor(a: CommandQueue<array of TRecord>; a_offset, buff_offset: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.   a_offset :=    a_offset;
      self.buff_offset := buff_offset;
    end;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var    a_offset_qr :=    a_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=    a_offset_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      
      Result := (o, cq, tsk, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var    a_offset :=    a_offset_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        
        var res: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[a_offset],
          evs.count, evs.evs, res
        ).RaiseIfError;
        
        Result := res;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
         a_offset.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray1AutoSize}

function BufferCommandQueue.AddWriteArray1<TRecord>(a: CommandQueue<array of TRecord>; a_offset, buff_offset: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray1AutoSize<TRecord>(a, a_offset, buff_offset));

{$region WriteArray2AutoSize}

type
  BufferCommandWriteArray2AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array[,] of TRecord>;
    private   a_offset1: CommandQueue<integer>;
    private   a_offset2: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    public constructor(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2, buff_offset: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.  a_offset1 :=   a_offset1;
      self.  a_offset2 :=   a_offset2;
      self.buff_offset := buff_offset;
    end;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var   a_offset1_qr :=   a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset1_qr.ev;
      var   a_offset2_qr :=   a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset2_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      
      Result := (o, cq, tsk, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var   a_offset1 :=   a_offset1_qr.GetRes;
        var   a_offset2 :=   a_offset2_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        
        var res: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2],
          evs.count, evs.evs, res
        ).RaiseIfError;
        
        Result := res;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
        a_offset1.RegisterWaitables(tsk, prev_hubs);
        a_offset2.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray2AutoSize}

function BufferCommandQueue.AddWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2, buff_offset: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray2AutoSize<TRecord>(a, a_offset1, a_offset2, buff_offset));

{$region WriteArray3AutoSize}

type
  BufferCommandWriteArray3AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array[,,] of TRecord>;
    private   a_offset1: CommandQueue<integer>;
    private   a_offset2: CommandQueue<integer>;
    private   a_offset3: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3, buff_offset: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.  a_offset1 :=   a_offset1;
      self.  a_offset2 :=   a_offset2;
      self.  a_offset3 :=   a_offset3;
      self.buff_offset := buff_offset;
    end;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var   a_offset1_qr :=   a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset1_qr.ev;
      var   a_offset2_qr :=   a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset2_qr.ev;
      var   a_offset3_qr :=   a_offset3.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset3_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      
      Result := (o, cq, tsk, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var   a_offset1 :=   a_offset1_qr.GetRes;
        var   a_offset2 :=   a_offset2_qr.GetRes;
        var   a_offset3 :=   a_offset3_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        
        var res: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2,a_offset3],
          evs.count, evs.evs, res
        ).RaiseIfError;
        
        Result := res;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
        a_offset1.RegisterWaitables(tsk, prev_hubs);
        a_offset2.RegisterWaitables(tsk, prev_hubs);
        a_offset3.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray3AutoSize}

function BufferCommandQueue.AddWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3, buff_offset: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray3AutoSize<TRecord>(a, a_offset1, a_offset2, a_offset3, buff_offset));

{$region WriteArray1}

type
  BufferCommandWriteArray1<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array of TRecord>;
    private    a_offset: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    public constructor(a: CommandQueue<array of TRecord>; a_offset, buff_offset, len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.   a_offset :=    a_offset;
      self.buff_offset := buff_offset;
      self.        len :=         len;
    end;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var    a_offset_qr :=    a_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=    a_offset_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      var         len_qr :=         len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=         len_qr.ev;
      
      Result := (o, cq, tsk, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var    a_offset :=    a_offset_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        var         len :=         len_qr.GetRes;
        
        var res: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(len*Marshal.SizeOf&<TRecord>),
          a[a_offset],
          evs.count, evs.evs, res
        ).RaiseIfError;
        
        Result := res;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
         a_offset.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
              len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray1}

function BufferCommandQueue.AddWriteArray1<TRecord>(a: CommandQueue<array of TRecord>; a_offset, buff_offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray1<TRecord>(a, a_offset, buff_offset, len));

{$region WriteArray2}

type
  BufferCommandWriteArray2<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array[,] of TRecord>;
    private   a_offset1: CommandQueue<integer>;
    private   a_offset2: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    public constructor(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2, buff_offset, len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.  a_offset1 :=   a_offset1;
      self.  a_offset2 :=   a_offset2;
      self.buff_offset := buff_offset;
      self.        len :=         len;
    end;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var   a_offset1_qr :=   a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset1_qr.ev;
      var   a_offset2_qr :=   a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset2_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      var         len_qr :=         len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=         len_qr.ev;
      
      Result := (o, cq, tsk, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var   a_offset1 :=   a_offset1_qr.GetRes;
        var   a_offset2 :=   a_offset2_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        var         len :=         len_qr.GetRes;
        
        var res: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(len*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2],
          evs.count, evs.evs, res
        ).RaiseIfError;
        
        Result := res;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
        a_offset1.RegisterWaitables(tsk, prev_hubs);
        a_offset2.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
              len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray2}

function BufferCommandQueue.AddWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2, buff_offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray2<TRecord>(a, a_offset1, a_offset2, buff_offset, len));

{$region WriteArray3}

type
  BufferCommandWriteArray3<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array[,,] of TRecord>;
    private   a_offset1: CommandQueue<integer>;
    private   a_offset2: CommandQueue<integer>;
    private   a_offset3: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3, buff_offset, len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.  a_offset1 :=   a_offset1;
      self.  a_offset2 :=   a_offset2;
      self.  a_offset3 :=   a_offset3;
      self.buff_offset := buff_offset;
      self.        len :=         len;
    end;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var   a_offset1_qr :=   a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset1_qr.ev;
      var   a_offset2_qr :=   a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset2_qr.ev;
      var   a_offset3_qr :=   a_offset3.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset3_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      var         len_qr :=         len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=         len_qr.ev;
      
      Result := (o, cq, tsk, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var   a_offset1 :=   a_offset1_qr.GetRes;
        var   a_offset2 :=   a_offset2_qr.GetRes;
        var   a_offset3 :=   a_offset3_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        var         len :=         len_qr.GetRes;
        
        var res: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(len*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2,a_offset3],
          evs.count, evs.evs, res
        ).RaiseIfError;
        
        Result := res;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
        a_offset1.RegisterWaitables(tsk, prev_hubs);
        a_offset2.RegisterWaitables(tsk, prev_hubs);
        a_offset3.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
              len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray3}

function BufferCommandQueue.AddWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3, buff_offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray3<TRecord>(a, a_offset1, a_offset2, a_offset3, buff_offset, len));

{$endregion Write}


