


{$region 1#Write&Read}

{$region WriteDataAutoSize}

type
  BufferCommandWriteDataAutoSize = sealed class(EnqueueableGPUCommand<Buffer>)
    private ptr: CommandQueue<IntPtr>;
    
    protected function ParamCountL1: integer; override := 1;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var ptr_qr := ptr.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 += ptr_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var ptr := ptr_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, o.Size,
          ptr,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      ptr.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteDataAutoSize}

function BufferCommandQueue.AddWriteData(ptr: CommandQueue<IntPtr>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteDataAutoSize(ptr));

{$region ReadDataAutoSize}

type
  BufferCommandReadDataAutoSize = sealed class(EnqueueableGPUCommand<Buffer>)
    private ptr: CommandQueue<IntPtr>;
    
    protected function ParamCountL1: integer; override := 1;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var ptr_qr := ptr.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 += ptr_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var ptr := ptr_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, o.Size,
          ptr,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      ptr.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion ReadDataAutoSize}

function BufferCommandQueue.AddReadData(ptr: CommandQueue<IntPtr>): BufferCommandQueue :=
AddCommand(new BufferCommandReadDataAutoSize(ptr));

{$region WriteData}

type
  BufferCommandWriteData = sealed class(EnqueueableGPUCommand<Buffer>)
    private    ptr: CommandQueue<IntPtr>;
    private offset: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    
    protected function ParamCountL1: integer; override := 3;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(ptr: CommandQueue<IntPtr>; offset, len: CommandQueue<integer>);
    begin
      self.   ptr :=    ptr;
      self.offset := offset;
      self.   len :=    len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var    ptr_qr :=    ptr.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=    ptr_qr.ev;
      var offset_qr := offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += offset_qr.ev;
      var    len_qr :=    len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=    len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var    ptr :=    ptr_qr.GetRes;
        var offset := offset_qr.GetRes;
        var    len :=    len_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(offset), new UIntPtr(len),
          ptr,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
         ptr.RegisterWaitables(tsk, prev_hubs);
      offset.RegisterWaitables(tsk, prev_hubs);
         len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteData}

function BufferCommandQueue.AddWriteData(ptr: CommandQueue<IntPtr>; offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteData(ptr, offset, len));

{$region ReadData}

type
  BufferCommandReadData = sealed class(EnqueueableGPUCommand<Buffer>)
    private    ptr: CommandQueue<IntPtr>;
    private offset: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    
    protected function ParamCountL1: integer; override := 3;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(ptr: CommandQueue<IntPtr>; offset, len: CommandQueue<integer>);
    begin
      self.   ptr :=    ptr;
      self.offset := offset;
      self.   len :=    len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var    ptr_qr :=    ptr.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=    ptr_qr.ev;
      var offset_qr := offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += offset_qr.ev;
      var    len_qr :=    len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=    len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var    ptr :=    ptr_qr.GetRes;
        var offset := offset_qr.GetRes;
        var    len :=    len_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(offset), new UIntPtr(len),
          ptr,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
         ptr.RegisterWaitables(tsk, prev_hubs);
      offset.RegisterWaitables(tsk, prev_hubs);
         len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion ReadData}

function BufferCommandQueue.AddReadData(ptr: CommandQueue<IntPtr>; offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandReadData(ptr, offset, len));

function BufferCommandQueue.AddWriteData(ptr: pointer): BufferCommandQueue :=
AddWriteData(IntPtr(ptr));

function BufferCommandQueue.AddReadData(ptr: pointer): BufferCommandQueue :=
AddReadData(IntPtr(ptr));

function BufferCommandQueue.AddWriteData(ptr: pointer; offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddWriteData(IntPtr(ptr), offset, len);

function BufferCommandQueue.AddReadData(ptr: pointer; offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddReadData(IntPtr(ptr), offset, len);

function BufferCommandQueue.AddWriteValue<TRecord>(val: TRecord): BufferCommandQueue :=
AddWriteValue(val, 0);

{$region WriteValue}

type
  BufferCommandWriteValue<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private    val: ^TRecord := pointer(Marshal.AllocHGlobal(Marshal.SizeOf&<TRecord>));
    private offset: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      Marshal.FreeHGlobal(new IntPtr(val));
    end;
    
    protected function ParamCountL1: integer; override := 1;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(val: TRecord; offset: CommandQueue<integer>);
    begin
      self.   val^ :=    val;
      self.offset  := offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var offset_qr := offset.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 += offset_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var offset := offset_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(offset), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new IntPtr(val),
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      offset.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteValue}

function BufferCommandQueue.AddWriteValue<TRecord>(val: TRecord; offset: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteValue<TRecord>(val, offset));

function BufferCommandQueue.AddWriteValue<TRecord>(val: CommandQueue<TRecord>): BufferCommandQueue :=
AddWriteValue(val, 0);

{$region WriteValueQ}

type
  BufferCommandWriteValueQ<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private    val: CommandQueue<TRecord>;
    private offset: CommandQueue<integer>;
    
    protected function ParamCountL1: integer; override := 1;
    protected function ParamCountL2: integer; override := 1;
    
    public constructor(val: CommandQueue<TRecord>; offset: CommandQueue<integer>);
    begin
      self.   val :=    val;
      self.offset := offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var    val_qr :=    val.Invoke    (tsk, c, main_dvc,  True, cq, nil); evs_l2 +=    val_qr.ev;
      var offset_qr := offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += offset_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var    val :=    val_qr.ToPtr;
        var offset := offset_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(offset), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new IntPtr(val.GetPtr),
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        var val_hnd := GCHandle.Alloc(val);
        
        EventList.AttachFinallyCallback(res_ev, ()->
        begin
          val_hnd.Free;
        end, tsk);
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
         val.RegisterWaitables(tsk, prev_hubs);
      offset.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteValueQ}

function BufferCommandQueue.AddWriteValue<TRecord>(val: CommandQueue<TRecord>; offset: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteValueQ<TRecord>(val, offset));

function BufferCommandQueue.AddWriteArray1<TRecord>(a: CommandQueue<array of TRecord>): BufferCommandQueue :=
AddWriteArray1(a, 0);

function BufferCommandQueue.AddWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): BufferCommandQueue :=
AddWriteArray2(a, 0,0);

function BufferCommandQueue.AddWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): BufferCommandQueue :=
AddWriteArray3(a, 0,0,0);

function BufferCommandQueue.AddReadArray1<TRecord>(a: CommandQueue<array of TRecord>): BufferCommandQueue :=
AddReadArray1(a, 0);

function BufferCommandQueue.AddReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): BufferCommandQueue :=
AddReadArray2(a, 0,0);

function BufferCommandQueue.AddReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): BufferCommandQueue :=
AddReadArray3(a, 0,0,0);

{$region WriteArray1AutoSize}

type
  BufferCommandWriteArray1AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private        a: CommandQueue<array of TRecord>;
    private a_offset: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 2;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array of TRecord>; a_offset: CommandQueue<integer>);
    begin
      self.       a :=        a;
      self.a_offset := a_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var        a_qr :=        a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=        a_qr.ev;
      var a_offset_qr := a_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var        a :=        a_qr.GetRes;
        var a_offset := a_offset_qr.GetRes;
        
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[a_offset],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
             a.RegisterWaitables(tsk, prev_hubs);
      a_offset.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray1AutoSize}

function BufferCommandQueue.AddWriteArray1<TRecord>(a: CommandQueue<array of TRecord>; a_offset: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray1AutoSize<TRecord>(a, a_offset));

{$region WriteArray2AutoSize}

type
  BufferCommandWriteArray2AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private         a: CommandQueue<array[,] of TRecord>;
    private a_offset1: CommandQueue<integer>;
    private a_offset2: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 3;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2: CommandQueue<integer>);
    begin
      self.        a :=         a;
      self.a_offset1 := a_offset1;
      self.a_offset2 := a_offset2;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var         a_qr :=         a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=         a_qr.ev;
      var a_offset1_qr := a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset1_qr.ev;
      var a_offset2_qr := a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset2_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var         a :=         a_qr.GetRes;
        var a_offset1 := a_offset1_qr.GetRes;
        var a_offset2 := a_offset2_qr.GetRes;
        
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
              a.RegisterWaitables(tsk, prev_hubs);
      a_offset1.RegisterWaitables(tsk, prev_hubs);
      a_offset2.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray2AutoSize}

function BufferCommandQueue.AddWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray2AutoSize<TRecord>(a, a_offset1, a_offset2));

{$region WriteArray3AutoSize}

type
  BufferCommandWriteArray3AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private         a: CommandQueue<array[,,] of TRecord>;
    private a_offset1: CommandQueue<integer>;
    private a_offset2: CommandQueue<integer>;
    private a_offset3: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 4;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3: CommandQueue<integer>);
    begin
      self.        a :=         a;
      self.a_offset1 := a_offset1;
      self.a_offset2 := a_offset2;
      self.a_offset3 := a_offset3;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var         a_qr :=         a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=         a_qr.ev;
      var a_offset1_qr := a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset1_qr.ev;
      var a_offset2_qr := a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset2_qr.ev;
      var a_offset3_qr := a_offset3.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset3_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var         a :=         a_qr.GetRes;
        var a_offset1 := a_offset1_qr.GetRes;
        var a_offset2 := a_offset2_qr.GetRes;
        var a_offset3 := a_offset3_qr.GetRes;
        
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2,a_offset3],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
              a.RegisterWaitables(tsk, prev_hubs);
      a_offset1.RegisterWaitables(tsk, prev_hubs);
      a_offset2.RegisterWaitables(tsk, prev_hubs);
      a_offset3.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray3AutoSize}

function BufferCommandQueue.AddWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray3AutoSize<TRecord>(a, a_offset1, a_offset2, a_offset3));

{$region ReadArray1AutoSize}

type
  BufferCommandReadArray1AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private        a: CommandQueue<array of TRecord>;
    private a_offset: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 2;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array of TRecord>; a_offset: CommandQueue<integer>);
    begin
      self.       a :=        a;
      self.a_offset := a_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var        a_qr :=        a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=        a_qr.ev;
      var a_offset_qr := a_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var        a :=        a_qr.GetRes;
        var a_offset := a_offset_qr.GetRes;
        
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[a_offset],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
             a.RegisterWaitables(tsk, prev_hubs);
      a_offset.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion ReadArray1AutoSize}

function BufferCommandQueue.AddReadArray1<TRecord>(a: CommandQueue<array of TRecord>; a_offset: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandReadArray1AutoSize<TRecord>(a, a_offset));

{$region ReadArray2AutoSize}

type
  BufferCommandReadArray2AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private         a: CommandQueue<array[,] of TRecord>;
    private a_offset1: CommandQueue<integer>;
    private a_offset2: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 3;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2: CommandQueue<integer>);
    begin
      self.        a :=         a;
      self.a_offset1 := a_offset1;
      self.a_offset2 := a_offset2;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var         a_qr :=         a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=         a_qr.ev;
      var a_offset1_qr := a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset1_qr.ev;
      var a_offset2_qr := a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset2_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var         a :=         a_qr.GetRes;
        var a_offset1 := a_offset1_qr.GetRes;
        var a_offset2 := a_offset2_qr.GetRes;
        
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
              a.RegisterWaitables(tsk, prev_hubs);
      a_offset1.RegisterWaitables(tsk, prev_hubs);
      a_offset2.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion ReadArray2AutoSize}

function BufferCommandQueue.AddReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandReadArray2AutoSize<TRecord>(a, a_offset1, a_offset2));

{$region ReadArray3AutoSize}

type
  BufferCommandReadArray3AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private         a: CommandQueue<array[,,] of TRecord>;
    private a_offset1: CommandQueue<integer>;
    private a_offset2: CommandQueue<integer>;
    private a_offset3: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 4;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3: CommandQueue<integer>);
    begin
      self.        a :=         a;
      self.a_offset1 := a_offset1;
      self.a_offset2 := a_offset2;
      self.a_offset3 := a_offset3;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var         a_qr :=         a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=         a_qr.ev;
      var a_offset1_qr := a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset1_qr.ev;
      var a_offset2_qr := a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset2_qr.ev;
      var a_offset3_qr := a_offset3.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += a_offset3_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var         a :=         a_qr.GetRes;
        var a_offset1 := a_offset1_qr.GetRes;
        var a_offset2 := a_offset2_qr.GetRes;
        var a_offset3 := a_offset3_qr.GetRes;
        
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2,a_offset3],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
              a.RegisterWaitables(tsk, prev_hubs);
      a_offset1.RegisterWaitables(tsk, prev_hubs);
      a_offset2.RegisterWaitables(tsk, prev_hubs);
      a_offset3.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion ReadArray3AutoSize}

function BufferCommandQueue.AddReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandReadArray3AutoSize<TRecord>(a, a_offset1, a_offset2, a_offset3));

{$region WriteArray1}

type
  BufferCommandWriteArray1<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array of TRecord>;
    private    a_offset: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 4;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array of TRecord>; a_offset, buff_offset, len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.   a_offset :=    a_offset;
      self.buff_offset := buff_offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var    a_offset_qr :=    a_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=    a_offset_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      var         len_qr :=         len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=         len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var    a_offset :=    a_offset_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        var         len :=         len_qr.GetRes;
        
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(len*Marshal.SizeOf&<TRecord>),
          a[a_offset],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
         a_offset.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
              len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray1}

function BufferCommandQueue.AddWriteArray1<TRecord>(a: CommandQueue<array of TRecord>; a_offset, buff_offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray1<TRecord>(a, a_offset, buff_offset, len));

{$region WriteArray2}

type
  BufferCommandWriteArray2<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array[,] of TRecord>;
    private   a_offset1: CommandQueue<integer>;
    private   a_offset2: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 5;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2, buff_offset, len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.  a_offset1 :=   a_offset1;
      self.  a_offset2 :=   a_offset2;
      self.buff_offset := buff_offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var   a_offset1_qr :=   a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset1_qr.ev;
      var   a_offset2_qr :=   a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset2_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      var         len_qr :=         len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=         len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var   a_offset1 :=   a_offset1_qr.GetRes;
        var   a_offset2 :=   a_offset2_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        var         len :=         len_qr.GetRes;
        
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(len*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
        a_offset1.RegisterWaitables(tsk, prev_hubs);
        a_offset2.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
              len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray2}

function BufferCommandQueue.AddWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2, buff_offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray2<TRecord>(a, a_offset1, a_offset2, buff_offset, len));

{$region WriteArray3}

type
  BufferCommandWriteArray3<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array[,,] of TRecord>;
    private   a_offset1: CommandQueue<integer>;
    private   a_offset2: CommandQueue<integer>;
    private   a_offset3: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 6;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3, buff_offset, len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.  a_offset1 :=   a_offset1;
      self.  a_offset2 :=   a_offset2;
      self.  a_offset3 :=   a_offset3;
      self.buff_offset := buff_offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var   a_offset1_qr :=   a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset1_qr.ev;
      var   a_offset2_qr :=   a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset2_qr.ev;
      var   a_offset3_qr :=   a_offset3.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset3_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      var         len_qr :=         len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=         len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var   a_offset1 :=   a_offset1_qr.GetRes;
        var   a_offset2 :=   a_offset2_qr.GetRes;
        var   a_offset3 :=   a_offset3_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        var         len :=         len_qr.GetRes;
        
        
        cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(len*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2,a_offset3],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
        a_offset1.RegisterWaitables(tsk, prev_hubs);
        a_offset2.RegisterWaitables(tsk, prev_hubs);
        a_offset3.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
              len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion WriteArray3}

function BufferCommandQueue.AddWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3, buff_offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandWriteArray3<TRecord>(a, a_offset1, a_offset2, a_offset3, buff_offset, len));

{$region ReadArray1}

type
  BufferCommandReadArray1<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array of TRecord>;
    private    a_offset: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 4;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array of TRecord>; a_offset, buff_offset, len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.   a_offset :=    a_offset;
      self.buff_offset := buff_offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var    a_offset_qr :=    a_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=    a_offset_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      var         len_qr :=         len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=         len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var    a_offset :=    a_offset_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        var         len :=         len_qr.GetRes;
        
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(len*Marshal.SizeOf&<TRecord>),
          a[a_offset],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
         a_offset.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
              len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion ReadArray1}

function BufferCommandQueue.AddReadArray1<TRecord>(a: CommandQueue<array of TRecord>; a_offset, buff_offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandReadArray1<TRecord>(a, a_offset, buff_offset, len));

{$region ReadArray2}

type
  BufferCommandReadArray2<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array[,] of TRecord>;
    private   a_offset1: CommandQueue<integer>;
    private   a_offset2: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 5;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2, buff_offset, len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.  a_offset1 :=   a_offset1;
      self.  a_offset2 :=   a_offset2;
      self.buff_offset := buff_offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var   a_offset1_qr :=   a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset1_qr.ev;
      var   a_offset2_qr :=   a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset2_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      var         len_qr :=         len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=         len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var   a_offset1 :=   a_offset1_qr.GetRes;
        var   a_offset2 :=   a_offset2_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        var         len :=         len_qr.GetRes;
        
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(len*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
        a_offset1.RegisterWaitables(tsk, prev_hubs);
        a_offset2.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
              len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion ReadArray2}

function BufferCommandQueue.AddReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_offset1,a_offset2, buff_offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandReadArray2<TRecord>(a, a_offset1, a_offset2, buff_offset, len));

{$region ReadArray3}

type
  BufferCommandReadArray3<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private           a: CommandQueue<array[,,] of TRecord>;
    private   a_offset1: CommandQueue<integer>;
    private   a_offset2: CommandQueue<integer>;
    private   a_offset3: CommandQueue<integer>;
    private buff_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function NeedThread: boolean; override := true;
    
    protected function ParamCountL1: integer; override := 6;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3, buff_offset, len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.  a_offset1 :=   a_offset1;
      self.  a_offset2 :=   a_offset2;
      self.  a_offset3 :=   a_offset3;
      self.buff_offset := buff_offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var           a_qr :=           a.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=           a_qr.ev;
      var   a_offset1_qr :=   a_offset1.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset1_qr.ev;
      var   a_offset2_qr :=   a_offset2.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset2_qr.ev;
      var   a_offset3_qr :=   a_offset3.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   a_offset3_qr.ev;
      var buff_offset_qr := buff_offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += buff_offset_qr.ev;
      var         len_qr :=         len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=         len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var           a :=           a_qr.GetRes;
        var   a_offset1 :=   a_offset1_qr.GetRes;
        var   a_offset2 :=   a_offset2_qr.GetRes;
        var   a_offset3 :=   a_offset3_qr.GetRes;
        var buff_offset := buff_offset_qr.GetRes;
        var         len :=         len_qr.GetRes;
        
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.BLOCKING,
          new UIntPtr(buff_offset), new UIntPtr(len*Marshal.SizeOf&<TRecord>),
          a[a_offset1,a_offset2,a_offset3],
          evs.count, evs.evs, IntPtr.Zero
        ).RaiseIfError;
        
        Result := cl_event.Zero;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
                a.RegisterWaitables(tsk, prev_hubs);
        a_offset1.RegisterWaitables(tsk, prev_hubs);
        a_offset2.RegisterWaitables(tsk, prev_hubs);
        a_offset3.RegisterWaitables(tsk, prev_hubs);
      buff_offset.RegisterWaitables(tsk, prev_hubs);
              len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion ReadArray3}

function BufferCommandQueue.AddReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_offset1,a_offset2,a_offset3, buff_offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandReadArray3<TRecord>(a, a_offset1, a_offset2, a_offset3, buff_offset, len));

{$endregion 1#Write&Read}

{$region 2#Fill}

{$region FillDataAutoSize}

type
  BufferCommandFillDataAutoSize = sealed class(EnqueueableGPUCommand<Buffer>)
    private         ptr: CommandQueue<IntPtr>;
    private pattern_len: CommandQueue<integer>;
    
    protected function ParamCountL1: integer; override := 2;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>);
    begin
      self.        ptr :=         ptr;
      self.pattern_len := pattern_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var         ptr_qr :=         ptr.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=         ptr_qr.ev;
      var pattern_len_qr := pattern_len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += pattern_len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var         ptr :=         ptr_qr.GetRes;
        var pattern_len := pattern_len_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueFillBuffer(
          cq, o.ntv,
          ptr, new UIntPtr(pattern_len),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
              ptr.RegisterWaitables(tsk, prev_hubs);
      pattern_len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion FillDataAutoSize}

function BufferCommandQueue.AddFillData(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandFillDataAutoSize(ptr, pattern_len));

{$region FillData}

type
  BufferCommandFillData = sealed class(EnqueueableGPUCommand<Buffer>)
    private         ptr: CommandQueue<IntPtr>;
    private pattern_len: CommandQueue<integer>;
    private      offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    protected function ParamCountL1: integer; override := 4;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_len, offset, len: CommandQueue<integer>);
    begin
      self.        ptr :=         ptr;
      self.pattern_len := pattern_len;
      self.     offset :=      offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var         ptr_qr :=         ptr.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=         ptr_qr.ev;
      var pattern_len_qr := pattern_len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += pattern_len_qr.ev;
      var      offset_qr :=      offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=      offset_qr.ev;
      var         len_qr :=         len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=         len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var         ptr :=         ptr_qr.GetRes;
        var pattern_len := pattern_len_qr.GetRes;
        var      offset :=      offset_qr.GetRes;
        var         len :=         len_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueFillBuffer(
          cq, o.ntv,
          ptr, new UIntPtr(pattern_len),
          new UIntPtr(offset), new UIntPtr(len),
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
              ptr.RegisterWaitables(tsk, prev_hubs);
      pattern_len.RegisterWaitables(tsk, prev_hubs);
           offset.RegisterWaitables(tsk, prev_hubs);
              len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion FillData}

function BufferCommandQueue.AddFillData(ptr: CommandQueue<IntPtr>; pattern_len, offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandFillData(ptr, pattern_len, offset, len));

{$region FillValueAutoSize}

type
  BufferCommandFillValueAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private val: ^TRecord := pointer(Marshal.AllocHGlobal(Marshal.SizeOf&<TRecord>));
    
    protected procedure Finalize; override;
    begin
      Marshal.FreeHGlobal(new IntPtr(val));
    end;
    
    protected function ParamCountL1: integer; override := 0;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(val: TRecord);
    begin
      self.val^ := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      
      Result := (o, cq, tsk, c, evs)->
      begin
        
        var res_ev: cl_event;
        
        cl.EnqueueFillBuffer(
          cq, o.ntv,
          new IntPtr(val), new UIntPtr(Marshal.SizeOf&<TRecord>),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
    end;
    
  end;
  
{$endregion FillValueAutoSize}

function BufferCommandQueue.AddFillValue<TRecord>(val: TRecord): BufferCommandQueue :=
AddCommand(new BufferCommandFillValueAutoSize<TRecord>(val));

{$region FillValue}

type
  BufferCommandFillValue<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private    val: ^TRecord := pointer(Marshal.AllocHGlobal(Marshal.SizeOf&<TRecord>));
    private offset: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      Marshal.FreeHGlobal(new IntPtr(val));
    end;
    
    protected function ParamCountL1: integer; override := 2;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(val: TRecord; offset, len: CommandQueue<integer>);
    begin
      self.   val^ :=    val;
      self.offset  := offset;
      self.   len  :=    len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var offset_qr := offset.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 += offset_qr.ev;
      var    len_qr :=    len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=    len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var offset := offset_qr.GetRes;
        var    len :=    len_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueFillBuffer(
          cq, o.ntv,
          new IntPtr(val), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new UIntPtr(offset), new UIntPtr(len),
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      offset.RegisterWaitables(tsk, prev_hubs);
         len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion FillValue}

function BufferCommandQueue.AddFillValue<TRecord>(val: TRecord; offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandFillValue<TRecord>(val, offset, len));

{$region FillValueAutoSizeQ}

type
  BufferCommandFillValueAutoSizeQ<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private val: CommandQueue<TRecord>;
    
    protected function ParamCountL1: integer; override := 0;
    protected function ParamCountL2: integer; override := 1;
    
    public constructor(val: CommandQueue<TRecord>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var val_qr := val.Invoke    (tsk, c, main_dvc,  True, cq, nil); evs_l2 += val_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var val := val_qr.ToPtr;
        
        var res_ev: cl_event;
        
        cl.EnqueueFillBuffer(
          cq, o.ntv,
          new IntPtr(val.GetPtr), new UIntPtr(Marshal.SizeOf&<TRecord>),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        
        
        var val_hnd := GCHandle.Alloc(val);
        
        EventList.AttachFinallyCallback(res_ev, ()->
        begin
          val_hnd.Free;
        end, tsk);
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      val.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion FillValueAutoSizeQ}

function BufferCommandQueue.AddFillValue<TRecord>(val: CommandQueue<TRecord>): BufferCommandQueue :=
AddCommand(new BufferCommandFillValueAutoSizeQ<TRecord>(val));

{$region FillValueQ}

type
  BufferCommandFillValueQ<TRecord> = sealed class(EnqueueableGPUCommand<Buffer>)
  where TRecord: record;
    private    val: CommandQueue<TRecord>;
    private offset: CommandQueue<integer>;
    private    len: CommandQueue<integer>;
    
    protected function ParamCountL1: integer; override := 2;
    protected function ParamCountL2: integer; override := 1;
    
    public constructor(val: CommandQueue<TRecord>; offset, len: CommandQueue<integer>);
    begin
      self.   val :=    val;
      self.offset := offset;
      self.   len :=    len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var    val_qr :=    val.Invoke    (tsk, c, main_dvc,  True, cq, nil); evs_l2 +=    val_qr.ev;
      var offset_qr := offset.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += offset_qr.ev;
      var    len_qr :=    len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=    len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var    val :=    val_qr.ToPtr;
        var offset := offset_qr.GetRes;
        var    len :=    len_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueFillBuffer(
          cq, o.ntv,
          new IntPtr(val.GetPtr), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new UIntPtr(offset), new UIntPtr(len),
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        
        
        var val_hnd := GCHandle.Alloc(val);
        
        EventList.AttachFinallyCallback(res_ev, ()->
        begin
          val_hnd.Free;
        end, tsk);
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
         val.RegisterWaitables(tsk, prev_hubs);
      offset.RegisterWaitables(tsk, prev_hubs);
         len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion FillValueQ}

function BufferCommandQueue.AddFillValue<TRecord>(val: CommandQueue<TRecord>; offset, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandFillValueQ<TRecord>(val, offset, len));

{$endregion 2#Fill}

{$region 3#Copy}

{$region CopyToAutoSize}

type
  BufferCommandCopyToAutoSize = sealed class(EnqueueableGPUCommand<Buffer>)
    private b: CommandQueue<Buffer>;
    
    protected function ParamCountL1: integer; override := 1;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(b: CommandQueue<Buffer>);
    begin
      self.b := b;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var b_qr := b.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 += b_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var b := b_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueCopyBuffer(
          cq, o.ntv,b.ntv,
          UIntPtr.Zero, UIntPtr.Zero,
          o.Size64<b.Size64 ? o.Size : b.Size,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      b.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion CopyToAutoSize}

function BufferCommandQueue.AddCopyTo(b: CommandQueue<Buffer>): BufferCommandQueue :=
AddCommand(new BufferCommandCopyToAutoSize(b));

{$region CopyFormAutoSize}

type
  BufferCommandCopyFormAutoSize = sealed class(EnqueueableGPUCommand<Buffer>)
    private b: CommandQueue<Buffer>;
    
    protected function ParamCountL1: integer; override := 1;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(b: CommandQueue<Buffer>);
    begin
      self.b := b;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var b_qr := b.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 += b_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var b := b_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueCopyBuffer(
          cq, b.ntv,o.ntv,
          UIntPtr.Zero, UIntPtr.Zero,
          o.Size64<b.Size64 ? o.Size : b.Size,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
      b.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion CopyFormAutoSize}

function BufferCommandQueue.AddCopyForm(b: CommandQueue<Buffer>): BufferCommandQueue :=
AddCommand(new BufferCommandCopyFormAutoSize(b));

{$region CopyTo}

type
  BufferCommandCopyTo = sealed class(EnqueueableGPUCommand<Buffer>)
    private        b: CommandQueue<Buffer>;
    private from_pos: CommandQueue<integer>;
    private   to_pos: CommandQueue<integer>;
    private      len: CommandQueue<integer>;
    
    protected function ParamCountL1: integer; override := 4;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(b: CommandQueue<Buffer>; from_pos, to_pos, len: CommandQueue<integer>);
    begin
      self.       b :=        b;
      self.from_pos := from_pos;
      self.  to_pos :=   to_pos;
      self.     len :=      len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var        b_qr :=        b.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=        b_qr.ev;
      var from_pos_qr := from_pos.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += from_pos_qr.ev;
      var   to_pos_qr :=   to_pos.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   to_pos_qr.ev;
      var      len_qr :=      len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=      len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var        b :=        b_qr.GetRes;
        var from_pos := from_pos_qr.GetRes;
        var   to_pos :=   to_pos_qr.GetRes;
        var      len :=      len_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueCopyBuffer(
          cq, o.ntv,b.ntv,
          new UIntPtr(from_pos), new UIntPtr(to_pos),
          new UIntPtr(len),
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
             b.RegisterWaitables(tsk, prev_hubs);
      from_pos.RegisterWaitables(tsk, prev_hubs);
        to_pos.RegisterWaitables(tsk, prev_hubs);
           len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion CopyTo}

function BufferCommandQueue.AddCopyTo(b: CommandQueue<Buffer>; from_pos, to_pos, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandCopyTo(b, from_pos, to_pos, len));

{$region CopyForm}

type
  BufferCommandCopyForm = sealed class(EnqueueableGPUCommand<Buffer>)
    private        b: CommandQueue<Buffer>;
    private from_pos: CommandQueue<integer>;
    private   to_pos: CommandQueue<integer>;
    private      len: CommandQueue<integer>;
    
    protected function ParamCountL1: integer; override := 4;
    protected function ParamCountL2: integer; override := 0;
    
    public constructor(b: CommandQueue<Buffer>; from_pos, to_pos, len: CommandQueue<integer>);
    begin
      self.       b :=        b;
      self.from_pos := from_pos;
      self.  to_pos :=   to_pos;
      self.     len :=      len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParams(tsk: CLTaskBase; c: Context; main_dvc: cl_device_id; var cq: cl_command_queue; evs_l1, evs_l2: List<EventList>): (Buffer, cl_command_queue, CLTaskBase, Context, EventList)->cl_event; override;
    begin
      var        b_qr :=        b.Invoke    (tsk, c, main_dvc, False, cq, nil); evs_l1 +=        b_qr.ev;
      var from_pos_qr := from_pos.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 += from_pos_qr.ev;
      var   to_pos_qr :=   to_pos.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=   to_pos_qr.ev;
      var      len_qr :=      len.InvokeNewQ(tsk, c, main_dvc, False,     nil); evs_l1 +=      len_qr.ev;
      
      Result := (o, cq, tsk, c, evs)->
      begin
        var        b :=        b_qr.GetRes;
        var from_pos := from_pos_qr.GetRes;
        var   to_pos :=   to_pos_qr.GetRes;
        var      len :=      len_qr.GetRes;
        
        var res_ev: cl_event;
        
        cl.EnqueueCopyBuffer(
          cq, b.ntv,o.ntv,
          new UIntPtr(from_pos), new UIntPtr(to_pos),
          new UIntPtr(len),
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(tsk: CLTaskBase; prev_hubs: HashSet<MultiusableCommandQueueHubBase>); override;
    begin
             b.RegisterWaitables(tsk, prev_hubs);
      from_pos.RegisterWaitables(tsk, prev_hubs);
        to_pos.RegisterWaitables(tsk, prev_hubs);
           len.RegisterWaitables(tsk, prev_hubs);
    end;
    
  end;
  
{$endregion CopyForm}

function BufferCommandQueue.AddCopyForm(b: CommandQueue<Buffer>; from_pos, to_pos, len: CommandQueue<integer>): BufferCommandQueue :=
AddCommand(new BufferCommandCopyForm(b, from_pos, to_pos, len));

{$endregion 3#Copy}


