


{$region 1#Write&Read}

{$region WriteValue}

function CLMemorySegmentCCQ.ThenWriteValue<TRecord>(val: TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteValue(val, 0);
end;

{$endregion WriteValue}

{$region WriteValue!Q}

function CLMemorySegmentCCQ.ThenWriteValue<TRecord>(val: CommandQueue<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteValue(val, 0);
end;

{$endregion WriteValue!Q}

{$region WriteValue}

type
  CLMemorySegmentCommandWriteValue<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private        val: ^TRecord := pointer(Marshal.AllocHGlobal(Marshal.SizeOf&<TRecord>));
    private mem_offset: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      Marshal.FreeHGlobal(new IntPtr(val));
    end;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteValue%');
    end;
    public constructor(val: TRecord; mem_offset: CommandQueue<integer>);
    begin
      self.       val^ :=        val;
      self.mem_offset  := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new IntPtr(val),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val^);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteValue<TRecord>(val: TRecord; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteValue<TRecord>(val, mem_offset));
end;

{$endregion WriteValue}

{$region WriteValue!Q}

type
  CLMemorySegmentCommandWriteValueQ<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private        val: CommandQueue<TRecord>;
    private mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteValueQ%');
    end;
    public constructor(val: CommandQueue<TRecord>; mem_offset: CommandQueue<integer>);
    begin
      self.       val :=        val;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             val.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var        val_qr: QueueResPtr<TRecord>;
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               val_qr := invoker.InvokeBranch&<QueueResPtr<TRecord>>(       val.InvokeToPtr); enq_evs.AddL2(val_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        val :=        val_qr.res;
        var mem_offset := mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new IntPtr(val),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteValue<TRecord>(val: CommandQueue<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteValueQ<TRecord>(val, mem_offset));
end;

{$endregion WriteValue!Q}

{$region WriteArray1!AutoSize}

function CLMemorySegmentCCQ.ThenWriteArray1<TRecord>(a: array of TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteArray1(CQ(a));
end;

{$endregion WriteArray1!AutoSize}

{$region WriteArray2!AutoSize}

function CLMemorySegmentCCQ.ThenWriteArray2<TRecord>(a: array[,] of TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteArray2(CQ(a));
end;

{$endregion WriteArray2!AutoSize}

{$region WriteArray3!AutoSize}

function CLMemorySegmentCCQ.ThenWriteArray3<TRecord>(a: array[,,] of TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteArray3(CQ(a));
end;

{$endregion WriteArray3!AutoSize}

{$region ReadArray1!AutoSize}

function CLMemorySegmentCCQ.ThenReadArray1<TRecord>(a: array of TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadArray1(CQ(a));
end;

{$endregion ReadArray1!AutoSize}

{$region ReadArray2!AutoSize}

function CLMemorySegmentCCQ.ThenReadArray2<TRecord>(a: array[,] of TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadArray2(CQ(a));
end;

{$endregion ReadArray2!AutoSize}

{$region ReadArray3!AutoSize}

function CLMemorySegmentCCQ.ThenReadArray3<TRecord>(a: array[,,] of TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadArray3(CQ(a));
end;

{$endregion ReadArray3!AutoSize}

{$region WriteArray1}

function CLMemorySegmentCCQ.ThenWriteArray1<TRecord>(a: array of TRecord; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteArray1(CQ(a), a_ind, el_count, mem_offset);
end;

{$endregion WriteArray1}

{$region WriteArray2}

function CLMemorySegmentCCQ.ThenWriteArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteArray2(CQ(a), a_ind1,a_ind2, el_count, mem_offset);
end;

{$endregion WriteArray2}

{$region WriteArray3}

function CLMemorySegmentCCQ.ThenWriteArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteArray3(CQ(a), a_ind1,a_ind2,a_ind3, el_count, mem_offset);
end;

{$endregion WriteArray3}

{$region ReadArray1}

function CLMemorySegmentCCQ.ThenReadArray1<TRecord>(a: array of TRecord; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadArray1(CQ(a), a_ind, el_count, mem_offset);
end;

{$endregion ReadArray1}

{$region ReadArray2}

function CLMemorySegmentCCQ.ThenReadArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadArray2(CQ(a), a_ind1,a_ind2, el_count, mem_offset);
end;

{$endregion ReadArray2}

{$region ReadArray3}

function CLMemorySegmentCCQ.ThenReadArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadArray3(CQ(a), a_ind1,a_ind2,a_ind3, el_count, mem_offset);
end;

{$endregion ReadArray3}

{$region WriteArray1!AutoSize}

type
  CLMemorySegmentCommandWriteArray1AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private a: CommandQueue<array of TRecord>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteArray1AutoSize%');
    end;
    public constructor(a: CommandQueue<array of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var a_qr: QueueRes<array of TRecord>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array of TRecord>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteArray1AutoSize<TRecord>(a));
end;

{$endregion WriteArray1!AutoSize}

{$region WriteArray2!AutoSize}

type
  CLMemorySegmentCommandWriteArray2AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private a: CommandQueue<array[,] of TRecord>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteArray2AutoSize%');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var a_qr: QueueRes<array[,] of TRecord>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,] of TRecord>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteArray2AutoSize<TRecord>(a));
end;

{$endregion WriteArray2!AutoSize}

{$region WriteArray3!AutoSize}

type
  CLMemorySegmentCommandWriteArray3AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private a: CommandQueue<array[,,] of TRecord>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteArray3AutoSize%');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var a_qr: QueueRes<array[,,] of TRecord>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of TRecord>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteArray3AutoSize<TRecord>(a));
end;

{$endregion WriteArray3!AutoSize}

{$region ReadArray1!AutoSize}

type
  CLMemorySegmentCommandReadArray1AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private a: CommandQueue<array of TRecord>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:ReadArray1AutoSize%');
    end;
    public constructor(a: CommandQueue<array of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var a_qr: QueueRes<array of TRecord>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array of TRecord>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadArray1AutoSize<TRecord>(a));
end;

{$endregion ReadArray1!AutoSize}

{$region ReadArray2!AutoSize}

type
  CLMemorySegmentCommandReadArray2AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private a: CommandQueue<array[,] of TRecord>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:ReadArray2AutoSize%');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var a_qr: QueueRes<array[,] of TRecord>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,] of TRecord>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadArray2AutoSize<TRecord>(a));
end;

{$endregion ReadArray2!AutoSize}

{$region ReadArray3!AutoSize}

type
  CLMemorySegmentCommandReadArray3AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private a: CommandQueue<array[,,] of TRecord>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:ReadArray3AutoSize%');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var a_qr: QueueRes<array[,,] of TRecord>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of TRecord>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because {-rank-} block would be nested in {-AutoSize-}
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          a[0,0,0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadArray3AutoSize<TRecord>(a));
end;

{$endregion ReadArray3!AutoSize}

{$region WriteArray1}

type
  CLMemorySegmentCommandWriteArray1<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private          a: CommandQueue<array of TRecord>;
    private      a_ind: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteArray1%');
    end;
    public constructor(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.     a_ind :=      a_ind;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
           a_ind.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var          a_qr: QueueRes<array of TRecord>;
      var      a_ind_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                 a_qr := invoker.InvokeBranch&<QueueRes<array of TRecord>>(         a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
             a_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(     a_ind.InvokeToAny); if a_ind_qr.IsConst then enq_evs.AddL2(a_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind_qr.AttachInvokeActions(g));
          el_count_qr := invoker.InvokeBranch&<QueueRes<integer>>(  el_count.InvokeToAny); if el_count_qr.IsConst then enq_evs.AddL2(el_count_qr.AttachInvokeActions(g)) else enq_evs.AddL1(el_count_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var      a_ind :=      a_ind_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf&<TRecord>),
          a[a_ind],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteArray1<TRecord>(a, a_ind, el_count, mem_offset));
end;

{$endregion WriteArray1}

{$region WriteArray2}

type
  CLMemorySegmentCommandWriteArray2<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private          a: CommandQueue<array[,] of TRecord>;
    private     a_ind1: CommandQueue<integer>;
    private     a_ind2: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 5;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteArray2%');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.    a_ind1 :=     a_ind1;
      self.    a_ind2 :=     a_ind2;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
          a_ind1.InitBeforeInvoke(g, prev_hubs);
          a_ind2.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var          a_qr: QueueRes<array[,] of TRecord>;
      var     a_ind1_qr: QueueRes<integer>;
      var     a_ind2_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                 a_qr := invoker.InvokeBranch&<QueueRes<array[,] of TRecord>>(         a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
            a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(    a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
            a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(    a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
          el_count_qr := invoker.InvokeBranch&<QueueRes<integer>>(  el_count.InvokeToAny); if el_count_qr.IsConst then enq_evs.AddL2(el_count_qr.AttachInvokeActions(g)) else enq_evs.AddL1(el_count_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var     a_ind1 :=     a_ind1_qr.GetResDirect;
        var     a_ind2 :=     a_ind2_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf&<TRecord>),
          a[a_ind1,a_ind2],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteArray2<TRecord>(a, a_ind1, a_ind2, el_count, mem_offset));
end;

{$endregion WriteArray2}

{$region WriteArray3}

type
  CLMemorySegmentCommandWriteArray3<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private          a: CommandQueue<array[,,] of TRecord>;
    private     a_ind1: CommandQueue<integer>;
    private     a_ind2: CommandQueue<integer>;
    private     a_ind3: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 6;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteArray3%');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.    a_ind1 :=     a_ind1;
      self.    a_ind2 :=     a_ind2;
      self.    a_ind3 :=     a_ind3;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
          a_ind1.InitBeforeInvoke(g, prev_hubs);
          a_ind2.InitBeforeInvoke(g, prev_hubs);
          a_ind3.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var          a_qr: QueueRes<array[,,] of TRecord>;
      var     a_ind1_qr: QueueRes<integer>;
      var     a_ind2_qr: QueueRes<integer>;
      var     a_ind3_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                 a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of TRecord>>(         a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
            a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(    a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
            a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(    a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
            a_ind3_qr := invoker.InvokeBranch&<QueueRes<integer>>(    a_ind3.InvokeToAny); if a_ind3_qr.IsConst then enq_evs.AddL2(a_ind3_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind3_qr.AttachInvokeActions(g));
          el_count_qr := invoker.InvokeBranch&<QueueRes<integer>>(  el_count.InvokeToAny); if el_count_qr.IsConst then enq_evs.AddL2(el_count_qr.AttachInvokeActions(g)) else enq_evs.AddL1(el_count_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var     a_ind1 :=     a_ind1_qr.GetResDirect;
        var     a_ind2 :=     a_ind2_qr.GetResDirect;
        var     a_ind3 :=     a_ind3_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf&<TRecord>),
          a[a_ind1,a_ind2,a_ind3],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteArray3<TRecord>(a, a_ind1, a_ind2, a_ind3, el_count, mem_offset));
end;

{$endregion WriteArray3}

{$region ReadArray1}

type
  CLMemorySegmentCommandReadArray1<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private          a: CommandQueue<array of TRecord>;
    private      a_ind: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:ReadArray1%');
    end;
    public constructor(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.     a_ind :=      a_ind;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
           a_ind.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var          a_qr: QueueRes<array of TRecord>;
      var      a_ind_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                 a_qr := invoker.InvokeBranch&<QueueRes<array of TRecord>>(         a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
             a_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(     a_ind.InvokeToAny); if a_ind_qr.IsConst then enq_evs.AddL2(a_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind_qr.AttachInvokeActions(g));
          el_count_qr := invoker.InvokeBranch&<QueueRes<integer>>(  el_count.InvokeToAny); if el_count_qr.IsConst then enq_evs.AddL2(el_count_qr.AttachInvokeActions(g)) else enq_evs.AddL1(el_count_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var      a_ind :=      a_ind_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf&<TRecord>),
          a[a_ind],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadArray1<TRecord>(a, a_ind, el_count, mem_offset));
end;

{$endregion ReadArray1}

{$region ReadArray2}

type
  CLMemorySegmentCommandReadArray2<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private          a: CommandQueue<array[,] of TRecord>;
    private     a_ind1: CommandQueue<integer>;
    private     a_ind2: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 5;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:ReadArray2%');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.    a_ind1 :=     a_ind1;
      self.    a_ind2 :=     a_ind2;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
          a_ind1.InitBeforeInvoke(g, prev_hubs);
          a_ind2.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var          a_qr: QueueRes<array[,] of TRecord>;
      var     a_ind1_qr: QueueRes<integer>;
      var     a_ind2_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                 a_qr := invoker.InvokeBranch&<QueueRes<array[,] of TRecord>>(         a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
            a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(    a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
            a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(    a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
          el_count_qr := invoker.InvokeBranch&<QueueRes<integer>>(  el_count.InvokeToAny); if el_count_qr.IsConst then enq_evs.AddL2(el_count_qr.AttachInvokeActions(g)) else enq_evs.AddL1(el_count_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var     a_ind1 :=     a_ind1_qr.GetResDirect;
        var     a_ind2 :=     a_ind2_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf&<TRecord>),
          a[a_ind1,a_ind2],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadArray2<TRecord>(a, a_ind1, a_ind2, el_count, mem_offset));
end;

{$endregion ReadArray2}

{$region ReadArray3}

type
  CLMemorySegmentCommandReadArray3<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private          a: CommandQueue<array[,,] of TRecord>;
    private     a_ind1: CommandQueue<integer>;
    private     a_ind2: CommandQueue<integer>;
    private     a_ind3: CommandQueue<integer>;
    private   el_count: CommandQueue<integer>;
    private mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 6;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:ReadArray3%');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>);
    begin
      self.         a :=          a;
      self.    a_ind1 :=     a_ind1;
      self.    a_ind2 :=     a_ind2;
      self.    a_ind3 :=     a_ind3;
      self.  el_count :=   el_count;
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
               a.InitBeforeInvoke(g, prev_hubs);
          a_ind1.InitBeforeInvoke(g, prev_hubs);
          a_ind2.InitBeforeInvoke(g, prev_hubs);
          a_ind3.InitBeforeInvoke(g, prev_hubs);
        el_count.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var          a_qr: QueueRes<array[,,] of TRecord>;
      var     a_ind1_qr: QueueRes<integer>;
      var     a_ind2_qr: QueueRes<integer>;
      var     a_ind3_qr: QueueRes<integer>;
      var   el_count_qr: QueueRes<integer>;
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                 a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of TRecord>>(         a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
            a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(    a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
            a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(    a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
            a_ind3_qr := invoker.InvokeBranch&<QueueRes<integer>>(    a_ind3.InvokeToAny); if a_ind3_qr.IsConst then enq_evs.AddL2(a_ind3_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind3_qr.AttachInvokeActions(g));
          el_count_qr := invoker.InvokeBranch&<QueueRes<integer>>(  el_count.InvokeToAny); if el_count_qr.IsConst then enq_evs.AddL2(el_count_qr.AttachInvokeActions(g)) else enq_evs.AddL1(el_count_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var          a :=          a_qr.GetResDirect;
        var     a_ind1 :=     a_ind1_qr.GetResDirect;
        var     a_ind2 :=     a_ind2_qr.GetResDirect;
        var     a_ind3 :=     a_ind3_qr.GetResDirect;
        var   el_count :=   el_count_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(el_count*Marshal.SizeOf&<TRecord>),
          a[a_ind1,a_ind2,a_ind3],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'el_count:';
      sb += ' ';
      el_count.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, el_count, mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadArray3<TRecord>(a, a_ind1, a_ind2, a_ind3, el_count, mem_offset));
end;

{$endregion ReadArray3}

{$region WriteArraySegment}

function CLMemorySegmentCCQ.ThenWriteArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteArray1(CQ(a.Array), a.Offset, a.Count, mem_offset);
end;

{$endregion WriteArraySegment}

{$region ReadArraySegment}

function CLMemorySegmentCCQ.ThenReadArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadArray1(CQ(a.Array), a.Offset, a.Count, mem_offset);
end;

{$endregion ReadArraySegment}

{$region WriteData!AutoSize}

type
  CLMemorySegmentCommandWriteDataAutoSize = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private ptr: CommandQueue<IntPtr>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, o.Size,
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteData(ptr: CommandQueue<IntPtr>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteDataAutoSize(ptr));
end;

{$endregion WriteData!AutoSize}

{$region WriteData}

type
  CLMemorySegmentCommandWriteData = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private        ptr: CommandQueue<IntPtr>;
    private mem_offset: CommandQueue<integer>;
    private        len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>);
    begin
      self.       ptr :=        ptr;
      self.mem_offset := mem_offset;
      self.       len :=        len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             ptr.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
             len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var        ptr_qr: QueueRes<IntPtr>;
      var mem_offset_qr: QueueRes<integer>;
      var        len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(       ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
               len_qr := invoker.InvokeBranch&<QueueRes<integer>>(       len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        ptr :=        ptr_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var        len :=        len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(len),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteData(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteData(ptr, mem_offset, len));
end;

{$endregion WriteData}

{$region ReadData!AutoSize}

type
  CLMemorySegmentCommandReadDataAutoSize = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private ptr: CommandQueue<IntPtr>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, o.Size,
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadData(ptr: CommandQueue<IntPtr>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadDataAutoSize(ptr));
end;

{$endregion ReadData!AutoSize}

{$region ReadData}

type
  CLMemorySegmentCommandReadData = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private        ptr: CommandQueue<IntPtr>;
    private mem_offset: CommandQueue<integer>;
    private        len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>);
    begin
      self.       ptr :=        ptr;
      self.mem_offset := mem_offset;
      self.       len :=        len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             ptr.InitBeforeInvoke(g, prev_hubs);
      mem_offset.InitBeforeInvoke(g, prev_hubs);
             len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var        ptr_qr: QueueRes<IntPtr>;
      var mem_offset_qr: QueueRes<integer>;
      var        len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(       ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
               len_qr := invoker.InvokeBranch&<QueueRes<integer>>(       len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        ptr :=        ptr_qr.GetResDirect;
        var mem_offset := mem_offset_qr.GetResDirect;
        var        len :=        len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(len),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadData(ptr: CommandQueue<IntPtr>; mem_offset, len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadData(ptr, mem_offset, len));
end;

{$endregion ReadData}

{$region WriteData!AutoSize}

function CLMemorySegmentCCQ.ThenWriteData(ptr: pointer): CLMemorySegmentCCQ;
begin
  Result := ThenWriteData(IntPtr(ptr));
end;

{$endregion WriteData!AutoSize}

{$region WriteData}

function CLMemorySegmentCCQ.ThenWriteData(ptr: pointer; mem_offset, len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := ThenWriteData(IntPtr(ptr), mem_offset, len);
end;

{$endregion WriteData}

{$region ReadData!AutoSize}

function CLMemorySegmentCCQ.ThenReadData(ptr: pointer): CLMemorySegmentCCQ;
begin
  Result := ThenReadData(IntPtr(ptr));
end;

{$endregion ReadData!AutoSize}

{$region ReadData}

function CLMemorySegmentCCQ.ThenReadData(ptr: pointer; mem_offset, len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := ThenReadData(IntPtr(ptr), mem_offset, len);
end;

{$endregion ReadData}

{$region WriteNativeMemoryArea!AutoOffset}

function CLMemorySegmentCCQ.ThenWriteNativeMemoryArea(native_data: NativeMemoryArea): CLMemorySegmentCCQ;
begin
  Result := ThenWriteNativeMemoryArea(CQ(native_data), 0);
end;

{$endregion WriteNativeMemoryArea!AutoOffset}

{$region WriteNativeMemoryArea}

function CLMemorySegmentCCQ.ThenWriteNativeMemoryArea(native_data: NativeMemoryArea; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := ThenWriteNativeMemoryArea(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeMemoryArea}

{$region WriteNativeMemory!AutoOffset}

function CLMemorySegmentCCQ.ThenWriteNativeMemory(native_data: NativeMemory): CLMemorySegmentCCQ;
begin
  Result := ThenWriteNativeMemory(CQ(native_data), 0);
end;

{$endregion WriteNativeMemory!AutoOffset}

{$region WriteNativeMemory}

function CLMemorySegmentCCQ.ThenWriteNativeMemory(native_data: NativeMemory; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := ThenWriteNativeMemory(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeMemory}

{$region WriteNativeValueArea!AutoOffset}

function CLMemorySegmentCCQ.ThenWriteNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValueArea(CQ(native_data), 0);
end;

{$endregion WriteNativeValueArea!AutoOffset}

{$region WriteNativeValueArea}

function CLMemorySegmentCCQ.ThenWriteNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValueArea(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue!AutoOffset}

function CLMemorySegmentCCQ.ThenWriteNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValue(CQ(native_data), 0);
end;

{$endregion WriteNativeValue!AutoOffset}

{$region WriteNativeValue}

function CLMemorySegmentCCQ.ThenWriteNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValue(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeValue}

{$region WriteNativeArrayArea!AutoOffset}

function CLMemorySegmentCCQ.ThenWriteNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArrayArea(CQ(native_data), 0);
end;

{$endregion WriteNativeArrayArea!AutoOffset}

{$region WriteNativeArrayArea}

function CLMemorySegmentCCQ.ThenWriteNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArrayArea(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeArrayArea}

{$region WriteNativeArray!AutoOffset}

function CLMemorySegmentCCQ.ThenWriteNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArray(CQ(native_data), 0);
end;

{$endregion WriteNativeArray!AutoOffset}

{$region WriteNativeArray}

function CLMemorySegmentCCQ.ThenWriteNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArray(CQ(native_data), mem_offset);
end;

{$endregion WriteNativeArray}

{$region ReadNativeMemoryArea!AutoOffset}

function CLMemorySegmentCCQ.ThenReadNativeMemoryArea(native_data: NativeMemoryArea): CLMemorySegmentCCQ;
begin
  Result := ThenReadNativeMemoryArea(CQ(native_data), 0);
end;

{$endregion ReadNativeMemoryArea!AutoOffset}

{$region ReadNativeMemoryArea}

function CLMemorySegmentCCQ.ThenReadNativeMemoryArea(native_data: NativeMemoryArea; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := ThenReadNativeMemoryArea(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeMemoryArea}

{$region ReadNativeMemory!AutoOffset}

function CLMemorySegmentCCQ.ThenReadNativeMemory(native_data: NativeMemory): CLMemorySegmentCCQ;
begin
  Result := ThenReadNativeMemory(CQ(native_data), 0);
end;

{$endregion ReadNativeMemory!AutoOffset}

{$region ReadNativeMemory}

function CLMemorySegmentCCQ.ThenReadNativeMemory(native_data: NativeMemory; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := ThenReadNativeMemory(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeMemory}

{$region ReadNativeValueArea!AutoOffset}

function CLMemorySegmentCCQ.ThenReadNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValueArea(CQ(native_data), 0);
end;

{$endregion ReadNativeValueArea!AutoOffset}

{$region ReadNativeValueArea}

function CLMemorySegmentCCQ.ThenReadNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValueArea(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue!AutoOffset}

function CLMemorySegmentCCQ.ThenReadNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValue(CQ(native_data), 0);
end;

{$endregion ReadNativeValue!AutoOffset}

{$region ReadNativeValue}

function CLMemorySegmentCCQ.ThenReadNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValue(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeValue}

{$region ReadNativeArrayArea!AutoOffset}

function CLMemorySegmentCCQ.ThenReadNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArrayArea(CQ(native_data), 0);
end;

{$endregion ReadNativeArrayArea!AutoOffset}

{$region ReadNativeArrayArea}

function CLMemorySegmentCCQ.ThenReadNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArrayArea(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeArrayArea}

{$region ReadNativeArray!AutoOffset}

function CLMemorySegmentCCQ.ThenReadNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArray(CQ(native_data), 0);
end;

{$endregion ReadNativeArray!AutoOffset}

{$region ReadNativeArray}

function CLMemorySegmentCCQ.ThenReadNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArray(CQ(native_data), mem_offset);
end;

{$endregion ReadNativeArray}

{$region WriteNativeMemoryArea}

function CLMemorySegmentCCQ.ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemorySegmentCCQ;
begin
  Result := ThenWriteNativeMemoryArea(native_data, 0);
end;

{$endregion WriteNativeMemoryArea}

{$region WriteNativeMemory}

function CLMemorySegmentCCQ.ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemorySegmentCCQ;
begin
  Result := ThenWriteNativeMemory(native_data, 0);
end;

{$endregion WriteNativeMemory}

{$region WriteNativeValueArea}

function CLMemorySegmentCCQ.ThenWriteNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValueArea(native_data, 0);
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

function CLMemorySegmentCCQ.ThenWriteNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeValue(native_data, 0);
end;

{$endregion WriteNativeValue}

{$region WriteNativeArrayArea}

function CLMemorySegmentCCQ.ThenWriteNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArrayArea(native_data, 0);
end;

{$endregion WriteNativeArrayArea}

{$region WriteNativeArray}

function CLMemorySegmentCCQ.ThenWriteNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenWriteNativeArray(native_data, 0);
end;

{$endregion WriteNativeArray}

{$region ReadNativeMemoryArea}

function CLMemorySegmentCCQ.ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemorySegmentCCQ;
begin
  Result := ThenReadNativeMemoryArea(native_data, 0);
end;

{$endregion ReadNativeMemoryArea}

{$region ReadNativeMemory}

function CLMemorySegmentCCQ.ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemorySegmentCCQ;
begin
  Result := ThenReadNativeMemory(native_data, 0);
end;

{$endregion ReadNativeMemory}

{$region ReadNativeValueArea}

function CLMemorySegmentCCQ.ThenReadNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValueArea(native_data, 0);
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

function CLMemorySegmentCCQ.ThenReadNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeValue(native_data, 0);
end;

{$endregion ReadNativeValue}

{$region ReadNativeArrayArea}

function CLMemorySegmentCCQ.ThenReadNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArrayArea(native_data, 0);
end;

{$endregion ReadNativeArrayArea}

{$region ReadNativeArray}

function CLMemorySegmentCCQ.ThenReadNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenReadNativeArray(native_data, 0);
end;

{$endregion ReadNativeArray}

{$region WriteNativeMemoryArea}

type
  CLMemorySegmentCommandWriteNativeMemoryArea = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private native_data: CommandQueue<NativeMemoryArea>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemoryArea>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.sz,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteNativeMemoryArea(native_data, mem_offset));
end;

{$endregion WriteNativeMemoryArea}

{$region WriteNativeMemory}

type
  CLMemorySegmentCommandWriteNativeMemory = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private native_data: CommandQueue<NativeMemory>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemory>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.sz,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteNativeMemory(native_data, mem_offset));
end;

{$endregion WriteNativeMemory}

{$region WriteNativeValueArea}

type
  CLMemorySegmentCommandWriteNativeValueArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValueArea<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteNativeValueArea%');
    end;
    public constructor(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValueArea<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteNativeValueArea<TRecord>(native_data, mem_offset));
end;

{$endregion WriteNativeValueArea}

{$region WriteNativeValue}

type
  CLMemorySegmentCommandWriteNativeValue<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValue<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteNativeValue%');
    end;
    public constructor(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValue<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteNativeValue<TRecord>(native_data, mem_offset));
end;

{$endregion WriteNativeValue}

{$region WriteNativeArrayArea}

type
  CLMemorySegmentCommandWriteNativeArrayArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArrayArea<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteNativeArrayArea%');
    end;
    public constructor(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArrayArea<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteNativeArrayArea<TRecord>(native_data, mem_offset));
end;

{$endregion WriteNativeArrayArea}

{$region WriteNativeArray}

type
  CLMemorySegmentCommandWriteNativeArray<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArray<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:WriteNativeArray%');
    end;
    public constructor(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArray<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenWriteNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandWriteNativeArray<TRecord>(native_data, mem_offset));
end;

{$endregion WriteNativeArray}

{$region ReadNativeMemoryArea}

type
  CLMemorySegmentCommandReadNativeMemoryArea = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private native_data: CommandQueue<NativeMemoryArea>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemoryArea>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.sz,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadNativeMemoryArea(native_data, mem_offset));
end;

{$endregion ReadNativeMemoryArea}

{$region ReadNativeMemory}

type
  CLMemorySegmentCommandReadNativeMemory = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private native_data: CommandQueue<NativeMemory>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemory>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.sz,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadNativeMemory(native_data, mem_offset));
end;

{$endregion ReadNativeMemory}

{$region ReadNativeValueArea}

type
  CLMemorySegmentCommandReadNativeValueArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValueArea<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:ReadNativeValueArea%');
    end;
    public constructor(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValueArea<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadNativeValueArea<TRecord>(native_data, mem_offset));
end;

{$endregion ReadNativeValueArea}

{$region ReadNativeValue}

type
  CLMemorySegmentCommandReadNativeValue<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValue<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:ReadNativeValue%');
    end;
    public constructor(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValue<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadNativeValue<TRecord>(native_data, mem_offset));
end;

{$endregion ReadNativeValue}

{$region ReadNativeArrayArea}

type
  CLMemorySegmentCommandReadNativeArrayArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArrayArea<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:ReadNativeArrayArea%');
    end;
    public constructor(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArrayArea<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.ByteSize,
          native_data.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadNativeArrayArea<TRecord>(native_data, mem_offset));
end;

{$endregion ReadNativeArrayArea}

{$region ReadNativeArray}

type
  CLMemorySegmentCommandReadNativeArray<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArray<TRecord>>;
    private  mem_offset: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:ReadNativeArray%');
    end;
    public constructor(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>);
    begin
      self.native_data := native_data;
      self. mem_offset :=  mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
       mem_offset.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<TRecord>>;
      var  mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArray<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
         mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>( mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var  mem_offset :=  mem_offset_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), native_data.Area.ByteSize,
          native_data.Area.first_ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenReadNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandReadNativeArray<TRecord>(native_data, mem_offset));
end;

{$endregion ReadNativeArray}

{$endregion 1#Write&Read}

{$region 2#Fill}

{$region FillValue!AutoSize}

type
  CLMemorySegmentCommandFillValueAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private val: ^TRecord := pointer(Marshal.AllocHGlobal(Marshal.SizeOf&<TRecord>));
    
    protected procedure Finalize; override;
    begin
      Marshal.FreeHGlobal(new IntPtr(val));
    end;
    
    public function EnqEvCapacity: integer; override := 0;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillValueAutoSize%');
    end;
    public constructor(val: TRecord);
    begin
      self.val^ := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      
      Result := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          new IntPtr(val), new UIntPtr(Marshal.SizeOf&<TRecord>),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val^);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillValue<TRecord>(val: TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillValueAutoSize<TRecord>(val));
end;

{$endregion FillValue!AutoSize}

{$region FillValue!AutoSizeQ}

type
  CLMemorySegmentCommandFillValueAutoSizeQ<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private val: CommandQueue<TRecord>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillValueAutoSizeQ%');
    end;
    public constructor(val: CommandQueue<TRecord>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var val_qr: QueueResPtr<TRecord>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueResPtr<TRecord>>(val.InvokeToPtr); enq_evs.AddL2(val_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.res;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          new IntPtr(val), new UIntPtr(Marshal.SizeOf&<TRecord>),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillValue<TRecord>(val: CommandQueue<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillValueAutoSizeQ<TRecord>(val));
end;

{$endregion FillValue!AutoSizeQ}

{$region FillValue}

type
  CLMemorySegmentCommandFillValue<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private           val: ^TRecord := pointer(Marshal.AllocHGlobal(Marshal.SizeOf&<TRecord>));
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      Marshal.FreeHGlobal(new IntPtr(val));
    end;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillValue%');
    end;
    public constructor(val: TRecord; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.          val^ :=           val;
      self.   mem_offset  :=    mem_offset;
      self.fill_byte_len  := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
           mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(   mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
        fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          new IntPtr(val), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      sb.Append(val^);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillValue<TRecord>(val: TRecord; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillValue<TRecord>(val, mem_offset, fill_byte_len));
end;

{$endregion FillValue}

{$region FillValue!Q}

type
  CLMemorySegmentCommandFillValueQ<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private           val: CommandQueue<TRecord>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillValueQ%');
    end;
    public constructor(val: CommandQueue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.          val :=           val;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
                val.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var           val_qr: QueueResPtr<TRecord>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                  val_qr := invoker.InvokeBranch&<QueueResPtr<TRecord>>(          val.InvokeToPtr); enq_evs.AddL2(val_qr.AttachInvokeActions(g));
           mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(   mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
        fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var           val :=           val_qr.res;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          new IntPtr(val), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val:';
      sb += ' ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillValue<TRecord>(val: CommandQueue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillValueQ<TRecord>(val, mem_offset, fill_byte_len));
end;

{$endregion FillValue!Q}

{$region FillArray1!AutoSize}

function CLMemorySegmentCCQ.ThenFillArray1<TRecord>(a: array of TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillArray1(CQ(a));
end;

{$endregion FillArray1!AutoSize}

{$region FillArray2!AutoSize}

function CLMemorySegmentCCQ.ThenFillArray2<TRecord>(a: array[,] of TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillArray2(CQ(a));
end;

{$endregion FillArray2!AutoSize}

{$region FillArray3!AutoSize}

function CLMemorySegmentCCQ.ThenFillArray3<TRecord>(a: array[,,] of TRecord): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillArray3(CQ(a));
end;

{$endregion FillArray3!AutoSize}

{$region FillArray1}

function CLMemorySegmentCCQ.ThenFillArray1<TRecord>(a: array of TRecord; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillArray1(CQ(a), a_ind, pattern_byte_len, mem_offset, fill_byte_len);
end;

{$endregion FillArray1}

{$region FillArray2}

function CLMemorySegmentCCQ.ThenFillArray2<TRecord>(a: array[,] of TRecord; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillArray2(CQ(a), a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len);
end;

{$endregion FillArray2}

{$region FillArray3}

function CLMemorySegmentCCQ.ThenFillArray3<TRecord>(a: array[,,] of TRecord; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillArray3(CQ(a), a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len);
end;

{$endregion FillArray3}

{$region FillArray1!AutoSize}

type
  CLMemorySegmentCommandFillArray1AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private a: CommandQueue<array of TRecord>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillArray1AutoSize%');
    end;
    public constructor(a: CommandQueue<array of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var a_qr: QueueRes<array of TRecord>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array of TRecord>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because %rank would be nested in %AutoSize
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0], new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillArray1<TRecord>(a: CommandQueue<array of TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillArray1AutoSize<TRecord>(a));
end;

{$endregion FillArray1!AutoSize}

{$region FillArray2!AutoSize}

type
  CLMemorySegmentCommandFillArray2AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private a: CommandQueue<array[,] of TRecord>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillArray2AutoSize%');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var a_qr: QueueRes<array[,] of TRecord>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,] of TRecord>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because %rank would be nested in %AutoSize
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0,0], new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillArray2<TRecord>(a: CommandQueue<array[,] of TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillArray2AutoSize<TRecord>(a));
end;

{$endregion FillArray2!AutoSize}

{$region FillArray3!AutoSize}

type
  CLMemorySegmentCommandFillArray3AutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private a: CommandQueue<array[,,] of TRecord>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillArray3AutoSize%');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var a_qr: QueueRes<array[,,] of TRecord>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of TRecord>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        //TODO unable to merge this Enqueue with non-AutoSize, because %rank would be nested in %AutoSize
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0,0,0], new UIntPtr(a.Length*Marshal.SizeOf&<TRecord>),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillArray3AutoSize<TRecord>(a));
end;

{$endregion FillArray3!AutoSize}

{$region FillArray1}

type
  CLMemorySegmentCommandFillArray1<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private                a: CommandQueue<array of TRecord>;
    private            a_ind: CommandQueue<integer>;
    private pattern_byte_len: CommandQueue<integer>;
    private       mem_offset: CommandQueue<integer>;
    private    fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 5;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillArray1%');
    end;
    public constructor(a: CommandQueue<array of TRecord>; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.               a :=                a;
      self.           a_ind :=            a_ind;
      self.pattern_byte_len := pattern_byte_len;
      self.      mem_offset :=       mem_offset;
      self.   fill_byte_len :=    fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
                     a.InitBeforeInvoke(g, prev_hubs);
                 a_ind.InitBeforeInvoke(g, prev_hubs);
      pattern_byte_len.InitBeforeInvoke(g, prev_hubs);
            mem_offset.InitBeforeInvoke(g, prev_hubs);
         fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var                a_qr: QueueRes<array of TRecord>;
      var            a_ind_qr: QueueRes<integer>;
      var pattern_byte_len_qr: QueueRes<integer>;
      var       mem_offset_qr: QueueRes<integer>;
      var    fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                       a_qr := invoker.InvokeBranch&<QueueRes<array of TRecord>>(               a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
                   a_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(           a_ind.InvokeToAny); if a_ind_qr.IsConst then enq_evs.AddL2(a_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind_qr.AttachInvokeActions(g));
        pattern_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_byte_len.InvokeToAny); if pattern_byte_len_qr.IsConst then enq_evs.AddL2(pattern_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_byte_len_qr.AttachInvokeActions(g));
              mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(      mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
           fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var                a :=                a_qr.GetResDirect;
        var            a_ind :=            a_ind_qr.GetResDirect;
        var pattern_byte_len := pattern_byte_len_qr.GetResDirect;
        var       mem_offset :=       mem_offset_qr.GetResDirect;
        var    fill_byte_len :=    fill_byte_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind], new UIntPtr(pattern_byte_len),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind:';
      sb += ' ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_byte_len:';
      sb += ' ';
      pattern_byte_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillArray1<TRecord>(a: CommandQueue<array of TRecord>; a_ind, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillArray1<TRecord>(a, a_ind, pattern_byte_len, mem_offset, fill_byte_len));
end;

{$endregion FillArray1}

{$region FillArray2}

type
  CLMemorySegmentCommandFillArray2<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private                a: CommandQueue<array[,] of TRecord>;
    private           a_ind1: CommandQueue<integer>;
    private           a_ind2: CommandQueue<integer>;
    private pattern_byte_len: CommandQueue<integer>;
    private       mem_offset: CommandQueue<integer>;
    private    fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 6;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillArray2%');
    end;
    public constructor(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.               a :=                a;
      self.          a_ind1 :=           a_ind1;
      self.          a_ind2 :=           a_ind2;
      self.pattern_byte_len := pattern_byte_len;
      self.      mem_offset :=       mem_offset;
      self.   fill_byte_len :=    fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
                     a.InitBeforeInvoke(g, prev_hubs);
                a_ind1.InitBeforeInvoke(g, prev_hubs);
                a_ind2.InitBeforeInvoke(g, prev_hubs);
      pattern_byte_len.InitBeforeInvoke(g, prev_hubs);
            mem_offset.InitBeforeInvoke(g, prev_hubs);
         fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var                a_qr: QueueRes<array[,] of TRecord>;
      var           a_ind1_qr: QueueRes<integer>;
      var           a_ind2_qr: QueueRes<integer>;
      var pattern_byte_len_qr: QueueRes<integer>;
      var       mem_offset_qr: QueueRes<integer>;
      var    fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                       a_qr := invoker.InvokeBranch&<QueueRes<array[,] of TRecord>>(               a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
                  a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(          a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
                  a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(          a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
        pattern_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_byte_len.InvokeToAny); if pattern_byte_len_qr.IsConst then enq_evs.AddL2(pattern_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_byte_len_qr.AttachInvokeActions(g));
              mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(      mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
           fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var                a :=                a_qr.GetResDirect;
        var           a_ind1 :=           a_ind1_qr.GetResDirect;
        var           a_ind2 :=           a_ind2_qr.GetResDirect;
        var pattern_byte_len := pattern_byte_len_qr.GetResDirect;
        var       mem_offset :=       mem_offset_qr.GetResDirect;
        var    fill_byte_len :=    fill_byte_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind1,a_ind2], new UIntPtr(pattern_byte_len),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_byte_len:';
      sb += ' ';
      pattern_byte_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillArray2<TRecord>(a: CommandQueue<array[,] of TRecord>; a_ind1,a_ind2, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillArray2<TRecord>(a, a_ind1, a_ind2, pattern_byte_len, mem_offset, fill_byte_len));
end;

{$endregion FillArray2}

{$region FillArray3}

type
  CLMemorySegmentCommandFillArray3<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private                a: CommandQueue<array[,,] of TRecord>;
    private           a_ind1: CommandQueue<integer>;
    private           a_ind2: CommandQueue<integer>;
    private           a_ind3: CommandQueue<integer>;
    private pattern_byte_len: CommandQueue<integer>;
    private       mem_offset: CommandQueue<integer>;
    private    fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 7;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillArray3%');
    end;
    public constructor(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.               a :=                a;
      self.          a_ind1 :=           a_ind1;
      self.          a_ind2 :=           a_ind2;
      self.          a_ind3 :=           a_ind3;
      self.pattern_byte_len := pattern_byte_len;
      self.      mem_offset :=       mem_offset;
      self.   fill_byte_len :=    fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
                     a.InitBeforeInvoke(g, prev_hubs);
                a_ind1.InitBeforeInvoke(g, prev_hubs);
                a_ind2.InitBeforeInvoke(g, prev_hubs);
                a_ind3.InitBeforeInvoke(g, prev_hubs);
      pattern_byte_len.InitBeforeInvoke(g, prev_hubs);
            mem_offset.InitBeforeInvoke(g, prev_hubs);
         fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var                a_qr: QueueRes<array[,,] of TRecord>;
      var           a_ind1_qr: QueueRes<integer>;
      var           a_ind2_qr: QueueRes<integer>;
      var           a_ind3_qr: QueueRes<integer>;
      var pattern_byte_len_qr: QueueRes<integer>;
      var       mem_offset_qr: QueueRes<integer>;
      var    fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                       a_qr := invoker.InvokeBranch&<QueueRes<array[,,] of TRecord>>(               a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
                  a_ind1_qr := invoker.InvokeBranch&<QueueRes<integer>>(          a_ind1.InvokeToAny); if a_ind1_qr.IsConst then enq_evs.AddL2(a_ind1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind1_qr.AttachInvokeActions(g));
                  a_ind2_qr := invoker.InvokeBranch&<QueueRes<integer>>(          a_ind2.InvokeToAny); if a_ind2_qr.IsConst then enq_evs.AddL2(a_ind2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind2_qr.AttachInvokeActions(g));
                  a_ind3_qr := invoker.InvokeBranch&<QueueRes<integer>>(          a_ind3.InvokeToAny); if a_ind3_qr.IsConst then enq_evs.AddL2(a_ind3_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind3_qr.AttachInvokeActions(g));
        pattern_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_byte_len.InvokeToAny); if pattern_byte_len_qr.IsConst then enq_evs.AddL2(pattern_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_byte_len_qr.AttachInvokeActions(g));
              mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(      mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
           fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var                a :=                a_qr.GetResDirect;
        var           a_ind1 :=           a_ind1_qr.GetResDirect;
        var           a_ind2 :=           a_ind2_qr.GetResDirect;
        var           a_ind3 :=           a_ind3_qr.GetResDirect;
        var pattern_byte_len := pattern_byte_len_qr.GetResDirect;
        var       mem_offset :=       mem_offset_qr.GetResDirect;
        var    fill_byte_len :=    fill_byte_len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_ind1,a_ind2,a_ind3], new UIntPtr(pattern_byte_len),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind1:';
      sb += ' ';
      a_ind1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind2:';
      sb += ' ';
      a_ind2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind3:';
      sb += ' ';
      a_ind3.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_byte_len:';
      sb += ' ';
      pattern_byte_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillArray3<TRecord>(a: CommandQueue<array[,,] of TRecord>; a_ind1,a_ind2,a_ind3, pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillArray3<TRecord>(a, a_ind1, a_ind2, a_ind3, pattern_byte_len, mem_offset, fill_byte_len));
end;

{$endregion FillArray3}

{$region FillArraySegment!AutoSize}

type
  CLMemorySegmentCommandFillArraySegmentAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private a: ArraySegment<TRecord>;
    
    public function EnqEvCapacity: integer; override := 0;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillArraySegmentAutoSize%');
    end;
    public constructor(a: ArraySegment<TRecord>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      
      Result := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a.Array[a.Offset], new UIntPtr(a.Count * Marshal.SizeOf&<TRecord>),
          UIntPtr.Zero,o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      sb.Append(a);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillArraySegment<TRecord>(a: ArraySegment<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillArraySegmentAutoSize<TRecord>(a));
end;

{$endregion FillArraySegment!AutoSize}

{$region FillArraySegment}

type
  CLMemorySegmentCommandFillArraySegment<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private             a: ArraySegment<TRecord>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillArraySegment%');
    end;
    public constructor(a: ArraySegment<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.            a :=             a;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
           mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(   mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
        fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a.Array[a.Offset], new UIntPtr(a.Count * Marshal.SizeOf&<TRecord>),
          new UIntPtr(mem_offset),new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a:';
      sb += ' ';
      sb.Append(a);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillArraySegment<TRecord>(a: ArraySegment<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillArraySegment<TRecord>(a, mem_offset, fill_byte_len));
end;

{$endregion FillArraySegment}

{$region FillData!AutoSize}

type
  CLMemorySegmentCommandFillDataAutoSize = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private              ptr: CommandQueue<IntPtr>;
    private pattern_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_byte_len: CommandQueue<integer>);
    begin
      self.             ptr :=              ptr;
      self.pattern_byte_len := pattern_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
                   ptr.InitBeforeInvoke(g, prev_hubs);
      pattern_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var              ptr_qr: QueueRes<IntPtr>;
      var pattern_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                     ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(             ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        pattern_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_byte_len.InvokeToAny); if pattern_byte_len_qr.IsConst then enq_evs.AddL2(pattern_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var              ptr :=              ptr_qr.GetResDirect;
        var pattern_byte_len := pattern_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          ptr, new UIntPtr(pattern_byte_len),
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_byte_len:';
      sb += ' ';
      pattern_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillData(ptr: CommandQueue<IntPtr>; pattern_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillDataAutoSize(ptr, pattern_byte_len));
end;

{$endregion FillData!AutoSize}

{$region FillData}

type
  CLMemorySegmentCommandFillData = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private              ptr: CommandQueue<IntPtr>;
    private pattern_byte_len: CommandQueue<integer>;
    private       mem_offset: CommandQueue<integer>;
    private    fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.             ptr :=              ptr;
      self.pattern_byte_len := pattern_byte_len;
      self.      mem_offset :=       mem_offset;
      self.   fill_byte_len :=    fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
                   ptr.InitBeforeInvoke(g, prev_hubs);
      pattern_byte_len.InitBeforeInvoke(g, prev_hubs);
            mem_offset.InitBeforeInvoke(g, prev_hubs);
         fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var              ptr_qr: QueueRes<IntPtr>;
      var pattern_byte_len_qr: QueueRes<integer>;
      var       mem_offset_qr: QueueRes<integer>;
      var    fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                     ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(             ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        pattern_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_byte_len.InvokeToAny); if pattern_byte_len_qr.IsConst then enq_evs.AddL2(pattern_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_byte_len_qr.AttachInvokeActions(g));
              mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(      mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
           fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(   fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var              ptr :=              ptr_qr.GetResDirect;
        var pattern_byte_len := pattern_byte_len_qr.GetResDirect;
        var       mem_offset :=       mem_offset_qr.GetResDirect;
        var    fill_byte_len :=    fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          ptr, new UIntPtr(pattern_byte_len),
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr:';
      sb += ' ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_byte_len:';
      sb += ' ';
      pattern_byte_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillData(ptr: CommandQueue<IntPtr>; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillData(ptr, pattern_byte_len, mem_offset, fill_byte_len));
end;

{$endregion FillData}

{$region FillData!AutoSize}

function CLMemorySegmentCCQ.ThenFillData(ptr: pointer; pattern_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := ThenFillData(IntPtr(ptr), pattern_byte_len);
end;

{$endregion FillData!AutoSize}

{$region FillData}

function CLMemorySegmentCCQ.ThenFillData(ptr: pointer; pattern_byte_len, mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := ThenFillData(IntPtr(ptr), pattern_byte_len, mem_offset, fill_byte_len);
end;

{$endregion FillData}

{$region FillNativeMemoryArea!AutoSize}

function CLMemorySegmentCCQ.ThenFillNativeMemoryArea(native_data: NativeMemoryArea): CLMemorySegmentCCQ;
begin
  Result := ThenFillNativeMemoryArea(CQ(native_data));
end;

{$endregion FillNativeMemoryArea!AutoSize}

{$region FillNativeMemoryArea}

function CLMemorySegmentCCQ.ThenFillNativeMemoryArea(native_data: NativeMemoryArea; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := ThenFillNativeMemoryArea(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeMemoryArea}

{$region FillNativeMemory!AutoSize}

function CLMemorySegmentCCQ.ThenFillNativeMemory(native_data: NativeMemory): CLMemorySegmentCCQ;
begin
  Result := ThenFillNativeMemory(CQ(native_data));
end;

{$endregion FillNativeMemory!AutoSize}

{$region FillNativeMemory}

function CLMemorySegmentCCQ.ThenFillNativeMemory(native_data: NativeMemory; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := ThenFillNativeMemory(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeMemory}

{$region FillNativeValueArea!AutoSize}

function CLMemorySegmentCCQ.ThenFillNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillNativeValueArea(CQ(native_data));
end;

{$endregion FillNativeValueArea!AutoSize}

{$region FillNativeValueArea}

function CLMemorySegmentCCQ.ThenFillNativeValueArea<TRecord>(native_data: NativeValueArea<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillNativeValueArea(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeValueArea}

{$region FillNativeValue!AutoSize}

function CLMemorySegmentCCQ.ThenFillNativeValue<TRecord>(native_data: NativeValue<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillNativeValue(CQ(native_data));
end;

{$endregion FillNativeValue!AutoSize}

{$region FillNativeValue}

function CLMemorySegmentCCQ.ThenFillNativeValue<TRecord>(native_data: NativeValue<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillNativeValue(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeValue}

{$region FillNativeArrayArea!AutoSize}

function CLMemorySegmentCCQ.ThenFillNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillNativeArrayArea(CQ(native_data));
end;

{$endregion FillNativeArrayArea!AutoSize}

{$region FillNativeArrayArea}

function CLMemorySegmentCCQ.ThenFillNativeArrayArea<TRecord>(native_data: NativeArrayArea<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillNativeArrayArea(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeArrayArea}

{$region FillNativeArray!AutoSize}

function CLMemorySegmentCCQ.ThenFillNativeArray<TRecord>(native_data: NativeArray<TRecord>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillNativeArray(CQ(native_data));
end;

{$endregion FillNativeArray!AutoSize}

{$region FillNativeArray}

function CLMemorySegmentCCQ.ThenFillNativeArray<TRecord>(native_data: NativeArray<TRecord>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := ThenFillNativeArray(CQ(native_data),mem_offset,fill_byte_len);
end;

{$endregion FillNativeArray}

{$region FillNativeMemoryArea!AutoSize}

type
  CLMemorySegmentCommandFillNativeMemoryAreaAutoSize = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private native_data: CommandQueue<NativeMemoryArea>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeMemoryArea>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemoryArea>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.sz,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeMemoryAreaAutoSize(native_data));
end;

{$endregion FillNativeMemoryArea!AutoSize}

{$region FillNativeMemoryArea}

type
  CLMemorySegmentCommandFillNativeMemoryArea = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private   native_data: CommandQueue<NativeMemoryArea>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeMemoryArea>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var   native_data_qr: QueueRes<NativeMemoryArea>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
          native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemoryArea>>(  native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
           mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(   mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
        fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.sz,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeMemoryArea(native_data: CommandQueue<NativeMemoryArea>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeMemoryArea(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeMemoryArea}

{$region FillNativeMemory!AutoSize}

type
  CLMemorySegmentCommandFillNativeMemoryAutoSize = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private native_data: CommandQueue<NativeMemory>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(native_data: CommandQueue<NativeMemory>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeMemory>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemory>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.sz,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeMemoryAutoSize(native_data));
end;

{$endregion FillNativeMemory!AutoSize}

{$region FillNativeMemory}

type
  CLMemorySegmentCommandFillNativeMemory = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private   native_data: CommandQueue<NativeMemory>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(native_data: CommandQueue<NativeMemory>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var   native_data_qr: QueueRes<NativeMemory>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
          native_data_qr := invoker.InvokeBranch&<QueueRes<NativeMemory>>(  native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
           mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(   mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
        fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.sz,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeMemory(native_data: CommandQueue<NativeMemory>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeMemory(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeMemory}

{$region FillNativeValueArea!AutoSize}

type
  CLMemorySegmentCommandFillNativeValueAreaAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValueArea<TRecord>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillNativeValueAreaAutoSize%');
    end;
    public constructor(native_data: CommandQueue<NativeValueArea<TRecord>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeValueArea<TRecord>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValueArea<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.ByteSize,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeValueAreaAutoSize<TRecord>(native_data));
end;

{$endregion FillNativeValueArea!AutoSize}

{$region FillNativeValueArea}

type
  CLMemorySegmentCommandFillNativeValueArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private   native_data: CommandQueue<NativeValueArea<TRecord>>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillNativeValueArea%');
    end;
    public constructor(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var   native_data_qr: QueueRes<NativeValueArea<TRecord>>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
          native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValueArea<TRecord>>>(  native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
           mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(   mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
        fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.ptr,
          native_data.ByteSize,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeValueArea<TRecord>(native_data: CommandQueue<NativeValueArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeValueArea<TRecord>(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeValueArea}

{$region FillNativeValue!AutoSize}

type
  CLMemorySegmentCommandFillNativeValueAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeValue<TRecord>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillNativeValueAutoSize%');
    end;
    public constructor(native_data: CommandQueue<NativeValue<TRecord>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeValue<TRecord>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValue<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.ByteSize,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeValueAutoSize<TRecord>(native_data));
end;

{$endregion FillNativeValue!AutoSize}

{$region FillNativeValue}

type
  CLMemorySegmentCommandFillNativeValue<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private   native_data: CommandQueue<NativeValue<TRecord>>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillNativeValue%');
    end;
    public constructor(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var   native_data_qr: QueueRes<NativeValue<TRecord>>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
          native_data_qr := invoker.InvokeBranch&<QueueRes<NativeValue<TRecord>>>(  native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
           mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(   mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
        fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.ptr,
          native_data.Area.ByteSize,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeValue<TRecord>(native_data: CommandQueue<NativeValue<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeValue<TRecord>(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeValue}

{$region FillNativeArrayArea!AutoSize}

type
  CLMemorySegmentCommandFillNativeArrayAreaAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArrayArea<TRecord>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillNativeArrayAreaAutoSize%');
    end;
    public constructor(native_data: CommandQueue<NativeArrayArea<TRecord>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeArrayArea<TRecord>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArrayArea<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.first_ptr,
          native_data.ByteSize,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeArrayAreaAutoSize<TRecord>(native_data));
end;

{$endregion FillNativeArrayArea!AutoSize}

{$region FillNativeArrayArea}

type
  CLMemorySegmentCommandFillNativeArrayArea<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private   native_data: CommandQueue<NativeArrayArea<TRecord>>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillNativeArrayArea%');
    end;
    public constructor(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var   native_data_qr: QueueRes<NativeArrayArea<TRecord>>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
          native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArrayArea<TRecord>>>(  native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
           mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(   mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
        fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.first_ptr,
          native_data.ByteSize,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeArrayArea<TRecord>(native_data: CommandQueue<NativeArrayArea<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeArrayArea<TRecord>(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeArrayArea}

{$region FillNativeArray!AutoSize}

type
  CLMemorySegmentCommandFillNativeArrayAutoSize<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private native_data: CommandQueue<NativeArray<TRecord>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillNativeArrayAutoSize%');
    end;
    public constructor(native_data: CommandQueue<NativeArray<TRecord>>);
    begin
      self.native_data := native_data;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      native_data.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var native_data_qr: QueueRes<NativeArray<TRecord>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArray<TRecord>>>(native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var native_data := native_data_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.first_ptr,
          native_data.Area.ByteSize,
          UIntPtr.Zero, o.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeArrayAutoSize<TRecord>(native_data));
end;

{$endregion FillNativeArray!AutoSize}

{$region FillNativeArray}

type
  CLMemorySegmentCommandFillNativeArray<TRecord> = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
  where TRecord: record;
    private   native_data: CommandQueue<NativeArray<TRecord>>;
    private    mem_offset: CommandQueue<integer>;
    private fill_byte_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:CLMemorySegment:FillNativeArray%');
    end;
    public constructor(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>);
    begin
      self.  native_data :=   native_data;
      self.   mem_offset :=    mem_offset;
      self.fill_byte_len := fill_byte_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
        native_data.InitBeforeInvoke(g, prev_hubs);
         mem_offset.InitBeforeInvoke(g, prev_hubs);
      fill_byte_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var   native_data_qr: QueueRes<NativeArray<TRecord>>;
      var    mem_offset_qr: QueueRes<integer>;
      var fill_byte_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
          native_data_qr := invoker.InvokeBranch&<QueueRes<NativeArray<TRecord>>>(  native_data.InvokeToAny); if native_data_qr.IsConst then enq_evs.AddL2(native_data_qr.AttachInvokeActions(g)) else enq_evs.AddL1(native_data_qr.AttachInvokeActions(g));
           mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(   mem_offset.InvokeToAny); if mem_offset_qr.IsConst then enq_evs.AddL2(mem_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_offset_qr.AttachInvokeActions(g));
        fill_byte_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(fill_byte_len.InvokeToAny); if fill_byte_len_qr.IsConst then enq_evs.AddL2(fill_byte_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(fill_byte_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var   native_data :=   native_data_qr.GetResDirect;
        var    mem_offset :=    mem_offset_qr.GetResDirect;
        var fill_byte_len := fill_byte_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          native_data.Area.first_ptr,
          native_data.Area.ByteSize,
          new UIntPtr(mem_offset), new UIntPtr(fill_byte_len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'native_data:';
      sb += ' ';
      native_data.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'mem_offset:';
      sb += ' ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'fill_byte_len:';
      sb += ' ';
      fill_byte_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenFillNativeArray<TRecord>(native_data: CommandQueue<NativeArray<TRecord>>; mem_offset, fill_byte_len: CommandQueue<integer>): CLMemorySegmentCCQ; where TRecord: record;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandFillNativeArray<TRecord>(native_data, mem_offset, fill_byte_len));
end;

{$endregion FillNativeArray}

{$endregion 2#Fill}

{$region 3#Copy}

{$region CopyTo!AutoSize}

type
  CLMemorySegmentCommandCopyToAutoSize = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private mem: CommandQueue<CLMemorySegment>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(mem: CommandQueue<CLMemorySegment>);
    begin
      self.mem := mem;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      mem.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var mem_qr: QueueRes<CLMemorySegment>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        mem_qr := invoker.InvokeBranch&<QueueRes<CLMemorySegment>>(mem.InvokeToAny); if mem_qr.IsConst then enq_evs.AddL2(mem_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var mem := mem_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          o.Size64<mem.Size64 ? o.Size : mem.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenCopyTo(mem: CommandQueue<CLMemorySegment>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandCopyToAutoSize(mem));
end;

{$endregion CopyTo!AutoSize}

{$region CopyTo}

type
  CLMemorySegmentCommandCopyTo = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private         mem: CommandQueue<CLMemorySegment>;
    private from_offset: CommandQueue<integer>;
    private   to_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(mem: CommandQueue<CLMemorySegment>; from_offset, to_offset, len: CommandQueue<integer>);
    begin
      self.        mem :=         mem;
      self.from_offset := from_offset;
      self.  to_offset :=   to_offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
              mem.InitBeforeInvoke(g, prev_hubs);
      from_offset.InitBeforeInvoke(g, prev_hubs);
        to_offset.InitBeforeInvoke(g, prev_hubs);
              len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var         mem_qr: QueueRes<CLMemorySegment>;
      var from_offset_qr: QueueRes<integer>;
      var   to_offset_qr: QueueRes<integer>;
      var         len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                mem_qr := invoker.InvokeBranch&<QueueRes<CLMemorySegment>>(        mem.InvokeToAny); if mem_qr.IsConst then enq_evs.AddL2(mem_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_qr.AttachInvokeActions(g));
        from_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(from_offset.InvokeToAny); if from_offset_qr.IsConst then enq_evs.AddL2(from_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(from_offset_qr.AttachInvokeActions(g));
          to_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(  to_offset.InvokeToAny); if to_offset_qr.IsConst then enq_evs.AddL2(to_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(to_offset_qr.AttachInvokeActions(g));
                len_qr := invoker.InvokeBranch&<QueueRes<integer>>(        len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var         mem :=         mem_qr.GetResDirect;
        var from_offset := from_offset_qr.GetResDirect;
        var   to_offset :=   to_offset_qr.GetResDirect;
        var         len :=         len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,mem.Native,
          new UIntPtr(from_offset), new UIntPtr(to_offset),
          new UIntPtr(len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'from_offset:';
      sb += ' ';
      from_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'to_offset:';
      sb += ' ';
      to_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenCopyTo(mem: CommandQueue<CLMemorySegment>; from_offset, to_offset, len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandCopyTo(mem, from_offset, to_offset, len));
end;

{$endregion CopyTo}

{$region CopyFrom!AutoSize}

type
  CLMemorySegmentCommandCopyFromAutoSize = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private mem: CommandQueue<CLMemorySegment>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(mem: CommandQueue<CLMemorySegment>);
    begin
      self.mem := mem;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      mem.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var mem_qr: QueueRes<CLMemorySegment>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        mem_qr := invoker.InvokeBranch&<QueueRes<CLMemorySegment>>(mem.InvokeToAny); if mem_qr.IsConst then enq_evs.AddL2(mem_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var mem := mem_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          o.Size64<mem.Size64 ? o.Size : mem.Size,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenCopyFrom(mem: CommandQueue<CLMemorySegment>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandCopyFromAutoSize(mem));
end;

{$endregion CopyFrom!AutoSize}

{$region CopyFrom}

type
  CLMemorySegmentCommandCopyFrom = sealed class(EnqueueableGPUCommand<CLMemorySegment>)
    private         mem: CommandQueue<CLMemorySegment>;
    private from_offset: CommandQueue<integer>;
    private   to_offset: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(mem: CommandQueue<CLMemorySegment>; from_offset, to_offset, len: CommandQueue<integer>);
    begin
      self.        mem :=         mem;
      self.from_offset := from_offset;
      self.  to_offset :=   to_offset;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
              mem.InitBeforeInvoke(g, prev_hubs);
      from_offset.InitBeforeInvoke(g, prev_hubs);
        to_offset.InitBeforeInvoke(g, prev_hubs);
              len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParams(g: CLTaskGlobalData; enq_evs: DoubleEventListList): EnqFunc<CLMemorySegment>; override;
    begin
      var         mem_qr: QueueRes<CLMemorySegment>;
      var from_offset_qr: QueueRes<integer>;
      var   to_offset_qr: QueueRes<integer>;
      var         len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                mem_qr := invoker.InvokeBranch&<QueueRes<CLMemorySegment>>(        mem.InvokeToAny); if mem_qr.IsConst then enq_evs.AddL2(mem_qr.AttachInvokeActions(g)) else enq_evs.AddL1(mem_qr.AttachInvokeActions(g));
        from_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(from_offset.InvokeToAny); if from_offset_qr.IsConst then enq_evs.AddL2(from_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(from_offset_qr.AttachInvokeActions(g));
          to_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(  to_offset.InvokeToAny); if to_offset_qr.IsConst then enq_evs.AddL2(to_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(to_offset_qr.AttachInvokeActions(g));
                len_qr := invoker.InvokeBranch&<QueueRes<integer>>(        len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var         mem :=         mem_qr.GetResDirect;
        var from_offset := from_offset_qr.GetResDirect;
        var   to_offset :=   to_offset_qr.GetResDirect;
        var         len :=         len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, mem.Native,o.Native,
          new UIntPtr(from_offset), new UIntPtr(to_offset),
          new UIntPtr(len),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem:';
      sb += ' ';
      mem.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'from_offset:';
      sb += ' ';
      from_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'to_offset:';
      sb += ' ';
      to_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len:';
      sb += ' ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLMemorySegmentCCQ.ThenCopyFrom(mem: CommandQueue<CLMemorySegment>; from_offset, to_offset, len: CommandQueue<integer>): CLMemorySegmentCCQ;
begin
  Result := AddCommand(self, new CLMemorySegmentCommandCopyFrom(mem, from_offset, to_offset, len));
end;

{$endregion CopyFrom}

{$endregion 3#Copy}


