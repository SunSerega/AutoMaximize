


{$region 1#Write&Read}

{$region WriteDataAutoSize}

type
  CLArrayCommandWriteDataAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(o.ByteSize),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr: ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteData(ptr: CommandQueue<IntPtr>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteDataAutoSize<T>(ptr));
end;

{$endregion WriteDataAutoSize}

{$region WriteData}

type
  CLArrayCommandWriteData<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>);
    begin
      self.ptr := ptr;
      self.ind := ind;
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
        len_qr := invoker.InvokeBranch&<QueueRes<integer>>(len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf&<T>), new UIntPtr(len*Marshal.SizeOf&<T>),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr: ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteData<T>(ptr, ind, len));
end;

{$endregion WriteData}

{$region ReadDataAutoSize}

type
  CLArrayCommandReadDataAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(ptr: CommandQueue<IntPtr>);
    begin
      self.ptr := ptr;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(o.ByteSize),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr: ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadData(ptr: CommandQueue<IntPtr>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadDataAutoSize<T>(ptr));
end;

{$endregion ReadDataAutoSize}

{$region ReadData}

type
  CLArrayCommandReadData<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private ptr: CommandQueue<IntPtr>;
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>);
    begin
      self.ptr := ptr;
      self.ind := ind;
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ptr.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var ptr_qr: QueueRes<IntPtr>;
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
        len_qr := invoker.InvokeBranch&<QueueRes<integer>>(len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ptr := ptr_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf&<T>), new UIntPtr(len*Marshal.SizeOf&<T>),
          ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr: ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadData(ptr: CommandQueue<IntPtr>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadData<T>(ptr, ind, len));
end;

{$endregion ReadData}

{$region WriteDataAutoSize}

function CLArrayCCQ<T>.ThenWriteData(ptr: pointer): CLArrayCCQ<T>;
begin
  Result := ThenWriteData(IntPtr(ptr));
end;

{$endregion WriteDataAutoSize}

{$region WriteData}

function CLArrayCCQ<T>.ThenWriteData(ptr: pointer; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenWriteData(IntPtr(ptr), ind, len);
end;

{$endregion WriteData}

{$region ReadDataAutoSize}

function CLArrayCCQ<T>.ThenReadData(ptr: pointer): CLArrayCCQ<T>;
begin
  Result := ThenReadData(IntPtr(ptr));
end;

{$endregion ReadDataAutoSize}

{$region ReadData}

function CLArrayCCQ<T>.ThenReadData(ptr: pointer; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenReadData(IntPtr(ptr), ind, len);
end;

{$endregion ReadData}

{$region WriteValue}

type
  CLArrayCommandWriteValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: ^&T := pointer(Marshal.AllocHGlobal(Marshal.SizeOf&<&T>));
    private ind: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      Marshal.FreeHGlobal(new IntPtr(val));
    end;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(val: &T; ind: CommandQueue<integer>);
    begin
      self.val^ := val;
      self.ind  := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf&<T>), new UIntPtr(Marshal.SizeOf&<T>),
          new IntPtr(val),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val: ';
      sb.Append(val^);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteValue(val: &T; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteValue<T>(val, ind));
end;

{$endregion WriteValue}

{$region WriteValueQ}

type
  CLArrayCommandWriteValueQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    private ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(val: CommandQueue<&T>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var val_qr: QueueResPtr<&T>;
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueResPtr<&T>>(val.InvokeToPtr); enq_evs.AddL2(val_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.res;
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf&<T>), new UIntPtr(Marshal.SizeOf&<T>),
          new IntPtr(val),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val: ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteValue(val: CommandQueue<&T>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteValueQ<T>(val, ind));
end;

{$endregion WriteValueQ}

{$region WriteValueN}

type
  CLArrayCommandWriteValueN<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: NativeValue<&T>;
    private ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(val: NativeValue<&T>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf&<T>), new UIntPtr(Marshal.SizeOf&<T>),
          val.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val: ';
      sb.Append(val);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteValue(val: NativeValue<&T>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteValueN<T>(val, ind));
end;

{$endregion WriteValueN}

{$region WriteValueNQ}

type
  CLArrayCommandWriteValueNQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<NativeValue<&T>>;
    private ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(val: CommandQueue<NativeValue<&T>>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var val_qr: QueueRes<NativeValue<&T>>;
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueRes<NativeValue<&T>>>(val.InvokeToAny); if val_qr.IsConst then enq_evs.AddL2(val_qr.AttachInvokeActions(g)) else enq_evs.AddL1(val_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf&<T>), new UIntPtr(Marshal.SizeOf&<T>),
          val.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val: ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteValue(val: CommandQueue<NativeValue<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteValueNQ<T>(val, ind));
end;

{$endregion WriteValueNQ}

{$region ReadValueN}

type
  CLArrayCommandReadValueN<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: NativeValue<&T>;
    private ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(val: NativeValue<&T>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf&<T>), new UIntPtr(Marshal.SizeOf&<T>),
          val.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val: ';
      sb.Append(val);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadValue(val: NativeValue<&T>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadValueN<T>(val, ind));
end;

{$endregion ReadValueN}

{$region ReadValueNQ}

type
  CLArrayCommandReadValueNQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<NativeValue<&T>>;
    private ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(val: CommandQueue<NativeValue<&T>>; ind: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var val_qr: QueueRes<NativeValue<&T>>;
      var ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueRes<NativeValue<&T>>>(val.InvokeToAny); if val_qr.IsConst then enq_evs.AddL2(val_qr.AttachInvokeActions(g)) else enq_evs.AddL1(val_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.GetResDirect;
        var ind := ind_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind * Marshal.SizeOf&<T>), new UIntPtr(Marshal.SizeOf&<T>),
          val.ptr,
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val: ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadValue(val: CommandQueue<NativeValue<&T>>; ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadValueNQ<T>(val, ind));
end;

{$endregion ReadValueNQ}

{$region WriteArrayAutoSize}

type
  CLArrayCommandWriteArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var a_qr: QueueRes<array of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<T>),
          a[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a: ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArrayAutoSize<T>(a));
end;

{$endregion WriteArrayAutoSize}

{$region WriteArray}

type
  CLArrayCommandWriteArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private     a: CommandQueue<array of &T>;
    private   ind: CommandQueue<integer>;
    private   len: CommandQueue<integer>;
    private a_ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(a: CommandQueue<array of &T>; ind, len, a_ind: CommandQueue<integer>);
    begin
      self.    a :=     a;
      self.  ind :=   ind;
      self.  len :=   len;
      self.a_ind := a_ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
          a.InitBeforeInvoke(g, prev_hubs);
        ind.InitBeforeInvoke(g, prev_hubs);
        len.InitBeforeInvoke(g, prev_hubs);
      a_ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var     a_qr: QueueRes<array of &T>;
      var   ind_qr: QueueRes<integer>;
      var   len_qr: QueueRes<integer>;
      var a_ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
            a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(    a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
          ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(  ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
          len_qr := invoker.InvokeBranch&<QueueRes<integer>>(  len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
        a_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind.InvokeToAny); if a_ind_qr.IsConst then enq_evs.AddL2(a_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var     a :=     a_qr.GetResDirect;
        var   ind :=   ind_qr.GetResDirect;
        var   len :=   len_qr.GetResDirect;
        var a_ind := a_ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueWriteBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind*Marshal.SizeOf&<T>), new UIntPtr(len*Marshal.SizeOf&<T>),
          a[a_ind],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a: ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind: ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenWriteArray(a: CommandQueue<array of &T>; ind, len, a_ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandWriteArray<T>(a, ind, len, a_ind));
end;

{$endregion WriteArray}

{$region ReadArrayAutoSize}

type
  CLArrayCommandReadArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var a_qr: QueueRes<array of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, new UIntPtr(a.Length*Marshal.SizeOf&<T>),
          a[0],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a: ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArrayAutoSize<T>(a));
end;

{$endregion ReadArrayAutoSize}

{$region ReadArray}

type
  CLArrayCommandReadArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private     a: CommandQueue<array of &T>;
    private   ind: CommandQueue<integer>;
    private   len: CommandQueue<integer>;
    private a_ind: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(a: CommandQueue<array of &T>; ind, len, a_ind: CommandQueue<integer>);
    begin
      self.    a :=     a;
      self.  ind :=   ind;
      self.  len :=   len;
      self.a_ind := a_ind;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
          a.InitBeforeInvoke(g, prev_hubs);
        ind.InitBeforeInvoke(g, prev_hubs);
        len.InitBeforeInvoke(g, prev_hubs);
      a_ind.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var     a_qr: QueueRes<array of &T>;
      var   ind_qr: QueueRes<integer>;
      var   len_qr: QueueRes<integer>;
      var a_ind_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
            a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(    a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
          ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(  ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
          len_qr := invoker.InvokeBranch&<QueueRes<integer>>(  len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
        a_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(a_ind.InvokeToAny); if a_ind_qr.IsConst then enq_evs.AddL2(a_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_ind_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var     a :=     a_qr.GetResDirect;
        var   ind :=   ind_qr.GetResDirect;
        var   len :=   len_qr.GetResDirect;
        var a_ind := a_ind_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(ind*Marshal.SizeOf&<T>), new UIntPtr(len*Marshal.SizeOf&<T>),
          a[a_ind],
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a: ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_ind: ';
      a_ind.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenReadArray(a: CommandQueue<array of &T>; ind, len, a_ind: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandReadArray<T>(a, ind, len, a_ind));
end;

{$endregion ReadArray}

{$endregion 1#Write&Read}

{$region 2#Fill}

{$region FillDataAutoSize}

type
  CLArrayCommandFillDataAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private         ptr: CommandQueue<IntPtr>;
    private pattern_len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>);
    begin
      self.        ptr :=         ptr;
      self.pattern_len := pattern_len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
              ptr.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var         ptr_qr: QueueRes<IntPtr>;
      var pattern_len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(        ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        pattern_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_len.InvokeToAny); if pattern_len_qr.IsConst then enq_evs.AddL2(pattern_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var         ptr :=         ptr_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          ptr, new UIntPtr(pattern_len*Marshal.SizeOf&<&T>),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr: ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len: ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillData(ptr: CommandQueue<IntPtr>; pattern_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillDataAutoSize<T>(ptr, pattern_len));
end;

{$endregion FillDataAutoSize}

{$region FillData}

type
  CLArrayCommandFillData<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private         ptr: CommandQueue<IntPtr>;
    private pattern_len: CommandQueue<integer>;
    private         ind: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(ptr: CommandQueue<IntPtr>; pattern_len, ind, len: CommandQueue<integer>);
    begin
      self.        ptr :=         ptr;
      self.pattern_len := pattern_len;
      self.        ind :=         ind;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
              ptr.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
              len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var         ptr_qr: QueueRes<IntPtr>;
      var pattern_len_qr: QueueRes<integer>;
      var         ind_qr: QueueRes<integer>;
      var         len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                ptr_qr := invoker.InvokeBranch&<QueueRes<IntPtr>>(        ptr.InvokeToAny); if ptr_qr.IsConst then enq_evs.AddL2(ptr_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ptr_qr.AttachInvokeActions(g));
        pattern_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_len.InvokeToAny); if pattern_len_qr.IsConst then enq_evs.AddL2(pattern_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_len_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
                len_qr := invoker.InvokeBranch&<QueueRes<integer>>(        len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var         ptr :=         ptr_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var         len :=         len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          ptr, new UIntPtr(pattern_len*Marshal.SizeOf&<&T>),
          new UIntPtr(ind*Marshal.SizeOf&<&T>), new UIntPtr(len*Marshal.SizeOf&<&T>),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'ptr: ';
      ptr.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len: ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillData(ptr: CommandQueue<IntPtr>; pattern_len, ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillData<T>(ptr, pattern_len, ind, len));
end;

{$endregion FillData}

{$region FillDataAutoSize}

function CLArrayCCQ<T>.ThenFillData(ptr: pointer; pattern_len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillData(IntPtr(ptr), pattern_len);
end;

{$endregion FillDataAutoSize}

{$region FillData}

function CLArrayCCQ<T>.ThenFillData(ptr: pointer; pattern_len, ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := ThenFillData(IntPtr(ptr), pattern_len, ind, len);
end;

{$endregion FillData}

{$region FillValueAutoSize}

type
  CLArrayCommandFillValueAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: ^&T := pointer(Marshal.AllocHGlobal(Marshal.SizeOf&<&T>));
    
    protected procedure Finalize; override;
    begin
      Marshal.FreeHGlobal(new IntPtr(val));
    end;
    
    public function EnqEvCapacity: integer; override := 0;
    
    public constructor(val: &T);
    begin
      self.val^ := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      
      Result := (o, cq, evs)->
      begin
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          new IntPtr(val), new UIntPtr(Marshal.SizeOf&<&T>),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val: ';
      sb.Append(val^);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: &T): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValueAutoSize<T>(val));
end;

{$endregion FillValueAutoSize}

{$region FillValueAutoSizeQ}

type
  CLArrayCommandFillValueAutoSizeQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(val: CommandQueue<&T>);
    begin
      self.val := val;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var val_qr: QueueResPtr<&T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueResPtr<&T>>(val.InvokeToPtr); enq_evs.AddL2(val_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.res;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          new IntPtr(val), new UIntPtr(Marshal.SizeOf&<&T>),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val: ';
      val.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: CommandQueue<&T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValueAutoSizeQ<T>(val));
end;

{$endregion FillValueAutoSizeQ}

{$region FillValue}

type
  CLArrayCommandFillValue<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: ^&T := pointer(Marshal.AllocHGlobal(Marshal.SizeOf&<&T>));
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    protected procedure Finalize; override;
    begin
      Marshal.FreeHGlobal(new IntPtr(val));
    end;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(val: &T; ind, len: CommandQueue<integer>);
    begin
      self.val^ := val;
      self.ind  := ind;
      self.len  := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
        len_qr := invoker.InvokeBranch&<QueueRes<integer>>(len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          new IntPtr(val), new UIntPtr(Marshal.SizeOf&<&T>),
          new UIntPtr(ind*Marshal.SizeOf&<&T>), new UIntPtr(len*Marshal.SizeOf&<&T>),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val: ';
      sb.Append(val^);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: &T; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValue<T>(val, ind, len));
end;

{$endregion FillValue}

{$region FillValueQ}

type
  CLArrayCommandFillValueQ<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private val: CommandQueue<&T>;
    private ind: CommandQueue<integer>;
    private len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    public constructor(val: CommandQueue<&T>; ind, len: CommandQueue<integer>);
    begin
      self.val := val;
      self.ind := ind;
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      val.InitBeforeInvoke(g, prev_hubs);
      ind.InitBeforeInvoke(g, prev_hubs);
      len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var val_qr: QueueResPtr<&T>;
      var ind_qr: QueueRes<integer>;
      var len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        val_qr := invoker.InvokeBranch&<QueueResPtr<&T>>(val.InvokeToPtr); enq_evs.AddL2(val_qr.AttachInvokeActions(g));
        ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
        len_qr := invoker.InvokeBranch&<QueueRes<integer>>(len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var val := val_qr.res;
        var ind := ind_qr.GetResDirect;
        var len := len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          new IntPtr(val), new UIntPtr(Marshal.SizeOf&<&T>),
          new UIntPtr(ind*Marshal.SizeOf&<&T>), new UIntPtr(len*Marshal.SizeOf&<&T>),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          GC.KeepAlive(val_qr);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'val: ';
      val.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillValue(val: CommandQueue<&T>; ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillValueQ<T>(val, ind, len));
end;

{$endregion FillValueQ}

{$region FillArrayAutoSize}

type
  CLArrayCommandFillArrayAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<array of &T>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<array of &T>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var a_qr: QueueRes<array of &T>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[0], new UIntPtr(a.Length*Marshal.SizeOf&<&T>),
          UIntPtr.Zero, new UIntPtr(o.ByteSize),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a: ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray(a: CommandQueue<array of &T>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArrayAutoSize<T>(a));
end;

{$endregion FillArrayAutoSize}

{$region FillArray}

type
  CLArrayCommandFillArray<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private           a: CommandQueue<array of &T>;
    private    a_offset: CommandQueue<integer>;
    private pattern_len: CommandQueue<integer>;
    private         ind: CommandQueue<integer>;
    private         len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 5;
    
    public constructor(a: CommandQueue<array of &T>; a_offset,pattern_len, ind,len: CommandQueue<integer>);
    begin
      self.          a :=           a;
      self.   a_offset :=    a_offset;
      self.pattern_len := pattern_len;
      self.        ind :=         ind;
      self.        len :=         len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
                a.InitBeforeInvoke(g, prev_hubs);
         a_offset.InitBeforeInvoke(g, prev_hubs);
      pattern_len.InitBeforeInvoke(g, prev_hubs);
              ind.InitBeforeInvoke(g, prev_hubs);
              len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var           a_qr: QueueRes<array of &T>;
      var    a_offset_qr: QueueRes<integer>;
      var pattern_len_qr: QueueRes<integer>;
      var         ind_qr: QueueRes<integer>;
      var         len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
                  a_qr := invoker.InvokeBranch&<QueueRes<array of &T>>(          a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
           a_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(   a_offset.InvokeToAny); if a_offset_qr.IsConst then enq_evs.AddL2(a_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_offset_qr.AttachInvokeActions(g));
        pattern_len_qr := invoker.InvokeBranch&<QueueRes<integer>>(pattern_len.InvokeToAny); if pattern_len_qr.IsConst then enq_evs.AddL2(pattern_len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(pattern_len_qr.AttachInvokeActions(g));
                ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(        ind.InvokeToAny); if ind_qr.IsConst then enq_evs.AddL2(ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(ind_qr.AttachInvokeActions(g));
                len_qr := invoker.InvokeBranch&<QueueRes<integer>>(        len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var           a :=           a_qr.GetResDirect;
        var    a_offset :=    a_offset_qr.GetResDirect;
        var pattern_len := pattern_len_qr.GetResDirect;
        var         ind :=         ind_qr.GetResDirect;
        var         len :=         len_qr.GetResDirect;
        var a_hnd := GCHandle.Alloc(a, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        var ec := cl.EnqueueFillBuffer(
          cq, o.Native,
          a[a_offset], new UIntPtr(pattern_len*Marshal.SizeOf&<&T>),
          new UIntPtr(ind*Marshal.SizeOf&<&T>), new UIntPtr(len*Marshal.SizeOf&<&T>),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          a_hnd.Free;
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a: ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'a_offset: ';
      a_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'pattern_len: ';
      pattern_len.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'ind: ';
      ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenFillArray(a: CommandQueue<array of &T>; a_offset,pattern_len, ind,len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandFillArray<T>(a, a_offset, pattern_len, ind, len));
end;

{$endregion FillArray}

{$endregion 2#Fill}

{$region 3#Copy}

{$region CopyToAutoSize}

type
  CLArrayCommandCopyToAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<CLArray<T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<CLArray<T>>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var a_qr: QueueRes<CLArray<T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<CLArray<T>>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,a.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Min(o.ByteSize, a.ByteSize)),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a: ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(a: CommandQueue<CLArray<T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyToAutoSize<T>(a));
end;

{$endregion CopyToAutoSize}

{$region CopyTo}

type
  CLArrayCommandCopyTo<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        a: CommandQueue<CLArray<T>>;
    private from_ind: CommandQueue<integer>;
    private   to_ind: CommandQueue<integer>;
    private      len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(a: CommandQueue<CLArray<T>>; from_ind, to_ind, len: CommandQueue<integer>);
    begin
      self.       a :=        a;
      self.from_ind := from_ind;
      self.  to_ind :=   to_ind;
      self.     len :=      len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             a.InitBeforeInvoke(g, prev_hubs);
      from_ind.InitBeforeInvoke(g, prev_hubs);
        to_ind.InitBeforeInvoke(g, prev_hubs);
           len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var        a_qr: QueueRes<CLArray<T>>;
      var from_ind_qr: QueueRes<integer>;
      var   to_ind_qr: QueueRes<integer>;
      var      len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               a_qr := invoker.InvokeBranch&<QueueRes<CLArray<T>>>(       a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        from_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(from_ind.InvokeToAny); if from_ind_qr.IsConst then enq_evs.AddL2(from_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(from_ind_qr.AttachInvokeActions(g));
          to_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(  to_ind.InvokeToAny); if to_ind_qr.IsConst then enq_evs.AddL2(to_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(to_ind_qr.AttachInvokeActions(g));
             len_qr := invoker.InvokeBranch&<QueueRes<integer>>(     len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        a :=        a_qr.GetResDirect;
        var from_ind := from_ind_qr.GetResDirect;
        var   to_ind :=   to_ind_qr.GetResDirect;
        var      len :=      len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, o.Native,a.Native,
          new UIntPtr(from_ind*Marshal.SizeOf&<T>), new UIntPtr(to_ind*Marshal.SizeOf&<T>),
          new UIntPtr(len*Marshal.SizeOf&<T>),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a: ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'from_ind: ';
      from_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'to_ind: ';
      to_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyTo(a: CommandQueue<CLArray<T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyTo<T>(a, from_ind, to_ind, len));
end;

{$endregion CopyTo}

{$region CopyFromAutoSize}

type
  CLArrayCommandCopyFromAutoSize<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private a: CommandQueue<CLArray<T>>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    public constructor(a: CommandQueue<CLArray<T>>);
    begin
      self.a := a;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      a.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var a_qr: QueueRes<CLArray<T>>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        a_qr := invoker.InvokeBranch&<QueueRes<CLArray<T>>>(a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var a := a_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, a.Native,o.Native,
          UIntPtr.Zero, UIntPtr.Zero,
          new UIntPtr(Min(o.ByteSize, a.ByteSize)),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a: ';
      a.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(a: CommandQueue<CLArray<T>>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFromAutoSize<T>(a));
end;

{$endregion CopyFromAutoSize}

{$region CopyFrom}

type
  CLArrayCommandCopyFrom<T> = sealed class(EnqueueableGPUCommand<CLArray<T>>)
  where T: record;
    private        a: CommandQueue<CLArray<T>>;
    private from_ind: CommandQueue<integer>;
    private   to_ind: CommandQueue<integer>;
    private      len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 4;
    
    public constructor(a: CommandQueue<CLArray<T>>; from_ind, to_ind, len: CommandQueue<integer>);
    begin
      self.       a :=        a;
      self.from_ind := from_ind;
      self.  to_ind :=   to_ind;
      self.     len :=      len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
             a.InitBeforeInvoke(g, prev_hubs);
      from_ind.InitBeforeInvoke(g, prev_hubs);
        to_ind.InitBeforeInvoke(g, prev_hubs);
           len.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (CLArray<T>, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var        a_qr: QueueRes<CLArray<T>>;
      var from_ind_qr: QueueRes<integer>;
      var   to_ind_qr: QueueRes<integer>;
      var      len_qr: QueueRes<integer>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
               a_qr := invoker.InvokeBranch&<QueueRes<CLArray<T>>>(       a.InvokeToAny); if a_qr.IsConst then enq_evs.AddL2(a_qr.AttachInvokeActions(g)) else enq_evs.AddL1(a_qr.AttachInvokeActions(g));
        from_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(from_ind.InvokeToAny); if from_ind_qr.IsConst then enq_evs.AddL2(from_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(from_ind_qr.AttachInvokeActions(g));
          to_ind_qr := invoker.InvokeBranch&<QueueRes<integer>>(  to_ind.InvokeToAny); if to_ind_qr.IsConst then enq_evs.AddL2(to_ind_qr.AttachInvokeActions(g)) else enq_evs.AddL1(to_ind_qr.AttachInvokeActions(g));
             len_qr := invoker.InvokeBranch&<QueueRes<integer>>(     len.InvokeToAny); if len_qr.IsConst then enq_evs.AddL2(len_qr.AttachInvokeActions(g)) else enq_evs.AddL1(len_qr.AttachInvokeActions(g));
      end);
      
      Result := (o, cq, evs)->
      begin
        var        a :=        a_qr.GetResDirect;
        var from_ind := from_ind_qr.GetResDirect;
        var   to_ind :=   to_ind_qr.GetResDirect;
        var      len :=      len_qr.GetResDirect;
        var res_ev: cl_event;
        
        var ec := cl.EnqueueCopyBuffer(
          cq, a.Native,o.Native,
          new UIntPtr(from_ind*Marshal.SizeOf&<T>), new UIntPtr(to_ind*Marshal.SizeOf&<T>),
          new UIntPtr(len*Marshal.SizeOf&<T>),
          evs.count, evs.evs, res_ev
        );
        OpenCLABCInternalException.RaiseIfError(ec);
        
        Result := new DirectEnqRes(res_ev, nil);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'a: ';
      a.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'from_ind: ';
      from_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'to_ind: ';
      to_ind.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function CLArrayCCQ<T>.ThenCopyFrom(a: CommandQueue<CLArray<T>>; from_ind, to_ind, len: CommandQueue<integer>): CLArrayCCQ<T>;
begin
  Result := AddCommand(self, new CLArrayCommandCopyFrom<T>(a, from_ind, to_ind, len));
end;

{$endregion CopyFrom}

{$endregion 3#Copy}


