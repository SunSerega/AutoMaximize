


{$region 1#Exec}

{$region Exec1}

type
  KernelCommandExec1 = sealed class(EnqueueableGPUCommand<Kernel>)
    private  sz1: CommandQueue<integer>;
    private args: array of KernelArg;
    
    public function EnqEvCapacity: integer; override := 1 + args.Length;
    
    public constructor(sz1: CommandQueue<integer>; params args: array of KernelArg);
    begin
      self. sz1 :=  sz1;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (Kernel, cl_command_queue, CLTaskErrHandler, EventList)->cl_event; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var args_qr: array of QueueRes<ISetableKernelArg>;
      g.ParallelInvoke(l, true, enq_evs.Capacity-1, invoker->
      begin
         sz1_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz1.Invoke); if (sz1_qr is IQueueResConst) then enq_evs.AddL2(sz1_qr.ev) else enq_evs.AddL1(sz1_qr.ev);
        args_qr := args.ConvertAll(temp1->begin Result := invoker.InvokeBranch&<QueueRes<ISetableKernelArg>>(temp1.Invoke); if (Result is IQueueResConst) then enq_evs.AddL2(Result.ev) else enq_evs.AddL1(Result.ev); end);
      end);
      
      Result := (o, cq, err_handler, evs)->
      begin
        var  sz1 :=  sz1_qr.GetRes;
        var args := args_qr.ConvertAll(temp1->temp1.GetRes);
        var res_ev: cl_event;
        
        o.UseExclusiveNative(ntv->
        begin
          
          for var i := 0 to args.Length-1 do
            args[i].SetArg(ntv, i);
          
          cl.EnqueueNDRangeKernel(
            cq, ntv, 1,
            nil,
            new UIntPtr[](new UIntPtr(sz1)),
            nil,
            evs.count, evs.evs, res_ev
          ).RaiseIfError;
          
          cl.RetainKernel(ntv).RaiseIfError;
          var args_hnd := GCHandle.Alloc(args);
          
          EventList.AttachCallback(true, res_ev, ()->
          begin
            cl.ReleaseKernel(ntv).RaiseIfError();
            args_hnd.Free;
          end, err_handler{$ifdef EventDebug}, 'ReleaseKernel'{$endif});
        end);
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
       sz1.RegisterWaitables(g, prev_hubs);
      foreach var temp1 in args do temp1.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1: ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      for var i := 0 to args.Length-1 do 
      begin
        sb.Append(#9, tabs);
        sb += 'args[';
        sb.Append(i);
        sb += ']: ';
        args[i].ToString(sb, tabs, index, delayed, false);
      end;
      
    end;
    
  end;
  
function KernelCCQ.AddExec1(sz1: CommandQueue<integer>; params args: array of KernelArg): KernelCCQ;
begin
  Result := AddCommand(self, new KernelCommandExec1(sz1, args));
end;

{$endregion Exec1}

{$region Exec2}

type
  KernelCommandExec2 = sealed class(EnqueueableGPUCommand<Kernel>)
    private  sz1: CommandQueue<integer>;
    private  sz2: CommandQueue<integer>;
    private args: array of KernelArg;
    
    public function EnqEvCapacity: integer; override := 2 + args.Length;
    
    public constructor(sz1,sz2: CommandQueue<integer>; params args: array of KernelArg);
    begin
      self. sz1 :=  sz1;
      self. sz2 :=  sz2;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (Kernel, cl_command_queue, CLTaskErrHandler, EventList)->cl_event; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var  sz2_qr: QueueRes<integer>;
      var args_qr: array of QueueRes<ISetableKernelArg>;
      g.ParallelInvoke(l, true, enq_evs.Capacity-1, invoker->
      begin
         sz1_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz1.Invoke); if (sz1_qr is IQueueResConst) then enq_evs.AddL2(sz1_qr.ev) else enq_evs.AddL1(sz1_qr.ev);
         sz2_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz2.Invoke); if (sz2_qr is IQueueResConst) then enq_evs.AddL2(sz2_qr.ev) else enq_evs.AddL1(sz2_qr.ev);
        args_qr := args.ConvertAll(temp1->begin Result := invoker.InvokeBranch&<QueueRes<ISetableKernelArg>>(temp1.Invoke); if (Result is IQueueResConst) then enq_evs.AddL2(Result.ev) else enq_evs.AddL1(Result.ev); end);
      end);
      
      Result := (o, cq, err_handler, evs)->
      begin
        var  sz1 :=  sz1_qr.GetRes;
        var  sz2 :=  sz2_qr.GetRes;
        var args := args_qr.ConvertAll(temp1->temp1.GetRes);
        var res_ev: cl_event;
        
        o.UseExclusiveNative(ntv->
        begin
          
          for var i := 0 to args.Length-1 do
            args[i].SetArg(ntv, i);
          
          cl.EnqueueNDRangeKernel(
            cq, ntv, 2,
            nil,
            new UIntPtr[](new UIntPtr(sz1),new UIntPtr(sz2)),
            nil,
            evs.count, evs.evs, res_ev
          ).RaiseIfError;
          
          cl.RetainKernel(ntv).RaiseIfError;
          var args_hnd := GCHandle.Alloc(args);
          
          EventList.AttachCallback(true, res_ev, ()->
          begin
            cl.ReleaseKernel(ntv).RaiseIfError();
            args_hnd.Free;
          end, err_handler{$ifdef EventDebug}, 'ReleaseKernel'{$endif});
        end);
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
       sz1.RegisterWaitables(g, prev_hubs);
       sz2.RegisterWaitables(g, prev_hubs);
      foreach var temp1 in args do temp1.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1: ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz2: ';
      sz2.ToString(sb, tabs, index, delayed, false);
      
      for var i := 0 to args.Length-1 do 
      begin
        sb.Append(#9, tabs);
        sb += 'args[';
        sb.Append(i);
        sb += ']: ';
        args[i].ToString(sb, tabs, index, delayed, false);
      end;
      
    end;
    
  end;
  
function KernelCCQ.AddExec2(sz1,sz2: CommandQueue<integer>; params args: array of KernelArg): KernelCCQ;
begin
  Result := AddCommand(self, new KernelCommandExec2(sz1, sz2, args));
end;

{$endregion Exec2}

{$region Exec3}

type
  KernelCommandExec3 = sealed class(EnqueueableGPUCommand<Kernel>)
    private  sz1: CommandQueue<integer>;
    private  sz2: CommandQueue<integer>;
    private  sz3: CommandQueue<integer>;
    private args: array of KernelArg;
    
    public function EnqEvCapacity: integer; override := 3 + args.Length;
    
    public constructor(sz1,sz2,sz3: CommandQueue<integer>; params args: array of KernelArg);
    begin
      self. sz1 :=  sz1;
      self. sz2 :=  sz2;
      self. sz3 :=  sz3;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (Kernel, cl_command_queue, CLTaskErrHandler, EventList)->cl_event; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var  sz2_qr: QueueRes<integer>;
      var  sz3_qr: QueueRes<integer>;
      var args_qr: array of QueueRes<ISetableKernelArg>;
      g.ParallelInvoke(l, true, enq_evs.Capacity-1, invoker->
      begin
         sz1_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz1.Invoke); if (sz1_qr is IQueueResConst) then enq_evs.AddL2(sz1_qr.ev) else enq_evs.AddL1(sz1_qr.ev);
         sz2_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz2.Invoke); if (sz2_qr is IQueueResConst) then enq_evs.AddL2(sz2_qr.ev) else enq_evs.AddL1(sz2_qr.ev);
         sz3_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz3.Invoke); if (sz3_qr is IQueueResConst) then enq_evs.AddL2(sz3_qr.ev) else enq_evs.AddL1(sz3_qr.ev);
        args_qr := args.ConvertAll(temp1->begin Result := invoker.InvokeBranch&<QueueRes<ISetableKernelArg>>(temp1.Invoke); if (Result is IQueueResConst) then enq_evs.AddL2(Result.ev) else enq_evs.AddL1(Result.ev); end);
      end);
      
      Result := (o, cq, err_handler, evs)->
      begin
        var  sz1 :=  sz1_qr.GetRes;
        var  sz2 :=  sz2_qr.GetRes;
        var  sz3 :=  sz3_qr.GetRes;
        var args := args_qr.ConvertAll(temp1->temp1.GetRes);
        var res_ev: cl_event;
        
        o.UseExclusiveNative(ntv->
        begin
          
          for var i := 0 to args.Length-1 do
            args[i].SetArg(ntv, i);
          
          cl.EnqueueNDRangeKernel(
            cq, ntv, 3,
            nil,
            new UIntPtr[](new UIntPtr(sz1),new UIntPtr(sz2),new UIntPtr(sz3)),
            nil,
            evs.count, evs.evs, res_ev
          ).RaiseIfError;
          
          cl.RetainKernel(ntv).RaiseIfError;
          var args_hnd := GCHandle.Alloc(args);
          
          EventList.AttachCallback(true, res_ev, ()->
          begin
            cl.ReleaseKernel(ntv).RaiseIfError();
            args_hnd.Free;
          end, err_handler{$ifdef EventDebug}, 'ReleaseKernel'{$endif});
        end);
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
       sz1.RegisterWaitables(g, prev_hubs);
       sz2.RegisterWaitables(g, prev_hubs);
       sz3.RegisterWaitables(g, prev_hubs);
      foreach var temp1 in args do temp1.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1: ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz2: ';
      sz2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz3: ';
      sz3.ToString(sb, tabs, index, delayed, false);
      
      for var i := 0 to args.Length-1 do 
      begin
        sb.Append(#9, tabs);
        sb += 'args[';
        sb.Append(i);
        sb += ']: ';
        args[i].ToString(sb, tabs, index, delayed, false);
      end;
      
    end;
    
  end;
  
function KernelCCQ.AddExec3(sz1,sz2,sz3: CommandQueue<integer>; params args: array of KernelArg): KernelCCQ;
begin
  Result := AddCommand(self, new KernelCommandExec3(sz1, sz2, sz3, args));
end;

{$endregion Exec3}

{$region Exec}

type
  KernelCommandExec = sealed class(EnqueueableGPUCommand<Kernel>)
    private global_work_offset: CommandQueue<array of UIntPtr>;
    private   global_work_size: CommandQueue<array of UIntPtr>;
    private    local_work_size: CommandQueue<array of UIntPtr>;
    private               args: array of KernelArg;
    
    public function EnqEvCapacity: integer; override := 3 + args.Length;
    
    public constructor(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of KernelArg);
    begin
      self.global_work_offset := global_work_offset;
      self.  global_work_size :=   global_work_size;
      self.   local_work_size :=    local_work_size;
      self.              args :=               args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (Kernel, cl_command_queue, CLTaskErrHandler, EventList)->cl_event; override;
    begin
      var global_work_offset_qr: QueueRes<array of UIntPtr>;
      var   global_work_size_qr: QueueRes<array of UIntPtr>;
      var    local_work_size_qr: QueueRes<array of UIntPtr>;
      var               args_qr: array of QueueRes<ISetableKernelArg>;
      g.ParallelInvoke(l, true, enq_evs.Capacity-1, invoker->
      begin
        global_work_offset_qr := invoker.InvokeBranch&<QueueRes<array of UIntPtr>>(global_work_offset.Invoke); if (global_work_offset_qr is IQueueResConst) then enq_evs.AddL2(global_work_offset_qr.ev) else enq_evs.AddL1(global_work_offset_qr.ev);
          global_work_size_qr := invoker.InvokeBranch&<QueueRes<array of UIntPtr>>(  global_work_size.Invoke); if (global_work_size_qr is IQueueResConst) then enq_evs.AddL2(global_work_size_qr.ev) else enq_evs.AddL1(global_work_size_qr.ev);
           local_work_size_qr := invoker.InvokeBranch&<QueueRes<array of UIntPtr>>(   local_work_size.Invoke); if (local_work_size_qr is IQueueResConst) then enq_evs.AddL2(local_work_size_qr.ev) else enq_evs.AddL1(local_work_size_qr.ev);
                      args_qr := args.ConvertAll(temp1->begin Result := invoker.InvokeBranch&<QueueRes<ISetableKernelArg>>(temp1.Invoke); if (Result is IQueueResConst) then enq_evs.AddL2(Result.ev) else enq_evs.AddL1(Result.ev); end);
      end);
      
      Result := (o, cq, err_handler, evs)->
      begin
        var global_work_offset := global_work_offset_qr.GetRes;
        var   global_work_size :=   global_work_size_qr.GetRes;
        var    local_work_size :=    local_work_size_qr.GetRes;
        var               args :=               args_qr.ConvertAll(temp1->temp1.GetRes);
        var res_ev: cl_event;
        
        o.UseExclusiveNative(ntv->
        begin
          
          for var i := 0 to args.Length-1 do
            args[i].SetArg(ntv, i);
          
          cl.EnqueueNDRangeKernel(
            cq, ntv, global_work_size.Length,
            global_work_offset,
            global_work_size,
            local_work_size,
            evs.count, evs.evs, res_ev
          ).RaiseIfError;
          
          cl.RetainKernel(ntv).RaiseIfError;
          var args_hnd := GCHandle.Alloc(args);
          
          EventList.AttachCallback(true, res_ev, ()->
          begin
            cl.ReleaseKernel(ntv).RaiseIfError();
            args_hnd.Free;
          end, err_handler{$ifdef EventDebug}, 'ReleaseKernel'{$endif});
        end);
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      global_work_offset.RegisterWaitables(g, prev_hubs);
        global_work_size.RegisterWaitables(g, prev_hubs);
         local_work_size.RegisterWaitables(g, prev_hubs);
      foreach var temp1 in args do temp1.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'global_work_offset: ';
      global_work_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'global_work_size: ';
      global_work_size.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'local_work_size: ';
      local_work_size.ToString(sb, tabs, index, delayed, false);
      
      for var i := 0 to args.Length-1 do 
      begin
        sb.Append(#9, tabs);
        sb += 'args[';
        sb.Append(i);
        sb += ']: ';
        args[i].ToString(sb, tabs, index, delayed, false);
      end;
      
    end;
    
  end;
  
function KernelCCQ.AddExec(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of KernelArg): KernelCCQ;
begin
  Result := AddCommand(self, new KernelCommandExec(global_work_offset, global_work_size, local_work_size, args));
end;

{$endregion Exec}

{$endregion 1#Exec}


