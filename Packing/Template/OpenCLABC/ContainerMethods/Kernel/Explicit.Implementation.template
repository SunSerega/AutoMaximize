


{$region 1#Exec}

{$region Exec1}

type
  KernelCommandExec1 = sealed class(EnqueueableGPUCommand<Kernel>)
    private  sz1: CommandQueue<integer>;
    private args: array of KernelArg;
    
    public function EnqEvCapacity: integer; override := 1 + args.Length;
    
    public constructor(sz1: CommandQueue<integer>; params args: array of KernelArg);
    begin
      self. sz1 :=  sz1;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
       sz1.InitBeforeInvoke(g, prev_hubs);
      foreach var temp1 in args do temp1.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (Kernel, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var args_qr: array of QueueResVal<ISetableKernelArg>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
         sz1_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz1.InvokeToAny); if sz1_qr.IsConst then enq_evs.AddL2(sz1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(sz1_qr.AttachInvokeActions(g));
        args_qr := args.ConvertAll(temp1->begin Result := invoker.InvokeBranch&<QueueResVal<ISetableKernelArg>>(temp1.Invoke); if Result.IsConst then enq_evs.AddL2(Result.AttachInvokeActions(g)) else enq_evs.AddL1(Result.AttachInvokeActions(g)); end);
      end);
      
      Result := (o, cq, evs)->
      begin
        var  sz1 :=  sz1_qr.GetResDirect;
        var args := args_qr.ConvertAll(temp1->temp1.GetResDirect);
        var res_ev: cl_event;
        
        var ntv := o.UseExclusiveNative(ntv->
        begin
          for var i := 0 to args.Length-1 do
            args[i].SetArg(ntv, i);
          
          var ec := cl.EnqueueNDRangeKernel(
            cq, ntv, 1,
            nil,
            new UIntPtr[](new UIntPtr(sz1)),
            nil,
            evs.count, evs.evs, res_ev
          );
          OpenCLABCInternalException.RaiseIfError(ec);
          
          OpenCLABCInternalException.RaiseIfError( cl.RetainKernel(ntv) );
          Result := ntv;
        end);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          OpenCLABCInternalException.RaiseIfError( cl.ReleaseKernel(ntv) );
          GC.KeepAlive(args);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1: ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      for var i := 0 to args.Length-1 do 
      begin
        sb.Append(#9, tabs);
        sb += 'args[';
        sb.Append(i);
        sb += ']: ';
        args[i].ToString(sb, tabs, index, delayed, false);
      end;
      
    end;
    
  end;
  
function KernelCCQ.ThenExec1(sz1: CommandQueue<integer>; params args: array of KernelArg): KernelCCQ;
begin
  Result := AddCommand(self, new KernelCommandExec1(sz1, args));
end;

{$endregion Exec1}

{$region Exec2}

type
  KernelCommandExec2 = sealed class(EnqueueableGPUCommand<Kernel>)
    private  sz1: CommandQueue<integer>;
    private  sz2: CommandQueue<integer>;
    private args: array of KernelArg;
    
    public function EnqEvCapacity: integer; override := 2 + args.Length;
    
    public constructor(sz1,sz2: CommandQueue<integer>; params args: array of KernelArg);
    begin
      self. sz1 :=  sz1;
      self. sz2 :=  sz2;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
       sz1.InitBeforeInvoke(g, prev_hubs);
       sz2.InitBeforeInvoke(g, prev_hubs);
      foreach var temp1 in args do temp1.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (Kernel, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var  sz2_qr: QueueRes<integer>;
      var args_qr: array of QueueResVal<ISetableKernelArg>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
         sz1_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz1.InvokeToAny); if sz1_qr.IsConst then enq_evs.AddL2(sz1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(sz1_qr.AttachInvokeActions(g));
         sz2_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz2.InvokeToAny); if sz2_qr.IsConst then enq_evs.AddL2(sz2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(sz2_qr.AttachInvokeActions(g));
        args_qr := args.ConvertAll(temp1->begin Result := invoker.InvokeBranch&<QueueResVal<ISetableKernelArg>>(temp1.Invoke); if Result.IsConst then enq_evs.AddL2(Result.AttachInvokeActions(g)) else enq_evs.AddL1(Result.AttachInvokeActions(g)); end);
      end);
      
      Result := (o, cq, evs)->
      begin
        var  sz1 :=  sz1_qr.GetResDirect;
        var  sz2 :=  sz2_qr.GetResDirect;
        var args := args_qr.ConvertAll(temp1->temp1.GetResDirect);
        var res_ev: cl_event;
        
        var ntv := o.UseExclusiveNative(ntv->
        begin
          for var i := 0 to args.Length-1 do
            args[i].SetArg(ntv, i);
          
          var ec := cl.EnqueueNDRangeKernel(
            cq, ntv, 2,
            nil,
            new UIntPtr[](new UIntPtr(sz1),new UIntPtr(sz2)),
            nil,
            evs.count, evs.evs, res_ev
          );
          OpenCLABCInternalException.RaiseIfError(ec);
          
          OpenCLABCInternalException.RaiseIfError( cl.RetainKernel(ntv) );
          Result := ntv;
        end);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          OpenCLABCInternalException.RaiseIfError( cl.ReleaseKernel(ntv) );
          GC.KeepAlive(args);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1: ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz2: ';
      sz2.ToString(sb, tabs, index, delayed, false);
      
      for var i := 0 to args.Length-1 do 
      begin
        sb.Append(#9, tabs);
        sb += 'args[';
        sb.Append(i);
        sb += ']: ';
        args[i].ToString(sb, tabs, index, delayed, false);
      end;
      
    end;
    
  end;
  
function KernelCCQ.ThenExec2(sz1,sz2: CommandQueue<integer>; params args: array of KernelArg): KernelCCQ;
begin
  Result := AddCommand(self, new KernelCommandExec2(sz1, sz2, args));
end;

{$endregion Exec2}

{$region Exec3}

type
  KernelCommandExec3 = sealed class(EnqueueableGPUCommand<Kernel>)
    private  sz1: CommandQueue<integer>;
    private  sz2: CommandQueue<integer>;
    private  sz3: CommandQueue<integer>;
    private args: array of KernelArg;
    
    public function EnqEvCapacity: integer; override := 3 + args.Length;
    
    public constructor(sz1,sz2,sz3: CommandQueue<integer>; params args: array of KernelArg);
    begin
      self. sz1 :=  sz1;
      self. sz2 :=  sz2;
      self. sz3 :=  sz3;
      self.args := args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
       sz1.InitBeforeInvoke(g, prev_hubs);
       sz2.InitBeforeInvoke(g, prev_hubs);
       sz3.InitBeforeInvoke(g, prev_hubs);
      foreach var temp1 in args do temp1.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (Kernel, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var  sz1_qr: QueueRes<integer>;
      var  sz2_qr: QueueRes<integer>;
      var  sz3_qr: QueueRes<integer>;
      var args_qr: array of QueueResVal<ISetableKernelArg>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
         sz1_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz1.InvokeToAny); if sz1_qr.IsConst then enq_evs.AddL2(sz1_qr.AttachInvokeActions(g)) else enq_evs.AddL1(sz1_qr.AttachInvokeActions(g));
         sz2_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz2.InvokeToAny); if sz2_qr.IsConst then enq_evs.AddL2(sz2_qr.AttachInvokeActions(g)) else enq_evs.AddL1(sz2_qr.AttachInvokeActions(g));
         sz3_qr := invoker.InvokeBranch&<QueueRes<integer>>( sz3.InvokeToAny); if sz3_qr.IsConst then enq_evs.AddL2(sz3_qr.AttachInvokeActions(g)) else enq_evs.AddL1(sz3_qr.AttachInvokeActions(g));
        args_qr := args.ConvertAll(temp1->begin Result := invoker.InvokeBranch&<QueueResVal<ISetableKernelArg>>(temp1.Invoke); if Result.IsConst then enq_evs.AddL2(Result.AttachInvokeActions(g)) else enq_evs.AddL1(Result.AttachInvokeActions(g)); end);
      end);
      
      Result := (o, cq, evs)->
      begin
        var  sz1 :=  sz1_qr.GetResDirect;
        var  sz2 :=  sz2_qr.GetResDirect;
        var  sz3 :=  sz3_qr.GetResDirect;
        var args := args_qr.ConvertAll(temp1->temp1.GetResDirect);
        var res_ev: cl_event;
        
        var ntv := o.UseExclusiveNative(ntv->
        begin
          for var i := 0 to args.Length-1 do
            args[i].SetArg(ntv, i);
          
          var ec := cl.EnqueueNDRangeKernel(
            cq, ntv, 3,
            nil,
            new UIntPtr[](new UIntPtr(sz1),new UIntPtr(sz2),new UIntPtr(sz3)),
            nil,
            evs.count, evs.evs, res_ev
          );
          OpenCLABCInternalException.RaiseIfError(ec);
          
          OpenCLABCInternalException.RaiseIfError( cl.RetainKernel(ntv) );
          Result := ntv;
        end);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          OpenCLABCInternalException.RaiseIfError( cl.ReleaseKernel(ntv) );
          GC.KeepAlive(args);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'sz1: ';
      sz1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz2: ';
      sz2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'sz3: ';
      sz3.ToString(sb, tabs, index, delayed, false);
      
      for var i := 0 to args.Length-1 do 
      begin
        sb.Append(#9, tabs);
        sb += 'args[';
        sb.Append(i);
        sb += ']: ';
        args[i].ToString(sb, tabs, index, delayed, false);
      end;
      
    end;
    
  end;
  
function KernelCCQ.ThenExec3(sz1,sz2,sz3: CommandQueue<integer>; params args: array of KernelArg): KernelCCQ;
begin
  Result := AddCommand(self, new KernelCommandExec3(sz1, sz2, sz3, args));
end;

{$endregion Exec3}

{$region Exec}

type
  KernelCommandExec = sealed class(EnqueueableGPUCommand<Kernel>)
    private global_work_offset: CommandQueue<array of UIntPtr>;
    private   global_work_size: CommandQueue<array of UIntPtr>;
    private    local_work_size: CommandQueue<array of UIntPtr>;
    private               args: array of KernelArg;
    
    public function EnqEvCapacity: integer; override := 3 + args.Length;
    
    public constructor(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of KernelArg);
    begin
      self.global_work_offset := global_work_offset;
      self.  global_work_size :=   global_work_size;
      self.   local_work_size :=    local_work_size;
      self.              args :=               args;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected procedure InitBeforeInvoke(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      global_work_offset.InitBeforeInvoke(g, prev_hubs);
        global_work_size.InitBeforeInvoke(g, prev_hubs);
         local_work_size.InitBeforeInvoke(g, prev_hubs);
      foreach var temp1 in args do temp1.InitBeforeInvoke(g, prev_hubs);
    end;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; enq_evs: EnqEvLst): (Kernel, cl_command_queue, EventList)->DirectEnqRes; override;
    begin
      var global_work_offset_qr: QueueRes<array of UIntPtr>;
      var   global_work_size_qr: QueueRes<array of UIntPtr>;
      var    local_work_size_qr: QueueRes<array of UIntPtr>;
      var               args_qr: array of QueueResVal<ISetableKernelArg>;
      g.ParallelInvoke(nil, enq_evs.Capacity-1, invoker->
      begin
        global_work_offset_qr := invoker.InvokeBranch&<QueueRes<array of UIntPtr>>(global_work_offset.InvokeToAny); if global_work_offset_qr.IsConst then enq_evs.AddL2(global_work_offset_qr.AttachInvokeActions(g)) else enq_evs.AddL1(global_work_offset_qr.AttachInvokeActions(g));
          global_work_size_qr := invoker.InvokeBranch&<QueueRes<array of UIntPtr>>(  global_work_size.InvokeToAny); if global_work_size_qr.IsConst then enq_evs.AddL2(global_work_size_qr.AttachInvokeActions(g)) else enq_evs.AddL1(global_work_size_qr.AttachInvokeActions(g));
           local_work_size_qr := invoker.InvokeBranch&<QueueRes<array of UIntPtr>>(   local_work_size.InvokeToAny); if local_work_size_qr.IsConst then enq_evs.AddL2(local_work_size_qr.AttachInvokeActions(g)) else enq_evs.AddL1(local_work_size_qr.AttachInvokeActions(g));
                      args_qr := args.ConvertAll(temp1->begin Result := invoker.InvokeBranch&<QueueResVal<ISetableKernelArg>>(temp1.Invoke); if Result.IsConst then enq_evs.AddL2(Result.AttachInvokeActions(g)) else enq_evs.AddL1(Result.AttachInvokeActions(g)); end);
      end);
      
      Result := (o, cq, evs)->
      begin
        var global_work_offset := global_work_offset_qr.GetResDirect;
        var   global_work_size :=   global_work_size_qr.GetResDirect;
        var    local_work_size :=    local_work_size_qr.GetResDirect;
        var               args :=               args_qr.ConvertAll(temp1->temp1.GetResDirect);
        var res_ev: cl_event;
        
        var ntv := o.UseExclusiveNative(ntv->
        begin
          for var i := 0 to args.Length-1 do
            args[i].SetArg(ntv, i);
          
          var ec := cl.EnqueueNDRangeKernel(
            cq, ntv, global_work_size.Length,
            global_work_offset,
            global_work_size,
            local_work_size,
            evs.count, evs.evs, res_ev
          );
          OpenCLABCInternalException.RaiseIfError(ec);
          
          OpenCLABCInternalException.RaiseIfError( cl.RetainKernel(ntv) );
          Result := ntv;
        end);
        
        Result := new DirectEnqRes(res_ev, c->
        begin
          OpenCLABCInternalException.RaiseIfError( cl.ReleaseKernel(ntv) );
          GC.KeepAlive(args);
        end);
      end;
      
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'global_work_offset: ';
      global_work_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'global_work_size: ';
      global_work_size.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'local_work_size: ';
      local_work_size.ToString(sb, tabs, index, delayed, false);
      
      for var i := 0 to args.Length-1 do 
      begin
        sb.Append(#9, tabs);
        sb += 'args[';
        sb.Append(i);
        sb += ']: ';
        args[i].ToString(sb, tabs, index, delayed, false);
      end;
      
    end;
    
  end;
  
function KernelCCQ.ThenExec(global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of KernelArg): KernelCCQ;
begin
  Result := AddCommand(self, new KernelCommandExec(global_work_offset, global_work_size, local_work_size, args));
end;

{$endregion Exec}

{$endregion 1#Exec}


