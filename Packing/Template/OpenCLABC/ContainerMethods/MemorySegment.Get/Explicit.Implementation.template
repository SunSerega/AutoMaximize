


{$region Get}

{$region GetDataAutoSize}

type
  MemorySegmentCommandGetDataAutoSize = sealed class(EnqueueableGetCommand<MemorySegment, IntPtr>)
    
    public function EnqEvCapacity: integer; override := 0;
    
    public constructor(ccq: MemorySegmentCCQ);
    begin
      inherited Create(ccq);
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (MemorySegment, cl_command_queue, CLTaskErrHandler, EventList, QueueResDelayedBase<IntPtr>)->cl_event; override;
    begin
      
      Result := (o, cq, err_handler, evs, own_qr)->
      begin
        var res := Marshal.AllocHGlobal(IntPtr(pointer(o.Size)));;
        own_qr.SetRes(res);
        var res_ev: cl_event;
        
        //TODO А что если результат уже получен и освобождёт сдедующей .ThenConvert
        // - Вообще .WhenError тут (и в +1 месте) - говнокод
        // - Лучше стоит сделать обёртку вроде SafeIntPtr (или использовать готовую)
        //tsk.WhenErrorBase((tsk,err)->Marshal.FreeHGlobal(res));
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          UIntPtr.Zero, o.Size,
          res,
          evs.count, evs.evs, res_ev
        );
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override := sb += #10;
    
  end;
  
function MemorySegmentCCQ.AddGetData: CommandQueue<IntPtr> :=
new MemorySegmentCommandGetDataAutoSize(self) as CommandQueue<IntPtr>;

{$endregion GetDataAutoSize}

{$region GetData}

type
  MemorySegmentCommandGetData = sealed class(EnqueueableGetCommand<MemorySegment, IntPtr>)
    private mem_offset: CommandQueue<integer>;
    private        len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    public constructor(ccq: MemorySegmentCCQ; mem_offset, len: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.mem_offset := mem_offset;
      self.       len :=        len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (MemorySegment, cl_command_queue, CLTaskErrHandler, EventList, QueueResDelayedBase<IntPtr>)->cl_event; override;
    begin
      var mem_offset_qr: QueueRes<integer>;
      var        len_qr: QueueRes<integer>;
      g.ParallelInvoke(l.WithPtrNeed(False), true, enq_evs.Capacity-1, invoker->
      begin
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.Invoke); if (mem_offset_qr is IQueueResConst) then enq_evs.AddL2(mem_offset_qr.ev) else enq_evs.AddL1(mem_offset_qr.ev);
               len_qr := invoker.InvokeBranch&<QueueRes<integer>>(       len.Invoke); if (len_qr is IQueueResConst) then enq_evs.AddL2(len_qr.ev) else enq_evs.AddL1(len_qr.ev);
      end);
      
      Result := (o, cq, err_handler, evs, own_qr)->
      begin
        var mem_offset := mem_offset_qr.GetRes;
        var        len :=        len_qr.GetRes;
        var res := Marshal.AllocHGlobal(len);
        own_qr.SetRes(res);
        var res_ev: cl_event;
        
        //tsk.WhenErrorBase((tsk,err)->Marshal.FreeHGlobal(res));
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(len),
          res,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      mem_offset.RegisterWaitables(g, prev_hubs);
             len.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem_offset: ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function MemorySegmentCCQ.AddGetData(mem_offset, len: CommandQueue<integer>): CommandQueue<IntPtr> :=
new MemorySegmentCommandGetData(self, mem_offset, len) as CommandQueue<IntPtr>;

{$endregion GetData}

{$region GetValue}

function MemorySegmentCCQ.AddGetValue<TRecord>: CommandQueue<TRecord> :=
AddGetValue&<TRecord>(0);

{$endregion GetValue}

{$region GetValue}

type
  MemorySegmentCommandGetValue<TRecord> = sealed class(EnqueueableGetCommand<MemorySegment, TRecord>)
  where TRecord: record;
    private mem_offset: CommandQueue<integer>;
    
    public function ForcePtrQr: boolean; override := true;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:MemorySegment:GetValue%');
    end;
    public constructor(ccq: MemorySegmentCCQ; mem_offset: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.mem_offset := mem_offset;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (MemorySegment, cl_command_queue, CLTaskErrHandler, EventList, QueueResDelayedBase<TRecord>)->cl_event; override;
    begin
      var mem_offset_qr: QueueRes<integer>;
      g.ParallelInvoke(l.WithPtrNeed(False), true, enq_evs.Capacity-1, invoker->
      begin
        mem_offset_qr := invoker.InvokeBranch&<QueueRes<integer>>(mem_offset.Invoke); if (mem_offset_qr is IQueueResConst) then enq_evs.AddL2(mem_offset_qr.ev) else enq_evs.AddL1(mem_offset_qr.ev);
      end);
      
      Result := (o, cq, err_handler, evs, own_qr)->
      begin
        var mem_offset := mem_offset_qr.GetRes;
        var res_ev: cl_event;
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(mem_offset), new UIntPtr(Marshal.SizeOf&<TRecord>),
          new IntPtr((own_qr as QueueResDelayedPtr<TRecord>).ptr),
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        var own_qr_hnd := GCHandle.Alloc(own_qr);
        
        EventList.AttachCallback(true, res_ev, ()->
        begin
          own_qr_hnd.Free;
        end, err_handler{$ifdef EventDebug}, 'GCHandle.Free for [own_qr]'{$endif});
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      mem_offset.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'mem_offset: ';
      mem_offset.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function MemorySegmentCCQ.AddGetValue<TRecord>(mem_offset: CommandQueue<integer>): CommandQueue<TRecord> :=
new MemorySegmentCommandGetValue<TRecord>(self, mem_offset) as CommandQueue<TRecord>;

{$endregion GetValue}

{$region GetArray1AutoSize}

type
  MemorySegmentCommandGetArray1AutoSize<TRecord> = sealed class(EnqueueableGetCommand<MemorySegment, array of TRecord>)
  where TRecord: record;
    
    public function EnqEvCapacity: integer; override := 0;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:MemorySegment:GetArray1AutoSize%');
    end;
    public constructor(ccq: MemorySegmentCCQ);
    begin
      inherited Create(ccq);
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (MemorySegment, cl_command_queue, CLTaskErrHandler, EventList, QueueResDelayedBase<array of TRecord>)->cl_event; override;
    begin
      
      Result := (o, cq, err_handler, evs, own_qr)->
      begin
        var res := new TRecord[o.Size64 div Marshal.SizeOf&<TRecord>];;
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(res.Length * Marshal.SizeOf&<TRecord>),
          res_hnd.AddrOfPinnedObject,
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        EventList.AttachCallback(true, res_ev, ()->
        begin
          res_hnd.Free;
        end, err_handler{$ifdef EventDebug}, 'GCHandle.Free for [res]'{$endif});
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override := exit;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override := sb += #10;
    
  end;
  
function MemorySegmentCCQ.AddGetArray1<TRecord>: CommandQueue<array of TRecord> :=
new MemorySegmentCommandGetArray1AutoSize<TRecord>(self) as CommandQueue<array of TRecord>;

{$endregion GetArray1AutoSize}

{$region GetArray1}

type
  MemorySegmentCommandGetArray1<TRecord> = sealed class(EnqueueableGetCommand<MemorySegment, array of TRecord>)
  where TRecord: record;
    private len: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 1;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:MemorySegment:GetArray1%');
    end;
    public constructor(ccq: MemorySegmentCCQ; len: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len := len;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (MemorySegment, cl_command_queue, CLTaskErrHandler, EventList, QueueResDelayedBase<array of TRecord>)->cl_event; override;
    begin
      var len_qr: QueueRes<integer>;
      g.ParallelInvoke(l.WithPtrNeed(False), true, enq_evs.Capacity-1, invoker->
      begin
        len_qr := invoker.InvokeBranch&<QueueRes<integer>>(len.Invoke); if (len_qr is IQueueResConst) then enq_evs.AddL2(len_qr.ev) else enq_evs.AddL1(len_qr.ev);
      end);
      
      Result := (o, cq, err_handler, evs, own_qr)->
      begin
        var len := len_qr.GetRes;
        var res := new TRecord[len];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(int64(len) * Marshal.SizeOf&<TRecord>),
          res[0],
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        EventList.AttachCallback(true, res_ev, ()->
        begin
          res_hnd.Free;
        end, err_handler{$ifdef EventDebug}, 'GCHandle.Free for [res]'{$endif});
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      len.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len: ';
      len.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function MemorySegmentCCQ.AddGetArray1<TRecord>(len: CommandQueue<integer>): CommandQueue<array of TRecord> :=
new MemorySegmentCommandGetArray1<TRecord>(self, len) as CommandQueue<array of TRecord>;

{$endregion GetArray1}

{$region GetArray2}

type
  MemorySegmentCommandGetArray2<TRecord> = sealed class(EnqueueableGetCommand<MemorySegment, array[,] of TRecord>)
  where TRecord: record;
    private len1: CommandQueue<integer>;
    private len2: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 2;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:MemorySegment:GetArray2%');
    end;
    public constructor(ccq: MemorySegmentCCQ; len1,len2: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len1 := len1;
      self.len2 := len2;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (MemorySegment, cl_command_queue, CLTaskErrHandler, EventList, QueueResDelayedBase<array[,] of TRecord>)->cl_event; override;
    begin
      var len1_qr: QueueRes<integer>;
      var len2_qr: QueueRes<integer>;
      g.ParallelInvoke(l.WithPtrNeed(False), true, enq_evs.Capacity-1, invoker->
      begin
        len1_qr := invoker.InvokeBranch&<QueueRes<integer>>(len1.Invoke); if (len1_qr is IQueueResConst) then enq_evs.AddL2(len1_qr.ev) else enq_evs.AddL1(len1_qr.ev);
        len2_qr := invoker.InvokeBranch&<QueueRes<integer>>(len2.Invoke); if (len2_qr is IQueueResConst) then enq_evs.AddL2(len2_qr.ev) else enq_evs.AddL1(len2_qr.ev);
      end);
      
      Result := (o, cq, err_handler, evs, own_qr)->
      begin
        var len1 := len1_qr.GetRes;
        var len2 := len2_qr.GetRes;
        var res := new TRecord[len1,len2];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(int64(len1)*len2 * Marshal.SizeOf&<TRecord>),
          res[0,0],
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        EventList.AttachCallback(true, res_ev, ()->
        begin
          res_hnd.Free;
        end, err_handler{$ifdef EventDebug}, 'GCHandle.Free for [res]'{$endif});
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      len1.RegisterWaitables(g, prev_hubs);
      len2.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len1: ';
      len1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len2: ';
      len2.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function MemorySegmentCCQ.AddGetArray2<TRecord>(len1,len2: CommandQueue<integer>): CommandQueue<array[,] of TRecord> :=
new MemorySegmentCommandGetArray2<TRecord>(self, len1, len2) as CommandQueue<array[,] of TRecord>;

{$endregion GetArray2}

{$region GetArray3}

type
  MemorySegmentCommandGetArray3<TRecord> = sealed class(EnqueueableGetCommand<MemorySegment, array[,,] of TRecord>)
  where TRecord: record;
    private len1: CommandQueue<integer>;
    private len2: CommandQueue<integer>;
    private len3: CommandQueue<integer>;
    
    public function EnqEvCapacity: integer; override := 3;
    
    static constructor;
    begin
      BlittableHelper.RaiseIfBad(typeof(TRecord), '%Err:Blittable:Source:MemorySegment:GetArray3%');
    end;
    public constructor(ccq: MemorySegmentCCQ; len1,len2,len3: CommandQueue<integer>);
    begin
      inherited Create(ccq);
      self.len1 := len1;
      self.len2 := len2;
      self.len3 := len3;
    end;
    private constructor := raise new System.InvalidOperationException;
    
    protected function InvokeParamsImpl(g: CLTaskGlobalData; l: CLTaskLocalData; enq_evs: EnqEvLst): (MemorySegment, cl_command_queue, CLTaskErrHandler, EventList, QueueResDelayedBase<array[,,] of TRecord>)->cl_event; override;
    begin
      var len1_qr: QueueRes<integer>;
      var len2_qr: QueueRes<integer>;
      var len3_qr: QueueRes<integer>;
      g.ParallelInvoke(l.WithPtrNeed(False), true, enq_evs.Capacity-1, invoker->
      begin
        len1_qr := invoker.InvokeBranch&<QueueRes<integer>>(len1.Invoke); if (len1_qr is IQueueResConst) then enq_evs.AddL2(len1_qr.ev) else enq_evs.AddL1(len1_qr.ev);
        len2_qr := invoker.InvokeBranch&<QueueRes<integer>>(len2.Invoke); if (len2_qr is IQueueResConst) then enq_evs.AddL2(len2_qr.ev) else enq_evs.AddL1(len2_qr.ev);
        len3_qr := invoker.InvokeBranch&<QueueRes<integer>>(len3.Invoke); if (len3_qr is IQueueResConst) then enq_evs.AddL2(len3_qr.ev) else enq_evs.AddL1(len3_qr.ev);
      end);
      
      Result := (o, cq, err_handler, evs, own_qr)->
      begin
        var len1 := len1_qr.GetRes;
        var len2 := len2_qr.GetRes;
        var len3 := len3_qr.GetRes;
        var res := new TRecord[len1,len2,len3];
        own_qr.SetRes(res);
        var res_hnd := GCHandle.Alloc(res, GCHandleType.Pinned);
        
        var res_ev: cl_event;
        
        cl.EnqueueReadBuffer(
          cq, o.Native, Bool.NON_BLOCKING,
          new UIntPtr(0), new UIntPtr(int64(len1)*len2*len3 * Marshal.SizeOf&<TRecord>),
          res[0,0,0],
          evs.count, evs.evs, res_ev
        ).RaiseIfError;
        
        EventList.AttachCallback(true, res_ev, ()->
        begin
          res_hnd.Free;
        end, err_handler{$ifdef EventDebug}, 'GCHandle.Free for [res]'{$endif});
        
        Result := res_ev;
      end;
      
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      len1.RegisterWaitables(g, prev_hubs);
      len2.RegisterWaitables(g, prev_hubs);
      len3.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<CommandQueueBase,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      
      sb.Append(#9, tabs);
      sb += 'len1: ';
      len1.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len2: ';
      len2.ToString(sb, tabs, index, delayed, false);
      
      sb.Append(#9, tabs);
      sb += 'len3: ';
      len3.ToString(sb, tabs, index, delayed, false);
      
    end;
    
  end;
  
function MemorySegmentCCQ.AddGetArray3<TRecord>(len1,len2,len3: CommandQueue<integer>): CommandQueue<array[,,] of TRecord> :=
new MemorySegmentCommandGetArray3<TRecord>(self, len1, len2, len3) as CommandQueue<array[,,] of TRecord>;

{$endregion GetArray3}

{$endregion Get}


