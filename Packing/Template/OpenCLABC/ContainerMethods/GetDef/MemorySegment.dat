


# GetData!AutoSize
!ResultType
IntPtr
!SetRes
Marshal.AllocHGlobal(IntPtr(pointer(o.Size)));
!Enqueue
//TODO А что если результат уже получен и освобождёт сдедующей .ThenConvert
// - Вообще .WhenError тут (и в +1 месте) - говнокод
// - Лучше стоит сделать обёртку вроде SafeIntPtr (или использовать готовую)
//tsk.WhenErrorBase((tsk,err)->Marshal.FreeHGlobal(res));
cl.EnqueueReadBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  UIntPtr.Zero, o.Size,
  !res!,
  !evs!
);

# GetData
mem_offset, len: CommandQueue<integer>
!ResultType
IntPtr
!SetRes
Marshal.AllocHGlobal(!len!)
!Enqueue
//tsk.WhenErrorBase((tsk,err)->Marshal.FreeHGlobal(res));
var ec := cl.EnqueueReadBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), new UIntPtr(!len!),
  !res!,
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);



# GetValue
!ResultType
TRecord
!ShortDef
GetValue&<TRecord>(0);

# GetValue
mem_offset: CommandQueue<integer>
!ResultType
TRecord
!Enqueue
var ec := cl.EnqueueReadBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  new IntPtr(!res_ptr!),
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);
!ForcePtrQr



# GetArray1!AutoSize
!ResultType
array of TRecord
!SetRes
new TRecord[o.Size64 div Marshal.SizeOf&<TRecord>];
!PinnRes
!Enqueue
var ec := cl.EnqueueReadBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(0), new UIntPtr(!res!.Length * Marshal.SizeOf&<TRecord>),
  !res_pinn_adr!,
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);

# GetArray[%rank:1,2,3%]
{%rank? len : len1,len2 : len1,len2,len3 %}: CommandQueue<integer>
!ResultType
array{%rank? : [,] : [,,] %} of TRecord
!SetRes
new TRecord[{%rank? !len! : !len1!,!len2! : !len1!,!len2!,!len3! %}]
!PinnRes
!Enqueue
var ec := cl.EnqueueReadBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(0), new UIntPtr({%rank? int64(!len!) : int64(!len1!)*!len2! : int64(!len1!)*!len2!*!len3! %} * Marshal.SizeOf&<TRecord>),
  !res![{%rank? 0 : 0,0 : 0,0,0 %}],
  !evs!
);
OpenCLABCInternalException.RaiseIfError(ec);


