


# Exec[%dims:1,2,3%]
{%dims? sz1 : sz1,sz2 : sz1,sz2,sz3 %}: CommandQueue<integer>; params args: array of KernelArg
!Enqueue
var ntv := o.UseExclusiveNative(ntv->
begin
  for var i := 0 to !args!.Length-1 do
    !args![i].SetArg(ntv, i);
  
  var ec := cl.EnqueueNDRangeKernel(
    cq, ntv, {%dims%},
    nil,
    new UIntPtr[](new UIntPtr(!sz1!){%dims?: ,new UIntPtr(!sz2!) : ,new UIntPtr(!sz2!),new UIntPtr(!sz3!) %}),
    nil,
    !evs!
  );
  OpenCLABCInternalException.RaiseIfError(ec);
  
  OpenCLABCInternalException.RaiseIfError( cl.RetainKernel(ntv) );
  Result := ntv;
end);

!AttachCallback
OpenCLABCInternalException.RaiseIfError( cl.ReleaseKernel(ntv) );
GC.KeepAlive(args);



# Exec
global_work_offset, global_work_size, local_work_size: CommandQueue<array of UIntPtr>; params args: array of KernelArg
!Enqueue
var ntv := o.UseExclusiveNative(ntv->
begin
  for var i := 0 to !args!.Length-1 do
    !args![i].SetArg(ntv, i);
  
  var ec := cl.EnqueueNDRangeKernel(
    cq, ntv, !global_work_size!.Length,
    !global_work_offset!,
    !global_work_size!,
    !local_work_size!,
    !evs!
  );
  OpenCLABCInternalException.RaiseIfError(ec);
  
  OpenCLABCInternalException.RaiseIfError( cl.RetainKernel(ntv) );
  Result := ntv;
end);

!AttachCallback
OpenCLABCInternalException.RaiseIfError( cl.ReleaseKernel(ntv) );
GC.KeepAlive(args);


