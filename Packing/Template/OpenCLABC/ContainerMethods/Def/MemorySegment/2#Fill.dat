


# FillData![%AutoSize:AutoSize,%]
ptr: CommandQueue<IntPtr>; pattern_len{%AutoSize?:, mem_offset, len%}: CommandQueue<integer>
!Enqueue
cl.EnqueueFillBuffer(
  cq, o.Native,
  !ptr!, new UIntPtr(!pattern_len!),
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!len!) %},
  !evs!
).RaiseIfError;



# FillValue![%AutoSize:AutoSize,%][%Q:,Q%]
val: {%Q?TRecord:CommandQueue<TRecord>%}{%AutoSize?:; mem_offset, len\: CommandQueue<integer>%}
!Enqueue
cl.EnqueueFillBuffer(
  cq, o.Native,
  new IntPtr(!val:ptr!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!len!) %},
  !evs!
).RaiseIfError;



# FillArray[%rank:1,2,3%]!AutoSize
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>
!Enqueue
//TODO unable to merge this Enqueue with non-AutoSize, because %rank would be nested in %AutoSize
cl.EnqueueFillBuffer(
  cq, o.Native,
  !a:pinn![{%rank? 0 : 0,0 : 0,0,0 %}], new UIntPtr(!a:pinn!.Length*Marshal.SizeOf&<TRecord>),
  UIntPtr.Zero, o.Size,
  !evs!
).RaiseIfError;

# FillArray[%rank:1,2,3%]
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>; {%rank? a_offset : a_offset1,a_offset2 : a_offset1,a_offset2,a_offset3 %}, pattern_len, len, mem_offset: CommandQueue<integer>
!Enqueue
cl.EnqueueFillBuffer(
  cq, o.Native,
  !a:pinn![{%rank? !a_offset! : !a_offset1!,!a_offset2! : !a_offset1!,!a_offset2!,!a_offset3! %}], new UIntPtr(!pattern_len!),
  new UIntPtr(!mem_offset!), new UIntPtr(!len!*Marshal.SizeOf&<TRecord>),
  !evs!
).RaiseIfError;


