


# [%mode:Write,Read%]Data![%AutoSize:AutoSize,%]
ptr: CommandQueue<IntPtr>{%AutoSize?:; mem_offset, len\: CommandQueue<integer>%}
!Enqueue
cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  {%AutoSize? UIntPtr.Zero, o.Size : new UIntPtr(!mem_offset!), new UIntPtr(!len!) %},
  !ptr!,
  !evs!
).RaiseIfError;

# [%mode:Write,Read%]Data![%AutoSize:AutoSize,%]
ptr: pointer{%AutoSize?:; mem_offset, len\: CommandQueue<integer>%}
!ShortDef
{%mode%}Data(IntPtr(ptr){%AutoSize?:, mem_offset, len%});



# WriteValue![%Q:,Q%]
val: {%Q?TRecord:CommandQueue<TRecord>%}
!ShortDef
WriteValue(val, 0);

# WriteValue![%Q:,Q%]
val: {%Q?TRecord:CommandQueue<TRecord>%}; mem_offset: CommandQueue<integer>
!Enqueue
cl.EnqueueWriteBuffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), new UIntPtr(Marshal.SizeOf&<TRecord>),
  new IntPtr(!val:ptr!),
  !evs!
).RaiseIfError;



# [%mode:Write,Read%]Array[%rank:1,2,3%]!AutoSize
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>
!Enqueue
//TODO unable to merge this Enqueue with non-AutoSize, because %rank would be nested in %AutoSize
cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  UIntPtr.Zero, new UIntPtr(!a:pinn!.Length*Marshal.SizeOf&<TRecord>),
  !a:pinn![{%rank? 0 : 0,0 : 0,0,0 %}],
  !evs!
).RaiseIfError;

# [%mode:Write,Read%]Array[%rank:1,2,3%]
a: CommandQueue<array{%rank? : [,] : [,,] %} of TRecord>; {%rank? a_offset : a_offset1,a_offset2 : a_offset1,a_offset2,a_offset3 %}, len, mem_offset: CommandQueue<integer>
!Enqueue
cl.Enqueue{%mode%}Buffer(
  cq, o.Native, Bool.NON_BLOCKING,
  new UIntPtr(!mem_offset!), new UIntPtr(!len!*Marshal.SizeOf&<TRecord>),
  !a:pinn![{%rank? !a_offset! : !a_offset1!,!a_offset2! : !a_offset1!,!a_offset2!,!a_offset3! %}],
  !evs!
).RaiseIfError;


