


type
  BackgroundConvQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, TFunc> = abstract class(HostQueue<ValueTuple<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>, TRes>)
  where TFunc: Delegate;
    protected q1: CommandQueue<TInp1>;
    protected q2: CommandQueue<TInp2>;
    protected q3: CommandQueue<TInp3>;
    protected q4: CommandQueue<TInp4>;
    protected q5: CommandQueue<TInp5>;
    protected q6: CommandQueue<TInp6>;
    protected f: TFunc;
    
    public constructor(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; f: TFunc);
    begin
      self.q1 := q1;
      self.q2 := q2;
      self.q3 := q3;
      self.q4 := q4;
      self.q5 := q5;
      self.q6 := q6;
      self.f := f;
    end;
    private constructor := raise new InvalidOperationException($'%Err:NoParamCtor%');
    
    protected function CombineQRs(qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; ev: EventList): QueueRes<ValueTuple<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>;
    begin
      if qr1.IsConst and qr2.IsConst and qr3.IsConst and qr4.IsConst and qr5.IsConst and qr6.IsConst then
      begin
        var res := ValueTuple.Create(qr1.GetResImpl, qr2.GetResImpl, qr3.GetResImpl, qr4.GetResImpl, qr5.GetResImpl, qr6.GetResImpl);
        Result := new QueueResVal<ValueTuple<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(ev, res);
      end else
        Result := new QueueResVal<ValueTuple<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>(ev);
        Result.AddResSetter(()->ValueTuple.Create(qr1.GetResImpl, qr2.GetResImpl, qr3.GetResImpl, qr4.GetResImpl, qr5.GetResImpl, qr6.GetResImpl));
    end;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      self.q1.RegisterWaitables(g, prev_hubs);
      self.q2.RegisterWaitables(g, prev_hubs);
      self.q3.RegisterWaitables(g, prev_hubs);
      self.q4.RegisterWaitables(g, prev_hubs);
      self.q5.RegisterWaitables(g, prev_hubs);
      self.q6.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      self.q1.ToString(sb, tabs, index, delayed);
      self.q2.ToString(sb, tabs, index, delayed);
      self.q3.ToString(sb, tabs, index, delayed);
      self.q4.ToString(sb, tabs, index, delayed);
      self.q5.ToString(sb, tabs, index, delayed);
      self.q6.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  QuickConvQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, TFunc> = abstract class(CommandQueue<TRes>)
  where TFunc: Delegate;
    protected q1: CommandQueue<TInp1>;
    protected q2: CommandQueue<TInp2>;
    protected q3: CommandQueue<TInp3>;
    protected q4: CommandQueue<TInp4>;
    protected q5: CommandQueue<TInp5>;
    protected q6: CommandQueue<TInp6>;
    protected f: TFunc;
    
    public constructor(q1: CommandQueue<TInp1>; q2: CommandQueue<TInp2>; q3: CommandQueue<TInp3>; q4: CommandQueue<TInp4>; q5: CommandQueue<TInp5>; q6: CommandQueue<TInp6>; f: TFunc);
    begin
      self.q1 := q1;
      self.q2 := q2;
      self.q3 := q3;
      self.q4 := q4;
      self.q5 := q5;
      self.q6 := q6;
      self.f := f;
    end;
    private constructor := raise new InvalidOperationException($'%Err:NoParamCtor%');
    
    protected function CombineQRs(qr1: QueueRes<TInp1>; qr2: QueueRes<TInp2>; qr3: QueueRes<TInp3>; qr4: QueueRes<TInp4>; qr5: QueueRes<TInp5>; qr6: QueueRes<TInp6>; ev: EventList; need_ptr_qr: boolean; c: Context): QueueRes<TRes>;
    begin
      if qr1.IsConst and qr2.IsConst and qr3.IsConst and qr4.IsConst and qr5.IsConst and qr6.IsConst then
      begin
        var res := ExecFunc(qr1.GetResImpl, qr2.GetResImpl, qr3.GetResImpl, qr4.GetResImpl, qr5.GetResImpl, qr6.GetResImpl, c);
        Result := QueueRes&<TRes>.MakeNewConstOrPtr(need_ptr_qr, ev, res);
      end else
        Result := QueueRes&<TRes>.MakeNewDelayedOrPtr(need_ptr_qr, ev);
        Result.AddResSetter(()->ExecFunc(qr1.GetResImpl, qr2.GetResImpl, qr3.GetResImpl, qr4.GetResImpl, qr5.GetResImpl, qr6.GetResImpl, c));
    end;
    
    protected function ExecFunc(o1: TInp1; o2: TInp2; o3: TInp3; o4: TInp4; o5: TInp5; o6: TInp6; c: Context): TRes; abstract;
    
    protected procedure RegisterWaitables(g: CLTaskGlobalData; prev_hubs: HashSet<IMultiusableCommandQueueHub>); override;
    begin
      self.q1.RegisterWaitables(g, prev_hubs);
      self.q2.RegisterWaitables(g, prev_hubs);
      self.q3.RegisterWaitables(g, prev_hubs);
      self.q4.RegisterWaitables(g, prev_hubs);
      self.q5.RegisterWaitables(g, prev_hubs);
      self.q6.RegisterWaitables(g, prev_hubs);
    end;
    
    private procedure ToStringImpl(sb: StringBuilder; tabs: integer; index: Dictionary<object,integer>; delayed: HashSet<CommandQueueBase>); override;
    begin
      sb += #10;
      self.q1.ToString(sb, tabs, index, delayed);
      self.q2.ToString(sb, tabs, index, delayed);
      self.q3.ToString(sb, tabs, index, delayed);
      self.q4.ToString(sb, tabs, index, delayed);
      self.q5.ToString(sb, tabs, index, delayed);
      self.q6.ToString(sb, tabs, index, delayed);
    end;
    
  end;
  
  BackgroundConvSyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, TFunc> = abstract class(BackgroundConvQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, TFunc>)
  where TFunc: Delegate;
    
    protected function InvokeSubQs(g: CLTaskGlobalData; l_nil: CLTaskLocalDataNil): QueueRes<ValueTuple<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>; override;
    begin
      var l := l_nil.WithPtrNeed(false);
      var qr1 := q1.Invoke(g, l); l.prev_ev := qr1.ThenAttachInvokeActions(g);
      var qr2 := q2.Invoke(g, l); l.prev_ev := qr2.ThenAttachInvokeActions(g);
      var qr3 := q3.Invoke(g, l); l.prev_ev := qr3.ThenAttachInvokeActions(g);
      var qr4 := q4.Invoke(g, l); l.prev_ev := qr4.ThenAttachInvokeActions(g);
      var qr5 := q5.Invoke(g, l); l.prev_ev := qr5.ThenAttachInvokeActions(g);
      var qr6 := q6.Invoke(g, l); l.prev_ev := qr6.ThenAttachInvokeActions(g);
      Result := CombineQRs(qr1, qr2, qr3, qr4, qr5, qr6, l.prev_ev);
    end;
    
  end;
  
  BackgroundConvSyncQueueArray6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes> = sealed class(BackgroundConvSyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, (TInp1, TInp2, TInp3, TInp4, TInp5, TInp6)->TRes>)
    
    protected function ExecFunc(t: ValueTuple<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>; c: Context): TRes; override := f(t.Item1, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6);
    
  end;
  BackgroundConvSyncQueueArray6C<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes> = sealed class(BackgroundConvSyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, (TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, Context)->TRes>)
    
    protected function ExecFunc(t: ValueTuple<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>; c: Context): TRes; override := f(t.Item1, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6, c);
    
  end;
  
  BackgroundConvAsyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, TFunc> = abstract class(BackgroundConvQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, TFunc>)
  where TFunc: Delegate;
    
    protected function InvokeSubQs(g: CLTaskGlobalData; l_nil: CLTaskLocalDataNil): QueueRes<ValueTuple<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>>; override;
    begin
      var l := l_nil.WithPtrNeed(false);
      if l.prev_ev.count<>0 then loop 5 do l.prev_ev.Retain({$ifdef EventDebug}'for all async branches'{$endif});
      var qr1: QueueRes<TInp1>;
      var qr2: QueueRes<TInp2>;
      var qr3: QueueRes<TInp3>;
      var qr4: QueueRes<TInp4>;
      var qr5: QueueRes<TInp5>;
      var qr6: QueueRes<TInp6>;
      g.ParallelInvoke(l, false, 6, invoker->
      begin
        qr1 := invoker.InvokeBranch(q1.Invoke);
        qr2 := invoker.InvokeBranch(q2.Invoke);
        qr3 := invoker.InvokeBranch(q3.Invoke);
        qr4 := invoker.InvokeBranch(q4.Invoke);
        qr5 := invoker.InvokeBranch(q5.Invoke);
        qr6 := invoker.InvokeBranch(q6.Invoke);
      end);
      var res_ev := EventList.Combine(|qr1.ThenAttachInvokeActions(g), qr2.ThenAttachInvokeActions(g), qr3.ThenAttachInvokeActions(g), qr4.ThenAttachInvokeActions(g), qr5.ThenAttachInvokeActions(g), qr6.ThenAttachInvokeActions(g)|);
      Result := CombineQRs(qr1, qr2, qr3, qr4, qr5, qr6, res_ev);
    end;
    
  end;
  
  BackgroundConvAsyncQueueArray6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes> = sealed class(BackgroundConvAsyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, (TInp1, TInp2, TInp3, TInp4, TInp5, TInp6)->TRes>)
    
    protected function ExecFunc(t: ValueTuple<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>; c: Context): TRes; override := f(t.Item1, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6);
    
  end;
  BackgroundConvAsyncQueueArray6C<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes> = sealed class(BackgroundConvAsyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, (TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, Context)->TRes>)
    
    protected function ExecFunc(t: ValueTuple<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6>; c: Context): TRes; override := f(t.Item1, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6, c);
    
  end;
  
  QuickConvSyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, TFunc> = abstract class(QuickConvQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, TFunc>)
  where TFunc: Delegate;
    
    protected function Invoke(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes<TRes>; override;
    begin
      var qr1 := q1.Invoke(g, l); l.prev_ev := qr1.ThenAttachInvokeActions(g);
      var qr2 := q2.Invoke(g, l); l.prev_ev := qr2.ThenAttachInvokeActions(g);
      var qr3 := q3.Invoke(g, l); l.prev_ev := qr3.ThenAttachInvokeActions(g);
      var qr4 := q4.Invoke(g, l); l.prev_ev := qr4.ThenAttachInvokeActions(g);
      var qr5 := q5.Invoke(g, l); l.prev_ev := qr5.ThenAttachInvokeActions(g);
      var qr6 := q6.Invoke(g, l); l.prev_ev := qr6.ThenAttachInvokeActions(g);
      Result := CombineQRs(qr1, qr2, qr3, qr4, qr5, qr6, l.prev_ev, l.need_ptr_qr, g.c);
    end;
    
  end;
  
  QuickConvSyncQueueArray6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes> = sealed class(QuickConvSyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, (TInp1, TInp2, TInp3, TInp4, TInp5, TInp6)->TRes>)
    
    protected function ExecFunc(o1: TInp1; o2: TInp2; o3: TInp3; o4: TInp4; o5: TInp5; o6: TInp6; c: Context): TRes; override := f(o1, o2, o3, o4, o5, o6);
    
  end;
  QuickConvSyncQueueArray6C<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes> = sealed class(QuickConvSyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, (TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, Context)->TRes>)
    
    protected function ExecFunc(o1: TInp1; o2: TInp2; o3: TInp3; o4: TInp4; o5: TInp5; o6: TInp6; c: Context): TRes; override := f(o1, o2, o3, o4, o5, o6, c);
    
  end;
  
  QuickConvAsyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, TFunc> = abstract class(QuickConvQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, TFunc>)
  where TFunc: Delegate;
    
    protected function Invoke(g: CLTaskGlobalData; l: CLTaskLocalData): QueueRes<TRes>; override;
    begin
      if l.prev_ev.count<>0 then loop 5 do l.prev_ev.Retain({$ifdef EventDebug}'for all async branches'{$endif});
      var qr1: QueueRes<TInp1>;
      var qr2: QueueRes<TInp2>;
      var qr3: QueueRes<TInp3>;
      var qr4: QueueRes<TInp4>;
      var qr5: QueueRes<TInp5>;
      var qr6: QueueRes<TInp6>;
      g.ParallelInvoke(l, false, 6, invoker->
      begin
        qr1 := invoker.InvokeBranch(q1.Invoke);
        qr2 := invoker.InvokeBranch(q2.Invoke);
        qr3 := invoker.InvokeBranch(q3.Invoke);
        qr4 := invoker.InvokeBranch(q4.Invoke);
        qr5 := invoker.InvokeBranch(q5.Invoke);
        qr6 := invoker.InvokeBranch(q6.Invoke);
      end);
      var res_ev := EventList.Combine(|qr1.ThenAttachInvokeActions(g), qr2.ThenAttachInvokeActions(g), qr3.ThenAttachInvokeActions(g), qr4.ThenAttachInvokeActions(g), qr5.ThenAttachInvokeActions(g), qr6.ThenAttachInvokeActions(g)|);
      Result := CombineQRs(qr1, qr2, qr3, qr4, qr5, qr6, res_ev, l.need_ptr_qr, g.c);
    end;
    
  end;
  
  QuickConvAsyncQueueArray6<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes> = sealed class(QuickConvAsyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, (TInp1, TInp2, TInp3, TInp4, TInp5, TInp6)->TRes>)
    
    protected function ExecFunc(o1: TInp1; o2: TInp2; o3: TInp3; o4: TInp4; o5: TInp5; o6: TInp6; c: Context): TRes; override := f(o1, o2, o3, o4, o5, o6);
    
  end;
  QuickConvAsyncQueueArray6C<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes> = sealed class(QuickConvAsyncQueueArray6Base<TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, TRes, (TInp1, TInp2, TInp3, TInp4, TInp5, TInp6, Context)->TRes>)
    
    protected function ExecFunc(o1: TInp1; o2: TInp2; o3: TInp3; o4: TInp4; o5: TInp5; o6: TInp6; c: Context): TRes; override := f(o1, o2, o3, o4, o5, o6, c);
    
  end;
  
  
  